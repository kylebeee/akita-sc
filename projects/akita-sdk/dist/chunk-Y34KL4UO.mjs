import {
  AllowanceInfoTranslate,
  AllowancesToTuple,
  ValueMap,
  domainBoxKey,
  executionBoxKey,
  forceProperties,
  getTxns
} from "./chunk-ZRCAYT2V.mjs";
import {
  BaseSDK
} from "./chunk-JXQTRU3Z.mjs";
import {
  ENV_VAR_NAMES,
  MAX_UINT64,
  emptySigner
} from "./chunk-WBPQYKCD.mjs";
import {
  hasSenderSigner,
  isPluginSDKReturn
} from "./chunk-V3TNOMIB.mjs";

// src/generated/AbstractedAccountClient.ts
import { getArc56ReturnValue, getABIStructFromABITuple } from "@algorandfoundation/algokit-utils/types/app-arc56";
import {
  AppClient as _AppClient
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC = { "name": "AbstractedAccount", "structs": { "AbstractAccountBoxMBRData": [{ "name": "plugins", "type": "uint64" }, { "name": "namedPlugins", "type": "uint64" }, { "name": "escrows", "type": "uint64" }, { "name": "allowances", "type": "uint64" }, { "name": "executions", "type": "uint64" }, { "name": "domainKeys", "type": "uint64" }, { "name": "escrowExists", "type": "bool" }, { "name": "newEscrowMintCost", "type": "uint64" }], "AllowanceInfo": [{ "name": "type", "type": "uint8" }, { "name": "max", "type": "uint64" }, { "name": "amount", "type": "uint64" }, { "name": "spent", "type": "uint64" }, { "name": "interval", "type": "uint64" }, { "name": "last", "type": "uint64" }, { "name": "start", "type": "uint64" }, { "name": "useRounds", "type": "bool" }], "AllowanceKey": [{ "name": "escrow", "type": "string" }, { "name": "asset", "type": "uint64" }], "EscrowInfo": [{ "name": "id", "type": "uint64" }, { "name": "locked", "type": "bool" }], "ExecutionInfo": [{ "name": "groups", "type": "byte[32][]" }, { "name": "firstValid", "type": "uint64" }, { "name": "lastValid", "type": "uint64" }], "PluginInfo": [{ "name": "escrow", "type": "uint64" }, { "name": "delegationType", "type": "uint8" }, { "name": "lastValid", "type": "uint64" }, { "name": "cooldown", "type": "uint64" }, { "name": "methods", "type": "(byte[4],uint64,uint64)[]" }, { "name": "admin", "type": "bool" }, { "name": "useRounds", "type": "bool" }, { "name": "useExecutionKey", "type": "bool" }, { "name": "coverFees", "type": "bool" }, { "name": "canReclaim", "type": "bool" }, { "name": "lastCalled", "type": "uint64" }, { "name": "start", "type": "uint64" }], "PluginKey": [{ "name": "plugin", "type": "uint64" }, { "name": "caller", "type": "address" }, { "name": "escrow", "type": "string" }] }, "methods": [{ "name": "create", "args": [{ "type": "string", "name": "version", "desc": "The version of the abstracted account application" }, { "type": "uint64", "name": "akitaDAO" }, { "type": "address", "name": "controlledAddress", "desc": "The address of the abstracted account. If zeroAddress, then the address of the contract account will be used" }, { "type": "address", "name": "admin", "desc": "The address of the admin for this application" }, { "type": "string", "name": "domain", "desc": "The domain associated with the admin account" }, { "type": "uint64", "name": "escrowFactory", "desc": "The app ID of the escrow factory to use for creating escrows" }, { "type": "uint64", "name": "revocationApp", "desc": "The app ID of the revocation app associated with this abstracted account" }, { "type": "string", "name": "nickname", "desc": "A user-friendly name for this abstracted account" }, { "type": "address", "name": "referrer", "desc": "The address that referred the creation of this wallet" }], "returns": { "type": "void" }, "actions": { "create": ["NoOp"], "call": [] }, "readonly": false, "desc": "Create an abstracted account application.\nThis is not part of ARC58 and implementation specific.", "events": [], "recommendations": {} }, { "name": "register", "args": [{ "type": "string", "name": "escrow", "desc": "The name of the escrow to register, or empty string for the main account" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Register the abstracted account with the escrow factory.\nThis allows apps to correlate the account with the app without needing\nit to be explicitly provided.", "events": [], "recommendations": {} }, { "name": "update", "args": [{ "type": "string", "name": "version", "desc": "the version of the wallet" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["UpdateApplication"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "setDomain", "args": [{ "type": "string", "name": "domain", "desc": "The domain to associate with the admin account" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Set the domain associated with the admin account", "events": [], "recommendations": {} }, { "name": "setRevocationApp", "args": [{ "type": "uint64", "name": "app", "desc": "The app ID of the new revocation app" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Changes the revocation app associated with the contract", "events": [], "recommendations": {} }, { "name": "setAkitaDAO", "args": [{ "type": "uint64", "name": "akitaDAO", "desc": "The app ID of the new Akita DAO" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Changes the Akita DAO associated with the contract", "events": [], "recommendations": {} }, { "name": "setNickname", "args": [{ "type": "string", "name": "nickname", "desc": "the new nickname of the wallet" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Changes the nickname of the wallet", "events": [], "recommendations": {} }, { "name": "setAvatar", "args": [{ "type": "uint64", "name": "avatar", "desc": "the new avatar of the wallet" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Changes the avatar of the wallet", "events": [], "recommendations": {} }, { "name": "setBanner", "args": [{ "type": "uint64", "name": "banner", "desc": "the new banner of the wallet" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Changes the banner of the wallet", "events": [], "recommendations": {} }, { "name": "setBio", "args": [{ "type": "string", "name": "bio", "desc": "the new bio of the wallet" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Changes the bio of the wallet", "events": [], "recommendations": {} }, { "name": "arc58_changeAdmin", "args": [{ "type": "address", "name": "newAdmin", "desc": "The new admin" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Attempt to change the admin for this app. Some implementations MAY not support this.", "events": [], "recommendations": {} }, { "name": "arc58_pluginChangeAdmin", "args": [{ "type": "address", "name": "newAdmin", "desc": "The new admin" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Attempt to change the admin via plugin.", "events": [], "recommendations": {} }, { "name": "arc58_verifyAuthAddress", "args": [], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Verify the abstracted account is rekeyed to this app", "events": [], "recommendations": {} }, { "name": "arc58_rekeyTo", "args": [{ "type": "address", "name": "address", "desc": "The address to rekey to" }, { "type": "bool", "name": "flash", "desc": "Whether or not this should be a flash rekey. If true, the rekey back to the app address must done in the same txn group as this call" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Rekey the abstracted account to another address. Primarily useful for rekeying to an EOA.", "events": [], "recommendations": {} }, { "name": "arc58_canCall", "args": [{ "type": "uint64", "name": "plugin", "desc": "The app ID of the plugin to check" }, { "type": "bool", "name": "global", "desc": "Whether to check the global (zero address) caller" }, { "type": "address", "name": "address", "desc": "The address that will trigger the plugin" }, { "type": "string", "name": "escrow", "desc": "The escrow associated with the plugin" }, { "type": "byte[4]", "name": "method", "desc": "The method selector being called on the plugin" }], "returns": { "type": "bool", "desc": "Whether the plugin can be called with these parameters" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": true, "desc": "Check whether the plugin can be used", "events": [], "recommendations": {} }, { "name": "arc58_rekeyToPlugin", "args": [{ "type": "uint64", "name": "plugin", "desc": "The app ID of the plugin to rekey to" }, { "type": "bool", "name": "global", "desc": "Whether the plugin is callable globally" }, { "type": "string", "name": "escrow", "desc": "The escrow associated with the plugin" }, { "type": "uint64[]", "name": "methodOffsets", "desc": "The indices of the methods being used in the group. If the plugin has method restrictions, these indices must match the methods used on each subsequent call to the plugin within the group" }, { "type": "(uint64,uint64)[]", "name": "fundsRequest", "desc": "If the plugin is using an escrow, this is the list of funds to transfer to the escrow for the plugin to use during execution" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Temporarily rekey to an approved plugin app address", "events": [], "recommendations": {} }, { "name": "arc58_rekeyToNamedPlugin", "args": [{ "type": "string", "name": "name", "desc": "The name of the plugin to rekey to" }, { "type": "bool", "name": "global", "desc": "Whether the plugin is callable globally" }, { "type": "string", "name": "escrow", "desc": "The escrow associated with the plugin" }, { "type": "uint64[]", "name": "methodOffsets", "desc": "The indices of the methods being used in the group. If the plugin has method restrictions, these indices must match the methods used on each subsequent call to the plugin within the group" }, { "type": "(uint64,uint64)[]", "name": "fundsRequest", "desc": "If the plugin is using an escrow, this is the list of funds to transfer to the escrow for the plugin to use during execution" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Temporarily rekey to a named plugin app address", "events": [], "recommendations": {} }, { "name": "arc58_addPlugin", "args": [{ "type": "uint64", "name": "plugin", "desc": "The app ID of the plugin to add" }, { "type": "address", "name": "caller", "desc": "The address allowed to call the plugin, or the global zero address for any address" }, { "type": "string", "name": "escrow", "desc": "The escrow account to use for the plugin, if any. If empty, no escrow will be used, if the named escrow does not exist, it will be created" }, { "type": "bool", "name": "admin", "desc": "Whether the plugin has permissions to change the admin account" }, { "type": "uint8", "name": "delegationType", "desc": "The ownership of the delegation for last_interval updates" }, { "type": "uint64", "name": "lastValid", "desc": "The timestamp or round when the permission expires" }, { "type": "uint64", "name": "cooldown", "desc": "The number of seconds or rounds that must pass before the plugin can be called again" }, { "type": "(byte[4],uint64)[]", "name": "methods", "desc": "The methods that are allowed to be called for the plugin by the address" }, { "type": "bool", "name": "useRounds", "desc": "Whether the plugin uses rounds for cooldowns and lastValid, defaults to timestamp" }, { "type": "bool", "name": "useExecutionKey", "desc": "Whether the plugin requires an execution key to be used" }, { "type": "bool", "name": "coverFees", "desc": "Whether the plugin reimburses the caller for transaction fees" }, { "type": "bool", "name": "canReclaim", "desc": "Whether the plugin is allowed to reclaim funds from escrows via arc58_pluginReclaim" }, { "type": "bool", "name": "defaultToEscrow", "desc": "Whether to use the named escrow as the default escrow (plugin key uses empty string)" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Add an app to the list of approved plugins", "events": [], "recommendations": {} }, { "name": "assignDomain", "args": [{ "type": "address", "name": "caller", "desc": "The address of the passkey" }, { "type": "string", "name": "domain", "desc": "The domain to assign to the passkey" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Assign a domain to a passkey", "events": [], "recommendations": {} }, { "name": "arc58_removePlugin", "args": [{ "type": "uint64", "name": "plugin", "desc": "The app ID of the plugin to remove" }, { "type": "address", "name": "caller", "desc": "The address that was allowed to call the plugin" }, { "type": "string", "name": "escrow", "desc": "The escrow associated with the plugin" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Remove an app from the list of approved plugins", "events": [], "recommendations": {} }, { "name": "arc58_addNamedPlugin", "args": [{ "type": "string", "name": "name", "desc": "The plugin name" }, { "type": "uint64", "name": "plugin", "desc": "The app ID of the plugin to add" }, { "type": "address", "name": "caller", "desc": "The address allowed to call the plugin, or the global zero address for any address" }, { "type": "string", "name": "escrow", "desc": "The escrow account to use for the plugin, if any. If empty, no escrow will be used, if the named escrow does not exist, it will be created" }, { "type": "bool", "name": "admin", "desc": "Whether the plugin has permissions to change the admin account" }, { "type": "uint8", "name": "delegationType", "desc": "The ownership of the delegation for last_interval updates" }, { "type": "uint64", "name": "lastValid", "desc": "The timestamp or round when the permission expires" }, { "type": "uint64", "name": "cooldown", "desc": "The number of seconds or rounds that must pass before the plugin can be called again" }, { "type": "(byte[4],uint64)[]", "name": "methods", "desc": "The methods that are allowed to be called for the plugin by the address" }, { "type": "bool", "name": "useRounds", "desc": "Whether the plugin uses rounds for cooldowns and lastValid, defaults to timestamp" }, { "type": "bool", "name": "useExecutionKey", "desc": "Whether the plugin requires an execution key to be used" }, { "type": "bool", "name": "coverFees", "desc": "Whether the plugin reimburses the caller for transaction fees" }, { "type": "bool", "name": "canReclaim", "desc": "Whether the plugin is allowed to reclaim funds from escrows via arc58_pluginReclaim" }, { "type": "bool", "name": "defaultToEscrow", "desc": "Whether to use the named escrow as the default escrow (plugin key uses empty string)" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Add a named plugin", "events": [], "recommendations": {} }, { "name": "arc58_removeNamedPlugin", "args": [{ "type": "string", "name": "name", "desc": "The plugin name" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Remove a named plugin", "events": [], "recommendations": {} }, { "name": "arc58_newEscrow", "args": [{ "type": "string", "name": "escrow", "desc": "The name of the escrow to create" }], "returns": { "type": "uint64" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Create a new escrow for the controlled address", "events": [], "recommendations": {} }, { "name": "arc58_toggleEscrowLock", "args": [{ "type": "string", "name": "escrow", "desc": "The escrow to lock or unlock" }], "returns": { "type": "(uint64,bool)", "struct": "EscrowInfo" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Lock or Unlock an escrow account", "events": [], "recommendations": {} }, { "name": "arc58_reclaim", "args": [{ "type": "string", "name": "escrow", "desc": "The escrow to reclaim funds from" }, { "type": "(uint64,uint64,bool)[]", "name": "reclaims", "desc": "The list of reclaims to make from the escrow" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Transfer funds from an escrow back to the controlled address.", "events": [], "recommendations": {} }, { "name": "arc58_pluginReclaim", "args": [{ "type": "uint64", "name": "plugin", "desc": "The plugin app ID" }, { "type": "address", "name": "caller", "desc": "The address allowed to call the plugin" }, { "type": "string", "name": "escrow", "desc": "The escrow to reclaim funds from" }, { "type": "(uint64,uint64,bool)[]", "name": "reclaims", "desc": "The list of reclaims to make from the escrow" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Transfer funds from an escrow back to the controlled address via a plugin / allowed caller.\nThe plugin must have canReclaim set to true. CloseOut on asset transfers is blocked when the escrow is locked.", "events": [], "recommendations": {} }, { "name": "arc58_optInEscrow", "args": [{ "type": "string", "name": "escrow", "desc": "The escrow to opt-in to" }, { "type": "uint64[]", "name": "assets", "desc": "The list of assets to opt-in to" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Opt-in an escrow account to assets", "events": [], "recommendations": {} }, { "name": "arc58_pluginOptInEscrow", "args": [{ "type": "uint64", "name": "plugin", "desc": "The plugin app ID" }, { "type": "address", "name": "caller", "desc": "The address allowed to call the plugin" }, { "type": "string", "name": "escrow", "desc": "The escrow to opt-in assets for" }, { "type": "uint64[]", "name": "assets", "desc": "The list of assets to opt-in to" }, { "type": "pay", "name": "mbrPayment", "desc": "The payment txn that is used to pay for the asset opt-in" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Opt-in an escrow account to assets via a plugin / allowed caller", "events": [], "recommendations": {} }, { "name": "arc58_addAllowances", "args": [{ "type": "string", "name": "escrow", "desc": "The escrow to add the allowance for" }, { "type": "(uint64,uint8,uint64,uint64,uint64,bool)[]", "name": "allowances", "desc": "The list of allowances to add" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Add an allowance for an escrow account", "events": [], "recommendations": {} }, { "name": "arc58_removeAllowances", "args": [{ "type": "string", "name": "escrow", "desc": "The escrow to remove the allowance for" }, { "type": "uint64[]", "name": "assets", "desc": "The list of assets to remove the allowance for" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Remove an allowances for an escrow account", "events": [], "recommendations": {} }, { "name": "arc58_addExecutionKey", "args": [{ "type": "byte[32]", "name": "lease", "desc": "The 32-byte lease key that uniquely identifies this execution" }, { "type": "byte[32][]", "name": "groups", "desc": "The list of 32-byte group IDs that are authorized under this key" }, { "type": "uint64", "name": "firstValid", "desc": "The first round or timestamp when this key becomes valid" }, { "type": "uint64", "name": "lastValid", "desc": "The last round or timestamp when this key expires" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Add or extend an execution key for pre-authorized plugin usage", "events": [], "recommendations": {} }, { "name": "arc58_removeExecutionKey", "args": [{ "type": "byte[32]", "name": "lease", "desc": "The 32-byte lease key identifying the execution to remove" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Remove an execution key. Can be called by admin at any time, or by anyone after the key has expired.", "events": [], "recommendations": {} }, { "name": "arc58_getAdmin", "args": [], "returns": { "type": "address" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": true, "desc": "Get the admin of this app. This method SHOULD always be used rather than reading directly from state\nbecause different implementations may have different ways of determining the admin.", "events": [], "recommendations": {} }, { "name": "arc58_getPlugins", "args": [{ "type": "(uint64,address,string)[]", "name": "keys", "desc": "The plugin keys to look up" }], "returns": { "type": "(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[]", "desc": "The plugin info for each key, or empty plugin info if the key does not exist" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": true, "desc": "Get plugin info for a list of plugin keys", "events": [], "recommendations": {} }, { "name": "arc58_getNamedPlugins", "args": [{ "type": "string[]", "name": "names", "desc": "The plugin names to look up" }], "returns": { "type": "(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[]", "desc": "The plugin info for each name, or empty plugin info if the name does not exist" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": true, "desc": "Get plugin info for a list of named plugins", "events": [], "recommendations": {} }, { "name": "arc58_getEscrows", "args": [{ "type": "string[]", "name": "escrows", "desc": "The escrow names to look up" }], "returns": { "type": "(uint64,bool)[]", "desc": "The escrow info for each name, or empty escrow info if the name does not exist" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": true, "desc": "Get escrow info for a list of escrow names", "events": [], "recommendations": {} }, { "name": "arc58_getAllowances", "args": [{ "type": "string", "name": "escrow", "desc": "The escrow to look up allowances for" }, { "type": "uint64[]", "name": "assets", "desc": "The asset IDs to look up allowances for" }], "returns": { "type": "(uint8,uint64,uint64,uint64,uint64,uint64,uint64,bool)[]", "desc": "The allowance info for each asset, or empty allowance info if no allowance exists" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": true, "desc": "Get allowance info for a list of assets on a given escrow", "events": [], "recommendations": {} }, { "name": "arc58_getExecutions", "args": [{ "type": "byte[32][]", "name": "leases", "desc": "The 32-byte lease keys to look up" }], "returns": { "type": "(byte[32][],uint64,uint64)[]", "desc": "The execution info for each lease, or empty execution info if the lease does not exist" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": true, "desc": "Get execution key info for a list of leases", "events": [], "recommendations": {} }, { "name": "arc58_getDomainKeys", "args": [{ "type": "address[]", "name": "addresses", "desc": "The addresses to look up domain keys for" }], "returns": { "type": "string[]", "desc": "The domain string for each address, or empty string if no domain is assigned" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": true, "desc": "Get domain key assignments for a list of addresses", "events": [], "recommendations": {} }, { "name": "mbr", "args": [{ "type": "string", "name": "escrow", "desc": "The escrow name to calculate MBR for" }, { "type": "uint64", "name": "methodCount", "desc": "The number of method restrictions on the plugin" }, { "type": "string", "name": "plugin", "desc": "The plugin name to calculate named plugin MBR for" }, { "type": "uint64", "name": "groups", "desc": "The number of execution groups to calculate MBR for" }], "returns": { "type": "(uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64)", "struct": "AbstractAccountBoxMBRData", "desc": "The MBR costs for plugins, named plugins, escrows, allowances, domain keys, executions, and new escrow creation" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": true, "desc": "Calculate the minimum balance requirements for various box operations", "events": [], "recommendations": {} }, { "name": "balance", "args": [{ "type": "uint64[]", "name": "assets", "desc": "The asset IDs to check balances for (0 for ALGO)" }], "returns": { "type": "uint64[]", "desc": "The balance for each asset including any staked amounts" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": true, "desc": "Get the balance of a set of assets in the account, including staked amounts", "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 9, "bytes": 9 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": { "version": { "keyType": "AVMString", "valueType": "AVMString", "key": "dmVyc2lvbg==", "desc": "the version of the wallet contract" }, "akitaDAO": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "YWtpdGFfZGFv", "desc": "the app id of the akita DAO" }, "admin": { "keyType": "AVMString", "valueType": "address", "key": "YWRtaW4=", "desc": "The admin of the abstracted account. This address can add plugins and initiate rekeys" }, "domain": { "keyType": "AVMString", "valueType": "AVMString", "key": "ZG9tYWlu", "desc": "The domain associated with the admin account of the abstracted account" }, "controlledAddress": { "keyType": "AVMString", "valueType": "address", "key": "Y29udHJvbGxlZF9hZGRyZXNz", "desc": "The address this app controls" }, "nickname": { "keyType": "AVMString", "valueType": "AVMString", "key": "bmlja25hbWU=", "desc": "A user defined nickname for their wallet" }, "avatar": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "YXZhdGFy", "desc": "A user defined NFT to display as their avatar that the user owns" }, "banner": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "YmFubmVy", "desc": "A user defined NFT to display as their banner that the user owns" }, "bio": { "keyType": "AVMString", "valueType": "AVMString", "key": "Ymlv", "desc": "A user defined description" }, "lastUserInteraction": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "bGFzdF91c2VyX2ludGVyYWN0aW9u", "desc": "The last time the contract was interacted with in unix time" }, "lastChange": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "bGFzdF9jaGFuZ2U=", "desc": "The last time state has changed on the abstracted account (not including lastCalled for cooldowns) in unix time" }, "spendingAddress": { "keyType": "AVMString", "valueType": "address", "key": "c3BlbmRpbmdfYWRkcmVzcw==", "desc": "[TEMPORARY STATE FIELD] The spending address for the currently active plugin" }, "currentPlugin": { "keyType": "AVMString", "valueType": "PluginKey", "key": "Y3VycmVudF9wbHVnaW4=", "desc": "[TEMPORARY STATE FIELD] The current plugin key being used" }, "rekeyIndex": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "cmVrZXlfaW5kZXg=", "desc": "[TEMPORARY STATE FIELD] The index of the transaction that created the rekey sandwich" }, "escrowFactory": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "ZXNjcm93X2ZhY3Rvcnk=", "desc": "the spending account factory to use for allowances" }, "factoryApp": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "ZmFjdG9yeV9hcHA=", "desc": "the application ID for the contract that deployed this wallet" }, "revocation": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "cmV2b2NhdGlvbg==", "desc": "The app that can revoke plugins" }, "referrer": { "keyType": "AVMString", "valueType": "address", "key": "cmVmZXJyZXI=", "desc": "The address that created the wallet" } }, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": { "plugins": { "keyType": "PluginKey", "valueType": "PluginInfo", "desc": "Plugins that add functionality to the controlledAddress and the account that has permission to use it.", "prefix": "cA==" }, "namedPlugins": { "keyType": "AVMString", "valueType": "PluginKey", "desc": "Plugins that have been given a name for discoverability", "prefix": "bg==" }, "escrows": { "keyType": "AVMString", "valueType": "EscrowInfo", "desc": "the escrows that this wallet has created for specific callers with allowances", "prefix": "ZQ==" }, "allowances": { "keyType": "AllowanceKey", "valueType": "AllowanceInfo", "desc": "The Allowances for plugins installed on the smart contract with useAllowance set to true", "prefix": "YQ==" }, "executions": { "keyType": "AVMBytes", "valueType": "ExecutionInfo", "desc": "execution keys", "prefix": "eA==" }, "domainKeys": { "keyType": "address", "valueType": "AVMString", "desc": "Passkeys on the account and their corresponding domain names\naddress : domain\nIMPORTANT: a passkey attached to the akita domain is a co-admin passkey\nwe explicitly have this feature so that the wallet can be used on multiple devices\nwhere the admin passkey may be incompatible\nwe track this onchain so we can assist with 'sign-in from another device' functionality\nas well as uses like DAO based domain revocation", "prefix": "ZA==" } } } }, "bareActions": { "create": [], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [6734, 6873, 6897, 6979], "errorMessage": "Allowance exceeded" }, { "pc": [3605, 4624, 4752, 4768, 4929, 5087, 5231, 5373, 5657, 5831, 6247, 6354, 6593, 6741, 6904], "errorMessage": "Box must have value" }, { "pc": [5784, 7820], "errorMessage": "Bytes has valid prefix" }, { "pc": [3333], "errorMessage": "Escrow already exists" }, { "pc": [1093, 3376, 3461, 3574, 3669, 3791, 3915, 4181], "errorMessage": "Escrow does not exist" }, { "pc": [3676, 3798, 3922, 4188], "errorMessage": "Escrow is locked" }, { "pc": [3337], "errorMessage": "Escrow name is required" }, { "pc": [7063], "errorMessage": "Execution key expired" }, { "pc": [4493, 7036], "errorMessage": "Execution key not found" }, { "pc": [7049], "errorMessage": "Execution key not ready" }, { "pc": [7124], "errorMessage": "Group not found" }, { "pc": [262], "errorMessage": "OnCompletion must be NoOp" }, { "pc": [570], "errorMessage": "OnCompletion must be UpdateApplication && can only call when not creating" }, { "pc": [2490], "errorMessage": "Only an admin can add a plugin" }, { "pc": [1255], "errorMessage": "Only an admin can change the Akita DAO" }, { "pc": [1405], "errorMessage": "Only an admin can change the admin account" }, { "pc": [1281, 1300, 1338, 1383], "errorMessage": "Only an admin can change the nickname" }, { "pc": [1236], "errorMessage": "Only an admin can change the revocation app" }, { "pc": [1186, 1217], "errorMessage": "Only an admin can update the application" }, { "pc": [4172], "errorMessage": "Only an admin or revocation app can remove method restrictions" }, { "pc": [2591, 3197], "errorMessage": "Only an admin or revocation app can remove plugins" }, { "pc": [2621, 3207, 3221, 3556, 3783, 6563, 7142], "errorMessage": "Plugin does not exist" }, { "pc": [1313, 1351], "errorMessage": "The account does not hold the asset" }, { "pc": [969], "errorMessage": "This contract must be deployed from a factory" }, { "pc": [1501], "errorMessage": "This plugin does not have admin privileges" }, { "pc": [1479], "errorMessage": "This plugin is not in control of the account" }, { "pc": [1473, 1544, 7762], "errorMessage": "account funded" }, { "pc": [1626, 2147, 2828, 3324, 3907, 4355, 4513], "errorMessage": "admin only" }, { "pc": [1457], "errorMessage": "admin plugins cannot use escrows" }, { "pc": [4059], "errorMessage": "allowance already exists" }, { "pc": [4277, 6655], "errorMessage": "allowance does not exist" }, { "pc": [1109, 1180, 1464, 1477, 3580, 3804, 5733, 5854, 6256, 6359, 6583, 6601, 7245, 7355], "errorMessage": "application exists" }, { "pc": [7435], "errorMessage": "cannot call other apps during rekey" }, { "pc": [1105, 1177, 1435, 1470, 1537, 1548, 1556, 1631, 2314, 2325, 2494, 2505, 2999, 3010, 3238, 3249, 3834, 3926, 3937, 4192, 4203, 4537, 5676, 5687, 5717, 5729, 5809, 5836, 5851, 6053, 6261, 6399, 6434, 6461, 6770, 6808, 7238, 7350, 7698, 7768, 7781], "errorMessage": "check GlobalState exists" }, { "pc": [2164, 2858], "errorMessage": "delegation type must not be self for global plugins" }, { "pc": [2447, 3151], "errorMessage": "escrow must be set if defaultToEscrow is true" }, { "pc": [4413], "errorMessage": "execution key update must match first valid" }, { "pc": [4423], "errorMessage": "execution key update must match last valid" }, { "pc": [2256, 2950, 3988, 4251, 4593, 4719, 4897, 5053, 5214, 5356, 6383, 6627, 7745], "errorMessage": "index access is out of bounds" }, { "pc": [7514], "errorMessage": "invalid method signature length" }, { "pc": [1891, 1971], "errorMessage": "invalid number of bytes for (len+(uint64,uint64)[])" }, { "pc": [3449, 3526], "errorMessage": "invalid number of bytes for (len+(uint64,uint64,bool1)[])" }, { "pc": [3903], "errorMessage": "invalid number of bytes for (len+(uint64,uint8,uint64,uint64,uint64,bool1)[])" }, { "pc": [2088, 2764], "errorMessage": "invalid number of bytes for (len+(uint8[4],uint64)[])" }, { "pc": [1875, 1955, 3656, 3742, 4158, 5030, 5594], "errorMessage": "invalid number of bytes for (len+uint64[])" }, { "pc": [4329, 5191, 5333], "errorMessage": "invalid number of bytes for (len+uint8[32][])" }, { "pc": [866, 912, 950, 1073, 1161, 1210, 1274, 1376, 1771, 1857, 1911, 1937, 2025, 2483, 2574, 2657, 2695, 3180, 3317, 3361, 3430, 3502, 3638, 3716, 3878, 4137, 5009, 5432, 5457], "errorMessage": "invalid number of bytes for (len+utf8[])" }, { "pc": [7825], "errorMessage": "invalid number of bytes for (uint64,uint64)" }, { "pc": [1620, 1745, 1842, 1922, 2036, 2096, 2107, 2118, 2129, 2140, 2707, 2772, 2784, 2796, 2808, 2820], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [877, 923, 934, 1231, 1250, 1295, 1333, 1736, 1833, 2002, 2055, 2065, 2551, 2669, 2729, 2740, 3476, 3690, 4337, 4348, 5443, 5468, 5789], "errorMessage": "invalid number of bytes for uint64" }, { "pc": [2047, 2721], "errorMessage": "invalid number of bytes for uint8" }, { "pc": [890, 899, 966, 1401, 1430, 1612, 1758, 2012, 2470, 2561, 2682, 3489, 3703, 4311, 4484], "errorMessage": "invalid number of bytes for uint8[32]" }, { "pc": [1786], "errorMessage": "invalid number of bytes for uint8[4]" }, { "pc": [7440], "errorMessage": "invalid oncomplete must be no op" }, { "pc": [3846], "errorMessage": "invalid payment" }, { "pc": [7454], "errorMessage": "invalid sender app id" }, { "pc": [7446], "errorMessage": "invalid sender must be this app id" }, { "pc": [2271, 2965], "errorMessage": "invalid size" }, { "pc": [7492], "errorMessage": "malformed method offsets" }, { "pc": [2281, 2975, 4445, 4935, 4971, 5093, 5147, 7849], "errorMessage": "max array length exceeded" }, { "pc": [7644], "errorMessage": "method on cooldown" }, { "pc": [1712, 7198], "errorMessage": "missing rekey back" }, { "pc": [3368, 3453, 3564, 3602, 3660, 3826], "errorMessage": "only the creator wallet can delete a spending account" }, { "pc": [818], "errorMessage": "overflow" }, { "pc": [2221], "errorMessage": "plugin already exists" }, { "pc": [7147, 7475], "errorMessage": "plugin expired" }, { "pc": [7151, 7478], "errorMessage": "plugin on cooldown" }, { "pc": [1466], "errorMessage": "sender must be admin plugin" }, { "pc": [3754], "errorMessage": "transaction type is pay" }, { "pc": [2180, 2874], "errorMessage": "using execution key requires global plugin" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDIgOCA0MDAgMTg5MDAgMjc3MDAKICAgIGJ5dGVjYmxvY2sgImNvbnRyb2xsZWRfYWRkcmVzcyIgIiIgImUiICJwIiAibGFzdF91c2VyX2ludGVyYWN0aW9uIiAweDE1MWY3Yzc1ICJsYXN0X2NoYW5nZSIgMHgwMDAwIDB4MDAgIngiICJzcGVuZGluZ19hZGRyZXNzIiAweDAwMmEgMHgwMDAyICJhZG1pbiIgMHgwMSAibiIgImQiIDB4MDAwYSAiYSIgInJla2V5X2luZGV4IiAiYWtpdGFfZGFvIiAiZG9tYWluIiAiZXNjcm93X2ZhY3RvcnkiICJyZXZvY2F0aW9uIiAweDAwMDEgImN1cnJlbnRfcGx1Z2luIiAweDZjYzNmNjA2ICJ2ZXJzaW9uIiAibmlja25hbWUiICJmYWN0b3J5X2FwcCIgMHgwMDJjCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYm56IG1haW5fYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE1MAogICAgLy8gcmVrZXlJbmRleCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBpbml0aWFsVmFsdWU6IDAsIGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzUmVrZXlJbmRleCB9KQogICAgYnl0ZWMgMTkgLy8gInJla2V5X2luZGV4IgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CgptYWluX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTEzLTExOQogICAgLy8gQGNvbnRyYWN0KHsKICAgIC8vICAgc3RhdGVUb3RhbHM6IHsKICAgIC8vICAgICBnbG9iYWxCeXRlczogQWJzdHJhY3RBY2NvdW50TnVtR2xvYmFsQnl0ZXMsCiAgICAvLyAgICAgZ2xvYmFsVWludHM6IEFic3RyYWN0QWNjb3VudE51bUdsb2JhbFVpbnRzCiAgICAvLyAgIH0KICAgIC8vIH0pCiAgICAvLyBleHBvcnQgY2xhc3MgQWJzdHJhY3RlZEFjY291bnQgZXh0ZW5kcyBDb250cmFjdCB7CiAgICBwdXNoYnl0ZXMgMHhlYTkxODBkZCAvLyBtZXRob2QgInVwZGF0ZShzdHJpbmcpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5fdXBkYXRlX3JvdXRlQDQKCm1haW5fc3dpdGNoX2Nhc2VfbmV4dEA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMTMtMTE5CiAgICAvLyBAY29udHJhY3QoewogICAgLy8gICBzdGF0ZVRvdGFsczogewogICAgLy8gICAgIGdsb2JhbEJ5dGVzOiBBYnN0cmFjdEFjY291bnROdW1HbG9iYWxCeXRlcywKICAgIC8vICAgICBnbG9iYWxVaW50czogQWJzdHJhY3RBY2NvdW50TnVtR2xvYmFsVWludHMKICAgIC8vICAgfQogICAgLy8gfSkKICAgIC8vIGV4cG9ydCBjbGFzcyBBYnN0cmFjdGVkQWNjb3VudCBleHRlbmRzIENvbnRyYWN0IHsKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gbXVzdCBiZSBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYnogbWFpbl9jcmVhdGVfTm9PcEA0NwogICAgcHVzaGJ5dGVzcyAweGJkNjA5OWU1IDB4Nzc4Nzg2N2QgMHgyZDc3MTFiNyAweDQwMWE2ZDgwIDB4OWY5MWNjY2QgMHgxN2Q4YmNiNCAweDM4NTY1OGFiIDB4NWVmMGI0MTUgMHhkMjRiNzU1NiAweDE0N2I2Y2Q2IC8vIG1ldGhvZCAicmVnaXN0ZXIoc3RyaW5nKXZvaWQiLCBtZXRob2QgInNldERvbWFpbihzdHJpbmcpdm9pZCIsIG1ldGhvZCAic2V0UmV2b2NhdGlvbkFwcCh1aW50NjQpdm9pZCIsIG1ldGhvZCAic2V0QWtpdGFEQU8odWludDY0KXZvaWQiLCBtZXRob2QgInNldE5pY2tuYW1lKHN0cmluZyl2b2lkIiwgbWV0aG9kICJzZXRBdmF0YXIodWludDY0KXZvaWQiLCBtZXRob2QgInNldEJhbm5lcih1aW50NjQpdm9pZCIsIG1ldGhvZCAic2V0QmlvKHN0cmluZyl2b2lkIiwgbWV0aG9kICJhcmM1OF9jaGFuZ2VBZG1pbihhZGRyZXNzKXZvaWQiLCBtZXRob2QgImFyYzU4X3BsdWdpbkNoYW5nZUFkbWluKGFkZHJlc3Mpdm9pZCIKICAgIGJ5dGVjIDI2IC8vIG1ldGhvZCAiYXJjNThfdmVyaWZ5QXV0aEFkZHJlc3MoKXZvaWQiCiAgICBwdXNoYnl0ZXNzIDB4Yzk1YTVkM2QgMHg0NzI3YWYyMSAweDU4MmZmMzgyIDB4ZGVmZDVjZDIgMHg1NjcyNDYyZSAweDU3YTUxZDg4IDB4ZWVmNDQ4ZmQgMHg1NzJmZDFlYSAweGUzNTBiOWQ0IDB4MGE4Y2IyYzIgMHgyNWI3MTNjYSAweGViYWYxNGEwIDB4NmEyMDVjZmMgMHhhZTFhNGRjYSAweDY0NGQyZGVjIDB4YmY0ZDdjNTcgMHhkNWRkMzgyYiAweDVjZWJlZDQzIDB4ZDU4Njg1YWYgMHgxM2JjNDRlNCAweDg5YTc2ODI2IDB4MDU3OTRkN2QgMHhhMjQwM2RkZiAweDAyZmU0NTE1IDB4NDFiZGM2ODAgMHg4ODJiYjFjMiAweDE3NjBjNjUyIDB4MTI0YzBhN2YgLy8gbWV0aG9kICJhcmM1OF9yZWtleVRvKGFkZHJlc3MsYm9vbCl2b2lkIiwgbWV0aG9kICJhcmM1OF9jYW5DYWxsKHVpbnQ2NCxib29sLGFkZHJlc3Msc3RyaW5nLGJ5dGVbNF0pYm9vbCIsIG1ldGhvZCAiYXJjNThfcmVrZXlUb1BsdWdpbih1aW50NjQsYm9vbCxzdHJpbmcsdWludDY0W10sKHVpbnQ2NCx1aW50NjQpW10pdm9pZCIsIG1ldGhvZCAiYXJjNThfcmVrZXlUb05hbWVkUGx1Z2luKHN0cmluZyxib29sLHN0cmluZyx1aW50NjRbXSwodWludDY0LHVpbnQ2NClbXSl2b2lkIiwgbWV0aG9kICJhcmM1OF9hZGRQbHVnaW4odWludDY0LGFkZHJlc3Msc3RyaW5nLGJvb2wsdWludDgsdWludDY0LHVpbnQ2NCwoYnl0ZVs0XSx1aW50NjQpW10sYm9vbCxib29sLGJvb2wsYm9vbCxib29sKXZvaWQiLCBtZXRob2QgImFzc2lnbkRvbWFpbihhZGRyZXNzLHN0cmluZyl2b2lkIiwgbWV0aG9kICJhcmM1OF9yZW1vdmVQbHVnaW4odWludDY0LGFkZHJlc3Msc3RyaW5nKXZvaWQiLCBtZXRob2QgImFyYzU4X2FkZE5hbWVkUGx1Z2luKHN0cmluZyx1aW50NjQsYWRkcmVzcyxzdHJpbmcsYm9vbCx1aW50OCx1aW50NjQsdWludDY0LChieXRlWzRdLHVpbnQ2NClbXSxib29sLGJvb2wsYm9vbCxib29sLGJvb2wpdm9pZCIsIG1ldGhvZCAiYXJjNThfcmVtb3ZlTmFtZWRQbHVnaW4oc3RyaW5nKXZvaWQiLCBtZXRob2QgImFyYzU4X25ld0VzY3JvdyhzdHJpbmcpdWludDY0IiwgbWV0aG9kICJhcmM1OF90b2dnbGVFc2Nyb3dMb2NrKHN0cmluZykodWludDY0LGJvb2wpIiwgbWV0aG9kICJhcmM1OF9yZWNsYWltKHN0cmluZywodWludDY0LHVpbnQ2NCxib29sKVtdKXZvaWQiLCBtZXRob2QgImFyYzU4X3BsdWdpblJlY2xhaW0odWludDY0LGFkZHJlc3Msc3RyaW5nLCh1aW50NjQsdWludDY0LGJvb2wpW10pdm9pZCIsIG1ldGhvZCAiYXJjNThfb3B0SW5Fc2Nyb3coc3RyaW5nLHVpbnQ2NFtdKXZvaWQiLCBtZXRob2QgImFyYzU4X3BsdWdpbk9wdEluRXNjcm93KHVpbnQ2NCxhZGRyZXNzLHN0cmluZyx1aW50NjRbXSxwYXkpdm9pZCIsIG1ldGhvZCAiYXJjNThfYWRkQWxsb3dhbmNlcyhzdHJpbmcsKHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0LHVpbnQ2NCxib29sKVtdKXZvaWQiLCBtZXRob2QgImFyYzU4X3JlbW92ZUFsbG93YW5jZXMoc3RyaW5nLHVpbnQ2NFtdKXZvaWQiLCBtZXRob2QgImFyYzU4X2FkZEV4ZWN1dGlvbktleShieXRlWzMyXSxieXRlWzMyXVtdLHVpbnQ2NCx1aW50NjQpdm9pZCIsIG1ldGhvZCAiYXJjNThfcmVtb3ZlRXhlY3V0aW9uS2V5KGJ5dGVbMzJdKXZvaWQiLCBtZXRob2QgImFyYzU4X2dldEFkbWluKClhZGRyZXNzIiwgbWV0aG9kICJhcmM1OF9nZXRQbHVnaW5zKCh1aW50NjQsYWRkcmVzcyxzdHJpbmcpW10pKHVpbnQ2NCx1aW50OCx1aW50NjQsdWludDY0LChieXRlWzRdLHVpbnQ2NCx1aW50NjQpW10sYm9vbCxib29sLGJvb2wsYm9vbCxib29sLHVpbnQ2NCx1aW50NjQpW10iLCBtZXRob2QgImFyYzU4X2dldE5hbWVkUGx1Z2lucyhzdHJpbmdbXSkodWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQsKGJ5dGVbNF0sdWludDY0LHVpbnQ2NClbXSxib29sLGJvb2wsYm9vbCxib29sLGJvb2wsdWludDY0LHVpbnQ2NClbXSIsIG1ldGhvZCAiYXJjNThfZ2V0RXNjcm93cyhzdHJpbmdbXSkodWludDY0LGJvb2wpW10iLCBtZXRob2QgImFyYzU4X2dldEFsbG93YW5jZXMoc3RyaW5nLHVpbnQ2NFtdKSh1aW50OCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCxib29sKVtdIiwgbWV0aG9kICJhcmM1OF9nZXRFeGVjdXRpb25zKGJ5dGVbMzJdW10pKGJ5dGVbMzJdW10sdWludDY0LHVpbnQ2NClbXSIsIG1ldGhvZCAiYXJjNThfZ2V0RG9tYWluS2V5cyhhZGRyZXNzW10pc3RyaW5nW10iLCBtZXRob2QgIm1icihzdHJpbmcsdWludDY0LHN0cmluZyx1aW50NjQpKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LGJvb2wsdWludDY0KSIsIG1ldGhvZCAiYmFsYW5jZSh1aW50NjRbXSl1aW50NjRbXSIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIHJlZ2lzdGVyIHNldERvbWFpbiBzZXRSZXZvY2F0aW9uQXBwIHNldEFraXRhREFPIHNldE5pY2tuYW1lIHNldEF2YXRhciBzZXRCYW5uZXIgc2V0QmlvIGFyYzU4X2NoYW5nZUFkbWluIGFyYzU4X3BsdWdpbkNoYW5nZUFkbWluIGFyYzU4X3ZlcmlmeUF1dGhBZGRyZXNzIGFyYzU4X3Jla2V5VG8gYXJjNThfY2FuQ2FsbCBhcmM1OF9yZWtleVRvUGx1Z2luIGFyYzU4X3Jla2V5VG9OYW1lZFBsdWdpbiBhcmM1OF9hZGRQbHVnaW4gYXNzaWduRG9tYWluIGFyYzU4X3JlbW92ZVBsdWdpbiBhcmM1OF9hZGROYW1lZFBsdWdpbiBhcmM1OF9yZW1vdmVOYW1lZFBsdWdpbiBhcmM1OF9uZXdFc2Nyb3cgYXJjNThfdG9nZ2xlRXNjcm93TG9jayBhcmM1OF9yZWNsYWltIGFyYzU4X3BsdWdpblJlY2xhaW0gYXJjNThfb3B0SW5Fc2Nyb3cgYXJjNThfcGx1Z2luT3B0SW5Fc2Nyb3cgYXJjNThfYWRkQWxsb3dhbmNlcyBhcmM1OF9yZW1vdmVBbGxvd2FuY2VzIGFyYzU4X2FkZEV4ZWN1dGlvbktleSBhcmM1OF9yZW1vdmVFeGVjdXRpb25LZXkgYXJjNThfZ2V0QWRtaW4gYXJjNThfZ2V0UGx1Z2lucyBhcmM1OF9nZXROYW1lZFBsdWdpbnMgYXJjNThfZ2V0RXNjcm93cyBhcmM1OF9nZXRBbGxvd2FuY2VzIGFyYzU4X2dldEV4ZWN1dGlvbnMgYXJjNThfZ2V0RG9tYWluS2V5cyBtYnIgYmFsYW5jZQogICAgZXJyCgptYWluX2NyZWF0ZV9Ob09wQDQ3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMTMtMTE5CiAgICAvLyBAY29udHJhY3QoewogICAgLy8gICBzdGF0ZVRvdGFsczogewogICAgLy8gICAgIGdsb2JhbEJ5dGVzOiBBYnN0cmFjdEFjY291bnROdW1HbG9iYWxCeXRlcywKICAgIC8vICAgICBnbG9iYWxVaW50czogQWJzdHJhY3RBY2NvdW50TnVtR2xvYmFsVWludHMKICAgIC8vICAgfQogICAgLy8gfSkKICAgIC8vIGV4cG9ydCBjbGFzcyBBYnN0cmFjdGVkQWNjb3VudCBleHRlbmRzIENvbnRyYWN0IHsKICAgIHB1c2hieXRlcyAweGEzZGJkMzc3IC8vIG1ldGhvZCAiY3JlYXRlKHN0cmluZyx1aW50NjQsYWRkcmVzcyxhZGRyZXNzLHN0cmluZyx1aW50NjQsdWludDY0LHN0cmluZyxhZGRyZXNzKXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBjcmVhdGUKICAgIGVycgoKbWFpbl91cGRhdGVfcm91dGVANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Njg4CiAgICAvLyBAYWJpbWV0aG9kKHsgYWxsb3dBY3Rpb25zOiBbJ1VwZGF0ZUFwcGxpY2F0aW9uJ10gfSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIHB1c2hpbnQgNCAvLyBVcGRhdGVBcHBsaWNhdGlvbgogICAgPT0KICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAmJgogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIFVwZGF0ZUFwcGxpY2F0aW9uICYmIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGIgdXBkYXRlCgoKLy8gX3B1eWFfbGliLmFyYzQuZHluYW1pY19hcnJheV9jb25jYXRfYnl0ZV9sZW5ndGhfaGVhZChhcnJheTogYnl0ZXMsIG5ld19pdGVtc19ieXRlczogYnl0ZXMsIG5ld19pdGVtc19jb3VudDogdWludDY0KSAtPiBieXRlczoKZHluYW1pY19hcnJheV9jb25jYXRfYnl0ZV9sZW5ndGhfaGVhZDoKICAgIHByb3RvIDMgMQogICAgZnJhbWVfZGlnIC0zCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGR1cAogICAgZnJhbWVfZGlnIC0xCiAgICArCiAgICBzd2FwCiAgICBpbnRjXzIgLy8gMgogICAgKgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgY292ZXIgMgogICAgZnJhbWVfZGlnIC0zCiAgICBpbnRjXzIgLy8gMgogICAgZGlnIDIKICAgIHN1YnN0cmluZzMKICAgIGZyYW1lX2RpZyAtMQogICAgaW50Y18yIC8vIDIKICAgICoKICAgIGJ6ZXJvCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAtMwogICAgbGVuCiAgICBmcmFtZV9kaWcgLTMKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciAyCiAgICBzdWJzdHJpbmczCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAtMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBpbnRjXzIgLy8gMgogICAgKgogICAgZHVwCiAgICBpbnRjXzAgLy8gMAoKZHluYW1pY19hcnJheV9jb25jYXRfYnl0ZV9sZW5ndGhfaGVhZF9mb3JfaGVhZGVyQDI6CiAgICBmcmFtZV9kaWcgNAogICAgZnJhbWVfZGlnIDIKICAgIDwKICAgIGJ6IGR5bmFtaWNfYXJyYXlfY29uY2F0X2J5dGVfbGVuZ3RoX2hlYWRfYWZ0ZXJfZm9yQDQKICAgIGZyYW1lX2RpZyAzCiAgICBkdXAKICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBmcmFtZV9kaWcgMQogICAgZnJhbWVfZGlnIDQKICAgIGR1cAogICAgY292ZXIgNAogICAgdW5jb3ZlciAyCiAgICByZXBsYWNlMwogICAgZHVwCiAgICBmcmFtZV9idXJ5IDEKICAgIGRpZyAxCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18yIC8vIDIKICAgICsKICAgICsKICAgIGZyYW1lX2J1cnkgMwogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGZyYW1lX2J1cnkgNAogICAgYiBkeW5hbWljX2FycmF5X2NvbmNhdF9ieXRlX2xlbmd0aF9oZWFkX2Zvcl9oZWFkZXJAMgoKZHluYW1pY19hcnJheV9jb25jYXRfYnl0ZV9sZW5ndGhfaGVhZF9hZnRlcl9mb3JANDoKICAgIGZyYW1lX2RpZyAwCiAgICBmcmFtZV9kaWcgMQogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKCi8vIF9wdXlhX2xpYi5hcmM0LmR5bmFtaWNfYXJyYXlfY29uY2F0X2R5bmFtaWNfZWxlbWVudChhcnJheV9pdGVtc19jb3VudDogdWludDY0LCBhcnJheV9oZWFkX2FuZF90YWlsOiBieXRlcywgbmV3X2l0ZW1zX2NvdW50OiB1aW50NjQsIG5ld19oZWFkX2FuZF90YWlsOiBieXRlcykgLT4gYnl0ZXM6CmR5bmFtaWNfYXJyYXlfY29uY2F0X2R5bmFtaWNfZWxlbWVudDoKICAgIHByb3RvIDQgMQogICAgYnl0ZWNfMSAvLyAiIgogICAgZHVwCiAgICBmcmFtZV9kaWcgLTIKICAgIGludGNfMiAvLyAyCiAgICAqCiAgICBmcmFtZV9kaWcgLTQKICAgIGludGNfMiAvLyAyCiAgICAqCiAgICBpbnRjXzAgLy8gMAoKZHluYW1pY19hcnJheV9jb25jYXRfZHluYW1pY19lbGVtZW50X2Zvcl9oZWFkZXJAMToKICAgIGZyYW1lX2RpZyA0CiAgICBmcmFtZV9kaWcgMwogICAgPAogICAgYnogZHluYW1pY19hcnJheV9jb25jYXRfZHluYW1pY19lbGVtZW50X2FmdGVyX2ZvckA0CiAgICBmcmFtZV9kaWcgLTMKICAgIGZyYW1lX2RpZyA0CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGV4dHJhY3RfdWludDE2CiAgICBmcmFtZV9kaWcgMgogICAgKwogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIGZyYW1lX2RpZyAxCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGZyYW1lX2J1cnkgMQogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGZyYW1lX2J1cnkgNAogICAgYiBkeW5hbWljX2FycmF5X2NvbmNhdF9keW5hbWljX2VsZW1lbnRfZm9yX2hlYWRlckAxCgpkeW5hbWljX2FycmF5X2NvbmNhdF9keW5hbWljX2VsZW1lbnRfYWZ0ZXJfZm9yQDQ6CiAgICBmcmFtZV9kaWcgLTMKICAgIGxlbgogICAgZnJhbWVfYnVyeSAwCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSA0CgpkeW5hbWljX2FycmF5X2NvbmNhdF9keW5hbWljX2VsZW1lbnRfZm9yX2hlYWRlckA1OgogICAgZnJhbWVfZGlnIDQKICAgIGZyYW1lX2RpZyAyCiAgICA8CiAgICBieiBkeW5hbWljX2FycmF5X2NvbmNhdF9keW5hbWljX2VsZW1lbnRfYWZ0ZXJfZm9yQDgKICAgIGZyYW1lX2RpZyAtMQogICAgZnJhbWVfZGlnIDQKICAgIGR1cAogICAgY292ZXIgMgogICAgZXh0cmFjdF91aW50MTYKICAgIGZyYW1lX2RpZyAwCiAgICArCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgZnJhbWVfZGlnIDEKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZnJhbWVfYnVyeSAxCiAgICBpbnRjXzIgLy8gMgogICAgKwogICAgZnJhbWVfYnVyeSA0CiAgICBiIGR5bmFtaWNfYXJyYXlfY29uY2F0X2R5bmFtaWNfZWxlbWVudF9mb3JfaGVhZGVyQDUKCmR5bmFtaWNfYXJyYXlfY29uY2F0X2R5bmFtaWNfZWxlbWVudF9hZnRlcl9mb3JAODoKICAgIGZyYW1lX2RpZyAtNAogICAgZnJhbWVfZGlnIC0yCiAgICArCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgZnJhbWVfZGlnIDEKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIC0zCiAgICBmcmFtZV9kaWcgMwogICAgZnJhbWVfZGlnIDAKICAgIHN1YnN0cmluZzMKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIC0xCiAgICBsZW4KICAgIGZyYW1lX2RpZyAtMQogICAgZnJhbWVfZGlnIDIKICAgIHVuY292ZXIgMgogICAgc3Vic3RyaW5nMwogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9iYXNlLnRzOjp1aW50OCh2OiB1aW50NjQpIC0+IGJ5dGVzOgp1aW50ODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy90eXBlcy9iYXNlLnRzOjMKICAgIC8vIGV4cG9ydCBmdW5jdGlvbiB1aW50OCh2OiB1aW50NjQpIHsKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL3R5cGVzL2Jhc2UudHM6NAogICAgLy8gcmV0dXJuIG5ldyBhcmM0LlVpbnQ4KHYpCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBpbnRjXzMgLy8gOAogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgZXh0cmFjdCA3IDEKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L3V0aWxzLnRzOjplbXB0eVBsdWdpbkluZm8oKSAtPiBieXRlczoKZW1wdHlQbHVnaW5JbmZvOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvdXRpbHMudHM6NwogICAgLy8gZGVsZWdhdGlvblR5cGU6IHVpbnQ4KDApLAogICAgaW50Y18wIC8vIDAKICAgIGNhbGxzdWIgdWludDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L3V0aWxzLnRzOjEwCiAgICAvLyBtZXRob2RzOiBbXSwKICAgIGludGNfMCAvLyAwCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC91dGlscy50czo1LTE4CiAgICAvLyByZXR1cm4gewogICAgLy8gICBlc2Nyb3c6IDAsCiAgICAvLyAgIGRlbGVnYXRpb25UeXBlOiB1aW50OCgwKSwKICAgIC8vICAgbGFzdFZhbGlkOiAwLAogICAgLy8gICBjb29sZG93bjogMCwKICAgIC8vICAgbWV0aG9kczogW10sCiAgICAvLyAgIGFkbWluOiBmYWxzZSwKICAgIC8vICAgdXNlUm91bmRzOiBmYWxzZSwKICAgIC8vICAgdXNlRXhlY3V0aW9uS2V5OiBmYWxzZSwKICAgIC8vICAgY292ZXJGZWVzOiBmYWxzZSwKICAgIC8vICAgY2FuUmVjbGFpbTogZmFsc2UsCiAgICAvLyAgIGxhc3RDYWxsZWQ6IDAsCiAgICAvLyAgIHN0YXJ0OiAwLAogICAgLy8gfTsKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIHB1c2hieXRlcyAweDAwMmMwMAogICAgY29uY2F0CiAgICBkaWcgMQogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L3V0aWxzLnRzOjEwCiAgICAvLyBtZXRob2RzOiBbXSwKICAgIGJ5dGVjIDcgLy8gMHgwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC91dGlscy50czo1LTE4CiAgICAvLyByZXR1cm4gewogICAgLy8gICBlc2Nyb3c6IDAsCiAgICAvLyAgIGRlbGVnYXRpb25UeXBlOiB1aW50OCgwKSwKICAgIC8vICAgbGFzdFZhbGlkOiAwLAogICAgLy8gICBjb29sZG93bjogMCwKICAgIC8vICAgbWV0aG9kczogW10sCiAgICAvLyAgIGFkbWluOiBmYWxzZSwKICAgIC8vICAgdXNlUm91bmRzOiBmYWxzZSwKICAgIC8vICAgdXNlRXhlY3V0aW9uS2V5OiBmYWxzZSwKICAgIC8vICAgY292ZXJGZWVzOiBmYWxzZSwKICAgIC8vICAgY2FuUmVjbGFpbTogZmFsc2UsCiAgICAvLyAgIGxhc3RDYWxsZWQ6IDAsCiAgICAvLyAgIHN0YXJ0OiAwLAogICAgLy8gfTsKICAgIGNvbmNhdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuY3JlYXRlW3JvdXRpbmddKCkgLT4gdm9pZDoKY3JlYXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo2MjcKICAgIC8vIEBhYmltZXRob2QoeyBvbkNyZWF0ZTogJ3JlcXVpcmUnIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1dGY4W10pCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGNvdmVyIDUKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDcKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBjb3ZlciA1CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA4CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIGNvdmVyIDUKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDkKICAgIGR1cAogICAgY292ZXIgNgogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NjM5CiAgICAvLyBhc3NlcnQoR2xvYmFsLmNhbGxlckFwcGxpY2F0aW9uSWQgIT09IDAsIEVSUl9CQURfREVQTE9ZRVIpCiAgICBnbG9iYWwgQ2FsbGVyQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIFRoaXMgY29udHJhY3QgbXVzdCBiZSBkZXBsb3llZCBmcm9tIGEgZmFjdG9yeQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo2NDAKICAgIC8vIGFzc2VydChhZG1pbiAhPT0gY29udHJvbGxlZEFkZHJlc3MpCiAgICBkaWcgMQogICAgZGlnIDMKICAgICE9CiAgICBhc3NlcnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTI0CiAgICAvLyB2ZXJzaW9uID0gR2xvYmFsU3RhdGU8c3RyaW5nPih7IGtleTogR2xvYmFsU3RhdGVLZXlWZXJzaW9uIH0pCiAgICBieXRlYyAyNyAvLyAidmVyc2lvbiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NjQyCiAgICAvLyB0aGlzLnZlcnNpb24udmFsdWUgPSB2ZXJzaW9uCiAgICB1bmNvdmVyIDUKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyNgogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjIDIwIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjY0MwogICAgLy8gdGhpcy5ha2l0YURBTy52YWx1ZSA9IEFwcGxpY2F0aW9uKGFraXRhREFPKQogICAgdW5jb3ZlciA0CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMjgKICAgIC8vIGFkbWluID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0FkbWluIH0pCiAgICBieXRlYyAxMyAvLyAiYWRtaW4iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjY0NAogICAgLy8gdGhpcy5hZG1pbi52YWx1ZSA9IGFkbWluCiAgICB1bmNvdmVyIDIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMAogICAgLy8gZG9tYWluID0gR2xvYmFsU3RhdGU8c3RyaW5nPih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzRG9tYWluIH0pOwogICAgYnl0ZWMgMjEgLy8gImRvbWFpbiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NjQ1CiAgICAvLyB0aGlzLmRvbWFpbi52YWx1ZSA9IGRvbWFpbgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NjQ3CiAgICAvLyBjb250cm9sbGVkQWRkcmVzcyA9PT0gR2xvYmFsLnplcm9BZGRyZXNzCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjY0Ny02NDkKICAgIC8vIGNvbnRyb2xsZWRBZGRyZXNzID09PSBHbG9iYWwuemVyb0FkZHJlc3MKICAgIC8vICAgPyBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gICA6IGNvbnRyb2xsZWRBZGRyZXNzCiAgICBieiBjcmVhdGVfdGVybmFyeV9mYWxzZUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjY0OAogICAgLy8gPyBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCmNyZWF0ZV90ZXJuYXJ5X21lcmdlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMgogICAgLy8gY29udHJvbGxlZEFkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MgfSk7CiAgICBieXRlY18wIC8vICJjb250cm9sbGVkX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjY0Ni02NDkKICAgIC8vIHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUgPQogICAgLy8gICBjb250cm9sbGVkQWRkcmVzcyA9PT0gR2xvYmFsLnplcm9BZGRyZXNzCiAgICAvLyAgICAgPyBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gICAgIDogY29udHJvbGxlZEFkZHJlc3MKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE1MgogICAgLy8gZXNjcm93RmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzRXNjcm93RmFjdG9yeSB9KQogICAgYnl0ZWMgMjIgLy8gImVzY3Jvd19mYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo2NTAKICAgIC8vIHRoaXMuZXNjcm93RmFjdG9yeS52YWx1ZSA9IEFwcGxpY2F0aW9uKGVzY3Jvd0ZhY3RvcnkpCiAgICBkaWcgNAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQ2CiAgICAvLyBzcGVuZGluZ0FkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzIH0pCiAgICBieXRlYyAxMCAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NjUxCiAgICAvLyB0aGlzLnNwZW5kaW5nQWRkcmVzcy52YWx1ZSA9IEdsb2JhbC56ZXJvQWRkcmVzczsKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU2CiAgICAvLyByZXZvY2F0aW9uID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleVJldm9jYXRpb24gfSkKICAgIGJ5dGVjIDIzIC8vICJyZXZvY2F0aW9uIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo2NTIKICAgIC8vIHRoaXMucmV2b2NhdGlvbi52YWx1ZSA9IEFwcGxpY2F0aW9uKHJldm9jYXRpb25BcHApCiAgICBkaWcgMwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTM0CiAgICAvLyBuaWNrbmFtZSA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c05pY2tuYW1lIH0pCiAgICBieXRlYyAyOCAvLyAibmlja25hbWUiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjY1MwogICAgLy8gdGhpcy5uaWNrbmFtZS52YWx1ZSA9IG5pY2tuYW1lCiAgICBkaWcgMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU0CiAgICAvLyBmYWN0b3J5QXBwID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNGYWN0b3J5QXBwIH0pCiAgICBieXRlYyAyOSAvLyAiZmFjdG9yeV9hcHAiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjY1NAogICAgLy8gdGhpcy5mYWN0b3J5QXBwLnZhbHVlID0gQXBwbGljYXRpb24oR2xvYmFsLmNhbGxlckFwcGxpY2F0aW9uSWQpCiAgICBnbG9iYWwgQ2FsbGVyQXBwbGljYXRpb25JRAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU4CiAgICAvLyByZWZlcnJlciA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNSZWZlcnJlciB9KQogICAgcHVzaGJ5dGVzICJyZWZlcnJlciIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NjU1CiAgICAvLyB0aGlzLnJlZmVycmVyLnZhbHVlID0gcmVmZXJyZXIKICAgIGRpZyAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDIKICAgIC8vIGxhc3RVc2VySW50ZXJhY3Rpb24gPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNMYXN0VXNlckludGVyYWN0aW9uIH0pCiAgICBieXRlYyA0IC8vICJsYXN0X3VzZXJfaW50ZXJhY3Rpb24iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE4NwogICAgLy8gdGhpcy5sYXN0VXNlckludGVyYWN0aW9uLnZhbHVlID0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQ0CiAgICAvLyBsYXN0Q2hhbmdlID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzTGFzdENoYW5nZSB9KQogICAgYnl0ZWMgNiAvLyAibGFzdF9jaGFuZ2UiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE5MQogICAgLy8gdGhpcy5sYXN0Q2hhbmdlLnZhbHVlID0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NjI3CiAgICAvLyBAYWJpbWV0aG9kKHsgb25DcmVhdGU6ICdyZXF1aXJlJyB9KQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKY3JlYXRlX3Rlcm5hcnlfZmFsc2VAMzoKICAgIGRpZyA0CiAgICBiIGNyZWF0ZV90ZXJuYXJ5X21lcmdlQDQKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5yZWdpc3Rlcltyb3V0aW5nXSgpIC0+IHZvaWQ6CnJlZ2lzdGVyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo2NjgKICAgIC8vIHJlZ2lzdGVyKGVzY3Jvdzogc3RyaW5nKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo2NjkKICAgIC8vIGxldCBhcHA6IHVpbnQ2NCA9IDAKICAgIGludGNfMCAvLyAwCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjY3MAogICAgLy8gaWYgKGVzY3JvdyAhPT0gJycpIHsKICAgIGJ5dGVjXzEgLy8gIiIKICAgICE9CiAgICBieiByZWdpc3Rlcl9hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTY3CiAgICAvLyBlc2Nyb3dzID0gQm94TWFwPHN0cmluZywgRXNjcm93SW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeEVzY3Jvd3MgfSkKICAgIGJ5dGVjXzIgLy8gImUiCiAgICBkaWcgMgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjY3MQogICAgLy8gYXNzZXJ0KHRoaXMuZXNjcm93cyhlc2Nyb3cpLmV4aXN0cywgRVJSX0VTQ1JPV19ET0VTX05PVF9FWElTVCkKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gRXNjcm93IGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjY3MgogICAgLy8gYXBwID0gdGhpcy5lc2Nyb3dzKGVzY3JvdykudmFsdWUuaWQKICAgIGJveF9nZXQKICAgIHBvcAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBidXJ5IDEKCnJlZ2lzdGVyX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Njc1LTY4NAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgRXNjcm93RmFjdG9yeS5wcm90b3R5cGUucmVnaXN0ZXI+KHsKICAgIC8vICAgYXBwSWQ6IHRoaXMuZXNjcm93RmFjdG9yeS52YWx1ZSwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICByZWNlaXZlcjogdGhpcy5lc2Nyb3dGYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IEFSQzU4V2FsbGV0SURzQnlBY2NvdW50c01icgogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGFwcAogICAgLy8gICBdCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo2NzkKICAgIC8vIHJlY2VpdmVyOiB0aGlzLmVzY3Jvd0ZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE1MgogICAgLy8gZXNjcm93RmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzRXNjcm93RmFjdG9yeSB9KQogICAgYnl0ZWMgMjIgLy8gImVzY3Jvd19mYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo2NzkKICAgIC8vIHJlY2VpdmVyOiB0aGlzLmVzY3Jvd0ZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NjgwCiAgICAvLyBhbW91bnQ6IEFSQzU4V2FsbGV0SURzQnlBY2NvdW50c01icgogICAgcHVzaGludCAxMjEwMCAvLyAxMjEwMAogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Njc4LTY4MQogICAgLy8gaXR4bi5wYXltZW50KHsKICAgIC8vICAgcmVjZWl2ZXI6IHRoaXMuZXNjcm93RmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IEFSQzU4V2FsbGV0SURzQnlBY2NvdW50c01icgogICAgLy8gfSksCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjY3NS02ODQKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEVzY3Jvd0ZhY3RvcnkucHJvdG90eXBlLnJlZ2lzdGVyPih7CiAgICAvLyAgIGFwcElkOiB0aGlzLmVzY3Jvd0ZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgcmVjZWl2ZXI6IHRoaXMuZXNjcm93RmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBBUkM1OFdhbGxldElEc0J5QWNjb3VudHNNYnIKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBhcHAKICAgIC8vICAgXQogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo2ODIKICAgIC8vIGFwcAogICAgZGlnIDEKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Njc1LTY4NAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgRXNjcm93RmFjdG9yeS5wcm90b3R5cGUucmVnaXN0ZXI+KHsKICAgIC8vICAgYXBwSWQ6IHRoaXMuZXNjcm93RmFjdG9yeS52YWx1ZSwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICByZWNlaXZlcjogdGhpcy5lc2Nyb3dGYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IEFSQzU4V2FsbGV0SURzQnlBY2NvdW50c01icgogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGFwcAogICAgLy8gICBdCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4NjA3ZTcwNDYgLy8gbWV0aG9kICJyZWdpc3RlcihwYXksdWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NjY4CiAgICAvLyByZWdpc3Rlcihlc2Nyb3c6IHN0cmluZyk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LnVwZGF0ZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CnVwZGF0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Njg4CiAgICAvLyBAYWJpbWV0aG9kKHsgYWxsb3dBY3Rpb25zOiBbJ1VwZGF0ZUFwcGxpY2F0aW9uJ10gfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1dGY4W10pCiAgICBleHRyYWN0IDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo2OTAKICAgIC8vIGFzc2VydCh0aGlzLmlzQWRtaW4oKSB8fCBUeG4uc2VuZGVyID09PSB0aGlzLmZhY3RvcnlBcHAudmFsdWUuYWRkcmVzcywgRVJSX09OTFlfQURNSU5fQ0FOX1VQREFURSkKICAgIGNhbGxzdWIgaXNBZG1pbgogICAgYm56IHVwZGF0ZV9ib29sX3RydWVAMwogICAgdHhuIFNlbmRlcgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU0CiAgICAvLyBmYWN0b3J5QXBwID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNGYWN0b3J5QXBwIH0pCiAgICBieXRlYyAyOSAvLyAiZmFjdG9yeV9hcHAiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjY5MAogICAgLy8gYXNzZXJ0KHRoaXMuaXNBZG1pbigpIHx8IFR4bi5zZW5kZXIgPT09IHRoaXMuZmFjdG9yeUFwcC52YWx1ZS5hZGRyZXNzLCBFUlJfT05MWV9BRE1JTl9DQU5fVVBEQVRFKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBieiB1cGRhdGVfYm9vbF9mYWxzZUA0Cgp1cGRhdGVfYm9vbF90cnVlQDM6CiAgICBpbnRjXzEgLy8gMQoKdXBkYXRlX2Jvb2xfbWVyZ2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NjkwCiAgICAvLyBhc3NlcnQodGhpcy5pc0FkbWluKCkgfHwgVHhuLnNlbmRlciA9PT0gdGhpcy5mYWN0b3J5QXBwLnZhbHVlLmFkZHJlc3MsIEVSUl9PTkxZX0FETUlOX0NBTl9VUERBVEUpCiAgICBhc3NlcnQgLy8gT25seSBhbiBhZG1pbiBjYW4gdXBkYXRlIHRoZSBhcHBsaWNhdGlvbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMjQKICAgIC8vIHZlcnNpb24gPSBHbG9iYWxTdGF0ZTxzdHJpbmc+KHsga2V5OiBHbG9iYWxTdGF0ZUtleVZlcnNpb24gfSkKICAgIGJ5dGVjIDI3IC8vICJ2ZXJzaW9uIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo2OTEKICAgIC8vIHRoaXMudmVyc2lvbi52YWx1ZSA9IHZlcnNpb24KICAgIGRpZyAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo2ODgKICAgIC8vIEBhYmltZXRob2QoeyBhbGxvd0FjdGlvbnM6IFsnVXBkYXRlQXBwbGljYXRpb24nXSB9KQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKdXBkYXRlX2Jvb2xfZmFsc2VANDoKICAgIGludGNfMCAvLyAwCiAgICBiIHVwZGF0ZV9ib29sX21lcmdlQDUKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5zZXREb21haW5bcm91dGluZ10oKSAtPiB2b2lkOgpzZXREb21haW46CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjcwMQogICAgLy8gc2V0RG9tYWluKGRvbWFpbjogc3RyaW5nKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NzAyCiAgICAvLyBhc3NlcnQodGhpcy5pc0FkbWluKCksIEVSUl9PTkxZX0FETUlOX0NBTl9VUERBVEUpCiAgICBjYWxsc3ViIGlzQWRtaW4KICAgIGFzc2VydCAvLyBPbmx5IGFuIGFkbWluIGNhbiB1cGRhdGUgdGhlIGFwcGxpY2F0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMAogICAgLy8gZG9tYWluID0gR2xvYmFsU3RhdGU8c3RyaW5nPih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzRG9tYWluIH0pOwogICAgYnl0ZWMgMjEgLy8gImRvbWFpbiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NzAzCiAgICAvLyB0aGlzLmRvbWFpbi52YWx1ZSA9IGRvbWFpbgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NzAxCiAgICAvLyBzZXREb21haW4oZG9tYWluOiBzdHJpbmcpOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5zZXRSZXZvY2F0aW9uQXBwW3JvdXRpbmddKCkgLT4gdm9pZDoKc2V0UmV2b2NhdGlvbkFwcDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NzExCiAgICAvLyBzZXRSZXZvY2F0aW9uQXBwKGFwcDogdWludDY0KTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo3MTIKICAgIC8vIGFzc2VydCh0aGlzLmlzQWRtaW4oKSwgRVJSX09OTFlfQURNSU5fQ0FOX0NIQU5HRV9SRVZPS0UpCiAgICBjYWxsc3ViIGlzQWRtaW4KICAgIGFzc2VydCAvLyBPbmx5IGFuIGFkbWluIGNhbiBjaGFuZ2UgdGhlIHJldm9jYXRpb24gYXBwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE1NgogICAgLy8gcmV2b2NhdGlvbiA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlSZXZvY2F0aW9uIH0pCiAgICBieXRlYyAyMyAvLyAicmV2b2NhdGlvbiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NzEzCiAgICAvLyB0aGlzLnJldm9jYXRpb24udmFsdWUgPSBBcHBsaWNhdGlvbihhcHApCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo3MTEKICAgIC8vIHNldFJldm9jYXRpb25BcHAoYXBwOiB1aW50NjQpOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5zZXRBa2l0YURBT1tyb3V0aW5nXSgpIC0+IHZvaWQ6CnNldEFraXRhREFPOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo3MjEKICAgIC8vIHNldEFraXRhREFPKGFraXRhREFPOiBBcHBsaWNhdGlvbik6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NzIyCiAgICAvLyBhc3NlcnQodGhpcy5pc0FkbWluKCksIEVSUl9PTkxZX0FETUlOX0NBTl9DSEFOR0VfQUtJVEFfREFPKQogICAgY2FsbHN1YiBpc0FkbWluCiAgICBhc3NlcnQgLy8gT25seSBhbiBhZG1pbiBjYW4gY2hhbmdlIHRoZSBBa2l0YSBEQU8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTI2CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWMgMjAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NzIzCiAgICAvLyB0aGlzLmFraXRhREFPLnZhbHVlID0gYWtpdGFEQU8KICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjcyMQogICAgLy8gc2V0QWtpdGFEQU8oYWtpdGFEQU86IEFwcGxpY2F0aW9uKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuc2V0Tmlja25hbWVbcm91dGluZ10oKSAtPiB2b2lkOgpzZXROaWNrbmFtZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NzMxCiAgICAvLyBzZXROaWNrbmFtZShuaWNrbmFtZTogc3RyaW5nKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NzMyCiAgICAvLyBhc3NlcnQodGhpcy5pc0FkbWluKCksIEVSUl9PTkxZX0FETUlOX0NBTl9DSEFOR0VfTklDS05BTUUpCiAgICBjYWxsc3ViIGlzQWRtaW4KICAgIGFzc2VydCAvLyBPbmx5IGFuIGFkbWluIGNhbiBjaGFuZ2UgdGhlIG5pY2tuYW1lCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzNAogICAgLy8gbmlja25hbWUgPSBHbG9iYWxTdGF0ZTxzdHJpbmc+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNOaWNrbmFtZSB9KQogICAgYnl0ZWMgMjggLy8gIm5pY2tuYW1lIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo3MzMKICAgIC8vIHRoaXMubmlja25hbWUudmFsdWUgPSBuaWNrbmFtZQogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NzMxCiAgICAvLyBzZXROaWNrbmFtZShuaWNrbmFtZTogc3RyaW5nKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuc2V0QXZhdGFyW3JvdXRpbmddKCkgLT4gdm9pZDoKc2V0QXZhdGFyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo3NDEKICAgIC8vIHNldEF2YXRhcihhdmF0YXI6IHVpbnQ2NCk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NzQyCiAgICAvLyBhc3NlcnQodGhpcy5pc0FkbWluKCksIEVSUl9PTkxZX0FETUlOX0NBTl9DSEFOR0VfTklDS05BTUUpCiAgICBjYWxsc3ViIGlzQWRtaW4KICAgIGFzc2VydCAvLyBPbmx5IGFuIGFkbWluIGNhbiBjaGFuZ2UgdGhlIG5pY2tuYW1lCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjc0MwogICAgLy8gY29uc3QgYW1vdW50ID0gdGhpcy5iYWxhbmNlKFthdmF0YXJdKQogICAgZHVwCiAgICBpdG9iCiAgICBieXRlYyAyNCAvLyAweDAwMDEKICAgIHN3YXAKICAgIGNvbmNhdAogICAgY2FsbHN1YiBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5iYWxhbmNlCiAgICBwb3AKICAgIGludGNfMiAvLyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjc0NAogICAgLy8gYXNzZXJ0KGFtb3VudFswXSA+IDAsIEVSUl9ET0VTX05PVF9IT0xEX0FTU0VUKQogICAgZXh0cmFjdF91aW50NjQKICAgIGFzc2VydCAvLyBUaGUgYWNjb3VudCBkb2VzIG5vdCBob2xkIHRoZSBhc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzYKICAgIC8vIGF2YXRhciA9IEdsb2JhbFN0YXRlPEFzc2V0Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQXZhdGFyIH0pCiAgICBwdXNoYnl0ZXMgImF2YXRhciIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NzQ1CiAgICAvLyB0aGlzLmF2YXRhci52YWx1ZSA9IEFzc2V0KGF2YXRhcikKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjc0MQogICAgLy8gc2V0QXZhdGFyKGF2YXRhcjogdWludDY0KTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuc2V0QmFubmVyW3JvdXRpbmddKCkgLT4gdm9pZDoKc2V0QmFubmVyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo3NTMKICAgIC8vIHNldEJhbm5lcihiYW5uZXI6IHVpbnQ2NCk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NzU0CiAgICAvLyBhc3NlcnQodGhpcy5pc0FkbWluKCksIEVSUl9PTkxZX0FETUlOX0NBTl9DSEFOR0VfTklDS05BTUUpCiAgICBjYWxsc3ViIGlzQWRtaW4KICAgIGFzc2VydCAvLyBPbmx5IGFuIGFkbWluIGNhbiBjaGFuZ2UgdGhlIG5pY2tuYW1lCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjc1NQogICAgLy8gY29uc3QgYW1vdW50ID0gdGhpcy5iYWxhbmNlKFtiYW5uZXJdKQogICAgZHVwCiAgICBpdG9iCiAgICBieXRlYyAyNCAvLyAweDAwMDEKICAgIHN3YXAKICAgIGNvbmNhdAogICAgY2FsbHN1YiBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5iYWxhbmNlCiAgICBwb3AKICAgIGludGNfMiAvLyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjc1NgogICAgLy8gYXNzZXJ0KGFtb3VudFswXSA+IDAsIEVSUl9ET0VTX05PVF9IT0xEX0FTU0VUKQogICAgZXh0cmFjdF91aW50NjQKICAgIGFzc2VydCAvLyBUaGUgYWNjb3VudCBkb2VzIG5vdCBob2xkIHRoZSBhc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzgKICAgIC8vIGJhbm5lciA9IEdsb2JhbFN0YXRlPEFzc2V0Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQmFubmVyIH0pCiAgICBwdXNoYnl0ZXMgImJhbm5lciIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NzU3CiAgICAvLyB0aGlzLmJhbm5lci52YWx1ZSA9IEFzc2V0KGJhbm5lcikKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjc1MwogICAgLy8gc2V0QmFubmVyKGJhbm5lcjogdWludDY0KTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuc2V0QmlvW3JvdXRpbmddKCkgLT4gdm9pZDoKc2V0QmlvOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo3NjUKICAgIC8vIHNldEJpbyhiaW86IHN0cmluZyk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjc2NgogICAgLy8gYXNzZXJ0KHRoaXMuaXNBZG1pbigpLCBFUlJfT05MWV9BRE1JTl9DQU5fQ0hBTkdFX05JQ0tOQU1FKQogICAgY2FsbHN1YiBpc0FkbWluCiAgICBhc3NlcnQgLy8gT25seSBhbiBhZG1pbiBjYW4gY2hhbmdlIHRoZSBuaWNrbmFtZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDAKICAgIC8vIGJpbyA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0JpbyB9KQogICAgcHVzaGJ5dGVzICJiaW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjc2NwogICAgLy8gdGhpcy5iaW8udmFsdWUgPSBiaW8KICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjc2NQogICAgLy8gc2V0QmlvKGJpbzogc3RyaW5nKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfY2hhbmdlQWRtaW5bcm91dGluZ10oKSAtPiB2b2lkOgphcmM1OF9jaGFuZ2VBZG1pbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Nzc1CiAgICAvLyBhcmM1OF9jaGFuZ2VBZG1pbihuZXdBZG1pbjogQWNjb3VudCk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo3NzYKICAgIC8vIGFzc2VydCh0aGlzLmlzQWRtaW4oKSwgRVJSX09OTFlfQURNSU5fQ0FOX0NIQU5HRV9BRE1JTik7CiAgICBjYWxsc3ViIGlzQWRtaW4KICAgIGFzc2VydCAvLyBPbmx5IGFuIGFkbWluIGNhbiBjaGFuZ2UgdGhlIGFkbWluIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTI4CiAgICAvLyBhZG1pbiA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNBZG1pbiB9KQogICAgYnl0ZWMgMTMgLy8gImFkbWluIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo3NzcKICAgIC8vIHRoaXMuYWRtaW4udmFsdWUgPSBuZXdBZG1pbjsKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0MgogICAgLy8gbGFzdFVzZXJJbnRlcmFjdGlvbiA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0xhc3RVc2VySW50ZXJhY3Rpb24gfSkKICAgIGJ5dGVjIDQgLy8gImxhc3RfdXNlcl9pbnRlcmFjdGlvbiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTg3CiAgICAvLyB0aGlzLmxhc3RVc2VySW50ZXJhY3Rpb24udmFsdWUgPSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDQKICAgIC8vIGxhc3RDaGFuZ2UgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNMYXN0Q2hhbmdlIH0pCiAgICBieXRlYyA2IC8vICJsYXN0X2NoYW5nZSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTkxCiAgICAvLyB0aGlzLmxhc3RDaGFuZ2UudmFsdWUgPSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo3NzUKICAgIC8vIGFyYzU4X2NoYW5nZUFkbWluKG5ld0FkbWluOiBBY2NvdW50KTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcGx1Z2luQ2hhbmdlQWRtaW5bcm91dGluZ10oKSAtPiB2b2lkOgphcmM1OF9wbHVnaW5DaGFuZ2VBZG1pbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Nzg4CiAgICAvLyBhcmM1OF9wbHVnaW5DaGFuZ2VBZG1pbihuZXdBZG1pbjogQWNjb3VudCk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo3ODkKICAgIC8vIGNvbnN0IGtleSA9IGNsb25lKHRoaXMuY3VycmVudFBsdWdpbi52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0OAogICAgLy8gY3VycmVudFBsdWdpbiA9IEdsb2JhbFN0YXRlPFBsdWdpbktleT4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0N1cnJlbnRQbHVnaW4gfSkKICAgIGJ5dGVjIDI1IC8vICJjdXJyZW50X3BsdWdpbiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Nzg5CiAgICAvLyBjb25zdCBrZXkgPSBjbG9uZSh0aGlzLmN1cnJlbnRQbHVnaW4udmFsdWUpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo3OTAKICAgIC8vIGNvbnN0IHsgcGx1Z2luLCBlc2Nyb3cgfSA9IGtleQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGRpZyAxCiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZGlnIDIKICAgIGxlbgogICAgZGlnIDMKICAgIGNvdmVyIDIKICAgIHN1YnN0cmluZzMKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjc5MgogICAgLy8gYXNzZXJ0KGVzY3JvdyA9PT0gJycsIEVSUl9BRE1JTl9QTFVHSU5TX0NBTk5PVF9VU0VfRVNDUk9XUyk7CiAgICBieXRlY18xIC8vICIiCiAgICA9PQogICAgYXNzZXJ0IC8vIGFkbWluIHBsdWdpbnMgY2Fubm90IHVzZSBlc2Nyb3dzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjc5MwogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IEFwcGxpY2F0aW9uKHBsdWdpbikuYWRkcmVzcywgRVJSX1NFTkRFUl9NVVNUX0JFX0FETUlOX1BMVUdJTik7CiAgICB0eG4gU2VuZGVyCiAgICBkaWcgMQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBzZW5kZXIgbXVzdCBiZSBhZG1pbiBwbHVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Nzk1CiAgICAvLyB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLmF1dGhBZGRyZXNzID09PSBBcHBsaWNhdGlvbihwbHVnaW4pLmFkZHJlc3MsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzIKICAgIC8vIGNvbnRyb2xsZWRBZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzIH0pOwogICAgYnl0ZWNfMCAvLyAiY29udHJvbGxlZF9hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo3OTUKICAgIC8vIHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUuYXV0aEFkZHJlc3MgPT09IEFwcGxpY2F0aW9uKHBsdWdpbikuYWRkcmVzcywKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdEF1dGhBZGRyCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIHN3YXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjc5NC03OTcKICAgIC8vIGFzc2VydCgKICAgIC8vICAgdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZS5hdXRoQWRkcmVzcyA9PT0gQXBwbGljYXRpb24ocGx1Z2luKS5hZGRyZXNzLAogICAgLy8gICAnVGhpcyBwbHVnaW4gaXMgbm90IGluIGNvbnRyb2wgb2YgdGhlIGFjY291bnQnCiAgICAvLyApOwogICAgYXNzZXJ0IC8vIFRoaXMgcGx1Z2luIGlzIG5vdCBpbiBjb250cm9sIG9mIHRoZSBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE2MwogICAgLy8gcGx1Z2lucyA9IEJveE1hcDxQbHVnaW5LZXksIFBsdWdpbkluZm8+KHsga2V5UHJlZml4OiBBYnN0cmFjdEFjY291bnRCb3hQcmVmaXhQbHVnaW5zIH0pOwogICAgYnl0ZWNfMyAvLyAicCIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjgwMAogICAgLy8gdGhpcy5wbHVnaW5zKGtleSkuZXhpc3RzICYmIHRoaXMucGx1Z2lucyhrZXkpLnZhbHVlLmFkbWluLAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBieiBhcmM1OF9wbHVnaW5DaGFuZ2VBZG1pbl9ib29sX2ZhbHNlQDQKICAgIGR1cAogICAgcHVzaGludCAyNyAvLyAyNwogICAgaW50Y18xIC8vIDEKICAgIGJveF9leHRyYWN0CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBieiBhcmM1OF9wbHVnaW5DaGFuZ2VBZG1pbl9ib29sX2ZhbHNlQDQKICAgIGludGNfMSAvLyAxCgphcmM1OF9wbHVnaW5DaGFuZ2VBZG1pbl9ib29sX21lcmdlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjc5OS04MDIKICAgIC8vIGFzc2VydCgKICAgIC8vICAgdGhpcy5wbHVnaW5zKGtleSkuZXhpc3RzICYmIHRoaXMucGx1Z2lucyhrZXkpLnZhbHVlLmFkbWluLAogICAgLy8gICAnVGhpcyBwbHVnaW4gZG9lcyBub3QgaGF2ZSBhZG1pbiBwcml2aWxlZ2VzJwogICAgLy8gKTsKICAgIGFzc2VydCAvLyBUaGlzIHBsdWdpbiBkb2VzIG5vdCBoYXZlIGFkbWluIHByaXZpbGVnZXMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTI4CiAgICAvLyBhZG1pbiA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNBZG1pbiB9KQogICAgYnl0ZWMgMTMgLy8gImFkbWluIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo4MDQKICAgIC8vIHRoaXMuYWRtaW4udmFsdWUgPSBuZXdBZG1pbjsKICAgIGRpZyAyCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo4MDUKICAgIC8vIGlmICh0aGlzLnBsdWdpbnMoa2V5KS52YWx1ZS5kZWxlZ2F0aW9uVHlwZSA9PT0gRGVsZWdhdGlvblR5cGVTZWxmKSB7CiAgICBkdXAKICAgIGludGNfMyAvLyA4CiAgICBpbnRjXzEgLy8gMQogICAgYm94X2V4dHJhY3QKICAgIGJ5dGVjIDE0IC8vIDB4MDEKICAgID09CiAgICBieiBhcmM1OF9wbHVnaW5DaGFuZ2VBZG1pbl9hZnRlcl9pZl9lbHNlQDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQyCiAgICAvLyBsYXN0VXNlckludGVyYWN0aW9uID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzTGFzdFVzZXJJbnRlcmFjdGlvbiB9KQogICAgYnl0ZWMgNCAvLyAibGFzdF91c2VyX2ludGVyYWN0aW9uIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxODcKICAgIC8vIHRoaXMubGFzdFVzZXJJbnRlcmFjdGlvbi52YWx1ZSA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGFwcF9nbG9iYWxfcHV0CgphcmM1OF9wbHVnaW5DaGFuZ2VBZG1pbl9hZnRlcl9pZl9lbHNlQDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0NAogICAgLy8gbGFzdENoYW5nZSA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0xhc3RDaGFuZ2UgfSkKICAgIGJ5dGVjIDYgLy8gImxhc3RfY2hhbmdlIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxOTEKICAgIC8vIHRoaXMubGFzdENoYW5nZS52YWx1ZSA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjc4OAogICAgLy8gYXJjNThfcGx1Z2luQ2hhbmdlQWRtaW4obmV3QWRtaW46IEFjY291bnQpOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCmFyYzU4X3BsdWdpbkNoYW5nZUFkbWluX2Jvb2xfZmFsc2VANDoKICAgIGludGNfMCAvLyAwCiAgICBiIGFyYzU4X3BsdWdpbkNoYW5nZUFkbWluX2Jvb2xfbWVyZ2VANQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3ZlcmlmeUF1dGhBZGRyZXNzW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjNThfdmVyaWZ5QXV0aEFkZHJlc3M6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjgxNQogICAgLy8gYXNzZXJ0KHRoaXMuc3BlbmRpbmdBZGRyZXNzLnZhbHVlLmF1dGhBZGRyZXNzID09PSB0aGlzLmdldEF1dGhBZGRyZXNzKCkpOwogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQ2CiAgICAvLyBzcGVuZGluZ0FkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzIH0pCiAgICBieXRlYyAxMCAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6ODE1CiAgICAvLyBhc3NlcnQodGhpcy5zcGVuZGluZ0FkZHJlc3MudmFsdWUuYXV0aEFkZHJlc3MgPT09IHRoaXMuZ2V0QXV0aEFkZHJlc3MoKSk7CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZHVwCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdEF1dGhBZGRyCiAgICBzd2FwCiAgICBjb3ZlciAyCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NjA3CiAgICAvLyB0aGlzLnNwZW5kaW5nQWRkcmVzcy52YWx1ZSA9PT0gdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTMyCiAgICAvLyBjb250cm9sbGVkQWRkcmVzcyA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcyB9KTsKICAgIGJ5dGVjXzAgLy8gImNvbnRyb2xsZWRfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NjA3CiAgICAvLyB0aGlzLnNwZW5kaW5nQWRkcmVzcy52YWx1ZSA9PT0gdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjYwNy02MDgKICAgIC8vIHRoaXMuc3BlbmRpbmdBZGRyZXNzLnZhbHVlID09PSB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlCiAgICAvLyAmJiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYnogYXJjNThfdmVyaWZ5QXV0aEFkZHJlc3NfdGVybmFyeV9mYWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjYwOAogICAgLy8gJiYgdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMgogICAgLy8gY29udHJvbGxlZEFkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MgfSk7CiAgICBieXRlY18wIC8vICJjb250cm9sbGVkX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjYwOAogICAgLy8gJiYgdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NjA3LTYwOAogICAgLy8gdGhpcy5zcGVuZGluZ0FkZHJlc3MudmFsdWUgPT09IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUKICAgIC8vICYmIHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBieiBhcmM1OF92ZXJpZnlBdXRoQWRkcmVzc190ZXJuYXJ5X2ZhbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NjA5CiAgICAvLyApID8gR2xvYmFsLnplcm9BZGRyZXNzIDogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwoKYXJjNThfdmVyaWZ5QXV0aEFkZHJlc3NfdGVybmFyeV9tZXJnZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo4MTUKICAgIC8vIGFzc2VydCh0aGlzLnNwZW5kaW5nQWRkcmVzcy52YWx1ZS5hdXRoQWRkcmVzcyA9PT0gdGhpcy5nZXRBdXRoQWRkcmVzcygpKTsKICAgIGRpZyAxCiAgICA9PQogICAgYXNzZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0NgogICAgLy8gc3BlbmRpbmdBZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcyB9KQogICAgYnl0ZWMgMTAgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjgxNgogICAgLy8gdGhpcy5zcGVuZGluZ0FkZHJlc3MudmFsdWUgPSBHbG9iYWwuemVyb0FkZHJlc3MKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6ODE3CiAgICAvLyB0aGlzLmN1cnJlbnRQbHVnaW4udmFsdWUgPSB7IHBsdWdpbjogMCwgY2FsbGVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywgZXNjcm93OiAnJyB9CiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgaW50Y18wIC8vIDAKICAgIGl0b2IKICAgIHN3YXAKICAgIGNvbmNhdAogICAgcHVzaGJ5dGVzIDB4MDAyYTAwMDAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDgKICAgIC8vIGN1cnJlbnRQbHVnaW4gPSBHbG9iYWxTdGF0ZTxQbHVnaW5LZXk+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDdXJyZW50UGx1Z2luIH0pCiAgICBieXRlYyAyNSAvLyAiY3VycmVudF9wbHVnaW4iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjgxNwogICAgLy8gdGhpcy5jdXJyZW50UGx1Z2luLnZhbHVlID0geyBwbHVnaW46IDAsIGNhbGxlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsIGVzY3JvdzogJycgfQogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTUwCiAgICAvLyByZWtleUluZGV4ID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCwga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNSZWtleUluZGV4IH0pCiAgICBieXRlYyAxOSAvLyAicmVrZXlfaW5kZXgiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjgxOAogICAgLy8gdGhpcy5yZWtleUluZGV4LnZhbHVlID0gMAogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjgxNAogICAgLy8gYXJjNThfdmVyaWZ5QXV0aEFkZHJlc3MoKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgphcmM1OF92ZXJpZnlBdXRoQWRkcmVzc190ZXJuYXJ5X2ZhbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjYwOQogICAgLy8gKSA/IEdsb2JhbC56ZXJvQWRkcmVzcyA6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYiBhcmM1OF92ZXJpZnlBdXRoQWRkcmVzc190ZXJuYXJ5X21lcmdlQDUKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjNThfcmVrZXlUbzoKICAgIGJ5dGVjXzEgLy8gIiIKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo4MjcKICAgIC8vIGFyYzU4X3Jla2V5VG8oYWRkcmVzczogQWNjb3VudCwgZmxhc2g6IGJvb2xlYW4pOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6ODI4CiAgICAvLyBhc3NlcnQodGhpcy5pc0FkbWluKCksIEVSUl9BRE1JTl9PTkxZKTsKICAgIGNhbGxzdWIgaXNBZG1pbgogICAgYXNzZXJ0IC8vIGFkbWluIG9ubHkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6ODMwLTgzNwogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIHJlY2VpdmVyOiBhZGRyZXNzLAogICAgLy8gICAgIHJla2V5VG86IGFkZHJlc3MsCiAgICAvLyAgICAgbm90ZTogJ3Jla2V5aW5nIGFic3RyYWN0ZWQgYWNjb3VudCcKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpOwogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo4MzIKICAgIC8vIHNlbmRlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMgogICAgLy8gY29udHJvbGxlZEFkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MgfSk7CiAgICBieXRlY18wIC8vICJjb250cm9sbGVkX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjgzMgogICAgLy8gc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6ODM1CiAgICAvLyBub3RlOiAncmVrZXlpbmcgYWJzdHJhY3RlZCBhY2NvdW50JwogICAgcHVzaGJ5dGVzICJyZWtleWluZyBhYnN0cmFjdGVkIGFjY291bnQiCiAgICBpdHhuX2ZpZWxkIE5vdGUKICAgIGRpZyAyCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6ODMwLTgzNgogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIHJlY2VpdmVyOiBhZGRyZXNzLAogICAgLy8gICAgIHJla2V5VG86IGFkZHJlc3MsCiAgICAvLyAgICAgbm90ZTogJ3Jla2V5aW5nIGFic3RyYWN0ZWQgYWNjb3VudCcKICAgIC8vICAgfSkKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6ODMwLTgzNwogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIHJlY2VpdmVyOiBhZGRyZXNzLAogICAgLy8gICAgIHJla2V5VG86IGFkZHJlc3MsCiAgICAvLyAgICAgbm90ZTogJ3Jla2V5aW5nIGFic3RyYWN0ZWQgYWNjb3VudCcKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpOwogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6ODM5CiAgICAvLyBpZiAoZmxhc2gpIHRoaXMuYXNzZXJ0UmVrZXlzQmFjaygpOwogICAgYnogYXJjNThfcmVrZXlUb19hZnRlcl9pZl9lbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MzIwCiAgICAvLyBsZXQgcmVrZXlzQmFjayA9IGZhbHNlOwogICAgaW50Y18wIC8vIDAKICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozMjEKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IChUeG4uZ3JvdXBJbmRleCArIDEpOyBpIDwgR2xvYmFsLmdyb3VwU2l6ZTsgaSArPSAxKSB7CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgMgoKYXJjNThfcmVrZXlUb193aGlsZV90b3BANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MzIxCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAoVHhuLmdyb3VwSW5kZXggKyAxKTsgaSA8IEdsb2JhbC5ncm91cFNpemU7IGkgKz0gMSkgewogICAgZGlnIDEKICAgIGdsb2JhbCBHcm91cFNpemUKICAgIDwKICAgIGJ6IGFyYzU4X3Jla2V5VG9fYmxvY2tAMTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MzI0CiAgICAvLyBpZiAodGhpcy50eG5SZWtleXNCYWNrKHR4bikpIHsKICAgIGRpZyAxCiAgICBjYWxsc3ViIHR4blJla2V5c0JhY2sKICAgIGJ6IGFyYzU4X3Jla2V5VG9fYWZ0ZXJfaWZfZWxzZUA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjMyNQogICAgLy8gcmVrZXlzQmFjayA9IHRydWU7CiAgICBpbnRjXzEgLy8gMQogICAgYnVyeSAxCgphcmM1OF9yZWtleVRvX2Jsb2NrQDExOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozMzAKICAgIC8vIGFzc2VydChyZWtleXNCYWNrLCBFUlJfTUlTU0lOR19SRUtFWV9CQUNLKTsKICAgIGR1cAogICAgYXNzZXJ0IC8vIG1pc3NpbmcgcmVrZXkgYmFjawoKYXJjNThfcmVrZXlUb19hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0MgogICAgLy8gbGFzdFVzZXJJbnRlcmFjdGlvbiA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0xhc3RVc2VySW50ZXJhY3Rpb24gfSkKICAgIGJ5dGVjIDQgLy8gImxhc3RfdXNlcl9pbnRlcmFjdGlvbiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTg3CiAgICAvLyB0aGlzLmxhc3RVc2VySW50ZXJhY3Rpb24udmFsdWUgPSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo4MjcKICAgIC8vIGFyYzU4X3Jla2V5VG8oYWRkcmVzczogQWNjb3VudCwgZmxhc2g6IGJvb2xlYW4pOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCmFyYzU4X3Jla2V5VG9fYWZ0ZXJfaWZfZWxzZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozMjEKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IChUeG4uZ3JvdXBJbmRleCArIDEpOyBpIDwgR2xvYmFsLmdyb3VwU2l6ZTsgaSArPSAxKSB7CiAgICBkaWcgMQogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgMgogICAgYiBhcmM1OF9yZWtleVRvX3doaWxlX3RvcEA2CgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfY2FuQ2FsbFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzU4X2NhbkNhbGw6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjg1NAogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBjb3ZlciAyCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGxlbgogICAgcHVzaGludCA0IC8vIDQKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzRdCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjg2MgogICAgLy8gaWYgKGdsb2JhbCkgewogICAgYnogYXJjNThfY2FuQ2FsbF9hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6ODYzCiAgICAvLyB0aGlzLnBsdWdpbkNhbGxBbGxvd2VkKHBsdWdpbiwgR2xvYmFsLnplcm9BZGRyZXNzLCBlc2Nyb3csIG1ldGhvZCk7CiAgICBkaWcgMwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICBkaWcgMwogICAgZGlnIDMKICAgIGNhbGxzdWIgcGx1Z2luQ2FsbEFsbG93ZWQKICAgIHBvcAoKYXJjNThfY2FuQ2FsbF9hZnRlcl9pZl9lbHNlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjg2NQogICAgLy8gcmV0dXJuIHRoaXMucGx1Z2luQ2FsbEFsbG93ZWQocGx1Z2luLCBhZGRyZXNzLCBlc2Nyb3csIG1ldGhvZCk7CiAgICBkaWcgMwogICAgZGlnIDMKICAgIGRpZyAzCiAgICBkaWcgMwogICAgY2FsbHN1YiBwbHVnaW5DYWxsQWxsb3dlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo4NTQKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgYnl0ZWMgOCAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIGJ5dGVjIDUgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjNThfcmVrZXlUb1BsdWdpbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6ODc3LTg4MwogICAgLy8gYXJjNThfcmVrZXlUb1BsdWdpbigKICAgIC8vICAgcGx1Z2luOiB1aW50NjQsCiAgICAvLyAgIGdsb2JhbDogYm9vbGVhbiwKICAgIC8vICAgZXNjcm93OiBzdHJpbmcsCiAgICAvLyAgIG1ldGhvZE9mZnNldHM6IHVpbnQ2NFtdLAogICAgLy8gICBmdW5kc1JlcXVlc3Q6IEZ1bmRzUmVxdWVzdFtdCiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzMgLy8gOAogICAgKgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdWludDY0W10pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAxNiAvLyAxNgogICAgKgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rKHVpbnQ2NCx1aW50NjQpW10pCiAgICBjYWxsc3ViIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW4KICAgIHBvcG4gMgogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9OYW1lZFBsdWdpbltyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzU4X3Jla2V5VG9OYW1lZFBsdWdpbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OTQ1LTk1MAogICAgLy8gYXJjNThfcmVrZXlUb05hbWVkUGx1Z2luKAogICAgLy8gICBuYW1lOiBzdHJpbmcsCiAgICAvLyAgIGdsb2JhbDogYm9vbGVhbiwKICAgIC8vICAgZXNjcm93OiBzdHJpbmcsCiAgICAvLyAgIG1ldGhvZE9mZnNldHM6IHVpbnQ2NFtdLAogICAgLy8gICBmdW5kc1JlcXVlc3Q6IEZ1bmRzUmVxdWVzdFtdKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1dGY4W10pCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMyAvLyA4CiAgICAqCiAgICBpbnRjXzIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1aW50NjRbXSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICAqCiAgICBpbnRjXzIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbisodWludDY0LHVpbnQ2NClbXSkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTY1CiAgICAvLyBuYW1lZFBsdWdpbnMgPSBCb3hNYXA8c3RyaW5nLCBQbHVnaW5LZXk+KHsga2V5UHJlZml4OiBBYnN0cmFjdEFjY291bnRCb3hQcmVmaXhOYW1lZFBsdWdpbnMgfSk7CiAgICBieXRlYyAxNSAvLyAibiIKICAgIHVuY292ZXIgNQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjk1MgogICAgLy8gdGhpcy5uYW1lZFBsdWdpbnMobmFtZSkudmFsdWUucGx1Z2luLAogICAgaW50Y18wIC8vIDAKICAgIGludGNfMyAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo5NTEtOTU3CiAgICAvLyB0aGlzLmFyYzU4X3Jla2V5VG9QbHVnaW4oCiAgICAvLyAgIHRoaXMubmFtZWRQbHVnaW5zKG5hbWUpLnZhbHVlLnBsdWdpbiwKICAgIC8vICAgZ2xvYmFsLAogICAgLy8gICBlc2Nyb3csCiAgICAvLyAgIG1ldGhvZE9mZnNldHMsCiAgICAvLyAgIGZ1bmRzUmVxdWVzdAogICAgLy8gKTsKICAgIGNvdmVyIDQKICAgIGNhbGxzdWIgc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbgogICAgcG9wbiAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjk0NS05NTAKICAgIC8vIGFyYzU4X3Jla2V5VG9OYW1lZFBsdWdpbigKICAgIC8vICAgbmFtZTogc3RyaW5nLAogICAgLy8gICBnbG9iYWw6IGJvb2xlYW4sCiAgICAvLyAgIGVzY3Jvdzogc3RyaW5nLAogICAgLy8gICBtZXRob2RPZmZzZXRzOiB1aW50NjRbXSwKICAgIC8vICAgZnVuZHNSZXF1ZXN0OiBGdW5kc1JlcXVlc3RbXSk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X2FkZFBsdWdpbltyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzU4X2FkZFBsdWdpbjoKICAgIGludGNfMCAvLyAwCiAgICBkdXBuIDMKICAgIGJ5dGVjXzEgLy8gIiIKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo5NzctOTkxCiAgICAvLyBhcmM1OF9hZGRQbHVnaW4oCiAgICAvLyAgIHBsdWdpbjogdWludDY0LAogICAgLy8gICBjYWxsZXI6IEFjY291bnQsCiAgICAvLyAgIGVzY3Jvdzogc3RyaW5nLAogICAgLy8gICBhZG1pbjogYm9vbGVhbiwKICAgIC8vICAgZGVsZWdhdGlvblR5cGU6IFVpbnQ4LAogICAgLy8gICBsYXN0VmFsaWQ6IHVpbnQ2NCwKICAgIC8vICAgY29vbGRvd246IHVpbnQ2NCwKICAgIC8vICAgbWV0aG9kczogTWV0aG9kUmVzdHJpY3Rpb25bXSwKICAgIC8vICAgdXNlUm91bmRzOiBib29sZWFuLAogICAgLy8gICB1c2VFeGVjdXRpb25LZXk6IGJvb2xlYW4sCiAgICAvLyAgIGNvdmVyRmVlczogYm9vbGVhbiwKICAgIC8vICAgY2FuUmVjbGFpbTogYm9vbGVhbiwKICAgIC8vICAgZGVmYXVsdFRvRXNjcm93OiBib29sZWFuCiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGR1cG4gMgogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDgKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDYKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA3CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgc3dhcAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgOAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZHVwCiAgICBjb3ZlciAzCiAgICBwdXNoaW50IDEyIC8vIDEyCiAgICAqCiAgICBpbnRjXzIgLy8gMgogICAgKwogICAgc3dhcAogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuKyh1aW50OFs0XSx1aW50NjQpW10pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA5CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxMAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgc3dhcAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMTEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHN3YXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo5OTIKICAgIC8vIGFzc2VydCh0aGlzLmlzQWRtaW4oKSwgRVJSX0FETUlOX09OTFkpOwogICAgY2FsbHN1YiBpc0FkbWluCiAgICBhc3NlcnQgLy8gYWRtaW4gb25seQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo5OTUKICAgIC8vIGRlbGVnYXRpb25UeXBlID09PSBEZWxlZ2F0aW9uVHlwZVNlbGYgJiYKICAgIGJ5dGVjIDE0IC8vIDB4MDEKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjk5NS05OTYKICAgIC8vIGRlbGVnYXRpb25UeXBlID09PSBEZWxlZ2F0aW9uVHlwZVNlbGYgJiYKICAgIC8vIGNhbGxlciA9PT0gR2xvYmFsLnplcm9BZGRyZXNzCiAgICBieiBhcmM1OF9hZGRQbHVnaW5fYm9vbF9mYWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjk5NgogICAgLy8gY2FsbGVyID09PSBHbG9iYWwuemVyb0FkZHJlc3MKICAgIGRpZyAxMgogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo5OTUtOTk2CiAgICAvLyBkZWxlZ2F0aW9uVHlwZSA9PT0gRGVsZWdhdGlvblR5cGVTZWxmICYmCiAgICAvLyBjYWxsZXIgPT09IEdsb2JhbC56ZXJvQWRkcmVzcwogICAgYnogYXJjNThfYWRkUGx1Z2luX2Jvb2xfZmFsc2VANAogICAgaW50Y18xIC8vIDEKCmFyYzU4X2FkZFBsdWdpbl9ib29sX21lcmdlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjk5NC05OTcKICAgIC8vICEoCiAgICAvLyAgIGRlbGVnYXRpb25UeXBlID09PSBEZWxlZ2F0aW9uVHlwZVNlbGYgJiYKICAgIC8vICAgY2FsbGVyID09PSBHbG9iYWwuemVyb0FkZHJlc3MKICAgIC8vICksCiAgICAhCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjk5My05OTkKICAgIC8vIGFzc2VydCgKICAgIC8vICAgISgKICAgIC8vICAgICBkZWxlZ2F0aW9uVHlwZSA9PT0gRGVsZWdhdGlvblR5cGVTZWxmICYmCiAgICAvLyAgICAgY2FsbGVyID09PSBHbG9iYWwuemVyb0FkZHJlc3MKICAgIC8vICAgKSwKICAgIC8vICAgRVJSX1pFUk9fQUREUkVTU19ERUxFR0FUSU9OX1RZUEUKICAgIC8vICkKICAgIGFzc2VydCAvLyBkZWxlZ2F0aW9uIHR5cGUgbXVzdCBub3QgYmUgc2VsZiBmb3IgZ2xvYmFsIHBsdWdpbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTAwMi0xMDAzCiAgICAvLyB1c2VFeGVjdXRpb25LZXkgJiYKICAgIC8vIGNhbGxlciAhPT0gR2xvYmFsLnplcm9BZGRyZXNzCiAgICBkaWcgMwogICAgYnogYXJjNThfYWRkUGx1Z2luX2Jvb2xfZmFsc2VAOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMDAzCiAgICAvLyBjYWxsZXIgIT09IEdsb2JhbC56ZXJvQWRkcmVzcwogICAgZGlnIDEyCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgICE9CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEwMDItMTAwMwogICAgLy8gdXNlRXhlY3V0aW9uS2V5ICYmCiAgICAvLyBjYWxsZXIgIT09IEdsb2JhbC56ZXJvQWRkcmVzcwogICAgYnogYXJjNThfYWRkUGx1Z2luX2Jvb2xfZmFsc2VAOAogICAgaW50Y18xIC8vIDEKCmFyYzU4X2FkZFBsdWdpbl9ib29sX21lcmdlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEwMDEtMTAwNAogICAgLy8gISgKICAgIC8vICAgdXNlRXhlY3V0aW9uS2V5ICYmCiAgICAvLyAgIGNhbGxlciAhPT0gR2xvYmFsLnplcm9BZGRyZXNzCiAgICAvLyApLAogICAgIQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMDAwLTEwMDYKICAgIC8vIGFzc2VydCgKICAgIC8vICAgISgKICAgIC8vICAgICB1c2VFeGVjdXRpb25LZXkgJiYKICAgIC8vICAgICBjYWxsZXIgIT09IEdsb2JhbC56ZXJvQWRkcmVzcwogICAgLy8gICApLAogICAgLy8gICBFUlJfVVNJTkdfRVhFQ1VUSU9OX0tFWV9SRVFVSVJFU19HTE9CQUwKICAgIC8vICkKICAgIGFzc2VydCAvLyB1c2luZyBleGVjdXRpb24ga2V5IHJlcXVpcmVzIGdsb2JhbCBwbHVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTAwOQogICAgLy8gaWYgKGRlZmF1bHRUb0VzY3JvdykgewogICAgZHVwCiAgICBibnogYXJjNThfYWRkUGx1Z2luX2lmX2JvZHlAMTAKICAgIGRpZyAxMQogICAgYnVyeSAxOAoKYXJjNThfYWRkUGx1Z2luX2FmdGVyX2lmX2Vsc2VAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEwMTQKICAgIC8vIGNvbnN0IGtleTogUGx1Z2luS2V5ID0geyBwbHVnaW4sIGNhbGxlciwgZXNjcm93OiBlc2Nyb3dLZXkgfQogICAgZGlnIDEzCiAgICBpdG9iCiAgICBkaWcgMTMKICAgIGNvbmNhdAogICAgZGlnIDE4CiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgc3dhcAogICAgYnl0ZWMgMTEgLy8gMHgwMDJhCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjMKICAgIC8vIHBsdWdpbnMgPSBCb3hNYXA8UGx1Z2luS2V5LCBQbHVnaW5JbmZvPih7IGtleVByZWZpeDogQWJzdHJhY3RBY2NvdW50Qm94UHJlZml4UGx1Z2lucyB9KTsKICAgIGJ5dGVjXzMgLy8gInAiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgYnVyeSAyMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMDE2CiAgICAvLyBhc3NlcnQoIXRoaXMucGx1Z2lucyhrZXkpLmV4aXN0cywgRVJSX1BMVUdJTl9BTFJFQURZX0VYSVNUUykKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgIQogICAgYXNzZXJ0IC8vIHBsdWdpbiBhbHJlYWR5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMDE4CiAgICAvLyBsZXQgbWV0aG9kSW5mb3M6IE1ldGhvZEluZm9bXSA9IFtdCiAgICBpbnRjXzAgLy8gMAogICAgaXRvYgogICAgYnVyeSAyMAogICAgYnl0ZWMgNyAvLyAweDAwMDAKICAgIGJ1cnkgMTcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTAxOQogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDE1CgphcmM1OF9hZGRQbHVnaW5fd2hpbGVfdG9wQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMDE5CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkgKz0gMSkgewogICAgZGlnIDE0CiAgICBkaWcgNgogICAgPAogICAgYnogYXJjNThfYWRkUGx1Z2luX2FmdGVyX3doaWxlQDE0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEwMjAKICAgIC8vIG1ldGhvZEluZm9zLnB1c2goeyAuLi5tZXRob2RzW2ldLCBsYXN0Q2FsbGVkOiAwIH0pCiAgICBkaWcgNgogICAgZXh0cmFjdCAyIDAKICAgIGRpZyAxNQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBwdXNoaW50IDEyIC8vIDEyCiAgICAqCiAgICBwdXNoaW50IDEyIC8vIDEyCiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogaW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGR1cAogICAgZXh0cmFjdCAwIDQKICAgIHN3YXAKICAgIGV4dHJhY3QgNCA4CiAgICBkaWcgMQogICAgbGVuCiAgICBwdXNoaW50IDQgLy8gNAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIHNpemUKICAgIGNvbmNhdAogICAgZGlnIDIxCiAgICBjb25jYXQKICAgIGRpZyAxOAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdCAvLyBvbiBlcnJvcjogbWF4IGFycmF5IGxlbmd0aCBleGNlZWRlZAogICAgc3dhcAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHJlcGxhY2UyIDAKICAgIGJ1cnkgMTgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTAxOQogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBidXJ5IDE1CiAgICBiIGFyYzU4X2FkZFBsdWdpbl93aGlsZV90b3BAMTIKCmFyYzU4X2FkZFBsdWdpbl9hZnRlcl93aGlsZUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTAyMwogICAgLy8gY29uc3QgZXBvY2hSZWYgPSB1c2VSb3VuZHMgPyBHbG9iYWwucm91bmQgOiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wOwogICAgZGlnIDQKICAgIGJ6IGFyYzU4X2FkZFBsdWdpbl90ZXJuYXJ5X2ZhbHNlQDE2CiAgICBnbG9iYWwgUm91bmQKICAgIGJ1cnkgMTYKCmFyYzU4X2FkZFBsdWdpbl90ZXJuYXJ5X21lcmdlQDE3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMDI1CiAgICAvLyBpZiAodGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSAhPT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MpIHsKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMgogICAgLy8gY29udHJvbGxlZEFkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MgfSk7CiAgICBieXRlY18wIC8vICJjb250cm9sbGVkX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEwMjUKICAgIC8vIGlmICh0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlICE9PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcykgewogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICAhPQogICAgYnogYXJjNThfYWRkUGx1Z2luX2FmdGVyX2lmX2Vsc2VAMjAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTAyNi0xMDMyCiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICBzZW5kZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogdGhpcy5wbHVnaW5zTWJyKGVzY3Jvd0tleSwgbWV0aG9kSW5mb3MubGVuZ3RoKQogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTAyOAogICAgLy8gc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTMyCiAgICAvLyBjb250cm9sbGVkQWRkcmVzcyA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcyB9KTsKICAgIGJ5dGVjXzAgLy8gImNvbnRyb2xsZWRfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTAyOAogICAgLy8gc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTAyOQogICAgLy8gcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTAzMAogICAgLy8gYW1vdW50OiB0aGlzLnBsdWdpbnNNYnIoZXNjcm93S2V5LCBtZXRob2RJbmZvcy5sZW5ndGgpCiAgICBkaWcgMTgKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZGlnIDIwCiAgICBzd2FwCiAgICBjYWxsc3ViIHBsdWdpbnNNYnIKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMDI2LTEwMzEKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHNlbmRlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50OiB0aGlzLnBsdWdpbnNNYnIoZXNjcm93S2V5LCBtZXRob2RJbmZvcy5sZW5ndGgpCiAgICAvLyAgIH0pCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEwMjYtMTAzMgogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IHRoaXMucGx1Z2luc01icihlc2Nyb3dLZXksIG1ldGhvZEluZm9zLmxlbmd0aCkKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAoKYXJjNThfYWRkUGx1Z2luX2FmdGVyX2lmX2Vsc2VAMjA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEwMzUKICAgIC8vIGNvbnN0IGVzY3Jvd0lEID0gdGhpcy5tYXliZU5ld0VzY3Jvdyhlc2Nyb3cpOwogICAgZGlnIDExCiAgICBkdXAKICAgIGNhbGxzdWIgbWF5YmVOZXdFc2Nyb3cKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTA0NwogICAgLy8gY2FuUmVjbGFpbTogZXNjcm93ICE9PSAnJyA/IGNhblJlY2xhaW0gOiBmYWxzZSwKICAgIHN3YXAKICAgIGJ5dGVjXzEgLy8gIiIKICAgICE9CiAgICBpbnRjXzAgLy8gMAogICAgZGlnIDQKICAgIHVuY292ZXIgMgogICAgc2VsZWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEwMzctMTA1MAogICAgLy8gdGhpcy5wbHVnaW5zKGtleSkudmFsdWUgPSB7CiAgICAvLyAgIGVzY3JvdzogZXNjcm93SUQsCiAgICAvLyAgIGFkbWluLAogICAgLy8gICBkZWxlZ2F0aW9uVHlwZSwKICAgIC8vICAgbGFzdFZhbGlkLAogICAgLy8gICBjb29sZG93biwKICAgIC8vICAgbWV0aG9kczogY2xvbmUobWV0aG9kSW5mb3MpLAogICAgLy8gICB1c2VSb3VuZHMsCiAgICAvLyAgIHVzZUV4ZWN1dGlvbktleSwKICAgIC8vICAgY292ZXJGZWVzLAogICAgLy8gICBjYW5SZWNsYWltOiBlc2Nyb3cgIT09ICcnID8gY2FuUmVjbGFpbSA6IGZhbHNlLAogICAgLy8gICBsYXN0Q2FsbGVkOiAwLAogICAgLy8gICBzdGFydDogZXBvY2hSZWYsCiAgICAvLyB9CiAgICBzd2FwCiAgICBpdG9iCiAgICBkaWcgMTEKICAgIGNvbmNhdAogICAgZGlnIDEwCiAgICBpdG9iCiAgICBjb25jYXQKICAgIGRpZyA5CiAgICBpdG9iCiAgICBjb25jYXQKICAgIGJ5dGVjIDMwIC8vIDB4MDAyYwogICAgY29uY2F0CiAgICBieXRlYyA4IC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICBkaWcgMTQKICAgIHNldGJpdAogICAgaW50Y18xIC8vIDEKICAgIGRpZyA4CiAgICBzZXRiaXQKICAgIGludGNfMiAvLyAyCiAgICBkaWcgNwogICAgc2V0Yml0CiAgICBwdXNoaW50IDMgLy8gMwogICAgZGlnIDYKICAgIHNldGJpdAogICAgcHVzaGludCA0IC8vIDQKICAgIHVuY292ZXIgMwogICAgc2V0Yml0CiAgICBjb25jYXQKICAgIGRpZyAyMAogICAgY29uY2F0CiAgICBkaWcgMTYKICAgIGl0b2IKICAgIGNvbmNhdAogICAgZGlnIDE3CiAgICBjb25jYXQKICAgIGRpZyAxOQogICAgZHVwCiAgICBib3hfZGVsCiAgICBwb3AKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQyCiAgICAvLyBsYXN0VXNlckludGVyYWN0aW9uID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzTGFzdFVzZXJJbnRlcmFjdGlvbiB9KQogICAgYnl0ZWMgNCAvLyAibGFzdF91c2VyX2ludGVyYWN0aW9uIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxODcKICAgIC8vIHRoaXMubGFzdFVzZXJJbnRlcmFjdGlvbi52YWx1ZSA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0NAogICAgLy8gbGFzdENoYW5nZSA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0xhc3RDaGFuZ2UgfSkKICAgIGJ5dGVjIDYgLy8gImxhc3RfY2hhbmdlIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxOTEKICAgIC8vIHRoaXMubGFzdENoYW5nZS52YWx1ZSA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjk3Ny05OTEKICAgIC8vIGFyYzU4X2FkZFBsdWdpbigKICAgIC8vICAgcGx1Z2luOiB1aW50NjQsCiAgICAvLyAgIGNhbGxlcjogQWNjb3VudCwKICAgIC8vICAgZXNjcm93OiBzdHJpbmcsCiAgICAvLyAgIGFkbWluOiBib29sZWFuLAogICAgLy8gICBkZWxlZ2F0aW9uVHlwZTogVWludDgsCiAgICAvLyAgIGxhc3RWYWxpZDogdWludDY0LAogICAgLy8gICBjb29sZG93bjogdWludDY0LAogICAgLy8gICBtZXRob2RzOiBNZXRob2RSZXN0cmljdGlvbltdLAogICAgLy8gICB1c2VSb3VuZHM6IGJvb2xlYW4sCiAgICAvLyAgIHVzZUV4ZWN1dGlvbktleTogYm9vbGVhbiwKICAgIC8vICAgY292ZXJGZWVzOiBib29sZWFuLAogICAgLy8gICBjYW5SZWNsYWltOiBib29sZWFuLAogICAgLy8gICBkZWZhdWx0VG9Fc2Nyb3c6IGJvb2xlYW4KICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKYXJjNThfYWRkUGx1Z2luX3Rlcm5hcnlfZmFsc2VAMTY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEwMjMKICAgIC8vIGNvbnN0IGVwb2NoUmVmID0gdXNlUm91bmRzID8gR2xvYmFsLnJvdW5kIDogR2xvYmFsLmxhdGVzdFRpbWVzdGFtcDsKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGJ1cnkgMTYKICAgIGIgYXJjNThfYWRkUGx1Z2luX3Rlcm5hcnlfbWVyZ2VAMTcKCmFyYzU4X2FkZFBsdWdpbl9pZl9ib2R5QDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMDEwCiAgICAvLyBhc3NlcnQoZXNjcm93ICE9PSAnJywgRVJSX0VTQ1JPV19SRVFVSVJFRF9UT19CRV9TRVRfQVNfREVGQVVMVCkKICAgIGRpZyAxMQogICAgYnl0ZWNfMSAvLyAiIgogICAgIT0KICAgIGFzc2VydCAvLyBlc2Nyb3cgbXVzdCBiZSBzZXQgaWYgZGVmYXVsdFRvRXNjcm93IGlzIHRydWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTAxMQogICAgLy8gZXNjcm93S2V5ID0gJycKICAgIGJ5dGVjXzEgLy8gIiIKICAgIGJ1cnkgMTgKICAgIGIgYXJjNThfYWRkUGx1Z2luX2FmdGVyX2lmX2Vsc2VAMTEKCmFyYzU4X2FkZFBsdWdpbl9ib29sX2ZhbHNlQDg6CiAgICBpbnRjXzAgLy8gMAogICAgYiBhcmM1OF9hZGRQbHVnaW5fYm9vbF9tZXJnZUA5CgphcmM1OF9hZGRQbHVnaW5fYm9vbF9mYWxzZUA0OgogICAgaW50Y18wIC8vIDAKICAgIGIgYXJjNThfYWRkUGx1Z2luX2Jvb2xfbWVyZ2VANQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFzc2lnbkRvbWFpbltyb3V0aW5nXSgpIC0+IHZvaWQ6CmFzc2lnbkRvbWFpbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTA2MgogICAgLy8gYXNzaWduRG9tYWluKGNhbGxlcjogQWNjb3VudCwgZG9tYWluOiBzdHJpbmcpOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1dGY4W10pCiAgICBleHRyYWN0IDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMDYzCiAgICAvLyBhc3NlcnQodGhpcy5pc0FkbWluKCksIEVSUl9PTkxZX0FETUlOX0NBTl9BRERfUExVR0lOKQogICAgY2FsbHN1YiBpc0FkbWluCiAgICBhc3NlcnQgLy8gT25seSBhbiBhZG1pbiBjYW4gYWRkIGEgcGx1Z2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEwNjUKICAgIC8vIGlmICh0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlICE9PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcykgewogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTMyCiAgICAvLyBjb250cm9sbGVkQWRkcmVzcyA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcyB9KTsKICAgIGJ5dGVjXzAgLy8gImNvbnRyb2xsZWRfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTA2NQogICAgLy8gaWYgKHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUgIT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzKSB7CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgICE9CiAgICBieiBhc3NpZ25Eb21haW5fYWZ0ZXJfaWZfZWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEwNjYtMTA3MgogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IHRoaXMuZG9tYWluS2V5c01icihkb21haW4pCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMDY4CiAgICAvLyBzZW5kZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzIKICAgIC8vIGNvbnRyb2xsZWRBZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzIH0pOwogICAgYnl0ZWNfMCAvLyAiY29udHJvbGxlZF9hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMDY4CiAgICAvLyBzZW5kZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMDY5CiAgICAvLyByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyMTcKICAgIC8vIHJldHVybiBNaW5Eb21haW5LZXlzTUJSICsgKEJveENvc3RQZXJCeXRlICogQnl0ZXMoZG9tYWluKS5sZW5ndGgpCiAgICBkaWcgMgogICAgbGVuCiAgICBpbnRjIDQgLy8gNDAwCiAgICAqCiAgICBwdXNoaW50IDE1NzAwIC8vIDE1NzAwCiAgICArCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTA2Ni0xMDcxCiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICBzZW5kZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogdGhpcy5kb21haW5LZXlzTWJyKGRvbWFpbikKICAgIC8vICAgfSkKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTA2Ni0xMDcyCiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICBzZW5kZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogdGhpcy5kb21haW5LZXlzTWJyKGRvbWFpbikKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAoKYXNzaWduRG9tYWluX2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTgyCiAgICAvLyBkb21haW5LZXlzID0gQm94TWFwPEFjY291bnQsIHN0cmluZz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeERvbWFpbktleXMgfSkKICAgIGJ5dGVjIDE2IC8vICJkIgogICAgZGlnIDIKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMDc1CiAgICAvLyB0aGlzLmRvbWFpbktleXMoY2FsbGVyKS52YWx1ZSA9IGRvbWFpbgogICAgZHVwCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGRpZyAxCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEwNjIKICAgIC8vIGFzc2lnbkRvbWFpbihjYWxsZXI6IEFjY291bnQsIGRvbWFpbjogc3RyaW5nKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVtb3ZlUGx1Z2luW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjNThfcmVtb3ZlUGx1Z2luOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMDg1CiAgICAvLyBhcmM1OF9yZW1vdmVQbHVnaW4ocGx1Z2luOiB1aW50NjQsIGNhbGxlcjogQWNjb3VudCwgZXNjcm93OiBzdHJpbmcpOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTA4NgogICAgLy8gYXNzZXJ0KHRoaXMuaXNBZG1pbigpIHx8IHRoaXMuY2FuUmV2b2tlKCksIEVSUl9PTkxZX0FETUlOX09SX1JFVk9DQVRJT05fQVBQX0NBTl9SRU1PVkVfUExVR0lOKTsKICAgIGNhbGxzdWIgaXNBZG1pbgogICAgYm56IGFyYzU4X3JlbW92ZVBsdWdpbl9ib29sX3RydWVAMwogICAgY2FsbHN1YiBjYW5SZXZva2UKICAgIGJ6IGFyYzU4X3JlbW92ZVBsdWdpbl9ib29sX2ZhbHNlQDQKCmFyYzU4X3JlbW92ZVBsdWdpbl9ib29sX3RydWVAMzoKICAgIGludGNfMSAvLyAxCgphcmM1OF9yZW1vdmVQbHVnaW5fYm9vbF9tZXJnZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMDg2CiAgICAvLyBhc3NlcnQodGhpcy5pc0FkbWluKCkgfHwgdGhpcy5jYW5SZXZva2UoKSwgRVJSX09OTFlfQURNSU5fT1JfUkVWT0NBVElPTl9BUFBfQ0FOX1JFTU9WRV9QTFVHSU4pOwogICAgYXNzZXJ0IC8vIE9ubHkgYW4gYWRtaW4gb3IgcmV2b2NhdGlvbiBhcHAgY2FuIHJlbW92ZSBwbHVnaW5zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEwODgKICAgIC8vIGNvbnN0IGtleTogUGx1Z2luS2V5ID0geyBwbHVnaW4sIGNhbGxlcjogY2FsbGVyLCBlc2Nyb3cgfQogICAgZGlnIDIKICAgIGl0b2IKICAgIGRpZyAyCiAgICBjb25jYXQKICAgIGRpZyAxCiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgc3dhcAogICAgYnl0ZWMgMTEgLy8gMHgwMDJhCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjMKICAgIC8vIHBsdWdpbnMgPSBCb3hNYXA8UGx1Z2luS2V5LCBQbHVnaW5JbmZvPih7IGtleVByZWZpeDogQWJzdHJhY3RBY2NvdW50Qm94UHJlZml4UGx1Z2lucyB9KTsKICAgIGJ5dGVjXzMgLy8gInAiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTA4OQogICAgLy8gYXNzZXJ0KHRoaXMucGx1Z2lucyhrZXkpLmV4aXN0cywgRVJSX1BMVUdJTl9ET0VTX05PVF9FWElTVCkKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gUGx1Z2luIGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEwOTEKICAgIC8vIHRoaXMucGx1Z2lucyhrZXkpLmRlbGV0ZSgpOwogICAgYm94X2RlbAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0MgogICAgLy8gbGFzdFVzZXJJbnRlcmFjdGlvbiA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0xhc3RVc2VySW50ZXJhY3Rpb24gfSkKICAgIGJ5dGVjIDQgLy8gImxhc3RfdXNlcl9pbnRlcmFjdGlvbiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTg3CiAgICAvLyB0aGlzLmxhc3RVc2VySW50ZXJhY3Rpb24udmFsdWUgPSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDQKICAgIC8vIGxhc3RDaGFuZ2UgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNMYXN0Q2hhbmdlIH0pCiAgICBieXRlYyA2IC8vICJsYXN0X2NoYW5nZSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTkxCiAgICAvLyB0aGlzLmxhc3RDaGFuZ2UudmFsdWUgPSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMDg1CiAgICAvLyBhcmM1OF9yZW1vdmVQbHVnaW4ocGx1Z2luOiB1aW50NjQsIGNhbGxlcjogQWNjb3VudCwgZXNjcm93OiBzdHJpbmcpOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCmFyYzU4X3JlbW92ZVBsdWdpbl9ib29sX2ZhbHNlQDQ6CiAgICBpbnRjXzAgLy8gMAogICAgYiBhcmM1OF9yZW1vdmVQbHVnaW5fYm9vbF9tZXJnZUA1CgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfYWRkTmFtZWRQbHVnaW5bcm91dGluZ10oKSAtPiB2b2lkOgphcmM1OF9hZGROYW1lZFBsdWdpbjoKICAgIGludGNfMCAvLyAwCiAgICBkdXBuIDMKICAgIGJ5dGVjXzEgLy8gIiIKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMTE0LTExMjkKICAgIC8vIGFyYzU4X2FkZE5hbWVkUGx1Z2luKAogICAgLy8gICBuYW1lOiBzdHJpbmcsCiAgICAvLyAgIHBsdWdpbjogdWludDY0LAogICAgLy8gICBjYWxsZXI6IEFjY291bnQsCiAgICAvLyAgIGVzY3Jvdzogc3RyaW5nLAogICAgLy8gICBhZG1pbjogYm9vbGVhbiwKICAgIC8vICAgZGVsZWdhdGlvblR5cGU6IFVpbnQ4LAogICAgLy8gICBsYXN0VmFsaWQ6IHVpbnQ2NCwKICAgIC8vICAgY29vbGRvd246IHVpbnQ2NCwKICAgIC8vICAgbWV0aG9kczogTWV0aG9kUmVzdHJpY3Rpb25bXSwKICAgIC8vICAgdXNlUm91bmRzOiBib29sZWFuLAogICAgLy8gICB1c2VFeGVjdXRpb25LZXk6IGJvb2xlYW4sCiAgICAvLyAgIGNvdmVyRmVlczogYm9vbGVhbiwKICAgIC8vICAgY2FuUmVjbGFpbTogYm9vbGVhbiwKICAgIC8vICAgZGVmYXVsdFRvRXNjcm93OiBib29sZWFuCiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1dGY4W10pCiAgICBleHRyYWN0IDIgMAogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgc3dhcAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBjb3ZlciAyCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA2CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDgKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDcKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBjb3ZlciAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA4CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgY292ZXIgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgOQogICAgZHVwCiAgICBjb3ZlciAzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZHVwCiAgICBjb3ZlciA0CiAgICBwdXNoaW50IDEyIC8vIDEyCiAgICAqCiAgICBpbnRjXzIgLy8gMgogICAgKwogICAgc3dhcAogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuKyh1aW50OFs0XSx1aW50NjQpW10pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxMAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgY292ZXIgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMTEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIGNvdmVyIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBjb3ZlciAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgY292ZXIgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMTQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTEzMAogICAgLy8gYXNzZXJ0KHRoaXMuaXNBZG1pbigpLCBFUlJfQURNSU5fT05MWSk7CiAgICBjYWxsc3ViIGlzQWRtaW4KICAgIGFzc2VydCAvLyBhZG1pbiBvbmx5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE2NQogICAgLy8gbmFtZWRQbHVnaW5zID0gQm94TWFwPHN0cmluZywgUGx1Z2luS2V5Pih7IGtleVByZWZpeDogQWJzdHJhY3RBY2NvdW50Qm94UHJlZml4TmFtZWRQbHVnaW5zIH0pOwogICAgYnl0ZWMgMTUgLy8gIm4iCiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgZHVwCiAgICBjb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjExMzEKICAgIC8vIGFzc2VydCghdGhpcy5uYW1lZFBsdWdpbnMobmFtZSkuZXhpc3RzKTsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgIQogICAgYXNzZXJ0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjExMzQKICAgIC8vIGRlbGVnYXRpb25UeXBlID09PSBEZWxlZ2F0aW9uVHlwZVNlbGYgJiYKICAgIGJ5dGVjIDE0IC8vIDB4MDEKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjExMzQtMTEzNQogICAgLy8gZGVsZWdhdGlvblR5cGUgPT09IERlbGVnYXRpb25UeXBlU2VsZiAmJgogICAgLy8gY2FsbGVyID09PSBHbG9iYWwuemVyb0FkZHJlc3MKICAgIGJ6IGFyYzU4X2FkZE5hbWVkUGx1Z2luX2Jvb2xfZmFsc2VANAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMTM1CiAgICAvLyBjYWxsZXIgPT09IEdsb2JhbC56ZXJvQWRkcmVzcwogICAgZGlnIDEzCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjExMzQtMTEzNQogICAgLy8gZGVsZWdhdGlvblR5cGUgPT09IERlbGVnYXRpb25UeXBlU2VsZiAmJgogICAgLy8gY2FsbGVyID09PSBHbG9iYWwuemVyb0FkZHJlc3MKICAgIGJ6IGFyYzU4X2FkZE5hbWVkUGx1Z2luX2Jvb2xfZmFsc2VANAogICAgaW50Y18xIC8vIDEKCmFyYzU4X2FkZE5hbWVkUGx1Z2luX2Jvb2xfbWVyZ2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTEzMy0xMTM2CiAgICAvLyAhKAogICAgLy8gICBkZWxlZ2F0aW9uVHlwZSA9PT0gRGVsZWdhdGlvblR5cGVTZWxmICYmCiAgICAvLyAgIGNhbGxlciA9PT0gR2xvYmFsLnplcm9BZGRyZXNzCiAgICAvLyApLAogICAgIQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMTMyLTExMzgKICAgIC8vIGFzc2VydCgKICAgIC8vICAgISgKICAgIC8vICAgICBkZWxlZ2F0aW9uVHlwZSA9PT0gRGVsZWdhdGlvblR5cGVTZWxmICYmCiAgICAvLyAgICAgY2FsbGVyID09PSBHbG9iYWwuemVyb0FkZHJlc3MKICAgIC8vICAgKSwKICAgIC8vICAgRVJSX1pFUk9fQUREUkVTU19ERUxFR0FUSU9OX1RZUEUKICAgIC8vICkKICAgIGFzc2VydCAvLyBkZWxlZ2F0aW9uIHR5cGUgbXVzdCBub3QgYmUgc2VsZiBmb3IgZ2xvYmFsIHBsdWdpbnMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTE0MS0xMTQyCiAgICAvLyB1c2VFeGVjdXRpb25LZXkgJiYKICAgIC8vIGNhbGxlciAhPT0gR2xvYmFsLnplcm9BZGRyZXNzCiAgICBkaWcgNAogICAgYnogYXJjNThfYWRkTmFtZWRQbHVnaW5fYm9vbF9mYWxzZUA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjExNDIKICAgIC8vIGNhbGxlciAhPT0gR2xvYmFsLnplcm9BZGRyZXNzCiAgICBkaWcgMTMKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgIT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTE0MS0xMTQyCiAgICAvLyB1c2VFeGVjdXRpb25LZXkgJiYKICAgIC8vIGNhbGxlciAhPT0gR2xvYmFsLnplcm9BZGRyZXNzCiAgICBieiBhcmM1OF9hZGROYW1lZFBsdWdpbl9ib29sX2ZhbHNlQDgKICAgIGludGNfMSAvLyAxCgphcmM1OF9hZGROYW1lZFBsdWdpbl9ib29sX21lcmdlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjExNDAtMTE0MwogICAgLy8gISgKICAgIC8vICAgdXNlRXhlY3V0aW9uS2V5ICYmCiAgICAvLyAgIGNhbGxlciAhPT0gR2xvYmFsLnplcm9BZGRyZXNzCiAgICAvLyApLAogICAgIQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMTM5LTExNDUKICAgIC8vIGFzc2VydCgKICAgIC8vICAgISgKICAgIC8vICAgICB1c2VFeGVjdXRpb25LZXkgJiYKICAgIC8vICAgICBjYWxsZXIgIT09IEdsb2JhbC56ZXJvQWRkcmVzcwogICAgLy8gICApLAogICAgLy8gICBFUlJfVVNJTkdfRVhFQ1VUSU9OX0tFWV9SRVFVSVJFU19HTE9CQUwKICAgIC8vICkKICAgIGFzc2VydCAvLyB1c2luZyBleGVjdXRpb24ga2V5IHJlcXVpcmVzIGdsb2JhbCBwbHVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTE0OAogICAgLy8gaWYgKGRlZmF1bHRUb0VzY3JvdykgewogICAgZGlnIDEKICAgIGJueiBhcmM1OF9hZGROYW1lZFBsdWdpbl9pZl9ib2R5QDEwCiAgICBkaWcgMTIKICAgIGJ1cnkgMjEKCmFyYzU4X2FkZE5hbWVkUGx1Z2luX2FmdGVyX2lmX2Vsc2VAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjExNTMKICAgIC8vIGNvbnN0IGtleTogUGx1Z2luS2V5ID0geyBwbHVnaW4sIGNhbGxlcjogY2FsbGVyLCBlc2Nyb3c6IGVzY3Jvd0tleSB9CiAgICBkaWcgMTQKICAgIGl0b2IKICAgIGRpZyAxNAogICAgY29uY2F0CiAgICBkaWcgMjEKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBzd2FwCiAgICBieXRlYyAxMSAvLyAweDAwMmEKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGJ1cnkgMjEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTE1NAogICAgLy8gdGhpcy5uYW1lZFBsdWdpbnMobmFtZSkudmFsdWUgPSBjbG9uZShrZXkpCiAgICBkaWcgMQogICAgZHVwCiAgICBib3hfZGVsCiAgICBwb3AKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTE1NgogICAgLy8gbGV0IG1ldGhvZEluZm9zOiBNZXRob2RJbmZvW10gPSBbXQogICAgaW50Y18wIC8vIDAKICAgIGl0b2IKICAgIGJ1cnkgMjIKICAgIGJ5dGVjIDcgLy8gMHgwMDAwCiAgICBidXJ5IDE5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjExNTcKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSArPSAxKSB7CiAgICBpbnRjXzAgLy8gMAogICAgYnVyeSAxNwoKYXJjNThfYWRkTmFtZWRQbHVnaW5fd2hpbGVfdG9wQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMTU3CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkgKz0gMSkgewogICAgZGlnIDE2CiAgICBkaWcgNwogICAgPAogICAgYnogYXJjNThfYWRkTmFtZWRQbHVnaW5fYWZ0ZXJfd2hpbGVAMTQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTE1OAogICAgLy8gbWV0aG9kSW5mb3MucHVzaCh7IC4uLm1ldGhvZHNbaV0sIGxhc3RDYWxsZWQ6IDAgfSkKICAgIGRpZyA3CiAgICBleHRyYWN0IDIgMAogICAgZGlnIDE3CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIHB1c2hpbnQgMTIgLy8gMTIKICAgICoKICAgIHB1c2hpbnQgMTIgLy8gMTIKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBpbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZHVwCiAgICBleHRyYWN0IDAgNAogICAgc3dhcAogICAgZXh0cmFjdCA0IDgKICAgIGRpZyAxCiAgICBsZW4KICAgIHB1c2hpbnQgNCAvLyA0CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgc2l6ZQogICAgY29uY2F0CiAgICBkaWcgMjMKICAgIGNvbmNhdAogICAgZGlnIDIwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgY29uY2F0IC8vIG9uIGVycm9yOiBtYXggYXJyYXkgbGVuZ3RoIGV4Y2VlZGVkCiAgICBzd2FwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgcmVwbGFjZTIgMAogICAgYnVyeSAyMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMTU3CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkgKz0gMSkgewogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgMTcKICAgIGIgYXJjNThfYWRkTmFtZWRQbHVnaW5fd2hpbGVfdG9wQDEyCgphcmM1OF9hZGROYW1lZFBsdWdpbl9hZnRlcl93aGlsZUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTE2MQogICAgLy8gaWYgKHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUgIT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzKSB7CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzIKICAgIC8vIGNvbnRyb2xsZWRBZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzIH0pOwogICAgYnl0ZWNfMCAvLyAiY29udHJvbGxlZF9hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMTYxCiAgICAvLyBpZiAodGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSAhPT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MpIHsKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgIT0KICAgIGJ6IGFyYzU4X2FkZE5hbWVkUGx1Z2luX2FmdGVyX2lmX2Vsc2VAMTcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTE2Mi0xMTY4CiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICBzZW5kZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogdGhpcy5wbHVnaW5zTWJyKGVzY3Jvd0tleSwgbWV0aG9kSW5mb3MubGVuZ3RoKSArIHRoaXMubmFtZWRQbHVnaW5zTWJyKG5hbWUpCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMTY0CiAgICAvLyBzZW5kZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzIKICAgIC8vIGNvbnRyb2xsZWRBZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzIH0pOwogICAgYnl0ZWNfMCAvLyAiY29udHJvbGxlZF9hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMTY0CiAgICAvLyBzZW5kZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMTY1CiAgICAvLyByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMTY2CiAgICAvLyBhbW91bnQ6IHRoaXMucGx1Z2luc01icihlc2Nyb3dLZXksIG1ldGhvZEluZm9zLmxlbmd0aCkgKyB0aGlzLm5hbWVkUGx1Z2luc01icihuYW1lKQogICAgZGlnIDIwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGRpZyAyMwogICAgc3dhcAogICAgY2FsbHN1YiBwbHVnaW5zTWJyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjIwMQogICAgLy8gcmV0dXJuIE1pbk5hbWVkUGx1Z2luTUJSICsgKEJveENvc3RQZXJCeXRlICogQnl0ZXMobmFtZSkubGVuZ3RoKTsKICAgIGRpZyAxOAogICAgbGVuCiAgICBpbnRjIDQgLy8gNDAwCiAgICAqCiAgICBpbnRjIDUgLy8gMTg5MDAKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTE2NgogICAgLy8gYW1vdW50OiB0aGlzLnBsdWdpbnNNYnIoZXNjcm93S2V5LCBtZXRob2RJbmZvcy5sZW5ndGgpICsgdGhpcy5uYW1lZFBsdWdpbnNNYnIobmFtZSkKICAgICsKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMTYyLTExNjcKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHNlbmRlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50OiB0aGlzLnBsdWdpbnNNYnIoZXNjcm93S2V5LCBtZXRob2RJbmZvcy5sZW5ndGgpICsgdGhpcy5uYW1lZFBsdWdpbnNNYnIobmFtZSkKICAgIC8vICAgfSkKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTE2Mi0xMTY4CiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICBzZW5kZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogdGhpcy5wbHVnaW5zTWJyKGVzY3Jvd0tleSwgbWV0aG9kSW5mb3MubGVuZ3RoKSArIHRoaXMubmFtZWRQbHVnaW5zTWJyKG5hbWUpCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCmFyYzU4X2FkZE5hbWVkUGx1Z2luX2FmdGVyX2lmX2Vsc2VAMTc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjExNzEKICAgIC8vIGNvbnN0IGVzY3Jvd0lEID0gdGhpcy5tYXliZU5ld0VzY3Jvdyhlc2Nyb3cpOwogICAgZGlnIDEyCiAgICBjYWxsc3ViIG1heWJlTmV3RXNjcm93CiAgICBidXJ5IDE4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjExNzMKICAgIC8vIGNvbnN0IGVwb2NoUmVmID0gdXNlUm91bmRzID8gR2xvYmFsLnJvdW5kIDogR2xvYmFsLmxhdGVzdFRpbWVzdGFtcDsKICAgIGRpZyA1CiAgICBieiBhcmM1OF9hZGROYW1lZFBsdWdpbl90ZXJuYXJ5X2ZhbHNlQDE5CiAgICBnbG9iYWwgUm91bmQKCmFyYzU4X2FkZE5hbWVkUGx1Z2luX3Rlcm5hcnlfbWVyZ2VAMjA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjExODUKICAgIC8vIGNhblJlY2xhaW06IGVzY3JvdyAhPT0gJycgPyBjYW5SZWNsYWltIDogZmFsc2UsCiAgICBkaWcgMTMKICAgIGJ5dGVjXzEgLy8gIiIKICAgICE9CiAgICBpbnRjXzAgLy8gMAogICAgZGlnIDUKICAgIHVuY292ZXIgMgogICAgc2VsZWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjExNzUtMTE4OAogICAgLy8gdGhpcy5wbHVnaW5zKGtleSkudmFsdWUgPSB7CiAgICAvLyAgIGVzY3JvdzogZXNjcm93SUQsCiAgICAvLyAgIGFkbWluLAogICAgLy8gICBkZWxlZ2F0aW9uVHlwZSwKICAgIC8vICAgbGFzdFZhbGlkLAogICAgLy8gICBjb29sZG93biwKICAgIC8vICAgbWV0aG9kczogY2xvbmUobWV0aG9kSW5mb3MpLAogICAgLy8gICB1c2VSb3VuZHMsCiAgICAvLyAgIHVzZUV4ZWN1dGlvbktleSwKICAgIC8vICAgY292ZXJGZWVzLAogICAgLy8gICBjYW5SZWNsYWltOiBlc2Nyb3cgIT09ICcnID8gY2FuUmVjbGFpbSA6IGZhbHNlLAogICAgLy8gICBsYXN0Q2FsbGVkOiAwLAogICAgLy8gICBzdGFydDogZXBvY2hSZWYKICAgIC8vIH0KICAgIGRpZyAxOQogICAgaXRvYgogICAgZGlnIDEzCiAgICBjb25jYXQKICAgIGRpZyAxMgogICAgaXRvYgogICAgY29uY2F0CiAgICBkaWcgMTEKICAgIGl0b2IKICAgIGNvbmNhdAogICAgYnl0ZWMgMzAgLy8gMHgwMDJjCiAgICBjb25jYXQKICAgIGJ5dGVjIDggLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIGRpZyAxNgogICAgc2V0Yml0CiAgICBpbnRjXzEgLy8gMQogICAgZGlnIDEwCiAgICBzZXRiaXQKICAgIGludGNfMiAvLyAyCiAgICBkaWcgOQogICAgc2V0Yml0CiAgICBwdXNoaW50IDMgLy8gMwogICAgZGlnIDgKICAgIHNldGJpdAogICAgcHVzaGludCA0IC8vIDQKICAgIHVuY292ZXIgMwogICAgc2V0Yml0CiAgICBjb25jYXQKICAgIGRpZyAyMwogICAgY29uY2F0CiAgICBzd2FwCiAgICBpdG9iCiAgICBjb25jYXQKICAgIGRpZyAxOQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE2MwogICAgLy8gcGx1Z2lucyA9IEJveE1hcDxQbHVnaW5LZXksIFBsdWdpbkluZm8+KHsga2V5UHJlZml4OiBBYnN0cmFjdEFjY291bnRCb3hQcmVmaXhQbHVnaW5zIH0pOwogICAgYnl0ZWNfMyAvLyAicCIKICAgIGRpZyAyMQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjExNzUtMTE4OAogICAgLy8gdGhpcy5wbHVnaW5zKGtleSkudmFsdWUgPSB7CiAgICAvLyAgIGVzY3JvdzogZXNjcm93SUQsCiAgICAvLyAgIGFkbWluLAogICAgLy8gICBkZWxlZ2F0aW9uVHlwZSwKICAgIC8vICAgbGFzdFZhbGlkLAogICAgLy8gICBjb29sZG93biwKICAgIC8vICAgbWV0aG9kczogY2xvbmUobWV0aG9kSW5mb3MpLAogICAgLy8gICB1c2VSb3VuZHMsCiAgICAvLyAgIHVzZUV4ZWN1dGlvbktleSwKICAgIC8vICAgY292ZXJGZWVzLAogICAgLy8gICBjYW5SZWNsYWltOiBlc2Nyb3cgIT09ICcnID8gY2FuUmVjbGFpbSA6IGZhbHNlLAogICAgLy8gICBsYXN0Q2FsbGVkOiAwLAogICAgLy8gICBzdGFydDogZXBvY2hSZWYKICAgIC8vIH0KICAgIGR1cAogICAgYm94X2RlbAogICAgcG9wCiAgICBzd2FwCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0MgogICAgLy8gbGFzdFVzZXJJbnRlcmFjdGlvbiA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0xhc3RVc2VySW50ZXJhY3Rpb24gfSkKICAgIGJ5dGVjIDQgLy8gImxhc3RfdXNlcl9pbnRlcmFjdGlvbiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTg3CiAgICAvLyB0aGlzLmxhc3RVc2VySW50ZXJhY3Rpb24udmFsdWUgPSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDQKICAgIC8vIGxhc3RDaGFuZ2UgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNMYXN0Q2hhbmdlIH0pCiAgICBieXRlYyA2IC8vICJsYXN0X2NoYW5nZSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTkxCiAgICAvLyB0aGlzLmxhc3RDaGFuZ2UudmFsdWUgPSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMTE0LTExMjkKICAgIC8vIGFyYzU4X2FkZE5hbWVkUGx1Z2luKAogICAgLy8gICBuYW1lOiBzdHJpbmcsCiAgICAvLyAgIHBsdWdpbjogdWludDY0LAogICAgLy8gICBjYWxsZXI6IEFjY291bnQsCiAgICAvLyAgIGVzY3Jvdzogc3RyaW5nLAogICAgLy8gICBhZG1pbjogYm9vbGVhbiwKICAgIC8vICAgZGVsZWdhdGlvblR5cGU6IFVpbnQ4LAogICAgLy8gICBsYXN0VmFsaWQ6IHVpbnQ2NCwKICAgIC8vICAgY29vbGRvd246IHVpbnQ2NCwKICAgIC8vICAgbWV0aG9kczogTWV0aG9kUmVzdHJpY3Rpb25bXSwKICAgIC8vICAgdXNlUm91bmRzOiBib29sZWFuLAogICAgLy8gICB1c2VFeGVjdXRpb25LZXk6IGJvb2xlYW4sCiAgICAvLyAgIGNvdmVyRmVlczogYm9vbGVhbiwKICAgIC8vICAgY2FuUmVjbGFpbTogYm9vbGVhbiwKICAgIC8vICAgZGVmYXVsdFRvRXNjcm93OiBib29sZWFuCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCmFyYzU4X2FkZE5hbWVkUGx1Z2luX3Rlcm5hcnlfZmFsc2VAMTk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjExNzMKICAgIC8vIGNvbnN0IGVwb2NoUmVmID0gdXNlUm91bmRzID8gR2xvYmFsLnJvdW5kIDogR2xvYmFsLmxhdGVzdFRpbWVzdGFtcDsKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGIgYXJjNThfYWRkTmFtZWRQbHVnaW5fdGVybmFyeV9tZXJnZUAyMAoKYXJjNThfYWRkTmFtZWRQbHVnaW5faWZfYm9keUAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTE0OQogICAgLy8gYXNzZXJ0KGVzY3JvdyAhPT0gJycsIEVSUl9FU0NST1dfUkVRVUlSRURfVE9fQkVfU0VUX0FTX0RFRkFVTFQpCiAgICBkaWcgMTIKICAgIGJ5dGVjXzEgLy8gIiIKICAgICE9CiAgICBhc3NlcnQgLy8gZXNjcm93IG11c3QgYmUgc2V0IGlmIGRlZmF1bHRUb0VzY3JvdyBpcyB0cnVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjExNTAKICAgIC8vIGVzY3Jvd0tleSA9ICcnCiAgICBieXRlY18xIC8vICIiCiAgICBidXJ5IDIxCiAgICBiIGFyYzU4X2FkZE5hbWVkUGx1Z2luX2FmdGVyX2lmX2Vsc2VAMTEKCmFyYzU4X2FkZE5hbWVkUGx1Z2luX2Jvb2xfZmFsc2VAODoKICAgIGludGNfMCAvLyAwCiAgICBiIGFyYzU4X2FkZE5hbWVkUGx1Z2luX2Jvb2xfbWVyZ2VAOQoKYXJjNThfYWRkTmFtZWRQbHVnaW5fYm9vbF9mYWxzZUA0OgogICAgaW50Y18wIC8vIDAKICAgIGIgYXJjNThfYWRkTmFtZWRQbHVnaW5fYm9vbF9tZXJnZUA1CgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVtb3ZlTmFtZWRQbHVnaW5bcm91dGluZ10oKSAtPiB2b2lkOgphcmM1OF9yZW1vdmVOYW1lZFBsdWdpbjoKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjExOTkKICAgIC8vIGFyYzU4X3JlbW92ZU5hbWVkUGx1Z2luKG5hbWU6IHN0cmluZyk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyMDAKICAgIC8vIGFzc2VydCh0aGlzLmlzQWRtaW4oKSB8fCB0aGlzLmNhblJldm9rZSgpLCBFUlJfT05MWV9BRE1JTl9PUl9SRVZPQ0FUSU9OX0FQUF9DQU5fUkVNT1ZFX1BMVUdJTik7CiAgICBjYWxsc3ViIGlzQWRtaW4KICAgIGJueiBhcmM1OF9yZW1vdmVOYW1lZFBsdWdpbl9ib29sX3RydWVAMwogICAgY2FsbHN1YiBjYW5SZXZva2UKICAgIGJ6IGFyYzU4X3JlbW92ZU5hbWVkUGx1Z2luX2Jvb2xfZmFsc2VANAoKYXJjNThfcmVtb3ZlTmFtZWRQbHVnaW5fYm9vbF90cnVlQDM6CiAgICBpbnRjXzEgLy8gMQoKYXJjNThfcmVtb3ZlTmFtZWRQbHVnaW5fYm9vbF9tZXJnZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMjAwCiAgICAvLyBhc3NlcnQodGhpcy5pc0FkbWluKCkgfHwgdGhpcy5jYW5SZXZva2UoKSwgRVJSX09OTFlfQURNSU5fT1JfUkVWT0NBVElPTl9BUFBfQ0FOX1JFTU9WRV9QTFVHSU4pOwogICAgYXNzZXJ0IC8vIE9ubHkgYW4gYWRtaW4gb3IgcmV2b2NhdGlvbiBhcHAgY2FuIHJlbW92ZSBwbHVnaW5zCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE2NQogICAgLy8gbmFtZWRQbHVnaW5zID0gQm94TWFwPHN0cmluZywgUGx1Z2luS2V5Pih7IGtleVByZWZpeDogQWJzdHJhY3RBY2NvdW50Qm94UHJlZml4TmFtZWRQbHVnaW5zIH0pOwogICAgYnl0ZWMgMTUgLy8gIm4iCiAgICBkaWcgMQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyMDEKICAgIC8vIGFzc2VydCh0aGlzLm5hbWVkUGx1Z2lucyhuYW1lKS5leGlzdHMsIEVSUl9QTFVHSU5fRE9FU19OT1RfRVhJU1QpOwogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBQbHVnaW4gZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTIwMgogICAgLy8gY29uc3QgYXBwID0gY2xvbmUodGhpcy5uYW1lZFBsdWdpbnMobmFtZSkudmFsdWUpCiAgICBkdXAKICAgIGJveF9nZXQKICAgIHBvcAogICAgZHVwCiAgICBidXJ5IDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTYzCiAgICAvLyBwbHVnaW5zID0gQm94TWFwPFBsdWdpbktleSwgUGx1Z2luSW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeFBsdWdpbnMgfSk7CiAgICBieXRlY18zIC8vICJwIgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyMDMKICAgIC8vIGFzc2VydCh0aGlzLnBsdWdpbnMoYXBwKS5leGlzdHMsIEVSUl9QTFVHSU5fRE9FU19OT1RfRVhJU1QpOwogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBQbHVnaW4gZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTIwNQogICAgLy8gY29uc3QgbWV0aG9kc0xlbmd0aDogdWludDY0ID0gdGhpcy5wbHVnaW5zKGFwcCkudmFsdWUubWV0aG9kcy5sZW5ndGgKICAgIGR1cAogICAgcHVzaGludCA0NCAvLyA0NAogICAgaW50Y18yIC8vIDIKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBidXJ5IDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTIwNwogICAgLy8gdGhpcy5uYW1lZFBsdWdpbnMobmFtZSkuZGVsZXRlKCk7CiAgICBzd2FwCiAgICBib3hfZGVsCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTIwOAogICAgLy8gdGhpcy5wbHVnaW5zKGFwcCkuZGVsZXRlKCk7CiAgICBib3hfZGVsCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTIxMAogICAgLy8gaWYgKHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUgIT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzKSB7CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzIKICAgIC8vIGNvbnRyb2xsZWRBZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzIH0pOwogICAgYnl0ZWNfMCAvLyAiY29udHJvbGxlZF9hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMjEwCiAgICAvLyBpZiAodGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSAhPT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MpIHsKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgIT0KICAgIGJ6IGFyYzU4X3JlbW92ZU5hbWVkUGx1Z2luX2FmdGVyX2lmX2Vsc2VAOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMjExLTEyMTYKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHJlY2VpdmVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIGFtb3VudDogdGhpcy5uYW1lZFBsdWdpbnNNYnIobmFtZSkgKyB0aGlzLnBsdWdpbnNNYnIoYXBwLmVzY3JvdywgbWV0aG9kc0xlbmd0aCkKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyMTMKICAgIC8vIHJlY2VpdmVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTMyCiAgICAvLyBjb250cm9sbGVkQWRkcmVzcyA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcyB9KTsKICAgIGJ5dGVjXzAgLy8gImNvbnRyb2xsZWRfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTIxMwogICAgLy8gcmVjZWl2ZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyMDEKICAgIC8vIHJldHVybiBNaW5OYW1lZFBsdWdpbk1CUiArIChCb3hDb3N0UGVyQnl0ZSAqIEJ5dGVzKG5hbWUpLmxlbmd0aCk7CiAgICBkaWcgMQogICAgbGVuCiAgICBpbnRjIDQgLy8gNDAwCiAgICAqCiAgICBpbnRjIDUgLy8gMTg5MDAKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTIxNAogICAgLy8gYW1vdW50OiB0aGlzLm5hbWVkUGx1Z2luc01icihuYW1lKSArIHRoaXMucGx1Z2luc01icihhcHAuZXNjcm93LCBtZXRob2RzTGVuZ3RoKQogICAgZGlnIDQKICAgIGR1cAogICAgcHVzaGludCA0MCAvLyA0MAogICAgZXh0cmFjdF91aW50MTYKICAgIGRpZyAxCiAgICBsZW4KICAgIHN1YnN0cmluZzMKICAgIGV4dHJhY3QgMiAwCiAgICBkaWcgNAogICAgY2FsbHN1YiBwbHVnaW5zTWJyCiAgICArCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMjExLTEyMTUKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHJlY2VpdmVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIGFtb3VudDogdGhpcy5uYW1lZFBsdWdpbnNNYnIobmFtZSkgKyB0aGlzLnBsdWdpbnNNYnIoYXBwLmVzY3JvdywgbWV0aG9kc0xlbmd0aCkKICAgIC8vICAgfSkKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTIxMS0xMjE2CiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICByZWNlaXZlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIC8vICAgICBhbW91bnQ6IHRoaXMubmFtZWRQbHVnaW5zTWJyKG5hbWUpICsgdGhpcy5wbHVnaW5zTWJyKGFwcC5lc2Nyb3csIG1ldGhvZHNMZW5ndGgpCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCmFyYzU4X3JlbW92ZU5hbWVkUGx1Z2luX2FmdGVyX2lmX2Vsc2VAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQyCiAgICAvLyBsYXN0VXNlckludGVyYWN0aW9uID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzTGFzdFVzZXJJbnRlcmFjdGlvbiB9KQogICAgYnl0ZWMgNCAvLyAibGFzdF91c2VyX2ludGVyYWN0aW9uIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxODcKICAgIC8vIHRoaXMubGFzdFVzZXJJbnRlcmFjdGlvbi52YWx1ZSA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0NAogICAgLy8gbGFzdENoYW5nZSA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0xhc3RDaGFuZ2UgfSkKICAgIGJ5dGVjIDYgLy8gImxhc3RfY2hhbmdlIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxOTEKICAgIC8vIHRoaXMubGFzdENoYW5nZS52YWx1ZSA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjExOTkKICAgIC8vIGFyYzU4X3JlbW92ZU5hbWVkUGx1Z2luKG5hbWU6IHN0cmluZyk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKYXJjNThfcmVtb3ZlTmFtZWRQbHVnaW5fYm9vbF9mYWxzZUA0OgogICAgaW50Y18wIC8vIDAKICAgIGIgYXJjNThfcmVtb3ZlTmFtZWRQbHVnaW5fYm9vbF9tZXJnZUA1CgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfbmV3RXNjcm93W3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjNThfbmV3RXNjcm93OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMjI4CiAgICAvLyBhcmM1OF9uZXdFc2Nyb3coZXNjcm93OiBzdHJpbmcpOiB1aW50NjQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyMjkKICAgIC8vIGFzc2VydCh0aGlzLmlzQWRtaW4oKSwgRVJSX0FETUlOX09OTFkpOwogICAgY2FsbHN1YiBpc0FkbWluCiAgICBhc3NlcnQgLy8gYWRtaW4gb25seQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjcKICAgIC8vIGVzY3Jvd3MgPSBCb3hNYXA8c3RyaW5nLCBFc2Nyb3dJbmZvPih7IGtleVByZWZpeDogQWJzdHJhY3RBY2NvdW50Qm94UHJlZml4RXNjcm93cyB9KQogICAgYnl0ZWNfMiAvLyAiZSIKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTIzMAogICAgLy8gYXNzZXJ0KCF0aGlzLmVzY3Jvd3MoZXNjcm93KS5leGlzdHMsIEVSUl9FU0NST1dfQUxSRUFEWV9FWElTVFMpOwogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICAhCiAgICBhc3NlcnQgLy8gRXNjcm93IGFscmVhZHkgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyMzEKICAgIC8vIGFzc2VydChlc2Nyb3cgIT09ICcnLCBFUlJfRVNDUk9XX05BTUVfUkVRVUlSRUQpOwogICAgZHVwCiAgICBieXRlY18xIC8vICIiCiAgICAhPQogICAgYXNzZXJ0IC8vIEVzY3JvdyBuYW1lIGlzIHJlcXVpcmVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyMzIKICAgIC8vIHJldHVybiB0aGlzLm5ld0VzY3Jvdyhlc2Nyb3cpOwogICAgY2FsbHN1YiBuZXdFc2Nyb3cKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTIyOAogICAgLy8gYXJjNThfbmV3RXNjcm93KGVzY3Jvdzogc3RyaW5nKTogdWludDY0IHsKICAgIGl0b2IKICAgIGJ5dGVjIDUgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF90b2dnbGVFc2Nyb3dMb2NrW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjNThfdG9nZ2xlRXNjcm93TG9jazoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTI0MAogICAgLy8gYXJjNThfdG9nZ2xlRXNjcm93TG9jayhlc2Nyb3c6IHN0cmluZyk6IEVzY3Jvd0luZm8gewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyNDEKICAgIC8vIGFzc2VydCh0aGlzLmlzQWRtaW4oKSwgRVJSX0ZPUkJJRERFTik7CiAgICBjYWxsc3ViIGlzQWRtaW4KICAgIGFzc2VydCAvLyBvbmx5IHRoZSBjcmVhdG9yIHdhbGxldCBjYW4gZGVsZXRlIGEgc3BlbmRpbmcgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjcKICAgIC8vIGVzY3Jvd3MgPSBCb3hNYXA8c3RyaW5nLCBFc2Nyb3dJbmZvPih7IGtleVByZWZpeDogQWJzdHJhY3RBY2NvdW50Qm94UHJlZml4RXNjcm93cyB9KQogICAgYnl0ZWNfMiAvLyAiZSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMjQyCiAgICAvLyBhc3NlcnQodGhpcy5lc2Nyb3dzKGVzY3JvdykuZXhpc3RzLCBFUlJfRVNDUk9XX0RPRVNfTk9UX0VYSVNUKTsKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gRXNjcm93IGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyNDQKICAgIC8vIHRoaXMuZXNjcm93cyhlc2Nyb3cpLnZhbHVlLmxvY2tlZCA9ICF0aGlzLmVzY3Jvd3MoZXNjcm93KS52YWx1ZS5sb2NrZWQ7CiAgICBkdXAKICAgIGJveF9nZXQKICAgIHBvcAogICAgcHVzaGludCA2NCAvLyA2NAogICAgZ2V0Yml0CiAgICAhCiAgICBkaWcgMQogICAgaW50Y18zIC8vIDgKICAgIGludGNfMSAvLyAxCiAgICBib3hfZXh0cmFjdAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBkaWcgMQogICAgaW50Y18zIC8vIDgKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQyCiAgICAvLyBsYXN0VXNlckludGVyYWN0aW9uID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzTGFzdFVzZXJJbnRlcmFjdGlvbiB9KQogICAgYnl0ZWMgNCAvLyAibGFzdF91c2VyX2ludGVyYWN0aW9uIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxODcKICAgIC8vIHRoaXMubGFzdFVzZXJJbnRlcmFjdGlvbi52YWx1ZSA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0NAogICAgLy8gbGFzdENoYW5nZSA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0xhc3RDaGFuZ2UgfSkKICAgIGJ5dGVjIDYgLy8gImxhc3RfY2hhbmdlIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxOTEKICAgIC8vIHRoaXMubGFzdENoYW5nZS52YWx1ZSA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyNDkKICAgIC8vIHJldHVybiB0aGlzLmVzY3Jvd3MoZXNjcm93KS52YWx1ZTsKICAgIGJveF9nZXQKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMjQwCiAgICAvLyBhcmM1OF90b2dnbGVFc2Nyb3dMb2NrKGVzY3Jvdzogc3RyaW5nKTogRXNjcm93SW5mbyB7CiAgICBieXRlYyA1IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVjbGFpbVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzU4X3JlY2xhaW06CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyNTgKICAgIC8vIGFyYzU4X3JlY2xhaW0oZXNjcm93OiBzdHJpbmcsIHJlY2xhaW1zOiBFc2Nyb3dSZWNsYWltW10pOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1dGY4W10pCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMTcgLy8gMTcKICAgICoKICAgIGludGNfMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuKyh1aW50NjQsdWludDY0LGJvb2wxKVtdKQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMjU5CiAgICAvLyBhc3NlcnQodGhpcy5pc0FkbWluKCksIEVSUl9GT1JCSURERU4pOwogICAgY2FsbHN1YiBpc0FkbWluCiAgICBhc3NlcnQgLy8gb25seSB0aGUgY3JlYXRvciB3YWxsZXQgY2FuIGRlbGV0ZSBhIHNwZW5kaW5nIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTY3CiAgICAvLyBlc2Nyb3dzID0gQm94TWFwPHN0cmluZywgRXNjcm93SW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeEVzY3Jvd3MgfSkKICAgIGJ5dGVjXzIgLy8gImUiCiAgICBkaWcgMgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyNjAKICAgIC8vIGFzc2VydCh0aGlzLmVzY3Jvd3MoZXNjcm93KS5leGlzdHMsIEVSUl9FU0NST1dfRE9FU19OT1RfRVhJU1QpOwogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gRXNjcm93IGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyNjEKICAgIC8vIHRoaXMucmVjbGFpbShlc2Nyb3csIHJlY2xhaW1zLCB0cnVlKTsKICAgIGludGNfMSAvLyAxCiAgICBjYWxsc3ViIHJlY2xhaW0KICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMjU4CiAgICAvLyBhcmM1OF9yZWNsYWltKGVzY3Jvdzogc3RyaW5nLCByZWNsYWltczogRXNjcm93UmVjbGFpbVtdKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcGx1Z2luUmVjbGFpbVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzU4X3BsdWdpblJlY2xhaW06CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyNzMtMTI3OAogICAgLy8gYXJjNThfcGx1Z2luUmVjbGFpbSgKICAgIC8vICAgcGx1Z2luOiB1aW50NjQsCiAgICAvLyAgIGNhbGxlcjogQWNjb3VudCwKICAgIC8vICAgZXNjcm93OiBzdHJpbmcsCiAgICAvLyAgIHJlY2xhaW1zOiBFc2Nyb3dSZWNsYWltW10KICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgY292ZXIgMgogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgY292ZXIgNAogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMTcgLy8gMTcKICAgICoKICAgIGludGNfMiAvLyAyCiAgICArCiAgICBzd2FwCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rKHVpbnQ2NCx1aW50NjQsYm9vbDEpW10pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyNzkKICAgIC8vIGNvbnN0IGtleTogUGx1Z2luS2V5ID0geyBwbHVnaW4sIGNhbGxlcjogY2FsbGVyLCBlc2Nyb3cgfQogICAgZGlnIDIKICAgIGl0b2IKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBkaWcgMQogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgZGlnIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgYnl0ZWMgMTEgLy8gMHgwMDJhCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjMKICAgIC8vIHBsdWdpbnMgPSBCb3hNYXA8UGx1Z2luS2V5LCBQbHVnaW5JbmZvPih7IGtleVByZWZpeDogQWJzdHJhY3RBY2NvdW50Qm94UHJlZml4UGx1Z2lucyB9KTsKICAgIGJ5dGVjXzMgLy8gInAiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTI4MQogICAgLy8gYXNzZXJ0KHRoaXMucGx1Z2lucyhrZXkpLmV4aXN0cywgRVJSX1BMVUdJTl9ET0VTX05PVF9FWElTVCkKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gUGx1Z2luIGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyODIKICAgIC8vIGFzc2VydCh0aGlzLnBsdWdpbnMoa2V5KS52YWx1ZS5jYW5SZWNsYWltLCBFUlJfRk9SQklEREVOKQogICAgcHVzaGludCAyNyAvLyAyNwogICAgaW50Y18xIC8vIDEKICAgIGJveF9leHRyYWN0CiAgICBwdXNoaW50IDQgLy8gNAogICAgZ2V0Yml0CiAgICBhc3NlcnQgLy8gb25seSB0aGUgY3JlYXRvciB3YWxsZXQgY2FuIGRlbGV0ZSBhIHNwZW5kaW5nIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTY3CiAgICAvLyBlc2Nyb3dzID0gQm94TWFwPHN0cmluZywgRXNjcm93SW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeEVzY3Jvd3MgfSkKICAgIGJ5dGVjXzIgLy8gImUiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMjgzCiAgICAvLyBhc3NlcnQodGhpcy5lc2Nyb3dzKGVzY3JvdykuZXhpc3RzLCBFUlJfRVNDUk9XX0RPRVNfTk9UX0VYSVNUKQogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gRXNjcm93IGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyODYKICAgIC8vIFR4bi5zZW5kZXIgPT09IEFwcGxpY2F0aW9uKHBsdWdpbikuYWRkcmVzcyB8fAogICAgdHhuIFNlbmRlcgogICAgc3dhcAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTI4Ni0xMjg3CiAgICAvLyBUeG4uc2VuZGVyID09PSBBcHBsaWNhdGlvbihwbHVnaW4pLmFkZHJlc3MgfHwKICAgIC8vIFR4bi5zZW5kZXIgPT09IGNhbGxlciB8fAogICAgYm56IGFyYzU4X3BsdWdpblJlY2xhaW1fYm9vbF90cnVlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTI4NwogICAgLy8gVHhuLnNlbmRlciA9PT0gY2FsbGVyIHx8CiAgICB0eG4gU2VuZGVyCiAgICBkaWcgNAogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTI4Ni0xMjg3CiAgICAvLyBUeG4uc2VuZGVyID09PSBBcHBsaWNhdGlvbihwbHVnaW4pLmFkZHJlc3MgfHwKICAgIC8vIFR4bi5zZW5kZXIgPT09IGNhbGxlciB8fAogICAgYm56IGFyYzU4X3BsdWdpblJlY2xhaW1fYm9vbF90cnVlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTI4OAogICAgLy8gY2FsbGVyID09PSBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICBkaWcgMwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMjg2LTEyODgKICAgIC8vIFR4bi5zZW5kZXIgPT09IEFwcGxpY2F0aW9uKHBsdWdpbikuYWRkcmVzcyB8fAogICAgLy8gVHhuLnNlbmRlciA9PT0gY2FsbGVyIHx8CiAgICAvLyBjYWxsZXIgPT09IEdsb2JhbC56ZXJvQWRkcmVzcywKICAgIGJ6IGFyYzU4X3BsdWdpblJlY2xhaW1fYm9vbF9mYWxzZUA1CgphcmM1OF9wbHVnaW5SZWNsYWltX2Jvb2xfdHJ1ZUA0OgogICAgaW50Y18xIC8vIDEKCmFyYzU4X3BsdWdpblJlY2xhaW1fYm9vbF9tZXJnZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMjg1LTEyOTAKICAgIC8vIGFzc2VydCgKICAgIC8vICAgVHhuLnNlbmRlciA9PT0gQXBwbGljYXRpb24ocGx1Z2luKS5hZGRyZXNzIHx8CiAgICAvLyAgIFR4bi5zZW5kZXIgPT09IGNhbGxlciB8fAogICAgLy8gICBjYWxsZXIgPT09IEdsb2JhbC56ZXJvQWRkcmVzcywKICAgIC8vICAgRVJSX0ZPUkJJRERFTgogICAgLy8gKQogICAgYXNzZXJ0IC8vIG9ubHkgdGhlIGNyZWF0b3Igd2FsbGV0IGNhbiBkZWxldGUgYSBzcGVuZGluZyBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyOTIKICAgIC8vIHRoaXMucmVjbGFpbShlc2Nyb3csIHJlY2xhaW1zLCAhdGhpcy5lc2Nyb3dzKGVzY3JvdykudmFsdWUubG9ja2VkKTsKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIHB1c2hpbnQgNjQgLy8gNjQKICAgIGdldGJpdAogICAgIQogICAgZGlnIDMKICAgIGRpZyAzCiAgICB1bmNvdmVyIDIKICAgIGNhbGxzdWIgcmVjbGFpbQogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyNzMtMTI3OAogICAgLy8gYXJjNThfcGx1Z2luUmVjbGFpbSgKICAgIC8vICAgcGx1Z2luOiB1aW50NjQsCiAgICAvLyAgIGNhbGxlcjogQWNjb3VudCwKICAgIC8vICAgZXNjcm93OiBzdHJpbmcsCiAgICAvLyAgIHJlY2xhaW1zOiBFc2Nyb3dSZWNsYWltW10KICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKYXJjNThfcGx1Z2luUmVjbGFpbV9ib29sX2ZhbHNlQDU6CiAgICBpbnRjXzAgLy8gMAogICAgYiBhcmM1OF9wbHVnaW5SZWNsYWltX2Jvb2xfbWVyZ2VANgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X29wdEluRXNjcm93W3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjNThfb3B0SW5Fc2Nyb3c6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMDEKICAgIC8vIGFyYzU4X29wdEluRXNjcm93KGVzY3Jvdzogc3RyaW5nLCBhc3NldHM6IHVpbnQ2NFtdKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzMgLy8gOAogICAgKgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdWludDY0W10pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMDIKICAgIC8vIGFzc2VydCh0aGlzLmlzQWRtaW4oKSwgRVJSX0ZPUkJJRERFTikKICAgIGNhbGxzdWIgaXNBZG1pbgogICAgYXNzZXJ0IC8vIG9ubHkgdGhlIGNyZWF0b3Igd2FsbGV0IGNhbiBkZWxldGUgYSBzcGVuZGluZyBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE2NwogICAgLy8gZXNjcm93cyA9IEJveE1hcDxzdHJpbmcsIEVzY3Jvd0luZm8+KHsga2V5UHJlZml4OiBBYnN0cmFjdEFjY291bnRCb3hQcmVmaXhFc2Nyb3dzIH0pCiAgICBieXRlY18yIC8vICJlIgogICAgZGlnIDIKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzAzCiAgICAvLyBhc3NlcnQodGhpcy5lc2Nyb3dzKGVzY3JvdykuZXhpc3RzLCBFUlJfRVNDUk9XX0RPRVNfTk9UX0VYSVNUKQogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBFc2Nyb3cgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTMwNAogICAgLy8gYXNzZXJ0KCF0aGlzLmVzY3Jvd3MoZXNjcm93KS52YWx1ZS5sb2NrZWQsIEVSUl9FU0NST1dfTE9DS0VEKQogICAgYm94X2dldAogICAgcG9wCiAgICBwdXNoaW50IDY0IC8vIDY0CiAgICBnZXRiaXQKICAgICEKICAgIGFzc2VydCAvLyBFc2Nyb3cgaXMgbG9ja2VkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMDUKICAgIC8vIHRoaXMub3B0SW5Fc2Nyb3coZXNjcm93LCBhc3NldHMpOwogICAgY2FsbHN1YiBvcHRJbkVzY3JvdwogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMDEKICAgIC8vIGFyYzU4X29wdEluRXNjcm93KGVzY3Jvdzogc3RyaW5nLCBhc3NldHM6IHVpbnQ2NFtdKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcGx1Z2luT3B0SW5Fc2Nyb3dbcm91dGluZ10oKSAtPiB2b2lkOgphcmM1OF9wbHVnaW5PcHRJbkVzY3JvdzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTMxNy0xMzIzCiAgICAvLyBhcmM1OF9wbHVnaW5PcHRJbkVzY3JvdygKICAgIC8vICAgcGx1Z2luOiB1aW50NjQsCiAgICAvLyAgIGNhbGxlcjogQWNjb3VudCwKICAgIC8vICAgZXNjcm93OiBzdHJpbmcsCiAgICAvLyAgIGFzc2V0czogdWludDY0W10sCiAgICAvLyAgIG1iclBheW1lbnQ6IGd0eG4uUGF5bWVudFR4bgogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIGR1cAogICAgY292ZXIgMwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBjb3ZlciA0CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZHVwCiAgICBjb3ZlciA1CiAgICBpbnRjXzMgLy8gOAogICAgKgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIHN3YXAKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1aW50NjRbXSkKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBjb3ZlciA0CiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzI0CiAgICAvLyBjb25zdCBrZXk6IFBsdWdpbktleSA9IHsgcGx1Z2luLCBjYWxsZXI6IGNhbGxlciwgZXNjcm93IH0KICAgIGRpZyAyCiAgICBpdG9iCiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgZGlnIDEKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIGRpZyAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGJ5dGVjIDExIC8vIDB4MDAyYQogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTYzCiAgICAvLyBwbHVnaW5zID0gQm94TWFwPFBsdWdpbktleSwgUGx1Z2luSW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeFBsdWdpbnMgfSk7CiAgICBieXRlY18zIC8vICJwIgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMjYKICAgIC8vIGFzc2VydCh0aGlzLnBsdWdpbnMoa2V5KS5leGlzdHMsIEVSUl9QTFVHSU5fRE9FU19OT1RfRVhJU1QpCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBQbHVnaW4gZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTY3CiAgICAvLyBlc2Nyb3dzID0gQm94TWFwPHN0cmluZywgRXNjcm93SW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeEVzY3Jvd3MgfSkKICAgIGJ5dGVjXzIgLy8gImUiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTMyNwogICAgLy8gYXNzZXJ0KHRoaXMuZXNjcm93cyhlc2Nyb3cpLmV4aXN0cywgRVJSX0VTQ1JPV19ET0VTX05PVF9FWElTVCkKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gRXNjcm93IGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMjgKICAgIC8vIGFzc2VydCghdGhpcy5lc2Nyb3dzKGVzY3JvdykudmFsdWUubG9ja2VkLCBFUlJfRVNDUk9XX0xPQ0tFRCkKICAgIGJveF9nZXQKICAgIHBvcAogICAgcHVzaGludCA2NCAvLyA2NAogICAgZ2V0Yml0CiAgICAhCiAgICBhc3NlcnQgLy8gRXNjcm93IGlzIGxvY2tlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzMxCiAgICAvLyBUeG4uc2VuZGVyID09PSBBcHBsaWNhdGlvbihwbHVnaW4pLmFkZHJlc3MgfHwKICAgIHR4biBTZW5kZXIKICAgIHN3YXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMzEtMTMzMgogICAgLy8gVHhuLnNlbmRlciA9PT0gQXBwbGljYXRpb24ocGx1Z2luKS5hZGRyZXNzIHx8CiAgICAvLyBUeG4uc2VuZGVyID09PSBjYWxsZXIgfHwKICAgIGJueiBhcmM1OF9wbHVnaW5PcHRJbkVzY3Jvd19ib29sX3RydWVANAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzMyCiAgICAvLyBUeG4uc2VuZGVyID09PSBjYWxsZXIgfHwKICAgIHR4biBTZW5kZXIKICAgIGRpZyA1CiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzMxLTEzMzIKICAgIC8vIFR4bi5zZW5kZXIgPT09IEFwcGxpY2F0aW9uKHBsdWdpbikuYWRkcmVzcyB8fAogICAgLy8gVHhuLnNlbmRlciA9PT0gY2FsbGVyIHx8CiAgICBibnogYXJjNThfcGx1Z2luT3B0SW5Fc2Nyb3dfYm9vbF90cnVlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTMzMwogICAgLy8gY2FsbGVyID09PSBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICBkaWcgNAogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzMxLTEzMzMKICAgIC8vIFR4bi5zZW5kZXIgPT09IEFwcGxpY2F0aW9uKHBsdWdpbikuYWRkcmVzcyB8fAogICAgLy8gVHhuLnNlbmRlciA9PT0gY2FsbGVyIHx8CiAgICAvLyBjYWxsZXIgPT09IEdsb2JhbC56ZXJvQWRkcmVzcywKICAgIGJ6IGFyYzU4X3BsdWdpbk9wdEluRXNjcm93X2Jvb2xfZmFsc2VANQoKYXJjNThfcGx1Z2luT3B0SW5Fc2Nyb3dfYm9vbF90cnVlQDQ6CiAgICBpbnRjXzEgLy8gMQoKYXJjNThfcGx1Z2luT3B0SW5Fc2Nyb3dfYm9vbF9tZXJnZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzMwLTEzMzUKICAgIC8vIGFzc2VydCgKICAgIC8vICAgVHhuLnNlbmRlciA9PT0gQXBwbGljYXRpb24ocGx1Z2luKS5hZGRyZXNzIHx8CiAgICAvLyAgIFR4bi5zZW5kZXIgPT09IGNhbGxlciB8fAogICAgLy8gICBjYWxsZXIgPT09IEdsb2JhbC56ZXJvQWRkcmVzcywKICAgIC8vICAgRVJSX0ZPUkJJRERFTgogICAgLy8gKQogICAgYXNzZXJ0IC8vIG9ubHkgdGhlIGNyZWF0b3Igd2FsbGV0IGNhbiBkZWxldGUgYSBzcGVuZGluZyBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMzctMTM0NAogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIG1iclBheW1lbnQsCiAgICAvLyAgIHsKICAgIC8vICAgICByZWNlaXZlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIC8vICAgICBhbW91bnQ6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZSAqIGFzc2V0cy5sZW5ndGgKICAgIC8vICAgfSwKICAgIC8vICAgRVJSX0lOVkFMSURfUEFZTUVOVAogICAgLy8gKQogICAgZHVwbiAyCiAgICBndHhucyBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzQwCiAgICAvLyByZWNlaXZlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMgogICAgLy8gY29udHJvbGxlZEFkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MgfSk7CiAgICBieXRlY18wIC8vICJjb250cm9sbGVkX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzNDAKICAgIC8vIHJlY2VpdmVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTMzNy0xMzQ0CiAgICAvLyBhc3NlcnRNYXRjaCgKICAgIC8vICAgbWJyUGF5bWVudCwKICAgIC8vICAgewogICAgLy8gICAgIHJlY2VpdmVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlICogYXNzZXRzLmxlbmd0aAogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICA9PQogICAgc3dhcAogICAgZ3R4bnMgQW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzNDEKICAgIC8vIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlICogYXNzZXRzLmxlbmd0aAogICAgZ2xvYmFsIEFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICBkaWcgNAogICAgKgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzM3LTEzNDQKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBtYnJQYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICAvLyAgICAgYW1vdW50OiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UgKiBhc3NldHMubGVuZ3RoCiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1BBWU1FTlQKICAgIC8vICkKICAgID09CiAgICAmJgogICAgYXNzZXJ0IC8vIGludmFsaWQgcGF5bWVudAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzQ2CiAgICAvLyB0aGlzLm9wdEluRXNjcm93KGVzY3JvdywgYXNzZXRzKTsKICAgIGRpZyAzCiAgICBkaWcgMwogICAgY2FsbHN1YiBvcHRJbkVzY3JvdwogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMTctMTMyMwogICAgLy8gYXJjNThfcGx1Z2luT3B0SW5Fc2Nyb3coCiAgICAvLyAgIHBsdWdpbjogdWludDY0LAogICAgLy8gICBjYWxsZXI6IEFjY291bnQsCiAgICAvLyAgIGVzY3Jvdzogc3RyaW5nLAogICAgLy8gICBhc3NldHM6IHVpbnQ2NFtdLAogICAgLy8gICBtYnJQYXltZW50OiBndHhuLlBheW1lbnRUeG4KICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKYXJjNThfcGx1Z2luT3B0SW5Fc2Nyb3dfYm9vbF9mYWxzZUA1OgogICAgaW50Y18wIC8vIDAKICAgIGIgYXJjNThfcGx1Z2luT3B0SW5Fc2Nyb3dfYm9vbF9tZXJnZUA2CgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfYWRkQWxsb3dhbmNlc1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzU4X2FkZEFsbG93YW5jZXM6CiAgICBpbnRjXzAgLy8gMAogICAgZHVwbiA0CiAgICBieXRlY18xIC8vICIiCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTM1NQogICAgLy8gYXJjNThfYWRkQWxsb3dhbmNlcyhlc2Nyb3c6IHN0cmluZywgYWxsb3dhbmNlczogQWRkQWxsb3dhbmNlSW5mb1tdKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZHVwCiAgICBjb3ZlciAzCiAgICBwdXNoaW50IDM0IC8vIDM0CiAgICAqCiAgICBpbnRjXzIgLy8gMgogICAgKwogICAgc3dhcAogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuKyh1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCx1aW50NjQsYm9vbDEpW10pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzNTYKICAgIC8vIGFzc2VydCh0aGlzLmlzQWRtaW4oKSwgRVJSX0FETUlOX09OTFkpOwogICAgY2FsbHN1YiBpc0FkbWluCiAgICBhc3NlcnQgLy8gYWRtaW4gb25seQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjcKICAgIC8vIGVzY3Jvd3MgPSBCb3hNYXA8c3RyaW5nLCBFc2Nyb3dJbmZvPih7IGtleVByZWZpeDogQWJzdHJhY3RBY2NvdW50Qm94UHJlZml4RXNjcm93cyB9KQogICAgYnl0ZWNfMiAvLyAiZSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzU3CiAgICAvLyBhc3NlcnQodGhpcy5lc2Nyb3dzKGVzY3JvdykuZXhpc3RzLCBFUlJfRVNDUk9XX0RPRVNfTk9UX0VYSVNUKTsKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gRXNjcm93IGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzNTgKICAgIC8vIGFzc2VydCghdGhpcy5lc2Nyb3dzKGVzY3JvdykudmFsdWUubG9ja2VkLCBFUlJfRVNDUk9XX0xPQ0tFRCk7CiAgICBib3hfZ2V0CiAgICBwb3AKICAgIHB1c2hpbnQgNjQgLy8gNjQKICAgIGdldGJpdAogICAgIQogICAgYXNzZXJ0IC8vIEVzY3JvdyBpcyBsb2NrZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTM2MAogICAgLy8gaWYgKHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUgIT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzKSB7CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzIKICAgIC8vIGNvbnRyb2xsZWRBZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzIH0pOwogICAgYnl0ZWNfMCAvLyAiY29udHJvbGxlZF9hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzYwCiAgICAvLyBpZiAodGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSAhPT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MpIHsKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgIT0KICAgIGJ6IGFyYzU4X2FkZEFsbG93YW5jZXNfYWZ0ZXJfaWZfZWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzNjEtMTM2NwogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IHRoaXMuYWxsb3dhbmNlc01icihlc2Nyb3cpICogYWxsb3dhbmNlcy5sZW5ndGgKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzNjMKICAgIC8vIHNlbmRlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMgogICAgLy8gY29udHJvbGxlZEFkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MgfSk7CiAgICBieXRlY18wIC8vICJjb250cm9sbGVkX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzNjMKICAgIC8vIHNlbmRlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzNjQKICAgIC8vIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjIwOQogICAgLy8gcmV0dXJuIE1pbkFsbG93YW5jZU1CUiArIChCb3hDb3N0UGVyQnl0ZSAqIEJ5dGVzKGVzY3JvdykubGVuZ3RoKTsKICAgIGRpZyA0CiAgICBsZW4KICAgIGludGMgNCAvLyA0MDAKICAgICoKICAgIGludGMgNiAvLyAyNzcwMAogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzY1CiAgICAvLyBhbW91bnQ6IHRoaXMuYWxsb3dhbmNlc01icihlc2Nyb3cpICogYWxsb3dhbmNlcy5sZW5ndGgKICAgIGRpZyAzCiAgICAqCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTM2MS0xMzY2CiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICBzZW5kZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogdGhpcy5hbGxvd2FuY2VzTWJyKGVzY3JvdykgKiBhbGxvd2FuY2VzLmxlbmd0aAogICAgLy8gICB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzYxLTEzNjcKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHNlbmRlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50OiB0aGlzLmFsbG93YW5jZXNNYnIoZXNjcm93KSAqIGFsbG93YW5jZXMubGVuZ3RoCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCmFyYzU4X2FkZEFsbG93YW5jZXNfYWZ0ZXJfaWZfZWxzZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzcwCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgYWxsb3dhbmNlcy5sZW5ndGg7IGkgKz0gMSkgewogICAgaW50Y18wIC8vIDAKICAgIGJ1cnkgNQoKYXJjNThfYWRkQWxsb3dhbmNlc193aGlsZV90b3BANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTM3MAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGFsbG93YW5jZXMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGRpZyA0CiAgICBkaWcgMQogICAgPAogICAgYnogYXJjNThfYWRkQWxsb3dhbmNlc19hZnRlcl93aGlsZUAxMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzcxCiAgICAvLyBjb25zdCB7IGFzc2V0LCB0eXBlLCBhbW91bnQsIG1heCwgaW50ZXJ2YWwsIHVzZVJvdW5kcyB9ID0gYWxsb3dhbmNlc1tpXTsKICAgIGRpZyAxCiAgICBleHRyYWN0IDIgMAogICAgZGlnIDUKICAgIHB1c2hpbnQgMzQgLy8gMzQKICAgICoKICAgIHB1c2hpbnQgMzQgLy8gMzQKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBpbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZHVwCiAgICBleHRyYWN0IDAgOAogICAgZGlnIDEKICAgIGV4dHJhY3QgOCAxCiAgICBidXJ5IDgKICAgIGRpZyAxCiAgICBleHRyYWN0IDkgOAogICAgYnVyeSAxMgogICAgZGlnIDEKICAgIGV4dHJhY3QgMTcgOAogICAgYnVyeSAxMQogICAgZGlnIDEKICAgIGV4dHJhY3QgMjUgOAogICAgYnVyeSAxMAogICAgc3dhcAogICAgcHVzaGludCAyNjQgLy8gMjY0CiAgICBnZXRiaXQKICAgIGR1cAogICAgY292ZXIgMgogICAgYnVyeSA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzNzIKICAgIC8vIGNvbnN0IGtleTogQWxsb3dhbmNlS2V5ID0geyBlc2Nyb3csIGFzc2V0IH0KICAgIGRpZyA0CiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWMgMTcgLy8gMHgwMDBhCiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE2OQogICAgLy8gYWxsb3dhbmNlcyA9IEJveE1hcDxBbGxvd2FuY2VLZXksIEFsbG93YW5jZUluZm8+KHsga2V5UHJlZml4OiBBYnN0cmFjdEFjY291bnRCb3hQcmVmaXhBbGxvd2FuY2VzIH0pIC8vIDM4XzUwMAogICAgYnl0ZWMgMTggLy8gImEiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgYnVyeSA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzNzMKICAgIC8vIGFzc2VydCghdGhpcy5hbGxvd2FuY2VzKGtleSkuZXhpc3RzLCBFUlJfQUxMT1dBTkNFX0FMUkVBRFlfRVhJU1RTKTsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgIQogICAgYXNzZXJ0IC8vIGFsbG93YW5jZSBhbHJlYWR5IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzc0CiAgICAvLyBjb25zdCBzdGFydCA9IHVzZVJvdW5kcyA/IEdsb2JhbC5yb3VuZCA6IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXA7CiAgICBieiBhcmM1OF9hZGRBbGxvd2FuY2VzX3Rlcm5hcnlfZmFsc2VAOAogICAgZ2xvYmFsIFJvdW5kCgphcmM1OF9hZGRBbGxvd2FuY2VzX3Rlcm5hcnlfbWVyZ2VAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTM3Ni0xMzg1CiAgICAvLyB0aGlzLmFsbG93YW5jZXMoa2V5KS52YWx1ZSA9IHsKICAgIC8vICAgdHlwZSwKICAgIC8vICAgc3BlbnQ6IDAsCiAgICAvLyAgIGFtb3VudCwKICAgIC8vICAgbGFzdDogMCwKICAgIC8vICAgbWF4LAogICAgLy8gICBpbnRlcnZhbCwKICAgIC8vICAgc3RhcnQsCiAgICAvLyAgIHVzZVJvdW5kcwogICAgLy8gfQogICAgZGlnIDYKICAgIGRpZyAxMAogICAgY29uY2F0CiAgICBkaWcgMTEKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzc4CiAgICAvLyBzcGVudDogMCwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzNzYtMTM4NQogICAgLy8gdGhpcy5hbGxvd2FuY2VzKGtleSkudmFsdWUgPSB7CiAgICAvLyAgIHR5cGUsCiAgICAvLyAgIHNwZW50OiAwLAogICAgLy8gICBhbW91bnQsCiAgICAvLyAgIGxhc3Q6IDAsCiAgICAvLyAgIG1heCwKICAgIC8vICAgaW50ZXJ2YWwsCiAgICAvLyAgIHN0YXJ0LAogICAgLy8gICB1c2VSb3VuZHMKICAgIC8vIH0KICAgIGl0b2IKICAgIHN3YXAKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIGRpZyAxMAogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGl0b2IKICAgIGNvbmNhdAogICAgYnl0ZWMgOCAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgZGlnIDYKICAgIHNldGJpdAogICAgY29uY2F0CiAgICBkaWcgNwogICAgc3dhcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzcwCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgYWxsb3dhbmNlcy5sZW5ndGg7IGkgKz0gMSkgewogICAgZGlnIDQKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBidXJ5IDUKICAgIGIgYXJjNThfYWRkQWxsb3dhbmNlc193aGlsZV90b3BANQoKYXJjNThfYWRkQWxsb3dhbmNlc190ZXJuYXJ5X2ZhbHNlQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzNzQKICAgIC8vIGNvbnN0IHN0YXJ0ID0gdXNlUm91bmRzID8gR2xvYmFsLnJvdW5kIDogR2xvYmFsLmxhdGVzdFRpbWVzdGFtcDsKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGIgYXJjNThfYWRkQWxsb3dhbmNlc190ZXJuYXJ5X21lcmdlQDkKCmFyYzU4X2FkZEFsbG93YW5jZXNfYWZ0ZXJfd2hpbGVAMTA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0MgogICAgLy8gbGFzdFVzZXJJbnRlcmFjdGlvbiA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0xhc3RVc2VySW50ZXJhY3Rpb24gfSkKICAgIGJ5dGVjIDQgLy8gImxhc3RfdXNlcl9pbnRlcmFjdGlvbiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTg3CiAgICAvLyB0aGlzLmxhc3RVc2VySW50ZXJhY3Rpb24udmFsdWUgPSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDQKICAgIC8vIGxhc3RDaGFuZ2UgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNMYXN0Q2hhbmdlIH0pCiAgICBieXRlYyA2IC8vICJsYXN0X2NoYW5nZSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTkxCiAgICAvLyB0aGlzLmxhc3RDaGFuZ2UudmFsdWUgPSBHbG9iYWwubGF0ZXN0VGltZXN0YW1wCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzU1CiAgICAvLyBhcmM1OF9hZGRBbGxvd2FuY2VzKGVzY3Jvdzogc3RyaW5nLCBhbGxvd2FuY2VzOiBBZGRBbGxvd2FuY2VJbmZvW10pOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZW1vdmVBbGxvd2FuY2VzW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjNThfcmVtb3ZlQWxsb3dhbmNlczoKICAgIGJ5dGVjXzEgLy8gIiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTM5OAogICAgLy8gYXJjNThfcmVtb3ZlQWxsb3dhbmNlcyhlc2Nyb3c6IHN0cmluZywgYXNzZXRzOiB1aW50NjRbXSk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXBuIDIKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBpbnRjXzMgLy8gOAogICAgKgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIHN3YXAKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1aW50NjRbXSkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTM5OQogICAgLy8gYXNzZXJ0KHRoaXMuaXNBZG1pbigpIHx8IHRoaXMuY2FuUmV2b2tlKCksIEVSUl9PTkxZX0FETUlOX09SX1JFVk9DQVRJT05fQVBQX0NBTl9SRU1PVkVfTUVUSE9EX1JFU1RSSUNUSU9OKTsKICAgIGNhbGxzdWIgaXNBZG1pbgogICAgYm56IGFyYzU4X3JlbW92ZUFsbG93YW5jZXNfYm9vbF90cnVlQDMKICAgIGNhbGxzdWIgY2FuUmV2b2tlCiAgICBieiBhcmM1OF9yZW1vdmVBbGxvd2FuY2VzX2Jvb2xfZmFsc2VANAoKYXJjNThfcmVtb3ZlQWxsb3dhbmNlc19ib29sX3RydWVAMzoKICAgIGludGNfMSAvLyAxCgphcmM1OF9yZW1vdmVBbGxvd2FuY2VzX2Jvb2xfbWVyZ2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTM5OQogICAgLy8gYXNzZXJ0KHRoaXMuaXNBZG1pbigpIHx8IHRoaXMuY2FuUmV2b2tlKCksIEVSUl9PTkxZX0FETUlOX09SX1JFVk9DQVRJT05fQVBQX0NBTl9SRU1PVkVfTUVUSE9EX1JFU1RSSUNUSU9OKTsKICAgIGFzc2VydCAvLyBPbmx5IGFuIGFkbWluIG9yIHJldm9jYXRpb24gYXBwIGNhbiByZW1vdmUgbWV0aG9kIHJlc3RyaWN0aW9ucwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjcKICAgIC8vIGVzY3Jvd3MgPSBCb3hNYXA8c3RyaW5nLCBFc2Nyb3dJbmZvPih7IGtleVByZWZpeDogQWJzdHJhY3RBY2NvdW50Qm94UHJlZml4RXNjcm93cyB9KQogICAgYnl0ZWNfMiAvLyAiZSIKICAgIGRpZyAzCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQwMAogICAgLy8gYXNzZXJ0KHRoaXMuZXNjcm93cyhlc2Nyb3cpLmV4aXN0cywgRVJSX0VTQ1JPV19ET0VTX05PVF9FWElTVCk7CiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIEVzY3JvdyBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDAxCiAgICAvLyBhc3NlcnQoIXRoaXMuZXNjcm93cyhlc2Nyb3cpLnZhbHVlLmxvY2tlZCwgRVJSX0VTQ1JPV19MT0NLRUQpOwogICAgYm94X2dldAogICAgcG9wCiAgICBwdXNoaW50IDY0IC8vIDY0CiAgICBnZXRiaXQKICAgICEKICAgIGFzc2VydCAvLyBFc2Nyb3cgaXMgbG9ja2VkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0MDMKICAgIC8vIGlmICh0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlICE9PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcykgewogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTMyCiAgICAvLyBjb250cm9sbGVkQWRkcmVzcyA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcyB9KTsKICAgIGJ5dGVjXzAgLy8gImNvbnRyb2xsZWRfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQwMwogICAgLy8gaWYgKHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUgIT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzKSB7CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgICE9CiAgICBieiBhcmM1OF9yZW1vdmVBbGxvd2FuY2VzX2FmdGVyX2lmX2Vsc2VAOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDA0LTE0MDkKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHJlY2VpdmVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIGFtb3VudDogdGhpcy5hbGxvd2FuY2VzTWJyKGVzY3JvdykgKiBhc3NldHMubGVuZ3RoCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDA2CiAgICAvLyByZWNlaXZlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMgogICAgLy8gY29udHJvbGxlZEFkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MgfSk7CiAgICBieXRlY18wIC8vICJjb250cm9sbGVkX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0MDYKICAgIC8vIHJlY2VpdmVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MjA5CiAgICAvLyByZXR1cm4gTWluQWxsb3dhbmNlTUJSICsgKEJveENvc3RQZXJCeXRlICogQnl0ZXMoZXNjcm93KS5sZW5ndGgpOwogICAgZGlnIDMKICAgIGxlbgogICAgaW50YyA0IC8vIDQwMAogICAgKgogICAgaW50YyA2IC8vIDI3NzAwCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0MDcKICAgIC8vIGFtb3VudDogdGhpcy5hbGxvd2FuY2VzTWJyKGVzY3JvdykgKiBhc3NldHMubGVuZ3RoCiAgICBkaWcgMgogICAgKgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQwNC0xNDA4CiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICByZWNlaXZlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIC8vICAgICBhbW91bnQ6IHRoaXMuYWxsb3dhbmNlc01icihlc2Nyb3cpICogYXNzZXRzLmxlbmd0aAogICAgLy8gICB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDA0LTE0MDkKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHJlY2VpdmVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIGFtb3VudDogdGhpcy5hbGxvd2FuY2VzTWJyKGVzY3JvdykgKiBhc3NldHMubGVuZ3RoCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCmFyYzU4X3JlbW92ZUFsbG93YW5jZXNfYWZ0ZXJfaWZfZWxzZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDEyCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgYXNzZXRzLmxlbmd0aDsgaSArPSAxKSB7CiAgICBpbnRjXzAgLy8gMAogICAgYnVyeSA0CgphcmM1OF9yZW1vdmVBbGxvd2FuY2VzX3doaWxlX3RvcEA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDEyCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgYXNzZXRzLmxlbmd0aDsgaSArPSAxKSB7CiAgICBkaWcgMwogICAgZGlnIDEKICAgIDwKICAgIGJ6IGFyYzU4X3JlbW92ZUFsbG93YW5jZXNfYWZ0ZXJfd2hpbGVAMTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQxNQogICAgLy8gYXNzZXQ6IGFzc2V0c1tpXQogICAgZGlnIDEKICAgIGV4dHJhY3QgMiAwCiAgICBkaWcgNAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBpbnRjXzMgLy8gOAogICAgKgogICAgaW50Y18zIC8vIDgKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBpbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDEzLTE0MTYKICAgIC8vIGNvbnN0IGtleTogQWxsb3dhbmNlS2V5ID0gewogICAgLy8gICBlc2Nyb3csCiAgICAvLyAgIGFzc2V0OiBhc3NldHNbaV0KICAgIC8vIH0KICAgIGRpZyA0CiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWMgMTcgLy8gMHgwMDBhCiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE2OQogICAgLy8gYWxsb3dhbmNlcyA9IEJveE1hcDxBbGxvd2FuY2VLZXksIEFsbG93YW5jZUluZm8+KHsga2V5UHJlZml4OiBBYnN0cmFjdEFjY291bnRCb3hQcmVmaXhBbGxvd2FuY2VzIH0pIC8vIDM4XzUwMAogICAgYnl0ZWMgMTggLy8gImEiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQxNwogICAgLy8gYXNzZXJ0KHRoaXMuYWxsb3dhbmNlcyhrZXkpLmV4aXN0cywgRVJSX0FMTE9XQU5DRV9ET0VTX05PVF9FWElTVCkKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gYWxsb3dhbmNlIGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0MTgKICAgIC8vIHRoaXMuYWxsb3dhbmNlcyhrZXkpLmRlbGV0ZSgpCiAgICBib3hfZGVsCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQxMgogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGFzc2V0cy5sZW5ndGg7IGkgKz0gMSkgewogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgNAogICAgYiBhcmM1OF9yZW1vdmVBbGxvd2FuY2VzX3doaWxlX3RvcEA5CgphcmM1OF9yZW1vdmVBbGxvd2FuY2VzX2FmdGVyX3doaWxlQDExOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDIKICAgIC8vIGxhc3RVc2VySW50ZXJhY3Rpb24gPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNMYXN0VXNlckludGVyYWN0aW9uIH0pCiAgICBieXRlYyA0IC8vICJsYXN0X3VzZXJfaW50ZXJhY3Rpb24iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE4NwogICAgLy8gdGhpcy5sYXN0VXNlckludGVyYWN0aW9uLnZhbHVlID0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQ0CiAgICAvLyBsYXN0Q2hhbmdlID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzTGFzdENoYW5nZSB9KQogICAgYnl0ZWMgNiAvLyAibGFzdF9jaGFuZ2UiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE5MQogICAgLy8gdGhpcy5sYXN0Q2hhbmdlLnZhbHVlID0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTM5OAogICAgLy8gYXJjNThfcmVtb3ZlQWxsb3dhbmNlcyhlc2Nyb3c6IHN0cmluZywgYXNzZXRzOiB1aW50NjRbXSk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKYXJjNThfcmVtb3ZlQWxsb3dhbmNlc19ib29sX2ZhbHNlQDQ6CiAgICBpbnRjXzAgLy8gMAogICAgYiBhcmM1OF9yZW1vdmVBbGxvd2FuY2VzX2Jvb2xfbWVyZ2VANQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X2FkZEV4ZWN1dGlvbktleVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzU4X2FkZEV4ZWN1dGlvbktleToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQzMwogICAgLy8gYXJjNThfYWRkRXhlY3V0aW9uS2V5KGxlYXNlOiBieXRlczwzMj4sIGdyb3VwczogYnl0ZXM8MzI+W10sIGZpcnN0VmFsaWQ6IHVpbnQ2NCwgbGFzdFZhbGlkOiB1aW50NjQpOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgY292ZXIgMgogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgICoKICAgIGludGNfMiAvLyAyCiAgICArCiAgICBzd2FwCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdWludDhbMzJdW10pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgY292ZXIgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQzNAogICAgLy8gYXNzZXJ0KHRoaXMuaXNBZG1pbigpLCBFUlJfQURNSU5fT05MWSkKICAgIGNhbGxzdWIgaXNBZG1pbgogICAgYXNzZXJ0IC8vIGFkbWluIG9ubHkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTcxCiAgICAvLyBleGVjdXRpb25zID0gQm94TWFwPGJ5dGVzPDMyPiwgRXhlY3V0aW9uSW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeEV4ZWN1dGlvbnMgfSkKICAgIGJ5dGVjIDkgLy8gIngiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDM1CiAgICAvLyBpZiAoIXRoaXMuZXhlY3V0aW9ucyhsZWFzZSkuZXhpc3RzKSB7CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGJueiBhcmM1OF9hZGRFeGVjdXRpb25LZXlfZWxzZV9ib2R5QDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQzNi0xNDQwCiAgICAvLyB0aGlzLmV4ZWN1dGlvbnMobGVhc2UpLnZhbHVlID0gewogICAgLy8gICBncm91cHM6IGNsb25lKGdyb3VwcyksCiAgICAvLyAgIGZpcnN0VmFsaWQsCiAgICAvLyAgIGxhc3RWYWxpZAogICAgLy8gfQogICAgZGlnIDMKICAgIGl0b2IKICAgIHB1c2hieXRlcyAweDAwMTIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgdW5jb3ZlciAyCiAgICBpdG9iCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZGlnIDEKICAgIGR1cAogICAgYm94X2RlbAogICAgcG9wCiAgICBzd2FwCiAgICBib3hfcHV0CgphcmM1OF9hZGRFeGVjdXRpb25LZXlfYWZ0ZXJfaWZfZWxzZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDIKICAgIC8vIGxhc3RVc2VySW50ZXJhY3Rpb24gPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNMYXN0VXNlckludGVyYWN0aW9uIH0pCiAgICBieXRlYyA0IC8vICJsYXN0X3VzZXJfaW50ZXJhY3Rpb24iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE4NwogICAgLy8gdGhpcy5sYXN0VXNlckludGVyYWN0aW9uLnZhbHVlID0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQ0CiAgICAvLyBsYXN0Q2hhbmdlID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzTGFzdENoYW5nZSB9KQogICAgYnl0ZWMgNiAvLyAibGFzdF9jaGFuZ2UiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE5MQogICAgLy8gdGhpcy5sYXN0Q2hhbmdlLnZhbHVlID0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQzMwogICAgLy8gYXJjNThfYWRkRXhlY3V0aW9uS2V5KGxlYXNlOiBieXRlczwzMj4sIGdyb3VwczogYnl0ZXM8MzI+W10sIGZpcnN0VmFsaWQ6IHVpbnQ2NCwgbGFzdFZhbGlkOiB1aW50NjQpOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCmFyYzU4X2FkZEV4ZWN1dGlvbktleV9lbHNlX2JvZHlAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQ0MgogICAgLy8gYXNzZXJ0KHRoaXMuZXhlY3V0aW9ucyhsZWFzZSkudmFsdWUuZmlyc3RWYWxpZCA9PT0gZmlyc3RWYWxpZCwgRVJSX0VYRUNVVElPTl9LRVlfVVBEQVRFX01VU1RfTUFUQ0hfRklSU1RfVkFMSUQpCiAgICBkaWcgMgogICAgZHVwCiAgICBpbnRjXzIgLy8gMgogICAgaW50Y18zIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBkaWcgNQogICAgPT0KICAgIGFzc2VydCAvLyBleGVjdXRpb24ga2V5IHVwZGF0ZSBtdXN0IG1hdGNoIGZpcnN0IHZhbGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0NDMKICAgIC8vIGFzc2VydCh0aGlzLmV4ZWN1dGlvbnMobGVhc2UpLnZhbHVlLmxhc3RWYWxpZCA9PT0gbGFzdFZhbGlkLCBFUlJfRVhFQ1VUSU9OX0tFWV9VUERBVEVfTVVTVF9NQVRDSF9MQVNUX1ZBTElEKQogICAgZHVwCiAgICBwdXNoaW50IDEwIC8vIDEwCiAgICBpbnRjXzMgLy8gOAogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIHVuY292ZXIgMwogICAgPT0KICAgIGFzc2VydCAvLyBleGVjdXRpb24ga2V5IHVwZGF0ZSBtdXN0IG1hdGNoIGxhc3QgdmFsaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQ0NQogICAgLy8gdGhpcy5leGVjdXRpb25zKGxlYXNlKS52YWx1ZS5ncm91cHMgPSBbLi4uY2xvbmUodGhpcy5leGVjdXRpb25zKGxlYXNlKS52YWx1ZS5ncm91cHMpLCAuLi5jbG9uZShncm91cHMpXQogICAgZHVwCiAgICBib3hfZ2V0CiAgICBwb3AKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMQogICAgbGVuCiAgICBkaWcgMgogICAgZGlnIDIKICAgIHVuY292ZXIgMgogICAgc3Vic3RyaW5nMwogICAgdW5jb3ZlciA0CiAgICBleHRyYWN0IDIgMAogICAgY29uY2F0IC8vIG9uIGVycm9yOiBtYXggYXJyYXkgbGVuZ3RoIGV4Y2VlZGVkCiAgICBkdXAKICAgIGV4dHJhY3QgMiAwCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIC8KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICByZXBsYWNlMiAwCiAgICB1bmNvdmVyIDIKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDMKICAgIGV4dHJhY3QzCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGRpZyAxCiAgICBib3hfZGVsCiAgICBwb3AKICAgIGJveF9wdXQKICAgIGIgYXJjNThfYWRkRXhlY3V0aW9uS2V5X2FmdGVyX2lmX2Vsc2VANAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3JlbW92ZUV4ZWN1dGlvbktleVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzU4X3JlbW92ZUV4ZWN1dGlvbktleToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQ1NwogICAgLy8gYXJjNThfcmVtb3ZlRXhlY3V0aW9uS2V5KGxlYXNlOiBieXRlczwzMj4pOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTcxCiAgICAvLyBleGVjdXRpb25zID0gQm94TWFwPGJ5dGVzPDMyPiwgRXhlY3V0aW9uSW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeEV4ZWN1dGlvbnMgfSkKICAgIGJ5dGVjIDkgLy8gIngiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDU4CiAgICAvLyBhc3NlcnQodGhpcy5leGVjdXRpb25zKGxlYXNlKS5leGlzdHMsIEVSUl9FWEVDVVRJT05fS0VZX05PVF9GT1VORCkKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIEV4ZWN1dGlvbiBrZXkgbm90IGZvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0NTkKICAgIC8vIGFzc2VydCh0aGlzLmlzQWRtaW4oKSB8fCB0aGlzLmV4ZWN1dGlvbnMobGVhc2UpLnZhbHVlLmxhc3RWYWxpZCA8IEdsb2JhbC5yb3VuZCwgRVJSX0FETUlOX09OTFkpCiAgICBjYWxsc3ViIGlzQWRtaW4KICAgIGJueiBhcmM1OF9yZW1vdmVFeGVjdXRpb25LZXlfYm9vbF90cnVlQDMKICAgIGR1cAogICAgcHVzaGludCAxMCAvLyAxMAogICAgaW50Y18zIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBnbG9iYWwgUm91bmQKICAgIDwKICAgIGJ6IGFyYzU4X3JlbW92ZUV4ZWN1dGlvbktleV9ib29sX2ZhbHNlQDQKCmFyYzU4X3JlbW92ZUV4ZWN1dGlvbktleV9ib29sX3RydWVAMzoKICAgIGludGNfMSAvLyAxCgphcmM1OF9yZW1vdmVFeGVjdXRpb25LZXlfYm9vbF9tZXJnZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDU5CiAgICAvLyBhc3NlcnQodGhpcy5pc0FkbWluKCkgfHwgdGhpcy5leGVjdXRpb25zKGxlYXNlKS52YWx1ZS5sYXN0VmFsaWQgPCBHbG9iYWwucm91bmQsIEVSUl9BRE1JTl9PTkxZKQogICAgYXNzZXJ0IC8vIGFkbWluIG9ubHkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQ2MQogICAgLy8gdGhpcy5leGVjdXRpb25zKGxlYXNlKS5kZWxldGUoKQogICAgZHVwCiAgICBib3hfZGVsCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQyCiAgICAvLyBsYXN0VXNlckludGVyYWN0aW9uID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzTGFzdFVzZXJJbnRlcmFjdGlvbiB9KQogICAgYnl0ZWMgNCAvLyAibGFzdF91c2VyX2ludGVyYWN0aW9uIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxODcKICAgIC8vIHRoaXMubGFzdFVzZXJJbnRlcmFjdGlvbi52YWx1ZSA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0NAogICAgLy8gbGFzdENoYW5nZSA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0xhc3RDaGFuZ2UgfSkKICAgIGJ5dGVjIDYgLy8gImxhc3RfY2hhbmdlIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxOTEKICAgIC8vIHRoaXMubGFzdENoYW5nZS52YWx1ZSA9IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0NTcKICAgIC8vIGFyYzU4X3JlbW92ZUV4ZWN1dGlvbktleShsZWFzZTogYnl0ZXM8MzI+KTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgphcmM1OF9yZW1vdmVFeGVjdXRpb25LZXlfYm9vbF9mYWxzZUA0OgogICAgaW50Y18wIC8vIDAKICAgIGIgYXJjNThfcmVtb3ZlRXhlY3V0aW9uS2V5X2Jvb2xfbWVyZ2VANQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X2dldEFkbWluW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjNThfZ2V0QWRtaW46CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0NzUKICAgIC8vIHJldHVybiB0aGlzLmFkbWluLnZhbHVlCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMjgKICAgIC8vIGFkbWluID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0FkbWluIH0pCiAgICBieXRlYyAxMyAvLyAiYWRtaW4iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0NzUKICAgIC8vIHJldHVybiB0aGlzLmFkbWluLnZhbHVlCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDczCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGJ5dGVjIDUgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9nZXRQbHVnaW5zW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjNThfZ2V0UGx1Z2luczoKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0ODQKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDg2CiAgICAvLyBsZXQgcGx1Z2luczogUGx1Z2luSW5mb1tdID0gW10KICAgIGJ5dGVjIDcgLy8gMHgwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0ODcKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSArPSAxKSB7CiAgICBpbnRjXzAgLy8gMAoKYXJjNThfZ2V0UGx1Z2luc193aGlsZV90b3BAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQ4NwogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGRpZyAyCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGR1cAogICAgYnVyeSA1CiAgICBkaWcgMQogICAgPgogICAgYnogYXJjNThfZ2V0UGx1Z2luc19hZnRlcl93aGlsZUA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0ODgKICAgIC8vIGlmICh0aGlzLnBsdWdpbnMoa2V5c1tpXSkuZXhpc3RzKSB7CiAgICBkaWcgMgogICAgZXh0cmFjdCAyIDAKICAgIGRpZyAxCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGludGNfMiAvLyAyCiAgICAqCiAgICBkaWcgMQogICAgc3dhcAogICAgZXh0cmFjdF91aW50MTYKICAgIHVuY292ZXIgMgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGR1cAogICAgYnVyeSA0CiAgICBkaWcgNgogICAgZGlnIDEKICAgIC0gLy8gb24gZXJyb3I6IGluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBkaWcgMwogICAgbGVuCiAgICB1bmNvdmVyIDIKICAgIGludGNfMiAvLyAyCiAgICAqCiAgICBkaWcgNAogICAgc3dhcAogICAgZXh0cmFjdF91aW50MTYKICAgIHVuY292ZXIgMgogICAgc2VsZWN0CiAgICBzdWJzdHJpbmczCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE2MwogICAgLy8gcGx1Z2lucyA9IEJveE1hcDxQbHVnaW5LZXksIFBsdWdpbkluZm8+KHsga2V5UHJlZml4OiBBYnN0cmFjdEFjY291bnRCb3hQcmVmaXhQbHVnaW5zIH0pOwogICAgYnl0ZWNfMyAvLyAicCIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBidXJ5IDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQ4OAogICAgLy8gaWYgKHRoaXMucGx1Z2lucyhrZXlzW2ldKS5leGlzdHMpIHsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYnogYXJjNThfZ2V0UGx1Z2luc19hZnRlcl9pZl9lbHNlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQ4OQogICAgLy8gcGx1Z2lucy5wdXNoKHRoaXMucGx1Z2lucyhrZXlzW2ldKS52YWx1ZSkKICAgIGRpZyA0CiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgZGlnIDIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBzd2FwCiAgICBleHRyYWN0IDIgMAogICAgYnl0ZWMgMTIgLy8gMHgwMDAyCiAgICB1bmNvdmVyIDMKICAgIGNvbmNhdAogICAgY292ZXIgMgogICAgaW50Y18xIC8vIDEKICAgIHVuY292ZXIgMwogICAgY2FsbHN1YiBkeW5hbWljX2FycmF5X2NvbmNhdF9keW5hbWljX2VsZW1lbnQKICAgIGJ1cnkgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDkwCiAgICAvLyBjb250aW51ZQogICAgYiBhcmM1OF9nZXRQbHVnaW5zX3doaWxlX3RvcEAyCgphcmM1OF9nZXRQbHVnaW5zX2FmdGVyX2lmX2Vsc2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQ5MgogICAgLy8gcGx1Z2lucy5wdXNoKGVtcHR5UGx1Z2luSW5mbygpKQogICAgY2FsbHN1YiBlbXB0eVBsdWdpbkluZm8KICAgIGRpZyAyCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgc3dhcAogICAgZXh0cmFjdCAyIDAKICAgIGJ5dGVjIDEyIC8vIDB4MDAwMgogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIGNvdmVyIDIKICAgIGludGNfMSAvLyAxCiAgICB1bmNvdmVyIDMKICAgIGNhbGxzdWIgZHluYW1pY19hcnJheV9jb25jYXRfZHluYW1pY19lbGVtZW50CiAgICBidXJ5IDIKICAgIGIgYXJjNThfZ2V0UGx1Z2luc193aGlsZV90b3BAMgoKYXJjNThfZ2V0UGx1Z2luc19hZnRlcl93aGlsZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDg0CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGJ5dGVjIDUgLy8gMHgxNTFmN2M3NQogICAgZGlnIDIKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfZ2V0TmFtZWRQbHVnaW5zW3JvdXRpbmddKCkgLT4gdm9pZDoKYXJjNThfZ2V0TmFtZWRQbHVnaW5zOgogICAgaW50Y18wIC8vIDAKICAgIGR1cAogICAgYnl0ZWNfMSAvLyAiIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTAzCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTUwNQogICAgLy8gbGV0IHBsdWdpbnM6IFBsdWdpbkluZm9bXSA9IFtdCiAgICBieXRlYyA3IC8vIDB4MDAwMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTA2CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGludGNfMCAvLyAwCgphcmM1OF9nZXROYW1lZFBsdWdpbnNfd2hpbGVfdG9wQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE1MDYKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkgKz0gMSkgewogICAgZGlnIDIKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZGlnIDEKICAgID4KICAgIGR1cAogICAgYnVyeSA1CiAgICBieiBhcmM1OF9nZXROYW1lZFBsdWdpbnNfYWZ0ZXJfd2hpbGVAOQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTA3CiAgICAvLyBpZiAodGhpcy5uYW1lZFBsdWdpbnMobmFtZXNbaV0pLmV4aXN0cykgewogICAgZGlnIDIKICAgIGV4dHJhY3QgMiAwCiAgICBkaWcgNAogICAgYXNzZXJ0IC8vIGluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBkaWcgMQogICAgaW50Y18yIC8vIDIKICAgICoKICAgIGRpZyAxCiAgICBzd2FwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZHVwMgogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMiAvLyAyCiAgICArCiAgICBleHRyYWN0MwogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTY1CiAgICAvLyBuYW1lZFBsdWdpbnMgPSBCb3hNYXA8c3RyaW5nLCBQbHVnaW5LZXk+KHsga2V5UHJlZml4OiBBYnN0cmFjdEFjY291bnRCb3hQcmVmaXhOYW1lZFBsdWdpbnMgfSk7CiAgICBieXRlYyAxNSAvLyAibiIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBidXJ5IDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTUwNwogICAgLy8gaWYgKHRoaXMubmFtZWRQbHVnaW5zKG5hbWVzW2ldKS5leGlzdHMpIHsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYnogYXJjNThfZ2V0TmFtZWRQbHVnaW5zX2FmdGVyX2lmX2Vsc2VANwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTA4CiAgICAvLyBjb25zdCBuYW1lS2V5ID0gY2xvbmUodGhpcy5uYW1lZFBsdWdpbnMobmFtZXNbaV0pLnZhbHVlKQogICAgZGlnIDUKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE2MwogICAgLy8gcGx1Z2lucyA9IEJveE1hcDxQbHVnaW5LZXksIFBsdWdpbkluZm8+KHsga2V5UHJlZml4OiBBYnN0cmFjdEFjY291bnRCb3hQcmVmaXhQbHVnaW5zIH0pOwogICAgYnl0ZWNfMyAvLyAicCIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBidXJ5IDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTUwOQogICAgLy8gaWYgKHRoaXMucGx1Z2lucyhuYW1lS2V5KS5leGlzdHMpIHsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYnogYXJjNThfZ2V0TmFtZWRQbHVnaW5zX2FmdGVyX2lmX2Vsc2VANgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTEwCiAgICAvLyBwbHVnaW5zLnB1c2godGhpcy5wbHVnaW5zKG5hbWVLZXkpLnZhbHVlKQogICAgZGlnIDQKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBkaWcgMgogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHN3YXAKICAgIGV4dHJhY3QgMiAwCiAgICBieXRlYyAxMiAvLyAweDAwMDIKICAgIHVuY292ZXIgMwogICAgY29uY2F0CiAgICBjb3ZlciAyCiAgICBpbnRjXzEgLy8gMQogICAgdW5jb3ZlciAzCiAgICBjYWxsc3ViIGR5bmFtaWNfYXJyYXlfY29uY2F0X2R5bmFtaWNfZWxlbWVudAogICAgYnVyeSAyCgphcmM1OF9nZXROYW1lZFBsdWdpbnNfYmxvY2tAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTUwNgogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSArPSAxKSB7CiAgICBkdXAKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBidXJ5IDEKICAgIGIgYXJjNThfZ2V0TmFtZWRQbHVnaW5zX3doaWxlX3RvcEAyCgphcmM1OF9nZXROYW1lZFBsdWdpbnNfYWZ0ZXJfaWZfZWxzZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTEzCiAgICAvLyBwbHVnaW5zLnB1c2goZW1wdHlQbHVnaW5JbmZvKCkpCiAgICBjYWxsc3ViIGVtcHR5UGx1Z2luSW5mbwogICAgZGlnIDIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBzd2FwCiAgICBleHRyYWN0IDIgMAogICAgYnl0ZWMgMTIgLy8gMHgwMDAyCiAgICB1bmNvdmVyIDMKICAgIGNvbmNhdAogICAgY292ZXIgMgogICAgaW50Y18xIC8vIDEKICAgIHVuY292ZXIgMwogICAgY2FsbHN1YiBkeW5hbWljX2FycmF5X2NvbmNhdF9keW5hbWljX2VsZW1lbnQKICAgIGJ1cnkgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTE0CiAgICAvLyBjb250aW51ZQogICAgYiBhcmM1OF9nZXROYW1lZFBsdWdpbnNfYmxvY2tAOAoKYXJjNThfZ2V0TmFtZWRQbHVnaW5zX2FmdGVyX2lmX2Vsc2VANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTUxNgogICAgLy8gcGx1Z2lucy5wdXNoKGVtcHR5UGx1Z2luSW5mbygpKQogICAgY2FsbHN1YiBlbXB0eVBsdWdpbkluZm8KICAgIGRpZyAyCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgc3dhcAogICAgZXh0cmFjdCAyIDAKICAgIGJ5dGVjIDEyIC8vIDB4MDAwMgogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIGNvdmVyIDIKICAgIGludGNfMSAvLyAxCiAgICB1bmNvdmVyIDMKICAgIGNhbGxzdWIgZHluYW1pY19hcnJheV9jb25jYXRfZHluYW1pY19lbGVtZW50CiAgICBidXJ5IDIKICAgIGIgYXJjNThfZ2V0TmFtZWRQbHVnaW5zX2Jsb2NrQDgKCmFyYzU4X2dldE5hbWVkUGx1Z2luc19hZnRlcl93aGlsZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTAzCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGJ5dGVjIDUgLy8gMHgxNTFmN2M3NQogICAgZGlnIDIKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfZ2V0RXNjcm93c1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmFyYzU4X2dldEVzY3Jvd3M6CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAiIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTI3CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTUyOQogICAgLy8gbGV0IHJlc3VsdDogRXNjcm93SW5mb1tdID0gW10KICAgIGJ5dGVjIDcgLy8gMHgwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE1MzAKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBlc2Nyb3dzLmxlbmd0aDsgaSArPSAxKSB7CiAgICBpbnRjXzAgLy8gMAoKYXJjNThfZ2V0RXNjcm93c193aGlsZV90b3BAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTUzMAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGVzY3Jvd3MubGVuZ3RoOyBpICs9IDEpIHsKICAgIGRpZyAyCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGRpZyAxCiAgICA+CiAgICBkdXAKICAgIGJ1cnkgNQogICAgYnogYXJjNThfZ2V0RXNjcm93c19hZnRlcl93aGlsZUA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE1MzEKICAgIC8vIGlmICh0aGlzLmVzY3Jvd3MoZXNjcm93c1tpXSkuZXhpc3RzKSB7CiAgICBkaWcgMgogICAgZXh0cmFjdCAyIDAKICAgIGRpZyA0CiAgICBhc3NlcnQgLy8gaW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGRpZyAxCiAgICBpbnRjXzIgLy8gMgogICAgKgogICAgZGlnIDEKICAgIHN3YXAKICAgIGV4dHJhY3RfdWludDE2CiAgICBkdXAyCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGV4dHJhY3QzCiAgICBleHRyYWN0IDIgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjcKICAgIC8vIGVzY3Jvd3MgPSBCb3hNYXA8c3RyaW5nLCBFc2Nyb3dJbmZvPih7IGtleVByZWZpeDogQWJzdHJhY3RBY2NvdW50Qm94UHJlZml4RXNjcm93cyB9KQogICAgYnl0ZWNfMiAvLyAiZSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBidXJ5IDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTUzMQogICAgLy8gaWYgKHRoaXMuZXNjcm93cyhlc2Nyb3dzW2ldKS5leGlzdHMpIHsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYnogYXJjNThfZ2V0RXNjcm93c19hZnRlcl9pZl9lbHNlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTUzMgogICAgLy8gcmVzdWx0LnB1c2godGhpcy5lc2Nyb3dzKGVzY3Jvd3NbaV0pLnZhbHVlKQogICAgZGlnIDQKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBkaWcgMgogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdCAvLyBvbiBlcnJvcjogbWF4IGFycmF5IGxlbmd0aCBleGNlZWRlZAogICAgc3dhcAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHJlcGxhY2UyIDAKICAgIGJ1cnkgMgoKYXJjNThfZ2V0RXNjcm93c19ibG9ja0A2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTMwCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgZXNjcm93cy5sZW5ndGg7IGkgKz0gMSkgewogICAgZHVwCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnVyeSAxCiAgICBiIGFyYzU4X2dldEVzY3Jvd3Nfd2hpbGVfdG9wQDIKCmFyYzU4X2dldEVzY3Jvd3NfYWZ0ZXJfaWZfZWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTM1CiAgICAvLyByZXN1bHQucHVzaChlbXB0eUVzY3Jvd0luZm8oKSkKICAgIGRpZyAxCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L3V0aWxzLnRzOjIyLTI1CiAgICAvLyByZXR1cm4gewogICAgLy8gICBpZDogMCwKICAgIC8vICAgbG9ja2VkOiBmYWxzZQogICAgLy8gfTsKICAgIHB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDAwMDAwMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTM1CiAgICAvLyByZXN1bHQucHVzaChlbXB0eUVzY3Jvd0luZm8oKSkKICAgIGNvbmNhdCAvLyBvbiBlcnJvcjogbWF4IGFycmF5IGxlbmd0aCBleGNlZWRlZAogICAgc3dhcAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHJlcGxhY2UyIDAKICAgIGJ1cnkgMgogICAgYiBhcmM1OF9nZXRFc2Nyb3dzX2Jsb2NrQDYKCmFyYzU4X2dldEVzY3Jvd3NfYWZ0ZXJfd2hpbGVANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTUyNwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICBieXRlYyA1IC8vIDB4MTUxZjdjNzUKICAgIGRpZyAyCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X2dldEFsbG93YW5jZXNbcm91dGluZ10oKSAtPiB2b2lkOgphcmM1OF9nZXRBbGxvd2FuY2VzOgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU0NwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cG4gMgogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGludGNfMyAvLyA4CiAgICAqCiAgICBpbnRjXzIgLy8gMgogICAgKwogICAgc3dhcAogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3VpbnQ2NFtdKQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTQ5CiAgICAvLyBsZXQgcmVzdWx0OiBBbGxvd2FuY2VJbmZvW10gPSBbXQogICAgaW50Y18wIC8vIDAKICAgIGl0b2IKICAgIGJ5dGVjIDcgLy8gMHgwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE1NTAKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGludGNfMCAvLyAwCgphcmM1OF9nZXRBbGxvd2FuY2VzX3doaWxlX3RvcEAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTUwCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgYXNzZXRzLmxlbmd0aDsgaSArPSAxKSB7CiAgICBkdXAKICAgIGRpZyA0CiAgICA8CiAgICBieiBhcmM1OF9nZXRBbGxvd2FuY2VzX2FmdGVyX3doaWxlQDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU1MQogICAgLy8gY29uc3Qga2V5OiBBbGxvd2FuY2VLZXkgPSB7IGVzY3JvdywgYXNzZXQ6IGFzc2V0c1tpXSB9CiAgICBkaWcgNAogICAgZXh0cmFjdCAyIDAKICAgIGRpZyAxCiAgICBpbnRjXzMgLy8gOAogICAgKgogICAgaW50Y18zIC8vIDgKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBpbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZGlnIDYKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBieXRlYyAxNyAvLyAweDAwMGEKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTY5CiAgICAvLyBhbGxvd2FuY2VzID0gQm94TWFwPEFsbG93YW5jZUtleSwgQWxsb3dhbmNlSW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeEFsbG93YW5jZXMgfSkgLy8gMzhfNTAwCiAgICBieXRlYyAxOCAvLyAiYSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBidXJ5IDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU1MgogICAgLy8gaWYgKHRoaXMuYWxsb3dhbmNlcyhrZXkpLmV4aXN0cykgewogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBieiBhcmM1OF9nZXRBbGxvd2FuY2VzX2FmdGVyX2lmX2Vsc2VANQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTUzCiAgICAvLyByZXN1bHQucHVzaCh0aGlzLmFsbG93YW5jZXMoa2V5KS52YWx1ZSkKICAgIGRpZyA2CiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgZGlnIDIKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQgLy8gb24gZXJyb3I6IG1heCBhcnJheSBsZW5ndGggZXhjZWVkZWQKICAgIHN3YXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICByZXBsYWNlMiAwCiAgICBidXJ5IDIKCmFyYzU4X2dldEFsbG93YW5jZXNfYmxvY2tANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU1MAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGFzc2V0cy5sZW5ndGg7IGkgKz0gMSkgewogICAgZHVwCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnVyeSAxCiAgICBiIGFyYzU4X2dldEFsbG93YW5jZXNfd2hpbGVfdG9wQDIKCmFyYzU4X2dldEFsbG93YW5jZXNfYWZ0ZXJfaWZfZWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvdXRpbHMudHM6MzAKICAgIC8vIHR5cGU6IHVpbnQ4KDApLAogICAgaW50Y18wIC8vIDAKICAgIGNhbGxzdWIgdWludDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L3V0aWxzLnRzOjI5LTM4CiAgICAvLyByZXR1cm4gewogICAgLy8gICB0eXBlOiB1aW50OCgwKSwKICAgIC8vICAgbWF4OiAwLAogICAgLy8gICBhbW91bnQ6IDAsCiAgICAvLyAgIHNwZW50OiAwLAogICAgLy8gICBpbnRlcnZhbDogMCwKICAgIC8vICAgbGFzdDogMCwKICAgIC8vICAgc3RhcnQ6IDAsCiAgICAvLyAgIHVzZVJvdW5kczogZmFsc2UKICAgIC8vIH07CiAgICBkaWcgMwogICAgZHVwCiAgICBjb3ZlciAyCiAgICBjb25jYXQKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgYnl0ZWMgOCAvLyAweDAwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU1NgogICAgLy8gcmVzdWx0LnB1c2goZW1wdHlBbGxvd2FuY2VJbmZvKCkpCiAgICBkaWcgMgogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdCAvLyBvbiBlcnJvcjogbWF4IGFycmF5IGxlbmd0aCBleGNlZWRlZAogICAgc3dhcAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHJlcGxhY2UyIDAKICAgIGJ1cnkgMgogICAgYiBhcmM1OF9nZXRBbGxvd2FuY2VzX2Jsb2NrQDYKCmFyYzU4X2dldEFsbG93YW5jZXNfYWZ0ZXJfd2hpbGVANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU0NwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICBieXRlYyA1IC8vIDB4MTUxZjdjNzUKICAgIGRpZyAyCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X2dldEV4ZWN1dGlvbnNbcm91dGluZ10oKSAtPiB2b2lkOgphcmM1OF9nZXRFeGVjdXRpb25zOgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU2NwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXBuIDIKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICAqCiAgICBpbnRjXzIgLy8gMgogICAgKwogICAgc3dhcAogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3VpbnQ4WzMyXVtdKQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTY5CiAgICAvLyBsZXQgcmVzdWx0OiBFeGVjdXRpb25JbmZvW10gPSBbXQogICAgYnl0ZWMgNyAvLyAweDAwMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU3MAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGxlYXNlcy5sZW5ndGg7IGkgKz0gMSkgewogICAgaW50Y18wIC8vIDAKCmFyYzU4X2dldEV4ZWN1dGlvbnNfd2hpbGVfdG9wQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE1NzAKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBsZWFzZXMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGR1cAogICAgZGlnIDMKICAgIDwKICAgIGJ6IGFyYzU4X2dldEV4ZWN1dGlvbnNfYWZ0ZXJfd2hpbGVANwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTcxCiAgICAvLyBpZiAodGhpcy5leGVjdXRpb25zKGxlYXNlc1tpXSkuZXhpc3RzKSB7CiAgICBkaWcgMwogICAgZXh0cmFjdCAyIDAKICAgIGRpZyAxCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICAqCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogaW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTcxCiAgICAvLyBleGVjdXRpb25zID0gQm94TWFwPGJ5dGVzPDMyPiwgRXhlY3V0aW9uSW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeEV4ZWN1dGlvbnMgfSkKICAgIGJ5dGVjIDkgLy8gIngiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgYnVyeSA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE1NzEKICAgIC8vIGlmICh0aGlzLmV4ZWN1dGlvbnMobGVhc2VzW2ldKS5leGlzdHMpIHsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYnogYXJjNThfZ2V0RXhlY3V0aW9uc19hZnRlcl9pZl9lbHNlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU3MgogICAgLy8gcmVzdWx0LnB1c2godGhpcy5leGVjdXRpb25zKGxlYXNlc1tpXSkudmFsdWUpCiAgICBkaWcgNAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGRpZyAyCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgc3dhcAogICAgZXh0cmFjdCAyIDAKICAgIGJ5dGVjIDEyIC8vIDB4MDAwMgogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIGNvdmVyIDIKICAgIGludGNfMSAvLyAxCiAgICB1bmNvdmVyIDMKICAgIGNhbGxzdWIgZHluYW1pY19hcnJheV9jb25jYXRfZHluYW1pY19lbGVtZW50CiAgICBidXJ5IDIKCmFyYzU4X2dldEV4ZWN1dGlvbnNfYmxvY2tANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU3MAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGxlYXNlcy5sZW5ndGg7IGkgKz0gMSkgewogICAgZHVwCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnVyeSAxCiAgICBiIGFyYzU4X2dldEV4ZWN1dGlvbnNfd2hpbGVfdG9wQDIKCmFyYzU4X2dldEV4ZWN1dGlvbnNfYWZ0ZXJfaWZfZWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTc1CiAgICAvLyByZXN1bHQucHVzaChlbXB0eUV4ZWN1dGlvbkluZm8oKSkKICAgIGRpZyAxCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgc3dhcAogICAgZXh0cmFjdCAyIDAKICAgIGludGNfMSAvLyAxCiAgICBwdXNoYnl0ZXMgMHgwMDAyMDAxMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAogICAgY2FsbHN1YiBkeW5hbWljX2FycmF5X2NvbmNhdF9keW5hbWljX2VsZW1lbnQKICAgIGJ1cnkgMgogICAgYiBhcmM1OF9nZXRFeGVjdXRpb25zX2Jsb2NrQDYKCmFyYzU4X2dldEV4ZWN1dGlvbnNfYWZ0ZXJfd2hpbGVANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU2NwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICBieXRlYyA1IC8vIDB4MTUxZjdjNzUKICAgIGRpZyAyCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X2dldERvbWFpbktleXNbcm91dGluZ10oKSAtPiB2b2lkOgphcmM1OF9nZXREb21haW5LZXlzOgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU4NgogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXBuIDIKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICAqCiAgICBpbnRjXzIgLy8gMgogICAgKwogICAgc3dhcAogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3VpbnQ4WzMyXVtdKQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTg4CiAgICAvLyBsZXQgcmVzdWx0OiBzdHJpbmdbXSA9IFtdCiAgICBieXRlYyA3IC8vIDB4MDAwMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTg5CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgYWRkcmVzc2VzLmxlbmd0aDsgaSArPSAxKSB7CiAgICBpbnRjXzAgLy8gMAoKYXJjNThfZ2V0RG9tYWluS2V5c193aGlsZV90b3BAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU4OQogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGFkZHJlc3Nlcy5sZW5ndGg7IGkgKz0gMSkgewogICAgZHVwCiAgICBkaWcgMwogICAgPAogICAgYnogYXJjNThfZ2V0RG9tYWluS2V5c19hZnRlcl93aGlsZUA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE1OTAKICAgIC8vIGlmICh0aGlzLmRvbWFpbktleXMoYWRkcmVzc2VzW2ldKS5leGlzdHMpIHsKICAgIGRpZyAzCiAgICBleHRyYWN0IDIgMAogICAgZGlnIDEKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgICoKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBpbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxODIKICAgIC8vIGRvbWFpbktleXMgPSBCb3hNYXA8QWNjb3VudCwgc3RyaW5nPih7IGtleVByZWZpeDogQWJzdHJhY3RBY2NvdW50Qm94UHJlZml4RG9tYWluS2V5cyB9KQogICAgYnl0ZWMgMTYgLy8gImQiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgYnVyeSA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE1OTAKICAgIC8vIGlmICh0aGlzLmRvbWFpbktleXMoYWRkcmVzc2VzW2ldKS5leGlzdHMpIHsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYnogYXJjNThfZ2V0RG9tYWluS2V5c19hZnRlcl9pZl9lbHNlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU5MQogICAgLy8gcmVzdWx0LnB1c2godGhpcy5kb21haW5LZXlzKGFkZHJlc3Nlc1tpXSkudmFsdWUpCiAgICBkaWcgNAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICBkaWcgMgogICAgc3dhcAogICAgaW50Y18xIC8vIDEKICAgIGNhbGxzdWIgZHluYW1pY19hcnJheV9jb25jYXRfYnl0ZV9sZW5ndGhfaGVhZAogICAgYnVyeSAyCgphcmM1OF9nZXREb21haW5LZXlzX2Jsb2NrQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE1ODkKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBhZGRyZXNzZXMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGR1cAogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgMQogICAgYiBhcmM1OF9nZXREb21haW5LZXlzX3doaWxlX3RvcEAyCgphcmM1OF9nZXREb21haW5LZXlzX2FmdGVyX2lmX2Vsc2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU5NAogICAgLy8gcmVzdWx0LnB1c2goIiIpCiAgICBkaWcgMQogICAgYnl0ZWMgNyAvLyAweDAwMDAKICAgIGludGNfMSAvLyAxCiAgICBjYWxsc3ViIGR5bmFtaWNfYXJyYXlfY29uY2F0X2J5dGVfbGVuZ3RoX2hlYWQKICAgIGJ1cnkgMgogICAgYiBhcmM1OF9nZXREb21haW5LZXlzX2Jsb2NrQDYKCmFyYzU4X2dldERvbWFpbktleXNfYWZ0ZXJfd2hpbGVANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTU4NgogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICBieXRlYyA1IC8vIDB4MTUxZjdjNzUKICAgIGRpZyAyCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50Lm1icltyb3V0aW5nXSgpIC0+IHZvaWQ6Cm1icjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTYwOAogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18yIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjIwNQogICAgLy8gcmV0dXJuIE1pbkVzY3Jvd3NNQlIgKyAoQm94Q29zdFBlckJ5dGUgKiBCeXRlcyhlc2Nyb3cpLmxlbmd0aCk7CiAgICBkaWcgMwogICAgbGVuCiAgICBpbnRjIDQgLy8gNDAwCiAgICAqCiAgICBwdXNoaW50IDY1MDAgLy8gNjUwMAogICAgZGlnIDEKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTYxOAogICAgLy8gcGx1Z2luczogdGhpcy5wbHVnaW5zTWJyKGVzY3JvdywgbWV0aG9kQ291bnQpLAogICAgZGlnIDUKICAgIHVuY292ZXIgNQogICAgY2FsbHN1YiBwbHVnaW5zTWJyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjIwMQogICAgLy8gcmV0dXJuIE1pbk5hbWVkUGx1Z2luTUJSICsgKEJveENvc3RQZXJCeXRlICogQnl0ZXMobmFtZSkubGVuZ3RoKTsKICAgIHVuY292ZXIgNAogICAgbGVuCiAgICBpbnRjIDQgLy8gNDAwCiAgICAqCiAgICBpbnRjIDUgLy8gMTg5MDAKICAgIGRpZyAxCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjIwOQogICAgLy8gcmV0dXJuIE1pbkFsbG93YW5jZU1CUiArIChCb3hDb3N0UGVyQnl0ZSAqIEJ5dGVzKGVzY3JvdykubGVuZ3RoKTsKICAgIGludGMgNiAvLyAyNzcwMAogICAgdW5jb3ZlciA1CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjIxNwogICAgLy8gcmV0dXJuIE1pbkRvbWFpbktleXNNQlIgKyAoQm94Q29zdFBlckJ5dGUgKiBCeXRlcyhkb21haW4pLmxlbmd0aCkKICAgIHB1c2hpbnQgMTU3MDAgLy8gMTU3MDAKICAgIHVuY292ZXIgMwogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyMTMKICAgIC8vIHJldHVybiBNaW5FeGVjdXRpb25zTUJSICsgKEJveENvc3RQZXJCeXRlICogKGdyb3VwcyAqIDMyKSk7CiAgICB1bmNvdmVyIDUKICAgIHB1c2hpbnQgMTI4MDAgLy8gMTI4MDAKICAgICoKICAgIHB1c2hpbnQgMjA1MDAgLy8gMjA1MDAKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTY3CiAgICAvLyBlc2Nyb3dzID0gQm94TWFwPHN0cmluZywgRXNjcm93SW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeEVzY3Jvd3MgfSkKICAgIGJ5dGVjXzIgLy8gImUiCiAgICB1bmNvdmVyIDcKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjI0CiAgICAvLyBlc2Nyb3dFeGlzdHM6IHRoaXMuZXNjcm93cyhlc2Nyb3cpLmV4aXN0cywKICAgIGJveF9sZW4KICAgIGNvdmVyIDYKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjI3CiAgICAvLyBHbG9iYWwubWluQmFsYW5jZSArCiAgICBnbG9iYWwgTWluQmFsYW5jZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjI2LTE2MjgKICAgIC8vIE5ld0Nvc3RGb3JBUkM1OCArCiAgICAvLyBHbG9iYWwubWluQmFsYW5jZSArCiAgICAvLyBBUkM1OFdhbGxldElEc0J5QWNjb3VudHNNYnIgKwogICAgcHVzaGludCAxNjIxMDAgLy8gMTYyMTAwCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE2MjYtMTYyOQogICAgLy8gTmV3Q29zdEZvckFSQzU4ICsKICAgIC8vIEdsb2JhbC5taW5CYWxhbmNlICsKICAgIC8vIEFSQzU4V2FsbGV0SURzQnlBY2NvdW50c01iciArCiAgICAvLyBlc2Nyb3dzCiAgICBkaWcgNwogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjE3LTE2MzEKICAgIC8vIHJldHVybiB7CiAgICAvLyAgIHBsdWdpbnM6IHRoaXMucGx1Z2luc01icihlc2Nyb3csIG1ldGhvZENvdW50KSwKICAgIC8vICAgbmFtZWRQbHVnaW5zOiB0aGlzLm5hbWVkUGx1Z2luc01icihwbHVnaW4pLAogICAgLy8gICBlc2Nyb3dzLAogICAgLy8gICBhbGxvd2FuY2VzOiB0aGlzLmFsbG93YW5jZXNNYnIoZXNjcm93KSwKICAgIC8vICAgZG9tYWluS2V5czogdGhpcy5kb21haW5LZXlzTWJyKHBsdWdpbiksCiAgICAvLyAgIGV4ZWN1dGlvbnM6IHRoaXMuZXhlY3V0aW9uc01icihncm91cHMpLAogICAgLy8gICBlc2Nyb3dFeGlzdHM6IHRoaXMuZXNjcm93cyhlc2Nyb3cpLmV4aXN0cywKICAgIC8vICAgbmV3RXNjcm93TWludENvc3Q6ICgKICAgIC8vICAgICBOZXdDb3N0Rm9yQVJDNTggKwogICAgLy8gICAgIEdsb2JhbC5taW5CYWxhbmNlICsKICAgIC8vICAgICBBUkM1OFdhbGxldElEc0J5QWNjb3VudHNNYnIgKwogICAgLy8gICAgIGVzY3Jvd3MKICAgIC8vICAgKQogICAgLy8gfQogICAgdW5jb3ZlciA1CiAgICBpdG9iCiAgICB1bmNvdmVyIDUKICAgIGl0b2IKICAgIGNvbmNhdAogICAgdW5jb3ZlciA2CiAgICBpdG9iCiAgICBjb25jYXQKICAgIHVuY292ZXIgNAogICAgaXRvYgogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGl0b2IKICAgIGNvbmNhdAogICAgdW5jb3ZlciAyCiAgICBpdG9iCiAgICBjb25jYXQKICAgIGJ5dGVjIDggLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgNAogICAgc2V0Yml0CiAgICBjb25jYXQKICAgIHN3YXAKICAgIGl0b2IKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjA4CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGJ5dGVjIDUgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5iYWxhbmNlW3JvdXRpbmddKCkgLT4gdm9pZDoKYmFsYW5jZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTY0MAogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18zIC8vIDgKICAgICoKICAgIGludGNfMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3VpbnQ2NFtdKQogICAgY2FsbHN1YiBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5iYWxhbmNlCiAgICBwb3AKICAgIGJ5dGVjIDUgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5wbHVnaW5zTWJyKGVzY3JvdzogYnl0ZXMsIG1ldGhvZENvdW50OiB1aW50NjQpIC0+IHVpbnQ2NDoKcGx1Z2luc01icjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTk0CiAgICAvLyBwcml2YXRlIHBsdWdpbnNNYnIoZXNjcm93OiBzdHJpbmcsIG1ldGhvZENvdW50OiB1aW50NjQpOiB1aW50NjQgewogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE5NgogICAgLy8gQm94Q29zdFBlckJ5dGUgKiAoKE1ldGhvZFJlc3RyaWN0aW9uQnl0ZUxlbmd0aCAqIG1ldGhvZENvdW50KSArIEJ5dGVzKGVzY3JvdykubGVuZ3RoKQogICAgcHVzaGludCAyMCAvLyAyMAogICAgZnJhbWVfZGlnIC0xCiAgICAqCiAgICBmcmFtZV9kaWcgLTIKICAgIGxlbgogICAgKwogICAgaW50YyA0IC8vIDQwMAogICAgKgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxOTUKICAgIC8vIHJldHVybiBNaW5QbHVnaW5NQlIgKyAoCiAgICBwdXNoaW50IDM4OTAwIC8vIDM4OTAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE5NS0xOTcKICAgIC8vIHJldHVybiBNaW5QbHVnaW5NQlIgKyAoCiAgICAvLyAgIEJveENvc3RQZXJCeXRlICogKChNZXRob2RSZXN0cmljdGlvbkJ5dGVMZW5ndGggKiBtZXRob2RDb3VudCkgKyBCeXRlcyhlc2Nyb3cpLmxlbmd0aCkKICAgIC8vICk7CiAgICArCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5tYXliZU5ld0VzY3Jvdyhlc2Nyb3c6IGJ5dGVzKSAtPiB1aW50NjQ6Cm1heWJlTmV3RXNjcm93OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyMjAKICAgIC8vIHByaXZhdGUgbWF5YmVOZXdFc2Nyb3coZXNjcm93OiBzdHJpbmcpOiB1aW50NjQgewogICAgcHJvdG8gMSAxCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyMjEKICAgIC8vIGlmIChlc2Nyb3cgPT09ICcnKSB7CiAgICBmcmFtZV9kaWcgLTEKICAgIGJ5dGVjXzEgLy8gIiIKICAgID09CiAgICBieiBtYXliZU5ld0VzY3Jvd19hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MjIyCiAgICAvLyByZXR1cm4gMAogICAgaW50Y18wIC8vIDAKICAgIHN3YXAKICAgIHJldHN1YgoKbWF5YmVOZXdFc2Nyb3dfYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjcKICAgIC8vIGVzY3Jvd3MgPSBCb3hNYXA8c3RyaW5nLCBFc2Nyb3dJbmZvPih7IGtleVByZWZpeDogQWJzdHJhY3RBY2NvdW50Qm94UHJlZml4RXNjcm93cyB9KQogICAgYnl0ZWNfMiAvLyAiZSIKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyMjUKICAgIC8vIHJldHVybiB0aGlzLmVzY3Jvd3MoZXNjcm93KS5leGlzdHMKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyMjUtMjI3CiAgICAvLyByZXR1cm4gdGhpcy5lc2Nyb3dzKGVzY3JvdykuZXhpc3RzCiAgICAvLyAgID8gdGhpcy5lc2Nyb3dzKGVzY3JvdykudmFsdWUuaWQKICAgIC8vICAgOiB0aGlzLm5ld0VzY3Jvdyhlc2Nyb3cpCiAgICBieiBtYXliZU5ld0VzY3Jvd190ZXJuYXJ5X2ZhbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MjI2CiAgICAvLyA/IHRoaXMuZXNjcm93cyhlc2Nyb3cpLnZhbHVlLmlkCiAgICBmcmFtZV9kaWcgMAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAoKbWF5YmVOZXdFc2Nyb3dfdGVybmFyeV9tZXJnZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyMjUtMjI3CiAgICAvLyByZXR1cm4gdGhpcy5lc2Nyb3dzKGVzY3JvdykuZXhpc3RzCiAgICAvLyAgID8gdGhpcy5lc2Nyb3dzKGVzY3JvdykudmFsdWUuaWQKICAgIC8vICAgOiB0aGlzLm5ld0VzY3Jvdyhlc2Nyb3cpCiAgICBzd2FwCiAgICByZXRzdWIKCm1heWJlTmV3RXNjcm93X3Rlcm5hcnlfZmFsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MjI3CiAgICAvLyA6IHRoaXMubmV3RXNjcm93KGVzY3JvdykKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBuZXdFc2Nyb3cKICAgIGIgbWF5YmVOZXdFc2Nyb3dfdGVybmFyeV9tZXJnZUA1CgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQubmV3RXNjcm93KGVzY3JvdzogYnl0ZXMpIC0+IHVpbnQ2NDoKbmV3RXNjcm93OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyMzAKICAgIC8vIHByaXZhdGUgbmV3RXNjcm93KGVzY3Jvdzogc3RyaW5nKTogdWludDY0IHsKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyMzEKICAgIC8vIGlmICh0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlICE9PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcykgewogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTMyCiAgICAvLyBjb250cm9sbGVkQWRkcmVzcyA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcyB9KTsKICAgIGJ5dGVjXzAgLy8gImNvbnRyb2xsZWRfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MjMxCiAgICAvLyBpZiAodGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSAhPT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MpIHsKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgIT0KICAgIGJ6IG5ld0VzY3Jvd19hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MjMyLTIzOAogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IHRoaXMuZXNjcm93c01icihlc2Nyb3cpCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyMzQKICAgIC8vIHNlbmRlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMgogICAgLy8gY29udHJvbGxlZEFkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MgfSk7CiAgICBieXRlY18wIC8vICJjb250cm9sbGVkX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjIzNAogICAgLy8gc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MjM1CiAgICAvLyByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyMDUKICAgIC8vIHJldHVybiBNaW5Fc2Nyb3dzTUJSICsgKEJveENvc3RQZXJCeXRlICogQnl0ZXMoZXNjcm93KS5sZW5ndGgpOwogICAgZnJhbWVfZGlnIC0xCiAgICBsZW4KICAgIGludGMgNCAvLyA0MDAKICAgICoKICAgIHB1c2hpbnQgNjUwMCAvLyA2NTAwCiAgICArCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MjMyLTIzNwogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IHRoaXMuZXNjcm93c01icihlc2Nyb3cpCiAgICAvLyAgIH0pCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjIzMi0yMzgKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHNlbmRlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50OiB0aGlzLmVzY3Jvd3NNYnIoZXNjcm93KQogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CgpuZXdFc2Nyb3dfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyNDEtMjUxCiAgICAvLyBjb25zdCBpZCA9IGFiaUNhbGw8dHlwZW9mIEVzY3Jvd0ZhY3RvcnkucHJvdG90eXBlLm5ldz4oewogICAgLy8gICBzZW5kZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICAvLyAgIGFwcElkOiB0aGlzLmVzY3Jvd0ZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgICAgYW1vdW50OiBOZXdDb3N0Rm9yQVJDNTggKyBHbG9iYWwubWluQmFsYW5jZSwKICAgIC8vICAgICAgIHJlY2VpdmVyOiB0aGlzLmVzY3Jvd0ZhY3RvcnkudmFsdWUuYWRkcmVzcwogICAgLy8gICAgIH0pLAogICAgLy8gICBdCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyNDYKICAgIC8vIHNlbmRlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMgogICAgLy8gY29udHJvbGxlZEFkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MgfSk7CiAgICBieXRlY18wIC8vICJjb250cm9sbGVkX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjI0NgogICAgLy8gc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MjQ3CiAgICAvLyBhbW91bnQ6IE5ld0Nvc3RGb3JBUkM1OCArIEdsb2JhbC5taW5CYWxhbmNlLAogICAgcHVzaGludCAxNTAwMDAgLy8gMTUwMDAwCiAgICBnbG9iYWwgTWluQmFsYW5jZQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyNDgKICAgIC8vIHJlY2VpdmVyOiB0aGlzLmVzY3Jvd0ZhY3RvcnkudmFsdWUuYWRkcmVzcwogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTUyCiAgICAvLyBlc2Nyb3dGYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNFc2Nyb3dGYWN0b3J5IH0pCiAgICBieXRlYyAyMiAvLyAiZXNjcm93X2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjI0OAogICAgLy8gcmVjZWl2ZXI6IHRoaXMuZXNjcm93RmFjdG9yeS52YWx1ZS5hZGRyZXNzCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjI0NS0yNDkKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIC8vICAgYW1vdW50OiBOZXdDb3N0Rm9yQVJDNTggKyBHbG9iYWwubWluQmFsYW5jZSwKICAgIC8vICAgcmVjZWl2ZXI6IHRoaXMuZXNjcm93RmFjdG9yeS52YWx1ZS5hZGRyZXNzCiAgICAvLyB9KSwKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MjQxLTI1MQogICAgLy8gY29uc3QgaWQgPSBhYmlDYWxsPHR5cGVvZiBFc2Nyb3dGYWN0b3J5LnByb3RvdHlwZS5uZXc+KHsKICAgIC8vICAgc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICBhcHBJZDogdGhpcy5lc2Nyb3dGYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIC8vICAgICAgIGFtb3VudDogTmV3Q29zdEZvckFSQzU4ICsgR2xvYmFsLm1pbkJhbGFuY2UsCiAgICAvLyAgICAgICByZWNlaXZlcjogdGhpcy5lc2Nyb3dGYWN0b3J5LnZhbHVlLmFkZHJlc3MKICAgIC8vICAgICB9KSwKICAgIC8vICAgXQogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fbmV4dAogICAgcHVzaGJ5dGVzIDB4ZDg1Y2YxODQgLy8gbWV0aG9kICJuZXcocGF5KXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgZ2l0eG4gMSBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWMgNSAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjI1MwogICAgLy8gdGhpcy5lc2Nyb3dzKGVzY3JvdykudmFsdWUgPSB7IGlkLCBsb2NrZWQ6IGZhbHNlIH0KICAgIGR1cAogICAgaXRvYgogICAgYnl0ZWMgOCAvLyAweDAwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTY3CiAgICAvLyBlc2Nyb3dzID0gQm94TWFwPHN0cmluZywgRXNjcm93SW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeEVzY3Jvd3MgfSkKICAgIGJ5dGVjXzIgLy8gImUiCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyNTMKICAgIC8vIHRoaXMuZXNjcm93cyhlc2Nyb3cpLnZhbHVlID0geyBpZCwgbG9ja2VkOiBmYWxzZSB9CiAgICBzd2FwCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjI1NQogICAgLy8gcmV0dXJuIGlkOwogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuaXNBZG1pbigpIC0+IHVpbnQ2NDoKaXNBZG1pbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MjYxCiAgICAvLyBUeG4uc2VuZGVyID09PSB0aGlzLmFkbWluLnZhbHVlIHx8CiAgICB0eG4gU2VuZGVyCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMjgKICAgIC8vIGFkbWluID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0FkbWluIH0pCiAgICBieXRlYyAxMyAvLyAiYWRtaW4iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjI2MQogICAgLy8gVHhuLnNlbmRlciA9PT0gdGhpcy5hZG1pbi52YWx1ZSB8fAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjI2MS0yNjIKICAgIC8vIFR4bi5zZW5kZXIgPT09IHRoaXMuYWRtaW4udmFsdWUgfHwKICAgIC8vICh0aGlzLmRvbWFpbktleXMoVHhuLnNlbmRlcikuZXhpc3RzICYmIHRoaXMuZG9tYWluS2V5cyhUeG4uc2VuZGVyKS52YWx1ZSA9PT0gdGhpcy5kb21haW4udmFsdWUpCiAgICBibnogaXNBZG1pbl9ib29sX3RydWVAMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxODIKICAgIC8vIGRvbWFpbktleXMgPSBCb3hNYXA8QWNjb3VudCwgc3RyaW5nPih7IGtleVByZWZpeDogQWJzdHJhY3RBY2NvdW50Qm94UHJlZml4RG9tYWluS2V5cyB9KQogICAgYnl0ZWMgMTYgLy8gImQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjI2MgogICAgLy8gKHRoaXMuZG9tYWluS2V5cyhUeG4uc2VuZGVyKS5leGlzdHMgJiYgdGhpcy5kb21haW5LZXlzKFR4bi5zZW5kZXIpLnZhbHVlID09PSB0aGlzLmRvbWFpbi52YWx1ZSkKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTgyCiAgICAvLyBkb21haW5LZXlzID0gQm94TWFwPEFjY291bnQsIHN0cmluZz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeERvbWFpbktleXMgfSkKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyNjIKICAgIC8vICh0aGlzLmRvbWFpbktleXMoVHhuLnNlbmRlcikuZXhpc3RzICYmIHRoaXMuZG9tYWluS2V5cyhUeG4uc2VuZGVyKS52YWx1ZSA9PT0gdGhpcy5kb21haW4udmFsdWUpCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGJ6IGlzQWRtaW5fYm9vbF9mYWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE4MgogICAgLy8gZG9tYWluS2V5cyA9IEJveE1hcDxBY2NvdW50LCBzdHJpbmc+KHsga2V5UHJlZml4OiBBYnN0cmFjdEFjY291bnRCb3hQcmVmaXhEb21haW5LZXlzIH0pCiAgICBieXRlYyAxNiAvLyAiZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MjYyCiAgICAvLyAodGhpcy5kb21haW5LZXlzKFR4bi5zZW5kZXIpLmV4aXN0cyAmJiB0aGlzLmRvbWFpbktleXMoVHhuLnNlbmRlcikudmFsdWUgPT09IHRoaXMuZG9tYWluLnZhbHVlKQogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxODIKICAgIC8vIGRvbWFpbktleXMgPSBCb3hNYXA8QWNjb3VudCwgc3RyaW5nPih7IGtleVByZWZpeDogQWJzdHJhY3RBY2NvdW50Qm94UHJlZml4RG9tYWluS2V5cyB9KQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjI2MgogICAgLy8gKHRoaXMuZG9tYWluS2V5cyhUeG4uc2VuZGVyKS5leGlzdHMgJiYgdGhpcy5kb21haW5LZXlzKFR4bi5zZW5kZXIpLnZhbHVlID09PSB0aGlzLmRvbWFpbi52YWx1ZSkKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzAKICAgIC8vIGRvbWFpbiA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0RvbWFpbiB9KTsKICAgIGJ5dGVjIDIxIC8vICJkb21haW4iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjI2MgogICAgLy8gKHRoaXMuZG9tYWluS2V5cyhUeG4uc2VuZGVyKS5leGlzdHMgJiYgdGhpcy5kb21haW5LZXlzKFR4bi5zZW5kZXIpLnZhbHVlID09PSB0aGlzLmRvbWFpbi52YWx1ZSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICA9PQogICAgYnogaXNBZG1pbl9ib29sX2ZhbHNlQDQKCmlzQWRtaW5fYm9vbF90cnVlQDM6CiAgICBpbnRjXzEgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyNjAtMjYzCiAgICAvLyByZXR1cm4gKAogICAgLy8gICBUeG4uc2VuZGVyID09PSB0aGlzLmFkbWluLnZhbHVlIHx8CiAgICAvLyAgICh0aGlzLmRvbWFpbktleXMoVHhuLnNlbmRlcikuZXhpc3RzICYmIHRoaXMuZG9tYWluS2V5cyhUeG4uc2VuZGVyKS52YWx1ZSA9PT0gdGhpcy5kb21haW4udmFsdWUpCiAgICAvLyApCiAgICByZXRzdWIKCmlzQWRtaW5fYm9vbF9mYWxzZUA0OgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MjYwLTI2MwogICAgLy8gcmV0dXJuICgKICAgIC8vICAgVHhuLnNlbmRlciA9PT0gdGhpcy5hZG1pbi52YWx1ZSB8fAogICAgLy8gICAodGhpcy5kb21haW5LZXlzKFR4bi5zZW5kZXIpLmV4aXN0cyAmJiB0aGlzLmRvbWFpbktleXMoVHhuLnNlbmRlcikudmFsdWUgPT09IHRoaXMuZG9tYWluLnZhbHVlKQogICAgLy8gKQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuY2FuUmV2b2tlKCkgLT4gdWludDY0OgpjYW5SZXZva2U6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjI2OAogICAgLy8gcmV0dXJuIFR4bi5zZW5kZXIgPT09IHRoaXMucmV2b2NhdGlvbi52YWx1ZS5hZGRyZXNzCiAgICB0eG4gU2VuZGVyCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNTYKICAgIC8vIHJldm9jYXRpb24gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5UmV2b2NhdGlvbiB9KQogICAgYnl0ZWMgMjMgLy8gInJldm9jYXRpb24iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjI2OAogICAgLy8gcmV0dXJuIFR4bi5zZW5kZXIgPT09IHRoaXMucmV2b2NhdGlvbi52YWx1ZS5hZGRyZXNzCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LnBsdWdpbkNhbGxBbGxvd2VkKHBsdWdpbjogdWludDY0LCBjYWxsZXI6IGJ5dGVzLCBlc2Nyb3c6IGJ5dGVzLCBtZXRob2Q6IGJ5dGVzKSAtPiB1aW50NjQ6CnBsdWdpbkNhbGxBbGxvd2VkOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyNzEKICAgIC8vIHByaXZhdGUgcGx1Z2luQ2FsbEFsbG93ZWQocGx1Z2luOiB1aW50NjQsIGNhbGxlcjogQWNjb3VudCwgZXNjcm93OiBzdHJpbmcsIG1ldGhvZDogYnl0ZXM8ND4pOiBib29sZWFuIHsKICAgIHByb3RvIDQgMQogICAgYnl0ZWNfMSAvLyAiIgogICAgZHVwbiA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjI3MgogICAgLy8gY29uc3Qga2V5OiBQbHVnaW5LZXkgPSB7IHBsdWdpbiwgY2FsbGVyLCBlc2Nyb3cgfQogICAgZnJhbWVfZGlnIC00CiAgICBpdG9iCiAgICBmcmFtZV9kaWcgLTMKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIC0yCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBmcmFtZV9kaWcgLTIKICAgIGNvbmNhdAogICAgc3dhcAogICAgYnl0ZWMgMTEgLy8gMHgwMDJhCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjMKICAgIC8vIHBsdWdpbnMgPSBCb3hNYXA8UGx1Z2luS2V5LCBQbHVnaW5JbmZvPih7IGtleVByZWZpeDogQWJzdHJhY3RBY2NvdW50Qm94UHJlZml4UGx1Z2lucyB9KTsKICAgIGJ5dGVjXzMgLy8gInAiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyNzQKICAgIC8vIGlmICghdGhpcy5wbHVnaW5zKGtleSkuZXhpc3RzKSB7CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGJueiBwbHVnaW5DYWxsQWxsb3dlZF9hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Mjc1CiAgICAvLyByZXR1cm4gZmFsc2U7CiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCnBsdWdpbkNhbGxBbGxvd2VkX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Mjc4CiAgICAvLyBjb25zdCB7IG1ldGhvZHMsIHVzZVJvdW5kcywgbGFzdENhbGxlZCwgY29vbGRvd24sIHVzZUV4ZWN1dGlvbktleSB9ID0gdGhpcy5wbHVnaW5zKGtleSkudmFsdWUgYXMgUmVhZG9ubHk8UGx1Z2luSW5mbz4KICAgIGZyYW1lX2RpZyA2CiAgICBkdXAKICAgIHB1c2hpbnQgMTcgLy8gMTcKICAgIGludGNfMyAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZnJhbWVfYnVyeSAwCiAgICBkdXAKICAgIHB1c2hpbnQgMjcgLy8gMjcKICAgIGludGNfMSAvLyAxCiAgICBib3hfZXh0cmFjdAogICAgZHVwCiAgICBpbnRjXzEgLy8gMQogICAgZ2V0Yml0CiAgICBmcmFtZV9idXJ5IDUKICAgIGludGNfMiAvLyAyCiAgICBnZXRiaXQKICAgIHN3YXAKICAgIHB1c2hpbnQgMjggLy8gMjgKICAgIGludGNfMyAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZnJhbWVfYnVyeSAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjI4MAogICAgLy8gaWYgKHVzZUV4ZWN1dGlvbktleSkgewogICAgYnogcGx1Z2luQ2FsbEFsbG93ZWRfYWZ0ZXJfaWZfZWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjI4MQogICAgLy8gcmV0dXJuIGZhbHNlCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCnBsdWdpbkNhbGxBbGxvd2VkX2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Mjg0CiAgICAvLyBsZXQgbWV0aG9kQWxsb3dlZCA9IG1ldGhvZHMubGVuZ3RoID4gMCA/IGZhbHNlIDogdHJ1ZTsKICAgIGZyYW1lX2RpZyA2CiAgICBwdXNoaW50IDQ0IC8vIDQ0CiAgICBpbnRjXzIgLy8gMgogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgICEKICAgIGZyYW1lX2J1cnkgNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyODUKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSArPSAxKSB7CiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAyCgpwbHVnaW5DYWxsQWxsb3dlZF93aGlsZV90b3BANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Mjg1CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkgKz0gMSkgewogICAgZnJhbWVfZGlnIDYKICAgIHB1c2hpbnQgNDQgLy8gNDQKICAgIGludGNfMiAvLyAyCiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZnJhbWVfZGlnIDIKICAgID4KICAgIGJ6IHBsdWdpbkNhbGxBbGxvd2VkX2Jsb2NrQDEwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjI4NgogICAgLy8gaWYgKG1ldGhvZHNbaV0uc2VsZWN0b3IgPT09IG1ldGhvZCkgewogICAgZnJhbWVfZGlnIDIKICAgIHB1c2hpbnQgMjAgLy8gMjAKICAgICoKICAgIHB1c2hpbnQgNDYgLy8gNDYKICAgICsKICAgIGZyYW1lX2RpZyA2CiAgICBzd2FwCiAgICBwdXNoaW50IDIwIC8vIDIwCiAgICBib3hfZXh0cmFjdAogICAgZXh0cmFjdCAwIDQKICAgIGZyYW1lX2RpZyAtMQogICAgPT0KICAgIGJ6IHBsdWdpbkNhbGxBbGxvd2VkX2FmdGVyX2lmX2Vsc2VAOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyODcKICAgIC8vIG1ldGhvZEFsbG93ZWQgPSB0cnVlOwogICAgaW50Y18xIC8vIDEKICAgIGZyYW1lX2J1cnkgNAoKcGx1Z2luQ2FsbEFsbG93ZWRfYmxvY2tAMTA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjI5MgogICAgLy8gY29uc3QgZXBvY2hSZWYgPSB1c2VSb3VuZHMgPyBHbG9iYWwucm91bmQgOiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wOwogICAgZnJhbWVfZGlnIDUKICAgIGJ6IHBsdWdpbkNhbGxBbGxvd2VkX3Rlcm5hcnlfZmFsc2VAMTIKICAgIGdsb2JhbCBSb3VuZAogICAgZnJhbWVfYnVyeSAxCgpwbHVnaW5DYWxsQWxsb3dlZF90ZXJuYXJ5X21lcmdlQDEzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyOTUKICAgIC8vIGxhc3RDYWxsZWQgPj0gZXBvY2hSZWYgJiYKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9kaWcgMQogICAgPj0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Mjk1LTI5NgogICAgLy8gbGFzdENhbGxlZCA+PSBlcG9jaFJlZiAmJgogICAgLy8gKGVwb2NoUmVmIC0gbGFzdENhbGxlZCkgPj0gY29vbGRvd24gJiYKICAgIGJ6IHBsdWdpbkNhbGxBbGxvd2VkX2Jvb2xfZmFsc2VAMTYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Mjk2CiAgICAvLyAoZXBvY2hSZWYgLSBsYXN0Q2FsbGVkKSA+PSBjb29sZG93biAmJgogICAgZnJhbWVfZGlnIDEKICAgIGZyYW1lX2RpZyAzCiAgICAtCiAgICBmcmFtZV9kaWcgMAogICAgPj0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Mjk1LTI5NgogICAgLy8gbGFzdENhbGxlZCA+PSBlcG9jaFJlZiAmJgogICAgLy8gKGVwb2NoUmVmIC0gbGFzdENhbGxlZCkgPj0gY29vbGRvd24gJiYKICAgIGJ6IHBsdWdpbkNhbGxBbGxvd2VkX2Jvb2xfZmFsc2VAMTYKICAgIGludGNfMSAvLyAxCgpwbHVnaW5DYWxsQWxsb3dlZF9ib29sX21lcmdlQDE3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyOTUtMjk3CiAgICAvLyBsYXN0Q2FsbGVkID49IGVwb2NoUmVmICYmCiAgICAvLyAoZXBvY2hSZWYgLSBsYXN0Q2FsbGVkKSA+PSBjb29sZG93biAmJgogICAgLy8gbWV0aG9kQWxsb3dlZAogICAgZnJhbWVfZGlnIDQKICAgICYmCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjI5NC0yOTgKICAgIC8vIHJldHVybiAoCiAgICAvLyAgIGxhc3RDYWxsZWQgPj0gZXBvY2hSZWYgJiYKICAgIC8vICAgKGVwb2NoUmVmIC0gbGFzdENhbGxlZCkgPj0gY29vbGRvd24gJiYKICAgIC8vICAgbWV0aG9kQWxsb3dlZAogICAgLy8gKQogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCnBsdWdpbkNhbGxBbGxvd2VkX2Jvb2xfZmFsc2VAMTY6CiAgICBpbnRjXzAgLy8gMAogICAgYiBwbHVnaW5DYWxsQWxsb3dlZF9ib29sX21lcmdlQDE3CgpwbHVnaW5DYWxsQWxsb3dlZF90ZXJuYXJ5X2ZhbHNlQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoyOTIKICAgIC8vIGNvbnN0IGVwb2NoUmVmID0gdXNlUm91bmRzID8gR2xvYmFsLnJvdW5kIDogR2xvYmFsLmxhdGVzdFRpbWVzdGFtcDsKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGZyYW1lX2J1cnkgMQogICAgYiBwbHVnaW5DYWxsQWxsb3dlZF90ZXJuYXJ5X21lcmdlQDEzCgpwbHVnaW5DYWxsQWxsb3dlZF9hZnRlcl9pZl9lbHNlQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjI4NQogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGZyYW1lX2RpZyAyCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSAyCiAgICBiIHBsdWdpbkNhbGxBbGxvd2VkX3doaWxlX3RvcEA1CgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQudHhuUmVrZXlzQmFjayh0eG46IHVpbnQ2NCkgLT4gdWludDY0Ogp0eG5SZWtleXNCYWNrOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozMDEKICAgIC8vIHByaXZhdGUgdHhuUmVrZXlzQmFjayh0eG46IGd0eG4uVHJhbnNhY3Rpb24pOiBib29sZWFuIHsKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozMDQKICAgIC8vIHR4bi5zZW5kZXIgPT09IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUgJiYKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgU2VuZGVyCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzIKICAgIC8vIGNvbnRyb2xsZWRBZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzIH0pOwogICAgYnl0ZWNfMCAvLyAiY29udHJvbGxlZF9hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozMDQKICAgIC8vIHR4bi5zZW5kZXIgPT09IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUgJiYKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozMDQtMzA1CiAgICAvLyB0eG4uc2VuZGVyID09PSB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlICYmCiAgICAvLyB0eG4ucmVrZXlUbyA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGJ6IHR4blJla2V5c0JhY2tfYWZ0ZXJfaWZfZWxzZUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjMwNQogICAgLy8gdHhuLnJla2V5VG8gPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJla2V5VG8KICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozMDQtMzA1CiAgICAvLyB0eG4uc2VuZGVyID09PSB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlICYmCiAgICAvLyB0eG4ucmVrZXlUbyA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGJ6IHR4blJla2V5c0JhY2tfYWZ0ZXJfaWZfZWxzZUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjMwNwogICAgLy8gcmV0dXJuIHRydWU7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgp0eG5SZWtleXNCYWNrX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MzExCiAgICAvLyB0eG4udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFwcGxpY2F0aW9uQ2FsbAogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBUeXBlRW51bQogICAgcHVzaGludCA2IC8vIDYKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjMxMS0zMTIKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgYnogdHhuUmVrZXlzQmFja19ib29sX2ZhbHNlQDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MzEyCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBcHBsaWNhdGlvbklECiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uSUQKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjMxMS0zMTIKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgYnogdHhuUmVrZXlzQmFja19ib29sX2ZhbHNlQDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MzEzCiAgICAvLyAmJiB0eG4ubnVtQXBwQXJncyA9PT0gMQogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBOdW1BcHBBcmdzCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MzExLTMxMwogICAgLy8gdHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vICYmIHR4bi5hcHBJZCA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkCiAgICAvLyAmJiB0eG4ubnVtQXBwQXJncyA9PT0gMQogICAgYnogdHhuUmVrZXlzQmFja19ib29sX2ZhbHNlQDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MzE0CiAgICAvLyAmJiB0eG4ub25Db21wbGV0aW9uID09PSBPbkNvbXBsZXRlQWN0aW9uLk5vT3AKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgT25Db21wbGV0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjMxMS0zMTQKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgLy8gJiYgdHhuLm51bUFwcEFyZ3MgPT09IDEKICAgIC8vICYmIHR4bi5vbkNvbXBsZXRpb24gPT09IE9uQ29tcGxldGVBY3Rpb24uTm9PcAogICAgYm56IHR4blJla2V5c0JhY2tfYm9vbF9mYWxzZUA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjMxNQogICAgLy8gJiYgdHhuLmFwcEFyZ3MoMCkgPT09IG1ldGhvZFNlbGVjdG9yKCdhcmM1OF92ZXJpZnlBdXRoQWRkcmVzcygpdm9pZCcpCiAgICBmcmFtZV9kaWcgLTEKICAgIGludGNfMCAvLyAwCiAgICBndHhuc2FzIEFwcGxpY2F0aW9uQXJncwogICAgYnl0ZWMgMjYgLy8gbWV0aG9kICJhcmM1OF92ZXJpZnlBdXRoQWRkcmVzcygpdm9pZCIKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjMxMS0zMTUKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgLy8gJiYgdHhuLm51bUFwcEFyZ3MgPT09IDEKICAgIC8vICYmIHR4bi5vbkNvbXBsZXRpb24gPT09IE9uQ29tcGxldGVBY3Rpb24uTm9PcAogICAgLy8gJiYgdHhuLmFwcEFyZ3MoMCkgPT09IG1ldGhvZFNlbGVjdG9yKCdhcmM1OF92ZXJpZnlBdXRoQWRkcmVzcygpdm9pZCcpCiAgICBieiB0eG5SZWtleXNCYWNrX2Jvb2xfZmFsc2VAOQogICAgaW50Y18xIC8vIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MzEwLTMxNgogICAgLy8gcmV0dXJuICgKICAgIC8vICAgdHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vICAgJiYgdHhuLmFwcElkID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQKICAgIC8vICAgJiYgdHhuLm51bUFwcEFyZ3MgPT09IDEKICAgIC8vICAgJiYgdHhuLm9uQ29tcGxldGlvbiA9PT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wCiAgICAvLyAgICYmIHR4bi5hcHBBcmdzKDApID09PSBtZXRob2RTZWxlY3RvcignYXJjNThfdmVyaWZ5QXV0aEFkZHJlc3MoKXZvaWQnKQogICAgLy8gKQogICAgcmV0c3ViCgp0eG5SZWtleXNCYWNrX2Jvb2xfZmFsc2VAOToKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjMxMC0zMTYKICAgIC8vIHJldHVybiAoCiAgICAvLyAgIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAgICYmIHR4bi5hcHBJZCA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkCiAgICAvLyAgICYmIHR4bi5udW1BcHBBcmdzID09PSAxCiAgICAvLyAgICYmIHR4bi5vbkNvbXBsZXRpb24gPT09IE9uQ29tcGxldGVBY3Rpb24uTm9PcAogICAgLy8gICAmJiB0eG4uYXBwQXJncygwKSA9PT0gbWV0aG9kU2VsZWN0b3IoJ2FyYzU4X3ZlcmlmeUF1dGhBZGRyZXNzKCl2b2lkJykKICAgIC8vICkKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LnBsdWdpbkNoZWNrKGtleTogYnl0ZXMpIC0+IGJ5dGVzLCBieXRlczoKcGx1Z2luQ2hlY2s6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjMzMwogICAgLy8gcHJpdmF0ZSBwbHVnaW5DaGVjayhrZXk6IFBsdWdpbktleSk6IFBsdWdpblZhbGlkYXRpb24gewogICAgcHJvdG8gMSAyCiAgICBieXRlY18xIC8vICIiCiAgICBkdXBuIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTYzCiAgICAvLyBwbHVnaW5zID0gQm94TWFwPFBsdWdpbktleSwgUGx1Z2luSW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeFBsdWdpbnMgfSk7CiAgICBieXRlY18zIC8vICJwIgogICAgZnJhbWVfZGlnIC0xCiAgICBjb25jYXQKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozMzUKICAgIC8vIGNvbnN0IGV4aXN0cyA9IHRoaXMucGx1Z2lucyhrZXkpLmV4aXN0czsKICAgIGJveF9sZW4KICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MzM2CiAgICAvLyBpZiAoIWV4aXN0cykgewogICAgYm56IHBsdWdpbkNoZWNrX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozMzctMzQyCiAgICAvLyByZXR1cm4gewogICAgLy8gICBleGlzdHM6IGZhbHNlLAogICAgLy8gICBleHBpcmVkOiB0cnVlLAogICAgLy8gICBvbkNvb2xkb3duOiB0cnVlLAogICAgLy8gICBoYXNNZXRob2RSZXN0cmljdGlvbnM6IGZhbHNlLAogICAgLy8gfQogICAgcHVzaGJ5dGVzIDB4NjAKICAgIGZyYW1lX2RpZyAtMQogICAgZnJhbWVfYnVyeSAxCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKcGx1Z2luQ2hlY2tfYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozNDUKICAgIC8vIGNvbnN0IHsgdXNlUm91bmRzLCBsYXN0VmFsaWQsIGNvb2xkb3duLCBsYXN0Q2FsbGVkLCBtZXRob2RzIH0gPSB0aGlzLnBsdWdpbnMoa2V5KS52YWx1ZSBhcyBSZWFkb25seTxQbHVnaW5JbmZvPgogICAgZnJhbWVfZGlnIDMKICAgIGR1cAogICAgcHVzaGludCA5IC8vIDkKICAgIGludGNfMyAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZnJhbWVfYnVyeSAyCiAgICBkdXAKICAgIHB1c2hpbnQgMTcgLy8gMTcKICAgIGludGNfMyAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZnJhbWVfYnVyeSAwCiAgICBkdXAKICAgIHB1c2hpbnQgMjcgLy8gMjcKICAgIGludGNfMSAvLyAxCiAgICBib3hfZXh0cmFjdAogICAgaW50Y18xIC8vIDEKICAgIGdldGJpdAogICAgc3dhcAogICAgcHVzaGludCAyOCAvLyAyOAogICAgaW50Y18zIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBmcmFtZV9idXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MzQ2CiAgICAvLyBjb25zdCBlcG9jaFJlZiA9IHVzZVJvdW5kcyA/IEdsb2JhbC5yb3VuZCA6IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXA7CiAgICBieiBwbHVnaW5DaGVja190ZXJuYXJ5X2ZhbHNlQDQKICAgIGdsb2JhbCBSb3VuZAoKcGx1Z2luQ2hlY2tfdGVybmFyeV9tZXJnZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozNTAKICAgIC8vIGV4cGlyZWQ6IGVwb2NoUmVmID4gbGFzdFZhbGlkLAogICAgZHVwCiAgICBmcmFtZV9kaWcgMgogICAgPgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozNTEKICAgIC8vIG9uQ29vbGRvd246IChlcG9jaFJlZiAtIGxhc3RDYWxsZWQpIDwgY29vbGRvd24sCiAgICBzd2FwCiAgICBmcmFtZV9kaWcgMQogICAgLQogICAgZnJhbWVfZGlnIDAKICAgIDwKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MzUyCiAgICAvLyBoYXNNZXRob2RSZXN0cmljdGlvbnM6IG1ldGhvZHMubGVuZ3RoID4gMCwKICAgIGZyYW1lX2RpZyAzCiAgICBwdXNoaW50IDQ0IC8vIDQ0CiAgICBpbnRjXzIgLy8gMgogICAgYm94X2V4dHJhY3QKICAgIGJ0b2kKICAgIGludGNfMCAvLyAwCiAgICA+CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjM0OC0zNTMKICAgIC8vIHJldHVybiB7CiAgICAvLyAgIGV4aXN0cywKICAgIC8vICAgZXhwaXJlZDogZXBvY2hSZWYgPiBsYXN0VmFsaWQsCiAgICAvLyAgIG9uQ29vbGRvd246IChlcG9jaFJlZiAtIGxhc3RDYWxsZWQpIDwgY29vbGRvd24sCiAgICAvLyAgIGhhc01ldGhvZFJlc3RyaWN0aW9uczogbWV0aG9kcy5sZW5ndGggPiAwLAogICAgLy8gfQogICAgYnl0ZWMgOCAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfZGlnIDQKICAgIHNldGJpdAogICAgaW50Y18xIC8vIDEKICAgIHVuY292ZXIgNAogICAgc2V0Yml0CiAgICBpbnRjXzIgLy8gMgogICAgdW5jb3ZlciAzCiAgICBzZXRiaXQKICAgIHB1c2hpbnQgMyAvLyAzCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgZnJhbWVfZGlnIC0xCiAgICBmcmFtZV9idXJ5IDEKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpwbHVnaW5DaGVja190ZXJuYXJ5X2ZhbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjM0NgogICAgLy8gY29uc3QgZXBvY2hSZWYgPSB1c2VSb3VuZHMgPyBHbG9iYWwucm91bmQgOiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wOwogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgYiBwbHVnaW5DaGVja190ZXJuYXJ5X21lcmdlQDUKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5vcHRJbkVzY3Jvdyhlc2Nyb3c6IGJ5dGVzLCBhc3NldHM6IGJ5dGVzKSAtPiBieXRlczoKb3B0SW5Fc2Nyb3c6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjQ3NAogICAgLy8gcHJpdmF0ZSBvcHRJbkVzY3Jvdyhlc2Nyb3c6IHN0cmluZywgYXNzZXRzOiB1aW50NjRbXSk6IHZvaWQgewogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE2NwogICAgLy8gZXNjcm93cyA9IEJveE1hcDxzdHJpbmcsIEVzY3Jvd0luZm8+KHsga2V5UHJlZml4OiBBYnN0cmFjdEFjY291bnRCb3hQcmVmaXhFc2Nyb3dzIH0pCiAgICBieXRlY18yIC8vICJlIgogICAgZnJhbWVfZGlnIC0yCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NDc1CiAgICAvLyBjb25zdCBlc2Nyb3dBZGRyZXNzID0gQXBwbGljYXRpb24odGhpcy5lc2Nyb3dzKGVzY3JvdykudmFsdWUuaWQpLmFkZHJlc3MKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIHN3YXAKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjQ3Ny00ODMKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHNlbmRlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIC8vICAgICByZWNlaXZlcjogZXNjcm93QWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZSAqIGFzc2V0cy5sZW5ndGgKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpOwogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo0NzkKICAgIC8vIHNlbmRlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMgogICAgLy8gY29udHJvbGxlZEFkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MgfSk7CiAgICBieXRlY18wIC8vICJjb250cm9sbGVkX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjQ3OQogICAgLy8gc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NDgxCiAgICAvLyBhbW91bnQ6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZSAqIGFzc2V0cy5sZW5ndGgKICAgIGdsb2JhbCBBc3NldE9wdEluTWluQmFsYW5jZQogICAgZnJhbWVfZGlnIC0xCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGR1cAogICAgY292ZXIgNAogICAgKgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjQ3Ny00ODIKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHNlbmRlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIC8vICAgICByZWNlaXZlcjogZXNjcm93QWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZSAqIGFzc2V0cy5sZW5ndGgKICAgIC8vICAgfSkKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NDc3LTQ4MwogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIHJlY2VpdmVyOiBlc2Nyb3dBZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlICogYXNzZXRzLmxlbmd0aAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo0ODUKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGludGNfMCAvLyAwCgpvcHRJbkVzY3Jvd193aGlsZV90b3BAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NDg1CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgYXNzZXRzLmxlbmd0aDsgaSArPSAxKSB7CiAgICBmcmFtZV9kaWcgMgogICAgZnJhbWVfZGlnIDEKICAgIDwKICAgIGJ6IG9wdEluRXNjcm93X2FmdGVyX3doaWxlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NDg2LTQ5MwogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgc2VuZGVyOiBlc2Nyb3dBZGRyZXNzLAogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IGVzY3Jvd0FkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgeGZlckFzc2V0OiBhc3NldHNbaV0KICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpOwogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo0OTEKICAgIC8vIHhmZXJBc3NldDogYXNzZXRzW2ldCiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgMiAwCiAgICBmcmFtZV9kaWcgMgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBpbnRjXzMgLy8gOAogICAgKgogICAgZXh0cmFjdF91aW50NjQKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjQ5MAogICAgLy8gYXNzZXRBbW91bnQ6IDAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgZnJhbWVfZGlnIDAKICAgIGR1cAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo0ODYtNDkyCiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBzZW5kZXI6IGVzY3Jvd0FkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogZXNjcm93QWRkcmVzcywKICAgIC8vICAgICBhc3NldEFtb3VudDogMCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGFzc2V0c1tpXQogICAgLy8gICB9KQogICAgcHVzaGludCA0IC8vIDQKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo0ODYtNDkzCiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBzZW5kZXI6IGVzY3Jvd0FkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogZXNjcm93QWRkcmVzcywKICAgIC8vICAgICBhc3NldEFtb3VudDogMCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGFzc2V0c1tpXQogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo0ODUKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDIKICAgIGIgb3B0SW5Fc2Nyb3dfd2hpbGVfdG9wQDIKCm9wdEluRXNjcm93X2FmdGVyX3doaWxlQDU6CiAgICBmcmFtZV9kaWcgLTEKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQucmVjbGFpbShlc2Nyb3c6IGJ5dGVzLCByZWNsYWltczogYnl0ZXMsIGFsbG93Q2xvc2VPdXQ6IHVpbnQ2NCkgLT4gYnl0ZXM6CnJlY2xhaW06CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjQ5NwogICAgLy8gcHJpdmF0ZSByZWNsYWltKGVzY3Jvdzogc3RyaW5nLCByZWNsYWltczogRXNjcm93UmVjbGFpbVtdLCBhbGxvd0Nsb3NlT3V0OiBib29sZWFuKTogdm9pZCB7CiAgICBwcm90byAzIDEKICAgIGludGNfMCAvLyAwCiAgICBkdXAKICAgIGJ5dGVjXzEgLy8gIiIKICAgIGR1cG4gMgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTY3CiAgICAvLyBlc2Nyb3dzID0gQm94TWFwPHN0cmluZywgRXNjcm93SW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeEVzY3Jvd3MgfSkKICAgIGJ5dGVjXzIgLy8gImUiCiAgICBmcmFtZV9kaWcgLTMKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo0OTgKICAgIC8vIGNvbnN0IHNlbmRlciA9IEFwcGxpY2F0aW9uKHRoaXMuZXNjcm93cyhlc2Nyb3cpLnZhbHVlLmlkKS5hZGRyZXNzCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjUwMAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IHJlY2xhaW1zLmxlbmd0aDsgaSArPSAxKSB7CiAgICBpbnRjXzAgLy8gMAoKcmVjbGFpbV93aGlsZV90b3BAMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NTAwCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgcmVjbGFpbXMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGZyYW1lX2RpZyAtMgogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBmcmFtZV9kaWcgNwogICAgPgogICAgYnogcmVjbGFpbV9hZnRlcl93aGlsZUAxMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1MDEKICAgIC8vIGlmIChyZWNsYWltc1tpXS5hc3NldCA9PT0gMCkgewogICAgZnJhbWVfZGlnIC0yCiAgICBleHRyYWN0IDIgMAogICAgZnJhbWVfZGlnIDcKICAgIHB1c2hpbnQgMTcgLy8gMTcKICAgICoKICAgIHB1c2hpbnQgMTcgLy8gMTcKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBpbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZHVwCiAgICBmcmFtZV9idXJ5IDAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDIKICAgIGJueiByZWNsYWltX2Vsc2VfYm9keUA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjUwMi01MDYKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICAvLyAgIGFtb3VudDogcmVjbGFpbXNbaV0uYW1vdW50CiAgICAvLyB9KS5zdWJtaXQoKTsKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NTA0CiAgICAvLyByZWNlaXZlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMgogICAgLy8gY29udHJvbGxlZEFkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MgfSk7CiAgICBieXRlY18wIC8vICJjb250cm9sbGVkX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjUwNAogICAgLy8gcmVjZWl2ZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1MDUKICAgIC8vIGFtb3VudDogcmVjbGFpbXNbaV0uYW1vdW50CiAgICBmcmFtZV9kaWcgMAogICAgaW50Y18zIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZnJhbWVfZGlnIDYKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjUwMi01MDYKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICAvLyAgIGFtb3VudDogcmVjbGFpbXNbaV0uYW1vdW50CiAgICAvLyB9KS5zdWJtaXQoKTsKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CgpyZWNsYWltX2FmdGVyX2lmX2Vsc2VAMTI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjUwMAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IHJlY2xhaW1zLmxlbmd0aDsgaSArPSAxKSB7CiAgICBmcmFtZV9kaWcgNwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGZyYW1lX2J1cnkgNwogICAgYiByZWNsYWltX3doaWxlX3RvcEAxCgpyZWNsYWltX2Vsc2VfYm9keUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1MTAKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzIKICAgIC8vIGNvbnRyb2xsZWRBZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzIH0pOwogICAgYnl0ZWNfMCAvLyAiY29udHJvbGxlZF9hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1MTAKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgc3dhcAogICAgZnJhbWVfYnVyeSAxCiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjUxMQogICAgLy8gYXNzZXRBbW91bnQ6IHJlY2xhaW1zW2ldLmFtb3VudCwKICAgIGZyYW1lX2RpZyAwCiAgICBpbnRjXzMgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2J1cnkgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1MDgKICAgIC8vIGNvbnN0IHhmZXIgPSBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1MTUKICAgIC8vIGlmIChhbGxvd0Nsb3NlT3V0ICYmIHJlY2xhaW1zW2ldLmNsb3NlT3V0KSB7CiAgICBmcmFtZV9kaWcgLTEKICAgIGJ6IHJlY2xhaW1fYWZ0ZXJfaWZfZWxzZUA4CiAgICBmcmFtZV9kaWcgMAogICAgcHVzaGludCAxMjggLy8gMTI4CiAgICBnZXRiaXQKICAgIGJ6IHJlY2xhaW1fYWZ0ZXJfaWZfZWxzZUA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjUxNgogICAgLy8geGZlci5zZXQoeyBhc3NldENsb3NlVG86IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUgfSk7CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzIKICAgIC8vIGNvbnRyb2xsZWRBZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzIH0pOwogICAgYnl0ZWNfMCAvLyAiY29udHJvbGxlZF9hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1MTYKICAgIC8vIHhmZXIuc2V0KHsgYXNzZXRDbG9zZVRvOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlIH0pOwogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGludGNfMSAvLyAxCiAgICBmcmFtZV9idXJ5IDQKICAgIGZyYW1lX2J1cnkgNQoKcmVjbGFpbV9hZnRlcl9pZl9lbHNlQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjUxOQogICAgLy8geGZlci5zdWJtaXQoKTsKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyA0CiAgICBieiByZWNsYWltX25leHRfZmllbGRAMTAKICAgIGZyYW1lX2RpZyA1CiAgICBpdHhuX2ZpZWxkIEFzc2V0Q2xvc2VUbwoKcmVjbGFpbV9uZXh0X2ZpZWxkQDEwOgogICAgZnJhbWVfZGlnIDIKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBmcmFtZV9kaWcgMwogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgZnJhbWVfZGlnIDEKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZnJhbWVfZGlnIDYKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjUwOC01MTMKICAgIC8vIGNvbnN0IHhmZXIgPSBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICAvLyAgIGFzc2V0QW1vdW50OiByZWNsYWltc1tpXS5hbW91bnQsCiAgICAvLyAgIHhmZXJBc3NldDogcmVjbGFpbXNbaV0uYXNzZXQKICAgIC8vIH0pCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjUxOQogICAgLy8geGZlci5zdWJtaXQoKTsKICAgIGl0eG5fc3VibWl0CiAgICBiIHJlY2xhaW1fYWZ0ZXJfaWZfZWxzZUAxMgoKcmVjbGFpbV9hZnRlcl93aGlsZUAxMzoKICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luKHBsdWdpbjogdWludDY0LCBnbG9iYWw6IHVpbnQ2NCwgZXNjcm93OiBieXRlcywgbWV0aG9kT2Zmc2V0czogYnl0ZXMsIGZ1bmRzUmVxdWVzdDogYnl0ZXMpIC0+IGJ5dGVzLCBieXRlczoKc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6ODc3LTg4MwogICAgLy8gYXJjNThfcmVrZXlUb1BsdWdpbigKICAgIC8vICAgcGx1Z2luOiB1aW50NjQsCiAgICAvLyAgIGdsb2JhbDogYm9vbGVhbiwKICAgIC8vICAgZXNjcm93OiBzdHJpbmcsCiAgICAvLyAgIG1ldGhvZE9mZnNldHM6IHVpbnQ2NFtdLAogICAgLy8gICBmdW5kc1JlcXVlc3Q6IEZ1bmRzUmVxdWVzdFtdCiAgICAvLyApOiB2b2lkIHsKICAgIHByb3RvIDUgMgogICAgaW50Y18wIC8vIDAKICAgIGR1cG4gMTEKICAgIGJ5dGVjXzEgLy8gIiIKICAgIGR1cG4gMjAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6ODg1CiAgICAvLyBjb25zdCBjYWxsZXIgPSBnbG9iYWwgPyBHbG9iYWwuemVyb0FkZHJlc3MgOiBUeG4uc2VuZGVyCiAgICBmcmFtZV9kaWcgLTQKICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fdGVybmFyeV9mYWxzZUAyCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKCnNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fdGVybmFyeV9tZXJnZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo4ODYKICAgIC8vIGNvbnN0IGtleTogUGx1Z2luS2V5ID0geyBwbHVnaW4sIGNhbGxlciwgZXNjcm93IH0KICAgIGZyYW1lX2RpZyAtNQogICAgaXRvYgogICAgc3dhcAogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTMKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIGZyYW1lX2RpZyAtMwogICAgY29uY2F0CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMQogICAgc3dhcAogICAgYnl0ZWMgMTEgLy8gMHgwMDJhCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTYzCiAgICAvLyBwbHVnaW5zID0gQm94TWFwPFBsdWdpbktleSwgUGx1Z2luSW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeFBsdWdpbnMgfSk7CiAgICBieXRlY18zIC8vICJwIgogICAgZGlnIDEKICAgIGNvbmNhdAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6ODg4CiAgICAvLyBhc3NlcnQodGhpcy5wbHVnaW5zKGtleSkuZXhpc3RzLCBFUlJfUExVR0lOX0RPRVNfTk9UX0VYSVNUKQogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBQbHVnaW4gZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQ4CiAgICAvLyBjdXJyZW50UGx1Z2luID0gR2xvYmFsU3RhdGU8UGx1Z2luS2V5Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ3VycmVudFBsdWdpbiB9KQogICAgYnl0ZWMgMjUgLy8gImN1cnJlbnRfcGx1Z2luIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo4ODkKICAgIC8vIHRoaXMuY3VycmVudFBsdWdpbi52YWx1ZSA9IGNsb25lKGtleSkKICAgIHVuY292ZXIgMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6ODkwCiAgICAvLyBjb25zdCB7IGVzY3JvdzogZXNjcm93SUQgfSA9IHRoaXMucGx1Z2lucyhrZXkpLnZhbHVlCiAgICBpbnRjXzAgLy8gMAogICAgaW50Y18zIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMTYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6ODkyCiAgICAvLyBpZiAoZXNjcm93SUQgIT09IDApIHsKICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fZWxzZV9ib2R5QDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6ODk0CiAgICAvLyB0aGlzLnNwZW5kaW5nQWRkcmVzcy52YWx1ZSA9IHNwZW5kaW5nQXBwLmFkZHJlc3MKICAgIGZyYW1lX2RpZyAxNgogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDYKICAgIC8vIHNwZW5kaW5nQWRkcmVzcyA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MgfSkKICAgIGJ5dGVjIDEwIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo4OTQKICAgIC8vIHRoaXMuc3BlbmRpbmdBZGRyZXNzLnZhbHVlID0gc3BlbmRpbmdBcHAuYWRkcmVzcwogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTY3CiAgICAvLyBlc2Nyb3dzID0gQm94TWFwPHN0cmluZywgRXNjcm93SW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeEVzY3Jvd3MgfSkKICAgIGJ5dGVjXzIgLy8gImUiCiAgICBmcmFtZV9kaWcgLTMKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1MjUKICAgIC8vIGNvbnN0IGVzY3Jvd0lEID0gdGhpcy5lc2Nyb3dzKGVzY3JvdykudmFsdWUuaWQ7CiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjUyNgogICAgLy8gY29uc3QgZXNjcm93QWRkcmVzcyA9IEFwcGxpY2F0aW9uKGVzY3Jvd0lEKS5hZGRyZXNzOwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgc3dhcAogICAgZnJhbWVfYnVyeSA2CiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjUyOAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGZ1bmRzUmVxdWVzdHMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDE4CgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX3doaWxlX3RvcEA2MzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NTI4CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgZnVuZHNSZXF1ZXN0cy5sZW5ndGg7IGkgKz0gMSkgewogICAgZnJhbWVfZGlnIC0xCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGZyYW1lX2RpZyAxOAogICAgPgogICAgYnogc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9hZnRlcl9pZl9lbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NTMyCiAgICAvLyBhc3NldDogZnVuZHNSZXF1ZXN0c1tpXS5hc3NldAogICAgZnJhbWVfZGlnIC0xCiAgICBleHRyYWN0IDIgMAogICAgZnJhbWVfZGlnIDE4CiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICAqCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogaW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGR1cAogICAgZnJhbWVfYnVyeSAwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgZnJhbWVfYnVyeSAzMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1MzAtNTMzCiAgICAvLyBjb25zdCBhbGxvd2FuY2VLZXk6IEFsbG93YW5jZUtleSA9IHsKICAgIC8vICAgZXNjcm93LAogICAgLy8gICBhc3NldDogZnVuZHNSZXF1ZXN0c1tpXS5hc3NldAogICAgLy8gfQogICAgaXRvYgogICAgYnl0ZWMgMTcgLy8gMHgwMDBhCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGZyYW1lX2RpZyAxCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTY5CiAgICAvLyBhbGxvd2FuY2VzID0gQm94TWFwPEFsbG93YW5jZUtleSwgQWxsb3dhbmNlSW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeEFsbG93YW5jZXMgfSkgLy8gMzhfNTAwCiAgICBieXRlYyAxOCAvLyAiYSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NTU5CiAgICAvLyBhc3NlcnQodGhpcy5hbGxvd2FuY2VzKGtleSkuZXhpc3RzLCBFUlJfQUxMT1dBTkNFX0RPRVNfTk9UX0VYSVNUKTsKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gYWxsb3dhbmNlIGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjU2MAogICAgLy8gY29uc3QgeyB0eXBlLCBzcGVudCwgYW1vdW50LCBsYXN0LCBtYXgsIGludGVydmFsLCBzdGFydCwgdXNlUm91bmRzIH0gPSB0aGlzLmFsbG93YW5jZXMoa2V5KS52YWx1ZQogICAgYm94X2dldAogICAgcG9wCiAgICBkdXAKICAgIGV4dHJhY3QgMCAxCiAgICBmcmFtZV9idXJ5IDExCiAgICBkdXAKICAgIHB1c2hpbnQgMTcgLy8gMTcKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9idXJ5IDI5CiAgICBkdXAKICAgIHB1c2hpbnQgOSAvLyA5CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfYnVyeSAxMgogICAgZHVwCiAgICBwdXNoaW50IDMzIC8vIDMzCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfYnVyeSAyMQogICAgZHVwCiAgICBpbnRjXzEgLy8gMQogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2J1cnkgMjMKICAgIGR1cAogICAgcHVzaGludCAyNSAvLyAyNQogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2J1cnkgMTkKICAgIGR1cAogICAgcHVzaGludCA0MSAvLyA0MQogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2J1cnkgMzAKICAgIHB1c2hpbnQgMzkyIC8vIDM5MgogICAgZ2V0Yml0CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMzEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NTYxCiAgICAvLyBjb25zdCBuZXdMYXN0ID0gdXNlUm91bmRzID8gR2xvYmFsLnJvdW5kIDogR2xvYmFsLmxhdGVzdFRpbWVzdGFtcDsKICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fdGVybmFyeV9mYWxzZUA2NgogICAgZ2xvYmFsIFJvdW5kCiAgICBmcmFtZV9idXJ5IDI3CgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX3Rlcm5hcnlfbWVyZ2VANjc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjU2MwogICAgLy8gaWYgKHR5cGUgPT09IFNwZW5kQWxsb3dhbmNlVHlwZUZsYXQpIHsKICAgIGZyYW1lX2RpZyAxMQogICAgYnl0ZWMgMTQgLy8gMHgwMQogICAgPT0KICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fZWxzZV9ib2R5QDY5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjU2NAogICAgLy8gY29uc3QgbGVmdG92ZXI6IHVpbnQ2NCA9IGFtb3VudCAtIHNwZW50OwogICAgZnJhbWVfZGlnIDEyCiAgICBmcmFtZV9kaWcgMjkKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NTY1CiAgICAvLyBhc3NlcnQobGVmdG92ZXIgPj0gZnVuZFJlcXVlc3QuYW1vdW50LCBFUlJfQUxMT1dBTkNFX0VYQ0VFREVEKTsKICAgIGZyYW1lX2RpZyAwCiAgICBpbnRjXzMgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIHN3YXAKICAgIGRpZyAxCiAgICA+PQogICAgYXNzZXJ0IC8vIEFsbG93YW5jZSBleGNlZWRlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1NjYKICAgIC8vIHRoaXMuYWxsb3dhbmNlcyhrZXkpLnZhbHVlLnNwZW50ICs9IGZ1bmRSZXF1ZXN0LmFtb3VudAogICAgZnJhbWVfZGlnIDMKICAgIGR1cAogICAgY292ZXIgMgogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIHB1c2hpbnQgMTcgLy8gMTcKICAgIGV4dHJhY3RfdWludDY0CiAgICArCiAgICBpdG9iCiAgICBwdXNoaW50IDE3IC8vIDE3CiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQoKc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9hZnRlcl9pZl9lbHNlQDc4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1OTEKICAgIC8vIHRoaXMuYWxsb3dhbmNlcyhrZXkpLnZhbHVlLmxhc3QgPSBuZXdMYXN0CiAgICBmcmFtZV9kaWcgMjcKICAgIGl0b2IKICAgIGZyYW1lX2RpZyAzCiAgICBwdXNoaW50IDMzIC8vIDMzCiAgICB1bmNvdmVyIDIKICAgIGJveF9yZXBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjUzNwogICAgLy8gaWYgKGZ1bmRzUmVxdWVzdHNbaV0uYXNzZXQgIT09IDApIHsKICAgIGZyYW1lX2RpZyAzMgogICAgYnogc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9lbHNlX2JvZHlAODAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NTM4LTU0NQogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IGVzY3Jvd0FkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IGZ1bmRzUmVxdWVzdHNbaV0uYW1vdW50LAogICAgLy8gICAgIHhmZXJBc3NldDogZnVuZHNSZXF1ZXN0c1tpXS5hc3NldAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjU0MAogICAgLy8gc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTMyCiAgICAvLyBjb250cm9sbGVkQWRkcmVzcyA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcyB9KTsKICAgIGJ5dGVjXzAgLy8gImNvbnRyb2xsZWRfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NTQwCiAgICAvLyBzZW5kZXI6IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1NDIKICAgIC8vIGFzc2V0QW1vdW50OiBmdW5kc1JlcXVlc3RzW2ldLmFtb3VudCwKICAgIGZyYW1lX2RpZyAwCiAgICBpbnRjXzMgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2RpZyAzMgogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGZyYW1lX2RpZyA2CiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjUzOC01NDQKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIHNlbmRlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBlc2Nyb3dBZGRyZXNzLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiBmdW5kc1JlcXVlc3RzW2ldLmFtb3VudCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGZ1bmRzUmVxdWVzdHNbaV0uYXNzZXQKICAgIC8vICAgfSkKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NTM4LTU0NQogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IGVzY3Jvd0FkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IGZ1bmRzUmVxdWVzdHNbaV0uYW1vdW50LAogICAgLy8gICAgIHhmZXJBc3NldDogZnVuZHNSZXF1ZXN0c1tpXS5hc3NldAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX3N1Ym1pdAoKc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9hZnRlcl9pZl9lbHNlQDgxOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1MjgKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBmdW5kc1JlcXVlc3RzLmxlbmd0aDsgaSArPSAxKSB7CiAgICBmcmFtZV9kaWcgMTgKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDE4CiAgICBiIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fd2hpbGVfdG9wQDYzCgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2Vsc2VfYm9keUA4MDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NTQ3LTU1MwogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIHJlY2VpdmVyOiBlc2Nyb3dBZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogZnVuZHNSZXF1ZXN0c1tpXS5hbW91bnQKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpOwogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1NDkKICAgIC8vIHNlbmRlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEzMgogICAgLy8gY29udHJvbGxlZEFkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MgfSk7CiAgICBieXRlY18wIC8vICJjb250cm9sbGVkX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjU0OQogICAgLy8gc2VuZGVyOiB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NTUxCiAgICAvLyBhbW91bnQ6IGZ1bmRzUmVxdWVzdHNbaV0uYW1vdW50CiAgICBmcmFtZV9kaWcgMAogICAgaW50Y18zIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgZnJhbWVfZGlnIDYKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjU0Ny01NTIKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHNlbmRlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIC8vICAgICByZWNlaXZlcjogZXNjcm93QWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IGZ1bmRzUmVxdWVzdHNbaV0uYW1vdW50CiAgICAvLyAgIH0pCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjU0Ny01NTMKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHNlbmRlcjogdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZSwKICAgIC8vICAgICByZWNlaXZlcjogZXNjcm93QWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IGZ1bmRzUmVxdWVzdHNbaV0uYW1vdW50CiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKTsKICAgIGl0eG5fc3VibWl0CiAgICBiIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fYWZ0ZXJfaWZfZWxzZUA4MQoKc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9lbHNlX2JvZHlANjk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjU2NwogICAgLy8gfSBlbHNlIGlmICh0eXBlID09PSBTcGVuZEFsbG93YW5jZVR5cGVXaW5kb3cpIHsKICAgIGZyYW1lX2RpZyAxMQogICAgcHVzaGJ5dGVzIDB4MDIKICAgID09CiAgICBieiBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2Vsc2VfYm9keUA3MwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1OTUKICAgIC8vIGlmICh1c2VSb3VuZHMpIHsKICAgIGZyYW1lX2RpZyAzMQogICAgYnogc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9hZnRlcl9pZl9lbHNlQDg0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjU5NgogICAgLy8gcmV0dXJuIEdsb2JhbC5yb3VuZCAtICgoR2xvYmFsLnJvdW5kIC0gc3RhcnQpICUgaW50ZXJ2YWwpCiAgICBnbG9iYWwgUm91bmQKICAgIGR1cAogICAgZnJhbWVfZGlnIDMwCiAgICAtCiAgICBmcmFtZV9kaWcgMTkKICAgICUKICAgIC0KCnNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5nZXRMYXRlc3RXaW5kb3dTdGFydEA4NToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NTcwCiAgICAvLyBpZiAoY3VycmVudFdpbmRvd1N0YXJ0ID4gbGFzdCkgewogICAgZnJhbWVfZGlnIDIxCiAgICA+CiAgICBieiBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2Vsc2VfYm9keUA3MgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1NzEKICAgIC8vIGFzc2VydChhbW91bnQgPj0gZnVuZFJlcXVlc3QuYW1vdW50LCBFUlJfQUxMT1dBTkNFX0VYQ0VFREVEKTsKICAgIGZyYW1lX2RpZyAwCiAgICBkdXAKICAgIGV4dHJhY3QgOCA4CiAgICBzd2FwCiAgICBpbnRjXzMgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2RpZyAxMgogICAgPD0KICAgIGFzc2VydCAvLyBBbGxvd2FuY2UgZXhjZWVkZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NTcyCiAgICAvLyB0aGlzLmFsbG93YW5jZXMoa2V5KS52YWx1ZS5zcGVudCA9IGZ1bmRSZXF1ZXN0LmFtb3VudAogICAgZnJhbWVfZGlnIDMKICAgIHB1c2hpbnQgMTcgLy8gMTcKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIGIgc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9hZnRlcl9pZl9lbHNlQDc4CgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2Vsc2VfYm9keUA3MjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NTc1CiAgICAvLyBjb25zdCBsZWZ0b3ZlcjogdWludDY0ID0gYW1vdW50IC0gc3BlbnQ7CiAgICBmcmFtZV9kaWcgMTIKICAgIGZyYW1lX2RpZyAyOQogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1NzYKICAgIC8vIGFzc2VydChsZWZ0b3ZlciA+PSBmdW5kUmVxdWVzdC5hbW91bnQsIEVSUl9BTExPV0FOQ0VfRVhDRUVERUQpOwogICAgZnJhbWVfZGlnIDAKICAgIGludGNfMyAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgc3dhcAogICAgZGlnIDEKICAgID49CiAgICBhc3NlcnQgLy8gQWxsb3dhbmNlIGV4Y2VlZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjU3NwogICAgLy8gdGhpcy5hbGxvd2FuY2VzKGtleSkudmFsdWUuc3BlbnQgKz0gZnVuZFJlcXVlc3QuYW1vdW50CiAgICBmcmFtZV9kaWcgMwogICAgZHVwCiAgICBjb3ZlciAyCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgcHVzaGludCAxNyAvLyAxNwogICAgZXh0cmFjdF91aW50NjQKICAgICsKICAgIGl0b2IKICAgIHB1c2hpbnQgMTcgLy8gMTcKICAgIHN3YXAKICAgIGJveF9yZXBsYWNlCiAgICBiIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fYWZ0ZXJfaWZfZWxzZUA3OAoKc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9hZnRlcl9pZl9lbHNlQDg0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1OTgKICAgIC8vIHJldHVybiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wIC0gKChHbG9iYWwubGF0ZXN0VGltZXN0YW1wIC0gc3RhcnQpICUgaW50ZXJ2YWwpCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBkdXAKICAgIGZyYW1lX2RpZyAzMAogICAgLQogICAgZnJhbWVfZGlnIDE5CiAgICAlCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjU2OAogICAgLy8gY29uc3QgY3VycmVudFdpbmRvd1N0YXJ0ID0gdGhpcy5nZXRMYXRlc3RXaW5kb3dTdGFydCh1c2VSb3VuZHMsIHN0YXJ0LCBpbnRlcnZhbCkKICAgIGIgc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmdldExhdGVzdFdpbmRvd1N0YXJ0QDg1CgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2Vsc2VfYm9keUA3MzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NTc5CiAgICAvLyB9IGVsc2UgaWYgKHR5cGUgPT09IFNwZW5kQWxsb3dhbmNlVHlwZURyaXApIHsKICAgIGZyYW1lX2RpZyAxMQogICAgcHVzaGJ5dGVzIDB4MDMKICAgID09CiAgICBieiBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2FmdGVyX2lmX2Vsc2VANzgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NTgwCiAgICAvLyBjb25zdCBlcG9jaFJlZiA9IHVzZVJvdW5kcyA/IEdsb2JhbC5yb3VuZCA6IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXA7CiAgICBmcmFtZV9kaWcgMzEKICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fdGVybmFyeV9mYWxzZUA3NgogICAgZ2xvYmFsIFJvdW5kCiAgICBmcmFtZV9idXJ5IDE1CgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX3Rlcm5hcnlfbWVyZ2VANzc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjU4MQogICAgLy8gY29uc3QgcGFzc2VkOiB1aW50NjQgPSBlcG9jaFJlZiAtIGxhc3QKICAgIGZyYW1lX2RpZyAxNQogICAgZnJhbWVfZGlnIDIxCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjU4NQogICAgLy8gY29uc3QgYWNjcnVlZDogdWludDY0ID0gc3BlbnQgKyAoKHBhc3NlZCAvIGludGVydmFsKSAqIGFtb3VudCkKICAgIGZyYW1lX2RpZyAxOQogICAgLwogICAgZnJhbWVfZGlnIDEyCiAgICAqCiAgICBmcmFtZV9kaWcgMjkKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NTg2CiAgICAvLyBjb25zdCBhdmFpbGFibGU6IHVpbnQ2NCA9IGFjY3J1ZWQgPiBtYXggPyBtYXggOiBhY2NydWVkCiAgICBkdXAKICAgIGZyYW1lX2RpZyAyMwogICAgZHVwCiAgICBjb3ZlciAzCiAgICA+CiAgICBzd2FwCiAgICBjb3ZlciAyCiAgICBzZWxlY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NTg4CiAgICAvLyBhc3NlcnQoYXZhaWxhYmxlID49IGZ1bmRSZXF1ZXN0LmFtb3VudCwgRVJSX0FMTE9XQU5DRV9FWENFRURFRCk7CiAgICBmcmFtZV9kaWcgMAogICAgaW50Y18zIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAyCiAgICA+PQogICAgYXNzZXJ0IC8vIEFsbG93YW5jZSBleGNlZWRlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1ODkKICAgIC8vIHRoaXMuYWxsb3dhbmNlcyhrZXkpLnZhbHVlLnNwZW50ID0gKGF2YWlsYWJsZSAtIGZ1bmRSZXF1ZXN0LmFtb3VudCkKICAgIC0KICAgIGl0b2IKICAgIGZyYW1lX2RpZyAzCiAgICBwdXNoaW50IDE3IC8vIDE3CiAgICB1bmNvdmVyIDIKICAgIGJveF9yZXBsYWNlCiAgICBiIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fYWZ0ZXJfaWZfZWxzZUA3OAoKc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl90ZXJuYXJ5X2ZhbHNlQDc2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo1ODAKICAgIC8vIGNvbnN0IGVwb2NoUmVmID0gdXNlUm91bmRzID8gR2xvYmFsLnJvdW5kIDogR2xvYmFsLmxhdGVzdFRpbWVzdGFtcDsKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGZyYW1lX2J1cnkgMTUKICAgIGIgc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl90ZXJuYXJ5X21lcmdlQDc3CgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX3Rlcm5hcnlfZmFsc2VANjY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjU2MQogICAgLy8gY29uc3QgbmV3TGFzdCA9IHVzZVJvdW5kcyA/IEdsb2JhbC5yb3VuZCA6IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXA7CiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBmcmFtZV9idXJ5IDI3CiAgICBiIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fdGVybmFyeV9tZXJnZUA2NwoKc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9hZnRlcl9pZl9lbHNlQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjM2NAogICAgLy8gY29uc3QgeyB1c2VSb3VuZHMsIHVzZUV4ZWN1dGlvbktleSB9ID0gdGhpcy5wbHVnaW5zKGtleSkudmFsdWUKICAgIGZyYW1lX2RpZyAyCiAgICBwdXNoaW50IDI3IC8vIDI3CiAgICBpbnRjXzEgLy8gMQogICAgYm94X2V4dHJhY3QKICAgIGR1cAogICAgaW50Y18xIC8vIDEKICAgIGdldGJpdAogICAgZnJhbWVfYnVyeSAzMQogICAgaW50Y18yIC8vIDIKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozNjYKICAgIC8vIGlmICh1c2VFeGVjdXRpb25LZXkgJiYgIXRoaXMuaXNBZG1pbigpKSB7CiAgICBieiBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2FmdGVyX2lmX2Vsc2VAMjkKICAgIGNhbGxzdWIgaXNBZG1pbgogICAgYm56IHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fYWZ0ZXJfaWZfZWxzZUAyOQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNzEKICAgIC8vIGV4ZWN1dGlvbnMgPSBCb3hNYXA8Ynl0ZXM8MzI+LCBFeGVjdXRpb25JbmZvPih7IGtleVByZWZpeDogQWJzdHJhY3RBY2NvdW50Qm94UHJlZml4RXhlY3V0aW9ucyB9KQogICAgYnl0ZWMgOSAvLyAieCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MzY3CiAgICAvLyBhc3NlcnQodGhpcy5leGVjdXRpb25zKFR4bi5sZWFzZSkuZXhpc3RzLCBFUlJfRVhFQ1VUSU9OX0tFWV9OT1RfRk9VTkQpOwogICAgdHhuIExlYXNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE3MQogICAgLy8gZXhlY3V0aW9ucyA9IEJveE1hcDxieXRlczwzMj4sIEV4ZWN1dGlvbkluZm8+KHsga2V5UHJlZml4OiBBYnN0cmFjdEFjY291bnRCb3hQcmVmaXhFeGVjdXRpb25zIH0pCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MzY3CiAgICAvLyBhc3NlcnQodGhpcy5leGVjdXRpb25zKFR4bi5sZWFzZSkuZXhpc3RzLCBFUlJfRVhFQ1VUSU9OX0tFWV9OT1RfRk9VTkQpOwogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gRXhlY3V0aW9uIGtleSBub3QgZm91bmQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTcxCiAgICAvLyBleGVjdXRpb25zID0gQm94TWFwPGJ5dGVzPDMyPiwgRXhlY3V0aW9uSW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeEV4ZWN1dGlvbnMgfSkKICAgIGJ5dGVjIDkgLy8gIngiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjM2OAogICAgLy8gYXNzZXJ0KHRoaXMuZXhlY3V0aW9ucyhUeG4ubGVhc2UpLnZhbHVlLmZpcnN0VmFsaWQgPD0gR2xvYmFsLnJvdW5kLCBFUlJfRVhFQ1VUSU9OX05PVF9SRUFEWSk7CiAgICB0eG4gTGVhc2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTcxCiAgICAvLyBleGVjdXRpb25zID0gQm94TWFwPGJ5dGVzPDMyPiwgRXhlY3V0aW9uSW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeEV4ZWN1dGlvbnMgfSkKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozNjgKICAgIC8vIGFzc2VydCh0aGlzLmV4ZWN1dGlvbnMoVHhuLmxlYXNlKS52YWx1ZS5maXJzdFZhbGlkIDw9IEdsb2JhbC5yb3VuZCwgRVJSX0VYRUNVVElPTl9OT1RfUkVBRFkpOwogICAgaW50Y18yIC8vIDIKICAgIGludGNfMyAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZ2xvYmFsIFJvdW5kCiAgICA8PQogICAgYXNzZXJ0IC8vIEV4ZWN1dGlvbiBrZXkgbm90IHJlYWR5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE3MQogICAgLy8gZXhlY3V0aW9ucyA9IEJveE1hcDxieXRlczwzMj4sIEV4ZWN1dGlvbkluZm8+KHsga2V5UHJlZml4OiBBYnN0cmFjdEFjY291bnRCb3hQcmVmaXhFeGVjdXRpb25zIH0pCiAgICBieXRlYyA5IC8vICJ4IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozNjkKICAgIC8vIGFzc2VydCh0aGlzLmV4ZWN1dGlvbnMoVHhuLmxlYXNlKS52YWx1ZS5sYXN0VmFsaWQgPj0gR2xvYmFsLnJvdW5kLCBFUlJfRVhFQ1VUSU9OX0VYUElSRUQpOwogICAgdHhuIExlYXNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE3MQogICAgLy8gZXhlY3V0aW9ucyA9IEJveE1hcDxieXRlczwzMj4sIEV4ZWN1dGlvbkluZm8+KHsga2V5UHJlZml4OiBBYnN0cmFjdEFjY291bnRCb3hQcmVmaXhFeGVjdXRpb25zIH0pCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MzY5CiAgICAvLyBhc3NlcnQodGhpcy5leGVjdXRpb25zKFR4bi5sZWFzZSkudmFsdWUubGFzdFZhbGlkID49IEdsb2JhbC5yb3VuZCwgRVJSX0VYRUNVVElPTl9FWFBJUkVEKTsKICAgIHB1c2hpbnQgMTAgLy8gMTAKICAgIGludGNfMyAvLyA4CiAgICBib3hfZXh0cmFjdAogICAgYnRvaQogICAgZ2xvYmFsIFJvdW5kCiAgICA+PQogICAgYXNzZXJ0IC8vIEV4ZWN1dGlvbiBrZXkgZXhwaXJlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNzEKICAgIC8vIGV4ZWN1dGlvbnMgPSBCb3hNYXA8Ynl0ZXM8MzI+LCBFeGVjdXRpb25JbmZvPih7IGtleVByZWZpeDogQWJzdHJhY3RBY2NvdW50Qm94UHJlZml4RXhlY3V0aW9ucyB9KQogICAgYnl0ZWMgOSAvLyAieCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MzcxCiAgICAvLyBjb25zdCBncm91cHMgPSB0aGlzLmV4ZWN1dGlvbnMoVHhuLmxlYXNlKS52YWx1ZS5ncm91cHMgYXMgUmVhZG9ubHk8Ynl0ZXM8MzI+W10+OwogICAgdHhuIExlYXNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE3MQogICAgLy8gZXhlY3V0aW9ucyA9IEJveE1hcDxieXRlczwzMj4sIEV4ZWN1dGlvbkluZm8+KHsga2V5UHJlZml4OiBBYnN0cmFjdEFjY291bnRCb3hQcmVmaXhFeGVjdXRpb25zIH0pCiAgICBjb25jYXQKICAgIGZyYW1lX2J1cnkgNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozNzMKICAgIC8vIGxldCBmb3VuZEdyb3VwID0gZmFsc2U7CiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAxNwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozNzQKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDE4CgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX3doaWxlX3RvcEAyNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Mzc0CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSArPSAxKSB7CiAgICBmcmFtZV9kaWcgNQogICAgcHVzaGludCAxOCAvLyAxOAogICAgaW50Y18yIC8vIDIKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBmcmFtZV9kaWcgMTgKICAgID4KICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fYWZ0ZXJfd2hpbGVAMjgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Mzc1CiAgICAvLyBpZiAoZ3JvdXBzW2ldID09PSBHbG9iYWwuZ3JvdXBJZCkgewogICAgZnJhbWVfZGlnIDE4CiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICAqCiAgICBwdXNoaW50IDIwIC8vIDIwCiAgICArCiAgICBmcmFtZV9kaWcgNQogICAgc3dhcAogICAgcHVzaGludCAzMiAvLyAzMgogICAgYm94X2V4dHJhY3QKICAgIGdsb2JhbCBHcm91cElECiAgICA9PQogICAgYnogc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9hZnRlcl9pZl9lbHNlQDI3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjM3NgogICAgLy8gZm91bmRHcm91cCA9IHRydWU7CiAgICBpbnRjXzEgLy8gMQogICAgZnJhbWVfYnVyeSAxNwoKc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9hZnRlcl9pZl9lbHNlQDI3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozNzQKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGZyYW1lX2RpZyAxOAogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGZyYW1lX2J1cnkgMTgKICAgIGIgc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl93aGlsZV90b3BAMjQKCnNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fYWZ0ZXJfd2hpbGVAMjg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjM4MAogICAgLy8gYXNzZXJ0KGZvdW5kR3JvdXAsIEVSUl9HUk9VUF9OT1RfRk9VTkQpOwogICAgZnJhbWVfZGlnIDE3CiAgICBhc3NlcnQgLy8gR3JvdXAgbm90IGZvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE3MQogICAgLy8gZXhlY3V0aW9ucyA9IEJveE1hcDxieXRlczwzMj4sIEV4ZWN1dGlvbkluZm8+KHsga2V5UHJlZml4OiBBYnN0cmFjdEFjY291bnRCb3hQcmVmaXhFeGVjdXRpb25zIH0pCiAgICBieXRlYyA5IC8vICJ4IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozODEKICAgIC8vIHRoaXMuZXhlY3V0aW9ucyhUeG4ubGVhc2UpLmRlbGV0ZSgpOwogICAgdHhuIExlYXNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE3MQogICAgLy8gZXhlY3V0aW9ucyA9IEJveE1hcDxieXRlczwzMj4sIEV4ZWN1dGlvbkluZm8+KHsga2V5UHJlZml4OiBBYnN0cmFjdEFjY291bnRCb3hQcmVmaXhFeGVjdXRpb25zIH0pCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MzgxCiAgICAvLyB0aGlzLmV4ZWN1dGlvbnMoVHhuLmxlYXNlKS5kZWxldGUoKTsKICAgIGJveF9kZWwKICAgIHBvcAoKc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9hZnRlcl9pZl9lbHNlQDI5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czozODQKICAgIC8vIGNvbnN0IGluaXRpYWxDaGVjayA9IHRoaXMucGx1Z2luQ2hlY2soa2V5KTsKICAgIGZyYW1lX2RpZyA3CiAgICBjYWxsc3ViIHBsdWdpbkNoZWNrCiAgICBmcmFtZV9idXJ5IDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Mzg2CiAgICAvLyBhc3NlcnQoaW5pdGlhbENoZWNrLmV4aXN0cywgRVJSX1BMVUdJTl9ET0VTX05PVF9FWElTVCk7CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIGFzc2VydCAvLyBQbHVnaW4gZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Mzg3CiAgICAvLyBhc3NlcnQoIWluaXRpYWxDaGVjay5leHBpcmVkLCBFUlJfUExVR0lOX0VYUElSRUQpOwogICAgZHVwCiAgICBpbnRjXzEgLy8gMQogICAgZ2V0Yml0CiAgICAhCiAgICBhc3NlcnQgLy8gcGx1Z2luIGV4cGlyZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Mzg4CiAgICAvLyBhc3NlcnQoIWluaXRpYWxDaGVjay5vbkNvb2xkb3duLCBFUlJfUExVR0lOX09OX0NPT0xET1dOKTsKICAgIGludGNfMiAvLyAyCiAgICBnZXRiaXQKICAgICEKICAgIGFzc2VydCAvLyBwbHVnaW4gb24gY29vbGRvd24KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MzkwLTM5MgogICAgLy8gY29uc3QgZXBvY2hSZWYgPSB1c2VSb3VuZHMKICAgIC8vICAgPyBHbG9iYWwucm91bmQKICAgIC8vICAgOiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wOwogICAgZnJhbWVfZGlnIDMxCiAgICBieiBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX3Rlcm5hcnlfZmFsc2VAMzEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MzkxCiAgICAvLyA/IEdsb2JhbC5yb3VuZAogICAgZ2xvYmFsIFJvdW5kCiAgICBmcmFtZV9idXJ5IDE1CgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX3Rlcm5hcnlfbWVyZ2VAMzI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjM5NAogICAgLy8gbGV0IHJla2V5c0JhY2sgPSBmYWxzZTsKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDI4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjM5NQogICAgLy8gbGV0IG1ldGhvZEluZGV4OiB1aW50NjQgPSAwOwogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgMjUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Mzk3CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAoVHhuLmdyb3VwSW5kZXggKyAxKTsgaSA8IEdsb2JhbC5ncm91cFNpemU7IGkgKz0gMSkgewogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDIwCiAgICBmcmFtZV9kaWcgNwogICAgZnJhbWVfYnVyeSA4CgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX3doaWxlX3RvcEAzMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Mzk3CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAoVHhuLmdyb3VwSW5kZXggKyAxKTsgaSA8IEdsb2JhbC5ncm91cFNpemU7IGkgKz0gMSkgewogICAgZnJhbWVfZGlnIDIwCiAgICBnbG9iYWwgR3JvdXBTaXplCiAgICA8CiAgICBieiBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2Jsb2NrQDYwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjQwMAogICAgLy8gaWYgKHRoaXMudHhuUmVrZXlzQmFjayh0eG4pKSB7CiAgICBmcmFtZV9kaWcgMjAKICAgIGNhbGxzdWIgdHhuUmVrZXlzQmFjawogICAgYnogc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9hZnRlcl9pZl9lbHNlQDM2CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjQwMQogICAgLy8gcmVrZXlzQmFjayA9IHRydWU7CiAgICBpbnRjXzEgLy8gMQogICAgZnJhbWVfYnVyeSAyOAoKc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9ibG9ja0A2MDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NDMxCiAgICAvLyBhc3NlcnQocmVrZXlzQmFjaywgRVJSX01JU1NJTkdfUkVLRVlfQkFDSyk7CiAgICBmcmFtZV9kaWcgMjgKICAgIGFzc2VydCAvLyBtaXNzaW5nIHJla2V5IGJhY2sKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTYzCiAgICAvLyBwbHVnaW5zID0gQm94TWFwPFBsdWdpbktleSwgUGx1Z2luSW5mbz4oeyBrZXlQcmVmaXg6IEFic3RyYWN0QWNjb3VudEJveFByZWZpeFBsdWdpbnMgfSk7CiAgICBieXRlY18zIC8vICJwIgogICAgZnJhbWVfZGlnIDgKICAgIGNvbmNhdAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OTAzCiAgICAvLyBpZiAodGhpcy5wbHVnaW5zKGtleSkudmFsdWUuY292ZXJGZWVzKSB7CiAgICBwdXNoaW50IDI3IC8vIDI3CiAgICBpbnRjXzEgLy8gMQogICAgYm94X2V4dHJhY3QKICAgIHB1c2hpbnQgMyAvLyAzCiAgICBnZXRiaXQKICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fZWxzZV9ib2R5QDE2CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjkwNQogICAgLy8gY29uc3QgbWF4RmVlOiB1aW50NjQgPSAoTUFYX0lOTkVSX1RYTl9DT1VOVCArIE1BWF9PVVRFUl9UWE5fQ09VTlQpICogR2xvYmFsLm1pblR4bkZlZQogICAgcHVzaGludCAyNzIgLy8gMjcyCiAgICBnbG9iYWwgTWluVHhuRmVlCiAgICAqCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OTA2CiAgICAvLyBjb25zdCByZWltYnVyc2VtZW50ID0gVHhuLmZlZSA8IG1heEZlZSA/IFR4bi5mZWUgOiBtYXhGZWUKICAgIHR4biBGZWUKICAgID4KICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fdGVybmFyeV9mYWxzZUAxMwogICAgdHhuIEZlZQoKc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl90ZXJuYXJ5X21lcmdlQDE0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo5MDgtOTE2CiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICBzZW5kZXI6IHRoaXMuc3BlbmRpbmdBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIHJlY2VpdmVyOiBUeG4uc2VuZGVyLAogICAgLy8gICAgIGFtb3VudDogcmVpbWJ1cnNlbWVudCwKICAgIC8vICAgICByZWtleVRvOiBwbHVnaW5BcHAuYWRkcmVzcywKICAgIC8vICAgICBub3RlOiAncmVrZXlpbmcgdG8gcGx1Z2luIGFwcCAmIHJlaW1idXJzaW5nIGNhbGxlcicKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjkxMAogICAgLy8gc2VuZGVyOiB0aGlzLnNwZW5kaW5nQWRkcmVzcy52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE0NgogICAgLy8gc3BlbmRpbmdBZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcyB9KQogICAgYnl0ZWMgMTAgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjkxMAogICAgLy8gc2VuZGVyOiB0aGlzLnNwZW5kaW5nQWRkcmVzcy52YWx1ZSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjkxMQogICAgLy8gcmVjZWl2ZXI6IFR4bi5zZW5kZXIsCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjkxMwogICAgLy8gcmVrZXlUbzogcGx1Z2luQXBwLmFkZHJlc3MsCiAgICBmcmFtZV9kaWcgLTUKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OTE0CiAgICAvLyBub3RlOiAncmVrZXlpbmcgdG8gcGx1Z2luIGFwcCAmIHJlaW1idXJzaW5nIGNhbGxlcicKICAgIHB1c2hieXRlcyAicmVrZXlpbmcgdG8gcGx1Z2luIGFwcCAmIHJlaW1idXJzaW5nIGNhbGxlciIKICAgIGl0eG5fZmllbGQgTm90ZQogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo5MDgtOTE1CiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICBzZW5kZXI6IHRoaXMuc3BlbmRpbmdBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIHJlY2VpdmVyOiBUeG4uc2VuZGVyLAogICAgLy8gICAgIGFtb3VudDogcmVpbWJ1cnNlbWVudCwKICAgIC8vICAgICByZWtleVRvOiBwbHVnaW5BcHAuYWRkcmVzcywKICAgIC8vICAgICBub3RlOiAncmVrZXlpbmcgdG8gcGx1Z2luIGFwcCAmIHJlaW1idXJzaW5nIGNhbGxlcicKICAgIC8vICAgfSkKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OTA4LTkxNgogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyOiB0aGlzLnNwZW5kaW5nQWRkcmVzcy52YWx1ZSwKICAgIC8vICAgICByZWNlaXZlcjogVHhuLnNlbmRlciwKICAgIC8vICAgICBhbW91bnQ6IHJlaW1idXJzZW1lbnQsCiAgICAvLyAgICAgcmVrZXlUbzogcGx1Z2luQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgbm90ZTogJ3Jla2V5aW5nIHRvIHBsdWdpbiBhcHAgJiByZWltYnVyc2luZyBjYWxsZXInCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCnNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fYWZ0ZXJfaWZfZWxzZUAxODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTUwCiAgICAvLyByZWtleUluZGV4ID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGluaXRpYWxWYWx1ZTogMCwga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNSZWtleUluZGV4IH0pCiAgICBieXRlYyAxOSAvLyAicmVrZXlfaW5kZXgiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjkyOQogICAgLy8gdGhpcy5yZWtleUluZGV4LnZhbHVlID0gVHhuLmdyb3VwSW5kZXgKICAgIHR4biBHcm91cEluZGV4CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo5MzEKICAgIC8vIGlmICh0aGlzLnBsdWdpbnMoa2V5KS52YWx1ZS5kZWxlZ2F0aW9uVHlwZSA9PT0gRGVsZWdhdGlvblR5cGVTZWxmKSB7CiAgICBmcmFtZV9kaWcgNAogICAgaW50Y18zIC8vIDgKICAgIGludGNfMSAvLyAxCiAgICBib3hfZXh0cmFjdAogICAgYnl0ZWMgMTQgLy8gMHgwMQogICAgPT0KICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fYWZ0ZXJfaWZfZWxzZUAyMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNDIKICAgIC8vIGxhc3RVc2VySW50ZXJhY3Rpb24gPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiBBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNMYXN0VXNlckludGVyYWN0aW9uIH0pCiAgICBieXRlYyA0IC8vICJsYXN0X3VzZXJfaW50ZXJhY3Rpb24iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE4NwogICAgLy8gdGhpcy5sYXN0VXNlckludGVyYWN0aW9uLnZhbHVlID0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgYXBwX2dsb2JhbF9wdXQKCnNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fYWZ0ZXJfaWZfZWxzZUAyMDoKICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfZGlnIC0xCiAgICBmcmFtZV9idXJ5IDEKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX3Rlcm5hcnlfZmFsc2VAMTM6CiAgICBmcmFtZV9kaWcgMjQKICAgIGIgc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl90ZXJuYXJ5X21lcmdlQDE0CgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2Vsc2VfYm9keUAxNjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OTE4LTkyNQogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyOiB0aGlzLnNwZW5kaW5nQWRkcmVzcy52YWx1ZSwKICAgIC8vICAgICByZWNlaXZlcjogdGhpcy5zcGVuZGluZ0FkZHJlc3MudmFsdWUsCiAgICAvLyAgICAgcmVrZXlUbzogcGx1Z2luQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgbm90ZTogJ3Jla2V5aW5nIHRvIHBsdWdpbiBhcHAnCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKTsKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OTIwCiAgICAvLyBzZW5kZXI6IHRoaXMuc3BlbmRpbmdBZGRyZXNzLnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQ2CiAgICAvLyBzcGVuZGluZ0FkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzIH0pCiAgICBieXRlYyAxMCAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OTIwCiAgICAvLyBzZW5kZXI6IHRoaXMuc3BlbmRpbmdBZGRyZXNzLnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OTIyCiAgICAvLyByZWtleVRvOiBwbHVnaW5BcHAuYWRkcmVzcywKICAgIGZyYW1lX2RpZyAtNQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo5MjMKICAgIC8vIG5vdGU6ICdyZWtleWluZyB0byBwbHVnaW4gYXBwJwogICAgcHVzaGJ5dGVzICJyZWtleWluZyB0byBwbHVnaW4gYXBwIgogICAgaXR4bl9maWVsZCBOb3RlCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGR1cAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OTE4LTkyNAogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyOiB0aGlzLnNwZW5kaW5nQWRkcmVzcy52YWx1ZSwKICAgIC8vICAgICByZWNlaXZlcjogdGhpcy5zcGVuZGluZ0FkZHJlc3MudmFsdWUsCiAgICAvLyAgICAgcmVrZXlUbzogcGx1Z2luQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgbm90ZTogJ3Jla2V5aW5nIHRvIHBsdWdpbiBhcHAnCiAgICAvLyAgIH0pCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjkxOC05MjUKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHNlbmRlcjogdGhpcy5zcGVuZGluZ0FkZHJlc3MudmFsdWUsCiAgICAvLyAgICAgcmVjZWl2ZXI6IHRoaXMuc3BlbmRpbmdBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIHJla2V5VG86IHBsdWdpbkFwcC5hZGRyZXNzLAogICAgLy8gICAgIG5vdGU6ICdyZWtleWluZyB0byBwbHVnaW4gYXBwJwogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX3N1Ym1pdAogICAgYiBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2FmdGVyX2lmX2Vsc2VAMTgKCnNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fYWZ0ZXJfaWZfZWxzZUAzNjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NDA1CiAgICAvLyBpZiAodHhuLnR5cGUgIT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwpIHsKICAgIGZyYW1lX2RpZyAyMAogICAgZ3R4bnMgVHlwZUVudW0KICAgIHB1c2hpbnQgNiAvLyA2CiAgICAhPQogICAgYnogc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9hZnRlcl9pZl9lbHNlQDM4CiAgICBmcmFtZV9kaWcgOAoKc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9ibG9ja0A1ODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6Mzk3CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAoVHhuLmdyb3VwSW5kZXggKyAxKTsgaSA8IEdsb2JhbC5ncm91cFNpemU7IGkgKz0gMSkgewogICAgZnJhbWVfZGlnIDIwCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSAyMAogICAgZnJhbWVfYnVyeSA4CiAgICBiIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fd2hpbGVfdG9wQDMzCgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2FmdGVyX2lmX2Vsc2VAMzg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjQwOQogICAgLy8gYXNzZXJ0KHR4bi5hcHBJZC5pZCA9PT0ga2V5LnBsdWdpbiwgRVJSX0NBTk5PVF9DQUxMX09USEVSX0FQUFNfRFVSSU5HX1JFS0VZKTsKICAgIGZyYW1lX2RpZyAyMAogICAgZHVwCiAgICBndHhucyBBcHBsaWNhdGlvbklECiAgICBmcmFtZV9kaWcgNwogICAgZHVwCiAgICBjb3ZlciAzCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgID09CiAgICBhc3NlcnQgLy8gY2Fubm90IGNhbGwgb3RoZXIgYXBwcyBkdXJpbmcgcmVrZXkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NDEwCiAgICAvLyBhc3NlcnQodHhuLm9uQ29tcGxldGlvbiA9PT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wLCBFUlJfSU5WQUxJRF9PTkNPTVBMRVRFKTsKICAgIGR1cAogICAgZ3R4bnMgT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gaW52YWxpZCBvbmNvbXBsZXRlIG11c3QgYmUgbm8gb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NDEzCiAgICAvLyBhc3NlcnQodHhuLm51bUFwcEFyZ3MgPiAxLCBFUlJfSU5WQUxJRF9TRU5ERVJfQVJHKTsKICAgIGR1cAogICAgZ3R4bnMgTnVtQXBwQXJncwogICAgaW50Y18xIC8vIDEKICAgID4KICAgIGFzc2VydCAvLyBpbnZhbGlkIHNlbmRlciBtdXN0IGJlIHRoaXMgYXBwIGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjQxNAogICAgLy8gYXNzZXJ0KEFwcGxpY2F0aW9uKGJ0b2kodHhuLmFwcEFyZ3MoMSkpKSA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkLCBFUlJfSU5WQUxJRF9TRU5ERVJfVkFMVUUpOwogICAgaW50Y18xIC8vIDEKICAgIGd0eG5zYXMgQXBwbGljYXRpb25BcmdzCiAgICBidG9pCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uSUQKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBzZW5kZXIgYXBwIGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjQxNgogICAgLy8gY29uc3QgeyBleHBpcmVkLCBvbkNvb2xkb3duLCBoYXNNZXRob2RSZXN0cmljdGlvbnMgfSA9IHRoaXMucGx1Z2luQ2hlY2soa2V5KTsKICAgIGNhbGxzdWIgcGx1Z2luQ2hlY2sKICAgIGZyYW1lX2J1cnkgNwogICAgZHVwCiAgICBpbnRjXzEgLy8gMQogICAgZ2V0Yml0CiAgICBkaWcgMQogICAgaW50Y18yIC8vIDIKICAgIGdldGJpdAogICAgdW5jb3ZlciAyCiAgICBwdXNoaW50IDMgLy8gMwogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjQxOAogICAgLy8gYXNzZXJ0KCFleHBpcmVkLCBFUlJfUExVR0lOX0VYUElSRUQpOwogICAgdW5jb3ZlciAyCiAgICAhCiAgICBhc3NlcnQgLy8gcGx1Z2luIGV4cGlyZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NDE5CiAgICAvLyBhc3NlcnQoIW9uQ29vbGRvd24sIEVSUl9QTFVHSU5fT05fQ09PTERPV04pOwogICAgc3dhcAogICAgIQogICAgYXNzZXJ0IC8vIHBsdWdpbiBvbiBjb29sZG93bgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo0MjEKICAgIC8vIGlmIChoYXNNZXRob2RSZXN0cmljdGlvbnMpIHsKICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fYWZ0ZXJfaWZfZWxzZUA1NwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo0MjIKICAgIC8vIGFzc2VydChtZXRob2RJbmRleCA8IG1ldGhvZE9mZnNldHMubGVuZ3RoLCBFUlJfTUFMRk9STUVEX09GRlNFVFMpOwogICAgZnJhbWVfZGlnIC0yCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGZyYW1lX2RpZyAyNQogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIDwKICAgIGFzc2VydCAvLyBtYWxmb3JtZWQgbWV0aG9kIG9mZnNldHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NDIzCiAgICAvLyBjb25zdCB7IG1ldGhvZEFsbG93ZWQsIG1ldGhvZE9uQ29vbGRvd24gfSA9IHRoaXMubWV0aG9kQ2hlY2soa2V5LCB0eG4sIG1ldGhvZE9mZnNldHNbbWV0aG9kSW5kZXhdKTsKICAgIGZyYW1lX2RpZyAtMgogICAgZXh0cmFjdCAyIDAKICAgIHN3YXAKICAgIGludGNfMyAvLyA4CiAgICAqCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo0NDQKICAgIC8vIGFzc2VydChsZW4odHhuLmFwcEFyZ3MoMCkpID09PSA0LCBFUlJfSU5WQUxJRF9NRVRIT0RfU0lHTkFUVVJFX0xFTkdUSCkKICAgIGZyYW1lX2RpZyAyMAogICAgaW50Y18wIC8vIDAKICAgIGd0eG5zYXMgQXBwbGljYXRpb25BcmdzCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMTAKICAgIGxlbgogICAgcHVzaGludCA0IC8vIDQKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBtZXRob2Qgc2lnbmF0dXJlIGxlbmd0aAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjMKICAgIC8vIHBsdWdpbnMgPSBCb3hNYXA8UGx1Z2luS2V5LCBQbHVnaW5JbmZvPih7IGtleVByZWZpeDogQWJzdHJhY3RBY2NvdW50Qm94UHJlZml4UGx1Z2lucyB9KTsKICAgIGJ5dGVjXzMgLy8gInAiCiAgICBmcmFtZV9kaWcgNwogICAgY29uY2F0CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo0NDcKICAgIC8vIGNvbnN0IHsgdXNlUm91bmRzIH0gPSB0aGlzLnBsdWdpbnMoa2V5KS52YWx1ZQogICAgZHVwCiAgICBwdXNoaW50IDI3IC8vIDI3CiAgICBpbnRjXzEgLy8gMQogICAgYm94X2V4dHJhY3QKICAgIGludGNfMSAvLyAxCiAgICBnZXRiaXQKICAgIGR1cAogICAgY292ZXIgMgogICAgZnJhbWVfYnVyeSAzMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo0NDgKICAgIC8vIGNvbnN0IHsgc2VsZWN0b3IsIGNvb2xkb3duLCBsYXN0Q2FsbGVkIH0gPSB0aGlzLnBsdWdpbnMoa2V5KS52YWx1ZS5tZXRob2RzW29mZnNldF0KICAgIHVuY292ZXIgMgogICAgcHVzaGludCAyMCAvLyAyMAogICAgKgogICAgZHVwCiAgICBmcmFtZV9idXJ5IDEzCiAgICBwdXNoaW50IDQ2IC8vIDQ2CiAgICArCiAgICBwdXNoaW50IDIwIC8vIDIwCiAgICBib3hfZXh0cmFjdAogICAgZHVwCiAgICBleHRyYWN0IDAgNAogICAgZnJhbWVfYnVyeSA5CiAgICBkdXAKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfYnVyeSAxNAogICAgcHVzaGludCAxMiAvLyAxMgogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2J1cnkgMjIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NDUyCiAgICAvLyBjb25zdCBlcG9jaFJlZiA9IHVzZVJvdW5kcyA/IEdsb2JhbC5yb3VuZCA6IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fdGVybmFyeV9mYWxzZUA0MQogICAgZ2xvYmFsIFJvdW5kCgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX3Rlcm5hcnlfbWVyZ2VANDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjQ1MwogICAgLy8gY29uc3QgbWV0aG9kT25Db29sZG93biA9IChlcG9jaFJlZiAtIGxhc3RDYWxsZWQpIDwgY29vbGRvd24KICAgIGZyYW1lX2RpZyAyMgogICAgLQogICAgZnJhbWVfZGlnIDE0CiAgICA8CiAgICBmcmFtZV9idXJ5IDI2CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjQ1NQogICAgLy8gaWYgKHNlbGVjdG9yID09PSBzZWxlY3RvckFyZyAmJiAoIWhhc0Nvb2xkb3duIHx8ICFtZXRob2RPbkNvb2xkb3duKSkgewogICAgZnJhbWVfZGlnIDkKICAgIGZyYW1lX2RpZyAxMAogICAgPT0KICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fYWZ0ZXJfaWZfZWxzZUA1MQogICAgZnJhbWVfZGlnIDE0CiAgICBieiBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2lmX2JvZHlANDUKICAgIGZyYW1lX2RpZyAyNgogICAgYm56IHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fYWZ0ZXJfaWZfZWxzZUA1MQoKc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9pZl9ib2R5QDQ1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo0NTcKICAgIC8vIGlmIChoYXNDb29sZG93bikgewogICAgZnJhbWVfZGlnIDE0CiAgICBieiBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2FmdGVyX2lmX2Vsc2VANTAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NDU4CiAgICAvLyBjb25zdCBsYXN0Q2FsbGVkID0gdXNlUm91bmRzID8gR2xvYmFsLnJvdW5kIDogR2xvYmFsLmxhdGVzdFRpbWVzdGFtcDsKICAgIGZyYW1lX2RpZyAzMQogICAgYnogc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl90ZXJuYXJ5X2ZhbHNlQDQ4CiAgICBnbG9iYWwgUm91bmQKCnNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fdGVybmFyeV9tZXJnZUA0OToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NDU5CiAgICAvLyB0aGlzLnBsdWdpbnMoa2V5KS52YWx1ZS5tZXRob2RzW29mZnNldF0ubGFzdENhbGxlZCA9IGxhc3RDYWxsZWQKICAgIGl0b2IKICAgIGZyYW1lX2RpZyAxMwogICAgcHVzaGludCA1OCAvLyA1OAogICAgKwogICAgZnJhbWVfZGlnIDIKICAgIHN3YXAKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKCnNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fYWZ0ZXJfaWZfZWxzZUA1MDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NDYyLTQ2NQogICAgLy8gcmV0dXJuIHsKICAgIC8vICAgbWV0aG9kQWxsb3dlZDogdHJ1ZSwKICAgIC8vICAgbWV0aG9kT25Db29sZG93bgogICAgLy8gfQogICAgcHVzaGJ5dGVzIDB4ODAKICAgIGludGNfMSAvLyAxCiAgICBmcmFtZV9kaWcgMjYKICAgIHNldGJpdAoKc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50Lm1ldGhvZENoZWNrQDUyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo0MjMKICAgIC8vIGNvbnN0IHsgbWV0aG9kQWxsb3dlZCwgbWV0aG9kT25Db29sZG93biB9ID0gdGhpcy5tZXRob2RDaGVjayhrZXksIHR4biwgbWV0aG9kT2Zmc2V0c1ttZXRob2RJbmRleF0pOwogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICBpbnRjXzEgLy8gMQogICAgZ2V0Yml0CiAgICBmcmFtZV9idXJ5IDI2CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjQyNAogICAgLy8gYXNzZXJ0KG1ldGhvZEFsbG93ZWQgJiYgIW1ldGhvZE9uQ29vbGRvd24sIEVSUl9NRVRIT0RfT05fQ09PTERPV04pOwogICAgYnogc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9ib29sX2ZhbHNlQDU1CiAgICBmcmFtZV9kaWcgMjYKICAgIGJueiBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2Jvb2xfZmFsc2VANTUKICAgIGludGNfMSAvLyAxCgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2Jvb2xfbWVyZ2VANTY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjQyNAogICAgLy8gYXNzZXJ0KG1ldGhvZEFsbG93ZWQgJiYgIW1ldGhvZE9uQ29vbGRvd24sIEVSUl9NRVRIT0RfT05fQ09PTERPV04pOwogICAgYXNzZXJ0IC8vIG1ldGhvZCBvbiBjb29sZG93bgoKc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl9hZnRlcl9pZl9lbHNlQDU3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjMKICAgIC8vIHBsdWdpbnMgPSBCb3hNYXA8UGx1Z2luS2V5LCBQbHVnaW5JbmZvPih7IGtleVByZWZpeDogQWJzdHJhY3RBY2NvdW50Qm94UHJlZml4UGx1Z2lucyB9KTsKICAgIGJ5dGVjXzMgLy8gInAiCiAgICBmcmFtZV9kaWcgNwogICAgZHVwCiAgICBjb3ZlciAyCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NDI3CiAgICAvLyB0aGlzLnBsdWdpbnMoa2V5KS52YWx1ZS5sYXN0Q2FsbGVkID0gZXBvY2hSZWYKICAgIGZyYW1lX2RpZyAxNQogICAgaXRvYgogICAgcHVzaGludCAyOCAvLyAyOAogICAgc3dhcAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NDI4CiAgICAvLyBtZXRob2RJbmRleCArPSAxOwogICAgZnJhbWVfZGlnIDI1CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSAyNQogICAgYiBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2Jsb2NrQDU4CgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2Jvb2xfZmFsc2VANTU6CiAgICBpbnRjXzAgLy8gMAogICAgYiBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2Jvb2xfbWVyZ2VANTYKCnNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fdGVybmFyeV9mYWxzZUA0ODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NDU4CiAgICAvLyBjb25zdCBsYXN0Q2FsbGVkID0gdXNlUm91bmRzID8gR2xvYmFsLnJvdW5kIDogR2xvYmFsLmxhdGVzdFRpbWVzdGFtcDsKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGIgc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl90ZXJuYXJ5X21lcmdlQDQ5CgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2FmdGVyX2lmX2Vsc2VANTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjQ2OC00NzEKICAgIC8vIHJldHVybiB7CiAgICAvLyAgIG1ldGhvZEFsbG93ZWQ6IGZhbHNlLAogICAgLy8gICBtZXRob2RPbkNvb2xkb3duOiB0cnVlCiAgICAvLyB9CiAgICBwdXNoYnl0ZXMgMHg0MAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo0MjMKICAgIC8vIGNvbnN0IHsgbWV0aG9kQWxsb3dlZCwgbWV0aG9kT25Db29sZG93biB9ID0gdGhpcy5tZXRob2RDaGVjayhrZXksIHR4biwgbWV0aG9kT2Zmc2V0c1ttZXRob2RJbmRleF0pOwogICAgYiBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQubWV0aG9kQ2hlY2tANTIKCnNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fdGVybmFyeV9mYWxzZUA0MToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6NDUyCiAgICAvLyBjb25zdCBlcG9jaFJlZiA9IHVzZVJvdW5kcyA/IEdsb2JhbC5yb3VuZCA6IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGIgc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYXJjNThfcmVrZXlUb1BsdWdpbl90ZXJuYXJ5X21lcmdlQDQyCgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX3Rlcm5hcnlfZmFsc2VAMzE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjM5MgogICAgLy8gOiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wOwogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgZnJhbWVfYnVyeSAxNQogICAgYiBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX3Rlcm5hcnlfbWVyZ2VAMzIKCnNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fZWxzZV9ib2R5QDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjg5NwogICAgLy8gdGhpcy5zcGVuZGluZ0FkZHJlc3MudmFsdWUgPSB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzIKICAgIC8vIGNvbnRyb2xsZWRBZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzIH0pOwogICAgYnl0ZWNfMCAvLyAiY29udHJvbGxlZF9hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo4OTcKICAgIC8vIHRoaXMuc3BlbmRpbmdBZGRyZXNzLnZhbHVlID0gdGhpcy5jb250cm9sbGVkQWRkcmVzcy52YWx1ZQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTQ2CiAgICAvLyBzcGVuZGluZ0FkZHJlc3MgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzIH0pCiAgICBieXRlYyAxMCAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6ODk3CiAgICAvLyB0aGlzLnNwZW5kaW5nQWRkcmVzcy52YWx1ZSA9IHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICBiIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fYWZ0ZXJfaWZfZWxzZUA4CgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5hcmM1OF9yZWtleVRvUGx1Z2luX3Rlcm5hcnlfZmFsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6ODg1CiAgICAvLyBjb25zdCBjYWxsZXIgPSBnbG9iYWwgPyBHbG9iYWwuemVyb0FkZHJlc3MgOiBUeG4uc2VuZGVyCiAgICB0eG4gU2VuZGVyCiAgICBiIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmFyYzU4X3Jla2V5VG9QbHVnaW5fdGVybmFyeV9tZXJnZUAzCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnQuYmFsYW5jZShhc3NldHM6IGJ5dGVzKSAtPiBieXRlcywgYnl0ZXM6CnNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmJhbGFuY2U6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE2NDAtMTY0MQogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICAvLyBiYWxhbmNlKGFzc2V0czogdWludDY0W10pOiB1aW50NjRbXSB7CiAgICBwcm90byAxIDIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICIiCiAgICBkdXBuIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTY0MgogICAgLy8gbGV0IGFtb3VudHM6IHVpbnQ2NFtdID0gW10KICAgIGJ5dGVjIDcgLy8gMHgwMDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE2NDMKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGludGNfMCAvLyAwCgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5iYWxhbmNlX3doaWxlX3RvcEAxOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjQzCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgYXNzZXRzLmxlbmd0aDsgaSArPSAxKSB7CiAgICBmcmFtZV9kaWcgLTEKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZnJhbWVfZGlnIDUKICAgID4KICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmJhbGFuY2VfYWZ0ZXJfd2hpbGVAOQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjQ0CiAgICAvLyBsZXQgYW1vdW50OiB1aW50NjQgPSAwCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE2NDUKICAgIC8vIGNvbnN0IGFzc2V0ID0gQXNzZXQoYXNzZXRzW2ldKQogICAgZnJhbWVfZGlnIC0xCiAgICBleHRyYWN0IDIgMAogICAgZnJhbWVfZGlnIDUKICAgIGludGNfMyAvLyA4CiAgICAqCiAgICBkdXAyCiAgICBpbnRjXzMgLy8gOAogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IGluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBmcmFtZV9idXJ5IDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjQ3CiAgICAvLyBpZiAoYXNzZXQuaWQgPT09IDApIHsKICAgIGJueiBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5iYWxhbmNlX2Vsc2VfYm9keUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE2NDgKICAgIC8vIGFtb3VudCA9IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLmJhbGFuY2UKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdEJhbGFuY2UKICAgIHN3YXAKICAgIGZyYW1lX2J1cnkgMQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5iYWxhbmNlX2FmdGVyX2lmX2Vsc2VANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTY1Ni0xNjYyCiAgICAvLyBjb25zdCBlc2Nyb3dJbmZvID0gYWJpQ2FsbDx0eXBlb2YgU3Rha2luZy5wcm90b3R5cGUuZ2V0RXNjcm93SW5mbz4oewogICAgLy8gICBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN0YWtpbmcsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIGFzc2V0LmlkCiAgICAvLyAgIF0KICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE2NTcKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjEyNgogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjIDIwIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE2NTcKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQwCiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBwdXNoYnl0ZXMgImFhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTY1NwogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE2NTkKICAgIC8vIHRoaXMuY29udHJvbGxlZEFkZHJlc3MudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxMzIKICAgIC8vIGNvbnRyb2xsZWRBZGRyZXNzID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzIH0pOwogICAgYnl0ZWNfMCAvLyAiY29udHJvbGxlZF9hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjU5CiAgICAvLyB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTY1Ni0xNjYyCiAgICAvLyBjb25zdCBlc2Nyb3dJbmZvID0gYWJpQ2FsbDx0eXBlb2YgU3Rha2luZy5wcm90b3R5cGUuZ2V0RXNjcm93SW5mbz4oewogICAgLy8gICBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN0YWtpbmcsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICB0aGlzLmNvbnRyb2xsZWRBZGRyZXNzLnZhbHVlLAogICAgLy8gICAgIGFzc2V0LmlkCiAgICAvLyAgIF0KICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBwdXNoYnl0ZXMgMHg0Yzg4ZWFjZSAvLyBtZXRob2QgImdldEVzY3Jvd0luZm8oYWRkcmVzcyx1aW50NjQpKHVpbnQ2NCx1aW50NjQpIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgMAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgZGlnIDEKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlYyA1IC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgbGVuCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAodWludDY0LHVpbnQ2NCkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTY2NAogICAgLy8gYW1vdW50cyA9IFsuLi5hbW91bnRzLCAoYW1vdW50ICsgZXNjcm93SW5mby5oYXJkICsgZXNjcm93SW5mby5sb2NrKV0KICAgIGR1cAogICAgcHVzaGludCA0IC8vIDQKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9kaWcgMQogICAgKwogICAgc3dhcAogICAgcHVzaGludCAxMiAvLyAxMgogICAgZXh0cmFjdF91aW50NjQKICAgICsKICAgIGl0b2IKICAgIGJ5dGVjIDI0IC8vIDB4MDAwMQogICAgc3dhcAogICAgY29uY2F0CiAgICBleHRyYWN0IDIgMAogICAgZnJhbWVfZGlnIDQKICAgIHN3YXAKICAgIGNvbmNhdCAvLyBvbiBlcnJvcjogbWF4IGFycmF5IGxlbmd0aCBleGNlZWRlZAogICAgZHVwCiAgICBleHRyYWN0IDIgMAogICAgbGVuCiAgICBpbnRjXzMgLy8gOAogICAgLwogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHJlcGxhY2UyIDAKICAgIGZyYW1lX2J1cnkgNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjQzCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgYXNzZXRzLmxlbmd0aDsgaSArPSAxKSB7CiAgICBmcmFtZV9kaWcgNQogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGZyYW1lX2J1cnkgNQogICAgYiBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5iYWxhbmNlX3doaWxlX3RvcEAxCgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5iYWxhbmNlX2Vsc2VfYm9keUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvY29udHJhY3QuYWxnby50czoxNjUwCiAgICAvLyBjb25zdCBbaG9sZGluZ0Ftb3VudCwgb3B0ZWRJbl0gPSBBc3NldEhvbGRpbmcuYXNzZXRCYWxhbmNlKEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLCBhc3NldCkKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBmcmFtZV9kaWcgMgogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBzd2FwCiAgICBmcmFtZV9idXJ5IDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6MTY1MQogICAgLy8gaWYgKG9wdGVkSW4pIHsKICAgIGJ6IHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmJhbGFuY2VfYWZ0ZXJfaWZfZWxzZUA3CiAgICBmcmFtZV9kaWcgMwogICAgZnJhbWVfYnVyeSAxCiAgICBiIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2NvbnRyYWN0LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50LmJhbGFuY2VfYWZ0ZXJfaWZfZWxzZUA3CgpzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudC5iYWxhbmNlX2FmdGVyX3doaWxlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9jb250cmFjdC5hbGdvLnRzOjE2NjcKICAgIC8vIHJldHVybiBhbW91bnRzCiAgICBmcmFtZV9kaWcgNAogICAgZnJhbWVfZGlnIC0xCiAgICBmcmFtZV9idXJ5IDEKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCg==", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyAHAAECCJAD1JMBtNgBJh8SY29udHJvbGxlZF9hZGRyZXNzAAFlAXAVbGFzdF91c2VyX2ludGVyYWN0aW9uBBUffHULbGFzdF9jaGFuZ2UCAAABAAF4EHNwZW5kaW5nX2FkZHJlc3MCACoCAAIFYWRtaW4BAQFuAWQCAAoBYQtyZWtleV9pbmRleAlha2l0YV9kYW8GZG9tYWluDmVzY3Jvd19mYWN0b3J5CnJldm9jYXRpb24CAAEOY3VycmVudF9wbHVnaW4EbMP2Bgd2ZXJzaW9uCG5pY2tuYW1lC2ZhY3RvcnlfYXBwAgAsMRhAAAQnEyJngATqkYDdNhoAjgEBLzEZFEQxGEEBGIIKBL1gmeUEd4eGfQQtdxG3BEAabYAEn5HMzQQX2Ly0BDhWWKsEXvC0FQTSS3VWBBR7bNYnGoIcBMlaXT0ERyevIQRYL/OCBN79XNIEVnJGLgRXpR2IBO70SP0EVy/R6gTjULnUBAqMssIEJbcTygTrrxSgBGogXPwErhpNygRkTS3sBL9NfFcE1d04KwRc6+1DBNWGha8EE7xE5ASJp2gmBAV5TX0EokA93wQC/kUVBEG9xoAEiCuxwgQXYMZSBBJMCn82GgCOJwICAosCpQK4AssC5QMLAzEDTgNrA9oEHwSeBP8FSAWjB3sHzQgtCjsKxgryCzcLagwHDEAM8g35DqwPWQ+SD54QLxDiEWESERKfEwkTqQCABKPb03c2GgCOAQElADEZgQQSMRgQREICP4oDAYv9IllJi/8ITCQLJAhLARZXBgJOAov9JEsCUov/JAuvUIv9FYv9TwNPAlJQi/5QTCQLSSKLBIsCDEEAI4sDSRZXBgKLAYsESU4ETwJdSYwBSwFZJAgIjAMkCIwEQv/ViwCLAVCMAImKBAEpSYv+JAuL/CQLIosEiwMMQQAci/2LBElOAlmLAggWVwYCiwFMUIwBJAiMBEL/3Iv9FYwAIowEiwSLAgxBAByL/4sESU4CWYsACBZXBgKLAUxQjAEkCIwEQv/ci/yL/ggWVwYCiwFQi/2LA4sAUlCL/xWL/4sCTwJSUIwAiYoBAYv/FkmTJQ5EVwcBiSKI/+0iFklPAlBLAVBLAVCAAwAsAFBLAVBMUCcHUIk2GgFJIlkkCEsBFRJEVwIANhoCSRUlEkQXNhoDSU4DSRWBIBJENhoESRWBIBJENhoFSSJZJAhLARUSRFcCADYaBkkVJRJEF04FNhoHSRUlEkQXTgU2GghJIlkkCEsBFRJEVwIATgU2GglJTgYVgSASRDINREsBSwMTRCcbTwVnJxRPBGcnDU8CZycVTGcyAxJBADcyCihMZycWSwRnJwoyA2cnF0sDZyccSwJnJx0yDWeACHJlZmVycmVySwFnJwQyB2cnBjIHZyNDSwRC/8Y2GgFJIlkkCEsBFRJEVwIASSJMKRNBAA8qSwJQSb1FAUS+SCJbRQGxIicWZURJcghEgcResgiyByOyECKyAbZLARaABGB+cEayGrIashiBBrIQIrIBsyNDNhoBSSJZJAhLARUSRFcCAIgSG0AADjEAIicdZURyCEQSQQAJI0QnG0sBZyNDIkL/9DYaAUkiWSQISwEVEkRXAgCIEepEJxVMZyNDNhoBSRUlEkQXiBHXRCcXTGcjQzYaAUkVJRJEF4gRxEQnFExnI0M2GgFJIlkkCEsBFRJEVwIAiBGqRCccTGcjQzYaAUkVJRJEF4gRl0RJFicYTFCIGQFIJFtEgAZhdmF0YXJMZyNDNhoBSRUlEkQXiBFxREkWJxhMUIgY20gkW0SABmJhbm5lckxnI0M2GgFJIlkkCEsBFRJEVwIAiBFERIADYmlvTGcjQzYaAUkVgSASRIgRLkQnDUxnJwQyB2cnBjIHZyNDNhoBSRWBIBJEIicZZURJIltLAYEoWUsCFUsDTgJSVwIAKRJEMQBLAXIIRBJEIihlRHMCRExyCEQSRCtMUEm9RQFBACdJgRsjuiJTQQAdI0QnDUsCZ0klI7onDhJBAAUnBDIHZycGMgdnI0MiQv/gIicKZURJcwJMTgJEIihlRBJBACwiKGVEMgoSQQAiMgNLARJEJwoyA2cyCiIWTFCABAAqAABQJxlMZycTImcjQzIKQv/bKUk2GgFJFYEgEkQ2GgJJFSMSRCJTiBBRRLEiKGVEgBtyZWtleWluZyBhYnN0cmFjdGVkIGFjY291bnSyBUsCsiBPArIHsgAjshAisgGzQQAeIkUBMRYjCEUCSwEyBAxBAAtLAYgQ8kEADCNFAUlEJwQyB2cjQ0sBIwhFAkL/2zYaAUkVJRJEFzYaAkkVIxJEIlM2GgNJTgIVgSASRDYaBEkiWSQISwEVEkRXAgBMNhoFSU4CFYEEEkRBAAxLAzIDSwNLA4gP2EhLA0sDSwNLA4gPzCcIIk8CVCcFTFCwI0M2GgFJFSUSRBc2GgJJFSMSRCJTNhoDSSJZJAhLARUSRFcCADYaBEkiWSULJAhLARUSRDYaBUkiWYEQCyQISwEVEkSIEgZGAiNDNhoBSSJZJAhLARUSRFcCADYaAkkVIxJEIlM2GgNJIlkkCEsBFRJEVwIANhoESSJZJQskCEsBFRJENhoFSSJZgRALJAhLARUSRCcPTwVQIiW6F04EiBGrRgIjQyJHAylJNhoBSRUlEkQXNhoCSRWBIBJENhoDSSJZJAhLARUSRFcCADYaBEkVIxJEIlM2GgVHAhUjEkQ2GgZJFSUSRBdMNhoHSRUlEkQXTDYaCElOAkkiWUlOA4EMCyQITBUSRDYaCUkVIxJEIlNMNhoKSRUjEkQiU0w2GgtJFSMSRCJTTDYaDEkVIxJEIlNMNhoNSRUjEkQiU0yIDkhEJw4SQQEwSwwyAxJBASgjFERLA0EBHEsMMgMTQQEUIxRESUABAksLRRJLDRZLDVBLEkkVFlcGAkxQTCcLUExQK0xQSUUUvUUBFEQiFkUUJwdFESJFD0sOSwYMQQA9SwZXAgBLD0lOAoEMC4EMWElXAARMVwQISwEVgQQSRFBLFVBLEklPAlBMIlkjCBZXBgJcAEUSIwhFD0L/u0sEQQCBMgZFECIoZUQyChNBAB6xIihlRDIKSxIiWUsUTIgMxLIIsgeyACOyECKyAbNLC0mIDMZMKRMiSwRPAk1MFksLUEsKFlBLCRZQJx5QJwgiSw5UI0sIVCRLB1SBA0sGVIEETwNUUEsUUEsQFlBLEVBLE0m8SEy/JwQyB2cnBjIHZyNDMgdFEEL/fEsLKRNEKUUSQv73IkL+6SJC/tU2GgFJFYEgEkQ2GgJJIlkkCEsBFRJEVwIAiAzxRCIoZUQyChNBAB6xIihlRDIKSwIVIQQLgdR6CLIIsgeyACOyECKyAbMnEEsCUEm8SEsBvyNDNhoBSRUlEkQXNhoCSRWBIBJENhoDSSJZJAhLARUSRFcCAIgMlkAABogMukEALiNESwIWSwJQSwFJFRZXBgJMUEwnC1BMUCtMUEm9RQFEvEgnBDIHZycGMgdnI0MiQv/PIkcDKUk2GgFJIlkkCEsBFRJEVwIASTYaAkkVJRJEF0w2GgNJTgIVgSASRDYaBEkiWSQISwEVEkRXAgBMNhoFSRUjEkQiU0w2GgZJTgJJFSMSRDYaB0kVJRJEF04CNhoISRUlEkQXTgI2GglJTgNJIllJTgSBDAskCEwVEkQ2GgpJFSMSRCJTTgI2GgtJFSMSRCJTTgI2GgxJFSMSRCJTTgI2Gg1JFSMSRCJTTgI2Gg5JFSMSRCJTTgKIC59EJw9PAlBJTgK9RQEURCcOEkEBOksNMgMSQQEyIxRESwRBASZLDTIDE0EBHiMUREsBQAELSwxFFUsOFksOUEsVSRUWVwYCTFBMJwtQTFBJRRVLAUm8SEy/IhZFFicHRRMiRRFLEEsHDEEAPUsHVwIASxFJTgKBDAuBDFhJVwAETFcECEsBFYEEEkRQSxdQSxRJTwJQTCJZIwgWVwYCXABFFCMIRRFC/7siKGVEMgoTQQAosSIoZUQyCksUIllLF0yIChdLEhUhBAshBQgIsgiyB7IAI7IQIrIBs0sMiAoQRRJLBUEAVDIGSw0pEyJLBU8CTUsTFksNUEsMFlBLCxZQJx5QJwgiSxBUI0sKVCRLCVSBA0sIVIEETwNUUEsXUEwWUEsTUCtLFVBJvEhMvycEMgdnJwYyB2cjQzIHQv+pSwwpE0QpRRVC/u4iQv7fIkL+yyIpNhoBSSJZJAhLARUSRFcCAIgKOEAABogKXEEAaSNEJw9LAVBJvUUBREm+SElFBStMUEm9RQFESYEsJLoXRQRMvEi8SCIoZUQyChNBACyxIihlREsBFSEECyEFCEsESYEoWUsBFVJXAgBLBIgJGQiyCLIHI7IQIrIBsycEMgdnJwYyB2cjQyJC/5Q2GgFJIlkkCEsBFRJEVwIAiAmvRCpLAVC9RQEUREkpE0SICRkWJwVMULAjQzYaAUkiWSQISwEVEkRXAgCICYNEKkxQSb1FAURJvkiBQFMUSwElI7oiTwJUSwElTwK7JwQyB2cnBjIHZ75IJwVMULAjQzYaAUkiWSQISwEVEkRXAgA2GgJJIlmBEQskCEsBFRJEiAkuRCpLAlC9RQFEI4gLOkgjQzYaAUkVJRJEFzYaAklOAkkVgSASRDYaA0kiWSQISwEVEkRXAgBJTgM2GgRJTgRJIlmBEQskCEwVEkRLAhZPAlBLARUWVwYCSwJQTCcLUExQK0xQSb1FAUSBGyO6gQRTRCpMUElOAr1FAUQxAExyCEQSQAAQMQBLBBJAAAhLAzIDEkEAFSNESb5EgUBTFEsDSwNPAogKoUgjQyJC/+g2GgFJIlkkCEsBFRJEVwIANhoCSSJZJQskCEsBFRJEiAhfRCpLAlBJvUUBRL5IgUBTFESICf9II0M2GgFJFSUSRBc2GgJJTgJJFYEgEkQ2GgNJIlkkCEsBFRJEVwIASU4DNhoESU4ESSJZSU4FJQskCEwVEkQxFiMJSU4EOBAjEkRLAhZPAlBLARUWVwYCSwJQTCcLUExQK0xQvUUBRCpMUEm9RQFEvkiBQFMURDEATHIIRBJAABAxAEsFEkAACEsEMgMSQQAgI0RHAjgHIihlRBJMOAgyEEsECxIQREsDSwOICVFII0MiQv/dIkcEKUk2GgFJIlkkCEsBFRJEVwIASTYaAklOAkkiWUlOA4EiCyQITBUSRIgHaEQqTFBJvUUBRL5IgUBTFEQiKGVEMgoTQQAgsSIoZUQyCksEFSEECyEGCEsDC7IIsgeyACOyECKyAbMiRQVLBEsBDEEAiEsBVwIASwWBIguBIlhJVwAISwFXCAFFCEsBVwkIRQxLAVcRCEULSwFXGQhFCkyBiAJTSU4CRQZLBEkVFlcGAkxQJxFPAlBMUCcSTFBJRQm9RQEUREEALDIGSwZLClBLC1AiFkxLAVBLClBMUEwWUCcIIksGVFBLB0y/SwQjCEUFQv91MgdC/9EnBDIHZycGMgdnI0MpNhoBSSJZJAhLARUSRFcCADYaAkcCIllJTgIlCyQITBUSRIgGaUAABogGjUEAgCNEKksDUEm9RQFEvkiBQFMURCIoZUQyChNBAByxIihlREsDFSEECyEGCEsCC7IIsgcjshAisgGzIkUESwNLAQxBADFLAVcCAEsESU4CJQslWEsESRUWVwYCTFAnEU8CUExQJxJMUEm9RQFEvEgjCEUEQv/HJwQyB2cnBjIHZyNDIkL/fTYaAUkVgSASRDYaAklOAkkiWYEgCyQITBUSRDYaA0kVJRJEF04CNhoESRUlEkQXTgKIBahEJwlMUElOA71FAUAAIksDFoACABJMUE8CFlBMUEsBSbxITL8nBDIHZycGMgdnI0NLAkkkJboXSwUSREmBCiW6F08DEkRJvkhJIllLARVLAksCTwJSTwRXAgBQSVcCABWBIAoWVwYCXABPAiJPA1hMUEsBvEi/Qv+rNhoBSRWBIBJEJwlMUEm9RQFEiAUaQAAMSYEKJboXMgYMQQARI0RJvEgnBDIHZycGMgdnI0MiQv/sIicNZUQnBUxQsCNDIik2GgEnByJLAiJZSUUFSwENQQB0SwJXAgBLAUlOAiQLSwFMWU8CIwhJRQRLBksBCUsDFU8CJAtLBExZTwJNUitMUElFBr1FAUEAH0sEvkRLAkkiWUxXAgAnDE8DUE4CI08DiPCBRQJC/52I8QhLAkkiWUxXAgAnDE8DUE4CI08DiPBjRQJC/38nBUsCULAjQyJJKTYaAScHIksCIllLAQ1JRQVBAJVLAlcCAEsEREsBJAtLAUxZSlkkCFhXAgAnD0xQSUUHvUUBQQBSSwW+RCtMUElFBr1FAUEAJEsEvkRLAkkiWUxXAgAnDE8DUE4CI08DiO/xRQJJIwhFAUL/mojwc0sCSSJZTFcCACcMTwNQTgIjTwOI785FAkL/2ojwVUsCSSJZTFcCACcMTwNQTgIjTwOI77BFAkL/vCcFSwJQsCNDIik2GgEnByJLAiJZSwENSUUFQQBiSwJXAgBLBERLASQLSwFMWUpZJAhYVwIAKkxQSUUGvUUBQQAfSwS+REsCSU8CUEwiWSMIFlcGAlwARQJJIwhFAUL/sEsBSYAJAAAAAAAAAAAAUEwiWSMIFlcGAlwARQJC/9knBUsCULAjQyI2GgFJIlkkCEsBFRJEVwIANhoCRwIiWUlOAiULJAhMFRJEIhYnByJJSwQMQQB5SwRXAgBLASULJVhLBkkVFlcGAkxQJxFPAlBMUCcSTFBJRQi9RQFBAB9LBr5ESwJJTwJQTCJZIwgWVwYCXABFAkkjCEUBQv+xIojvKUsDSU4CUEsBUEsBUEsBUEsBUExQJwhQSwJJTwJQTCJZIwgWVwYCXABFAkL/xycFSwJQsCNDIjYaAUcCIllJTgKBIAskCEwVEkQnByJJSwMMQQBoSwNXAgBLAYEgC4EgWCcJTFBJRQa9RQFBACRLBL5ESwJJIllMVwIAJwxPA1BOAiNPA4juIkUCSSMIRQFC/7tLAUkiWUxXAgAjgBYAAgASAAAAAAAAAAAAAAAAAAAAAAAAiO3zRQJC/84nBUsCULAjQyI2GgFHAiJZSU4CgSALJAhMFRJEJwciSUsDDEEAREsDVwIASwGBIAuBIFgnEExQSUUGvUUBQQAdSwS+REkVFlcGAkxQSwJMI4jtMUUCSSMIRQFC/8JLAScHI4jtH0UCQv/rJwVLAlCwI0M2GgFJIlkkCEsBFRJEVwIANhoCSRUlEkQXNhoDSSJZJAhLARUSRFcCADYaBEkVJRJEF0sDFSEEC4HkMksBCEsFTwWIAHVPBBUhBAshBUsBCCEGTwUIgdR6TwMITwWBgGQLgZSgAQgqTwdQvU4GSDIBgbTyCQhLBwhPBRZPBRZQTwYWUE8EFlBPAhZQTwIWUCcIIk8EVFBMFlAnBUxQsCNDNhoBSSJZJQskCEsBFRJEiAhBSCcFTFCwI0OKAgGBFIv/C4v+FQghBAuB9K8CCImKAQEii/8pEkEAAyJMiSqL/1BJjAC9RQFBAAiLAL5EIltMiYv/iAADQv/2igEBIihlRDIKE0EAHrEiKGVEMgqL/xUhBAuB5DIIsgiyB7IAI7IQIrIBs7EiKGVEgfCTCTIBCCInFmVESXIIRLIHTLIISwGyACOyECKyAbaABNhc8YSyGrIYsgCBBrIQIrIBs7cBPklXBABMVwAEJwUSREkVJRJEF0kWJwhQKov/UEy/iTEAIicNZUQSQAAbJxAxAFC9RQFBABInEDEAUL5EIicVZUQSQQACI4kiiTEAIicXZURyCEQSiYoEASlHBYv8Fov9UIv+FRZXBgKL/lBMJwtQTFArTFBJvUUBQAAEIowAiYsGSYERJboXjABJgRsjukkjU4wFJFNMgRwluheMA0EABCKMAImLBoEsJLoXFIwEIowCiwaBLCS6F4sCDUEAGosCgRQLgS4IiwZMgRS6VwAEi/8SQQAxI4wEiwVBACIyBowBiwOLAQ9BABKLAYsDCYsAD0EAByOLBBCMAIkiQv/2MgeMAUL/24sCIwiMAkL/oooBAYv/OAAiKGVEEkEADIv/OCAyChJBAAIjiYv/OBCBBhJBACeL/zgYMggSQQAdi/84GyMSQQAUi/84GUAADYv/IsIaJxoSQQACI4kiiYoBAilHAiuL/1BJvUlPAkhAAAqAAWCL/4wBjACJiwNJgQkluheMAkmBESW6F4wASYEbI7ojU0yBHCW6F4wBQQAwMgZJiwINTIsBCYsADIsDgSwkuhciDScIIosEVCNPBFQkTwNUgQNPAlSL/4wBjACJMgdC/82KAgEqi/5QvkQiW3IITElPAkSxIihlRDIQi/8iWUlOBAuyCLIAsgcjshAisgGzIosCiwEMQQApsYv/VwIAiwJJTgIlC1uyESKyEosASbIUsgCBBLIQIrIBsyMIjAJC/8+L/4wAiYoDASJJKUcCIiqL/VC+RCJbcghEIov+IlmLBw1BAIWL/lcCAIsHgRELgRFYSYwAIltJjAJAACGxIihlRIsAJVuyCLIHiwayACOyECKyAbOLByMIjAdC/70iKGVMjAFEiwAlW4wDIowEi/9BABKLAIGAAVNBAAkiKGVEI4wEjAWxiwRBAASLBbIViwKyEYsDshKLAbIUiwayAIEEshAisgGzQv+ri/6MAImKBQIiRwspRxSL/EEEnzIDi/sWTFCL/RUWVwYCi/1QSYwBTCcLUExQSYwHK0sBUEmMAkm9RQFEJxlPAmciJboXSYwQQQRcixByCEQnCkxnKov9UL5EIltyCEyMBkQijBKL/yJZixINQQGHi/9XAgCLEoEQC4EQWEmMACJbSYwgFicRTFCLAVAnEkxQSYwDSb1FAUS+SElXAAGMC0mBEVuMHUmBCVuMDEmBIVuMFUkjW4wXSYEZW4wTSYEpW4wegYgDU0mMH0EBIjIGjBuLCycOEkEAbosMix0JiwAlW0xLAQ9EiwNJTgK+RIERWwgWgRFMu4sbFosDgSFPAruLIEEAJrEiKGVEiwAlW4sgshGyEosGshSyAIEEshAisgGzixIjCIwSQv85sSIoZUSLACVbsgiLBrIHsgAjshAisgGzQv/ciwuAAQISQQBaix9BAEgyBkmLHgmLExgJixUNQQAXiwBJVwgITCVbiwwORIsDgRFPArtC/3uLDIsdCYsAJVtMSwEPRIsDSU4CvkSBEVsIFoERTLtC/1oyB0mLHgmLExgJQv+1iwuAAQMSQf9Eix9BADAyBowPiw+LFQmLEwqLDAuLHQhJixdJTgMNTE4CTYsAJVtKD0QJFosDgRFPArtC/w8yB4wPQv/NMgeMG0L+24sCgRsjukkjU4wfJFNBAG6I+zpAAGgnCTEGUL1FAUQnCTEGUCQluhcyBg5EJwkxBlCBCiW6FzIGD0QnCTEGUIwFIowRIowSiwWBEiS6F4sSDUEAIIsSgSALgRQIiwVMgSC6MgsSQQADI4wRixIjCIwSQv/TixFEJwkxBlC8SIsHiPwIjAdJIlNESSNTFEQkUxREix9BAhMyBowPIowcIowZMRYjCIwUiweMCIsUMgQMQQALixSI+4VBAM4jjByLHEQriwhQSYwEgRsjuoEDU0EAgYGQAjIAC0mMGDEBDUEAbTEBsSInCmVEMQCL+3IIRIArcmVrZXlpbmcgdG8gcGx1Z2luIGFwcCAmIHJlaW1idXJzaW5nIGNhbGxlcrIFsiBPArIIsgeyACOyECKyAbMnEzEWZ4sEJSO6Jw4SQQAFJwQyB2eL/ov/jAGMAImLGEL/kLEiJwplRIv7cghEgBZyZWtleWluZyB0byBwbHVnaW4gYXBwsgWyIEmyB7IAI7IQIrIBs0L/p4sUOBCBBhNBAA2LCIsUIwiMFIwIQv8LixRJOBiLB0lOAyJbEkRJOBkUREk4GyMNRCPCGhcyCBJEiPrHjAdJI1NLASRTTwKBA1NPAhRETBREQQCji/4iWYsZSU8CDESL/lcCAEwlC1uLFCLCGkmMChWBBBJEK4sHUEmMAkmBGyO6I1NJTgKMH08CgRQLSYwNgS4IgRS6SVcABIwJSYEEW4wOgQxbjBZBAHMyBosWCYsODIwaiwmLChJBAFuLDkEABYsaQABRiw5BABOLH0EAQjIGFosNgToIiwJMTwK7gAGAI4saVEkiU0wjU4waQQAeixpAABkjRCuLB0lOAlCLDxaBHEy7ixkjCIwZQv7/IkL/5DIHQv+7gAFAQv/IMgdC/4oyB4wPQv3qIihlRCcKTGdC/UQxAEL7XooBAiIpRwInByKL/yJZiwUNQQCiIowBi/9XAgCLBSULSiVYjABbSYwCQAB3MgpzAEyMAUSxIicUZUSAA2FhbGVIIlsiKGVEgARMiOrOshqyGosAshqyGIEGshAisgGztD5JVwQASwFXAAQnBRJEFYEQEkRJgQRbiwEITIEMWwgWJxhMUFcCAIsETFBJVwIAFSUKFlcGAlwAjASLBSMIjAVC/2cyCosCcABMjANB/4WLA4wBQv9+iwSL/4wBjACJ", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
function EscrowInfoFromTuple(abiTuple) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.EscrowInfo, APP_SPEC.structs);
}
function PluginInfoFromTuple(abiTuple) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.PluginInfo, APP_SPEC.structs);
}
var AbstractedAccountParamsFactory = class _AbstractedAccountParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "create":
          case "create(string,uint64,address,address,string,uint64,uint64,string,address)void":
            return _AbstractedAccountParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs create ABI call params for the AbstractedAccount smart contract using the create(string,uint64,address,address,string,uint64,uint64,string,address)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params) {
        return {
          ...params,
          method: "create(string,uint64,address,address,string,uint64,uint64,string,address)void",
          args: Array.isArray(params.args) ? params.args : [params.args.version, params.args.akitaDao, params.args.controlledAddress, params.args.admin, params.args.domain, params.args.escrowFactory, params.args.revocationApp, params.args.nickname, params.args.referrer]
        };
      }
    };
  }
  /**
   * Gets available update ABI call param factories
   */
  static get update() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "update":
          case "update(string)void":
            return _AbstractedAccountParamsFactory.update.update(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs update ABI call params for the AbstractedAccount smart contract using the update(string)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      update(params) {
        return {
          ...params,
          method: "update(string)void",
          args: Array.isArray(params.args) ? params.args : [params.args.version]
        };
      }
    };
  }
  /**
     * Constructs a no op call for the register(string)void ABI method
     *
    * Register the abstracted account with the escrow factory.
    This allows apps to correlate the account with the app without needing
    it to be explicitly provided.
  
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
  static register(params) {
    return {
      ...params,
      method: "register(string)void",
      args: Array.isArray(params.args) ? params.args : [params.args.escrow]
    };
  }
  /**
   * Constructs a no op call for the setDomain(string)void ABI method
   *
   * Set the domain associated with the admin account
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setDomain(params) {
    return {
      ...params,
      method: "setDomain(string)void",
      args: Array.isArray(params.args) ? params.args : [params.args.domain]
    };
  }
  /**
   * Constructs a no op call for the setRevocationApp(uint64)void ABI method
   *
   * Changes the revocation app associated with the contract
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setRevocationApp(params) {
    return {
      ...params,
      method: "setRevocationApp(uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.app]
    };
  }
  /**
   * Constructs a no op call for the setAkitaDAO(uint64)void ABI method
   *
   * Changes the Akita DAO associated with the contract
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setAkitaDao(params) {
    return {
      ...params,
      method: "setAkitaDAO(uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.akitaDao]
    };
  }
  /**
   * Constructs a no op call for the setNickname(string)void ABI method
   *
   * Changes the nickname of the wallet
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setNickname(params) {
    return {
      ...params,
      method: "setNickname(string)void",
      args: Array.isArray(params.args) ? params.args : [params.args.nickname]
    };
  }
  /**
   * Constructs a no op call for the setAvatar(uint64)void ABI method
   *
   * Changes the avatar of the wallet
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setAvatar(params) {
    return {
      ...params,
      method: "setAvatar(uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.avatar]
    };
  }
  /**
   * Constructs a no op call for the setBanner(uint64)void ABI method
   *
   * Changes the banner of the wallet
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setBanner(params) {
    return {
      ...params,
      method: "setBanner(uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.banner]
    };
  }
  /**
   * Constructs a no op call for the setBio(string)void ABI method
   *
   * Changes the bio of the wallet
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setBio(params) {
    return {
      ...params,
      method: "setBio(string)void",
      args: Array.isArray(params.args) ? params.args : [params.args.bio]
    };
  }
  /**
   * Constructs a no op call for the arc58_changeAdmin(address)void ABI method
   *
   * Attempt to change the admin for this app. Some implementations MAY not support this.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58ChangeAdmin(params) {
    return {
      ...params,
      method: "arc58_changeAdmin(address)void",
      args: Array.isArray(params.args) ? params.args : [params.args.newAdmin]
    };
  }
  /**
   * Constructs a no op call for the arc58_pluginChangeAdmin(address)void ABI method
   *
   * Attempt to change the admin via plugin.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58PluginChangeAdmin(params) {
    return {
      ...params,
      method: "arc58_pluginChangeAdmin(address)void",
      args: Array.isArray(params.args) ? params.args : [params.args.newAdmin]
    };
  }
  /**
   * Constructs a no op call for the arc58_verifyAuthAddress()void ABI method
   *
   * Verify the abstracted account is rekeyed to this app
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58VerifyAuthAddress(params) {
    return {
      ...params,
      method: "arc58_verifyAuthAddress()void",
      args: Array.isArray(params.args) ? params.args : []
    };
  }
  /**
   * Constructs a no op call for the arc58_rekeyTo(address,bool)void ABI method
   *
   * Rekey the abstracted account to another address. Primarily useful for rekeying to an EOA.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58RekeyTo(params) {
    return {
      ...params,
      method: "arc58_rekeyTo(address,bool)void",
      args: Array.isArray(params.args) ? params.args : [params.args.address, params.args.flash]
    };
  }
  /**
   * Constructs a no op call for the arc58_canCall(uint64,bool,address,string,byte[4])bool ABI method
   *
   * Check whether the plugin can be used
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58CanCall(params) {
    return {
      ...params,
      method: "arc58_canCall(uint64,bool,address,string,byte[4])bool",
      args: Array.isArray(params.args) ? params.args : [params.args.plugin, params.args.global, params.args.address, params.args.escrow, params.args.method]
    };
  }
  /**
   * Constructs a no op call for the arc58_rekeyToPlugin(uint64,bool,string,uint64[],(uint64,uint64)[])void ABI method
   *
   * Temporarily rekey to an approved plugin app address
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58RekeyToPlugin(params) {
    return {
      ...params,
      method: "arc58_rekeyToPlugin(uint64,bool,string,uint64[],(uint64,uint64)[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.plugin, params.args.global, params.args.escrow, params.args.methodOffsets, params.args.fundsRequest]
    };
  }
  /**
   * Constructs a no op call for the arc58_rekeyToNamedPlugin(string,bool,string,uint64[],(uint64,uint64)[])void ABI method
   *
   * Temporarily rekey to a named plugin app address
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58RekeyToNamedPlugin(params) {
    return {
      ...params,
      method: "arc58_rekeyToNamedPlugin(string,bool,string,uint64[],(uint64,uint64)[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.name, params.args.global, params.args.escrow, params.args.methodOffsets, params.args.fundsRequest]
    };
  }
  /**
   * Constructs a no op call for the arc58_addPlugin(uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,bool)void ABI method
   *
   * Add an app to the list of approved plugins
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58AddPlugin(params) {
    return {
      ...params,
      method: "arc58_addPlugin(uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,bool)void",
      args: Array.isArray(params.args) ? params.args : [params.args.plugin, params.args.caller, params.args.escrow, params.args.admin, params.args.delegationType, params.args.lastValid, params.args.cooldown, params.args.methods, params.args.useRounds, params.args.useExecutionKey, params.args.coverFees, params.args.canReclaim, params.args.defaultToEscrow]
    };
  }
  /**
   * Constructs a no op call for the assignDomain(address,string)void ABI method
   *
   * Assign a domain to a passkey
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static assignDomain(params) {
    return {
      ...params,
      method: "assignDomain(address,string)void",
      args: Array.isArray(params.args) ? params.args : [params.args.caller, params.args.domain]
    };
  }
  /**
   * Constructs a no op call for the arc58_removePlugin(uint64,address,string)void ABI method
   *
   * Remove an app from the list of approved plugins
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58RemovePlugin(params) {
    return {
      ...params,
      method: "arc58_removePlugin(uint64,address,string)void",
      args: Array.isArray(params.args) ? params.args : [params.args.plugin, params.args.caller, params.args.escrow]
    };
  }
  /**
   * Constructs a no op call for the arc58_addNamedPlugin(string,uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,bool)void ABI method
   *
   * Add a named plugin
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58AddNamedPlugin(params) {
    return {
      ...params,
      method: "arc58_addNamedPlugin(string,uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,bool)void",
      args: Array.isArray(params.args) ? params.args : [params.args.name, params.args.plugin, params.args.caller, params.args.escrow, params.args.admin, params.args.delegationType, params.args.lastValid, params.args.cooldown, params.args.methods, params.args.useRounds, params.args.useExecutionKey, params.args.coverFees, params.args.canReclaim, params.args.defaultToEscrow]
    };
  }
  /**
   * Constructs a no op call for the arc58_removeNamedPlugin(string)void ABI method
   *
   * Remove a named plugin
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58RemoveNamedPlugin(params) {
    return {
      ...params,
      method: "arc58_removeNamedPlugin(string)void",
      args: Array.isArray(params.args) ? params.args : [params.args.name]
    };
  }
  /**
   * Constructs a no op call for the arc58_newEscrow(string)uint64 ABI method
   *
   * Create a new escrow for the controlled address
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58NewEscrow(params) {
    return {
      ...params,
      method: "arc58_newEscrow(string)uint64",
      args: Array.isArray(params.args) ? params.args : [params.args.escrow]
    };
  }
  /**
   * Constructs a no op call for the arc58_toggleEscrowLock(string)(uint64,bool) ABI method
   *
   * Lock or Unlock an escrow account
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58ToggleEscrowLock(params) {
    return {
      ...params,
      method: "arc58_toggleEscrowLock(string)(uint64,bool)",
      args: Array.isArray(params.args) ? params.args : [params.args.escrow]
    };
  }
  /**
   * Constructs a no op call for the arc58_reclaim(string,(uint64,uint64,bool)[])void ABI method
   *
   * Transfer funds from an escrow back to the controlled address.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58Reclaim(params) {
    return {
      ...params,
      method: "arc58_reclaim(string,(uint64,uint64,bool)[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.escrow, params.args.reclaims]
    };
  }
  /**
     * Constructs a no op call for the arc58_pluginReclaim(uint64,address,string,(uint64,uint64,bool)[])void ABI method
     *
    * Transfer funds from an escrow back to the controlled address via a plugin / allowed caller.
    The plugin must have canReclaim set to true. CloseOut on asset transfers is blocked when the escrow is locked.
  
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
  static arc58PluginReclaim(params) {
    return {
      ...params,
      method: "arc58_pluginReclaim(uint64,address,string,(uint64,uint64,bool)[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.plugin, params.args.caller, params.args.escrow, params.args.reclaims]
    };
  }
  /**
   * Constructs a no op call for the arc58_optInEscrow(string,uint64[])void ABI method
   *
   * Opt-in an escrow account to assets
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58OptInEscrow(params) {
    return {
      ...params,
      method: "arc58_optInEscrow(string,uint64[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.escrow, params.args.assets]
    };
  }
  /**
   * Constructs a no op call for the arc58_pluginOptInEscrow(uint64,address,string,uint64[],pay)void ABI method
   *
   * Opt-in an escrow account to assets via a plugin / allowed caller
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58PluginOptInEscrow(params) {
    return {
      ...params,
      method: "arc58_pluginOptInEscrow(uint64,address,string,uint64[],pay)void",
      args: Array.isArray(params.args) ? params.args : [params.args.plugin, params.args.caller, params.args.escrow, params.args.assets, params.args.mbrPayment]
    };
  }
  /**
   * Constructs a no op call for the arc58_addAllowances(string,(uint64,uint8,uint64,uint64,uint64,bool)[])void ABI method
   *
   * Add an allowance for an escrow account
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58AddAllowances(params) {
    return {
      ...params,
      method: "arc58_addAllowances(string,(uint64,uint8,uint64,uint64,uint64,bool)[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.escrow, params.args.allowances]
    };
  }
  /**
   * Constructs a no op call for the arc58_removeAllowances(string,uint64[])void ABI method
   *
   * Remove an allowances for an escrow account
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58RemoveAllowances(params) {
    return {
      ...params,
      method: "arc58_removeAllowances(string,uint64[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.escrow, params.args.assets]
    };
  }
  /**
   * Constructs a no op call for the arc58_addExecutionKey(byte[32],byte[32][],uint64,uint64)void ABI method
   *
   * Add or extend an execution key for pre-authorized plugin usage
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58AddExecutionKey(params) {
    return {
      ...params,
      method: "arc58_addExecutionKey(byte[32],byte[32][],uint64,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.lease, params.args.groups, params.args.firstValid, params.args.lastValid]
    };
  }
  /**
   * Constructs a no op call for the arc58_removeExecutionKey(byte[32])void ABI method
   *
   * Remove an execution key. Can be called by admin at any time, or by anyone after the key has expired.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58RemoveExecutionKey(params) {
    return {
      ...params,
      method: "arc58_removeExecutionKey(byte[32])void",
      args: Array.isArray(params.args) ? params.args : [params.args.lease]
    };
  }
  /**
     * Constructs a no op call for the arc58_getAdmin()address ABI method
     *
    * Get the admin of this app. This method SHOULD always be used rather than reading directly from state
    because different implementations may have different ways of determining the admin.
  
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
  static arc58GetAdmin(params) {
    return {
      ...params,
      method: "arc58_getAdmin()address",
      args: Array.isArray(params.args) ? params.args : []
    };
  }
  /**
   * Constructs a no op call for the arc58_getPlugins((uint64,address,string)[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[] ABI method
   *
   * Get plugin info for a list of plugin keys
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58GetPlugins(params) {
    return {
      ...params,
      method: "arc58_getPlugins((uint64,address,string)[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[]",
      args: Array.isArray(params.args) ? params.args : [params.args.keys]
    };
  }
  /**
   * Constructs a no op call for the arc58_getNamedPlugins(string[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[] ABI method
   *
   * Get plugin info for a list of named plugins
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58GetNamedPlugins(params) {
    return {
      ...params,
      method: "arc58_getNamedPlugins(string[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[]",
      args: Array.isArray(params.args) ? params.args : [params.args.names]
    };
  }
  /**
   * Constructs a no op call for the arc58_getEscrows(string[])(uint64,bool)[] ABI method
   *
   * Get escrow info for a list of escrow names
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58GetEscrows(params) {
    return {
      ...params,
      method: "arc58_getEscrows(string[])(uint64,bool)[]",
      args: Array.isArray(params.args) ? params.args : [params.args.escrows]
    };
  }
  /**
   * Constructs a no op call for the arc58_getAllowances(string,uint64[])(uint8,uint64,uint64,uint64,uint64,uint64,uint64,bool)[] ABI method
   *
   * Get allowance info for a list of assets on a given escrow
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58GetAllowances(params) {
    return {
      ...params,
      method: "arc58_getAllowances(string,uint64[])(uint8,uint64,uint64,uint64,uint64,uint64,uint64,bool)[]",
      args: Array.isArray(params.args) ? params.args : [params.args.escrow, params.args.assets]
    };
  }
  /**
   * Constructs a no op call for the arc58_getExecutions(byte[32][])(byte[32][],uint64,uint64)[] ABI method
   *
   * Get execution key info for a list of leases
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58GetExecutions(params) {
    return {
      ...params,
      method: "arc58_getExecutions(byte[32][])(byte[32][],uint64,uint64)[]",
      args: Array.isArray(params.args) ? params.args : [params.args.leases]
    };
  }
  /**
   * Constructs a no op call for the arc58_getDomainKeys(address[])string[] ABI method
   *
   * Get domain key assignments for a list of addresses
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static arc58GetDomainKeys(params) {
    return {
      ...params,
      method: "arc58_getDomainKeys(address[])string[]",
      args: Array.isArray(params.args) ? params.args : [params.args.addresses]
    };
  }
  /**
   * Constructs a no op call for the mbr(string,uint64,string,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64) ABI method
   *
   * Calculate the minimum balance requirements for various box operations
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mbr(params) {
    return {
      ...params,
      method: "mbr(string,uint64,string,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64)",
      args: Array.isArray(params.args) ? params.args : [params.args.escrow, params.args.methodCount, params.args.plugin, params.args.groups]
    };
  }
  /**
   * Constructs a no op call for the balance(uint64[])uint64[] ABI method
   *
   * Get the balance of a set of assets in the account, including staked amounts
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static balance(params) {
    return {
      ...params,
      method: "balance(uint64[])uint64[]",
      args: Array.isArray(params.args) ? params.args : [params.args.assets]
    };
  }
};
var AbstractedAccountFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `AbstractedAccountFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory({
      ...params,
      appSpec: APP_SPEC
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new AbstractedAccountClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new AbstractedAccountClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the AbstractedAccount smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    var _a, _b;
    const result = await this.appFactory.deploy({
      ...params,
      createParams: ((_a = params.createParams) == null ? void 0 : _a.method) ? AbstractedAccountParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams : void 0,
      updateParams: ((_b = params.updateParams) == null ? void 0 : _b.method) ? AbstractedAccountParamsFactory.update._resolveByMethod(params.updateParams) : params.updateParams ? params.updateParams : void 0
    });
    return { result: result.result, appClient: new AbstractedAccountClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
             * Creates a new instance of the AbstractedAccount smart contract using the create(string,uint64,address,address,string,uint64,uint64,string,address)void ABI method.
             *
            * Create an abstracted account application.
            This is not part of ARC58 and implementation specific.
      
             *
             * @param params The params for the smart contract call
             * @returns The create params
             */
      create: (params) => {
        return this.appFactory.params.create(AbstractedAccountParamsFactory.create.create(params));
      }
    },
    /**
     * Gets available deployUpdate methods
     */
    deployUpdate: {
      /**
       * Updates an existing instance of the AbstractedAccount smart contract using the update(string)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The deployUpdate params
       */
      update: (params) => {
        return this.appFactory.params.deployUpdate(AbstractedAccountParamsFactory.update.update(params));
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
             * Creates a new instance of the AbstractedAccount smart contract using the create(string,uint64,address,address,string,uint64,uint64,string,address)void ABI method.
             *
            * Create an abstracted account application.
            This is not part of ARC58 and implementation specific.
      
             *
             * @param params The params for the smart contract call
             * @returns The create transaction
             */
      create: (params) => {
        return this.appFactory.createTransaction.create(AbstractedAccountParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
             * Creates a new instance of the AbstractedAccount smart contract using an ABI method call using the create(string,uint64,address,address,string,uint64,uint64,string,address)void ABI method.
             *
            * Create an abstracted account application.
            This is not part of ARC58 and implementation specific.
      
             *
             * @param params The params for the smart contract call
             * @returns The create result
             */
      create: async (params) => {
        const result = await this.appFactory.send.create(AbstractedAccountParamsFactory.create.create(params));
        return { result: { ...result.result, return: result.result.return }, appClient: new AbstractedAccountClient(result.appClient) };
      }
    }
  };
};
var AbstractedAccountClient = class _AbstractedAccountClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient ? appClientOrParams : new _AppClient({
      ...appClientOrParams,
      appSpec: APP_SPEC
    });
  }
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue(method, returnValue) {
    return returnValue !== void 0 ? getArc56ReturnValue(returnValue, this.appClient.getABIMethod(method), APP_SPEC.structs) : void 0;
  }
  /**
   * Returns a new `AbstractedAccountClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _AbstractedAccountClient(await _AppClient.fromCreatorAndName({ ...params, appSpec: APP_SPEC }));
  }
  /**
   * Returns an `AbstractedAccountClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _AbstractedAccountClient(await _AppClient.fromNetwork({ ...params, appSpec: APP_SPEC }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the AbstractedAccount smart contract using the `update(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update params
       */
      update: (params) => {
        return this.appClient.params.update(AbstractedAccountParamsFactory.update.update(params));
      }
    },
    /**
     * Makes a clear_state call to an existing instance of the AbstractedAccount smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
         * Makes a call to the AbstractedAccount smart contract using the `register(string)void` ABI method.
         *
        * Register the abstracted account with the escrow factory.
        This allows apps to correlate the account with the app without needing
        it to be explicitly provided.
    
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
    register: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.register(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setDomain(string)void` ABI method.
     *
     * Set the domain associated with the admin account
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setDomain: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.setDomain(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setRevocationApp(uint64)void` ABI method.
     *
     * Changes the revocation app associated with the contract
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setRevocationApp: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.setRevocationApp(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setAkitaDAO(uint64)void` ABI method.
     *
     * Changes the Akita DAO associated with the contract
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setAkitaDao: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.setAkitaDao(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setNickname(string)void` ABI method.
     *
     * Changes the nickname of the wallet
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setNickname: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.setNickname(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setAvatar(uint64)void` ABI method.
     *
     * Changes the avatar of the wallet
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setAvatar: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.setAvatar(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setBanner(uint64)void` ABI method.
     *
     * Changes the banner of the wallet
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setBanner: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.setBanner(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setBio(string)void` ABI method.
     *
     * Changes the bio of the wallet
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setBio: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.setBio(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_changeAdmin(address)void` ABI method.
     *
     * Attempt to change the admin for this app. Some implementations MAY not support this.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    arc58ChangeAdmin: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58ChangeAdmin(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_pluginChangeAdmin(address)void` ABI method.
     *
     * Attempt to change the admin via plugin.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    arc58PluginChangeAdmin: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58PluginChangeAdmin(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_verifyAuthAddress()void` ABI method.
     *
     * Verify the abstracted account is rekeyed to this app
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    arc58VerifyAuthAddress: (params = { args: [] }) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58VerifyAuthAddress(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_rekeyTo(address,bool)void` ABI method.
     *
     * Rekey the abstracted account to another address. Primarily useful for rekeying to an EOA.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    arc58RekeyTo: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58RekeyTo(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_canCall(uint64,bool,address,string,byte[4])bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Check whether the plugin can be used
     *
     * @param params The params for the smart contract call
     * @returns The call params: Whether the plugin can be called with these parameters
     */
    arc58CanCall: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58CanCall(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_rekeyToPlugin(uint64,bool,string,uint64[],(uint64,uint64)[])void` ABI method.
     *
     * Temporarily rekey to an approved plugin app address
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    arc58RekeyToPlugin: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58RekeyToPlugin(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_rekeyToNamedPlugin(string,bool,string,uint64[],(uint64,uint64)[])void` ABI method.
     *
     * Temporarily rekey to a named plugin app address
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    arc58RekeyToNamedPlugin: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58RekeyToNamedPlugin(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_addPlugin(uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,bool)void` ABI method.
     *
     * Add an app to the list of approved plugins
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    arc58AddPlugin: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58AddPlugin(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `assignDomain(address,string)void` ABI method.
     *
     * Assign a domain to a passkey
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    assignDomain: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.assignDomain(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_removePlugin(uint64,address,string)void` ABI method.
     *
     * Remove an app from the list of approved plugins
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    arc58RemovePlugin: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58RemovePlugin(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_addNamedPlugin(string,uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,bool)void` ABI method.
     *
     * Add a named plugin
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    arc58AddNamedPlugin: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58AddNamedPlugin(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_removeNamedPlugin(string)void` ABI method.
     *
     * Remove a named plugin
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    arc58RemoveNamedPlugin: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58RemoveNamedPlugin(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_newEscrow(string)uint64` ABI method.
     *
     * Create a new escrow for the controlled address
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    arc58NewEscrow: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58NewEscrow(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_toggleEscrowLock(string)(uint64,bool)` ABI method.
     *
     * Lock or Unlock an escrow account
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    arc58ToggleEscrowLock: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58ToggleEscrowLock(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_reclaim(string,(uint64,uint64,bool)[])void` ABI method.
     *
     * Transfer funds from an escrow back to the controlled address.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    arc58Reclaim: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58Reclaim(params));
    },
    /**
         * Makes a call to the AbstractedAccount smart contract using the `arc58_pluginReclaim(uint64,address,string,(uint64,uint64,bool)[])void` ABI method.
         *
        * Transfer funds from an escrow back to the controlled address via a plugin / allowed caller.
        The plugin must have canReclaim set to true. CloseOut on asset transfers is blocked when the escrow is locked.
    
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
    arc58PluginReclaim: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58PluginReclaim(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_optInEscrow(string,uint64[])void` ABI method.
     *
     * Opt-in an escrow account to assets
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    arc58OptInEscrow: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58OptInEscrow(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_pluginOptInEscrow(uint64,address,string,uint64[],pay)void` ABI method.
     *
     * Opt-in an escrow account to assets via a plugin / allowed caller
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    arc58PluginOptInEscrow: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58PluginOptInEscrow(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_addAllowances(string,(uint64,uint8,uint64,uint64,uint64,bool)[])void` ABI method.
     *
     * Add an allowance for an escrow account
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    arc58AddAllowances: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58AddAllowances(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_removeAllowances(string,uint64[])void` ABI method.
     *
     * Remove an allowances for an escrow account
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    arc58RemoveAllowances: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58RemoveAllowances(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_addExecutionKey(byte[32],byte[32][],uint64,uint64)void` ABI method.
     *
     * Add or extend an execution key for pre-authorized plugin usage
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    arc58AddExecutionKey: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58AddExecutionKey(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_removeExecutionKey(byte[32])void` ABI method.
     *
     * Remove an execution key. Can be called by admin at any time, or by anyone after the key has expired.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    arc58RemoveExecutionKey: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58RemoveExecutionKey(params));
    },
    /**
         * Makes a call to the AbstractedAccount smart contract using the `arc58_getAdmin()address` ABI method.
         * 
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
        * Get the admin of this app. This method SHOULD always be used rather than reading directly from state
        because different implementations may have different ways of determining the admin.
    
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
    arc58GetAdmin: (params = { args: [] }) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58GetAdmin(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_getPlugins((uint64,address,string)[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get plugin info for a list of plugin keys
     *
     * @param params The params for the smart contract call
     * @returns The call params: The plugin info for each key, or empty plugin info if the key does not exist
     */
    arc58GetPlugins: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58GetPlugins(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_getNamedPlugins(string[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get plugin info for a list of named plugins
     *
     * @param params The params for the smart contract call
     * @returns The call params: The plugin info for each name, or empty plugin info if the name does not exist
     */
    arc58GetNamedPlugins: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58GetNamedPlugins(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_getEscrows(string[])(uint64,bool)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get escrow info for a list of escrow names
     *
     * @param params The params for the smart contract call
     * @returns The call params: The escrow info for each name, or empty escrow info if the name does not exist
     */
    arc58GetEscrows: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58GetEscrows(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_getAllowances(string,uint64[])(uint8,uint64,uint64,uint64,uint64,uint64,uint64,bool)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get allowance info for a list of assets on a given escrow
     *
     * @param params The params for the smart contract call
     * @returns The call params: The allowance info for each asset, or empty allowance info if no allowance exists
     */
    arc58GetAllowances: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58GetAllowances(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_getExecutions(byte[32][])(byte[32][],uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get execution key info for a list of leases
     *
     * @param params The params for the smart contract call
     * @returns The call params: The execution info for each lease, or empty execution info if the lease does not exist
     */
    arc58GetExecutions: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58GetExecutions(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_getDomainKeys(address[])string[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get domain key assignments for a list of addresses
     *
     * @param params The params for the smart contract call
     * @returns The call params: The domain string for each address, or empty string if no domain is assigned
     */
    arc58GetDomainKeys: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.arc58GetDomainKeys(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `mbr(string,uint64,string,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Calculate the minimum balance requirements for various box operations
     *
     * @param params The params for the smart contract call
     * @returns The call params: The MBR costs for plugins, named plugins, escrows, allowances, domain keys, executions, and new escrow creation
     */
    mbr: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.mbr(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `balance(uint64[])uint64[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get the balance of a set of assets in the account, including staked amounts
     *
     * @param params The params for the smart contract call
     * @returns The call params: The balance for each asset including any staked amounts
     */
    balance: (params) => {
      return this.appClient.params.call(AbstractedAccountParamsFactory.balance(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the AbstractedAccount smart contract using the `update(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update transaction
       */
      update: (params) => {
        return this.appClient.createTransaction.update(AbstractedAccountParamsFactory.update.update(params));
      }
    },
    /**
     * Makes a clear_state call to an existing instance of the AbstractedAccount smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
         * Makes a call to the AbstractedAccount smart contract using the `register(string)void` ABI method.
         *
        * Register the abstracted account with the escrow factory.
        This allows apps to correlate the account with the app without needing
        it to be explicitly provided.
    
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
    register: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.register(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setDomain(string)void` ABI method.
     *
     * Set the domain associated with the admin account
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setDomain: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.setDomain(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setRevocationApp(uint64)void` ABI method.
     *
     * Changes the revocation app associated with the contract
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setRevocationApp: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.setRevocationApp(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setAkitaDAO(uint64)void` ABI method.
     *
     * Changes the Akita DAO associated with the contract
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setAkitaDao: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.setAkitaDao(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setNickname(string)void` ABI method.
     *
     * Changes the nickname of the wallet
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setNickname: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.setNickname(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setAvatar(uint64)void` ABI method.
     *
     * Changes the avatar of the wallet
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setAvatar: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.setAvatar(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setBanner(uint64)void` ABI method.
     *
     * Changes the banner of the wallet
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setBanner: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.setBanner(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setBio(string)void` ABI method.
     *
     * Changes the bio of the wallet
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setBio: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.setBio(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_changeAdmin(address)void` ABI method.
     *
     * Attempt to change the admin for this app. Some implementations MAY not support this.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    arc58ChangeAdmin: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58ChangeAdmin(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_pluginChangeAdmin(address)void` ABI method.
     *
     * Attempt to change the admin via plugin.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    arc58PluginChangeAdmin: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58PluginChangeAdmin(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_verifyAuthAddress()void` ABI method.
     *
     * Verify the abstracted account is rekeyed to this app
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    arc58VerifyAuthAddress: (params = { args: [] }) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58VerifyAuthAddress(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_rekeyTo(address,bool)void` ABI method.
     *
     * Rekey the abstracted account to another address. Primarily useful for rekeying to an EOA.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    arc58RekeyTo: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58RekeyTo(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_canCall(uint64,bool,address,string,byte[4])bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Check whether the plugin can be used
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: Whether the plugin can be called with these parameters
     */
    arc58CanCall: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58CanCall(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_rekeyToPlugin(uint64,bool,string,uint64[],(uint64,uint64)[])void` ABI method.
     *
     * Temporarily rekey to an approved plugin app address
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    arc58RekeyToPlugin: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58RekeyToPlugin(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_rekeyToNamedPlugin(string,bool,string,uint64[],(uint64,uint64)[])void` ABI method.
     *
     * Temporarily rekey to a named plugin app address
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    arc58RekeyToNamedPlugin: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58RekeyToNamedPlugin(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_addPlugin(uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,bool)void` ABI method.
     *
     * Add an app to the list of approved plugins
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    arc58AddPlugin: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58AddPlugin(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `assignDomain(address,string)void` ABI method.
     *
     * Assign a domain to a passkey
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    assignDomain: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.assignDomain(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_removePlugin(uint64,address,string)void` ABI method.
     *
     * Remove an app from the list of approved plugins
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    arc58RemovePlugin: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58RemovePlugin(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_addNamedPlugin(string,uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,bool)void` ABI method.
     *
     * Add a named plugin
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    arc58AddNamedPlugin: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58AddNamedPlugin(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_removeNamedPlugin(string)void` ABI method.
     *
     * Remove a named plugin
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    arc58RemoveNamedPlugin: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58RemoveNamedPlugin(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_newEscrow(string)uint64` ABI method.
     *
     * Create a new escrow for the controlled address
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    arc58NewEscrow: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58NewEscrow(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_toggleEscrowLock(string)(uint64,bool)` ABI method.
     *
     * Lock or Unlock an escrow account
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    arc58ToggleEscrowLock: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58ToggleEscrowLock(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_reclaim(string,(uint64,uint64,bool)[])void` ABI method.
     *
     * Transfer funds from an escrow back to the controlled address.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    arc58Reclaim: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58Reclaim(params));
    },
    /**
         * Makes a call to the AbstractedAccount smart contract using the `arc58_pluginReclaim(uint64,address,string,(uint64,uint64,bool)[])void` ABI method.
         *
        * Transfer funds from an escrow back to the controlled address via a plugin / allowed caller.
        The plugin must have canReclaim set to true. CloseOut on asset transfers is blocked when the escrow is locked.
    
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
    arc58PluginReclaim: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58PluginReclaim(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_optInEscrow(string,uint64[])void` ABI method.
     *
     * Opt-in an escrow account to assets
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    arc58OptInEscrow: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58OptInEscrow(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_pluginOptInEscrow(uint64,address,string,uint64[],pay)void` ABI method.
     *
     * Opt-in an escrow account to assets via a plugin / allowed caller
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    arc58PluginOptInEscrow: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58PluginOptInEscrow(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_addAllowances(string,(uint64,uint8,uint64,uint64,uint64,bool)[])void` ABI method.
     *
     * Add an allowance for an escrow account
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    arc58AddAllowances: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58AddAllowances(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_removeAllowances(string,uint64[])void` ABI method.
     *
     * Remove an allowances for an escrow account
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    arc58RemoveAllowances: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58RemoveAllowances(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_addExecutionKey(byte[32],byte[32][],uint64,uint64)void` ABI method.
     *
     * Add or extend an execution key for pre-authorized plugin usage
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    arc58AddExecutionKey: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58AddExecutionKey(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_removeExecutionKey(byte[32])void` ABI method.
     *
     * Remove an execution key. Can be called by admin at any time, or by anyone after the key has expired.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    arc58RemoveExecutionKey: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58RemoveExecutionKey(params));
    },
    /**
         * Makes a call to the AbstractedAccount smart contract using the `arc58_getAdmin()address` ABI method.
         * 
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
        * Get the admin of this app. This method SHOULD always be used rather than reading directly from state
        because different implementations may have different ways of determining the admin.
    
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
    arc58GetAdmin: (params = { args: [] }) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58GetAdmin(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_getPlugins((uint64,address,string)[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get plugin info for a list of plugin keys
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: The plugin info for each key, or empty plugin info if the key does not exist
     */
    arc58GetPlugins: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58GetPlugins(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_getNamedPlugins(string[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get plugin info for a list of named plugins
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: The plugin info for each name, or empty plugin info if the name does not exist
     */
    arc58GetNamedPlugins: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58GetNamedPlugins(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_getEscrows(string[])(uint64,bool)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get escrow info for a list of escrow names
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: The escrow info for each name, or empty escrow info if the name does not exist
     */
    arc58GetEscrows: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58GetEscrows(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_getAllowances(string,uint64[])(uint8,uint64,uint64,uint64,uint64,uint64,uint64,bool)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get allowance info for a list of assets on a given escrow
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: The allowance info for each asset, or empty allowance info if no allowance exists
     */
    arc58GetAllowances: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58GetAllowances(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_getExecutions(byte[32][])(byte[32][],uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get execution key info for a list of leases
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: The execution info for each lease, or empty execution info if the lease does not exist
     */
    arc58GetExecutions: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58GetExecutions(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_getDomainKeys(address[])string[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get domain key assignments for a list of addresses
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: The domain string for each address, or empty string if no domain is assigned
     */
    arc58GetDomainKeys: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.arc58GetDomainKeys(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `mbr(string,uint64,string,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Calculate the minimum balance requirements for various box operations
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: The MBR costs for plugins, named plugins, escrows, allowances, domain keys, executions, and new escrow creation
     */
    mbr: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.mbr(params));
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `balance(uint64[])uint64[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get the balance of a set of assets in the account, including staked amounts
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: The balance for each asset including any staked amounts
     */
    balance: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountParamsFactory.balance(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the AbstractedAccount smart contract using the `update(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update result
       */
      update: async (params) => {
        const result = await this.appClient.send.update(AbstractedAccountParamsFactory.update.update(params));
        return { ...result, return: result.return };
      }
    },
    /**
     * Makes a clear_state call to an existing instance of the AbstractedAccount smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
         * Makes a call to the AbstractedAccount smart contract using the `register(string)void` ABI method.
         *
        * Register the abstracted account with the escrow factory.
        This allows apps to correlate the account with the app without needing
        it to be explicitly provided.
    
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
    register: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.register(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setDomain(string)void` ABI method.
     *
     * Set the domain associated with the admin account
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setDomain: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.setDomain(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setRevocationApp(uint64)void` ABI method.
     *
     * Changes the revocation app associated with the contract
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setRevocationApp: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.setRevocationApp(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setAkitaDAO(uint64)void` ABI method.
     *
     * Changes the Akita DAO associated with the contract
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setAkitaDao: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.setAkitaDao(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setNickname(string)void` ABI method.
     *
     * Changes the nickname of the wallet
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setNickname: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.setNickname(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setAvatar(uint64)void` ABI method.
     *
     * Changes the avatar of the wallet
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setAvatar: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.setAvatar(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setBanner(uint64)void` ABI method.
     *
     * Changes the banner of the wallet
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setBanner: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.setBanner(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `setBio(string)void` ABI method.
     *
     * Changes the bio of the wallet
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setBio: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.setBio(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_changeAdmin(address)void` ABI method.
     *
     * Attempt to change the admin for this app. Some implementations MAY not support this.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    arc58ChangeAdmin: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58ChangeAdmin(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_pluginChangeAdmin(address)void` ABI method.
     *
     * Attempt to change the admin via plugin.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    arc58PluginChangeAdmin: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58PluginChangeAdmin(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_verifyAuthAddress()void` ABI method.
     *
     * Verify the abstracted account is rekeyed to this app
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    arc58VerifyAuthAddress: async (params = { args: [] }) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58VerifyAuthAddress(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_rekeyTo(address,bool)void` ABI method.
     *
     * Rekey the abstracted account to another address. Primarily useful for rekeying to an EOA.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    arc58RekeyTo: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58RekeyTo(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_canCall(uint64,bool,address,string,byte[4])bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Check whether the plugin can be used
     *
     * @param params The params for the smart contract call
     * @returns The call result: Whether the plugin can be called with these parameters
     */
    arc58CanCall: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58CanCall(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_rekeyToPlugin(uint64,bool,string,uint64[],(uint64,uint64)[])void` ABI method.
     *
     * Temporarily rekey to an approved plugin app address
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    arc58RekeyToPlugin: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58RekeyToPlugin(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_rekeyToNamedPlugin(string,bool,string,uint64[],(uint64,uint64)[])void` ABI method.
     *
     * Temporarily rekey to a named plugin app address
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    arc58RekeyToNamedPlugin: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58RekeyToNamedPlugin(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_addPlugin(uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,bool)void` ABI method.
     *
     * Add an app to the list of approved plugins
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    arc58AddPlugin: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58AddPlugin(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `assignDomain(address,string)void` ABI method.
     *
     * Assign a domain to a passkey
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    assignDomain: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.assignDomain(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_removePlugin(uint64,address,string)void` ABI method.
     *
     * Remove an app from the list of approved plugins
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    arc58RemovePlugin: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58RemovePlugin(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_addNamedPlugin(string,uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,bool)void` ABI method.
     *
     * Add a named plugin
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    arc58AddNamedPlugin: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58AddNamedPlugin(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_removeNamedPlugin(string)void` ABI method.
     *
     * Remove a named plugin
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    arc58RemoveNamedPlugin: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58RemoveNamedPlugin(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_newEscrow(string)uint64` ABI method.
     *
     * Create a new escrow for the controlled address
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    arc58NewEscrow: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58NewEscrow(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_toggleEscrowLock(string)(uint64,bool)` ABI method.
     *
     * Lock or Unlock an escrow account
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    arc58ToggleEscrowLock: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58ToggleEscrowLock(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_reclaim(string,(uint64,uint64,bool)[])void` ABI method.
     *
     * Transfer funds from an escrow back to the controlled address.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    arc58Reclaim: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58Reclaim(params));
      return { ...result, return: result.return };
    },
    /**
         * Makes a call to the AbstractedAccount smart contract using the `arc58_pluginReclaim(uint64,address,string,(uint64,uint64,bool)[])void` ABI method.
         *
        * Transfer funds from an escrow back to the controlled address via a plugin / allowed caller.
        The plugin must have canReclaim set to true. CloseOut on asset transfers is blocked when the escrow is locked.
    
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
    arc58PluginReclaim: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58PluginReclaim(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_optInEscrow(string,uint64[])void` ABI method.
     *
     * Opt-in an escrow account to assets
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    arc58OptInEscrow: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58OptInEscrow(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_pluginOptInEscrow(uint64,address,string,uint64[],pay)void` ABI method.
     *
     * Opt-in an escrow account to assets via a plugin / allowed caller
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    arc58PluginOptInEscrow: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58PluginOptInEscrow(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_addAllowances(string,(uint64,uint8,uint64,uint64,uint64,bool)[])void` ABI method.
     *
     * Add an allowance for an escrow account
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    arc58AddAllowances: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58AddAllowances(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_removeAllowances(string,uint64[])void` ABI method.
     *
     * Remove an allowances for an escrow account
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    arc58RemoveAllowances: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58RemoveAllowances(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_addExecutionKey(byte[32],byte[32][],uint64,uint64)void` ABI method.
     *
     * Add or extend an execution key for pre-authorized plugin usage
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    arc58AddExecutionKey: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58AddExecutionKey(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_removeExecutionKey(byte[32])void` ABI method.
     *
     * Remove an execution key. Can be called by admin at any time, or by anyone after the key has expired.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    arc58RemoveExecutionKey: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58RemoveExecutionKey(params));
      return { ...result, return: result.return };
    },
    /**
         * Makes a call to the AbstractedAccount smart contract using the `arc58_getAdmin()address` ABI method.
         * 
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
        * Get the admin of this app. This method SHOULD always be used rather than reading directly from state
        because different implementations may have different ways of determining the admin.
    
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
    arc58GetAdmin: async (params = { args: [] }) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58GetAdmin(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_getPlugins((uint64,address,string)[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get plugin info for a list of plugin keys
     *
     * @param params The params for the smart contract call
     * @returns The call result: The plugin info for each key, or empty plugin info if the key does not exist
     */
    arc58GetPlugins: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58GetPlugins(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_getNamedPlugins(string[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get plugin info for a list of named plugins
     *
     * @param params The params for the smart contract call
     * @returns The call result: The plugin info for each name, or empty plugin info if the name does not exist
     */
    arc58GetNamedPlugins: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58GetNamedPlugins(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_getEscrows(string[])(uint64,bool)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get escrow info for a list of escrow names
     *
     * @param params The params for the smart contract call
     * @returns The call result: The escrow info for each name, or empty escrow info if the name does not exist
     */
    arc58GetEscrows: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58GetEscrows(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_getAllowances(string,uint64[])(uint8,uint64,uint64,uint64,uint64,uint64,uint64,bool)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get allowance info for a list of assets on a given escrow
     *
     * @param params The params for the smart contract call
     * @returns The call result: The allowance info for each asset, or empty allowance info if no allowance exists
     */
    arc58GetAllowances: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58GetAllowances(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_getExecutions(byte[32][])(byte[32][],uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get execution key info for a list of leases
     *
     * @param params The params for the smart contract call
     * @returns The call result: The execution info for each lease, or empty execution info if the lease does not exist
     */
    arc58GetExecutions: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58GetExecutions(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `arc58_getDomainKeys(address[])string[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get domain key assignments for a list of addresses
     *
     * @param params The params for the smart contract call
     * @returns The call result: The domain string for each address, or empty string if no domain is assigned
     */
    arc58GetDomainKeys: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58GetDomainKeys(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `mbr(string,uint64,string,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Calculate the minimum balance requirements for various box operations
     *
     * @param params The params for the smart contract call
     * @returns The call result: The MBR costs for plugins, named plugins, escrows, allowances, domain keys, executions, and new escrow creation
     */
    mbr: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.mbr(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccount smart contract using the `balance(uint64[])uint64[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get the balance of a set of assets in the account, including staked amounts
     *
     * @param params The params for the smart contract call
     * @returns The call result: The balance for each asset including any staked amounts
     */
    balance: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountParamsFactory.balance(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _AbstractedAccountClient(this.appClient.clone(params));
  }
  /**
   * Makes a readonly (simulated) call to the AbstractedAccount smart contract using the `arc58_canCall(uint64,bool,address,string,byte[4])bool` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Check whether the plugin can be used
   *
   * @param params The params for the smart contract call
   * @returns The call result: Whether the plugin can be called with these parameters
   */
  async arc58CanCall(params) {
    const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58CanCall(params));
    return result.return;
  }
  /**
     * Makes a readonly (simulated) call to the AbstractedAccount smart contract using the `arc58_getAdmin()address` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Get the admin of this app. This method SHOULD always be used rather than reading directly from state
    because different implementations may have different ways of determining the admin.
  
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
  async arc58GetAdmin(params = { args: [] }) {
    const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58GetAdmin(params));
    return result.return;
  }
  /**
   * Makes a readonly (simulated) call to the AbstractedAccount smart contract using the `arc58_getPlugins((uint64,address,string)[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[]` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Get plugin info for a list of plugin keys
   *
   * @param params The params for the smart contract call
   * @returns The call result: The plugin info for each key, or empty plugin info if the key does not exist
   */
  async arc58GetPlugins(params) {
    const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58GetPlugins(params));
    return result.return;
  }
  /**
   * Makes a readonly (simulated) call to the AbstractedAccount smart contract using the `arc58_getNamedPlugins(string[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[]` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Get plugin info for a list of named plugins
   *
   * @param params The params for the smart contract call
   * @returns The call result: The plugin info for each name, or empty plugin info if the name does not exist
   */
  async arc58GetNamedPlugins(params) {
    const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58GetNamedPlugins(params));
    return result.return;
  }
  /**
   * Makes a readonly (simulated) call to the AbstractedAccount smart contract using the `arc58_getEscrows(string[])(uint64,bool)[]` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Get escrow info for a list of escrow names
   *
   * @param params The params for the smart contract call
   * @returns The call result: The escrow info for each name, or empty escrow info if the name does not exist
   */
  async arc58GetEscrows(params) {
    const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58GetEscrows(params));
    return result.return;
  }
  /**
   * Makes a readonly (simulated) call to the AbstractedAccount smart contract using the `arc58_getAllowances(string,uint64[])(uint8,uint64,uint64,uint64,uint64,uint64,uint64,bool)[]` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Get allowance info for a list of assets on a given escrow
   *
   * @param params The params for the smart contract call
   * @returns The call result: The allowance info for each asset, or empty allowance info if no allowance exists
   */
  async arc58GetAllowances(params) {
    const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58GetAllowances(params));
    return result.return;
  }
  /**
   * Makes a readonly (simulated) call to the AbstractedAccount smart contract using the `arc58_getExecutions(byte[32][])(byte[32][],uint64,uint64)[]` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Get execution key info for a list of leases
   *
   * @param params The params for the smart contract call
   * @returns The call result: The execution info for each lease, or empty execution info if the lease does not exist
   */
  async arc58GetExecutions(params) {
    const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58GetExecutions(params));
    return result.return;
  }
  /**
   * Makes a readonly (simulated) call to the AbstractedAccount smart contract using the `arc58_getDomainKeys(address[])string[]` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Get domain key assignments for a list of addresses
   *
   * @param params The params for the smart contract call
   * @returns The call result: The domain string for each address, or empty string if no domain is assigned
   */
  async arc58GetDomainKeys(params) {
    const result = await this.appClient.send.call(AbstractedAccountParamsFactory.arc58GetDomainKeys(params));
    return result.return;
  }
  /**
   * Makes a readonly (simulated) call to the AbstractedAccount smart contract using the `mbr(string,uint64,string,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Calculate the minimum balance requirements for various box operations
   *
   * @param params The params for the smart contract call
   * @returns The call result: The MBR costs for plugins, named plugins, escrows, allowances, domain keys, executions, and new escrow creation
   */
  async mbr(params) {
    const result = await this.appClient.send.call(AbstractedAccountParamsFactory.mbr(params));
    return result.return;
  }
  /**
   * Makes a readonly (simulated) call to the AbstractedAccount smart contract using the `balance(uint64[])uint64[]` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Get the balance of a set of assets in the account, including staked amounts
   *
   * @param params The params for the smart contract call
   * @returns The call result: The balance for each asset including any staked amounts
   */
  async balance(params) {
    const result = await this.appClient.send.call(AbstractedAccountParamsFactory.balance(params));
    return result.return;
  }
  /**
   * Methods to access state for the current AbstractedAccount app
   */
  state = {
    /**
     * Methods to access global state for the current AbstractedAccount app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async () => {
        const result = await this.appClient.state.global.getAll();
        return {
          version: result.version,
          akitaDao: result.akitaDAO,
          admin: result.admin,
          domain: result.domain,
          controlledAddress: result.controlledAddress,
          nickname: result.nickname,
          avatar: result.avatar,
          banner: result.banner,
          bio: result.bio,
          lastUserInteraction: result.lastUserInteraction,
          lastChange: result.lastChange,
          spendingAddress: result.spendingAddress,
          currentPlugin: result.currentPlugin,
          rekeyIndex: result.rekeyIndex,
          escrowFactory: result.escrowFactory,
          factoryApp: result.factoryApp,
          revocation: result.revocation,
          referrer: result.referrer
        };
      },
      /**
       * Get the current value of the version key in global state
       */
      version: async () => {
        return await this.appClient.state.global.getValue("version");
      },
      /**
       * Get the current value of the akitaDAO key in global state
       */
      akitaDao: async () => {
        return await this.appClient.state.global.getValue("akitaDAO");
      },
      /**
       * Get the current value of the admin key in global state
       */
      admin: async () => {
        return await this.appClient.state.global.getValue("admin");
      },
      /**
       * Get the current value of the domain key in global state
       */
      domain: async () => {
        return await this.appClient.state.global.getValue("domain");
      },
      /**
       * Get the current value of the controlledAddress key in global state
       */
      controlledAddress: async () => {
        return await this.appClient.state.global.getValue("controlledAddress");
      },
      /**
       * Get the current value of the nickname key in global state
       */
      nickname: async () => {
        return await this.appClient.state.global.getValue("nickname");
      },
      /**
       * Get the current value of the avatar key in global state
       */
      avatar: async () => {
        return await this.appClient.state.global.getValue("avatar");
      },
      /**
       * Get the current value of the banner key in global state
       */
      banner: async () => {
        return await this.appClient.state.global.getValue("banner");
      },
      /**
       * Get the current value of the bio key in global state
       */
      bio: async () => {
        return await this.appClient.state.global.getValue("bio");
      },
      /**
       * Get the current value of the lastUserInteraction key in global state
       */
      lastUserInteraction: async () => {
        return await this.appClient.state.global.getValue("lastUserInteraction");
      },
      /**
       * Get the current value of the lastChange key in global state
       */
      lastChange: async () => {
        return await this.appClient.state.global.getValue("lastChange");
      },
      /**
       * Get the current value of the spendingAddress key in global state
       */
      spendingAddress: async () => {
        return await this.appClient.state.global.getValue("spendingAddress");
      },
      /**
       * Get the current value of the currentPlugin key in global state
       */
      currentPlugin: async () => {
        return await this.appClient.state.global.getValue("currentPlugin");
      },
      /**
       * Get the current value of the rekeyIndex key in global state
       */
      rekeyIndex: async () => {
        return await this.appClient.state.global.getValue("rekeyIndex");
      },
      /**
       * Get the current value of the escrowFactory key in global state
       */
      escrowFactory: async () => {
        return await this.appClient.state.global.getValue("escrowFactory");
      },
      /**
       * Get the current value of the factoryApp key in global state
       */
      factoryApp: async () => {
        return await this.appClient.state.global.getValue("factoryApp");
      },
      /**
       * Get the current value of the revocation key in global state
       */
      revocation: async () => {
        return await this.appClient.state.global.getValue("revocation");
      },
      /**
       * Get the current value of the referrer key in global state
       */
      referrer: async () => {
        return await this.appClient.state.global.getValue("referrer");
      }
    },
    /**
     * Methods to access box state for the current AbstractedAccount app
     */
    box: {
      /**
       * Get all current keyed values from box state
       */
      getAll: async () => {
        const result = await this.appClient.state.box.getAll();
        return {};
      },
      /**
       * Get values from the plugins map in box state
       */
      plugins: {
        /**
         * Get all current values of the plugins map in box state
         */
        getMap: async () => {
          return await this.appClient.state.box.getMap("plugins");
        },
        /**
         * Get a current value of the plugins map by key from box state
         */
        value: async (key) => {
          return await this.appClient.state.box.getMapValue("plugins", key);
        }
      },
      /**
       * Get values from the namedPlugins map in box state
       */
      namedPlugins: {
        /**
         * Get all current values of the namedPlugins map in box state
         */
        getMap: async () => {
          return await this.appClient.state.box.getMap("namedPlugins");
        },
        /**
         * Get a current value of the namedPlugins map by key from box state
         */
        value: async (key) => {
          return await this.appClient.state.box.getMapValue("namedPlugins", key);
        }
      },
      /**
       * Get values from the escrows map in box state
       */
      escrows: {
        /**
         * Get all current values of the escrows map in box state
         */
        getMap: async () => {
          return await this.appClient.state.box.getMap("escrows");
        },
        /**
         * Get a current value of the escrows map by key from box state
         */
        value: async (key) => {
          return await this.appClient.state.box.getMapValue("escrows", key);
        }
      },
      /**
       * Get values from the allowances map in box state
       */
      allowances: {
        /**
         * Get all current values of the allowances map in box state
         */
        getMap: async () => {
          return await this.appClient.state.box.getMap("allowances");
        },
        /**
         * Get a current value of the allowances map by key from box state
         */
        value: async (key) => {
          return await this.appClient.state.box.getMapValue("allowances", key);
        }
      },
      /**
       * Get values from the executions map in box state
       */
      executions: {
        /**
         * Get all current values of the executions map in box state
         */
        getMap: async () => {
          return await this.appClient.state.box.getMap("executions");
        },
        /**
         * Get a current value of the executions map by key from box state
         */
        value: async (key) => {
          return await this.appClient.state.box.getMapValue("executions", key);
        }
      },
      /**
       * Get values from the domainKeys map in box state
       */
      domainKeys: {
        /**
         * Get all current values of the domainKeys map in box state
         */
        getMap: async () => {
          return await this.appClient.state.box.getMap("domainKeys");
        },
        /**
         * Get a current value of the domainKeys map by key from box state
         */
        value: async (key) => {
          return await this.appClient.state.box.getMapValue("domainKeys", key);
        }
      }
    }
  };
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a register(string)void method call against the AbstractedAccount contract
       */
      register(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.register(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a setDomain(string)void method call against the AbstractedAccount contract
       */
      setDomain(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.setDomain(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a setRevocationApp(uint64)void method call against the AbstractedAccount contract
       */
      setRevocationApp(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.setRevocationApp(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a setAkitaDAO(uint64)void method call against the AbstractedAccount contract
       */
      setAkitaDao(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.setAkitaDao(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a setNickname(string)void method call against the AbstractedAccount contract
       */
      setNickname(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.setNickname(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a setAvatar(uint64)void method call against the AbstractedAccount contract
       */
      setAvatar(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.setAvatar(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a setBanner(uint64)void method call against the AbstractedAccount contract
       */
      setBanner(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.setBanner(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a setBio(string)void method call against the AbstractedAccount contract
       */
      setBio(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.setBio(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a arc58_changeAdmin(address)void method call against the AbstractedAccount contract
       */
      arc58ChangeAdmin(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58ChangeAdmin(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a arc58_pluginChangeAdmin(address)void method call against the AbstractedAccount contract
       */
      arc58PluginChangeAdmin(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58PluginChangeAdmin(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a arc58_verifyAuthAddress()void method call against the AbstractedAccount contract
       */
      arc58VerifyAuthAddress(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58VerifyAuthAddress(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a arc58_rekeyTo(address,bool)void method call against the AbstractedAccount contract
       */
      arc58RekeyTo(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58RekeyTo(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a arc58_canCall(uint64,bool,address,string,byte[4])bool method call against the AbstractedAccount contract
       */
      arc58CanCall(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58CanCall(params)));
        resultMappers.push((v) => client.decodeReturnValue("arc58_canCall(uint64,bool,address,string,byte[4])bool", v));
        return this;
      },
      /**
       * Add a arc58_rekeyToPlugin(uint64,bool,string,uint64[],(uint64,uint64)[])void method call against the AbstractedAccount contract
       */
      arc58RekeyToPlugin(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58RekeyToPlugin(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a arc58_rekeyToNamedPlugin(string,bool,string,uint64[],(uint64,uint64)[])void method call against the AbstractedAccount contract
       */
      arc58RekeyToNamedPlugin(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58RekeyToNamedPlugin(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a arc58_addPlugin(uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,bool)void method call against the AbstractedAccount contract
       */
      arc58AddPlugin(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58AddPlugin(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a assignDomain(address,string)void method call against the AbstractedAccount contract
       */
      assignDomain(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.assignDomain(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a arc58_removePlugin(uint64,address,string)void method call against the AbstractedAccount contract
       */
      arc58RemovePlugin(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58RemovePlugin(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a arc58_addNamedPlugin(string,uint64,address,string,bool,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,bool)void method call against the AbstractedAccount contract
       */
      arc58AddNamedPlugin(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58AddNamedPlugin(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a arc58_removeNamedPlugin(string)void method call against the AbstractedAccount contract
       */
      arc58RemoveNamedPlugin(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58RemoveNamedPlugin(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a arc58_newEscrow(string)uint64 method call against the AbstractedAccount contract
       */
      arc58NewEscrow(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58NewEscrow(params)));
        resultMappers.push((v) => client.decodeReturnValue("arc58_newEscrow(string)uint64", v));
        return this;
      },
      /**
       * Add a arc58_toggleEscrowLock(string)(uint64,bool) method call against the AbstractedAccount contract
       */
      arc58ToggleEscrowLock(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58ToggleEscrowLock(params)));
        resultMappers.push((v) => client.decodeReturnValue("arc58_toggleEscrowLock(string)(uint64,bool)", v));
        return this;
      },
      /**
       * Add a arc58_reclaim(string,(uint64,uint64,bool)[])void method call against the AbstractedAccount contract
       */
      arc58Reclaim(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58Reclaim(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a arc58_pluginReclaim(uint64,address,string,(uint64,uint64,bool)[])void method call against the AbstractedAccount contract
       */
      arc58PluginReclaim(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58PluginReclaim(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a arc58_optInEscrow(string,uint64[])void method call against the AbstractedAccount contract
       */
      arc58OptInEscrow(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58OptInEscrow(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a arc58_pluginOptInEscrow(uint64,address,string,uint64[],pay)void method call against the AbstractedAccount contract
       */
      arc58PluginOptInEscrow(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58PluginOptInEscrow(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a arc58_addAllowances(string,(uint64,uint8,uint64,uint64,uint64,bool)[])void method call against the AbstractedAccount contract
       */
      arc58AddAllowances(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58AddAllowances(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a arc58_removeAllowances(string,uint64[])void method call against the AbstractedAccount contract
       */
      arc58RemoveAllowances(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58RemoveAllowances(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a arc58_addExecutionKey(byte[32],byte[32][],uint64,uint64)void method call against the AbstractedAccount contract
       */
      arc58AddExecutionKey(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58AddExecutionKey(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a arc58_removeExecutionKey(byte[32])void method call against the AbstractedAccount contract
       */
      arc58RemoveExecutionKey(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58RemoveExecutionKey(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a arc58_getAdmin()address method call against the AbstractedAccount contract
       */
      arc58GetAdmin(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58GetAdmin(params)));
        resultMappers.push((v) => client.decodeReturnValue("arc58_getAdmin()address", v));
        return this;
      },
      /**
       * Add a arc58_getPlugins((uint64,address,string)[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[] method call against the AbstractedAccount contract
       */
      arc58GetPlugins(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58GetPlugins(params)));
        resultMappers.push((v) => client.decodeReturnValue("arc58_getPlugins((uint64,address,string)[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[]", v));
        return this;
      },
      /**
       * Add a arc58_getNamedPlugins(string[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[] method call against the AbstractedAccount contract
       */
      arc58GetNamedPlugins(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58GetNamedPlugins(params)));
        resultMappers.push((v) => client.decodeReturnValue("arc58_getNamedPlugins(string[])(uint64,uint8,uint64,uint64,(byte[4],uint64,uint64)[],bool,bool,bool,bool,bool,uint64,uint64)[]", v));
        return this;
      },
      /**
       * Add a arc58_getEscrows(string[])(uint64,bool)[] method call against the AbstractedAccount contract
       */
      arc58GetEscrows(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58GetEscrows(params)));
        resultMappers.push((v) => client.decodeReturnValue("arc58_getEscrows(string[])(uint64,bool)[]", v));
        return this;
      },
      /**
       * Add a arc58_getAllowances(string,uint64[])(uint8,uint64,uint64,uint64,uint64,uint64,uint64,bool)[] method call against the AbstractedAccount contract
       */
      arc58GetAllowances(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58GetAllowances(params)));
        resultMappers.push((v) => client.decodeReturnValue("arc58_getAllowances(string,uint64[])(uint8,uint64,uint64,uint64,uint64,uint64,uint64,bool)[]", v));
        return this;
      },
      /**
       * Add a arc58_getExecutions(byte[32][])(byte[32][],uint64,uint64)[] method call against the AbstractedAccount contract
       */
      arc58GetExecutions(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58GetExecutions(params)));
        resultMappers.push((v) => client.decodeReturnValue("arc58_getExecutions(byte[32][])(byte[32][],uint64,uint64)[]", v));
        return this;
      },
      /**
       * Add a arc58_getDomainKeys(address[])string[] method call against the AbstractedAccount contract
       */
      arc58GetDomainKeys(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.arc58GetDomainKeys(params)));
        resultMappers.push((v) => client.decodeReturnValue("arc58_getDomainKeys(address[])string[]", v));
        return this;
      },
      /**
       * Add a mbr(string,uint64,string,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64) method call against the AbstractedAccount contract
       */
      mbr(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mbr(params)));
        resultMappers.push((v) => client.decodeReturnValue("mbr(string,uint64,string,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64)", v));
        return this;
      },
      /**
       * Add a balance(uint64[])uint64[] method call against the AbstractedAccount contract
       */
      balance(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.balance(params)));
        resultMappers.push((v) => client.decodeReturnValue("balance(uint64[])uint64[]", v));
        return this;
      },
      get update() {
        return {
          update: (params) => {
            promiseChain = promiseChain.then(async () => composer.addAppUpdateMethodCall(await client.params.update.update(params)));
            resultMappers.push(void 0);
            return this;
          }
        };
      },
      /**
       * Add a clear state call to the AbstractedAccount contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/index.ts
import algosdk6, { Address as Address5, ALGORAND_ZERO_ADDRESS_STRING as ALGORAND_ZERO_ADDRESS_STRING3, makeEmptyTransactionSigner } from "algosdk";

// src/wallet/constants.ts
var NewEscrowFeeAmount = 6000n;

// src/wallet/index.ts
import { encodeLease, microAlgo as microAlgo6 } from "@algorandfoundation/algokit-utils";

// src/simulate/prepare.ts
import algosdk2 from "algosdk";

// src/simulate/deltas.ts
import algosdk from "algosdk";
var normalizeAddr = (addr) => {
  if (!addr) return null;
  if (typeof addr === "string") return addr;
  if (addr instanceof Uint8Array && addr.length === 32) {
    return algosdk.encodeAddress(addr);
  }
  return null;
};
function extractAccountDeltas(simResponse, account) {
  const deltas = /* @__PURE__ */ new Map();
  const addDelta = (asset, delta) => {
    deltas.set(asset, (deltas.get(asset) ?? 0n) + delta);
  };
  const getCloseAmount = (txnResult, assetId) => {
    const localStateDelta = txnResult == null ? void 0 : txnResult["local-state-delta"];
    const globalStateDelta = txnResult == null ? void 0 : txnResult["global-state-delta"];
    return 0n;
  };
  const applyTxn = (txnWrapper, txnResult) => {
    const t = (txnWrapper == null ? void 0 : txnWrapper.txn) ?? txnWrapper;
    if (!t) return;
    const type = t.type;
    if (type === "pay") {
      const snd = normalizeAddr(t.snd);
      const rcv = normalizeAddr(t.rcv);
      const close = normalizeAddr(t.close);
      const amt = BigInt(t.amt ?? 0);
      const fee = BigInt(t.fee ?? 0);
      if (snd === account) addDelta(0n, -amt - fee);
      if (rcv === account) addDelta(0n, amt);
      if (close && close === account) {
        const closeAmount = txnResult ? getCloseAmount(txnResult, 0n) : 0n;
        if (closeAmount > 0n) addDelta(0n, closeAmount);
      }
    } else if (type === "axfer") {
      const snd = normalizeAddr(t.snd);
      const rcv = normalizeAddr(t.arcv);
      const close = normalizeAddr(t.aclose);
      const amt = BigInt(t.aamt ?? 0);
      const assetId = BigInt(t.xaid ?? 0);
      const fee = BigInt(t.fee ?? 0);
      if (snd === account) {
        addDelta(assetId, -amt);
        addDelta(0n, -fee);
      }
      if (rcv === account) addDelta(assetId, amt);
      if (close && close === account) {
        const closeAmount = txnResult ? getCloseAmount(txnResult, assetId) : 0n;
        if (closeAmount > 0n) addDelta(assetId, closeAmount);
      }
    }
  };
  const walkInner = (inner) => {
    for (const tx of inner ?? []) {
      applyTxn(tx.txn ?? tx, tx["txn-result"]);
      walkInner(tx["inner-txns"] ?? tx.innerTxns);
    }
  };
  const response = simResponse;
  const txnGroups = (response == null ? void 0 : response["txn-groups"]) ?? (response == null ? void 0 : response.txnGroups) ?? [];
  for (const group of txnGroups) {
    const results = (group == null ? void 0 : group["txn-results"]) ?? (group == null ? void 0 : group.txnResults) ?? [];
    for (const res of results) {
      const txnResult = (res == null ? void 0 : res["txn-result"]) ?? (res == null ? void 0 : res.txnResult);
      applyTxn(res == null ? void 0 : res.txn, txnResult);
      walkInner((txnResult == null ? void 0 : txnResult["inner-txns"]) ?? (txnResult == null ? void 0 : txnResult.innerTxns));
    }
  }
  return Array.from(deltas.entries()).map(([asset, delta]) => ({ asset, delta }));
}

// src/simulate/prepare.ts
var MAX_APP_CALL_FOREIGN_REFERENCES = 8;
var MAX_APP_CALL_ACCOUNT_REFERENCES = 4;
async function getGroupExecutionInfo(atc, algod, sendParams, additionalAtcContext) {
  var _a, _b;
  const simulateRequest = new algosdk2.modelsv2.SimulateRequest({
    txnGroups: [],
    allowUnnamedResources: true,
    allowEmptySignatures: true,
    fixSigners: true
  });
  const nullSigner = algosdk2.makeEmptyTransactionSigner();
  const emptySignerAtc = atc.clone();
  const appCallIndexesWithoutMaxFees = [];
  emptySignerAtc["transactions"].forEach((t, i) => {
    var _a2, _b2;
    t.signer = nullSigner;
    if (sendParams.coverAppCallInnerTransactionFees && t.txn.type === algosdk2.TransactionType.appl) {
      if (!(additionalAtcContext == null ? void 0 : additionalAtcContext.suggestedParams)) {
        throw Error(`Please provide additionalAtcContext.suggestedParams when coverAppCallInnerTransactionFees is enabled`);
      }
      const maxFee = (_b2 = (_a2 = additionalAtcContext == null ? void 0 : additionalAtcContext.maxFees) == null ? void 0 : _a2.get(i)) == null ? void 0 : _b2.microAlgo;
      if (maxFee === void 0) {
        appCallIndexesWithoutMaxFees.push(i);
      } else {
        t.txn.fee = maxFee;
      }
    }
  });
  if (sendParams.coverAppCallInnerTransactionFees && appCallIndexesWithoutMaxFees.length > 0) {
    throw Error(`Please provide a maxFee for each app call transaction when coverAppCallInnerTransactionFees is enabled. Required for transaction ${appCallIndexesWithoutMaxFees.join(", ")}`);
  }
  const perByteTxnFee = BigInt(((_a = additionalAtcContext == null ? void 0 : additionalAtcContext.suggestedParams) == null ? void 0 : _a.fee) ?? 0n);
  const minTxnFee = BigInt(((_b = additionalAtcContext == null ? void 0 : additionalAtcContext.suggestedParams) == null ? void 0 : _b.minFee) ?? 1000n);
  const result = await emptySignerAtc.simulate(algod, simulateRequest);
  const groupResponse = result.simulateResponse.txnGroups[0];
  if (groupResponse.failureMessage) {
    if (sendParams.coverAppCallInnerTransactionFees && groupResponse.failureMessage.match(/fee too small/)) {
      throw Error(`Fees were too small to resolve execution info via simulate. You may need to increase an app call transaction maxFee.`);
    }
    throw Error(`Error resolving execution info via simulate in transaction ${groupResponse.failedAt}: ${groupResponse.failureMessage}`);
  }
  return {
    simulateResponse: result.simulateResponse,
    groupUnnamedResourcesAccessed: sendParams.populateAppCallResources ? groupResponse.unnamedResourcesAccessed : void 0,
    txns: groupResponse.txnResults.map((txn, i) => {
      const originalTxn = atc["transactions"][i].txn;
      let requiredFeeDelta = 0n;
      if (sendParams.coverAppCallInnerTransactionFees) {
        const parentPerByteFee = perByteTxnFee * BigInt(originalTxn.toByte().length + 75);
        const parentMinFee = parentPerByteFee < minTxnFee ? minTxnFee : parentPerByteFee;
        const parentFeeDelta = parentMinFee - originalTxn.fee;
        if (originalTxn.type === algosdk2.TransactionType.appl) {
          const calculateInnerFeeDelta = (itxns, acc = 0n) => {
            return itxns.reverse().reduce((acc2, itxn) => {
              const currentFeeDelta = (itxn.innerTxns && itxn.innerTxns.length > 0 ? calculateInnerFeeDelta(itxn.innerTxns, acc2) : acc2) + (minTxnFee - itxn.txn.txn.fee);
              return currentFeeDelta < 0n ? 0n : currentFeeDelta;
            }, acc);
          };
          const innerFeeDelta = calculateInnerFeeDelta(txn.txnResult.innerTxns ?? []);
          requiredFeeDelta = innerFeeDelta + parentFeeDelta;
        } else {
          requiredFeeDelta = parentFeeDelta;
        }
      }
      return {
        unnamedResourcesAccessed: sendParams.populateAppCallResources ? txn.unnamedResourcesAccessed : void 0,
        requiredFeeDelta
      };
    })
  };
}
async function prepareGroupWithCost(atc, algod, sendParams = {}, additionalAtcContext = {}, simulateAccount, simulateOptions) {
  var _a, _b, _c, _d, _e, _f;
  const executionInfo = await getGroupExecutionInfo(atc, algod, sendParams, additionalAtcContext);
  const group = atc.buildGroup();
  const [_, additionalTransactionFees] = sendParams.coverAppCallInnerTransactionFees ? executionInfo.txns.map((txn, i) => {
    var _a2, _b2;
    const groupIndex = i;
    const txnInGroup = group[groupIndex].txn;
    const maxFee = (_b2 = (_a2 = additionalAtcContext == null ? void 0 : additionalAtcContext.maxFees) == null ? void 0 : _a2.get(i)) == null ? void 0 : _b2.microAlgo;
    const immutableFee = maxFee !== void 0 && maxFee === txnInGroup.fee;
    const priorityMultiplier = txn.requiredFeeDelta > 0n && (immutableFee || txnInGroup.type !== algosdk2.TransactionType.appl) ? 1000n : 1n;
    return {
      ...txn,
      groupIndex,
      surplusFeePriorityLevel: txn.requiredFeeDelta > 0n ? txn.requiredFeeDelta * priorityMultiplier : -1n
    };
  }).sort((a, b) => {
    return a.surplusFeePriorityLevel > b.surplusFeePriorityLevel ? -1 : a.surplusFeePriorityLevel < b.surplusFeePriorityLevel ? 1 : 0;
  }).reduce((acc, { groupIndex, requiredFeeDelta }) => {
    if (requiredFeeDelta > 0n) {
      let surplusGroupFees = acc[0];
      const additionalTransactionFees2 = acc[1];
      const additionalFeeDelta = requiredFeeDelta - surplusGroupFees;
      if (additionalFeeDelta <= 0n) {
        surplusGroupFees = -additionalFeeDelta;
      } else {
        additionalTransactionFees2.set(groupIndex, additionalFeeDelta);
        surplusGroupFees = 0n;
      }
      return [surplusGroupFees, additionalTransactionFees2];
    }
    return acc;
  }, [
    executionInfo.txns.reduce((acc, { requiredFeeDelta }) => {
      if (requiredFeeDelta < 0n) return acc + -requiredFeeDelta;
      return acc;
    }, 0n),
    /* @__PURE__ */ new Map()
  ]) : [0n, /* @__PURE__ */ new Map()];
  executionInfo.txns.forEach(({ unnamedResourcesAccessed: r }, i) => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
    if (sendParams.populateAppCallResources && r !== void 0 && group[i].txn.type === algosdk2.TransactionType.appl) {
      if (r.boxes || r.extraBoxRefs)
        throw Error("Unexpected boxes at the transaction level");
      if (r.appLocals)
        throw Error("Unexpected app local at the transaction level");
      if (r.assetHoldings)
        throw Error("Unexpected asset holding at the transaction level");
      group[i].txn["applicationCall"] = {
        ...group[i].txn.applicationCall,
        accounts: [...((_b2 = (_a2 = group[i].txn) == null ? void 0 : _a2.applicationCall) == null ? void 0 : _b2.accounts) ?? [], ...r.accounts ?? []],
        foreignApps: [...((_d2 = (_c2 = group[i].txn) == null ? void 0 : _c2.applicationCall) == null ? void 0 : _d2.foreignApps) ?? [], ...r.apps ?? []],
        foreignAssets: [...((_f2 = (_e2 = group[i].txn) == null ? void 0 : _e2.applicationCall) == null ? void 0 : _f2.foreignAssets) ?? [], ...r.assets ?? []],
        boxes: [...((_h = (_g = group[i].txn) == null ? void 0 : _g.applicationCall) == null ? void 0 : _h.boxes) ?? [], ...r.boxes ?? []]
      };
      const accounts = ((_j = (_i = group[i].txn.applicationCall) == null ? void 0 : _i.accounts) == null ? void 0 : _j.length) ?? 0;
      if (accounts > MAX_APP_CALL_ACCOUNT_REFERENCES)
        throw Error(`Account reference limit of ${MAX_APP_CALL_ACCOUNT_REFERENCES} exceeded in transaction ${i}`);
      const assets = ((_l = (_k = group[i].txn.applicationCall) == null ? void 0 : _k.foreignAssets) == null ? void 0 : _l.length) ?? 0;
      const apps = ((_n = (_m = group[i].txn.applicationCall) == null ? void 0 : _m.foreignApps) == null ? void 0 : _n.length) ?? 0;
      const boxes = ((_p = (_o = group[i].txn.applicationCall) == null ? void 0 : _o.boxes) == null ? void 0 : _p.length) ?? 0;
      if (accounts + assets + apps + boxes > MAX_APP_CALL_FOREIGN_REFERENCES) {
        throw Error(`Resource reference limit of ${MAX_APP_CALL_FOREIGN_REFERENCES} exceeded in transaction ${i}`);
      }
    }
    if (sendParams.coverAppCallInnerTransactionFees) {
      const additionalTransactionFee = additionalTransactionFees.get(i);
      if (additionalTransactionFee !== void 0) {
        if (group[i].txn.type !== algosdk2.TransactionType.appl) {
          throw Error(`An additional fee of ${additionalTransactionFee} \xB5ALGO is required for non app call transaction ${i}`);
        }
        const transactionFee = group[i].txn.fee + additionalTransactionFee;
        const maxFee = (_r = (_q = additionalAtcContext == null ? void 0 : additionalAtcContext.maxFees) == null ? void 0 : _q.get(i)) == null ? void 0 : _r.microAlgo;
        if (maxFee === void 0 || transactionFee > maxFee) {
          throw Error(`Calculated transaction fee ${transactionFee} \xB5ALGO is greater than max of ${maxFee ?? "undefined"} for transaction ${i}`);
        }
        group[i].txn.fee = transactionFee;
      }
    }
  });
  if (sendParams.populateAppCallResources) {
    const populateGroupResource = (txns, reference, type) => {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
      const isApplBelowLimit = (t) => {
        var _a3, _b3, _c3, _d3, _e3, _f3, _g2, _h2;
        if (t.txn.type !== algosdk2.TransactionType.appl)
          return false;
        const accounts = ((_b3 = (_a3 = t.txn.applicationCall) == null ? void 0 : _a3.accounts) == null ? void 0 : _b3.length) ?? 0;
        const assets = ((_d3 = (_c3 = t.txn.applicationCall) == null ? void 0 : _c3.foreignAssets) == null ? void 0 : _d3.length) ?? 0;
        const apps = ((_f3 = (_e3 = t.txn.applicationCall) == null ? void 0 : _e3.foreignApps) == null ? void 0 : _f3.length) ?? 0;
        const boxes = ((_h2 = (_g2 = t.txn.applicationCall) == null ? void 0 : _g2.boxes) == null ? void 0 : _h2.length) ?? 0;
        return accounts + assets + apps + boxes < MAX_APP_CALL_FOREIGN_REFERENCES;
      };
      if (type === "assetHolding" || type === "appLocal") {
        const { account } = reference;
        let txnIndex2 = txns.findIndex((t) => {
          var _a3, _b3, _c3, _d3;
          if (!isApplBelowLimit(t))
            return false;
          return (
            // account is in the foreign accounts array
            ((_b3 = (_a3 = t.txn.applicationCall) == null ? void 0 : _a3.accounts) == null ? void 0 : _b3.map((a) => a.toString()).includes(account.toString())) || // account is available as an app account
            ((_d3 = (_c3 = t.txn.applicationCall) == null ? void 0 : _c3.foreignApps) == null ? void 0 : _d3.map((a) => algosdk2.getApplicationAddress(a).toString()).includes(account.toString())) || // account is available since it's in one of the fields
            Object.values(t.txn).some((f) => {
              var _a4;
              return (_a4 = algosdk2.stringifyJSON(f, (_2, v) => v instanceof algosdk2.Address ? v.toString() : v)) == null ? void 0 : _a4.includes(account.toString());
            })
          );
        });
        if (txnIndex2 > -1) {
          if (type === "assetHolding") {
            const { asset } = reference;
            txns[txnIndex2].txn["applicationCall"] = {
              ...txns[txnIndex2].txn.applicationCall,
              foreignAssets: [...((_b2 = (_a2 = txns[txnIndex2].txn) == null ? void 0 : _a2.applicationCall) == null ? void 0 : _b2.foreignAssets) ?? [], ...[asset]]
            };
          } else {
            const { app } = reference;
            txns[txnIndex2].txn["applicationCall"] = {
              ...txns[txnIndex2].txn.applicationCall,
              foreignApps: [...((_d2 = (_c2 = txns[txnIndex2].txn) == null ? void 0 : _c2.applicationCall) == null ? void 0 : _d2.foreignApps) ?? [], ...[app]]
            };
          }
          return;
        }
        txnIndex2 = txns.findIndex((t) => {
          var _a3, _b3, _c3, _d3, _e3, _f3, _g2;
          if (!isApplBelowLimit(t))
            return false;
          if ((((_b3 = (_a3 = t.txn.applicationCall) == null ? void 0 : _a3.accounts) == null ? void 0 : _b3.length) ?? 0) >= MAX_APP_CALL_ACCOUNT_REFERENCES)
            return false;
          if (type === "assetHolding") {
            const { asset } = reference;
            return (_d3 = (_c3 = t.txn.applicationCall) == null ? void 0 : _c3.foreignAssets) == null ? void 0 : _d3.includes(asset);
          } else {
            const { app } = reference;
            return ((_f3 = (_e3 = t.txn.applicationCall) == null ? void 0 : _e3.foreignApps) == null ? void 0 : _f3.includes(app)) || ((_g2 = t.txn.applicationCall) == null ? void 0 : _g2.appIndex) === app;
          }
        });
        if (txnIndex2 > -1) {
          const { account: account2 } = reference;
          txns[txnIndex2].txn["applicationCall"] = {
            ...txns[txnIndex2].txn.applicationCall,
            accounts: [...((_f2 = (_e2 = txns[txnIndex2].txn) == null ? void 0 : _e2.applicationCall) == null ? void 0 : _f2.accounts) ?? [], ...[account2]]
          };
          return;
        }
      }
      if (type === "box") {
        const { app, name } = reference;
        const txnIndex2 = txns.findIndex((t) => {
          var _a3, _b3, _c3;
          if (!isApplBelowLimit(t))
            return false;
          return ((_b3 = (_a3 = t.txn.applicationCall) == null ? void 0 : _a3.foreignApps) == null ? void 0 : _b3.includes(app)) || ((_c3 = t.txn.applicationCall) == null ? void 0 : _c3.appIndex) === app;
        });
        if (txnIndex2 > -1) {
          txns[txnIndex2].txn["applicationCall"] = {
            ...txns[txnIndex2].txn.applicationCall,
            boxes: [...((_h = (_g = txns[txnIndex2].txn) == null ? void 0 : _g.applicationCall) == null ? void 0 : _h.boxes) ?? [], ...[{ appIndex: app, name }]]
          };
          return;
        }
      }
      const txnIndex = txns.findIndex((t) => {
        var _a3, _b3, _c3, _d3, _e3, _f3, _g2, _h2;
        if (t.txn.type !== algosdk2.TransactionType.appl)
          return false;
        const accounts = ((_b3 = (_a3 = t.txn.applicationCall) == null ? void 0 : _a3.accounts) == null ? void 0 : _b3.length) ?? 0;
        if (type === "account")
          return accounts < MAX_APP_CALL_ACCOUNT_REFERENCES;
        const assets = ((_d3 = (_c3 = t.txn.applicationCall) == null ? void 0 : _c3.foreignAssets) == null ? void 0 : _d3.length) ?? 0;
        const apps = ((_f3 = (_e3 = t.txn.applicationCall) == null ? void 0 : _e3.foreignApps) == null ? void 0 : _f3.length) ?? 0;
        const boxes = ((_h2 = (_g2 = t.txn.applicationCall) == null ? void 0 : _g2.boxes) == null ? void 0 : _h2.length) ?? 0;
        if (type === "assetHolding" || type === "appLocal") {
          return accounts + assets + apps + boxes < MAX_APP_CALL_FOREIGN_REFERENCES - 1 && accounts < MAX_APP_CALL_ACCOUNT_REFERENCES;
        }
        if (type === "box" && BigInt(reference.app) !== 0n) {
          return accounts + assets + apps + boxes < MAX_APP_CALL_FOREIGN_REFERENCES - 1;
        }
        return accounts + assets + apps + boxes < MAX_APP_CALL_FOREIGN_REFERENCES;
      });
      if (txnIndex === -1) {
        throw Error("No more transactions below reference limit. Add another app call to the group.");
      }
      if (type === "account") {
        txns[txnIndex].txn["applicationCall"] = {
          ...txns[txnIndex].txn.applicationCall,
          accounts: [...((_j = (_i = txns[txnIndex].txn) == null ? void 0 : _i.applicationCall) == null ? void 0 : _j.accounts) ?? [], ...[reference]]
        };
      } else if (type === "app") {
        txns[txnIndex].txn["applicationCall"] = {
          ...txns[txnIndex].txn.applicationCall,
          foreignApps: [
            ...((_l = (_k = txns[txnIndex].txn) == null ? void 0 : _k.applicationCall) == null ? void 0 : _l.foreignApps) ?? [],
            ...[typeof reference === "bigint" ? reference : BigInt(reference)]
          ]
        };
      } else if (type === "box") {
        const { app, name } = reference;
        txns[txnIndex].txn["applicationCall"] = {
          ...txns[txnIndex].txn.applicationCall,
          boxes: [...((_n = (_m = txns[txnIndex].txn) == null ? void 0 : _m.applicationCall) == null ? void 0 : _n.boxes) ?? [], ...[{ appIndex: app, name }]]
        };
        if (app.toString() !== "0") {
          txns[txnIndex].txn["applicationCall"] = {
            ...txns[txnIndex].txn.applicationCall,
            foreignApps: [...((_p = (_o = txns[txnIndex].txn) == null ? void 0 : _o.applicationCall) == null ? void 0 : _p.foreignApps) ?? [], ...[app]]
          };
        }
      } else if (type === "assetHolding") {
        const { asset, account } = reference;
        txns[txnIndex].txn["applicationCall"] = {
          ...txns[txnIndex].txn.applicationCall,
          foreignAssets: [...((_r = (_q = txns[txnIndex].txn) == null ? void 0 : _q.applicationCall) == null ? void 0 : _r.foreignAssets) ?? [], ...[asset]],
          accounts: [...((_t = (_s = txns[txnIndex].txn) == null ? void 0 : _s.applicationCall) == null ? void 0 : _t.accounts) ?? [], ...[account]]
        };
      } else if (type === "appLocal") {
        const { app, account } = reference;
        txns[txnIndex].txn["applicationCall"] = {
          ...txns[txnIndex].txn.applicationCall,
          foreignApps: [...((_v = (_u = txns[txnIndex].txn) == null ? void 0 : _u.applicationCall) == null ? void 0 : _v.foreignApps) ?? [], ...[app]],
          accounts: [...((_x = (_w = txns[txnIndex].txn) == null ? void 0 : _w.applicationCall) == null ? void 0 : _x.accounts) ?? [], ...[account]]
        };
      } else if (type === "asset") {
        txns[txnIndex].txn["applicationCall"] = {
          ...txns[txnIndex].txn.applicationCall,
          foreignAssets: [
            ...((_z = (_y = txns[txnIndex].txn) == null ? void 0 : _y.applicationCall) == null ? void 0 : _z.foreignAssets) ?? [],
            ...[typeof reference === "bigint" ? reference : BigInt(reference)]
          ]
        };
      }
    };
    const g = executionInfo.groupUnnamedResourcesAccessed;
    if (g) {
      (_a = g.appLocals) == null ? void 0 : _a.forEach((a) => {
        var _a2, _b2;
        populateGroupResource(group, a, "appLocal");
        g.accounts = (_a2 = g.accounts) == null ? void 0 : _a2.filter((acc) => acc !== a.account);
        g.apps = (_b2 = g.apps) == null ? void 0 : _b2.filter((app) => BigInt(app) !== BigInt(a.app));
      });
      (_b = g.assetHoldings) == null ? void 0 : _b.forEach((a) => {
        var _a2, _b2;
        populateGroupResource(group, a, "assetHolding");
        g.accounts = (_a2 = g.accounts) == null ? void 0 : _a2.filter((acc) => acc !== a.account);
        g.assets = (_b2 = g.assets) == null ? void 0 : _b2.filter((asset) => BigInt(asset) !== BigInt(a.asset));
      });
      (_c = g.accounts) == null ? void 0 : _c.forEach((a) => {
        populateGroupResource(group, a, "account");
      });
      (_d = g.boxes) == null ? void 0 : _d.forEach((b) => {
        var _a2;
        populateGroupResource(group, b, "box");
        g.apps = (_a2 = g.apps) == null ? void 0 : _a2.filter((app) => BigInt(app) !== BigInt(b.app));
      });
      (_e = g.assets) == null ? void 0 : _e.forEach((a) => {
        populateGroupResource(group, a, "asset");
      });
      (_f = g.apps) == null ? void 0 : _f.forEach((a) => {
        populateGroupResource(group, a, "app");
      });
      if (g.extraBoxRefs) {
        for (let i = 0; i < g.extraBoxRefs; i += 1) {
          const ref = new algosdk2.modelsv2.BoxReference({ app: 0, name: new Uint8Array(0) });
          populateGroupResource(group, ref, "box");
        }
      }
    }
  }
  const expectedCost = calculateExpectedCostFromSimulation(
    executionInfo.simulateResponse,
    group,
    simulateOptions
  );
  if (simulateAccount) {
    expectedCost.accountDeltas = extractAccountDeltas(executionInfo.simulateResponse, simulateAccount);
  }
  const newAtc = new algosdk2.AtomicTransactionComposer();
  group.forEach((t) => {
    var _a2;
    t.txn.group = void 0;
    if (t.txn.type === algosdk2.TransactionType.appl) {
      const tx = t.txn;
      if ((_a2 = tx.applicationCall) == null ? void 0 : _a2.boxes) {
        tx.applicationCall.boxes = tx.applicationCall.boxes.filter((b) => b !== void 0 && b !== null).map((b) => ({
          appIndex: BigInt(b.appIndex ?? b.app ?? 0),
          name: b.name
        }));
      }
    }
    newAtc.addTransaction(t);
  });
  newAtc["methodCalls"] = atc["methodCalls"];
  return { atc: newAtc, expectedCost };
}
function calculateExpectedCostFromSimulation(simulateResponse, group, simulateOptions) {
  const hints = /* @__PURE__ */ new Map();
  for (const hint of (simulateOptions == null ? void 0 : simulateOptions.payments) ?? []) {
    hints.set(hint.asset, hint);
  }
  const payments = [];
  const ZERO = 0n;
  const processTxn = (unsignedTxn, applyData) => {
    if (!unsignedTxn) return;
    const type = unsignedTxn.type;
    if (type === "pay") {
      const payment = unsignedTxn.payment;
      let amount = BigInt((payment == null ? void 0 : payment.amount) ?? 0);
      if ((payment == null ? void 0 : payment.closeRemainderTo) && applyData) {
        const closingAmount = BigInt(applyData.closingAmount ?? 0);
        amount += closingAmount;
      }
      const base = {
        asset: 0n,
        amount,
        mbr: ZERO,
        fee: ZERO,
        total: amount
      };
      const hint = hints.get(0n);
      if (hint) {
        payments.push({
          ...base,
          amount: hint.amount ?? base.amount,
          mbr: hint.mbr ?? base.mbr,
          fee: hint.fee ?? base.fee,
          total: (hint.amount ?? base.amount) + (hint.mbr ?? base.mbr) + (hint.fee ?? base.fee)
        });
      } else {
        payments.push(base);
      }
    } else if (type === "axfer") {
      const assetTransfer = unsignedTxn.assetTransfer;
      const assetId = BigInt((assetTransfer == null ? void 0 : assetTransfer.assetIndex) ?? 0);
      let amount = BigInt((assetTransfer == null ? void 0 : assetTransfer.amount) ?? 0);
      if ((assetTransfer == null ? void 0 : assetTransfer.closeRemainderTo) && applyData) {
        const assetClosingAmount = BigInt(applyData.assetClosingAmount ?? 0);
        amount += assetClosingAmount;
      }
      const base = {
        asset: assetId,
        amount,
        mbr: ZERO,
        fee: ZERO,
        total: amount
      };
      const hint = hints.get(assetId);
      if (hint) {
        payments.push({
          ...base,
          amount: hint.amount ?? base.amount,
          mbr: hint.mbr ?? base.mbr,
          fee: hint.fee ?? base.fee,
          total: (hint.amount ?? base.amount) + (hint.mbr ?? base.mbr) + (hint.fee ?? base.fee)
        });
      } else {
        payments.push(base);
      }
    }
  };
  const walkInner = (inner) => {
    for (const itxn of inner ?? []) {
      const signedTxn = itxn.txn;
      const unsignedTxn = signedTxn == null ? void 0 : signedTxn.txn;
      processTxn(unsignedTxn, itxn);
      walkInner(itxn.innerTxns);
    }
  };
  const response = simulateResponse;
  const txnGroups = (response == null ? void 0 : response.txnGroups) ?? [];
  for (const grp of txnGroups) {
    const results = (grp == null ? void 0 : grp.txnResults) ?? [];
    for (const res of results) {
      const outerSignedTxn = res == null ? void 0 : res.txn;
      const outerUnsignedTxn = outerSignedTxn == null ? void 0 : outerSignedTxn.txn;
      const txnResult = res == null ? void 0 : res.txnResult;
      const outerApplyData = txnResult;
      processTxn(outerUnsignedTxn, outerApplyData);
      const innerTxns = txnResult == null ? void 0 : txnResult.innerTxns;
      walkInner(innerTxns);
    }
  }
  const networkFees = (simulateOptions == null ? void 0 : simulateOptions.networkFeeOverride) ?? group.reduce((acc, { txn }) => acc + BigInt((txn == null ? void 0 : txn.fee) ?? 0), ZERO);
  const subtotals = /* @__PURE__ */ new Map();
  for (const p of payments) {
    subtotals.set(p.asset, (subtotals.get(p.asset) ?? ZERO) + p.total);
  }
  const totalAlgo = subtotals.get(0n) ?? ZERO;
  return {
    payments,
    networkFees,
    subtotals: Array.from(subtotals.entries()).map(([asset, amount]) => ({ asset, amount })),
    totalAlgo
  };
}

// src/wallet/group.ts
import { ALGORAND_ZERO_ADDRESS_STRING } from "algosdk";
import { microAlgo } from "@algorandfoundation/algokit-utils";
var WalletGroupComposer = class {
  wallet;
  resolvers = [];
  postProcessors = [];
  newEscrows = /* @__PURE__ */ new Set();
  /** Tracks `"escrow:asset"` keys to deduplicate allowance additions */
  newAllowances = /* @__PURE__ */ new Set();
  group;
  constructor(wallet) {
    this.wallet = wallet;
    this.group = wallet.client.newGroup();
  }
  getSendParams({ sender, signer } = {}) {
    return {
      ...this.wallet.sendParams,
      ...sender !== void 0 && { sender },
      ...signer !== void 0 && { signer }
    };
  }
  // ---------------------------------------------------------------------------
  // Complex methods
  // ---------------------------------------------------------------------------
  addPlugin(params) {
    this.resolvers.push(async () => {
      const {
        sender,
        signer,
        name = "",
        client,
        caller: rawCaller,
        global = false,
        methods = [],
        escrow = "",
        admin = false,
        delegationType = 0n,
        lastValid = MAX_UINT64,
        cooldown = 0n,
        useRounds = false,
        useExecutionKey = false,
        coverFees = false,
        canReclaim = true,
        defaultToEscrow = false,
        allowances = []
      } = params;
      let caller = rawCaller;
      const sendParams = this.getSendParams({ sender, signer });
      const plugin = client.appId;
      if (global) {
        caller = ALGORAND_ZERO_ADDRESS_STRING;
      }
      let transformedMethods = [];
      if (methods.length > 0) {
        transformedMethods = methods.reduce(
          (acc, method) => {
            if (isPluginSDKReturn(method.name)) {
              const selectors = method.name().selectors ?? [];
              selectors.forEach((selector) => acc.push([selector, method.cooldown]));
            } else {
              method.name.forEach((x) => acc.push([x, method.cooldown]));
            }
            return acc;
          },
          []
        );
      }
      const isNewEscrow = escrow !== "" && !this.wallet.escrows.get(escrow) && !this.newEscrows.has(escrow);
      if (isNewEscrow) {
        this.newEscrows.add(escrow);
      }
      const controlledAddress = await this.wallet.client.state.global.controlledAddress();
      const hasExternalControlledAddress = controlledAddress !== this.wallet.client.appAddress.toString();
      const externalControlledFee = hasExternalControlledAddress ? 1000n : 0n;
      const extraFee = microAlgo((isNewEscrow ? NewEscrowFeeAmount : 0n) + externalControlledFee);
      const args = {
        plugin,
        caller,
        escrow,
        admin,
        delegationType,
        lastValid,
        cooldown,
        methods: transformedMethods,
        useRounds,
        useExecutionKey,
        coverFees,
        canReclaim,
        defaultToEscrow
      };
      if (name !== "") {
        this.group.arc58AddNamedPlugin({
          ...sendParams,
          args: { name, ...args },
          extraFee
        });
      } else {
        this.group.arc58AddPlugin({
          ...sendParams,
          args,
          extraFee
        });
      }
      if (allowances.length > 0) {
        if (escrow === "") {
          throw new Error("Allowances can only be added to plugins with an escrow");
        }
        const dedupedAllowances = allowances.filter((a) => {
          const key = `${escrow}:${a.asset}`;
          if (this.newAllowances.has(key)) return false;
          this.newAllowances.add(key);
          return true;
        });
        if (dedupedAllowances.length > 0) {
          this.group.arc58AddAllowances({
            ...sendParams,
            args: {
              escrow,
              allowances: AllowancesToTuple(dedupedAllowances)
            }
          });
        }
      }
      const pluginKey = { plugin, caller, escrow };
      const allowanceAssets = allowances.map((a) => a.asset);
      this.postProcessors.push(async () => {
        if (isNewEscrow) {
          await this.wallet.register({ sender, signer, escrow });
        }
        await this.wallet.updateCache(pluginKey, allowanceAssets).catch((error) => {
          console.warn("Failed to update plugin cache:", error);
        });
      });
    });
    return this;
  }
  usePlugin(params) {
    this.resolvers.push(async () => {
      const { group: tempGroup } = await this.wallet.prepareUsePlugin(params);
      const atc = (await (await tempGroup.composer()).build()).atc;
      const mainComposer = await this.group.composer();
      mainComposer.addAtc(atc);
    });
    return this;
  }
  // ---------------------------------------------------------------------------
  // Simple methods
  // ---------------------------------------------------------------------------
  register({ sender, signer, ...args }) {
    this.resolvers.push(async () => {
      this.group.register({ ...this.getSendParams({ sender, signer }), args });
    });
    return this;
  }
  changeRevocationApp({ sender, signer, app }) {
    this.resolvers.push(async () => {
      this.group.setRevocationApp({ ...this.getSendParams({ sender, signer }), args: { app } });
    });
    return this;
  }
  setNickname({ sender, signer, nickname }) {
    this.resolvers.push(async () => {
      this.group.setNickname({ ...this.getSendParams({ sender, signer }), args: { nickname } });
    });
    return this;
  }
  setAvatar({ sender, signer, avatar }) {
    this.resolvers.push(async () => {
      this.group.setAvatar({ ...this.getSendParams({ sender, signer }), args: { avatar } });
    });
    return this;
  }
  setBanner({ sender, signer, banner }) {
    this.resolvers.push(async () => {
      this.group.setBanner({ ...this.getSendParams({ sender, signer }), args: { banner } });
    });
    return this;
  }
  setBio({ sender, signer, bio }) {
    this.resolvers.push(async () => {
      this.group.setBio({ ...this.getSendParams({ sender, signer }), args: { bio } });
    });
    return this;
  }
  changeAdmin({ sender, signer, newAdmin }) {
    this.resolvers.push(async () => {
      this.group.arc58ChangeAdmin({ ...this.getSendParams({ sender, signer }), args: { newAdmin } });
    });
    return this;
  }
  verifyAuthAddress(params) {
    this.resolvers.push(async () => {
      this.group.arc58VerifyAuthAddress({ ...this.getSendParams(params), args: {} });
    });
    return this;
  }
  rekeyTo({ sender, signer, ...args }) {
    this.resolvers.push(async () => {
      this.group.arc58RekeyTo({ ...this.getSendParams({ sender, signer }), args });
    });
    return this;
  }
  canCall({ sender, signer, ...args }) {
    this.resolvers.push(async () => {
      this.group.arc58CanCall({ ...this.getSendParams({ sender, signer }), args });
    });
    return this;
  }
  removePlugin({ sender, signer, ...args }) {
    this.resolvers.push(async () => {
      this.group.arc58RemovePlugin({ ...this.getSendParams({ sender, signer }), args });
    });
    return this;
  }
  newEscrow({ sender, signer, ...args }) {
    this.resolvers.push(async () => {
      this.group.arc58NewEscrow({ ...this.getSendParams({ sender, signer }), args });
      this.newEscrows.add(args.escrow);
    });
    return this;
  }
  toggleEscrowLock({ sender, signer, ...args }) {
    this.resolvers.push(async () => {
      this.group.arc58ToggleEscrowLock({ ...this.getSendParams({ sender, signer }), args });
    });
    return this;
  }
  reclaimFunds({ sender, signer, ...args }) {
    this.resolvers.push(async () => {
      this.group.arc58Reclaim({ ...this.getSendParams({ sender, signer }), args });
    });
    return this;
  }
  optInEscrow({ sender, signer, ...args }) {
    this.resolvers.push(async () => {
      this.group.arc58OptInEscrow({ ...this.getSendParams({ sender, signer }), args });
    });
    return this;
  }
  addAllowances({ sender, signer, escrow, allowances }) {
    this.resolvers.push(async () => {
      this.group.arc58AddAllowances({
        ...this.getSendParams({ sender, signer }),
        args: { escrow, allowances: AllowancesToTuple(allowances) }
      });
    });
    return this;
  }
  removeAllowances({ sender, signer, ...args }) {
    this.resolvers.push(async () => {
      this.group.arc58RemoveAllowances({ ...this.getSendParams({ sender, signer }), args });
    });
    return this;
  }
  addExecutionKey({ sender, signer, ...args }) {
    this.resolvers.push(async () => {
      this.group.arc58AddExecutionKey({ ...this.getSendParams({ sender, signer }), args });
    });
    return this;
  }
  removeExecutionKey({ sender, signer, ...args }) {
    this.resolvers.push(async () => {
      this.group.arc58RemoveExecutionKey({ ...this.getSendParams({ sender, signer }), args });
    });
    return this;
  }
  // ---------------------------------------------------------------------------
  // Terminal
  // ---------------------------------------------------------------------------
  async send(params) {
    for (const resolver of this.resolvers) {
      await resolver();
    }
    const built = await (await this.group.composer()).build();
    const atc = built.atc;
    const length = built.transactions.length;
    const suggestedParams = await this.wallet.client.algorand.getSuggestedParams();
    const maxFees = new Map(
      Array.from({ length }, (_, i) => [i, microAlgo(BigInt(suggestedParams.minFee) * 272n)])
    );
    const { atc: populatedAtc } = await prepareGroupWithCost(
      atc,
      this.wallet.client.algorand.client.algod,
      {
        coverAppCallInnerTransactionFees: true,
        populateAppCallResources: true
      },
      {
        maxFees,
        suggestedParams
      }
    );
    const { coverAppCallInnerTransactionFees, populateAppCallResources, ...sendParams } = params ?? {};
    const result = await this.wallet.client.algorand.newGroup().addAtc(populatedAtc).send(sendParams);
    for (const postProcessor of this.postProcessors) {
      await postProcessor();
    }
    return result;
  }
};

// src/generated/AbstractedAccountFactoryClient.ts
import { getArc56ReturnValue as getArc56ReturnValue2 } from "@algorandfoundation/algokit-utils/types/app-arc56";
import {
  AppClient as _AppClient2
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory2 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC2 = { "name": "AbstractedAccountFactory", "structs": {}, "methods": [{ "name": "create", "args": [{ "type": "uint64", "name": "akitaDAO" }, { "type": "uint64", "name": "akitaDAOEscrow" }, { "type": "string", "name": "version" }, { "type": "uint64", "name": "escrowFactory" }, { "type": "uint64", "name": "revocation" }, { "type": "string", "name": "domain" }], "returns": { "type": "void" }, "actions": { "create": ["NoOp"], "call": [] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "updateRevocation", "args": [{ "type": "uint64", "name": "app" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "newAccount", "args": [{ "type": "pay", "name": "payment" }, { "type": "address", "name": "controlledAddress" }, { "type": "address", "name": "admin" }, { "type": "string", "name": "nickname" }, { "type": "address", "name": "referrer" }], "returns": { "type": "uint64" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "cost", "args": [], "returns": { "type": "uint64" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": true, "events": [], "recommendations": {} }, { "name": "updateWallet", "args": [{ "type": "uint64", "name": "wallet", "desc": "The wallet application to update" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Permanent: Update a wallet's bytecode. The caller must be the wallet's admin.\nThe factory sends the update inner txn as itself (factory address), which the\nwallet accepts because Txn.sender === factoryApp.address.", "events": [], "recommendations": {} }, { "name": "initBoxedContract", "args": [{ "type": "string", "name": "version" }, { "type": "uint64", "name": "size" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "loadBoxedContract", "args": [{ "type": "uint64", "name": "offset" }, { "type": "byte[]", "name": "data" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "deleteBoxedContract", "args": [], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "optIn", "args": [{ "type": "pay", "name": "payment", "desc": "The payment transaction" }, { "type": "uint64", "name": "asset", "desc": "The asset to be opted into" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "optin tells the contract to opt into an asa", "events": [], "recommendations": {} }, { "name": "optInCost", "args": [{ "type": "uint64", "name": "asset" }], "returns": { "type": "uint64" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": true, "events": [], "recommendations": {} }, { "name": "updateAkitaDAOEscrow", "args": [{ "type": "uint64", "name": "app" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "update", "args": [{ "type": "string", "name": "newVersion" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["UpdateApplication"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "updateAkitaDAO", "args": [{ "type": "uint64", "name": "akitaDAO" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "opUp", "args": [], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 4, "bytes": 3 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": { "escrowFactory": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "ZXNjcm93X2ZhY3Rvcnk=", "desc": "the escrow factory app" }, "revocation": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "cmV2b2NhdGlvbg==", "desc": "the default app thats allowed to revoke plugins" }, "domain": { "keyType": "AVMString", "valueType": "AVMString", "key": "ZG9tYWlu", "desc": "domain" }, "childContractVersion": { "keyType": "AVMString", "valueType": "AVMString", "key": "Y2hpbGRfY29udHJhY3RfdmVyc2lvbg==", "desc": "the current version of the child contract" }, "akitaDAOEscrow": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "YWtpdGFfZXNjcm93", "desc": "the app ID for the akita DAO escrow to use" }, "version": { "keyType": "AVMString", "valueType": "AVMString", "key": "dmVyc2lvbg==", "desc": "the current version of the contract" }, "akitaDAO": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "YWtpdGFfZGFv", "desc": "the app ID of the Akita DAO" } }, "local": {}, "box": { "boxedContract": { "keyType": "AVMString", "valueType": "AVMBytes", "key": "YmM=" } } }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": [], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [648, 1185], "errorMessage": "Box must have value" }, { "pc": [334, 1035], "errorMessage": "Bytes has valid prefix" }, { "pc": [1431], "errorMessage": "Contract not set" }, { "pc": [1656], "errorMessage": "Invalid app upgrade" }, { "pc": [1426], "errorMessage": "Invalid call order" }, { "pc": [645, 1519], "errorMessage": "Invalid payment" }, { "pc": [898], "errorMessage": "Invalid percentage" }, { "pc": [158], "errorMessage": "OnCompletion must be NoOp" }, { "pc": [279], "errorMessage": "OnCompletion must be UpdateApplication && can only call when not creating" }, { "pc": [535, 1309, 1329, 1457, 1603, 1642, 1685], "errorMessage": "Only the Akita DAO can call this function" }, { "pc": [533, 790, 821, 971, 1327, 1455, 1493, 1561, 1601, 1638, 1683], "errorMessage": "application exists" }, { "pc": [527, 601, 669, 681, 687, 700, 706, 818, 853, 1100, 1116, 1130, 1213, 1321, 1449, 1485, 1490, 1553, 1558, 1595, 1631, 1677], "errorMessage": "check GlobalState exists" }, { "pc": [343, 1358], "errorMessage": "invalid number of bytes for (len+uint8[])" }, { "pc": [445, 479, 588, 1279, 1622], "errorMessage": "invalid number of bytes for (len+utf8[])" }, { "pc": [422, 431, 456, 465, 520, 1040, 1163, 1290, 1343, 1480, 1548, 1588, 1670], "errorMessage": "invalid number of bytes for uint64" }, { "pc": [566, 575, 597], "errorMessage": "invalid number of bytes for uint8[32]" }, { "pc": [557, 1472], "errorMessage": "transaction type is pay" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDggMiA0MDk2IDExMTg2MDAgMTAwMDAwCiAgICBieXRlY2Jsb2NrICJha2l0YV9kYW8iICJiYyIgIndhbGxldCIgMHgxNTFmN2M3NSAiYWtpdGFfZXNjcm93IiAicmV2b2NhdGlvbiIgIndhbGxldF9mZWVzIiAiY2hpbGRfY29udHJhY3RfdmVyc2lvbiIgMHhlYTkxODBkZCAweGM1M2IzMmNjICJ2ZXJzaW9uIiAiZXNjcm93X2ZhY3RvcnkiICJkb21haW4iIGJhc2U2NChDNEVCUXc9PSkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czozMQogICAgLy8gZXhwb3J0IGNsYXNzIEFic3RyYWN0ZWRBY2NvdW50RmFjdG9yeSBleHRlbmRzIEZhY3RvcnlDb250cmFjdCB7CiAgICBieXRlYyA4IC8vIG1ldGhvZCAidXBkYXRlKHN0cmluZyl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggbWFpbl91cGRhdGVfcm91dGVAMgoKbWFpbl9zd2l0Y2hfY2FzZV9uZXh0QDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6MzEKICAgIC8vIGV4cG9ydCBjbGFzcyBBYnN0cmFjdGVkQWNjb3VudEZhY3RvcnkgZXh0ZW5kcyBGYWN0b3J5Q29udHJhY3QgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBieiBtYWluX2NyZWF0ZV9Ob09wQDE4CiAgICBwdXNoYnl0ZXNzIDB4MDhkMzFkZTQgMHgzNzQ4NTU0MSAweDliNjdmYTZkIDB4MDFlMjJmM2YgLy8gbWV0aG9kICJ1cGRhdGVSZXZvY2F0aW9uKHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJuZXdBY2NvdW50KHBheSxhZGRyZXNzLGFkZHJlc3Msc3RyaW5nLGFkZHJlc3MpdWludDY0IiwgbWV0aG9kICJjb3N0KCl1aW50NjQiLCBtZXRob2QgInVwZGF0ZVdhbGxldCh1aW50NjQpdm9pZCIKICAgIGJ5dGVjIDkgLy8gbWV0aG9kICJpbml0Qm94ZWRDb250cmFjdChzdHJpbmcsdWludDY0KXZvaWQiCiAgICBwdXNoYnl0ZXNzIDB4ZGNhMmQ4NjIgMHhkMzQ2YjFhNCAweDM5NGVhZWIyIDB4MzNmNzg4MDggMHgxZWFkMjBhOSAweDMzZTkyYzk0IDB4ODU0ZGVkZTAgLy8gbWV0aG9kICJsb2FkQm94ZWRDb250cmFjdCh1aW50NjQsYnl0ZVtdKXZvaWQiLCBtZXRob2QgImRlbGV0ZUJveGVkQ29udHJhY3QoKXZvaWQiLCBtZXRob2QgIm9wdEluKHBheSx1aW50NjQpdm9pZCIsIG1ldGhvZCAib3B0SW5Db3N0KHVpbnQ2NCl1aW50NjQiLCBtZXRob2QgInVwZGF0ZUFraXRhREFPRXNjcm93KHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJ1cGRhdGVBa2l0YURBTyh1aW50NjQpdm9pZCIsIG1ldGhvZCAib3BVcCgpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIHVwZGF0ZVJldm9jYXRpb24gbmV3QWNjb3VudCBjb3N0IHVwZGF0ZVdhbGxldCBpbml0Qm94ZWRDb250cmFjdCBsb2FkQm94ZWRDb250cmFjdCBkZWxldGVCb3hlZENvbnRyYWN0IG9wdEluIG9wdEluQ29zdCB1cGRhdGVBa2l0YURBT0VzY3JvdyB1cGRhdGVBa2l0YURBTyBtYWluX29wVXBfcm91dGVAMTYKICAgIGVycgoKbWFpbl9vcFVwX3JvdXRlQDE2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NDMKICAgIC8vIG9wVXAoKTogdm9pZCB7IH0KICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fY3JlYXRlX05vT3BAMTg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6MzEKICAgIC8vIGV4cG9ydCBjbGFzcyBBYnN0cmFjdGVkQWNjb3VudEZhY3RvcnkgZXh0ZW5kcyBGYWN0b3J5Q29udHJhY3QgewogICAgcHVzaGJ5dGVzIDB4MDYxMDdhMGYgLy8gbWV0aG9kICJjcmVhdGUodWludDY0LHVpbnQ2NCxzdHJpbmcsdWludDY0LHVpbnQ2NCxzdHJpbmcpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIGNyZWF0ZQogICAgZXJyCgptYWluX3VwZGF0ZV9yb3V0ZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NDgKICAgIC8vIEBhYmltZXRob2QoeyBhbGxvd0FjdGlvbnM6IFsnVXBkYXRlQXBwbGljYXRpb24nXSB9KQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgcHVzaGludCA0IC8vIFVwZGF0ZUFwcGxpY2F0aW9uCiAgICA9PQogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICYmCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIG11c3QgYmUgVXBkYXRlQXBwbGljYXRpb24gJiYgY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgYiB1cGRhdGUKCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjpnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU8oYWtpdGFEQU86IHVpbnQ2NCwgYWRkcmVzczogYnl0ZXMpIC0+IHVpbnQ2NDoKZ2V0V2FsbGV0SURVc2luZ0FraXRhREFPOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNzYKICAgIC8vIGV4cG9ydCBmdW5jdGlvbiBnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU8oYWtpdGFEQU86IEFwcGxpY2F0aW9uLCBhZGRyZXNzOiBBY2NvdW50KTogQXBwbGljYXRpb24gewogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjU1CiAgICAvLyBjb25zdCBbb3RoZXJBcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzT3RoZXJBcHBMaXN0KSkKICAgIGZyYW1lX2RpZyAtMgogICAgcHVzaGJ5dGVzICJvYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjYwCiAgICAvLyByZXR1cm4gZ2V0T3RoZXJBcHBMaXN0KGFraXRhREFPKS5lc2Nyb3cKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE4Mi0xODUKICAgIC8vIGNvbnN0IGRhdGEgPSBhYmlDYWxsPHR5cGVvZiBFc2Nyb3dGYWN0b3J5LnByb3RvdHlwZS5nZXQ+KHsKICAgIC8vICAgYXBwSWQ6IGVzY3Jvd0ZhY3RvcnksCiAgICAvLyAgIGFyZ3M6IFthZGRyZXNzXQogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIHB1c2hieXRlcyAweDNjMWE2ZjMzIC8vIG1ldGhvZCAiZ2V0KGFkZHJlc3MpYnl0ZVtdIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgZGlnIDEKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18zIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBzd2FwCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdWludDhbXSkKICAgIGV4dHJhY3QgNiAwCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTg3CiAgICAvLyBpZiAoQnl0ZXMoZGF0YSkubGVuZ3RoID09PSAwIHx8IEJ5dGVzKGRhdGEpLmxlbmd0aCAhPT0gOCkgewogICAgbGVuCiAgICBkdXAKICAgIGJ6IGdldFdhbGxldElEVXNpbmdBa2l0YURBT19pZl9ib2R5QDYKICAgIGZyYW1lX2RpZyAxCiAgICBpbnRjXzIgLy8gOAogICAgIT0KICAgIGJ6IGdldFdhbGxldElEVXNpbmdBa2l0YURBT19hZnRlcl9pZl9lbHNlQDcKCmdldFdhbGxldElEVXNpbmdBa2l0YURBT19pZl9ib2R5QDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE4OAogICAgLy8gcmV0dXJuIDAKICAgIGludGNfMCAvLyAwCgpnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU9fYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjpnZXRXYWxsZXRJREA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNzgKICAgIC8vIHJldHVybiBBcHBsaWNhdGlvbihnZXRXYWxsZXRJRChlc2Nyb3dGYWN0b3J5LCBhZGRyZXNzKSkKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU9fYWZ0ZXJfaWZfZWxzZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxOTEKICAgIC8vIHJldHVybiBidG9pKGRhdGEpCiAgICBmcmFtZV9kaWcgMAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNzgKICAgIC8vIHJldHVybiBBcHBsaWNhdGlvbihnZXRXYWxsZXRJRChlc2Nyb3dGYWN0b3J5LCBhZGRyZXNzKSkKICAgIGIgZ2V0V2FsbGV0SURVc2luZ0FraXRhREFPX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6Z2V0V2FsbGV0SURAOAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OnNwbGl0T3B0SW5Db3VudChha2l0YURBTzogdWludDY0LCBlc2Nyb3c6IGJ5dGVzLCBhc3NldDogdWludDY0KSAtPiB1aW50NjQ6CnNwbGl0T3B0SW5Db3VudDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NTg3CiAgICAvLyBleHBvcnQgZnVuY3Rpb24gc3BsaXRPcHRJbkNvdW50KGFraXRhREFPOiBBcHBsaWNhdGlvbiwgZXNjcm93OiBBY2NvdW50LCBhc3NldDogQXNzZXQpOiB1aW50NjQgewogICAgcHJvdG8gMyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjU4OAogICAgLy8gbGV0IGNvdW50OiB1aW50NjQgPSAwCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo1OTAKICAgIC8vIGlmICghZXNjcm93LmlzT3B0ZWRJbihhc3NldCkpIHsKICAgIGZyYW1lX2RpZyAtMgogICAgZnJhbWVfZGlnIC0xCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYm56IHNwbGl0T3B0SW5Db3VudF9hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OTkKICAgIC8vIGNvbnN0IFtzcGxpdHNCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNSZXZlbnVlU3BsaXRzKSkKICAgIGZyYW1lX2RpZyAtMwogICAgcHVzaGJ5dGVzICJyZXZlbnVlX3NwbGl0cyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NTk0CiAgICAvLyBjb3VudCArPSBzcGxpdHMubGVuZ3RoCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NTkxCiAgICAvLyBjb3VudCArPSAxCiAgICBpbnRjXzEgLy8gMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo1OTQKICAgIC8vIGNvdW50ICs9IHNwbGl0cy5sZW5ndGgKICAgICsKICAgIGZyYW1lX2J1cnkgMAoKc3BsaXRPcHRJbkNvdW50X2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NTk3CiAgICAvLyByZXR1cm4gY291bnQKICAgIGZyYW1lX2RpZyAwCiAgICBzd2FwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50RmFjdG9yeS5jcmVhdGVbcm91dGluZ10oKSAtPiB2b2lkOgpjcmVhdGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6NDQKICAgIC8vIEBhYmltZXRob2QoeyBvbkNyZWF0ZTogJ3JlcXVpcmUnIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1dGY4W10pCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA2CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjUzCiAgICAvLyB0aGlzLmFraXRhREFPLnZhbHVlID0gYWtpdGFEQU8KICAgIHVuY292ZXIgNgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjY1CiAgICAvLyBha2l0YURBT0VzY3JvdyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YUVzY3JvdyB9KQogICAgYnl0ZWMgNCAvLyAiYWtpdGFfZXNjcm93IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjU0CiAgICAvLyB0aGlzLmFraXRhREFPRXNjcm93LnZhbHVlID0gYWtpdGFEQU9Fc2Nyb3cKICAgIHVuY292ZXIgNQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI3CiAgICAvLyB2ZXJzaW9uID0gR2xvYmFsU3RhdGU8c3RyaW5nPih7IGtleTogR2xvYmFsU3RhdGVLZXlWZXJzaW9uIH0pCiAgICBieXRlYyAxMCAvLyAidmVyc2lvbiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czo1NQogICAgLy8gdGhpcy52ZXJzaW9uLnZhbHVlID0gdmVyc2lvbgogICAgdW5jb3ZlciA0CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjM2CiAgICAvLyBlc2Nyb3dGYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUVzY3Jvd0ZhY3RvcnkgfSkKICAgIGJ5dGVjIDExIC8vICJlc2Nyb3dfZmFjdG9yeSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czo1NgogICAgLy8gdGhpcy5lc2Nyb3dGYWN0b3J5LnZhbHVlID0gZXNjcm93RmFjdG9yeQogICAgdW5jb3ZlciAzCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjM4CiAgICAvLyByZXZvY2F0aW9uID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleVJldm9jYXRpb24gfSkKICAgIGJ5dGVjIDUgLy8gInJldm9jYXRpb24iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6NTcKICAgIC8vIHRoaXMucmV2b2NhdGlvbi52YWx1ZSA9IHJldm9jYXRpb24KICAgIHVuY292ZXIgMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czo0MAogICAgLy8gZG9tYWluID0gR2xvYmFsU3RhdGU8c3RyaW5nPih7IGtleTogQWJzdHJhY3RlZEFjY291bnRGYWN0b3J5R2xvYmFsU3RhdGVLZXlEb21haW4gfSkKICAgIGJ5dGVjIDEyIC8vICJkb21haW4iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6NTgKICAgIC8vIHRoaXMuZG9tYWluLnZhbHVlID0gZG9tYWluCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjQ0CiAgICAvLyBAYWJpbWV0aG9kKHsgb25DcmVhdGU6ICdyZXF1aXJlJyB9KQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnRGYWN0b3J5LnVwZGF0ZVJldm9jYXRpb25bcm91dGluZ10oKSAtPiB2b2lkOgp1cGRhdGVSZXZvY2F0aW9uOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjYzCiAgICAvLyB1cGRhdGVSZXZvY2F0aW9uKGFwcDogQXBwbGljYXRpb24pOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6NjQKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSB0aGlzLmdldEFraXRhREFPV2FsbGV0KCkuYWRkcmVzcywgRVJSX05PVF9BS0lUQV9EQU8pCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozMgogICAgLy8gY29uc3QgW3dhbGxldElEXSA9IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NCh0aGlzLmFraXRhREFPLnZhbHVlLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1dhbGxldCkpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozMgogICAgLy8gY29uc3QgW3dhbGxldElEXSA9IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NCh0aGlzLmFraXRhREFPLnZhbHVlLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1dhbGxldCkpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYnl0ZWNfMiAvLyAid2FsbGV0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjY0CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5nZXRBa2l0YURBT1dhbGxldCgpLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IHRoZSBBa2l0YSBEQU8gY2FuIGNhbGwgdGhpcyBmdW5jdGlvbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjM4CiAgICAvLyByZXZvY2F0aW9uID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleVJldm9jYXRpb24gfSkKICAgIGJ5dGVjIDUgLy8gInJldm9jYXRpb24iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6NjUKICAgIC8vIHRoaXMucmV2b2NhdGlvbi52YWx1ZSA9IGFwcAogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czo2MwogICAgLy8gdXBkYXRlUmV2b2NhdGlvbihhcHA6IEFwcGxpY2F0aW9uKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjpBYnN0cmFjdGVkQWNjb3VudEZhY3RvcnkubmV3QWNjb3VudFtyb3V0aW5nXSgpIC0+IHZvaWQ6Cm5ld0FjY291bnQ6CiAgICBpbnRjXzAgLy8gMAogICAgZHVwCiAgICBwdXNoYnl0ZXMgIiIKICAgIGR1cG4gNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjY4LTc0CiAgICAvLyBuZXdBY2NvdW50KAogICAgLy8gICBwYXltZW50OiBndHhuLlBheW1lbnRUeG4sCiAgICAvLyAgIGNvbnRyb2xsZWRBZGRyZXNzOiBBY2NvdW50LAogICAgLy8gICBhZG1pbjogQWNjb3VudCwKICAgIC8vICAgbmlja25hbWU6IHN0cmluZywKICAgIC8vICAgcmVmZXJyZXI6IEFjY291bnQKICAgIC8vICk6IHVpbnQ2NCB7CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cG4gMgogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgc3dhcAogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czo3OAogICAgLy8gY29uc3QgY3JlYXRpb25GZWUgPSBnZXRXYWxsZXRGZWVzKHRoaXMuYWtpdGFEQU8udmFsdWUpLmNyZWF0ZUZlZQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjc4CiAgICAvLyBjb25zdCBjcmVhdGlvbkZlZSA9IGdldFdhbGxldEZlZXModGhpcy5ha2l0YURBTy52YWx1ZSkuY3JlYXRlRmVlCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo2NAogICAgLy8gY29uc3QgW3dhbGxldEZlZXNCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXRGZWVzKSkKICAgIGJ5dGVjIDYgLy8gIndhbGxldF9mZWVzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjc4CiAgICAvLyBjb25zdCBjcmVhdGlvbkZlZSA9IGdldFdhbGxldEZlZXModGhpcy5ha2l0YURBTy52YWx1ZSkuY3JlYXRlRmVlCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjg0CiAgICAvLyBHbG9iYWwubWluQmFsYW5jZSArIC8vIDEwMF8wMDAKICAgIGdsb2JhbCBNaW5CYWxhbmNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6ODEtODUKICAgIC8vIE1BWF9QUk9HUkFNX1BBR0VTICsgLy8gMzAwXzAwMAogICAgLy8gKEdMT0JBTF9TVEFURV9LRVlfVUlOVF9DT1NUICogYWJzdHJhY3RlZEFjY291bnQuZ2xvYmFsVWludHMpICsgLy8gMjU2XzUwMAogICAgLy8gKEdMT0JBTF9TVEFURV9LRVlfQllURVNfQ09TVCAqIGFic3RyYWN0ZWRBY2NvdW50Lmdsb2JhbEJ5dGVzKSArIC8vIDg1MF8wMDAKICAgIC8vIEdsb2JhbC5taW5CYWxhbmNlICsgLy8gMTAwXzAwMAogICAgLy8gQVJDNThXYWxsZXRJRHNCeUFjY291bnRzTWJyICsgLy8gMTJfMTAwCiAgICBpbnRjIDUgLy8gMTExODYwMAogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjgxLTg2CiAgICAvLyBNQVhfUFJPR1JBTV9QQUdFUyArIC8vIDMwMF8wMDAKICAgIC8vIChHTE9CQUxfU1RBVEVfS0VZX1VJTlRfQ09TVCAqIGFic3RyYWN0ZWRBY2NvdW50Lmdsb2JhbFVpbnRzKSArIC8vIDI1Nl81MDAKICAgIC8vIChHTE9CQUxfU1RBVEVfS0VZX0JZVEVTX0NPU1QgKiBhYnN0cmFjdGVkQWNjb3VudC5nbG9iYWxCeXRlcykgKyAvLyA4NTBfMDAwCiAgICAvLyBHbG9iYWwubWluQmFsYW5jZSArIC8vIDEwMF8wMDAKICAgIC8vIEFSQzU4V2FsbGV0SURzQnlBY2NvdW50c01iciArIC8vIDEyXzEwMAogICAgLy8gY3JlYXRpb25GZWUKICAgIGRpZyAxCiAgICArCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6OTAKICAgIC8vIGxldCByZWZlcnJhbE1icjogdWludDY0ID0gMDsKICAgIGludGNfMCAvLyAwCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6OTEKICAgIC8vIGlmIChjcmVhdGlvbkZlZSA+IDApIHsKICAgIGJueiBuZXdBY2NvdW50X2lmX2JvZHlAMgogICAgZGlnIDIKICAgIGJ1cnkgMTIKCm5ld0FjY291bnRfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjk1LTEwMgogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIHBheW1lbnQsCiAgICAvLyAgIHsKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50OiBjaGlsZE1CUiArIHJlZmVycmFsTWJyLAogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICBkaWcgNwogICAgZHVwCiAgICBndHhucyBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjk4CiAgICAvLyByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjk1LTEwMgogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIHBheW1lbnQsCiAgICAvLyAgIHsKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50OiBjaGlsZE1CUiArIHJlZmVycmFsTWJyLAogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICA9PQogICAgc3dhcAogICAgZ3R4bnMgQW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6OTkKICAgIC8vIGFtb3VudDogY2hpbGRNQlIgKyByZWZlcnJhbE1iciwKICAgIGRpZyAzCiAgICBkaWcgMwogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjk1LTEwMgogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIHBheW1lbnQsCiAgICAvLyAgIHsKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50OiBjaGlsZE1CUiArIHJlZmVycmFsTWJyLAogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICA9PQogICAgJiYKICAgIGFzc2VydCAvLyBJbnZhbGlkIHBheW1lbnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjM4CiAgICAvLyBib3hlZENvbnRyYWN0ID0gQm94PGJ5dGVzPih7IGtleTogQm94S2V5Qm94ZWRDb250cmFjdCB9KQogICAgYnl0ZWNfMSAvLyAiYmMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6MTA0CiAgICAvLyBjb25zdCBhcHByb3ZhbFNpemUgPSB0aGlzLmJveGVkQ29udHJhY3QubGVuZ3RoCiAgICBib3hfbGVuCiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2ZhY3RvcnkudHM6MzgKICAgIC8vIGJveGVkQ29udHJhY3QgPSBCb3g8Ynl0ZXM+KHsga2V5OiBCb3hLZXlCb3hlZENvbnRyYWN0IH0pCiAgICBieXRlY18xIC8vICJiYyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxMDUKICAgIC8vIGNvbnN0IGNodW5rMSA9IHRoaXMuYm94ZWRDb250cmFjdC5leHRyYWN0KDAsIDQwOTYpCiAgICBpbnRjXzAgLy8gMAogICAgaW50YyA0IC8vIDQwOTYKICAgIGJveF9leHRyYWN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6MTA2CiAgICAvLyBjb25zdCBjaHVuazIgPSB0aGlzLmJveGVkQ29udHJhY3QuZXh0cmFjdCg0MDk2LCBhcHByb3ZhbFNpemUgLSA0MDk2KQogICAgc3dhcAogICAgaW50YyA0IC8vIDQwOTYKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjM4CiAgICAvLyBib3hlZENvbnRyYWN0ID0gQm94PGJ5dGVzPih7IGtleTogQm94S2V5Qm94ZWRDb250cmFjdCB9KQogICAgYnl0ZWNfMSAvLyAiYmMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6MTA2CiAgICAvLyBjb25zdCBjaHVuazIgPSB0aGlzLmJveGVkQ29udHJhY3QuZXh0cmFjdCg0MDk2LCBhcHByb3ZhbFNpemUgLSA0MDk2KQogICAgaW50YyA0IC8vIDQwOTYKICAgIHVuY292ZXIgMgogICAgYm94X2V4dHJhY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxMDgtMTI0CiAgICAvLyBjb25zdCB3YWxsZXRJRCA9IGFic3RyYWN0ZWRBY2NvdW50LmNhbGwKICAgIC8vICAgLmNyZWF0ZSh7CiAgICAvLyAgICAgYXJnczogWwogICAgLy8gICAgICAgdGhpcy5jaGlsZENvbnRyYWN0VmVyc2lvbi52YWx1ZSwKICAgIC8vICAgICAgIHRoaXMuYWtpdGFEQU8udmFsdWUuaWQsCiAgICAvLyAgICAgICBjb250cm9sbGVkQWRkcmVzcywKICAgIC8vICAgICAgIGFkbWluLAogICAgLy8gICAgICAgdGhpcy5kb21haW4udmFsdWUsCiAgICAvLyAgICAgICB0aGlzLmVzY3Jvd0ZhY3RvcnkudmFsdWUuaWQsCiAgICAvLyAgICAgICB0aGlzLnJldm9jYXRpb24udmFsdWUuaWQsCiAgICAvLyAgICAgICBuaWNrbmFtZSwKICAgIC8vICAgICAgIHJlZmVycmVyCiAgICAvLyAgICAgXSwKICAgIC8vICAgICBhcHByb3ZhbFByb2dyYW06IFtjaHVuazEsIGNodW5rMl0sCiAgICAvLyAgICAgY2xlYXJTdGF0ZVByb2dyYW06IGFic3RyYWN0ZWRBY2NvdW50LmNsZWFyU3RhdGVQcm9ncmFtLAogICAgLy8gICAgIGV4dHJhUHJvZ3JhbVBhZ2VzOiAzCiAgICAvLyAgIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6MTExCiAgICAvLyB0aGlzLmNoaWxkQ29udHJhY3RWZXJzaW9uLnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjM0CiAgICAvLyBjaGlsZENvbnRyYWN0VmVyc2lvbiA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IEJhc2VGYWN0b3J5R2xvYmFsU3RhdGVLZXlDaGlsZENvbnRyYWN0VmVyc2lvbiB9KQogICAgYnl0ZWMgNyAvLyAiY2hpbGRfY29udHJhY3RfdmVyc2lvbiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxMTEKICAgIC8vIHRoaXMuY2hpbGRDb250cmFjdFZlcnNpb24udmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxMTIKICAgIC8vIHRoaXMuYWtpdGFEQU8udmFsdWUuaWQsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6MTEyCiAgICAvLyB0aGlzLmFraXRhREFPLnZhbHVlLmlkLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxMTUKICAgIC8vIHRoaXMuZG9tYWluLnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czo0MAogICAgLy8gZG9tYWluID0gR2xvYmFsU3RhdGU8c3RyaW5nPih7IGtleTogQWJzdHJhY3RlZEFjY291bnRGYWN0b3J5R2xvYmFsU3RhdGVLZXlEb21haW4gfSkKICAgIGJ5dGVjIDEyIC8vICJkb21haW4iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6MTE1CiAgICAvLyB0aGlzLmRvbWFpbi52YWx1ZSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjExNgogICAgLy8gdGhpcy5lc2Nyb3dGYWN0b3J5LnZhbHVlLmlkLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czozNgogICAgLy8gZXNjcm93RmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlFc2Nyb3dGYWN0b3J5IH0pCiAgICBieXRlYyAxMSAvLyAiZXNjcm93X2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6MTE2CiAgICAvLyB0aGlzLmVzY3Jvd0ZhY3RvcnkudmFsdWUuaWQsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjExNwogICAgLy8gdGhpcy5yZXZvY2F0aW9uLnZhbHVlLmlkLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czozOAogICAgLy8gcmV2b2NhdGlvbiA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlSZXZvY2F0aW9uIH0pCiAgICBieXRlYyA1IC8vICJyZXZvY2F0aW9uIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjExNwogICAgLy8gdGhpcy5yZXZvY2F0aW9uLnZhbHVlLmlkLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxMDgtMTI0CiAgICAvLyBjb25zdCB3YWxsZXRJRCA9IGFic3RyYWN0ZWRBY2NvdW50LmNhbGwKICAgIC8vICAgLmNyZWF0ZSh7CiAgICAvLyAgICAgYXJnczogWwogICAgLy8gICAgICAgdGhpcy5jaGlsZENvbnRyYWN0VmVyc2lvbi52YWx1ZSwKICAgIC8vICAgICAgIHRoaXMuYWtpdGFEQU8udmFsdWUuaWQsCiAgICAvLyAgICAgICBjb250cm9sbGVkQWRkcmVzcywKICAgIC8vICAgICAgIGFkbWluLAogICAgLy8gICAgICAgdGhpcy5kb21haW4udmFsdWUsCiAgICAvLyAgICAgICB0aGlzLmVzY3Jvd0ZhY3RvcnkudmFsdWUuaWQsCiAgICAvLyAgICAgICB0aGlzLnJldm9jYXRpb24udmFsdWUuaWQsCiAgICAvLyAgICAgICBuaWNrbmFtZSwKICAgIC8vICAgICAgIHJlZmVycmVyCiAgICAvLyAgICAgXSwKICAgIC8vICAgICBhcHByb3ZhbFByb2dyYW06IFtjaHVuazEsIGNodW5rMl0sCiAgICAvLyAgICAgY2xlYXJTdGF0ZVByb2dyYW06IGFic3RyYWN0ZWRBY2NvdW50LmNsZWFyU3RhdGVQcm9ncmFtLAogICAgLy8gICAgIGV4dHJhUHJvZ3JhbVBhZ2VzOiAzCiAgICAvLyAgIH0pCiAgICBwdXNoYnl0ZXMgMHhhM2RiZDM3NyAvLyBtZXRob2QgImNyZWF0ZShzdHJpbmcsdWludDY0LGFkZHJlc3MsYWRkcmVzcyxzdHJpbmcsdWludDY0LHVpbnQ2NCxzdHJpbmcsYWRkcmVzcyl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDYKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czo3NgogICAgLy8gY29uc3QgYWJzdHJhY3RlZEFjY291bnQgPSBjb21waWxlQXJjNChBYnN0cmFjdGVkQWNjb3VudCkKICAgIHB1c2hpbnQgOSAvLyA5CiAgICBpdHhuX2ZpZWxkIEdsb2JhbE51bUJ5dGVTbGljZQogICAgcHVzaGludCA5IC8vIDkKICAgIGl0eG5fZmllbGQgR2xvYmFsTnVtVWludAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjEwOC0xMjQKICAgIC8vIGNvbnN0IHdhbGxldElEID0gYWJzdHJhY3RlZEFjY291bnQuY2FsbAogICAgLy8gICAuY3JlYXRlKHsKICAgIC8vICAgICBhcmdzOiBbCiAgICAvLyAgICAgICB0aGlzLmNoaWxkQ29udHJhY3RWZXJzaW9uLnZhbHVlLAogICAgLy8gICAgICAgdGhpcy5ha2l0YURBTy52YWx1ZS5pZCwKICAgIC8vICAgICAgIGNvbnRyb2xsZWRBZGRyZXNzLAogICAgLy8gICAgICAgYWRtaW4sCiAgICAvLyAgICAgICB0aGlzLmRvbWFpbi52YWx1ZSwKICAgIC8vICAgICAgIHRoaXMuZXNjcm93RmFjdG9yeS52YWx1ZS5pZCwKICAgIC8vICAgICAgIHRoaXMucmV2b2NhdGlvbi52YWx1ZS5pZCwKICAgIC8vICAgICAgIG5pY2tuYW1lLAogICAgLy8gICAgICAgcmVmZXJyZXIKICAgIC8vICAgICBdLAogICAgLy8gICAgIGFwcHJvdmFsUHJvZ3JhbTogW2NodW5rMSwgY2h1bmsyXSwKICAgIC8vICAgICBjbGVhclN0YXRlUHJvZ3JhbTogYWJzdHJhY3RlZEFjY291bnQuY2xlYXJTdGF0ZVByb2dyYW0sCiAgICAvLyAgICAgZXh0cmFQcm9ncmFtUGFnZXM6IDMKICAgIC8vICAgfSkKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjEyMwogICAgLy8gZXh0cmFQcm9ncmFtUGFnZXM6IDMKICAgIHB1c2hpbnQgMyAvLyAzCiAgICBpdHhuX2ZpZWxkIEV4dHJhUHJvZ3JhbVBhZ2VzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6NzYKICAgIC8vIGNvbnN0IGFic3RyYWN0ZWRBY2NvdW50ID0gY29tcGlsZUFyYzQoQWJzdHJhY3RlZEFjY291bnQpCiAgICBieXRlYyAxMyAvLyBiYXNlNjQoQzRFQlF3PT0pCiAgICBpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtUGFnZXMKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtUGFnZXMKICAgIGl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtUGFnZXMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxMDgtMTI0CiAgICAvLyBjb25zdCB3YWxsZXRJRCA9IGFic3RyYWN0ZWRBY2NvdW50LmNhbGwKICAgIC8vICAgLmNyZWF0ZSh7CiAgICAvLyAgICAgYXJnczogWwogICAgLy8gICAgICAgdGhpcy5jaGlsZENvbnRyYWN0VmVyc2lvbi52YWx1ZSwKICAgIC8vICAgICAgIHRoaXMuYWtpdGFEQU8udmFsdWUuaWQsCiAgICAvLyAgICAgICBjb250cm9sbGVkQWRkcmVzcywKICAgIC8vICAgICAgIGFkbWluLAogICAgLy8gICAgICAgdGhpcy5kb21haW4udmFsdWUsCiAgICAvLyAgICAgICB0aGlzLmVzY3Jvd0ZhY3RvcnkudmFsdWUuaWQsCiAgICAvLyAgICAgICB0aGlzLnJldm9jYXRpb24udmFsdWUuaWQsCiAgICAvLyAgICAgICBuaWNrbmFtZSwKICAgIC8vICAgICAgIHJlZmVycmVyCiAgICAvLyAgICAgXSwKICAgIC8vICAgICBhcHByb3ZhbFByb2dyYW06IFtjaHVuazEsIGNodW5rMl0sCiAgICAvLyAgICAgY2xlYXJTdGF0ZVByb2dyYW06IGFic3RyYWN0ZWRBY2NvdW50LmNsZWFyU3RhdGVQcm9ncmFtLAogICAgLy8gICAgIGV4dHJhUHJvZ3JhbVBhZ2VzOiAzCiAgICAvLyAgIH0pCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjEwOC0xMjYKICAgIC8vIGNvbnN0IHdhbGxldElEID0gYWJzdHJhY3RlZEFjY291bnQuY2FsbAogICAgLy8gICAuY3JlYXRlKHsKICAgIC8vICAgICBhcmdzOiBbCiAgICAvLyAgICAgICB0aGlzLmNoaWxkQ29udHJhY3RWZXJzaW9uLnZhbHVlLAogICAgLy8gICAgICAgdGhpcy5ha2l0YURBTy52YWx1ZS5pZCwKICAgIC8vICAgICAgIGNvbnRyb2xsZWRBZGRyZXNzLAogICAgLy8gICAgICAgYWRtaW4sCiAgICAvLyAgICAgICB0aGlzLmRvbWFpbi52YWx1ZSwKICAgIC8vICAgICAgIHRoaXMuZXNjcm93RmFjdG9yeS52YWx1ZS5pZCwKICAgIC8vICAgICAgIHRoaXMucmV2b2NhdGlvbi52YWx1ZS5pZCwKICAgIC8vICAgICAgIG5pY2tuYW1lLAogICAgLy8gICAgICAgcmVmZXJyZXIKICAgIC8vICAgICBdLAogICAgLy8gICAgIGFwcHJvdmFsUHJvZ3JhbTogW2NodW5rMSwgY2h1bmsyXSwKICAgIC8vICAgICBjbGVhclN0YXRlUHJvZ3JhbTogYWJzdHJhY3RlZEFjY291bnQuY2xlYXJTdGF0ZVByb2dyYW0sCiAgICAvLyAgICAgZXh0cmFQcm9ncmFtUGFnZXM6IDMKICAgIC8vICAgfSkKICAgIC8vICAgLml0eG4KICAgIC8vICAgLmNyZWF0ZWRBcHAKICAgIGdpdHhuIDAgQ3JlYXRlZEFwcGxpY2F0aW9uSUQKICAgIGR1cAogICAgYnVyeSAxMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjEyOS0xMzQKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHJlY2VpdmVyOiBBcHBsaWNhdGlvbih3YWxsZXRJRCkuYWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IEdsb2JhbC5taW5CYWxhbmNlICsgQVJDNThXYWxsZXRJRHNCeUFjY291bnRzTWJyCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjEzMQogICAgLy8gcmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHdhbGxldElEKS5hZGRyZXNzLAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjEzMgogICAgLy8gYW1vdW50OiBHbG9iYWwubWluQmFsYW5jZSArIEFSQzU4V2FsbGV0SURzQnlBY2NvdW50c01icgogICAgZ2xvYmFsIE1pbkJhbGFuY2UKICAgIHB1c2hpbnQgMTIxMDAgLy8gMTIxMDAKICAgICsKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6MTI5LTEzMwogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHdhbGxldElEKS5hZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogR2xvYmFsLm1pbkJhbGFuY2UgKyBBUkM1OFdhbGxldElEc0J5QWNjb3VudHNNYnIKICAgIC8vICAgfSkKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxMjktMTM0CiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICByZWNlaXZlcjogQXBwbGljYXRpb24od2FsbGV0SUQpLmFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50OiBHbG9iYWwubWluQmFsYW5jZSArIEFSQzU4V2FsbGV0SURzQnlBY2NvdW50c01icgogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6MTM2CiAgICAvLyBpZiAobGVmdG92ZXIgPiAwKSB7CiAgICBkaWcgMTEKICAgIGJ6IG5ld0FjY291bnRfYWZ0ZXJfaWZfZWxzZUA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6MTM3LTE0MgogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgcmVjZWl2ZXI6IHRoaXMuYWtpdGFEQU9Fc2Nyb3cudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IGxlZnRvdmVyLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxMzkKICAgIC8vIHJlY2VpdmVyOiB0aGlzLmFraXRhREFPRXNjcm93LnZhbHVlLmFkZHJlc3MsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NjUKICAgIC8vIGFraXRhREFPRXNjcm93ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhRXNjcm93IH0pCiAgICBieXRlYyA0IC8vICJha2l0YV9lc2Nyb3ciCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6MTM5CiAgICAvLyByZWNlaXZlcjogdGhpcy5ha2l0YURBT0VzY3Jvdy52YWx1ZS5hZGRyZXNzLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGRpZyAxMgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxMzctMTQxCiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICByZWNlaXZlcjogdGhpcy5ha2l0YURBT0VzY3Jvdy52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogbGVmdG92ZXIsCiAgICAvLyAgIH0pCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6MTM3LTE0MgogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgcmVjZWl2ZXI6IHRoaXMuYWtpdGFEQU9Fc2Nyb3cudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IGxlZnRvdmVyLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CgpuZXdBY2NvdW50X2FmdGVyX2lmX2Vsc2VAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czo2OC03NAogICAgLy8gbmV3QWNjb3VudCgKICAgIC8vICAgcGF5bWVudDogZ3R4bi5QYXltZW50VHhuLAogICAgLy8gICBjb250cm9sbGVkQWRkcmVzczogQWNjb3VudCwKICAgIC8vICAgYWRtaW46IEFjY291bnQsCiAgICAvLyAgIG5pY2tuYW1lOiBzdHJpbmcsCiAgICAvLyAgIHJlZmVycmVyOiBBY2NvdW50CiAgICAvLyApOiB1aW50NjQgewogICAgZGlnIDgKICAgIGl0b2IKICAgIGJ5dGVjXzMgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm5ld0FjY291bnRfaWZfYm9keUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjkyCiAgICAvLyAoeyBsZWZ0b3ZlciwgcmVmZXJyYWxNYnIgfSA9IHNlbmRSZWZlcnJhbFBheW1lbnQodGhpcy5ha2l0YURBTy52YWx1ZSwgMCwgY3JlYXRpb25GZWUpKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjkyCiAgICAvLyAoeyBsZWZ0b3ZlciwgcmVmZXJyYWxNYnIgfSA9IHNlbmRSZWZlcnJhbFBheW1lbnQodGhpcy5ha2l0YURBTy52YWx1ZSwgMCwgY3JlYXRpb25GZWUpKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHN3YXAKICAgIGR1cAogICAgY292ZXIgMgogICAgYnVyeSAxNQogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo1NTkKICAgIC8vIGNvbnN0IHdhbGxldCA9IGdldFdhbGxldElEVXNpbmdBa2l0YURBTyhha2l0YURBTywgVHhuLnNlbmRlcikKICAgIHR4biBTZW5kZXIKICAgIGNhbGxzdWIgZ2V0V2FsbGV0SURVc2luZ0FraXRhREFPCiAgICBkdXAKICAgIGJ1cnkgMTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTU3CiAgICAvLyByZXR1cm4gcmVmZXJyZXJPcih3YWxsZXRJRCwgR2xvYmFsLnplcm9BZGRyZXNzKQogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICBidXJ5IDE2CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE1MAogICAgLy8gaWYgKHdhbGxldElELmlkID09PSAwKSB7CiAgICBibnogbmV3QWNjb3VudF9hZnRlcl9pZl9lbHNlQDExCiAgICBkaWcgMTQKICAgIGJ1cnkgMTQKCm5ld0FjY291bnRfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjpyZWZlcnJlck9yQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo1NjMKICAgIC8vIGlmIChhbW91bnQgPiAwICYmIHJlZmVycmVyICE9PSBHbG9iYWwuemVyb0FkZHJlc3MpIHsKICAgIGRpZyAyCiAgICBieiBuZXdBY2NvdW50X2FmdGVyX2lmX2Vsc2VAMjMKICAgIGRpZyAxMwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICAhPQogICAgYnogbmV3QWNjb3VudF9hZnRlcl9pZl9lbHNlQDIzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjY0CiAgICAvLyBjb25zdCBbd2FsbGV0RmVlc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1dhbGxldEZlZXMpKQogICAgZGlnIDEyCiAgICBieXRlYyA2IC8vICJ3YWxsZXRfZmVlcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NTY1CiAgICAvLyBjb25zdCB7IHJlZmVycmVyUGVyY2VudGFnZSB9ID0gZ2V0V2FsbGV0RmVlcyhha2l0YURBTykKICAgIGludGNfMiAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxMDQKICAgIC8vIGFzc2VydChwIDw9IERJVklTT1IsIEVSUl9JTlZBTElEX1BFUkNFTlRBR0UpCiAgICBkdXAKICAgIGludGMgNiAvLyAxMDAwMDAKICAgIDw9CiAgICBhc3NlcnQgLy8gSW52YWxpZCBwZXJjZW50YWdlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjEwNQogICAgLy8gcmV0dXJuIG9wLmRpdncoLi4ub3AubXVsdyhhLCBwKSwgRElWSVNPUikKICAgIGRpZyAzCiAgICBtdWx3CiAgICBpbnRjIDYgLy8gMTAwMDAwCiAgICBkaXZ3CiAgICBkdXAKICAgIGJ1cnkgMTIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NTY4CiAgICAvLyBpZiAocmVmZXJyYWxGZWUgPT09IDAgJiYgYW1vdW50ID4gMCkgewogICAgYm56IG5ld0FjY291bnRfYWZ0ZXJfaWZfZWxzZUAxNwogICAgZGlnIDIKICAgIGJ6IG5ld0FjY291bnRfYWZ0ZXJfaWZfZWxzZUAxNwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo1NjkKICAgIC8vIHJlZmVycmFsRmVlID0gMQogICAgaW50Y18xIC8vIDEKICAgIGJ1cnkgMTEKCm5ld0FjY291bnRfYWZ0ZXJfaWZfZWxzZUAxNzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NTc1CiAgICAvLyBHbG9iYWwubGF0ZXN0VGltZXN0YW1wLAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo1NzYKICAgIC8vIChHbG9iYWwubGF0ZXN0VGltZXN0YW1wICsgT05FX1dFRUspLAogICAgZHVwCiAgICBwdXNoaW50IDYwNDgwMCAvLyA2MDQ4MDAKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NTc3CiAgICAvLyBbeyBhZGRyZXNzOiByZWZlcnJlciwgYW1vdW50OiByZWZlcnJhbEZlZSB9XSwKICAgIGRpZyAxMgogICAgZHVwCiAgICBpdG9iCiAgICBkaWcgMTcKICAgIHN3YXAKICAgIGNvbmNhdAogICAgcHVzaGJ5dGVzIDB4MDAwMQogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQwCiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBkaWcgMTYKICAgIHB1c2hieXRlcyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0OTMKICAgIC8vIGNvbnN0IHJld2FyZHNBcHAgPSBnZXRBa2l0YUFwcExpc3QoYWtpdGFEQU8pLnJld2FyZHMKICAgIGludGNfMiAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0OTYKICAgIC8vIGxldCBjb3N0OiB1aW50NjQgPSBNaW5EaXNidXJzZW1lbnRzTUJSICsgKFVzZXJBbGxvY2F0aW9uTUJSICogYWxsb2NhdGlvbnMubGVuZ3RoKQogICAgZGlnIDEKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAyNTMwMCAvLyAyNTMwMAogICAgKgogICAgcHVzaGludCAzNTMwMCAvLyAzNTMwMAogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0OTgtNTA5CiAgICAvLyBpZCA9IGFiaUNhbGw8dHlwZW9mIFJld2FyZHMucHJvdG90eXBlLmNyZWF0ZUluc3RhbnREaXNidXJzZW1lbnQ+KHsKICAgIC8vICAgYXBwSWQ6IHJld2FyZHNBcHAsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgcmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHJld2FyZHNBcHApLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IE1pbkRpc2J1cnNlbWVudHNNQlIgKyAoVXNlckFsbG9jYXRpb25NQlIgKiBhbGxvY2F0aW9ucy5sZW5ndGgpICsgc3VtCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgdGltZVRvVW5sb2NrLAogICAgLy8gICAgIGV4cGlyYXRpb24sCiAgICAvLyAgICAgYWxsb2NhdGlvbnMKICAgIC8vICAgXQogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NTAyCiAgICAvLyByZWNlaXZlcjogQXBwbGljYXRpb24ocmV3YXJkc0FwcCkuYWRkcmVzcywKICAgIGRpZyAxCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjUwMwogICAgLy8gYW1vdW50OiBNaW5EaXNidXJzZW1lbnRzTUJSICsgKFVzZXJBbGxvY2F0aW9uTUJSICogYWxsb2NhdGlvbnMubGVuZ3RoKSArIHN1bQogICAgZGlnIDEKICAgIGRpZyA1CiAgICArCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo1MDEtNTA0CiAgICAvLyBpdHhuLnBheW1lbnQoewogICAgLy8gICByZWNlaXZlcjogQXBwbGljYXRpb24ocmV3YXJkc0FwcCkuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBNaW5EaXNidXJzZW1lbnRzTUJSICsgKFVzZXJBbGxvY2F0aW9uTUJSICogYWxsb2NhdGlvbnMubGVuZ3RoKSArIHN1bQogICAgLy8gfSksCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQ5OC01MDkKICAgIC8vIGlkID0gYWJpQ2FsbDx0eXBlb2YgUmV3YXJkcy5wcm90b3R5cGUuY3JlYXRlSW5zdGFudERpc2J1cnNlbWVudD4oewogICAgLy8gICBhcHBJZDogcmV3YXJkc0FwcCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICByZWNlaXZlcjogQXBwbGljYXRpb24ocmV3YXJkc0FwcCkuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogTWluRGlzYnVyc2VtZW50c01CUiArIChVc2VyQWxsb2NhdGlvbk1CUiAqIGFsbG9jYXRpb25zLmxlbmd0aCkgKyBzdW0KICAgIC8vICAgICB9KSwKICAgIC8vICAgICB0aW1lVG9VbmxvY2ssCiAgICAvLyAgICAgZXhwaXJhdGlvbiwKICAgIC8vICAgICBhbGxvY2F0aW9ucwogICAgLy8gICBdCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjUwNQogICAgLy8gdGltZVRvVW5sb2NrLAogICAgdW5jb3ZlciA1CiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjUwNgogICAgLy8gZXhwaXJhdGlvbiwKICAgIHVuY292ZXIgNQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0OTgtNTA5CiAgICAvLyBpZCA9IGFiaUNhbGw8dHlwZW9mIFJld2FyZHMucHJvdG90eXBlLmNyZWF0ZUluc3RhbnREaXNidXJzZW1lbnQ+KHsKICAgIC8vICAgYXBwSWQ6IHJld2FyZHNBcHAsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgcmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHJld2FyZHNBcHApLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IE1pbkRpc2J1cnNlbWVudHNNQlIgKyAoVXNlckFsbG9jYXRpb25NQlIgKiBhbGxvY2F0aW9ucy5sZW5ndGgpICsgc3VtCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgdGltZVRvVW5sb2NrLAogICAgLy8gICAgIGV4cGlyYXRpb24sCiAgICAvLyAgICAgYWxsb2NhdGlvbnMKICAgIC8vICAgXQogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweDdiN2RjNWZjIC8vIG1ldGhvZCAiY3JlYXRlSW5zdGFudERpc2J1cnNlbWVudChwYXksdWludDY0LHVpbnQ2NCwoYWRkcmVzcyx1aW50NjQpW10pdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgc3dhcAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgZ2l0eG4gMSBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMyAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjU0NAogICAgLy8gcmV0dXJuIHsgaWQsIGNvc3QgfQogICAgaXRvYgogICAgc3dhcAogICAgaXRvYgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjU3Mi01NzkKICAgIC8vIGNvbnN0IHsgY29zdDogcmVmZXJyYWxNYnIgfSA9IGNyZWF0ZUluc3RhbnREaXNidXJzZW1lbnQoCiAgICAvLyAgIGFraXRhREFPLAogICAgLy8gICBhc3NldCwKICAgIC8vICAgR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCwKICAgIC8vICAgKEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAgKyBPTkVfV0VFSyksCiAgICAvLyAgIFt7IGFkZHJlc3M6IHJlZmVycmVyLCBhbW91bnQ6IHJlZmVycmFsRmVlIH1dLAogICAgLy8gICByZWZlcnJhbEZlZQogICAgLy8gKQogICAgZXh0cmFjdCA4IDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NTgxCiAgICAvLyByZXR1cm4geyBsZWZ0b3ZlcjogKGFtb3VudCAtIHJlZmVycmFsRmVlKSwgcmVmZXJyYWxNYnIgfQogICAgZGlnIDQKICAgIHVuY292ZXIgMgogICAgLQogICAgaXRvYgogICAgc3dhcAogICAgY29uY2F0CgpuZXdBY2NvdW50X2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6c2VuZFJlZmVycmFsUGF5bWVudEAyNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czo5MgogICAgLy8gKHsgbGVmdG92ZXIsIHJlZmVycmFsTWJyIH0gPSBzZW5kUmVmZXJyYWxQYXltZW50KHRoaXMuYWtpdGFEQU8udmFsdWUsIDAsIGNyZWF0aW9uRmVlKSkKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBidXJ5IDEzCiAgICBpbnRjXzIgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIGJ1cnkgMQogICAgYiBuZXdBY2NvdW50X2FmdGVyX2lmX2Vsc2VAMwoKbmV3QWNjb3VudF9hZnRlcl9pZl9lbHNlQDIzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo1ODQKICAgIC8vIHJldHVybiB7IGxlZnRvdmVyOiBhbW91bnQsIHJlZmVycmFsTWJyOiAwIH0KICAgIGRpZyAyCiAgICBpdG9iCiAgICBpbnRjXzAgLy8gMAogICAgaXRvYgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6OTIKICAgIC8vICh7IGxlZnRvdmVyLCByZWZlcnJhbE1iciB9ID0gc2VuZFJlZmVycmFsUGF5bWVudCh0aGlzLmFraXRhREFPLnZhbHVlLCAwLCBjcmVhdGlvbkZlZSkpCiAgICBiIG5ld0FjY291bnRfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjpzZW5kUmVmZXJyYWxQYXltZW50QDI0CgpuZXdBY2NvdW50X2FmdGVyX2lmX2Vsc2VAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE2OS0xNzIKICAgIC8vIGNvbnN0IFtyZWZlcnJlckJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXRJRCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzUmVmZXJyZXIpCiAgICAvLyApCiAgICBkaWcgOQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNzEKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1JlZmVycmVyKQogICAgcHVzaGJ5dGVzICJyZWZlcnJlciIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTY5LTE3MgogICAgLy8gY29uc3QgW3JlZmVycmVyQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldElELAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNSZWZlcnJlcikKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIGJ1cnkgMTQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTU3CiAgICAvLyByZXR1cm4gcmVmZXJyZXJPcih3YWxsZXRJRCwgR2xvYmFsLnplcm9BZGRyZXNzKQogICAgYiBuZXdBY2NvdW50X2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6cmVmZXJyZXJPckAxMgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czo6QWJzdHJhY3RlZEFjY291bnRGYWN0b3J5LmNvc3Rbcm91dGluZ10oKSAtPiB2b2lkOgpjb3N0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjE1MQogICAgLy8gY29uc3QgY3JlYXRpb25GZWUgPSBnZXRXYWxsZXRGZWVzKHRoaXMuYWtpdGFEQU8udmFsdWUpLmNyZWF0ZUZlZQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjE1MQogICAgLy8gY29uc3QgY3JlYXRpb25GZWUgPSBnZXRXYWxsZXRGZWVzKHRoaXMuYWtpdGFEQU8udmFsdWUpLmNyZWF0ZUZlZQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NjQKICAgIC8vIGNvbnN0IFt3YWxsZXRGZWVzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0RmVlcykpCiAgICBieXRlYyA2IC8vICJ3YWxsZXRfZmVlcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxNTEKICAgIC8vIGNvbnN0IGNyZWF0aW9uRmVlID0gZ2V0V2FsbGV0RmVlcyh0aGlzLmFraXRhREFPLnZhbHVlKS5jcmVhdGVGZWUKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6MTUzCiAgICAvLyBsZXQgcmVmZXJyYWxDb3N0OiB1aW50NjQgPSAwCiAgICBpbnRjXzAgLy8gMAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjE1NAogICAgLy8gaWYgKGNyZWF0aW9uRmVlID4gMCkgewogICAgYnogY29zdF9hZnRlcl9pZl9lbHNlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxNTUKICAgIC8vIGNvbnN0IHdhbGxldCA9IGdldFdhbGxldElEVXNpbmdBa2l0YURBTyh0aGlzLmFraXRhREFPLnZhbHVlLCBUeG4uc2VuZGVyKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjE1NQogICAgLy8gY29uc3Qgd2FsbGV0ID0gZ2V0V2FsbGV0SURVc2luZ0FraXRhREFPKHRoaXMuYWtpdGFEQU8udmFsdWUsIFR4bi5zZW5kZXIpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgdHhuIFNlbmRlcgogICAgY2FsbHN1YiBnZXRXYWxsZXRJRFVzaW5nQWtpdGFEQU8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxNTYKICAgIC8vIGlmICh3YWxsZXQuaWQgPiAwKSB7CiAgICBieiBjb3N0X2FmdGVyX2lmX2Vsc2VANQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjE1NwogICAgLy8gcmVmZXJyYWxDb3N0ID0gY29zdEluc3RhbnREaXNidXJzZW1lbnQodGhpcy5ha2l0YURBTy52YWx1ZSwgMCwgMSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxNTcKICAgIC8vIHJlZmVycmFsQ29zdCA9IGNvc3RJbnN0YW50RGlzYnVyc2VtZW50KHRoaXMuYWtpdGFEQU8udmFsdWUsIDAsIDEpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQ4MwogICAgLy8gbGV0IGNvc3Q6IHVpbnQ2NCA9IE1pbkRpc2J1cnNlbWVudHNNQlIgKyAoVXNlckFsbG9jYXRpb25NQlIgKiBhbGxvY2F0aW9uc0xlbmd0aCkKICAgIHB1c2hpbnQgNjA2MDAgLy8gNjA2MDAKICAgIGJ1cnkgMQoKY29zdF9hZnRlcl9pZl9lbHNlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6MTY1CiAgICAvLyBHbG9iYWwubWluQmFsYW5jZSArCiAgICBnbG9iYWwgTWluQmFsYW5jZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjE2Mi0xNjYKICAgIC8vIE1BWF9QUk9HUkFNX1BBR0VTICsKICAgIC8vIChHTE9CQUxfU1RBVEVfS0VZX1VJTlRfQ09TVCAqIEFic3RyYWN0QWNjb3VudE51bUdsb2JhbFVpbnRzKSArCiAgICAvLyAoR0xPQkFMX1NUQVRFX0tFWV9CWVRFU19DT1NUICogQWJzdHJhY3RBY2NvdW50TnVtR2xvYmFsQnl0ZXMpICsKICAgIC8vIEdsb2JhbC5taW5CYWxhbmNlICsKICAgIC8vIEFSQzU4V2FsbGV0SURzQnlBY2NvdW50c01iciArCiAgICBpbnRjIDUgLy8gMTExODYwMAogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjE2Mi0xNjcKICAgIC8vIE1BWF9QUk9HUkFNX1BBR0VTICsKICAgIC8vIChHTE9CQUxfU1RBVEVfS0VZX1VJTlRfQ09TVCAqIEFic3RyYWN0QWNjb3VudE51bUdsb2JhbFVpbnRzKSArCiAgICAvLyAoR0xPQkFMX1NUQVRFX0tFWV9CWVRFU19DT1NUICogQWJzdHJhY3RBY2NvdW50TnVtR2xvYmFsQnl0ZXMpICsKICAgIC8vIEdsb2JhbC5taW5CYWxhbmNlICsKICAgIC8vIEFSQzU4V2FsbGV0SURzQnlBY2NvdW50c01iciArCiAgICAvLyBjcmVhdGlvbkZlZSArCiAgICBkaWcgMgogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjE2Mi0xNjgKICAgIC8vIE1BWF9QUk9HUkFNX1BBR0VTICsKICAgIC8vIChHTE9CQUxfU1RBVEVfS0VZX1VJTlRfQ09TVCAqIEFic3RyYWN0QWNjb3VudE51bUdsb2JhbFVpbnRzKSArCiAgICAvLyAoR0xPQkFMX1NUQVRFX0tFWV9CWVRFU19DT1NUICogQWJzdHJhY3RBY2NvdW50TnVtR2xvYmFsQnl0ZXMpICsKICAgIC8vIEdsb2JhbC5taW5CYWxhbmNlICsKICAgIC8vIEFSQzU4V2FsbGV0SURzQnlBY2NvdW50c01iciArCiAgICAvLyBjcmVhdGlvbkZlZSArCiAgICAvLyByZWZlcnJhbENvc3QKICAgIGRpZyAxCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6MTQ4CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGl0b2IKICAgIGJ5dGVjXzMgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6OkFic3RyYWN0ZWRBY2NvdW50RmFjdG9yeS51cGRhdGVXYWxsZXRbcm91dGluZ10oKSAtPiB2b2lkOgp1cGRhdGVXYWxsZXQ6CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjE4MQogICAgLy8gdXBkYXRlV2FsbGV0KHdhbGxldDogQXBwbGljYXRpb24pOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxODMKICAgIC8vIGNvbnN0IFthZG1pbkJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKHdhbGxldCwgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQWRtaW4pKQogICAgcHVzaGJ5dGVzICJhZG1pbiIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxODQKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSBBY2NvdW50KGFkbWluQnl0ZXMpKQogICAgdHhuIFNlbmRlcgogICAgPT0KICAgIGFzc2VydAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2ZhY3RvcnkudHM6MzgKICAgIC8vIGJveGVkQ29udHJhY3QgPSBCb3g8Ynl0ZXM+KHsga2V5OiBCb3hLZXlCb3hlZENvbnRyYWN0IH0pCiAgICBieXRlY18xIC8vICJiYyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxODYKICAgIC8vIGNvbnN0IGFwcHJvdmFsU2l6ZTogdWludDY0ID0gdGhpcy5ib3hlZENvbnRyYWN0Lmxlbmd0aAogICAgYm94X2xlbgogICAgc3dhcAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6MTkwCiAgICAvLyBpZiAoYXBwcm92YWxTaXplID4gTUFYX0FWTV9CWVRFX0FSUkFZX0xFTkdUSCkgewogICAgaW50YyA0IC8vIDQwOTYKICAgID4KICAgIGJ6IHVwZGF0ZVdhbGxldF9lbHNlX2JvZHlAMwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2ZhY3RvcnkudHM6MzgKICAgIC8vIGJveGVkQ29udHJhY3QgPSBCb3g8Ynl0ZXM+KHsga2V5OiBCb3hLZXlCb3hlZENvbnRyYWN0IH0pCiAgICBieXRlY18xIC8vICJiYyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxOTEKICAgIC8vIGNodW5rMSA9IHRoaXMuYm94ZWRDb250cmFjdC5leHRyYWN0KDAsIE1BWF9BVk1fQllURV9BUlJBWV9MRU5HVEgpCiAgICBpbnRjXzAgLy8gMAogICAgaW50YyA0IC8vIDQwOTYKICAgIGJveF9leHRyYWN0CiAgICBidXJ5IDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxOTIKICAgIC8vIGNodW5rMiA9IHRoaXMuYm94ZWRDb250cmFjdC5leHRyYWN0KE1BWF9BVk1fQllURV9BUlJBWV9MRU5HVEgsIGFwcHJvdmFsU2l6ZSAtIE1BWF9BVk1fQllURV9BUlJBWV9MRU5HVEgpCiAgICBpbnRjIDQgLy8gNDA5NgogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2ZhY3RvcnkudHM6MzgKICAgIC8vIGJveGVkQ29udHJhY3QgPSBCb3g8Ynl0ZXM+KHsga2V5OiBCb3hLZXlCb3hlZENvbnRyYWN0IH0pCiAgICBieXRlY18xIC8vICJiYyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxOTIKICAgIC8vIGNodW5rMiA9IHRoaXMuYm94ZWRDb250cmFjdC5leHRyYWN0KE1BWF9BVk1fQllURV9BUlJBWV9MRU5HVEgsIGFwcHJvdmFsU2l6ZSAtIE1BWF9BVk1fQllURV9BUlJBWV9MRU5HVEgpCiAgICBpbnRjIDQgLy8gNDA5NgogICAgdW5jb3ZlciAyCiAgICBib3hfZXh0cmFjdAoKdXBkYXRlV2FsbGV0X2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoyMDAtMjA2CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBYnN0cmFjdGVkQWNjb3VudC5wcm90b3R5cGUudXBkYXRlPih7CiAgICAvLyAgIGFwcElkOiB3YWxsZXQsCiAgICAvLyAgIGFyZ3M6IFt0aGlzLmNoaWxkQ29udHJhY3RWZXJzaW9uLnZhbHVlXSwKICAgIC8vICAgb25Db21wbGV0aW9uOiBPbkNvbXBsZXRlQWN0aW9uLlVwZGF0ZUFwcGxpY2F0aW9uLAogICAgLy8gICBhcHByb3ZhbFByb2dyYW06IFtjaHVuazEsIGNodW5rMl0sCiAgICAvLyAgIGNsZWFyU3RhdGVQcm9ncmFtOiBjbGVhclByb2dyYW0sCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjIwMgogICAgLy8gYXJnczogW3RoaXMuY2hpbGRDb250cmFjdFZlcnNpb24udmFsdWVdLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjM0CiAgICAvLyBjaGlsZENvbnRyYWN0VmVyc2lvbiA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IEJhc2VGYWN0b3J5R2xvYmFsU3RhdGVLZXlDaGlsZENvbnRyYWN0VmVyc2lvbiB9KQogICAgYnl0ZWMgNyAvLyAiY2hpbGRfY29udHJhY3RfdmVyc2lvbiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoyMDIKICAgIC8vIGFyZ3M6IFt0aGlzLmNoaWxkQ29udHJhY3RWZXJzaW9uLnZhbHVlXSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBkdXAKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjIwMC0yMDYKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFic3RyYWN0ZWRBY2NvdW50LnByb3RvdHlwZS51cGRhdGU+KHsKICAgIC8vICAgYXBwSWQ6IHdhbGxldCwKICAgIC8vICAgYXJnczogW3RoaXMuY2hpbGRDb250cmFjdFZlcnNpb24udmFsdWVdLAogICAgLy8gICBvbkNvbXBsZXRpb246IE9uQ29tcGxldGVBY3Rpb24uVXBkYXRlQXBwbGljYXRpb24sCiAgICAvLyAgIGFwcHJvdmFsUHJvZ3JhbTogW2NodW5rMSwgY2h1bmsyXSwKICAgIC8vICAgY2xlYXJTdGF0ZVByb2dyYW06IGNsZWFyUHJvZ3JhbSwKICAgIC8vIH0pCiAgICBieXRlYyA4IC8vIG1ldGhvZCAidXBkYXRlKHN0cmluZyl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvYWNjb3VudC9mYWN0b3J5LmFsZ28udHM6MTk4CiAgICAvLyBjb25zdCBjbGVhclByb2dyYW0gPSBjb21waWxlQXJjNChBYnN0cmFjdGVkQWNjb3VudCkuY2xlYXJTdGF0ZVByb2dyYW0KICAgIGJ5dGVjIDEzIC8vIGJhc2U2NChDNEVCUXc9PSkKICAgIGl0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW1QYWdlcwogICAgZGlnIDIKICAgIGl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtUGFnZXMKICAgIGl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtUGFnZXMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoyMDMKICAgIC8vIG9uQ29tcGxldGlvbjogT25Db21wbGV0ZUFjdGlvbi5VcGRhdGVBcHBsaWNhdGlvbiwKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgogICAgZHVwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoyMDAtMjA2CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBYnN0cmFjdGVkQWNjb3VudC5wcm90b3R5cGUudXBkYXRlPih7CiAgICAvLyAgIGFwcElkOiB3YWxsZXQsCiAgICAvLyAgIGFyZ3M6IFt0aGlzLmNoaWxkQ29udHJhY3RWZXJzaW9uLnZhbHVlXSwKICAgIC8vICAgb25Db21wbGV0aW9uOiBPbkNvbXBsZXRlQWN0aW9uLlVwZGF0ZUFwcGxpY2F0aW9uLAogICAgLy8gICBhcHByb3ZhbFByb2dyYW06IFtjaHVuazEsIGNodW5rMl0sCiAgICAvLyAgIGNsZWFyU3RhdGVQcm9ncmFtOiBjbGVhclByb2dyYW0sCiAgICAvLyB9KQogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9hY2NvdW50L2ZhY3RvcnkuYWxnby50czoxODEKICAgIC8vIHVwZGF0ZVdhbGxldCh3YWxsZXQ6IEFwcGxpY2F0aW9uKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgp1cGRhdGVXYWxsZXRfZWxzZV9ib2R5QDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZmFjdG9yeS50czozOAogICAgLy8gYm94ZWRDb250cmFjdCA9IEJveDxieXRlcz4oeyBrZXk6IEJveEtleUJveGVkQ29udHJhY3QgfSkKICAgIGJ5dGVjXzEgLy8gImJjIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjE5NAogICAgLy8gY2h1bmsxID0gdGhpcy5ib3hlZENvbnRyYWN0LmV4dHJhY3QoMCwgYXBwcm92YWxTaXplKQogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgYm94X2V4dHJhY3QKICAgIGJ1cnkgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L2FjY291bnQvZmFjdG9yeS5hbGdvLnRzOjE5NQogICAgLy8gY2h1bmsyID0gQnl0ZXMoJycpCiAgICBwdXNoYnl0ZXMgIiIKICAgIGIgdXBkYXRlV2FsbGV0X2FmdGVyX2lmX2Vsc2VANAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjpGYWN0b3J5Q29udHJhY3QuaW5pdEJveGVkQ29udHJhY3Rbcm91dGluZ10oKSAtPiB2b2lkOgppbml0Qm94ZWRDb250cmFjdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjQyCiAgICAvLyBpbml0Qm94ZWRDb250cmFjdCh2ZXJzaW9uOiBzdHJpbmcsIHNpemU6IHVpbnQ2NCk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2ZhY3RvcnkudHM6MzQKICAgIC8vIGNoaWxkQ29udHJhY3RWZXJzaW9uID0gR2xvYmFsU3RhdGU8c3RyaW5nPih7IGtleTogQmFzZUZhY3RvcnlHbG9iYWxTdGF0ZUtleUNoaWxkQ29udHJhY3RWZXJzaW9uIH0pCiAgICBieXRlYyA3IC8vICJjaGlsZF9jb250cmFjdF92ZXJzaW9uIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2ZhY3RvcnkudHM6NDMKICAgIC8vIHRoaXMuY2hpbGRDb250cmFjdFZlcnNpb24udmFsdWUgPSB2ZXJzaW9uCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2ZhY3RvcnkudHM6MzgKICAgIC8vIGJveGVkQ29udHJhY3QgPSBCb3g8Ynl0ZXM+KHsga2V5OiBCb3hLZXlCb3hlZENvbnRyYWN0IH0pCiAgICBieXRlY18xIC8vICJiYyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjQ0CiAgICAvLyBpZiAoIXRoaXMuYm94ZWRDb250cmFjdC5leGlzdHMpIHsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYm56IGluaXRCb3hlZENvbnRyYWN0X2Vsc2VfYm9keUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZmFjdG9yeS50czo0NQogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IEdsb2JhbC5jcmVhdG9yQWRkcmVzcywgRVJSX05PVF9BS0lUQV9EQU8pCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gT25seSB0aGUgQWtpdGEgREFPIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjM4CiAgICAvLyBib3hlZENvbnRyYWN0ID0gQm94PGJ5dGVzPih7IGtleTogQm94S2V5Qm94ZWRDb250cmFjdCB9KQogICAgYnl0ZWNfMSAvLyAiYmMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZmFjdG9yeS50czo0NgogICAgLy8gdGhpcy5ib3hlZENvbnRyYWN0LmNyZWF0ZSh7IHNpemUgfSkKICAgIHN3YXAKICAgIGJveF9jcmVhdGUKICAgIHBvcAoKaW5pdEJveGVkQ29udHJhY3RfYWZ0ZXJfaWZfZWxzZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2ZhY3RvcnkudHM6NDIKICAgIC8vIGluaXRCb3hlZENvbnRyYWN0KHZlcnNpb246IHN0cmluZywgc2l6ZTogdWludDY0KTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgppbml0Qm94ZWRDb250cmFjdF9lbHNlX2JvZHlAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjQ4CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5nZXRBa2l0YURBT1dhbGxldCgpLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzIKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzIKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ5dGVjXzIgLy8gIndhbGxldCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjQ4CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5nZXRBa2l0YURBT1dhbGxldCgpLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IHRoZSBBa2l0YSBEQU8gY2FuIGNhbGwgdGhpcyBmdW5jdGlvbgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2ZhY3RvcnkudHM6MzgKICAgIC8vIGJveGVkQ29udHJhY3QgPSBCb3g8Ynl0ZXM+KHsga2V5OiBCb3hLZXlCb3hlZENvbnRyYWN0IH0pCiAgICBieXRlY18xIC8vICJiYyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjQ5CiAgICAvLyB0aGlzLmJveGVkQ29udHJhY3QucmVzaXplKHNpemUpCiAgICBzd2FwCiAgICBib3hfcmVzaXplCiAgICBiIGluaXRCb3hlZENvbnRyYWN0X2FmdGVyX2lmX2Vsc2VANAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjpGYWN0b3J5Q29udHJhY3QubG9hZEJveGVkQ29udHJhY3Rbcm91dGluZ10oKSAtPiB2b2lkOgpsb2FkQm94ZWRDb250cmFjdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjUzCiAgICAvLyBsb2FkQm94ZWRDb250cmFjdChvZmZzZXQ6IHVpbnQ2NCwgZGF0YTogYnl0ZXMpOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1aW50OFtdKQogICAgZXh0cmFjdCAyIDAKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjU0CiAgICAvLyBjb25zdCBleHBlY3RlZFByZXZpb3VzQ2FsbHM6IHVpbnQ2NCA9IG9mZnNldCAvIDIwMzIKICAgIHB1c2hpbnQgMjAzMiAvLyAyMDMyCiAgICAvCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZmFjdG9yeS50czo1NQogICAgLy8gY29uc3QgdHhuID0gZ3R4bi5UcmFuc2FjdGlvbihUeG4uZ3JvdXBJbmRleCAtIGV4cGVjdGVkUHJldmlvdXNDYWxscyAtIDEpCiAgICB0eG4gR3JvdXBJbmRleAogICAgc3dhcAogICAgLQogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2ZhY3RvcnkudHM6NTcKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICBndHhucyBUeXBlRW51bQogICAgcHVzaGludCA2IC8vIDYKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZmFjdG9yeS50czo1Ny01OAogICAgLy8gdHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vICYmIHR4bi5hcHBJZCA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkCiAgICBieiBsb2FkQm94ZWRDb250cmFjdF9ib29sX2ZhbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjU4CiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgZHVwCiAgICBndHhucyBBcHBsaWNhdGlvbklECiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uSUQKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZmFjdG9yeS50czo1Ny01OAogICAgLy8gdHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vICYmIHR4bi5hcHBJZCA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkCiAgICBieiBsb2FkQm94ZWRDb250cmFjdF9ib29sX2ZhbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjU5CiAgICAvLyAmJiB0eG4ubnVtQXBwQXJncyA9PT0gMwogICAgZHVwCiAgICBndHhucyBOdW1BcHBBcmdzCiAgICBwdXNoaW50IDMgLy8gMwogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjU3LTU5CiAgICAvLyB0eG4udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFwcGxpY2F0aW9uQ2FsbAogICAgLy8gJiYgdHhuLmFwcElkID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQKICAgIC8vICYmIHR4bi5udW1BcHBBcmdzID09PSAzCiAgICBieiBsb2FkQm94ZWRDb250cmFjdF9ib29sX2ZhbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjYwCiAgICAvLyAmJiB0eG4ub25Db21wbGV0aW9uID09PSBPbkNvbXBsZXRlQWN0aW9uLk5vT3AKICAgIGR1cAogICAgZ3R4bnMgT25Db21wbGV0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZmFjdG9yeS50czo1Ny02MAogICAgLy8gdHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vICYmIHR4bi5hcHBJZCA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkCiAgICAvLyAmJiB0eG4ubnVtQXBwQXJncyA9PT0gMwogICAgLy8gJiYgdHhuLm9uQ29tcGxldGlvbiA9PT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wCiAgICBibnogbG9hZEJveGVkQ29udHJhY3RfYm9vbF9mYWxzZUA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZmFjdG9yeS50czo2MQogICAgLy8gJiYgdHhuLmFwcEFyZ3MoMCkgPT09IG1ldGhvZFNlbGVjdG9yKHRoaXMuaW5pdEJveGVkQ29udHJhY3QpCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBndHhuc2FzIEFwcGxpY2F0aW9uQXJncwogICAgYnl0ZWMgOSAvLyBtZXRob2QgImluaXRCb3hlZENvbnRyYWN0KHN0cmluZyx1aW50NjQpdm9pZCIKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZmFjdG9yeS50czo1Ny02MQogICAgLy8gdHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vICYmIHR4bi5hcHBJZCA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkCiAgICAvLyAmJiB0eG4ubnVtQXBwQXJncyA9PT0gMwogICAgLy8gJiYgdHhuLm9uQ29tcGxldGlvbiA9PT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wCiAgICAvLyAmJiB0eG4uYXBwQXJncygwKSA9PT0gbWV0aG9kU2VsZWN0b3IodGhpcy5pbml0Qm94ZWRDb250cmFjdCkKICAgIGJ6IGxvYWRCb3hlZENvbnRyYWN0X2Jvb2xfZmFsc2VAOAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2ZhY3RvcnkudHM6NjIKICAgIC8vICYmIHR4bi5zZW5kZXIgPT09IFR4bi5zZW5kZXIKICAgIGR1cAogICAgZ3R4bnMgU2VuZGVyCiAgICB0eG4gU2VuZGVyCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2ZhY3RvcnkudHM6NTctNjIKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgLy8gJiYgdHhuLm51bUFwcEFyZ3MgPT09IDMKICAgIC8vICYmIHR4bi5vbkNvbXBsZXRpb24gPT09IE9uQ29tcGxldGVBY3Rpb24uTm9PcAogICAgLy8gJiYgdHhuLmFwcEFyZ3MoMCkgPT09IG1ldGhvZFNlbGVjdG9yKHRoaXMuaW5pdEJveGVkQ29udHJhY3QpCiAgICAvLyAmJiB0eG4uc2VuZGVyID09PSBUeG4uc2VuZGVyCiAgICBieiBsb2FkQm94ZWRDb250cmFjdF9ib29sX2ZhbHNlQDgKICAgIGludGNfMSAvLyAxCgpsb2FkQm94ZWRDb250cmFjdF9ib29sX21lcmdlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZmFjdG9yeS50czo1Ni02MwogICAgLy8gYXNzZXJ0KCgKICAgIC8vICAgdHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vICAgJiYgdHhuLmFwcElkID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQKICAgIC8vICAgJiYgdHhuLm51bUFwcEFyZ3MgPT09IDMKICAgIC8vICAgJiYgdHhuLm9uQ29tcGxldGlvbiA9PT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wCiAgICAvLyAgICYmIHR4bi5hcHBBcmdzKDApID09PSBtZXRob2RTZWxlY3Rvcih0aGlzLmluaXRCb3hlZENvbnRyYWN0KQogICAgLy8gICAmJiB0eG4uc2VuZGVyID09PSBUeG4uc2VuZGVyCiAgICAvLyApLCBFUlJfSU5WQUxJRF9DQUxMX09SREVSKQogICAgYXNzZXJ0IC8vIEludmFsaWQgY2FsbCBvcmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2ZhY3RvcnkudHM6MzgKICAgIC8vIGJveGVkQ29udHJhY3QgPSBCb3g8Ynl0ZXM+KHsga2V5OiBCb3hLZXlCb3hlZENvbnRyYWN0IH0pCiAgICBieXRlY18xIC8vICJiYyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjY0CiAgICAvLyBhc3NlcnQodGhpcy5ib3hlZENvbnRyYWN0LmV4aXN0cywgRVJSX0NPTlRSQUNUX05PVF9TRVQpCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBDb250cmFjdCBub3Qgc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZmFjdG9yeS50czozOAogICAgLy8gYm94ZWRDb250cmFjdCA9IEJveDxieXRlcz4oeyBrZXk6IEJveEtleUJveGVkQ29udHJhY3QgfSkKICAgIGJ5dGVjXzEgLy8gImJjIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2ZhY3RvcnkudHM6NjUKICAgIC8vIHRoaXMuYm94ZWRDb250cmFjdC5yZXBsYWNlKG9mZnNldCwgZGF0YSkKICAgIGRpZyAzCiAgICBkaWcgMwogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjUzCiAgICAvLyBsb2FkQm94ZWRDb250cmFjdChvZmZzZXQ6IHVpbnQ2NCwgZGF0YTogYnl0ZXMpOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCmxvYWRCb3hlZENvbnRyYWN0X2Jvb2xfZmFsc2VAODoKICAgIGludGNfMCAvLyAwCiAgICBiIGxvYWRCb3hlZENvbnRyYWN0X2Jvb2xfbWVyZ2VAOQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjpGYWN0b3J5Q29udHJhY3QuZGVsZXRlQm94ZWRDb250cmFjdFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmRlbGV0ZUJveGVkQ29udHJhY3Q6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZmFjdG9yeS50czo2OQogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMyCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMyCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBieXRlY18yIC8vICJ3YWxsZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZmFjdG9yeS50czo2OQogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gT25seSB0aGUgQWtpdGEgREFPIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjM4CiAgICAvLyBib3hlZENvbnRyYWN0ID0gQm94PGJ5dGVzPih7IGtleTogQm94S2V5Qm94ZWRDb250cmFjdCB9KQogICAgYnl0ZWNfMSAvLyAiYmMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvZmFjdG9yeS50czo3MAogICAgLy8gdGhpcy5ib3hlZENvbnRyYWN0LmRlbGV0ZSgpCiAgICBib3hfZGVsCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9mYWN0b3J5LnRzOjY4CiAgICAvLyBkZWxldGVCb3hlZENvbnRyYWN0KCk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjpBa2l0YUZlZUdlbmVyYXRvckNvbnRyYWN0V2l0aE9wdEluLm9wdEluW3JvdXRpbmddKCkgLT4gdm9pZDoKb3B0SW46CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoxNTAKICAgIC8vIG9wdEluKHBheW1lbnQ6IGd0eG4uUGF5bWVudFR4biwgYXNzZXQ6IEFzc2V0KTogdm9pZCB7CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoxNTIKICAgIC8vIGNvbnN0IGNvdW50ID0gc3BsaXRPcHRJbkNvdW50KHRoaXMuYWtpdGFEQU8udmFsdWUsIHRoaXMuYWtpdGFEQU9Fc2Nyb3cudmFsdWUuYWRkcmVzcywgYXNzZXQpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoxNTIKICAgIC8vIGNvbnN0IGNvdW50ID0gc3BsaXRPcHRJbkNvdW50KHRoaXMuYWtpdGFEQU8udmFsdWUsIHRoaXMuYWtpdGFEQU9Fc2Nyb3cudmFsdWUuYWRkcmVzcywgYXNzZXQpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjY1CiAgICAvLyBha2l0YURBT0VzY3JvdyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YUVzY3JvdyB9KQogICAgYnl0ZWMgNCAvLyAiYWtpdGFfZXNjcm93IgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MTUyCiAgICAvLyBjb25zdCBjb3VudCA9IHNwbGl0T3B0SW5Db3VudCh0aGlzLmFraXRhREFPLnZhbHVlLCB0aGlzLmFraXRhREFPRXNjcm93LnZhbHVlLmFkZHJlc3MsIGFzc2V0KQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGRpZyAyCiAgICBjYWxsc3ViIHNwbGl0T3B0SW5Db3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MTU0LTE2MQogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIHBheW1lbnQsCiAgICAvLyAgIHsKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50OiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UgKiAoMSArIGNvdW50KSwKICAgIC8vICAgfSwKICAgIC8vICAgRVJSX0lOVkFMSURfUEFZTUVOVAogICAgLy8gKQogICAgZGlnIDIKICAgIGd0eG5zIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoxNTcKICAgIC8vIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoxNTQtMTYxCiAgICAvLyBhc3NlcnRNYXRjaCgKICAgIC8vICAgcGF5bWVudCwKICAgIC8vICAgewogICAgLy8gICAgIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZSAqICgxICsgY291bnQpLAogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICA9PQogICAgdW5jb3ZlciAzCiAgICBndHhucyBBbW91bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjE1OAogICAgLy8gYW1vdW50OiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UgKiAoMSArIGNvdW50KSwKICAgIGdsb2JhbCBBc3NldE9wdEluTWluQmFsYW5jZQogICAgaW50Y18xIC8vIDEKICAgIHVuY292ZXIgNAogICAgKwogICAgKgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MTU0LTE2MQogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIHBheW1lbnQsCiAgICAvLyAgIHsKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50OiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UgKiAoMSArIGNvdW50KSwKICAgIC8vICAgfSwKICAgIC8vICAgRVJSX0lOVkFMSURfUEFZTUVOVAogICAgLy8gKQogICAgPT0KICAgICYmCiAgICBhc3NlcnQgLy8gSW52YWxpZCBwYXltZW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoxNjMtMTY5CiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIC8vICAgICBhc3NldEFtb3VudDogMCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGFzc2V0CiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MTY1CiAgICAvLyBhc3NldFJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MTY2CiAgICAvLyBhc3NldEFtb3VudDogMCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjE2My0xNjgKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiAwLAogICAgLy8gICAgIHhmZXJBc3NldDogYXNzZXQKICAgIC8vICAgfSkKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjE2My0xNjkKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiAwLAogICAgLy8gICAgIHhmZXJBc3NldDogYXNzZXQKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MTUwCiAgICAvLyBvcHRJbihwYXltZW50OiBndHhuLlBheW1lbnRUeG4sIGFzc2V0OiBBc3NldCk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjpBa2l0YUZlZUdlbmVyYXRvckNvbnRyYWN0V2l0aE9wdEluLm9wdEluQ29zdFtyb3V0aW5nXSgpIC0+IHZvaWQ6Cm9wdEluQ29zdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjE3MgogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MTc0CiAgICAvLyBjb25zdCBjb3VudCA9IHNwbGl0T3B0SW5Db3VudCh0aGlzLmFraXRhREFPLnZhbHVlLCB0aGlzLmFraXRhREFPRXNjcm93LnZhbHVlLmFkZHJlc3MsIGFzc2V0KQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MTc0CiAgICAvLyBjb25zdCBjb3VudCA9IHNwbGl0T3B0SW5Db3VudCh0aGlzLmFraXRhREFPLnZhbHVlLCB0aGlzLmFraXRhREFPRXNjcm93LnZhbHVlLmFkZHJlc3MsIGFzc2V0KQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo2NQogICAgLy8gYWtpdGFEQU9Fc2Nyb3cgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFFc2Nyb3cgfSkKICAgIGJ5dGVjIDQgLy8gImFraXRhX2VzY3JvdyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjE3NAogICAgLy8gY29uc3QgY291bnQgPSBzcGxpdE9wdEluQ291bnQodGhpcy5ha2l0YURBTy52YWx1ZSwgdGhpcy5ha2l0YURBT0VzY3Jvdy52YWx1ZS5hZGRyZXNzLCBhc3NldCkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICB1bmNvdmVyIDIKICAgIGNhbGxzdWIgc3BsaXRPcHRJbkNvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoxNzUKICAgIC8vIHJldHVybiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UgKiAoMSArIGNvdW50KQogICAgZ2xvYmFsIEFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICBpbnRjXzEgLy8gMQogICAgdW5jb3ZlciAyCiAgICArCiAgICAqCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoxNzIKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgaXRvYgogICAgYnl0ZWNfMyAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjpBa2l0YUJhc2VGZWVHZW5lcmF0b3JDb250cmFjdC51cGRhdGVBa2l0YURBT0VzY3Jvd1tyb3V0aW5nXSgpIC0+IHZvaWQ6CnVwZGF0ZUFraXRhREFPRXNjcm93OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MTM3CiAgICAvLyB1cGRhdGVBa2l0YURBT0VzY3JvdyhhcHA6IEFwcGxpY2F0aW9uKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MTM4CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5nZXRBa2l0YURBT1dhbGxldCgpLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzIKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzIKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ5dGVjXzIgLy8gIndhbGxldCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjEzOAogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gT25seSB0aGUgQWtpdGEgREFPIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjY1CiAgICAvLyBha2l0YURBT0VzY3JvdyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YUVzY3JvdyB9KQogICAgYnl0ZWMgNCAvLyAiYWtpdGFfZXNjcm93IgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MTM5CiAgICAvLyB0aGlzLmFraXRhREFPRXNjcm93LnZhbHVlID0gYXBwCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MTM3CiAgICAvLyB1cGRhdGVBa2l0YURBT0VzY3JvdyhhcHA6IEFwcGxpY2F0aW9uKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6OlVwZ3JhZGVhYmxlQWtpdGFCYXNlQ29udHJhY3QudXBkYXRlW3JvdXRpbmddKCkgLT4gdm9pZDoKdXBkYXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NDgKICAgIC8vIEBhYmltZXRob2QoeyBhbGxvd0FjdGlvbnM6IFsnVXBkYXRlQXBwbGljYXRpb24nXSB9KQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo1MAogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMyCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMyCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBkdXAKICAgIGJ5dGVjXzIgLy8gIndhbGxldCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjUwCiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5nZXRBa2l0YURBT1dhbGxldCgpLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgdW5jb3ZlciAyCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgdGhlIEFraXRhIERBTyBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjUwCiAgICAvLyBjb25zdCBbcGx1Z2luQXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1BsdWdpbkFwcExpc3QpKQogICAgcHVzaGJ5dGVzICJwYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo1MQogICAgLy8gY29uc3QgdXBkYXRlUGx1Z2luID0gZ2V0UGx1Z2luQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS51cGRhdGUKICAgIHB1c2hpbnQgMTYgLy8gMTYKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo1MgogICAgLy8gYXNzZXJ0KEdsb2JhbC5jYWxsZXJBcHBsaWNhdGlvbklkID09PSB1cGRhdGVQbHVnaW4sIEVSUl9JTlZBTElEX1VQR1JBREUpCiAgICBnbG9iYWwgQ2FsbGVyQXBwbGljYXRpb25JRAogICAgPT0KICAgIGFzc2VydCAvLyBJbnZhbGlkIGFwcCB1cGdyYWRlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyNwogICAgLy8gdmVyc2lvbiA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5VmVyc2lvbiB9KQogICAgYnl0ZWMgMTAgLy8gInZlcnNpb24iCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo1MwogICAgLy8gdGhpcy52ZXJzaW9uLnZhbHVlID0gbmV3VmVyc2lvbgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjQ4CiAgICAvLyBAYWJpbWV0aG9kKHsgYWxsb3dBY3Rpb25zOiBbJ1VwZGF0ZUFwcGxpY2F0aW9uJ10gfSkKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo6QWtpdGFCYXNlQ29udHJhY3QudXBkYXRlQWtpdGFEQU9bcm91dGluZ10oKSAtPiB2b2lkOgp1cGRhdGVBa2l0YURBTzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjM4CiAgICAvLyB1cGRhdGVBa2l0YURBTyhha2l0YURBTzogQXBwbGljYXRpb24pOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozOQogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMyCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMyCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBieXRlY18yIC8vICJ3YWxsZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozOQogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gT25seSB0aGUgQWtpdGEgREFPIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NDAKICAgIC8vIHRoaXMuYWtpdGFEQU8udmFsdWUgPSBha2l0YURBTwogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjM4CiAgICAvLyB1cGRhdGVBa2l0YURBTyhha2l0YURBTzogQXBwbGljYXRpb24pOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4K", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyAHAAEIAoAgiKNEoI0GJg4JYWtpdGFfZGFvAmJjBndhbGxldAQVH3x1DGFraXRhX2VzY3JvdwpyZXZvY2F0aW9uC3dhbGxldF9mZWVzFmNoaWxkX2NvbnRyYWN0X3ZlcnNpb24E6pGA3QTFOzLMB3ZlcnNpb24OZXNjcm93X2ZhY3RvcnkGZG9tYWluBAuBAUMnCDYaAI4BAHQxGRREMRhBAF2CBAQI0x3kBDdIVUEEm2f6bQQB4i8/JwmCBwTcothiBNNGsaQEOU6usgQz94gIBB6tIKkEM+kslASFTe3gNhoAjgwBAwEgA0sDhQP1BDoEpgS5BQcFLwWBAAEAI0OABAYQeg82GgCOAQCRADEZgQQSMRgQREIFL4oCAYv+gANvYWxlSIEYW7GABDwabzOyGov/shqyGIEGshAisgGztD5JVwQASwFXAAQrEkRJIlklCEwVEkRXBgBJFUlBAAeLASQTQQAEIowAiYsAF0L/94oDASKL/ov/cABFAUAAGov9gA5yZXZlbnVlX3NwbGl0c2VIIlkjCIwAiwBMiTYaAUkVJBJEFzYaAkkVJBJEFzYaA0kiWSUISwEVEkRXAgA2GgRJFSQSRBc2GgVJFSQSRBc2GgZJIlklCEsBFRJEVwIAKE8GZycETwVnJwpPBGcnC08DZycFTwJnJwxMZyNDNhoBSRUkEkQXMQAiKGVEKmVIcghEEkQnBUxnI0MiSYAARwQxFiMJSTgQIxJENhoBSRWBIBJENhoCSRWBIBJENhoDRwIiWSUITBUSRDYaBEkVgSASRCIoZUQnBmVIIltJMgEhBQhLAQhMIkxAAN1LAkUMSwdJOAcyChJMOAhLA0sDCBIQRCm9RCkiIQS6TCEECSkhBE8CurEiJwdlREkVFlcGAkxQIihlRBYiJwxlREkVFlcGAkxQIicLZUQWIicFZUQWgASj29N3shpPBLIaTwOyGksLshpLCrIaTwKyGkyyGrIaSwayGksFshqBCbI1gQmyNCKyGYEDsjgnDbJCTLJAskCBBrIQIrIBs7cAPUlFCrFyCEQyAYHEXgiyCLIHI7IQIrIBs0sLQQAWsSInBGVEcghESwyyCLIHI7IQIrIBs0sIFitMULAjQyIoZUxJTgJFD0QxAIj9wElFCzIDRRBAANFLDkUOSwJBAL9LDTIDE0EAt0sMJwZlSCRbSSEGDkRLAx0hBpdJRQxAAAhLAkEAAyNFCzIHSYGA9SQISwxJFksRTFCAAgABTFBLEIADYWFsZUgkW0sBIlmB1MUBC4HkkwIIsUsBcghESwFLBQiyCLIHI7IQIrIBtk8FFk8FFoAEe33F/LIaTLIashpPArIaTLIYgQayECKyAbO3AT5JVwQATFcABCsSREkVJBJEFxZMFlBXCAhLBE8CCRZMUEkiW0UNJFtFAUL+RksCFiIWUEL/60sJgAhyZWZlcnJlcmVIRQ5C/yAiKGVEJwZlSCJbSSJMQQAYIihlRDEAiPy5QQAMIihlRQFEgbjZA0UBMgEhBQhLAghLAQgWK0xQsCNDIjYaAUkVJBJEF0mABWFkbWluZUgxABJEKb1MSU8CRCEEDUEAPykiIQS6RQMhBAkpIQRPArqxIicHZURJFRZXBgJMUCcIshqyGicNskJLArJAskCBBLIZSbIYgQayECKyAbMjQykiTwK6RQKAAEL/xTYaAUkiWSUISwEVEkRXAgA2GgJJFSQSRBdMJwdMZym9RQFAAAwxADIJEkQpTLlII0MxACIoZUQqZUhyCEQSRClM00L/6jYaAUkVJBJEF0k2GgJJIlklCEsBFRJEVwIATIHwDwoxFkwJIwlJOBCBBhJBADpJOBgyCBJBADFJOBuBAxJBAChJOBlAACJJIsIaJwkSQQAYSTgAMQASQQAPI0QpvUUBRClLA0sDuyNDIkL/7jEAIihlRCplSHIIRBJEKbxII0MxFiMJSTgQIxJENhoBSRUkEkQXIihlRCInBGVEcghESwKI+5dLAjgHMgoSTwM4CDIQI08ECAsSEESxMgpMshEishKyFIEEshAisgGzI0M2GgFJFSQSRBciKGVEIicEZURyCERPAoj7UzIQI08CCAsWK0xQsCNDNhoBSRUkEkQXMQAiKGVEKmVIcghEEkQnBExnI0M2GgFJIlklCEsBFRJEVwIAMQAiKGVESSplSHIIRE8CEkSAA3BhbGVIgRBbMg0SRCcKTGcjQzYaAUkVJBJEFzEAIihlRCplSHIIRBJEKExnI0M=", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var BinaryStateValue = class {
  constructor(value) {
    this.value = value;
  }
  asByteArray() {
    return this.value;
  }
  asString() {
    return this.value !== void 0 ? Buffer.from(this.value).toString("utf-8") : void 0;
  }
};
var AbstractedAccountFactoryParamsFactory = class _AbstractedAccountFactoryParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "create":
          case "create(uint64,uint64,string,uint64,uint64,string)void":
            return _AbstractedAccountFactoryParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs create ABI call params for the AbstractedAccountFactory smart contract using the create(uint64,uint64,string,uint64,uint64,string)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params) {
        return {
          ...params,
          method: "create(uint64,uint64,string,uint64,uint64,string)void",
          args: Array.isArray(params.args) ? params.args : [params.args.akitaDao, params.args.akitaDaoEscrow, params.args.version, params.args.escrowFactory, params.args.revocation, params.args.domain]
        };
      }
    };
  }
  /**
   * Gets available update ABI call param factories
   */
  static get update() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "update":
          case "update(string)void":
            return _AbstractedAccountFactoryParamsFactory.update.update(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs update ABI call params for the AbstractedAccountFactory smart contract using the update(string)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      update(params) {
        return {
          ...params,
          method: "update(string)void",
          args: Array.isArray(params.args) ? params.args : [params.args.newVersion]
        };
      }
    };
  }
  /**
   * Constructs a no op call for the updateRevocation(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateRevocation(params) {
    return {
      ...params,
      method: "updateRevocation(uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.app]
    };
  }
  /**
   * Constructs a no op call for the newAccount(pay,address,address,string,address)uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static newAccount(params) {
    return {
      ...params,
      method: "newAccount(pay,address,address,string,address)uint64",
      args: Array.isArray(params.args) ? params.args : [params.args.payment, params.args.controlledAddress, params.args.admin, params.args.nickname, params.args.referrer]
    };
  }
  /**
   * Constructs a no op call for the cost()uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static cost(params) {
    return {
      ...params,
      method: "cost()uint64",
      args: Array.isArray(params.args) ? params.args : []
    };
  }
  /**
     * Constructs a no op call for the updateWallet(uint64)void ABI method
     *
    * Permanent: Update a wallet's bytecode. The caller must be the wallet's admin.
    The factory sends the update inner txn as itself (factory address), which the
    wallet accepts because Txn.sender === factoryApp.address.
  
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
  static updateWallet(params) {
    return {
      ...params,
      method: "updateWallet(uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet]
    };
  }
  /**
   * Constructs a no op call for the initBoxedContract(string,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static initBoxedContract(params) {
    return {
      ...params,
      method: "initBoxedContract(string,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.version, params.args.size]
    };
  }
  /**
   * Constructs a no op call for the loadBoxedContract(uint64,byte[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static loadBoxedContract(params) {
    return {
      ...params,
      method: "loadBoxedContract(uint64,byte[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.offset, params.args.data]
    };
  }
  /**
   * Constructs a no op call for the deleteBoxedContract()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static deleteBoxedContract(params) {
    return {
      ...params,
      method: "deleteBoxedContract()void",
      args: Array.isArray(params.args) ? params.args : []
    };
  }
  /**
   * Constructs a no op call for the optIn(pay,uint64)void ABI method
   *
   * optin tells the contract to opt into an asa
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static optIn(params) {
    return {
      ...params,
      method: "optIn(pay,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.payment, params.args.asset]
    };
  }
  /**
   * Constructs a no op call for the optInCost(uint64)uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static optInCost(params) {
    return {
      ...params,
      method: "optInCost(uint64)uint64",
      args: Array.isArray(params.args) ? params.args : [params.args.asset]
    };
  }
  /**
   * Constructs a no op call for the updateAkitaDAOEscrow(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDaoEscrow(params) {
    return {
      ...params,
      method: "updateAkitaDAOEscrow(uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.app]
    };
  }
  /**
   * Constructs a no op call for the updateAkitaDAO(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDao(params) {
    return {
      ...params,
      method: "updateAkitaDAO(uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.akitaDao]
    };
  }
  /**
   * Constructs a no op call for the opUp()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static opUp(params) {
    return {
      ...params,
      method: "opUp()void",
      args: Array.isArray(params.args) ? params.args : []
    };
  }
};
var AbstractedAccountFactoryFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `AbstractedAccountFactoryFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory2({
      ...params,
      appSpec: APP_SPEC2
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC2;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new AbstractedAccountFactoryClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new AbstractedAccountFactoryClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the AbstractedAccountFactory smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    var _a, _b;
    const result = await this.appFactory.deploy({
      ...params,
      createParams: ((_a = params.createParams) == null ? void 0 : _a.method) ? AbstractedAccountFactoryParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams : void 0,
      updateParams: ((_b = params.updateParams) == null ? void 0 : _b.method) ? AbstractedAccountFactoryParamsFactory.update._resolveByMethod(params.updateParams) : params.updateParams ? params.updateParams : void 0
    });
    return { result: result.result, appClient: new AbstractedAccountFactoryClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the AbstractedAccountFactory smart contract using the create(uint64,uint64,string,uint64,uint64,string)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params) => {
        return this.appFactory.params.create(AbstractedAccountFactoryParamsFactory.create.create(params));
      }
    },
    /**
     * Gets available deployUpdate methods
     */
    deployUpdate: {
      /**
       * Updates an existing instance of the AbstractedAccountFactory smart contract using the update(string)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The deployUpdate params
       */
      update: (params) => {
        return this.appFactory.params.deployUpdate(AbstractedAccountFactoryParamsFactory.update.update(params));
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the AbstractedAccountFactory smart contract using the create(uint64,uint64,string,uint64,uint64,string)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params) => {
        return this.appFactory.createTransaction.create(AbstractedAccountFactoryParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the AbstractedAccountFactory smart contract using an ABI method call using the create(uint64,uint64,string,uint64,uint64,string)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params) => {
        const result = await this.appFactory.send.create(AbstractedAccountFactoryParamsFactory.create.create(params));
        return { result: { ...result.result, return: result.result.return }, appClient: new AbstractedAccountFactoryClient(result.appClient) };
      }
    }
  };
};
var AbstractedAccountFactoryClient = class _AbstractedAccountFactoryClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient2 ? appClientOrParams : new _AppClient2({
      ...appClientOrParams,
      appSpec: APP_SPEC2
    });
  }
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue(method, returnValue) {
    return returnValue !== void 0 ? getArc56ReturnValue2(returnValue, this.appClient.getABIMethod(method), APP_SPEC2.structs) : void 0;
  }
  /**
   * Returns a new `AbstractedAccountFactoryClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _AbstractedAccountFactoryClient(await _AppClient2.fromCreatorAndName({ ...params, appSpec: APP_SPEC2 }));
  }
  /**
   * Returns an `AbstractedAccountFactoryClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _AbstractedAccountFactoryClient(await _AppClient2.fromNetwork({ ...params, appSpec: APP_SPEC2 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the AbstractedAccountFactory smart contract using the `update(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update params
       */
      update: (params) => {
        return this.appClient.params.update(AbstractedAccountFactoryParamsFactory.update.update(params));
      }
    },
    /**
     * Makes a clear_state call to an existing instance of the AbstractedAccountFactory smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `updateRevocation(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateRevocation: (params) => {
      return this.appClient.params.call(AbstractedAccountFactoryParamsFactory.updateRevocation(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `newAccount(pay,address,address,string,address)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    newAccount: (params) => {
      return this.appClient.params.call(AbstractedAccountFactoryParamsFactory.newAccount(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `cost()uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    cost: (params = { args: [] }) => {
      return this.appClient.params.call(AbstractedAccountFactoryParamsFactory.cost(params));
    },
    /**
         * Makes a call to the AbstractedAccountFactory smart contract using the `updateWallet(uint64)void` ABI method.
         *
        * Permanent: Update a wallet's bytecode. The caller must be the wallet's admin.
        The factory sends the update inner txn as itself (factory address), which the
        wallet accepts because Txn.sender === factoryApp.address.
    
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
    updateWallet: (params) => {
      return this.appClient.params.call(AbstractedAccountFactoryParamsFactory.updateWallet(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `initBoxedContract(string,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    initBoxedContract: (params) => {
      return this.appClient.params.call(AbstractedAccountFactoryParamsFactory.initBoxedContract(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `loadBoxedContract(uint64,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    loadBoxedContract: (params) => {
      return this.appClient.params.call(AbstractedAccountFactoryParamsFactory.loadBoxedContract(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `deleteBoxedContract()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    deleteBoxedContract: (params = { args: [] }) => {
      return this.appClient.params.call(AbstractedAccountFactoryParamsFactory.deleteBoxedContract(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `optIn(pay,uint64)void` ABI method.
     *
     * optin tells the contract to opt into an asa
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    optIn: (params) => {
      return this.appClient.params.call(AbstractedAccountFactoryParamsFactory.optIn(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `optInCost(uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    optInCost: (params) => {
      return this.appClient.params.call(AbstractedAccountFactoryParamsFactory.optInCost(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `updateAkitaDAOEscrow(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDaoEscrow: (params) => {
      return this.appClient.params.call(AbstractedAccountFactoryParamsFactory.updateAkitaDaoEscrow(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDao: (params) => {
      return this.appClient.params.call(AbstractedAccountFactoryParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.params.call(AbstractedAccountFactoryParamsFactory.opUp(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the AbstractedAccountFactory smart contract using the `update(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update transaction
       */
      update: (params) => {
        return this.appClient.createTransaction.update(AbstractedAccountFactoryParamsFactory.update.update(params));
      }
    },
    /**
     * Makes a clear_state call to an existing instance of the AbstractedAccountFactory smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `updateRevocation(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateRevocation: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountFactoryParamsFactory.updateRevocation(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `newAccount(pay,address,address,string,address)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    newAccount: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountFactoryParamsFactory.newAccount(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `cost()uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    cost: (params = { args: [] }) => {
      return this.appClient.createTransaction.call(AbstractedAccountFactoryParamsFactory.cost(params));
    },
    /**
         * Makes a call to the AbstractedAccountFactory smart contract using the `updateWallet(uint64)void` ABI method.
         *
        * Permanent: Update a wallet's bytecode. The caller must be the wallet's admin.
        The factory sends the update inner txn as itself (factory address), which the
        wallet accepts because Txn.sender === factoryApp.address.
    
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
    updateWallet: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountFactoryParamsFactory.updateWallet(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `initBoxedContract(string,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    initBoxedContract: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountFactoryParamsFactory.initBoxedContract(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `loadBoxedContract(uint64,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    loadBoxedContract: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountFactoryParamsFactory.loadBoxedContract(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `deleteBoxedContract()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    deleteBoxedContract: (params = { args: [] }) => {
      return this.appClient.createTransaction.call(AbstractedAccountFactoryParamsFactory.deleteBoxedContract(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `optIn(pay,uint64)void` ABI method.
     *
     * optin tells the contract to opt into an asa
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    optIn: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountFactoryParamsFactory.optIn(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `optInCost(uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    optInCost: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountFactoryParamsFactory.optInCost(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `updateAkitaDAOEscrow(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDaoEscrow: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountFactoryParamsFactory.updateAkitaDaoEscrow(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDao: (params) => {
      return this.appClient.createTransaction.call(AbstractedAccountFactoryParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.createTransaction.call(AbstractedAccountFactoryParamsFactory.opUp(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available update methods
     */
    update: {
      /**
       * Updates an existing instance of the AbstractedAccountFactory smart contract using the `update(string)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The update result
       */
      update: async (params) => {
        const result = await this.appClient.send.update(AbstractedAccountFactoryParamsFactory.update.update(params));
        return { ...result, return: result.return };
      }
    },
    /**
     * Makes a clear_state call to an existing instance of the AbstractedAccountFactory smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `updateRevocation(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateRevocation: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountFactoryParamsFactory.updateRevocation(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `newAccount(pay,address,address,string,address)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    newAccount: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountFactoryParamsFactory.newAccount(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `cost()uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    cost: async (params = { args: [] }) => {
      const result = await this.appClient.send.call(AbstractedAccountFactoryParamsFactory.cost(params));
      return { ...result, return: result.return };
    },
    /**
         * Makes a call to the AbstractedAccountFactory smart contract using the `updateWallet(uint64)void` ABI method.
         *
        * Permanent: Update a wallet's bytecode. The caller must be the wallet's admin.
        The factory sends the update inner txn as itself (factory address), which the
        wallet accepts because Txn.sender === factoryApp.address.
    
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
    updateWallet: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountFactoryParamsFactory.updateWallet(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `initBoxedContract(string,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    initBoxedContract: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountFactoryParamsFactory.initBoxedContract(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `loadBoxedContract(uint64,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    loadBoxedContract: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountFactoryParamsFactory.loadBoxedContract(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `deleteBoxedContract()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    deleteBoxedContract: async (params = { args: [] }) => {
      const result = await this.appClient.send.call(AbstractedAccountFactoryParamsFactory.deleteBoxedContract(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `optIn(pay,uint64)void` ABI method.
     *
     * optin tells the contract to opt into an asa
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    optIn: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountFactoryParamsFactory.optIn(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `optInCost(uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    optInCost: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountFactoryParamsFactory.optInCost(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `updateAkitaDAOEscrow(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDaoEscrow: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountFactoryParamsFactory.updateAkitaDaoEscrow(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDao: async (params) => {
      const result = await this.appClient.send.call(AbstractedAccountFactoryParamsFactory.updateAkitaDao(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AbstractedAccountFactory smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    opUp: async (params = { args: [] }) => {
      const result = await this.appClient.send.call(AbstractedAccountFactoryParamsFactory.opUp(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _AbstractedAccountFactoryClient(this.appClient.clone(params));
  }
  /**
   * Makes a readonly (simulated) call to the AbstractedAccountFactory smart contract using the `cost()uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async cost(params = { args: [] }) {
    const result = await this.appClient.send.call(AbstractedAccountFactoryParamsFactory.cost(params));
    return result.return;
  }
  /**
   * Makes a readonly (simulated) call to the AbstractedAccountFactory smart contract using the `optInCost(uint64)uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async optInCost(params) {
    const result = await this.appClient.send.call(AbstractedAccountFactoryParamsFactory.optInCost(params));
    return result.return;
  }
  /**
   * Methods to access state for the current AbstractedAccountFactory app
   */
  state = {
    /**
     * Methods to access global state for the current AbstractedAccountFactory app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async () => {
        const result = await this.appClient.state.global.getAll();
        return {
          escrowFactory: result.escrowFactory,
          revocation: result.revocation,
          domain: result.domain,
          childContractVersion: result.childContractVersion,
          akitaDaoEscrow: result.akitaDAOEscrow,
          version: result.version,
          akitaDao: result.akitaDAO
        };
      },
      /**
       * Get the current value of the escrowFactory key in global state
       */
      escrowFactory: async () => {
        return await this.appClient.state.global.getValue("escrowFactory");
      },
      /**
       * Get the current value of the revocation key in global state
       */
      revocation: async () => {
        return await this.appClient.state.global.getValue("revocation");
      },
      /**
       * Get the current value of the domain key in global state
       */
      domain: async () => {
        return await this.appClient.state.global.getValue("domain");
      },
      /**
       * Get the current value of the childContractVersion key in global state
       */
      childContractVersion: async () => {
        return await this.appClient.state.global.getValue("childContractVersion");
      },
      /**
       * Get the current value of the akitaDAOEscrow key in global state
       */
      akitaDaoEscrow: async () => {
        return await this.appClient.state.global.getValue("akitaDAOEscrow");
      },
      /**
       * Get the current value of the version key in global state
       */
      version: async () => {
        return await this.appClient.state.global.getValue("version");
      },
      /**
       * Get the current value of the akitaDAO key in global state
       */
      akitaDao: async () => {
        return await this.appClient.state.global.getValue("akitaDAO");
      }
    },
    /**
     * Methods to access box state for the current AbstractedAccountFactory app
     */
    box: {
      /**
       * Get all current keyed values from box state
       */
      getAll: async () => {
        const result = await this.appClient.state.box.getAll();
        return {
          boxedContract: new BinaryStateValue(result.boxedContract)
        };
      },
      /**
       * Get the current value of the boxedContract key in box state
       */
      boxedContract: async () => {
        return new BinaryStateValue(await this.appClient.state.box.getValue("boxedContract"));
      }
    }
  };
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a updateRevocation(uint64)void method call against the AbstractedAccountFactory contract
       */
      updateRevocation(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateRevocation(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a newAccount(pay,address,address,string,address)uint64 method call against the AbstractedAccountFactory contract
       */
      newAccount(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.newAccount(params)));
        resultMappers.push((v) => client.decodeReturnValue("newAccount(pay,address,address,string,address)uint64", v));
        return this;
      },
      /**
       * Add a cost()uint64 method call against the AbstractedAccountFactory contract
       */
      cost(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.cost(params)));
        resultMappers.push((v) => client.decodeReturnValue("cost()uint64", v));
        return this;
      },
      /**
       * Add a updateWallet(uint64)void method call against the AbstractedAccountFactory contract
       */
      updateWallet(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateWallet(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a initBoxedContract(string,uint64)void method call against the AbstractedAccountFactory contract
       */
      initBoxedContract(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.initBoxedContract(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a loadBoxedContract(uint64,byte[])void method call against the AbstractedAccountFactory contract
       */
      loadBoxedContract(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.loadBoxedContract(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a deleteBoxedContract()void method call against the AbstractedAccountFactory contract
       */
      deleteBoxedContract(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.deleteBoxedContract(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a optIn(pay,uint64)void method call against the AbstractedAccountFactory contract
       */
      optIn(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.optIn(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a optInCost(uint64)uint64 method call against the AbstractedAccountFactory contract
       */
      optInCost(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.optInCost(params)));
        resultMappers.push((v) => client.decodeReturnValue("optInCost(uint64)uint64", v));
        return this;
      },
      /**
       * Add a updateAkitaDAOEscrow(uint64)void method call against the AbstractedAccountFactory contract
       */
      updateAkitaDaoEscrow(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDaoEscrow(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a updateAkitaDAO(uint64)void method call against the AbstractedAccountFactory contract
       */
      updateAkitaDao(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDao(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a opUp()void method call against the AbstractedAccountFactory contract
       */
      opUp(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.opUp(params)));
        resultMappers.push(void 0);
        return this;
      },
      get update() {
        return {
          update: (params) => {
            promiseChain = promiseChain.then(async () => composer.addAppUpdateMethodCall(await client.params.update.update(params)));
            resultMappers.push(void 0);
            return this;
          }
        };
      },
      /**
       * Add a clear state call to the AbstractedAccountFactory contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/factory.ts
import { ALGORAND_ZERO_ADDRESS_STRING as ALGORAND_ZERO_ADDRESS_STRING2, Address } from "algosdk";
import { microAlgo as microAlgo2 } from "@algorandfoundation/algokit-utils";
var WalletFactorySDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: AbstractedAccountFactoryFactory, ...params }, ENV_VAR_NAMES.WALLET_FACTORY_APP_ID);
  }
  async new({
    sender,
    signer,
    controlledAddress = ALGORAND_ZERO_ADDRESS_STRING2,
    admin = "",
    nickname,
    referrer = ALGORAND_ZERO_ADDRESS_STRING2
  }) {
    const sendParams = this.getRequiredSendParams({ sender, signer });
    const cost = await this.cost();
    const payment = await this.client.algorand.createTransaction.payment({
      ...sendParams,
      receiver: this.client.appAddress,
      amount: microAlgo2(cost)
    });
    if (!admin) {
      admin = sendParams.sender instanceof Address ? sendParams.sender.toString() : sendParams.sender;
    }
    const group = this.client.newGroup();
    const results = await group.newAccount({
      ...sendParams,
      args: {
        payment,
        controlledAddress,
        admin,
        nickname,
        referrer
      },
      maxFee: 5e3.microAlgos()
    }).opUp({ args: {}, maxFee: 1e3.microAlgos() }).send({ ...sendParams });
    const appId = results.returns[0];
    if (!appId) {
      throw new Error("Failed to create new wallet");
    }
    return new WalletSDK({
      algorand: this.algorand,
      factoryParams: {
        appId,
        defaultSender: sendParams.sender,
        defaultSigner: sendParams.signer
      }
    });
  }
  async get({ appId }) {
    return new WalletSDK({
      algorand: this.algorand,
      factoryParams: {
        appId,
        defaultSender: this.sendParams.sender,
        defaultSigner: this.sendParams.signer
      }
    });
  }
  async cost(params) {
    const sendParams = this.getSendParams({
      sender: this.readerAccount,
      signer: emptySigner,
      ...params
    });
    const { return: cost } = await this.client.send.cost({
      ...sendParams,
      args: {}
    });
    if (cost === void 0) {
      throw new Error("Failed to get cost for wallet creation");
    }
    return cost;
  }
};
async function newWallet({
  factoryParams,
  algorand,
  readerAccount,
  sendParams,
  sender,
  signer,
  controlledAddress = ALGORAND_ZERO_ADDRESS_STRING2,
  admin = "",
  nickname,
  referrer = ALGORAND_ZERO_ADDRESS_STRING2
}) {
  const factory = new WalletFactorySDK({ factoryParams, algorand, readerAccount, sendParams });
  const sdk = await factory.new({ sender, signer, controlledAddress, admin, nickname, referrer });
  await sdk.register({ escrow: "" });
  return sdk;
}

// src/generated/OptInPluginClient.ts
import {
  AppClient as _AppClient3
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory3 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC3 = { "name": "OptInPlugin", "structs": {}, "methods": [{ "name": "optIn", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64[]", "name": "assets" }, { "type": "pay", "name": "mbrPayment" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 0, "bytes": 0 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": {}, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": ["NoOp"], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [139], "errorMessage": "Invalid payment" }, { "pc": [42], "errorMessage": "OnCompletion must be NoOp && can only call when creating" }, { "pc": [31], "errorMessage": "OnCompletion must be NoOp && can only call when not creating" }, { "pc": [172], "errorMessage": "already opted in" }, { "pc": [230], "errorMessage": "application exists" }, { "pc": [88], "errorMessage": "invalid number of bytes for (len+uint64[])" }, { "pc": [62], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [52], "errorMessage": "invalid number of bytes for uint64" }, { "pc": [98], "errorMessage": "transaction type is pay" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMSAwIDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL29wdGluL2NvbnRyYWN0LmFsZ28udHM6NgogICAgLy8gZXhwb3J0IGNsYXNzIE9wdEluUGx1Z2luIGV4dGVuZHMgQ29udHJhY3QgewogICAgdHhuIE51bUFwcEFyZ3MKICAgIGJ6IG1haW5fX19hbGdvdHNfXy5kZWZhdWx0Q3JlYXRlQDUKICAgIHB1c2hieXRlcyAweDY4MzVlM2JjIC8vIG1ldGhvZCAib3B0SW4odWludDY0LGJvb2wsdWludDY0W10scGF5KXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX29wdEluX3JvdXRlQDMKICAgIGVycgoKbWFpbl9vcHRJbl9yb3V0ZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvb3B0aW4vY29udHJhY3QuYWxnby50czo4CiAgICAvLyBvcHRJbih3YWxsZXQ6IEFwcGxpY2F0aW9uLCByZWtleUJhY2s6IGJvb2xlYW4sIGFzc2V0czogdWludDY0W10sIG1iclBheW1lbnQ6IGd0eG4uUGF5bWVudFR4bik6IHZvaWQgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICYmCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIG11c3QgYmUgTm9PcCAmJiBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICBiIG9wdEluCgptYWluX19fYWxnb3RzX18uZGVmYXVsdENyZWF0ZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvb3B0aW4vY29udHJhY3QuYWxnby50czo2CiAgICAvLyBleHBvcnQgY2xhc3MgT3B0SW5QbHVnaW4gZXh0ZW5kcyBDb250cmFjdCB7CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgIQogICAgJiYKICAgIHJldHVybiAvLyBvbiBlcnJvcjogT25Db21wbGV0aW9uIG11c3QgYmUgTm9PcCAmJiBjYW4gb25seSBjYWxsIHdoZW4gY3JlYXRpbmcKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9vcHRpbi9jb250cmFjdC5hbGdvLnRzOjpPcHRJblBsdWdpbi5vcHRJbltyb3V0aW5nXSgpIC0+IHZvaWQ6Cm9wdEluOgogICAgcHVzaGJ5dGVzICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9vcHRpbi9jb250cmFjdC5hbGdvLnRzOjgKICAgIC8vIG9wdEluKHdhbGxldDogQXBwbGljYXRpb24sIHJla2V5QmFjazogYm9vbGVhbiwgYXNzZXRzOiB1aW50NjRbXSwgbWJyUGF5bWVudDogZ3R4bi5QYXltZW50VHhuKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18wIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzEgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGR1cAogICAgaW50Y18xIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGR1cAogICAgaW50Y18yIC8vIDgKICAgICoKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICB1bmNvdmVyIDIKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1aW50NjRbXSkKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzAgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18wIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgcHVzaGJ5dGVzICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgZHVwCiAgICBjb3ZlciAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9vcHRpbi9jb250cmFjdC5hbGdvLnRzOjExLTE4CiAgICAvLyBhc3NlcnRNYXRjaCgKICAgIC8vICAgbWJyUGF5bWVudCwKICAgIC8vICAgewogICAgLy8gICAgIHJlY2VpdmVyOiBzZW5kZXIsCiAgICAvLyAgICAgYW1vdW50OiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UgKiBhc3NldHMubGVuZ3RoCiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1BBWU1FTlQKICAgIC8vICkKICAgIGRpZyAxCiAgICBndHhucyBSZWNlaXZlcgogICAgPT0KICAgIHN3YXAKICAgIGd0eG5zIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvb3B0aW4vY29udHJhY3QuYWxnby50czoxNQogICAgLy8gYW1vdW50OiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UgKiBhc3NldHMubGVuZ3RoCiAgICBnbG9iYWwgQXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIHVuY292ZXIgMwogICAgKgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvb3B0aW4vY29udHJhY3QuYWxnby50czoxMS0xOAogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIG1iclBheW1lbnQsCiAgICAvLyAgIHsKICAgIC8vICAgICByZWNlaXZlcjogc2VuZGVyLAogICAgLy8gICAgIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlICogYXNzZXRzLmxlbmd0aAogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICA9PQogICAgJiYKICAgIGFzc2VydCAvLyBJbnZhbGlkIHBheW1lbnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL29wdGluL2NvbnRyYWN0LmFsZ28udHM6MjAKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpKyspIHsKICAgIGludGNfMSAvLyAwCgpvcHRJbl93aGlsZV90b3BAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL29wdGluL2NvbnRyYWN0LmFsZ28udHM6MjAKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpKyspIHsKICAgIGR1cAogICAgZGlnIDMKICAgIDwKICAgIGJ6IG9wdEluX2FmdGVyX3doaWxlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL29wdGluL2NvbnRyYWN0LmFsZ28udHM6MjEKICAgIC8vIGFzc2VydCghc2VuZGVyLmlzT3B0ZWRJbihBc3NldChhc3NldHNbaV0pKSwgRVJSX0FMUkVBRFlfT1BURURfSU4pCiAgICBkaWcgMwogICAgZXh0cmFjdCAyIDAKICAgIGRpZyAxCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGludGNfMiAvLyA4CiAgICAqCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBidXJ5IDkKICAgIGRpZyAzCiAgICBzd2FwCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgIQogICAgYXNzZXJ0IC8vIGFscmVhZHkgb3B0ZWQgaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL29wdGluL2NvbnRyYWN0LmFsZ28udHM6MjMtMzEKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIHNlbmRlciwKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBzZW5kZXIsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgeGZlckFzc2V0OiBBc3NldChhc3NldHNbaV0pLAogICAgLy8gICAgIHJla2V5VG86IGkgPCAoYXNzZXRzLmxlbmd0aCAtIDEpID8gR2xvYmFsLnplcm9BZGRyZXNzIDogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9vcHRpbi9jb250cmFjdC5hbGdvLnRzOjI5CiAgICAvLyByZWtleVRvOiBpIDwgKGFzc2V0cy5sZW5ndGggLSAxKSA/IEdsb2JhbC56ZXJvQWRkcmVzcyA6IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIGRpZyAzCiAgICBpbnRjXzAgLy8gMQogICAgLQogICAgPAogICAgYnogb3B0SW5fdGVybmFyeV9mYWxzZUA1CiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKCm9wdEluX3Rlcm5hcnlfbWVyZ2VANjoKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgZGlnIDYKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9vcHRpbi9jb250cmFjdC5hbGdvLnRzOjI3CiAgICAvLyBhc3NldEFtb3VudDogMCwKICAgIGludGNfMSAvLyAwCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBkaWcgMQogICAgZHVwCiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9vcHRpbi9jb250cmFjdC5hbGdvLnRzOjIzLTMwCiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBzZW5kZXIsCiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogc2VuZGVyLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiAwLAogICAgLy8gICAgIHhmZXJBc3NldDogQXNzZXQoYXNzZXRzW2ldKSwKICAgIC8vICAgICByZWtleVRvOiBpIDwgKGFzc2V0cy5sZW5ndGggLSAxKSA/IEdsb2JhbC56ZXJvQWRkcmVzcyA6IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vICAgfSkKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL29wdGluL2NvbnRyYWN0LmFsZ28udHM6MjMtMzEKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIHNlbmRlciwKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBzZW5kZXIsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgeGZlckFzc2V0OiBBc3NldChhc3NldHNbaV0pLAogICAgLy8gICAgIHJla2V5VG86IGkgPCAoYXNzZXRzLmxlbmd0aCAtIDEpID8gR2xvYmFsLnplcm9BZGRyZXNzIDogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvb3B0aW4vY29udHJhY3QuYWxnby50czoyMAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGFzc2V0cy5sZW5ndGg7IGkrKykgewogICAgZHVwCiAgICBpbnRjXzAgLy8gMQogICAgKwogICAgYnVyeSAxCiAgICBiIG9wdEluX3doaWxlX3RvcEAyCgpvcHRJbl90ZXJuYXJ5X2ZhbHNlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMgogICAgLy8gaWYgKCFyZWtleUJhY2spIHsKICAgIGRpZyA0CiAgICBibnogb3B0SW5fYWZ0ZXJfaWZfZWxzZUAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjMKICAgIC8vIHJldHVybiBHbG9iYWwuemVyb0FkZHJlc3MKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvb3B0aW4vY29udHJhY3QuYWxnby50czoyOQogICAgLy8gcmVrZXlUbzogaSA8IChhc3NldHMubGVuZ3RoIC0gMSkgPyBHbG9iYWwuemVyb0FkZHJlc3MgOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICBiIG9wdEluX3Rlcm5hcnlfbWVyZ2VANgoKb3B0SW5fYWZ0ZXJfaWZfZWxzZUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzI2CiAgICAvLyByZXR1cm4gd2FsbGV0LmFkZHJlc3MKICAgIGRpZyA1CiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9vcHRpbi9jb250cmFjdC5hbGdvLnRzOjI5CiAgICAvLyByZWtleVRvOiBpIDwgKGFzc2V0cy5sZW5ndGggLSAxKSA/IEdsb2JhbC56ZXJvQWRkcmVzcyA6IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIGIgb3B0SW5fdGVybmFyeV9tZXJnZUA2CgpvcHRJbl9hZnRlcl93aGlsZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvb3B0aW4vY29udHJhY3QuYWxnby50czo4CiAgICAvLyBvcHRJbih3YWxsZXQ6IEFwcGxpY2F0aW9uLCByZWtleUJhY2s6IGJvb2xlYW4sIGFzc2V0czogdWludDY0W10sIG1iclBheW1lbnQ6IGd0eG4uUGF5bWVudFR4bik6IHZvaWQgewogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgo=", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyADAQAIMRtBABiABGg147w2GgCOAQABADEZFDEYEERCAAgxGRQxGBQQQ4AANhoBSRUkEkQXSTYaAkkVIhJEI1NMNhoDSU4CSSNZSU4DSSQLgQIITwIVEkQxFiIJSTgQIhJETwKAEHNwZW5kaW5nX2FkZHJlc3NlSElOA0sBOAcSTDgIMhBPAwsSEEQjSUsDDEEAVksDVwIASwFJTgIkC1tJRQlLA0xwAEUBFESxSwMiCQxBACIyA7IgSwayESOyEksBSbIUsgCBBLIQI7IBs0kiCEUBQv+1SwRAAAUyA0L/1ksFcghEQv/OIkM=", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var OptInPluginParamsFactory = class {
  /**
   * Constructs a no op call for the optIn(uint64,bool,uint64[],pay)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static optIn(params) {
    return {
      ...params,
      method: "optIn(uint64,bool,uint64[],pay)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.assets, params.args.mbrPayment]
    };
  }
};
var OptInPluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `OptInPluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory3({
      ...params,
      appSpec: APP_SPEC3
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC3;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new OptInPluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new OptInPluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the OptInPlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    const result = await this.appFactory.deploy({
      ...params
    });
    return { result: result.result, appClient: new OptInPluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the OptInPlugin smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The params for a create call
       */
      bare: (params) => {
        return this.appFactory.params.bare.create(params);
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the OptInPlugin smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The transaction for a create call
       */
      bare: (params) => {
        return this.appFactory.createTransaction.bare.create(params);
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the OptInPlugin smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The create result
       */
      bare: async (params) => {
        const result = await this.appFactory.send.bare.create(params);
        return { result: result.result, appClient: new OptInPluginClient(result.appClient) };
      }
    }
  };
};
var OptInPluginClient = class _OptInPluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient3 ? appClientOrParams : new _AppClient3({
      ...appClientOrParams,
      appSpec: APP_SPEC3
    });
  }
  /**
   * Returns a new `OptInPluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _OptInPluginClient(await _AppClient3.fromCreatorAndName({ ...params, appSpec: APP_SPEC3 }));
  }
  /**
   * Returns an `OptInPluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _OptInPluginClient(await _AppClient3.fromNetwork({ ...params, appSpec: APP_SPEC3 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the OptInPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the OptInPlugin smart contract using the `optIn(uint64,bool,uint64[],pay)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    optIn: (params) => {
      return this.appClient.params.call(OptInPluginParamsFactory.optIn(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the OptInPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the OptInPlugin smart contract using the `optIn(uint64,bool,uint64[],pay)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    optIn: (params) => {
      return this.appClient.createTransaction.call(OptInPluginParamsFactory.optIn(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the OptInPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the OptInPlugin smart contract using the `optIn(uint64,bool,uint64[],pay)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    optIn: async (params) => {
      const result = await this.appClient.send.call(OptInPluginParamsFactory.optIn(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _OptInPluginClient(this.appClient.clone(params));
  }
  /**
   * Methods to access state for the current OptInPlugin app
   */
  state = {};
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a optIn(uint64,bool,uint64[],pay)void method call against the OptInPlugin contract
       */
      optIn(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.optIn(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a clear state call to the OptInPlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/optin.ts
import algosdk3 from "algosdk";
import { microAlgo as microAlgo3 } from "@algorandfoundation/algokit-utils";
var assetOptInCost = 1e5;
var OptInPluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: OptInPluginFactory, ...params });
  }
  optIn(args) {
    const methodName = "optIn";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer, assets } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const mbrPayment = this.client.algorand.createTransaction.payment({
          ...sendParams,
          amount: microAlgo3(assetOptInCost * assets.length),
          receiver: spendingAddress ? spendingAddress : algosdk3.getApplicationAddress(wallet)
        });
        const params = await this.client.params.optIn({
          ...sendParams,
          args: { wallet, ...args, rekeyBack, mbrPayment }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
};

// src/generated/PayPluginClient.ts
import {
  AppClient as _AppClient4
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory4 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC4 = { "name": "PayPlugin", "structs": {}, "methods": [{ "name": "pay", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "(address,uint64,uint64)[]", "name": "payments" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 0, "bytes": 0 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": {}, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": ["NoOp"], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [42], "errorMessage": "OnCompletion must be NoOp && can only call when creating" }, { "pc": [31], "errorMessage": "OnCompletion must be NoOp && can only call when not creating" }, { "pc": [58], "errorMessage": "application exists" }, { "pc": [145], "errorMessage": "index access is out of bounds" }, { "pc": [106], "errorMessage": "invalid number of bytes for (len+(uint8[32],uint64,uint64)[])" }, { "pc": [82], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [72], "errorMessage": "invalid number of bytes for uint64" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDQ4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXkvY29udHJhY3QuYWxnby50czo1CiAgICAvLyBleHBvcnQgY2xhc3MgUGF5UGx1Z2luIGV4dGVuZHMgQ29udHJhY3QgewogICAgdHhuIE51bUFwcEFyZ3MKICAgIGJ6IG1haW5fX19hbGdvdHNfXy5kZWZhdWx0Q3JlYXRlQDUKICAgIHB1c2hieXRlcyAweGY5NzM4NDkyIC8vIG1ldGhvZCAicGF5KHVpbnQ2NCxib29sLChhZGRyZXNzLHVpbnQ2NCx1aW50NjQpW10pdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5fcGF5X3JvdXRlQDMKICAgIGVycgoKbWFpbl9wYXlfcm91dGVAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS9jb250cmFjdC5hbGdvLnRzOjcKICAgIC8vIHBheSh3YWxsZXQ6IEFwcGxpY2F0aW9uLCByZWtleUJhY2s6IGJvb2xlYW4sIHBheW1lbnRzOiBQYXlQYXJhbXNbXSk6IHZvaWQgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICYmCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIG11c3QgYmUgTm9PcCAmJiBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICBiIHBheQoKbWFpbl9fX2FsZ290c19fLmRlZmF1bHRDcmVhdGVANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS9jb250cmFjdC5hbGdvLnRzOjUKICAgIC8vIGV4cG9ydCBjbGFzcyBQYXlQbHVnaW4gZXh0ZW5kcyBDb250cmFjdCB7CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgIQogICAgJiYKICAgIHJldHVybiAvLyBvbiBlcnJvcjogT25Db21wbGV0aW9uIG11c3QgYmUgTm9PcCAmJiBjYW4gb25seSBjYWxsIHdoZW4gY3JlYXRpbmcKCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjpyZWtleUFkZHJlc3MocmVrZXlCYWNrOiB1aW50NjQsIHdhbGxldDogdWludDY0KSAtPiBieXRlczoKcmVrZXlBZGRyZXNzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjEKICAgIC8vIGV4cG9ydCBmdW5jdGlvbiByZWtleUFkZHJlc3MocmVrZXlCYWNrOiBib29sZWFuLCB3YWxsZXQ6IEFwcGxpY2F0aW9uKTogQWNjb3VudCB7CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzIyCiAgICAvLyBpZiAoIXJla2V5QmFjaykgewogICAgZnJhbWVfZGlnIC0yCiAgICBibnogcmVrZXlBZGRyZXNzX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjMKICAgIC8vIHJldHVybiBHbG9iYWwuemVyb0FkZHJlc3MKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgcmV0c3ViCgpyZWtleUFkZHJlc3NfYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjYKICAgIC8vIHJldHVybiB3YWxsZXQuYWRkcmVzcwogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXkvY29udHJhY3QuYWxnby50czo6UGF5UGx1Z2luLnBheVtyb3V0aW5nXSgpIC0+IHZvaWQ6CnBheToKICAgIGludGNfMCAvLyAwCiAgICBwdXNoYnl0ZXMgIiIKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcGF5L2NvbnRyYWN0LmFsZ28udHM6NwogICAgLy8gcGF5KHdhbGxldDogQXBwbGljYXRpb24sIHJla2V5QmFjazogYm9vbGVhbiwgcGF5bWVudHM6IFBheVBhcmFtc1tdKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCA4IC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGludGNfMiAvLyA0OAogICAgKgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIHN3YXAKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbisodWludDhbMzJdLHVpbnQ2NCx1aW50NjQpW10pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgcHVzaGJ5dGVzICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcGF5L2NvbnRyYWN0LmFsZ28udHM6MTAKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBwYXltZW50cy5sZW5ndGg7IGkrKykgewogICAgaW50Y18wIC8vIDAKCnBheV93aGlsZV90b3BAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS9jb250cmFjdC5hbGdvLnRzOjEwCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgcGF5bWVudHMubGVuZ3RoOyBpKyspIHsKICAgIGR1cAogICAgZGlnIDMKICAgIDwKICAgIGJ6IHBheV9hZnRlcl93aGlsZUAxNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcGF5L2NvbnRyYWN0LmFsZ28udHM6MTEKICAgIC8vIGNvbnN0IHsgcmVjZWl2ZXIsIGFzc2V0LCBhbW91bnQgfSA9IHBheW1lbnRzW2ldOwogICAgZGlnIDMKICAgIGV4dHJhY3QgMiAwCiAgICBkaWcgMQogICAgaW50Y18yIC8vIDQ4CiAgICAqCiAgICBpbnRjXzIgLy8gNDgKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBpbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZHVwCiAgICBleHRyYWN0IDAgMzIKICAgIGJ1cnkgMTAKICAgIGR1cAogICAgcHVzaGludCAzMiAvLyAzMgogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgY292ZXIgMgogICAgYnVyeSA5CiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgYnVyeSA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXkvY29udHJhY3QuYWxnby50czoxMwogICAgLy8gaWYgKGFzc2V0ID09PSAwKSB7CiAgICBibnogcGF5X2Vsc2VfYm9keUA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXkvY29udHJhY3QuYWxnby50czoxNC0yMQogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyLAogICAgLy8gICAgIHJlY2VpdmVyLAogICAgLy8gICAgIGFtb3VudCwKICAgIC8vICAgICByZWtleVRvOiBpIDwgKHBheW1lbnRzLmxlbmd0aCAtIDEpID8gR2xvYmFsLnplcm9BZGRyZXNzIDogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXkvY29udHJhY3QuYWxnby50czoxOQogICAgLy8gcmVrZXlUbzogaSA8IChwYXltZW50cy5sZW5ndGggLSAxKSA/IEdsb2JhbC56ZXJvQWRkcmVzcyA6IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICBkaWcgMgogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGRpZyAxCiAgICA+CiAgICBieiBwYXlfdGVybmFyeV9mYWxzZUA2CiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKCnBheV90ZXJuYXJ5X21lcmdlQDc6CiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGRpZyA3CiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgZGlnIDgKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGRpZyAxCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcGF5L2NvbnRyYWN0LmFsZ28udHM6MTQtMjAKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHNlbmRlciwKICAgIC8vICAgICByZWNlaXZlciwKICAgIC8vICAgICBhbW91bnQsCiAgICAvLyAgICAgcmVrZXlUbzogaSA8IChwYXltZW50cy5sZW5ndGggLSAxKSA/IEdsb2JhbC56ZXJvQWRkcmVzcyA6IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyAgIH0pCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXkvY29udHJhY3QuYWxnby50czoxNC0yMQogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyLAogICAgLy8gICAgIHJlY2VpdmVyLAogICAgLy8gICAgIGFtb3VudCwKICAgIC8vICAgICByZWtleVRvOiBpIDwgKHBheW1lbnRzLmxlbmd0aCAtIDEpID8gR2xvYmFsLnplcm9BZGRyZXNzIDogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAoKcGF5X2FmdGVyX2lmX2Vsc2VAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXkvY29udHJhY3QuYWxnby50czoxMAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IHBheW1lbnRzLmxlbmd0aDsgaSsrKSB7CiAgICBkdXAKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBidXJ5IDEKICAgIGIgcGF5X3doaWxlX3RvcEAyCgpwYXlfdGVybmFyeV9mYWxzZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcGF5L2NvbnRyYWN0LmFsZ28udHM6MTkKICAgIC8vIHJla2V5VG86IGkgPCAocGF5bWVudHMubGVuZ3RoIC0gMSkgPyBHbG9iYWwuemVyb0FkZHJlc3MgOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgZGlnIDQKICAgIGRpZyA2CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgYiBwYXlfdGVybmFyeV9tZXJnZUA3CgpwYXlfZWxzZV9ib2R5QDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXkvY29udHJhY3QuYWxnby50czoyMy0zMQogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgc2VuZGVyLAogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IHJlY2VpdmVyLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgICByZWtleVRvOiBpIDwgKHBheW1lbnRzLmxlbmd0aCAtIDEpID8gR2xvYmFsLnplcm9BZGRyZXNzIDogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXkvY29udHJhY3QuYWxnby50czoyOQogICAgLy8gcmVrZXlUbzogaSA8IChwYXltZW50cy5sZW5ndGggLSAxKSA/IEdsb2JhbC56ZXJvQWRkcmVzcyA6IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICBkaWcgMgogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGRpZyAxCiAgICA+CiAgICBieiBwYXlfdGVybmFyeV9mYWxzZUAxMQogICAgZ2xvYmFsIFplcm9BZGRyZXNzCgpwYXlfdGVybmFyeV9tZXJnZUAxMjoKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgZGlnIDYKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBkaWcgNwogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgZGlnIDgKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXkvY29udHJhY3QuYWxnby50czoyMy0zMAogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgc2VuZGVyLAogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IHJlY2VpdmVyLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgICByZWtleVRvOiBpIDwgKHBheW1lbnRzLmxlbmd0aCAtIDEpID8gR2xvYmFsLnplcm9BZGRyZXNzIDogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vICAgfSkKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS9jb250cmFjdC5hbGdvLnRzOjIzLTMxCiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBzZW5kZXIsCiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogcmVjZWl2ZXIsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICAgIHJla2V5VG86IGkgPCAocGF5bWVudHMubGVuZ3RoIC0gMSkgPyBHbG9iYWwuemVyb0FkZHJlc3MgOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICBiIHBheV9hZnRlcl9pZl9lbHNlQDE0CgpwYXlfdGVybmFyeV9mYWxzZUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS9jb250cmFjdC5hbGdvLnRzOjI5CiAgICAvLyByZWtleVRvOiBpIDwgKHBheW1lbnRzLmxlbmd0aCAtIDEpID8gR2xvYmFsLnplcm9BZGRyZXNzIDogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIGRpZyA0CiAgICBkaWcgNgogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIGIgcGF5X3Rlcm5hcnlfbWVyZ2VAMTIKCnBheV9hZnRlcl93aGlsZUAxNToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS9jb250cmFjdC5hbGdvLnRzOjcKICAgIC8vIHBheSh3YWxsZXQ6IEFwcGxpY2F0aW9uLCByZWtleUJhY2s6IGJvb2xlYW4sIHBheW1lbnRzOiBQYXlQYXJhbXNbXSk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgo=", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyADAAEwMRtBABiABPlzhJI2GgCOAQABADEZFDEYEERCABkxGRQxGBQQQ4oCAYv+QAADMgOJi/9yCESJIoAASTYaAUkVgQgSRBdJNhoCSRUjEkQiU0w2GgNJTgJJIllJTgMkC4ECCEwVEkSAEHNwZW5kaW5nX2FkZHJlc3NlSCJJSwMMQQCKSwNXAgBLASQLJFhJVwAgRQpJgSBbSU4CRQmBKFtFCUAANLFLAiMJSwENQQAfMgOyIEsHsghLCLIHSwGyACOyECKyAbNJIwhFAUL/rUsESwaI/1FC/9mxSwIjCUsBDUEAHzIDsiBLBrIRSweyEksIshRLAbIAgQSyECKyAbNC/8RLBEsGiP8dQv/ZI0M=", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var PayPluginParamsFactory = class {
  /**
   * Constructs a no op call for the pay(uint64,bool,(address,uint64,uint64)[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static pay(params) {
    return {
      ...params,
      method: "pay(uint64,bool,(address,uint64,uint64)[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.payments]
    };
  }
};
var PayPluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `PayPluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory4({
      ...params,
      appSpec: APP_SPEC4
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC4;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new PayPluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new PayPluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the PayPlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    const result = await this.appFactory.deploy({
      ...params
    });
    return { result: result.result, appClient: new PayPluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the PayPlugin smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The params for a create call
       */
      bare: (params) => {
        return this.appFactory.params.bare.create(params);
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the PayPlugin smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The transaction for a create call
       */
      bare: (params) => {
        return this.appFactory.createTransaction.bare.create(params);
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the PayPlugin smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The create result
       */
      bare: async (params) => {
        const result = await this.appFactory.send.bare.create(params);
        return { result: result.result, appClient: new PayPluginClient(result.appClient) };
      }
    }
  };
};
var PayPluginClient = class _PayPluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient4 ? appClientOrParams : new _AppClient4({
      ...appClientOrParams,
      appSpec: APP_SPEC4
    });
  }
  /**
   * Returns a new `PayPluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _PayPluginClient(await _AppClient4.fromCreatorAndName({ ...params, appSpec: APP_SPEC4 }));
  }
  /**
   * Returns an `PayPluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _PayPluginClient(await _AppClient4.fromNetwork({ ...params, appSpec: APP_SPEC4 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the PayPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the PayPlugin smart contract using the `pay(uint64,bool,(address,uint64,uint64)[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    pay: (params) => {
      return this.appClient.params.call(PayPluginParamsFactory.pay(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the PayPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the PayPlugin smart contract using the `pay(uint64,bool,(address,uint64,uint64)[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    pay: (params) => {
      return this.appClient.createTransaction.call(PayPluginParamsFactory.pay(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the PayPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the PayPlugin smart contract using the `pay(uint64,bool,(address,uint64,uint64)[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    pay: async (params) => {
      const result = await this.appClient.send.call(PayPluginParamsFactory.pay(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _PayPluginClient(this.appClient.clone(params));
  }
  /**
   * Methods to access state for the current PayPlugin app
   */
  state = {};
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a pay(uint64,bool,(address,uint64,uint64)[])void method call against the PayPlugin contract
       */
      pay(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.pay(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a clear state call to the PayPlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/pay.ts
var PayPluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: PayPluginFactory, ...params });
  }
  pay(args) {
    const methodName = "pay";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer, payments } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const paymentsTuple = payments.map((payment) => [
          payment.receiver.toString(),
          payment.asset,
          payment.amount
        ]);
        const params = await this.client.params.pay({
          ...sendParams,
          args: { wallet, payments: paymentsTuple, rekeyBack }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
};

// src/generated/AsaMintPluginClient.ts
import { getArc56ReturnValue as getArc56ReturnValue3 } from "@algorandfoundation/algokit-utils/types/app-arc56";
import {
  AppClient as _AppClient5
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory5 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC5 = { "name": "AsaMintPlugin", "structs": {}, "methods": [{ "name": "mint", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "(string,string,uint64,uint64,address,address,address,address,bool,string)[]", "name": "assets" }, { "type": "pay", "name": "mbrPayment" }], "returns": { "type": "uint64[]" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 0, "bytes": 0 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": {}, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": ["NoOp"], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [42], "errorMessage": "OnCompletion must be NoOp && can only call when creating" }, { "pc": [31], "errorMessage": "OnCompletion must be NoOp && can only call when not creating" }, { "pc": [393], "errorMessage": "application exists" }, { "pc": [175], "errorMessage": "index access is out of bounds" }, { "pc": [68], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [58], "errorMessage": "invalid number of bytes for uint64" }, { "pc": [132], "errorMessage": "invalid payment" }, { "pc": [358], "errorMessage": "max array length exceeded" }, { "pc": [87], "errorMessage": "transaction type is pay" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2FzYS1taW50L2NvbnRyYWN0LmFsZ28udHM6NwogICAgLy8gZXhwb3J0IGNsYXNzIEFzYU1pbnRQbHVnaW4gZXh0ZW5kcyBDb250cmFjdCB7CiAgICB0eG4gTnVtQXBwQXJncwogICAgYnogbWFpbl9fX2FsZ290c19fLmRlZmF1bHRDcmVhdGVANQogICAgcHVzaGJ5dGVzIDB4MGRhMzk5MzkgLy8gbWV0aG9kICJtaW50KHVpbnQ2NCxib29sLChzdHJpbmcsc3RyaW5nLHVpbnQ2NCx1aW50NjQsYWRkcmVzcyxhZGRyZXNzLGFkZHJlc3MsYWRkcmVzcyxib29sLHN0cmluZylbXSxwYXkpdWludDY0W10iCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX21pbnRfcm91dGVAMwogICAgZXJyCgptYWluX21pbnRfcm91dGVAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2FzYS1taW50L2NvbnRyYWN0LmFsZ28udHM6OS0xNAogICAgLy8gbWludCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhc3NldHM6IENyZWF0ZUFzc2V0UGFyYW1zW10sCiAgICAvLyAgIG1iclBheW1lbnQ6IGd0eG4uUGF5bWVudFR4bgogICAgLy8gKTogdWludDY0W10gewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICYmCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIG11c3QgYmUgTm9PcCAmJiBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICBiIG1pbnQKCm1haW5fX19hbGdvdHNfXy5kZWZhdWx0Q3JlYXRlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hc2EtbWludC9jb250cmFjdC5hbGdvLnRzOjcKICAgIC8vIGV4cG9ydCBjbGFzcyBBc2FNaW50UGx1Z2luIGV4dGVuZHMgQ29udHJhY3QgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgICYmCiAgICByZXR1cm4gLy8gb24gZXJyb3I6IE9uQ29tcGxldGlvbiBtdXN0IGJlIE5vT3AgJiYgY2FuIG9ubHkgY2FsbCB3aGVuIGNyZWF0aW5nCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXNhLW1pbnQvY29udHJhY3QuYWxnby50czo6QXNhTWludFBsdWdpbi5taW50W3JvdXRpbmddKCkgLT4gdm9pZDoKbWludDoKICAgIGludGNfMCAvLyAwCiAgICBkdXBuIDYKICAgIHB1c2hieXRlcyAiIgogICAgZHVwbiAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hc2EtbWludC9jb250cmFjdC5hbGdvLnRzOjktMTQKICAgIC8vIG1pbnQoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXNzZXRzOiBDcmVhdGVBc3NldFBhcmFtc1tdLAogICAgLy8gICBtYnJQYXltZW50OiBndHhuLlBheW1lbnRUeG4KICAgIC8vICk6IHVpbnQ2NFtdIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDggLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHN3YXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBwdXNoYnl0ZXMgInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2FzYS1taW50L2NvbnRyYWN0LmFsZ28udHM6MTctMjQKICAgIC8vIGFzc2VydE1hdGNoKAogICAgLy8gICBtYnJQYXltZW50LAogICAgLy8gICB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IHNlbmRlciwKICAgIC8vICAgICBhbW91bnQ6IEdsb2JhbC5hc3NldENyZWF0ZU1pbkJhbGFuY2UgKiBhc3NldHMubGVuZ3RoCiAgICAvLyAgIH0sCiAgICAvLyAgIEVSUl9JTlZBTElEX1BBWU1FTlQKICAgIC8vICkKICAgIGRpZyAxCiAgICBndHhucyBSZWNlaXZlcgogICAgPT0KICAgIHN3YXAKICAgIGd0eG5zIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXNhLW1pbnQvY29udHJhY3QuYWxnby50czoyMQogICAgLy8gYW1vdW50OiBHbG9iYWwuYXNzZXRDcmVhdGVNaW5CYWxhbmNlICogYXNzZXRzLmxlbmd0aAogICAgZ2xvYmFsIEFzc2V0Q3JlYXRlTWluQmFsYW5jZQogICAgdW5jb3ZlciAzCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGR1cAogICAgY292ZXIgNAogICAgKgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXNhLW1pbnQvY29udHJhY3QuYWxnby50czoxNy0yNAogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIG1iclBheW1lbnQsCiAgICAvLyAgIHsKICAgIC8vICAgICByZWNlaXZlcjogc2VuZGVyLAogICAgLy8gICAgIGFtb3VudDogR2xvYmFsLmFzc2V0Q3JlYXRlTWluQmFsYW5jZSAqIGFzc2V0cy5sZW5ndGgKICAgIC8vICAgfSwKICAgIC8vICAgRVJSX0lOVkFMSURfUEFZTUVOVAogICAgLy8gKQogICAgPT0KICAgICYmCiAgICBhc3NlcnQgLy8gaW52YWxpZCBwYXltZW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hc2EtbWludC9jb250cmFjdC5hbGdvLnRzOjI2CiAgICAvLyBsZXQgYXNzZXRzQ3JlYXRlZDogdWludDY0W10gPSBbXTsKICAgIHB1c2hieXRlcyAweDAwMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2FzYS1taW50L2NvbnRyYWN0LmFsZ28udHM6MjcKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpKyspIHsKICAgIGludGNfMCAvLyAwCgptaW50X3doaWxlX3RvcEAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXNhLW1pbnQvY29udHJhY3QuYWxnby50czoyNwogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGFzc2V0cy5sZW5ndGg7IGkrKykgewogICAgZHVwCiAgICBkaWcgMwogICAgPAogICAgYnogbWludF9hZnRlcl93aGlsZUA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hc2EtbWludC9jb250cmFjdC5hbGdvLnRzOjM5CiAgICAvLyB9ID0gYXNzZXRzW2ldOwogICAgZGlnIDQKICAgIGV4dHJhY3QgMiAwCiAgICBkaWcgMQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBpbnRjXzIgLy8gMgogICAgKgogICAgZGlnIDEKICAgIHN3YXAKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGR1cAogICAgYnVyeSAxMwogICAgZGlnIDYKICAgIGR1cAogICAgY292ZXIgNAogICAgZGlnIDEKICAgIC0gLy8gb24gZXJyb3I6IGluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBkaWcgMwogICAgbGVuCiAgICB1bmNvdmVyIDIKICAgIGludGNfMiAvLyAyCiAgICAqCiAgICBkaWcgNAogICAgc3dhcAogICAgZXh0cmFjdF91aW50MTYKICAgIHVuY292ZXIgMgogICAgc2VsZWN0CiAgICBzdWJzdHJpbmczCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZGlnIDEKICAgIGludGNfMiAvLyAyCiAgICBleHRyYWN0X3VpbnQxNgogICAgZGlnIDIKICAgIHVuY292ZXIgMgogICAgZGlnIDIKICAgIHN1YnN0cmluZzMKICAgIGV4dHJhY3QgMiAwCiAgICBidXJ5IDIyCiAgICBkaWcgMQogICAgcHVzaGludCAxNDkgLy8gMTQ5CiAgICBleHRyYWN0X3VpbnQxNgogICAgZGlnIDIKICAgIHVuY292ZXIgMgogICAgZGlnIDIKICAgIHN1YnN0cmluZzMKICAgIGV4dHJhY3QgMiAwCiAgICBidXJ5IDE3CiAgICBkaWcgMQogICAgcHVzaGludCA0IC8vIDQKICAgIGV4dHJhY3RfdWludDY0CiAgICBidXJ5IDEyCiAgICBkaWcgMQogICAgcHVzaGludCAxMiAvLyAxMgogICAgZXh0cmFjdF91aW50NjQKICAgIGJ1cnkgMTUKICAgIGRpZyAxCiAgICBleHRyYWN0IDIwIDMyCiAgICBidXJ5IDE5CiAgICBkaWcgMQogICAgZXh0cmFjdCA1MiAzMgogICAgYnVyeSAxOAogICAgZGlnIDEKICAgIGV4dHJhY3QgODQgMzIKICAgIGJ1cnkgMjAKICAgIGRpZyAxCiAgICBleHRyYWN0IDExNiAzMgogICAgYnVyeSAyMQogICAgZGlnIDEKICAgIHB1c2hpbnQgMTE4NCAvLyAxMTg0CiAgICBnZXRiaXQKICAgIGJ1cnkgMTQKICAgIGRpZyAxCiAgICBsZW4KICAgIHN1YnN0cmluZzMKICAgIGV4dHJhY3QgMiAwCiAgICBidXJ5IDE0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hc2EtbWludC9jb250cmFjdC5hbGdvLnRzOjQxLTU2CiAgICAvLyBjb25zdCBjcmVhdGVUeG4gPSBpdHhuCiAgICAvLyAgIC5hc3NldENvbmZpZyh7CiAgICAvLyAgICAgc2VuZGVyLAogICAgLy8gICAgIGFzc2V0TmFtZSwKICAgIC8vICAgICB1bml0TmFtZSwKICAgIC8vICAgICB0b3RhbCwKICAgIC8vICAgICBkZWNpbWFscywKICAgIC8vICAgICBtYW5hZ2VyLAogICAgLy8gICAgIHJlc2VydmUsCiAgICAvLyAgICAgZnJlZXplLAogICAgLy8gICAgIGNsYXdiYWNrLAogICAgLy8gICAgIGRlZmF1bHRGcm96ZW4sCiAgICAvLyAgICAgdXJsLAogICAgLy8gICAgIHJla2V5VG86IGkgPCAoYXNzZXRzLmxlbmd0aCAtIDEpID8gR2xvYmFsLnplcm9BZGRyZXNzIDogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2FzYS1taW50L2NvbnRyYWN0LmFsZ28udHM6NTQKICAgIC8vIHJla2V5VG86IGkgPCAoYXNzZXRzLmxlbmd0aCAtIDEpID8gR2xvYmFsLnplcm9BZGRyZXNzIDogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIDwKICAgIGJ6IG1pbnRfdGVybmFyeV9mYWxzZUA1CiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKCm1pbnRfdGVybmFyeV9tZXJnZUA2OgogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBkaWcgMTEKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXRVUkwKICAgIGRpZyA5CiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RGVmYXVsdEZyb3plbgogICAgZGlnIDE2CiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0Q2xhd2JhY2sKICAgIGRpZyAxNQogICAgaXR4bl9maWVsZCBDb25maWdBc3NldEZyZWV6ZQogICAgZGlnIDEzCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0UmVzZXJ2ZQogICAgZGlnIDE0CiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0TWFuYWdlcgogICAgZGlnIDEwCiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RGVjaW1hbHMKICAgIGRpZyA3CiAgICBpdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VG90YWwKICAgIGRpZyAxMgogICAgaXR4bl9maWVsZCBDb25maWdBc3NldFVuaXROYW1lCiAgICBkaWcgMTcKICAgIGl0eG5fZmllbGQgQ29uZmlnQXNzZXROYW1lCiAgICBkaWcgMwogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2FzYS1taW50L2NvbnRyYWN0LmFsZ28udHM6NDEtNTUKICAgIC8vIGNvbnN0IGNyZWF0ZVR4biA9IGl0eG4KICAgIC8vICAgLmFzc2V0Q29uZmlnKHsKICAgIC8vICAgICBzZW5kZXIsCiAgICAvLyAgICAgYXNzZXROYW1lLAogICAgLy8gICAgIHVuaXROYW1lLAogICAgLy8gICAgIHRvdGFsLAogICAgLy8gICAgIGRlY2ltYWxzLAogICAgLy8gICAgIG1hbmFnZXIsCiAgICAvLyAgICAgcmVzZXJ2ZSwKICAgIC8vICAgICBmcmVlemUsCiAgICAvLyAgICAgY2xhd2JhY2ssCiAgICAvLyAgICAgZGVmYXVsdEZyb3plbiwKICAgIC8vICAgICB1cmwsCiAgICAvLyAgICAgcmVrZXlUbzogaSA8IChhc3NldHMubGVuZ3RoIC0gMSkgPyBHbG9iYWwuemVyb0FkZHJlc3MgOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyAgIH0pCiAgICBwdXNoaW50IDMgLy8gMwogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hc2EtbWludC9jb250cmFjdC5hbGdvLnRzOjQxLTU2CiAgICAvLyBjb25zdCBjcmVhdGVUeG4gPSBpdHhuCiAgICAvLyAgIC5hc3NldENvbmZpZyh7CiAgICAvLyAgICAgc2VuZGVyLAogICAgLy8gICAgIGFzc2V0TmFtZSwKICAgIC8vICAgICB1bml0TmFtZSwKICAgIC8vICAgICB0b3RhbCwKICAgIC8vICAgICBkZWNpbWFscywKICAgIC8vICAgICBtYW5hZ2VyLAogICAgLy8gICAgIHJlc2VydmUsCiAgICAvLyAgICAgZnJlZXplLAogICAgLy8gICAgIGNsYXdiYWNrLAogICAgLy8gICAgIGRlZmF1bHRGcm96ZW4sCiAgICAvLyAgICAgdXJsLAogICAgLy8gICAgIHJla2V5VG86IGkgPCAoYXNzZXRzLmxlbmd0aCAtIDEpID8gR2xvYmFsLnplcm9BZGRyZXNzIDogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIENyZWF0ZWRBc3NldElECiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hc2EtbWludC9jb250cmFjdC5hbGdvLnRzOjU4CiAgICAvLyBhc3NldHNDcmVhdGVkLnB1c2goY3JlYXRlVHhuLmNyZWF0ZWRBc3NldC5pZCk7CiAgICBpdG9iCiAgICBkaWcgMgogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdCAvLyBvbiBlcnJvcjogbWF4IGFycmF5IGxlbmd0aCBleGNlZWRlZAogICAgc3dhcAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHJlcGxhY2UyIDAKICAgIGJ1cnkgMgogICAgZGlnIDgKICAgIGJ1cnkgMQogICAgYiBtaW50X3doaWxlX3RvcEAyCgptaW50X3Rlcm5hcnlfZmFsc2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzIyCiAgICAvLyBpZiAoIXJla2V5QmFjaykgewogICAgZGlnIDUKICAgIGJueiBtaW50X2FmdGVyX2lmX2Vsc2VAMTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzIzCiAgICAvLyByZXR1cm4gR2xvYmFsLnplcm9BZGRyZXNzCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2FzYS1taW50L2NvbnRyYWN0LmFsZ28udHM6NTQKICAgIC8vIHJla2V5VG86IGkgPCAoYXNzZXRzLmxlbmd0aCAtIDEpID8gR2xvYmFsLnplcm9BZGRyZXNzIDogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgYiBtaW50X3Rlcm5hcnlfbWVyZ2VANgoKbWludF9hZnRlcl9pZl9lbHNlQDExOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjYKICAgIC8vIHJldHVybiB3YWxsZXQuYWRkcmVzcwogICAgZGlnIDYKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2FzYS1taW50L2NvbnRyYWN0LmFsZ28udHM6NTQKICAgIC8vIHJla2V5VG86IGkgPCAoYXNzZXRzLmxlbmd0aCAtIDEpID8gR2xvYmFsLnplcm9BZGRyZXNzIDogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgYiBtaW50X3Rlcm5hcnlfbWVyZ2VANgoKbWludF9hZnRlcl93aGlsZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXNhLW1pbnQvY29udHJhY3QuYWxnby50czo5LTE0CiAgICAvLyBtaW50KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFzc2V0czogQ3JlYXRlQXNzZXRQYXJhbXNbXSwKICAgIC8vICAgbWJyUGF5bWVudDogZ3R4bi5QYXltZW50VHhuCiAgICAvLyApOiB1aW50NjRbXSB7CiAgICBwdXNoYnl0ZXMgMHgxNTFmN2M3NQogICAgZGlnIDIKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCg==", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyADAAECMRtBABiABA2jmTk2GgCOAQABADEZFDEYEERCAAgxGRQxGBQQQyJHBoAARwM2GgFJFYEIEkQXSTYaAkkVIxJEIlNMNhoDSU8CMRYjCUk4ECMSREyAEHNwZW5kaW5nX2FkZHJlc3NlSElOA0sBOAcSTDgIMg9PAyJZSU4ECxIQRIACAAAiSUsDDEEA/EsEVwIASwFJTgIkC0sBTFlLAiMISUUNSwZJTgRLAQlLAxVPAiQLSwRMWU8CTVJJIllLASRZSwJPAksCUlcCAEUWSwGBlQFZSwJPAksCUlcCAEURSwGBBFtFDEsBgQxbRQ9LAVcUIEUTSwFXNCBFEksBV1QgRRRLAVd0IEUVSwGBoAlTRQ5LARVSVwIARQ6xIwkMQQBVMgOyIEsLsidLCbIkSxCyLEsPsitLDbIqSw6yKUsKsiNLB7IiSwyyJUsRsiZLA7IAgQOyECKyAbO0PBZLAklPAlBMIlkjCBZXBgJcAEUCSwhFAUL/D0sFQAAFMgNC/6NLBnIIREL/m4AEFR98dUsCULAjQw==", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var AsaMintPluginParamsFactory = class {
  /**
   * Constructs a no op call for the mint(uint64,bool,(string,string,uint64,uint64,address,address,address,address,bool,string)[],pay)uint64[] ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mint(params) {
    return {
      ...params,
      method: "mint(uint64,bool,(string,string,uint64,uint64,address,address,address,address,bool,string)[],pay)uint64[]",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.assets, params.args.mbrPayment]
    };
  }
};
var AsaMintPluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `AsaMintPluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory5({
      ...params,
      appSpec: APP_SPEC5
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC5;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new AsaMintPluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new AsaMintPluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the AsaMintPlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    const result = await this.appFactory.deploy({
      ...params
    });
    return { result: result.result, appClient: new AsaMintPluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the AsaMintPlugin smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The params for a create call
       */
      bare: (params) => {
        return this.appFactory.params.bare.create(params);
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the AsaMintPlugin smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The transaction for a create call
       */
      bare: (params) => {
        return this.appFactory.createTransaction.bare.create(params);
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the AsaMintPlugin smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The create result
       */
      bare: async (params) => {
        const result = await this.appFactory.send.bare.create(params);
        return { result: result.result, appClient: new AsaMintPluginClient(result.appClient) };
      }
    }
  };
};
var AsaMintPluginClient = class _AsaMintPluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient5 ? appClientOrParams : new _AppClient5({
      ...appClientOrParams,
      appSpec: APP_SPEC5
    });
  }
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue(method, returnValue) {
    return returnValue !== void 0 ? getArc56ReturnValue3(returnValue, this.appClient.getABIMethod(method), APP_SPEC5.structs) : void 0;
  }
  /**
   * Returns a new `AsaMintPluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _AsaMintPluginClient(await _AppClient5.fromCreatorAndName({ ...params, appSpec: APP_SPEC5 }));
  }
  /**
   * Returns an `AsaMintPluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _AsaMintPluginClient(await _AppClient5.fromNetwork({ ...params, appSpec: APP_SPEC5 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the AsaMintPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the AsaMintPlugin smart contract using the `mint(uint64,bool,(string,string,uint64,uint64,address,address,address,address,bool,string)[],pay)uint64[]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    mint: (params) => {
      return this.appClient.params.call(AsaMintPluginParamsFactory.mint(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the AsaMintPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the AsaMintPlugin smart contract using the `mint(uint64,bool,(string,string,uint64,uint64,address,address,address,address,bool,string)[],pay)uint64[]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    mint: (params) => {
      return this.appClient.createTransaction.call(AsaMintPluginParamsFactory.mint(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the AsaMintPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the AsaMintPlugin smart contract using the `mint(uint64,bool,(string,string,uint64,uint64,address,address,address,address,bool,string)[],pay)uint64[]` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mint: async (params) => {
      const result = await this.appClient.send.call(AsaMintPluginParamsFactory.mint(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _AsaMintPluginClient(this.appClient.clone(params));
  }
  /**
   * Methods to access state for the current AsaMintPlugin app
   */
  state = {};
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a mint(uint64,bool,(string,string,uint64,uint64,address,address,address,address,bool,string)[],pay)uint64[] method call against the AsaMintPlugin contract
       */
      mint(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mint(params)));
        resultMappers.push((v) => client.decodeReturnValue("mint(uint64,bool,(string,string,uint64,uint64,address,address,address,address,bool,string)[],pay)uint64[]", v));
        return this;
      },
      /**
       * Add a clear state call to the AsaMintPlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/asa-mint.ts
import algosdk4 from "algosdk";
import { microAlgo as microAlgo4 } from "@algorandfoundation/algokit-utils";
var assetCreateCost = 1e5;
var AsaMintPluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: AsaMintPluginFactory, ...params });
  }
  mint(args) {
    const methodName = "mint";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer, assets } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const mbrPayment = this.client.algorand.createTransaction.payment({
          ...sendParams,
          amount: microAlgo4(assetCreateCost * assets.length),
          receiver: spendingAddress ? spendingAddress : algosdk4.getApplicationAddress(wallet)
        });
        const assetsTuple = assets.map((asset) => [
          asset.assetName,
          asset.unitName,
          asset.total,
          asset.decimals,
          asset.manager,
          asset.reserve,
          asset.freeze,
          asset.clawback,
          asset.defaultFrozen,
          asset.url
        ]);
        const params = await this.client.params.mint({
          ...sendParams,
          args: { wallet, assets: assetsTuple, rekeyBack, mbrPayment }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
};

// src/generated/UpdateAkitaDAOPluginClient.ts
import {
  AppClient as _AppClient6
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory6 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC6 = { "name": "UpdateAkitaDAOPlugin", "structs": {}, "methods": [{ "name": "create", "args": [{ "type": "uint64", "name": "akitaDAO" }, { "type": "byte[]", "name": "clearProgram" }], "returns": { "type": "void" }, "actions": { "create": ["NoOp"], "call": [] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "setClearProgram", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "byte[]", "name": "clearProgram" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "initBoxedContract", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "string", "name": "version" }, { "type": "uint64", "name": "size" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "loadBoxedContract", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "uint64", "name": "offset" }, { "type": "byte[]", "name": "data" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "deleteBoxedContract", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "updateApp", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "updateAkitaDaoAppIDForApp", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "uint64", "name": "newAkitaDAOAppID" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "updateAkitaDaoEscrowForApp", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "uint64", "name": "newEscrow" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "updateRevocation", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "app" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "updateFactoryChildContract", "args": [{ "type": "uint64", "name": "wallet", "desc": "- The DAO wallet app" }, { "type": "bool", "name": "rekeyBack", "desc": "- Whether to rekey the wallet back after the operation" }, { "type": "uint64", "name": "factoryAppId", "desc": "- The factory app to update (e.g., walletFactory)" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Updates the factory's child contract bytecode using the contract stored in this plugin's box.\nThis allows the factory to deploy new wallets with the updated AbstractedAccount contract.\n\nThe contract must first be uploaded to this plugin via initBoxedContract/loadBoxedContract,\nthen this method transfers it to the factory's box storage via inner transactions.\n\nUses itxnCompose to group all inner transactions together so the factory's loadBoxedContract\nvalidation (which checks gtxn for initBoxedContract) works correctly.", "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 1, "bytes": 2 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": { "akitaDAO": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "YWtpdGFfZGFv", "desc": "the app ID of the Akita DAO" }, "childContractVersion": { "keyType": "AVMString", "valueType": "AVMString", "key": "Y2hpbGRfY29udHJhY3RfdmVyc2lvbg==" }, "clearProgram": { "keyType": "AVMString", "valueType": "AVMBytes", "key": "Y2xlYXJfcHJvZ3JhbQ==" } }, "local": {}, "box": { "boxedContract": { "keyType": "AVMString", "valueType": "AVMBytes", "key": "YmM=" } } }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": [], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [695], "errorMessage": "Box must have value" }, { "pc": [539, 1159], "errorMessage": "Contract not set" }, { "pc": [534, 688, 1150], "errorMessage": "Invalid call order" }, { "pc": [100], "errorMessage": "OnCompletion must be NoOp" }, { "pc": [330, 393, 471, 587, 997, 1093], "errorMessage": "Only the Akita DAO can call this function" }, { "pc": [240, 328, 391, 469, 585, 993, 1091], "errorMessage": "application exists" }, { "pc": [322, 385, 463, 579, 723, 735, 986, 1085, 1164], "errorMessage": "check GlobalState exists" }, { "pc": [264, 310, 451], "errorMessage": "invalid number of bytes for (len+uint8[])" }, { "pc": [363], "errorMessage": "invalid number of bytes for (len+utf8[])" }, { "pc": [294, 568, 615, 817, 892, 967, 1064], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [249, 285, 348, 374, 424, 433, 559, 605, 626, 808, 827, 836, 883, 902, 911, 958, 977, 1054, 1075], "errorMessage": "invalid number of bytes for uint64" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDggNiA0MDk2IDIwMzIKICAgIGJ5dGVjYmxvY2sgImJjIiAic3BlbmRpbmdfYWRkcmVzcyIgImFraXRhX2RhbyIgIndhbGxldCIgMHgyZTFkMjIyOSAiY2xlYXJfcHJvZ3JhbSIgImNoaWxkX2NvbnRyYWN0X3ZlcnNpb24iIDB4MTcwYmRlNjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoxNwogICAgLy8gZXhwb3J0IGNsYXNzIFVwZGF0ZUFraXRhREFPUGx1Z2luIGV4dGVuZHMgQ29udHJhY3QgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBieiBtYWluX2NyZWF0ZV9Ob09wQDEzCiAgICBwdXNoYnl0ZXMgMHhkMTVjM2Q3MCAvLyBtZXRob2QgInNldENsZWFyUHJvZ3JhbSh1aW50NjQsYm9vbCxieXRlW10pdm9pZCIKICAgIGJ5dGVjIDcgLy8gbWV0aG9kICJpbml0Qm94ZWRDb250cmFjdCh1aW50NjQsc3RyaW5nLHVpbnQ2NCl2b2lkIgogICAgYnl0ZWMgNCAvLyBtZXRob2QgImxvYWRCb3hlZENvbnRyYWN0KHVpbnQ2NCx1aW50NjQsYnl0ZVtdKXZvaWQiCiAgICBwdXNoYnl0ZXNzIDB4Y2I5OGRlZTkgMHg2YWQ3OGMxNCAweDg5ZTI1YTI0IDB4M2YzZTI1YjggMHg5MjM3MTYxNyAweDY4Yjc0ZTVjIC8vIG1ldGhvZCAiZGVsZXRlQm94ZWRDb250cmFjdCh1aW50NjQsYm9vbCl2b2lkIiwgbWV0aG9kICJ1cGRhdGVBcHAodWludDY0LGJvb2wsdWludDY0KXZvaWQiLCBtZXRob2QgInVwZGF0ZUFraXRhRGFvQXBwSURGb3JBcHAodWludDY0LGJvb2wsdWludDY0LHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJ1cGRhdGVBa2l0YURhb0VzY3Jvd0ZvckFwcCh1aW50NjQsYm9vbCx1aW50NjQsdWludDY0KXZvaWQiLCBtZXRob2QgInVwZGF0ZVJldm9jYXRpb24odWludDY0LGJvb2wsdWludDY0KXZvaWQiLCBtZXRob2QgInVwZGF0ZUZhY3RvcnlDaGlsZENvbnRyYWN0KHVpbnQ2NCxib29sLHVpbnQ2NCl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggc2V0Q2xlYXJQcm9ncmFtIGluaXRCb3hlZENvbnRyYWN0IGxvYWRCb3hlZENvbnRyYWN0IGRlbGV0ZUJveGVkQ29udHJhY3QgdXBkYXRlQXBwIHVwZGF0ZUFraXRhRGFvQXBwSURGb3JBcHAgdXBkYXRlQWtpdGFEYW9Fc2Nyb3dGb3JBcHAgdXBkYXRlUmV2b2NhdGlvbiB1cGRhdGVGYWN0b3J5Q2hpbGRDb250cmFjdAogICAgZXJyCgptYWluX2NyZWF0ZV9Ob09wQDEzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjE3CiAgICAvLyBleHBvcnQgY2xhc3MgVXBkYXRlQWtpdGFEQU9QbHVnaW4gZXh0ZW5kcyBDb250cmFjdCB7CiAgICBwdXNoYnl0ZXMgMHg1M2RmZDkxYiAvLyBtZXRob2QgImNyZWF0ZSh1aW50NjQsYnl0ZVtdKXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBjcmVhdGUKICAgIGVycgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OnJla2V5QmFja0lmTmVjZXNzYXJ5KHJla2V5QmFjazogdWludDY0LCB3YWxsZXQ6IHVpbnQ2NCkgLT4gdm9pZDoKcmVrZXlCYWNrSWZOZWNlc3Nhcnk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMwNwogICAgLy8gZXhwb3J0IGZ1bmN0aW9uIHJla2V5QmFja0lmTmVjZXNzYXJ5KHJla2V5QmFjazogYm9vbGVhbiwgd2FsbGV0OiBBcHBsaWNhdGlvbik6IHZvaWQgewogICAgcHJvdG8gMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMwOAogICAgLy8gaWYgKHJla2V5QmFjaykgewogICAgZnJhbWVfZGlnIC0yCiAgICBieiByZWtleUJhY2tJZk5lY2Vzc2FyeV9hZnRlcl9pZl9lbHNlQDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGZyYW1lX2RpZyAtMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMxMC0zMTcKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHNlbmRlciwKICAgIC8vICAgICByZWNlaXZlcjogc2VuZGVyLAogICAgLy8gICAgIGFtb3VudDogMCwKICAgIC8vICAgICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzE1CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzE0CiAgICAvLyBhbW91bnQ6IDAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGR1cAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzEwLTMxNgogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyLAogICAgLy8gICAgIHJlY2VpdmVyOiBzZW5kZXIsCiAgICAvLyAgICAgYW1vdW50OiAwLAogICAgLy8gICAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyAgIH0pCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMxMC0zMTcKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHNlbmRlciwKICAgIC8vICAgICByZWNlaXZlcjogc2VuZGVyLAogICAgLy8gICAgIGFtb3VudDogMCwKICAgIC8vICAgICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CgpyZWtleUJhY2tJZk5lY2Vzc2FyeV9hZnRlcl9pZl9lbHNlQDM6CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjpyZWtleUFkZHJlc3MocmVrZXlCYWNrOiB1aW50NjQsIHdhbGxldDogdWludDY0KSAtPiBieXRlczoKcmVrZXlBZGRyZXNzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjEKICAgIC8vIGV4cG9ydCBmdW5jdGlvbiByZWtleUFkZHJlc3MocmVrZXlCYWNrOiBib29sZWFuLCB3YWxsZXQ6IEFwcGxpY2F0aW9uKTogQWNjb3VudCB7CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzIyCiAgICAvLyBpZiAoIXJla2V5QmFjaykgewogICAgZnJhbWVfZGlnIC0yCiAgICBibnogcmVrZXlBZGRyZXNzX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjMKICAgIC8vIHJldHVybiBHbG9iYWwuemVyb0FkZHJlc3MKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgcmV0c3ViCgpyZWtleUFkZHJlc3NfYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjYKICAgIC8vIHJldHVybiB3YWxsZXQuYWRkcmVzcwogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6OlVwZGF0ZUFraXRhREFPUGx1Z2luLmNyZWF0ZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmNyZWF0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czozMwogICAgLy8gQGFiaW1ldGhvZCh7IG9uQ3JlYXRlOiAncmVxdWlyZScgfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdWludDhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjAKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18yIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MzUKICAgIC8vIHRoaXMuYWtpdGFEQU8udmFsdWUgPSBha2l0YURBTwogICAgdW5jb3ZlciAyCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjI0CiAgICAvLyBjbGVhclByb2dyYW0gPSBHbG9iYWxTdGF0ZTxieXRlcz4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5Q2xlYXJQcm9ncmFtIH0pCiAgICBieXRlYyA1IC8vICJjbGVhcl9wcm9ncmFtIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjM2CiAgICAvLyB0aGlzLmNsZWFyUHJvZ3JhbS52YWx1ZSA9IGNsZWFyUHJvZ3JhbQogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czozMwogICAgLy8gQGFiaW1ldGhvZCh7IG9uQ3JlYXRlOiAncmVxdWlyZScgfSkKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6OlVwZGF0ZUFraXRhREFPUGx1Z2luLnNldENsZWFyUHJvZ3JhbVtyb3V0aW5nXSgpIC0+IHZvaWQ6CnNldENsZWFyUHJvZ3JhbToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czozOQogICAgLy8gc2V0Q2xlYXJQcm9ncmFtKHdhbGxldDogQXBwbGljYXRpb24sIHJla2V5QmFjazogYm9vbGVhbiwgY2xlYXJQcm9ncmFtOiBieXRlcyk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1aW50OFtdKQogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMSAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoyOQogICAgLy8gY29uc3QgW3dhbGxldElEXSA9IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NCh0aGlzLmFraXRhREFPLnZhbHVlLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1dhbGxldCkpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjIwCiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjI5CiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBieXRlY18zIC8vICJ3YWxsZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6NDEKICAgIC8vIGFzc2VydChzZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gT25seSB0aGUgQWtpdGEgREFPIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoyNAogICAgLy8gY2xlYXJQcm9ncmFtID0gR2xvYmFsU3RhdGU8Ynl0ZXM+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUNsZWFyUHJvZ3JhbSB9KQogICAgYnl0ZWMgNSAvLyAiY2xlYXJfcHJvZ3JhbSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo0MwogICAgLy8gdGhpcy5jbGVhclByb2dyYW0udmFsdWUgPSBjbGVhclByb2dyYW0KICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6NDUKICAgIC8vIHJla2V5QmFja0lmTmVjZXNzYXJ5KHJla2V5QmFjaywgd2FsbGV0KQogICAgc3dhcAogICAgY2FsbHN1YiByZWtleUJhY2tJZk5lY2Vzc2FyeQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjM5CiAgICAvLyBzZXRDbGVhclByb2dyYW0od2FsbGV0OiBBcHBsaWNhdGlvbiwgcmVrZXlCYWNrOiBib29sZWFuLCBjbGVhclByb2dyYW06IGJ5dGVzKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjpVcGRhdGVBa2l0YURBT1BsdWdpbi5pbml0Qm94ZWRDb250cmFjdFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmluaXRCb3hlZENvbnRyYWN0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjQ4CiAgICAvLyBpbml0Qm94ZWRDb250cmFjdCh3YWxsZXQ6IEFwcGxpY2F0aW9uLCB2ZXJzaW9uOiBzdHJpbmcsIHNpemU6IHVpbnQ2NCk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1dGY4W10pCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjI5CiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjAKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18yIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjkKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ5dGVjXzMgLy8gIndhbGxldCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo1MAogICAgLy8gYXNzZXJ0KHNlbmRlciA9PT0gdGhpcy5nZXRBa2l0YURBT1dhbGxldCgpLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IHRoZSBBa2l0YSBEQU8gY2FuIGNhbGwgdGhpcyBmdW5jdGlvbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjIyCiAgICAvLyBjaGlsZENvbnRyYWN0VmVyc2lvbiA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5Q2hpbGRDb250cmFjdFZlcnNpb24gfSkKICAgIGJ5dGVjIDYgLy8gImNoaWxkX2NvbnRyYWN0X3ZlcnNpb24iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6NTIKICAgIC8vIHRoaXMuY2hpbGRDb250cmFjdFZlcnNpb24udmFsdWUgPSB2ZXJzaW9uCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjI2CiAgICAvLyBib3hlZENvbnRyYWN0ID0gQm94PGJ5dGVzPih7IGtleTogQm94S2V5Qm94ZWRDb250cmFjdCB9KQogICAgYnl0ZWNfMCAvLyAiYmMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6NTQKICAgIC8vIGlmICghdGhpcy5ib3hlZENvbnRyYWN0LmV4aXN0cykgewogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBibnogaW5pdEJveGVkQ29udHJhY3RfZWxzZV9ib2R5QDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoyNgogICAgLy8gYm94ZWRDb250cmFjdCA9IEJveDxieXRlcz4oeyBrZXk6IEJveEtleUJveGVkQ29udHJhY3QgfSkKICAgIGJ5dGVjXzAgLy8gImJjIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjU1CiAgICAvLyB0aGlzLmJveGVkQ29udHJhY3QuY3JlYXRlKHsgc2l6ZSB9KQogICAgc3dhcAogICAgYm94X2NyZWF0ZQogICAgcG9wCgppbml0Qm94ZWRDb250cmFjdF9hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6NDgKICAgIC8vIGluaXRCb3hlZENvbnRyYWN0KHdhbGxldDogQXBwbGljYXRpb24sIHZlcnNpb246IHN0cmluZywgc2l6ZTogdWludDY0KTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgppbml0Qm94ZWRDb250cmFjdF9lbHNlX2JvZHlAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoyNgogICAgLy8gYm94ZWRDb250cmFjdCA9IEJveDxieXRlcz4oeyBrZXk6IEJveEtleUJveGVkQ29udHJhY3QgfSkKICAgIGJ5dGVjXzAgLy8gImJjIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjU3CiAgICAvLyB0aGlzLmJveGVkQ29udHJhY3QucmVzaXplKHNpemUpCiAgICBzd2FwCiAgICBib3hfcmVzaXplCiAgICBiIGluaXRCb3hlZENvbnRyYWN0X2FmdGVyX2lmX2Vsc2VANAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo6VXBkYXRlQWtpdGFEQU9QbHVnaW4ubG9hZEJveGVkQ29udHJhY3Rbcm91dGluZ10oKSAtPiB2b2lkOgpsb2FkQm94ZWRDb250cmFjdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo2MQogICAgLy8gbG9hZEJveGVkQ29udHJhY3Qod2FsbGV0OiBBcHBsaWNhdGlvbiwgb2Zmc2V0OiB1aW50NjQsIGRhdGE6IGJ5dGVzKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdWludDhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICBjb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMSAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoyOQogICAgLy8gY29uc3QgW3dhbGxldElEXSA9IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NCh0aGlzLmFraXRhREFPLnZhbHVlLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1dhbGxldCkpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjIwCiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjI5CiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBieXRlY18zIC8vICJ3YWxsZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6NjMKICAgIC8vIGFzc2VydChzZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gT25seSB0aGUgQWtpdGEgREFPIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo2OAogICAgLy8gY29uc3QgZXhwZWN0ZWRQcmV2aW91c0NhbGxzOiB1aW50NjQgPSBvZmZzZXQgLyAyMDI2CiAgICBwdXNoaW50IDIwMjYgLy8gMjAyNgogICAgLwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjY5CiAgICAvLyBjb25zdCB0eG4gPSBndHhuLlRyYW5zYWN0aW9uKFR4bi5ncm91cEluZGV4IC0gZXhwZWN0ZWRQcmV2aW91c0NhbGxzIC0gMSkKICAgIHR4biBHcm91cEluZGV4CiAgICBzd2FwCiAgICAtCiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6NzEKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18zIC8vIDYKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6NzEtNzIKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgYnogbG9hZEJveGVkQ29udHJhY3RfYm9vbF9mYWxzZUA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6NzIKICAgIC8vICYmIHR4bi5hcHBJZCA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkCiAgICBkdXAKICAgIGd0eG5zIEFwcGxpY2F0aW9uSUQKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo3MS03MgogICAgLy8gdHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vICYmIHR4bi5hcHBJZCA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkCiAgICBieiBsb2FkQm94ZWRDb250cmFjdF9ib29sX2ZhbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo3MwogICAgLy8gJiYgdHhuLm51bUFwcEFyZ3MgPT09IDQKICAgIGR1cAogICAgZ3R4bnMgTnVtQXBwQXJncwogICAgcHVzaGludCA0IC8vIDQKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6NzEtNzMKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgLy8gJiYgdHhuLm51bUFwcEFyZ3MgPT09IDQKICAgIGJ6IGxvYWRCb3hlZENvbnRyYWN0X2Jvb2xfZmFsc2VAOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjc0CiAgICAvLyAmJiB0eG4ub25Db21wbGV0aW9uID09PSBPbkNvbXBsZXRlQWN0aW9uLk5vT3AKICAgIGR1cAogICAgZ3R4bnMgT25Db21wbGV0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6NzEtNzQKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgLy8gJiYgdHhuLm51bUFwcEFyZ3MgPT09IDQKICAgIC8vICYmIHR4bi5vbkNvbXBsZXRpb24gPT09IE9uQ29tcGxldGVBY3Rpb24uTm9PcAogICAgYm56IGxvYWRCb3hlZENvbnRyYWN0X2Jvb2xfZmFsc2VAOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjc1CiAgICAvLyAmJiB0eG4uYXBwQXJncygwKSA9PT0gbWV0aG9kU2VsZWN0b3IodGhpcy5pbml0Qm94ZWRDb250cmFjdCkKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGd0eG5zYXMgQXBwbGljYXRpb25BcmdzCiAgICBieXRlYyA3IC8vIG1ldGhvZCAiaW5pdEJveGVkQ29udHJhY3QodWludDY0LHN0cmluZyx1aW50NjQpdm9pZCIKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6NzEtNzUKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgLy8gJiYgdHhuLm51bUFwcEFyZ3MgPT09IDQKICAgIC8vICYmIHR4bi5vbkNvbXBsZXRpb24gPT09IE9uQ29tcGxldGVBY3Rpb24uTm9PcAogICAgLy8gJiYgdHhuLmFwcEFyZ3MoMCkgPT09IG1ldGhvZFNlbGVjdG9yKHRoaXMuaW5pdEJveGVkQ29udHJhY3QpCiAgICBieiBsb2FkQm94ZWRDb250cmFjdF9ib29sX2ZhbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo3NgogICAgLy8gJiYgdHhuLnNlbmRlciA9PT0gVHhuLnNlbmRlcgogICAgZHVwCiAgICBndHhucyBTZW5kZXIKICAgIHR4biBTZW5kZXIKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6NzEtNzYKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgLy8gJiYgdHhuLm51bUFwcEFyZ3MgPT09IDQKICAgIC8vICYmIHR4bi5vbkNvbXBsZXRpb24gPT09IE9uQ29tcGxldGVBY3Rpb24uTm9PcAogICAgLy8gJiYgdHhuLmFwcEFyZ3MoMCkgPT09IG1ldGhvZFNlbGVjdG9yKHRoaXMuaW5pdEJveGVkQ29udHJhY3QpCiAgICAvLyAmJiB0eG4uc2VuZGVyID09PSBUeG4uc2VuZGVyCiAgICBieiBsb2FkQm94ZWRDb250cmFjdF9ib29sX2ZhbHNlQDgKICAgIGludGNfMSAvLyAxCgpsb2FkQm94ZWRDb250cmFjdF9ib29sX21lcmdlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6NzAtNzcKICAgIC8vIGFzc2VydCgoCiAgICAvLyAgIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAgICYmIHR4bi5hcHBJZCA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkCiAgICAvLyAgICYmIHR4bi5udW1BcHBBcmdzID09PSA0CiAgICAvLyAgICYmIHR4bi5vbkNvbXBsZXRpb24gPT09IE9uQ29tcGxldGVBY3Rpb24uTm9PcAogICAgLy8gICAmJiB0eG4uYXBwQXJncygwKSA9PT0gbWV0aG9kU2VsZWN0b3IodGhpcy5pbml0Qm94ZWRDb250cmFjdCkKICAgIC8vICAgJiYgdHhuLnNlbmRlciA9PT0gVHhuLnNlbmRlcgogICAgLy8gKSwgRVJSX0lOVkFMSURfQ0FMTF9PUkRFUikKICAgIGFzc2VydCAvLyBJbnZhbGlkIGNhbGwgb3JkZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoyNgogICAgLy8gYm94ZWRDb250cmFjdCA9IEJveDxieXRlcz4oeyBrZXk6IEJveEtleUJveGVkQ29udHJhY3QgfSkKICAgIGJ5dGVjXzAgLy8gImJjIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjc4CiAgICAvLyBhc3NlcnQodGhpcy5ib3hlZENvbnRyYWN0LmV4aXN0cywgRVJSX0NPTlRSQUNUX05PVF9TRVQpCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBDb250cmFjdCBub3Qgc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjYKICAgIC8vIGJveGVkQ29udHJhY3QgPSBCb3g8Ynl0ZXM+KHsga2V5OiBCb3hLZXlCb3hlZENvbnRyYWN0IH0pCiAgICBieXRlY18wIC8vICJiYyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo3OQogICAgLy8gdGhpcy5ib3hlZENvbnRyYWN0LnJlcGxhY2Uob2Zmc2V0LCBkYXRhKQogICAgZGlnIDMKICAgIGRpZyAzCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjYxCiAgICAvLyBsb2FkQm94ZWRDb250cmFjdCh3YWxsZXQ6IEFwcGxpY2F0aW9uLCBvZmZzZXQ6IHVpbnQ2NCwgZGF0YTogYnl0ZXMpOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCmxvYWRCb3hlZENvbnRyYWN0X2Jvb2xfZmFsc2VAODoKICAgIGludGNfMCAvLyAwCiAgICBiIGxvYWRCb3hlZENvbnRyYWN0X2Jvb2xfbWVyZ2VAOQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo6VXBkYXRlQWtpdGFEQU9QbHVnaW4uZGVsZXRlQm94ZWRDb250cmFjdFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmRlbGV0ZUJveGVkQ29udHJhY3Q6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6ODIKICAgIC8vIGRlbGV0ZUJveGVkQ29udHJhY3Qod2FsbGV0OiBBcHBsaWNhdGlvbiwgcmVrZXlCYWNrOiBib29sZWFuKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjI5CiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjAKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18yIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjkKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGJ5dGVjXzMgLy8gIndhbGxldCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo4NAogICAgLy8gYXNzZXJ0KHNlbmRlciA9PT0gdGhpcy5nZXRBa2l0YURBT1dhbGxldCgpLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IHRoZSBBa2l0YSBEQU8gY2FuIGNhbGwgdGhpcyBmdW5jdGlvbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjI2CiAgICAvLyBib3hlZENvbnRyYWN0ID0gQm94PGJ5dGVzPih7IGtleTogQm94S2V5Qm94ZWRDb250cmFjdCB9KQogICAgYnl0ZWNfMCAvLyAiYmMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6ODYKICAgIC8vIHRoaXMuYm94ZWRDb250cmFjdC5kZWxldGUoKQogICAgYm94X2RlbAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6ODgKICAgIC8vIHJla2V5QmFja0lmTmVjZXNzYXJ5KHJla2V5QmFjaywgd2FsbGV0KQogICAgc3dhcAogICAgY2FsbHN1YiByZWtleUJhY2tJZk5lY2Vzc2FyeQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjgyCiAgICAvLyBkZWxldGVCb3hlZENvbnRyYWN0KHdhbGxldDogQXBwbGljYXRpb24sIHJla2V5QmFjazogYm9vbGVhbik6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo6VXBkYXRlQWtpdGFEQU9QbHVnaW4udXBkYXRlQXBwW3JvdXRpbmddKCkgLT4gdm9pZDoKdXBkYXRlQXBwOgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo5MQogICAgLy8gdXBkYXRlQXBwKHdhbGxldDogQXBwbGljYXRpb24sIHJla2V5QmFjazogYm9vbGVhbiwgYXBwSWQ6IEFwcGxpY2F0aW9uKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6OTYKICAgIC8vIGNvbnN0IHR4biA9IGd0eG4uVHJhbnNhY3Rpb24oVHhuLmdyb3VwSW5kZXggLSAxKQogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo5OAogICAgLy8gdHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzMgLy8gNgogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo5OC05OQogICAgLy8gdHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vICYmIHR4bi5hcHBJZCA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkCiAgICBieiB1cGRhdGVBcHBfYm9vbF9mYWxzZUA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6OTkKICAgIC8vICYmIHR4bi5hcHBJZCA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkCiAgICBkdXAKICAgIGd0eG5zIEFwcGxpY2F0aW9uSUQKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo5OC05OQogICAgLy8gdHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vICYmIHR4bi5hcHBJZCA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkCiAgICBieiB1cGRhdGVBcHBfYm9vbF9mYWxzZUA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MTAwCiAgICAvLyAmJiB0eG4ubnVtQXBwQXJncyA9PT0gNAogICAgZHVwCiAgICBndHhucyBOdW1BcHBBcmdzCiAgICBwdXNoaW50IDQgLy8gNAogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo5OC0xMDAKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgLy8gJiYgdHhuLm51bUFwcEFyZ3MgPT09IDQKICAgIGJ6IHVwZGF0ZUFwcF9ib29sX2ZhbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoxMDEKICAgIC8vICYmIHR4bi5vbkNvbXBsZXRpb24gPT09IE9uQ29tcGxldGVBY3Rpb24uTm9PcAogICAgZHVwCiAgICBndHhucyBPbkNvbXBsZXRpb24KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo5OC0xMDEKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgLy8gJiYgdHhuLm51bUFwcEFyZ3MgPT09IDQKICAgIC8vICYmIHR4bi5vbkNvbXBsZXRpb24gPT09IE9uQ29tcGxldGVBY3Rpb24uTm9PcAogICAgYm56IHVwZGF0ZUFwcF9ib29sX2ZhbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoxMDIKICAgIC8vICYmIHR4bi5hcHBBcmdzKDApID09PSBtZXRob2RTZWxlY3Rvcih0aGlzLmxvYWRCb3hlZENvbnRyYWN0KQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZ3R4bnNhcyBBcHBsaWNhdGlvbkFyZ3MKICAgIGJ5dGVjIDQgLy8gbWV0aG9kICJsb2FkQm94ZWRDb250cmFjdCh1aW50NjQsdWludDY0LGJ5dGVbXSl2b2lkIgogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo5OC0xMDIKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgLy8gJiYgdHhuLm51bUFwcEFyZ3MgPT09IDQKICAgIC8vICYmIHR4bi5vbkNvbXBsZXRpb24gPT09IE9uQ29tcGxldGVBY3Rpb24uTm9PcAogICAgLy8gJiYgdHhuLmFwcEFyZ3MoMCkgPT09IG1ldGhvZFNlbGVjdG9yKHRoaXMubG9hZEJveGVkQ29udHJhY3QpCiAgICBieiB1cGRhdGVBcHBfYm9vbF9mYWxzZUA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MTAzCiAgICAvLyAmJiB0eG4uc2VuZGVyID09PSBUeG4uc2VuZGVyCiAgICBkdXAKICAgIGd0eG5zIFNlbmRlcgogICAgdHhuIFNlbmRlcgogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo5OC0xMDMKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgLy8gJiYgdHhuLm51bUFwcEFyZ3MgPT09IDQKICAgIC8vICYmIHR4bi5vbkNvbXBsZXRpb24gPT09IE9uQ29tcGxldGVBY3Rpb24uTm9PcAogICAgLy8gJiYgdHhuLmFwcEFyZ3MoMCkgPT09IG1ldGhvZFNlbGVjdG9yKHRoaXMubG9hZEJveGVkQ29udHJhY3QpCiAgICAvLyAmJiB0eG4uc2VuZGVyID09PSBUeG4uc2VuZGVyCiAgICBieiB1cGRhdGVBcHBfYm9vbF9mYWxzZUA4CiAgICBpbnRjXzEgLy8gMQoKdXBkYXRlQXBwX2Jvb2xfbWVyZ2VAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo5Ny0xMDQKICAgIC8vIGFzc2VydCgoCiAgICAvLyAgIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAgICYmIHR4bi5hcHBJZCA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkCiAgICAvLyAgICYmIHR4bi5udW1BcHBBcmdzID09PSA0CiAgICAvLyAgICYmIHR4bi5vbkNvbXBsZXRpb24gPT09IE9uQ29tcGxldGVBY3Rpb24uTm9PcAogICAgLy8gICAmJiB0eG4uYXBwQXJncygwKSA9PT0gbWV0aG9kU2VsZWN0b3IodGhpcy5sb2FkQm94ZWRDb250cmFjdCkKICAgIC8vICAgJiYgdHhuLnNlbmRlciA9PT0gVHhuLnNlbmRlcgogICAgLy8gKSwgRVJSX0lOVkFMSURfQ0FMTF9PUkRFUikKICAgIGFzc2VydCAvLyBJbnZhbGlkIGNhbGwgb3JkZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoyNgogICAgLy8gYm94ZWRDb250cmFjdCA9IEJveDxieXRlcz4oeyBrZXk6IEJveEtleUJveGVkQ29udHJhY3QgfSkKICAgIGJ5dGVjXzAgLy8gImJjIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjEwNgogICAgLy8gY29uc3QgYXBwcm92YWxTaXplOiB1aW50NjQgPSB0aGlzLmJveGVkQ29udHJhY3QubGVuZ3RoCiAgICBib3hfbGVuCiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoxMTAKICAgIC8vIGlmIChhcHByb3ZhbFNpemUgPiBNQVhfQVZNX0JZVEVfQVJSQVlfTEVOR1RIKSB7CiAgICBpbnRjIDQgLy8gNDA5NgogICAgPgogICAgYnogdXBkYXRlQXBwX2Vsc2VfYm9keUAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjI2CiAgICAvLyBib3hlZENvbnRyYWN0ID0gQm94PGJ5dGVzPih7IGtleTogQm94S2V5Qm94ZWRDb250cmFjdCB9KQogICAgYnl0ZWNfMCAvLyAiYmMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MTExCiAgICAvLyBjaHVuazEgPSB0aGlzLmJveGVkQ29udHJhY3QuZXh0cmFjdCgwLCBNQVhfQVZNX0JZVEVfQVJSQVlfTEVOR1RIKQogICAgaW50Y18wIC8vIDAKICAgIGludGMgNCAvLyA0MDk2CiAgICBib3hfZXh0cmFjdAogICAgYnVyeSA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MTEyCiAgICAvLyBjaHVuazIgPSB0aGlzLmJveGVkQ29udHJhY3QuZXh0cmFjdChNQVhfQVZNX0JZVEVfQVJSQVlfTEVOR1RILCBhcHByb3ZhbFNpemUgLSBNQVhfQVZNX0JZVEVfQVJSQVlfTEVOR1RIKQogICAgaW50YyA0IC8vIDQwOTYKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoyNgogICAgLy8gYm94ZWRDb250cmFjdCA9IEJveDxieXRlcz4oeyBrZXk6IEJveEtleUJveGVkQ29udHJhY3QgfSkKICAgIGJ5dGVjXzAgLy8gImJjIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjExMgogICAgLy8gY2h1bmsyID0gdGhpcy5ib3hlZENvbnRyYWN0LmV4dHJhY3QoTUFYX0FWTV9CWVRFX0FSUkFZX0xFTkdUSCwgYXBwcm92YWxTaXplIC0gTUFYX0FWTV9CWVRFX0FSUkFZX0xFTkdUSCkKICAgIGludGMgNCAvLyA0MDk2CiAgICB1bmNvdmVyIDIKICAgIGJveF9leHRyYWN0Cgp1cGRhdGVBcHBfYWZ0ZXJfaWZfZWxzZUAxMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoxMTgtMTI2CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YUJhc2VGZWVHZW5lcmF0b3JDb250cmFjdC5wcm90b3R5cGUudXBkYXRlPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFt0aGlzLmNoaWxkQ29udHJhY3RWZXJzaW9uLnZhbHVlXSwKICAgIC8vICAgb25Db21wbGV0aW9uOiBPbkNvbXBsZXRlQWN0aW9uLlVwZGF0ZUFwcGxpY2F0aW9uLAogICAgLy8gICBhcHByb3ZhbFByb2dyYW06IFtjaHVuazEsIGNodW5rMl0sCiAgICAvLyAgIGNsZWFyU3RhdGVQcm9ncmFtOiB0aGlzLmNsZWFyUHJvZ3JhbS52YWx1ZSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoxMjQKICAgIC8vIGNsZWFyU3RhdGVQcm9ncmFtOiB0aGlzLmNsZWFyUHJvZ3JhbS52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjQKICAgIC8vIGNsZWFyUHJvZ3JhbSA9IEdsb2JhbFN0YXRlPGJ5dGVzPih7IGtleTogR2xvYmFsU3RhdGVLZXlDbGVhclByb2dyYW0gfSkKICAgIGJ5dGVjIDUgLy8gImNsZWFyX3Byb2dyYW0iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MTI0CiAgICAvLyBjbGVhclN0YXRlUHJvZ3JhbTogdGhpcy5jbGVhclByb2dyYW0udmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjEyNQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgZGlnIDUKICAgIGRpZyA3CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjEyMQogICAgLy8gYXJnczogW3RoaXMuY2hpbGRDb250cmFjdFZlcnNpb24udmFsdWVdLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoyMgogICAgLy8gY2hpbGRDb250cmFjdFZlcnNpb24gPSBHbG9iYWxTdGF0ZTxzdHJpbmc+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUNoaWxkQ29udHJhY3RWZXJzaW9uIH0pCiAgICBieXRlYyA2IC8vICJjaGlsZF9jb250cmFjdF92ZXJzaW9uIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjEyMQogICAgLy8gYXJnczogW3RoaXMuY2hpbGRDb250cmFjdFZlcnNpb24udmFsdWVdLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MTE4LTEyNgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFCYXNlRmVlR2VuZXJhdG9yQ29udHJhY3QucHJvdG90eXBlLnVwZGF0ZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbdGhpcy5jaGlsZENvbnRyYWN0VmVyc2lvbi52YWx1ZV0sCiAgICAvLyAgIG9uQ29tcGxldGlvbjogT25Db21wbGV0ZUFjdGlvbi5VcGRhdGVBcHBsaWNhdGlvbiwKICAgIC8vICAgYXBwcm92YWxQcm9ncmFtOiBbY2h1bmsxLCBjaHVuazJdLAogICAgLy8gICBjbGVhclN0YXRlUHJvZ3JhbTogdGhpcy5jbGVhclByb2dyYW0udmFsdWUsCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHhlYTkxODBkZCAvLyBtZXRob2QgInVwZGF0ZShzdHJpbmcpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtUGFnZXMKICAgIGRpZyA2CiAgICBpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbVBhZ2VzCiAgICBpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbVBhZ2VzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MTIyCiAgICAvLyBvbkNvbXBsZXRpb246IE9uQ29tcGxldGVBY3Rpb24uVXBkYXRlQXBwbGljYXRpb24sCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KICAgIGRpZyAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGRpZyAxCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjExOC0xMjYKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhQmFzZUZlZUdlbmVyYXRvckNvbnRyYWN0LnByb3RvdHlwZS51cGRhdGU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW3RoaXMuY2hpbGRDb250cmFjdFZlcnNpb24udmFsdWVdLAogICAgLy8gICBvbkNvbXBsZXRpb246IE9uQ29tcGxldGVBY3Rpb24uVXBkYXRlQXBwbGljYXRpb24sCiAgICAvLyAgIGFwcHJvdmFsUHJvZ3JhbTogW2NodW5rMSwgY2h1bmsyXSwKICAgIC8vICAgY2xlYXJTdGF0ZVByb2dyYW06IHRoaXMuY2xlYXJQcm9ncmFtLnZhbHVlLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czo5MQogICAgLy8gdXBkYXRlQXBwKHdhbGxldDogQXBwbGljYXRpb24sIHJla2V5QmFjazogYm9vbGVhbiwgYXBwSWQ6IEFwcGxpY2F0aW9uKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgp1cGRhdGVBcHBfZWxzZV9ib2R5QDExOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjI2CiAgICAvLyBib3hlZENvbnRyYWN0ID0gQm94PGJ5dGVzPih7IGtleTogQm94S2V5Qm94ZWRDb250cmFjdCB9KQogICAgYnl0ZWNfMCAvLyAiYmMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MTE0CiAgICAvLyBjaHVuazEgPSB0aGlzLmJveGVkQ29udHJhY3QuZXh0cmFjdCgwLCBhcHByb3ZhbFNpemUpCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAyCiAgICBib3hfZXh0cmFjdAogICAgYnVyeSA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MTE1CiAgICAvLyBjaHVuazIgPSBCeXRlcygnJykKICAgIHB1c2hieXRlcyAiIgogICAgYiB1cGRhdGVBcHBfYWZ0ZXJfaWZfZWxzZUAxMgoKdXBkYXRlQXBwX2Jvb2xfZmFsc2VAODoKICAgIGludGNfMCAvLyAwCiAgICBiIHVwZGF0ZUFwcF9ib29sX21lcmdlQDkKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6OlVwZGF0ZUFraXRhREFPUGx1Z2luLnVwZGF0ZUFraXRhRGFvQXBwSURGb3JBcHBbcm91dGluZ10oKSAtPiB2b2lkOgp1cGRhdGVBa2l0YURhb0FwcElERm9yQXBwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjEyOS0xMzQKICAgIC8vIHVwZGF0ZUFraXRhRGFvQXBwSURGb3JBcHAoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICBuZXdBa2l0YURBT0FwcElEOiBBcHBsaWNhdGlvbgogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MTM3LTE0MgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFCYXNlRmVlR2VuZXJhdG9yQ29udHJhY3QucHJvdG90eXBlLnVwZGF0ZUFraXRhREFPPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtuZXdBa2l0YURBT0FwcElEXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MTQxCiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDQKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MTM3LTE0MgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFCYXNlRmVlR2VuZXJhdG9yQ29udHJhY3QucHJvdG90eXBlLnVwZGF0ZUFraXRhREFPPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtuZXdBa2l0YURBT0FwcElEXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHgzM2U5MmM5NCAvLyBtZXRob2QgInVwZGF0ZUFraXRhREFPKHVpbnQ2NCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MTI5LTEzNAogICAgLy8gdXBkYXRlQWtpdGFEYW9BcHBJREZvckFwcCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24sCiAgICAvLyAgIG5ld0FraXRhREFPQXBwSUQ6IEFwcGxpY2F0aW9uCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6OlVwZGF0ZUFraXRhREFPUGx1Z2luLnVwZGF0ZUFraXRhRGFvRXNjcm93Rm9yQXBwW3JvdXRpbmddKCkgLT4gdm9pZDoKdXBkYXRlQWtpdGFEYW9Fc2Nyb3dGb3JBcHA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MTQ1LTE1MAogICAgLy8gdXBkYXRlQWtpdGFEYW9Fc2Nyb3dGb3JBcHAoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICBuZXdFc2Nyb3c6IEFwcGxpY2F0aW9uCiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMSAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoxNTMtMTU4CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YUJhc2VGZWVHZW5lcmF0b3JDb250cmFjdC5wcm90b3R5cGUudXBkYXRlQWtpdGFEQU9Fc2Nyb3c+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW25ld0VzY3Jvd10sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjE1NwogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciA0CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjE1My0xNTgKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhQmFzZUZlZUdlbmVyYXRvckNvbnRyYWN0LnByb3RvdHlwZS51cGRhdGVBa2l0YURBT0VzY3Jvdz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbbmV3RXNjcm93XSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHgxZWFkMjBhOSAvLyBtZXRob2QgInVwZGF0ZUFraXRhREFPRXNjcm93KHVpbnQ2NCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MTQ1LTE1MAogICAgLy8gdXBkYXRlQWtpdGFEYW9Fc2Nyb3dGb3JBcHAoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICBuZXdFc2Nyb3c6IEFwcGxpY2F0aW9uCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6OlVwZGF0ZUFraXRhREFPUGx1Z2luLnVwZGF0ZVJldm9jYXRpb25bcm91dGluZ10oKSAtPiB2b2lkOgp1cGRhdGVSZXZvY2F0aW9uOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjE2MS0xNjUKICAgIC8vIHVwZGF0ZVJldm9jYXRpb24oCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwOiBBcHBsaWNhdGlvbgogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMSAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoyOQogICAgLy8gY29uc3QgW3dhbGxldElEXSA9IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NCh0aGlzLmFraXRhREFPLnZhbHVlLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1dhbGxldCkpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjIwCiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjI5CiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBkdXAKICAgIGJ5dGVjXzMgLy8gIndhbGxldCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoxNjcKICAgIC8vIGFzc2VydChzZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGRpZyAyCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgdGhlIEFraXRhIERBTyBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQwCiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBwdXNoYnl0ZXMgImFhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoxNjkKICAgIC8vIGNvbnN0IGFwcElkID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLndhbGxldAogICAgcHVzaGludCA4OCAvLyA4OAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoxNzEtMTc2CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBYnN0cmFjdGVkQWNjb3VudEZhY3RvcnkucHJvdG90eXBlLnVwZGF0ZVJldm9jYXRpb24+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW2FwcF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjE3NQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciA0CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjE3MS0xNzYKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFic3RyYWN0ZWRBY2NvdW50RmFjdG9yeS5wcm90b3R5cGUudXBkYXRlUmV2b2NhdGlvbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbYXBwXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHgwOGQzMWRlNCAvLyBtZXRob2QgInVwZGF0ZVJldm9jYXRpb24odWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjE2MS0xNjUKICAgIC8vIHVwZGF0ZVJldm9jYXRpb24oCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwOiBBcHBsaWNhdGlvbgogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjpVcGRhdGVBa2l0YURBT1BsdWdpbi51cGRhdGVGYWN0b3J5Q2hpbGRDb250cmFjdFtyb3V0aW5nXSgpIC0+IHZvaWQ6CnVwZGF0ZUZhY3RvcnlDaGlsZENvbnRyYWN0OgogICAgaW50Y18wIC8vIDAKICAgIHB1c2hieXRlcyAiIgogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MTkzLTE5NwogICAgLy8gdXBkYXRlRmFjdG9yeUNoaWxkQ29udHJhY3QoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgZmFjdG9yeUFwcElkOiBBcHBsaWNhdGlvbgogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoyOQogICAgLy8gY29uc3QgW3dhbGxldElEXSA9IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NCh0aGlzLmFraXRhREFPLnZhbHVlLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1dhbGxldCkpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjIwCiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjI5CiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBieXRlY18zIC8vICJ3YWxsZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MTk5CiAgICAvLyBhc3NlcnQoc2VuZGVyID09PSB0aGlzLmdldEFraXRhREFPV2FsbGV0KCkuYWRkcmVzcywgRVJSX05PVF9BS0lUQV9EQU8pCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgdGhlIEFraXRhIERBTyBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjAzCiAgICAvLyBjb25zdCB0eG4gPSBndHhuLlRyYW5zYWN0aW9uKFR4bi5ncm91cEluZGV4IC0gMSkKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjA1CiAgICAvLyB0eG4udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFwcGxpY2F0aW9uQ2FsbAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMyAvLyA2CiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjIwNS0yMDYKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgYnogdXBkYXRlRmFjdG9yeUNoaWxkQ29udHJhY3RfYm9vbF9mYWxzZUA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjA2CiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgZHVwCiAgICBndHhucyBBcHBsaWNhdGlvbklECiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uSUQKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjA1LTIwNgogICAgLy8gdHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vICYmIHR4bi5hcHBJZCA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkCiAgICBieiB1cGRhdGVGYWN0b3J5Q2hpbGRDb250cmFjdF9ib29sX2ZhbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoyMDcKICAgIC8vICYmIHR4bi5udW1BcHBBcmdzID09PSA0CiAgICBkdXAKICAgIGd0eG5zIE51bUFwcEFyZ3MKICAgIHB1c2hpbnQgNCAvLyA0CiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjIwNS0yMDcKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgLy8gJiYgdHhuLm51bUFwcEFyZ3MgPT09IDQKICAgIGJ6IHVwZGF0ZUZhY3RvcnlDaGlsZENvbnRyYWN0X2Jvb2xfZmFsc2VAOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjIwOAogICAgLy8gJiYgdHhuLm9uQ29tcGxldGlvbiA9PT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wCiAgICBkdXAKICAgIGd0eG5zIE9uQ29tcGxldGlvbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjIwNS0yMDgKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgLy8gJiYgdHhuLm51bUFwcEFyZ3MgPT09IDQKICAgIC8vICYmIHR4bi5vbkNvbXBsZXRpb24gPT09IE9uQ29tcGxldGVBY3Rpb24uTm9PcAogICAgYm56IHVwZGF0ZUZhY3RvcnlDaGlsZENvbnRyYWN0X2Jvb2xfZmFsc2VAOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjIwOQogICAgLy8gJiYgdHhuLmFwcEFyZ3MoMCkgPT09IG1ldGhvZFNlbGVjdG9yKHRoaXMubG9hZEJveGVkQ29udHJhY3QpCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBndHhuc2FzIEFwcGxpY2F0aW9uQXJncwogICAgYnl0ZWMgNCAvLyBtZXRob2QgImxvYWRCb3hlZENvbnRyYWN0KHVpbnQ2NCx1aW50NjQsYnl0ZVtdKXZvaWQiCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjIwNS0yMDkKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgLy8gJiYgdHhuLm51bUFwcEFyZ3MgPT09IDQKICAgIC8vICYmIHR4bi5vbkNvbXBsZXRpb24gPT09IE9uQ29tcGxldGVBY3Rpb24uTm9PcAogICAgLy8gJiYgdHhuLmFwcEFyZ3MoMCkgPT09IG1ldGhvZFNlbGVjdG9yKHRoaXMubG9hZEJveGVkQ29udHJhY3QpCiAgICBieiB1cGRhdGVGYWN0b3J5Q2hpbGRDb250cmFjdF9ib29sX2ZhbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoyMTAKICAgIC8vICYmIHR4bi5zZW5kZXIgPT09IFR4bi5zZW5kZXIKICAgIGR1cAogICAgZ3R4bnMgU2VuZGVyCiAgICB0eG4gU2VuZGVyCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjIwNS0yMTAKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgLy8gJiYgdHhuLm51bUFwcEFyZ3MgPT09IDQKICAgIC8vICYmIHR4bi5vbkNvbXBsZXRpb24gPT09IE9uQ29tcGxldGVBY3Rpb24uTm9PcAogICAgLy8gJiYgdHhuLmFwcEFyZ3MoMCkgPT09IG1ldGhvZFNlbGVjdG9yKHRoaXMubG9hZEJveGVkQ29udHJhY3QpCiAgICAvLyAmJiB0eG4uc2VuZGVyID09PSBUeG4uc2VuZGVyCiAgICBieiB1cGRhdGVGYWN0b3J5Q2hpbGRDb250cmFjdF9ib29sX2ZhbHNlQDgKICAgIGludGNfMSAvLyAxCgp1cGRhdGVGYWN0b3J5Q2hpbGRDb250cmFjdF9ib29sX21lcmdlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjA0LTIxMQogICAgLy8gYXNzZXJ0KCgKICAgIC8vICAgdHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vICAgJiYgdHhuLmFwcElkID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQKICAgIC8vICAgJiYgdHhuLm51bUFwcEFyZ3MgPT09IDQKICAgIC8vICAgJiYgdHhuLm9uQ29tcGxldGlvbiA9PT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wCiAgICAvLyAgICYmIHR4bi5hcHBBcmdzKDApID09PSBtZXRob2RTZWxlY3Rvcih0aGlzLmxvYWRCb3hlZENvbnRyYWN0KQogICAgLy8gICAmJiB0eG4uc2VuZGVyID09PSBUeG4uc2VuZGVyCiAgICAvLyApLCBFUlJfSU5WQUxJRF9DQUxMX09SREVSKQogICAgYXNzZXJ0IC8vIEludmFsaWQgY2FsbCBvcmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjI2CiAgICAvLyBib3hlZENvbnRyYWN0ID0gQm94PGJ5dGVzPih7IGtleTogQm94S2V5Qm94ZWRDb250cmFjdCB9KQogICAgYnl0ZWNfMCAvLyAiYmMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjEzCiAgICAvLyBhc3NlcnQodGhpcy5ib3hlZENvbnRyYWN0LmV4aXN0cywgRVJSX0NPTlRSQUNUX05PVF9TRVQpCiAgICBib3hfbGVuCiAgICBzd2FwCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGJ1cnkgOQogICAgYXNzZXJ0IC8vIENvbnRyYWN0IG5vdCBzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoyMTYKICAgIC8vIGNvbnN0IHZlcnNpb24gPSB0aGlzLmNoaWxkQ29udHJhY3RWZXJzaW9uLnZhbHVlCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjIyCiAgICAvLyBjaGlsZENvbnRyYWN0VmVyc2lvbiA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5Q2hpbGRDb250cmFjdFZlcnNpb24gfSkKICAgIGJ5dGVjIDYgLy8gImNoaWxkX2NvbnRyYWN0X3ZlcnNpb24iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjE2CiAgICAvLyBjb25zdCB2ZXJzaW9uID0gdGhpcy5jaGlsZENvbnRyYWN0VmVyc2lvbi52YWx1ZQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoyMTktMjIzCiAgICAvLyBpdHhuQ29tcG9zZS5iZWdpbjx0eXBlb2YgRmFjdG9yeUNvbnRyYWN0LnByb3RvdHlwZS5pbml0Qm94ZWRDb250cmFjdD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBmYWN0b3J5QXBwSWQsCiAgICAvLyAgIGFyZ3M6IFt2ZXJzaW9uLCBjb250cmFjdFNpemVdLAogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoyMjIKICAgIC8vIGFyZ3M6IFt2ZXJzaW9uLCBjb250cmFjdFNpemVdLAogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoyMTktMjIzCiAgICAvLyBpdHhuQ29tcG9zZS5iZWdpbjx0eXBlb2YgRmFjdG9yeUNvbnRyYWN0LnByb3RvdHlwZS5pbml0Qm94ZWRDb250cmFjdD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBmYWN0b3J5QXBwSWQsCiAgICAvLyAgIGFyZ3M6IFt2ZXJzaW9uLCBjb250cmFjdFNpemVdLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweGM1M2IzMmNjIC8vIG1ldGhvZCAiaW5pdEJveGVkQ29udHJhY3Qoc3RyaW5nLHVpbnQ2NCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjI4CiAgICAvLyBmb3IgKGxldCBvZmZzZXQ6IHVpbnQ2NCA9IDA7IG9mZnNldCA8IGNvbnRyYWN0U2l6ZTsgb2Zmc2V0ICs9IEZBQ1RPUllfTE9BRF9DSFVOS19TSVpFKSB7CiAgICBpbnRjXzAgLy8gMAogICAgYnVyeSA2Cgp1cGRhdGVGYWN0b3J5Q2hpbGRDb250cmFjdF93aGlsZV90b3BAMTA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjI4CiAgICAvLyBmb3IgKGxldCBvZmZzZXQ6IHVpbnQ2NCA9IDA7IG9mZnNldCA8IGNvbnRyYWN0U2l6ZTsgb2Zmc2V0ICs9IEZBQ1RPUllfTE9BRF9DSFVOS19TSVpFKSB7CiAgICBkaWcgNQogICAgZGlnIDcKICAgIDwKICAgIGJ6IHVwZGF0ZUZhY3RvcnlDaGlsZENvbnRyYWN0X2FmdGVyX3doaWxlQDE1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjI5CiAgICAvLyBjb25zdCByZW1haW5pbmc6IHVpbnQ2NCA9IGNvbnRyYWN0U2l6ZSAtIG9mZnNldAogICAgZGlnIDYKICAgIGR1cAogICAgZGlnIDcKICAgIGR1cAogICAgY292ZXIgMgogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjIzMAogICAgLy8gY29uc3QgY2h1bmtTaXplID0gcmVtYWluaW5nIDwgRkFDVE9SWV9MT0FEX0NIVU5LX1NJWkUgPyByZW1haW5pbmcgOiBGQUNUT1JZX0xPQURfQ0hVTktfU0laRQogICAgZHVwCiAgICBpbnRjIDUgLy8gMjAzMgogICAgPAogICAgaW50YyA1IC8vIDIwMzIKICAgIGNvdmVyIDIKICAgIHNlbGVjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjI2CiAgICAvLyBib3hlZENvbnRyYWN0ID0gQm94PGJ5dGVzPih7IGtleTogQm94S2V5Qm94ZWRDb250cmFjdCB9KQogICAgYnl0ZWNfMCAvLyAiYmMiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjMxCiAgICAvLyBjb25zdCBjaHVuayA9IHRoaXMuYm94ZWRDb250cmFjdC5leHRyYWN0KG9mZnNldCwgY2h1bmtTaXplKQogICAgZGlnIDIKICAgIGRpZyAyCiAgICBib3hfZXh0cmFjdAogICAgYnVyeSAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjIzMwogICAgLy8gY29uc3QgaXNMYXN0Q2h1bmsgPSBvZmZzZXQgKyBjaHVua1NpemUgPj0gY29udHJhY3RTaXplCiAgICArCiAgICA8PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjIzNS0yNDAKICAgIC8vIGl0eG5Db21wb3NlLm5leHQ8dHlwZW9mIEZhY3RvcnlDb250cmFjdC5wcm90b3R5cGUubG9hZEJveGVkQ29udHJhY3Q+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogZmFjdG9yeUFwcElkLAogICAgLy8gICBhcmdzOiBbb2Zmc2V0LCBjaHVua10sCiAgICAvLyAgIHJla2V5VG86IGlzTGFzdENodW5rID8gcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSA6IEdsb2JhbC56ZXJvQWRkcmVzcywKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoyMzkKICAgIC8vIHJla2V5VG86IGlzTGFzdENodW5rID8gcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSA6IEdsb2JhbC56ZXJvQWRkcmVzcywKICAgIGJ6IHVwZGF0ZUZhY3RvcnlDaGlsZENvbnRyYWN0X3Rlcm5hcnlfZmFsc2VAMTMKICAgIGRpZyAzCiAgICBkaWcgNQogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKCnVwZGF0ZUZhY3RvcnlDaGlsZENvbnRyYWN0X3Rlcm5hcnlfbWVyZ2VAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjM4CiAgICAvLyBhcmdzOiBbb2Zmc2V0LCBjaHVua10sCiAgICBkaWcgNgogICAgZHVwCiAgICBpdG9iCiAgICBkaWcgMTAKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MjM1LTI0MAogICAgLy8gaXR4bkNvbXBvc2UubmV4dDx0eXBlb2YgRmFjdG9yeUNvbnRyYWN0LnByb3RvdHlwZS5sb2FkQm94ZWRDb250cmFjdD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBmYWN0b3J5QXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtvZmZzZXQsIGNodW5rXSwKICAgIC8vICAgcmVrZXlUbzogaXNMYXN0Q2h1bmsgPyByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpIDogR2xvYmFsLnplcm9BZGRyZXNzLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweGRjYTJkODYyIC8vIG1ldGhvZCAibG9hZEJveGVkQ29udHJhY3QodWludDY0LGJ5dGVbXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgc3dhcAogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBkaWcgMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBkaWcgMgogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3VwZGF0ZS1ha2l0YS1kYW8vY29udHJhY3QuYWxnby50czoyMjgKICAgIC8vIGZvciAobGV0IG9mZnNldDogdWludDY0ID0gMDsgb2Zmc2V0IDwgY29udHJhY3RTaXplOyBvZmZzZXQgKz0gRkFDVE9SWV9MT0FEX0NIVU5LX1NJWkUpIHsKICAgIGludGMgNSAvLyAyMDMyCiAgICArCiAgICBidXJ5IDYKICAgIGIgdXBkYXRlRmFjdG9yeUNoaWxkQ29udHJhY3Rfd2hpbGVfdG9wQDEwCgp1cGRhdGVGYWN0b3J5Q2hpbGRDb250cmFjdF90ZXJuYXJ5X2ZhbHNlQDEzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjIzOQogICAgLy8gcmVrZXlUbzogaXNMYXN0Q2h1bmsgPyByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpIDogR2xvYmFsLnplcm9BZGRyZXNzLAogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICBiIHVwZGF0ZUZhY3RvcnlDaGlsZENvbnRyYWN0X3Rlcm5hcnlfbWVyZ2VAMTQKCnVwZGF0ZUZhY3RvcnlDaGlsZENvbnRyYWN0X2FmdGVyX3doaWxlQDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvdXBkYXRlLWFraXRhLWRhby9jb250cmFjdC5hbGdvLnRzOjI0NAogICAgLy8gaXR4bkNvbXBvc2Uuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy91cGRhdGUtYWtpdGEtZGFvL2NvbnRyYWN0LmFsZ28udHM6MTkzLTE5NwogICAgLy8gdXBkYXRlRmFjdG9yeUNoaWxkQ29udHJhY3QoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgZmFjdG9yeUFwcElkOiBBcHBsaWNhdGlvbgogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgp1cGRhdGVGYWN0b3J5Q2hpbGRDb250cmFjdF9ib29sX2ZhbHNlQDg6CiAgICBpbnRjXzAgLy8gMAogICAgYiB1cGRhdGVGYWN0b3J5Q2hpbGRDb250cmFjdF9ib29sX21lcmdlQDkK", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyAGAAEIBoAg8A8mCAJiYxBzcGVuZGluZ19hZGRyZXNzCWFraXRhX2RhbwZ3YWxsZXQELh0iKQ1jbGVhcl9wcm9ncmFtFmNoaWxkX2NvbnRyYWN0X3ZlcnNpb24EFwveZDEZFEQxGEEAQoAE0Vw9cCcHJwSCBgTLmN7pBGrXjBQEieJaJAQ/PiW4BJI3FhcEaLdOXDYaAI4JAGsAqgD2AX0BqgJ2AsEDDANoAIAEU9/ZGzYaAI4BADkAigIAi/5BAB6L/yllSLGL/ov/iAASsiAisghJsgeyACOyECKyAbOJigIBi/5AAAMyA4mL/3IIRIk2GgFJFSQSRBc2GgJJIlmBAghLARUSRFcCACpPAmcnBUxnI0M2GgFJFSQSRBc2GgJJFSMSRCJTNhoDSSJZgQIISwEVEkRXAgBLAillSCIqZUQrZUhyCEQSRCcFTGdMiP9nI0M2GgFJFSQSRBc2GgJJIlmBAghLARUSRFcCADYaA0kVJBJEF04CTCllSCIqZUQrZUhyCEQSRCcGTGcovUUBQAAGKEy5SCNDKEzTQv/4NhoBSRUkEkQXNhoCSRUkEkQXSU8CNhoDSSJZgQIISwEVEkRXAgBOAillSCIqZUQrZUhyCEQSRIHqDwoxFkwJIwlJOBAlEkEAOkk4GDIIEkEAMUk4G4EEEkEAKEk4GUAAIkkiwhonBxJBABhJOAAxABJBAA8jRCi9RQFEKEsDSwO7I0MiQv/uNhoBSRUkEkQXNhoCSRUjEkQiU0sBKWVIIiplRCtlSHIIRBJEKLxITIj+ZyNDIjYaAUkVJBJEF0k2GgJJFSMSRCJTTDYaA0kVJBJEF0wpZUgxFiMJSTgQJRJBAJlJOBgyCBJBAJBJOBuBBBJBAIdJOBlAAIFJIsIaJwQSQQB3STgAMQASQQBuI0QovUxJTwJEIQQNQQBTKCIhBLpFByEECSghBE8CurEiJwVlREsFSweI/gYiJwZlREkVFlcGAkxQgATqkYDdshqyGrIgskJLBrJAskCBBLIZSwKyGEsBsgAlshAisgGzI0MoIk8CukUGgABC/7EiQv+PNhoBSRUkEkQXNhoCSRUjEkQiUzYaA0kVJBJEFzYaBEkVJBJESwMpZUhMsU8DTwSI/Y6ABDPpLJSyGrIgshqyALIYJbIQIrIBsyNDNhoBSRUkEkQXNhoCSRUjEkQiUzYaA0kVJBJEFzYaBEkVJBJESwMpZUhMsU8DTwSI/UOABB6tIKmyGrIgshqyALIYJbIQIrIBsyNDNhoBSRUkEkQXNhoCSRUjEkQiUzYaA0kVJBJESwIpZUgiKmVESStlSHIIREsCEkSAA2FhbGVIgVhbsU8DTwSI/OmABAjTHeSyGk8DshqyILIYsgAlshAisgGzI0MigABJNhoBSRUkEkQXSTYaAkkVIxJEIlNMNhoDSRUkEkQXTCllSEkiKmVEK2VIcghEEkQxFiMJSTgQJRJBAM9JOBgyCBJBAMZJOBuBBBJBAL1JOBlAALdJIsIaJwQSQQCtSTgAMQASQQCkI0QovUxJTgJFCUQiJwZlRLFJFRZXBgJMUEwWgATFOzLMshpMshqyGksCshhLAbIAJbIQIrIBIkUGSwVLBwxBAGBLBklLB0lOAglJIQUMIQVOAk0oSwJLArpFCwgOtkEAO0sDSwWI+/xLBkkWSwpJFRZXBgJMUIAE3KLYYrIaTLIashpMsiBLA7IYSwKyACWyECKyASEFCEUGQv+dMgNC/8ezI0MiQv9Z", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var BinaryStateValue2 = class {
  constructor(value) {
    this.value = value;
  }
  asByteArray() {
    return this.value;
  }
  asString() {
    return this.value !== void 0 ? Buffer.from(this.value).toString("utf-8") : void 0;
  }
};
var UpdateAkitaDaoPluginParamsFactory = class _UpdateAkitaDaoPluginParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "create":
          case "create(uint64,byte[])void":
            return _UpdateAkitaDaoPluginParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs create ABI call params for the UpdateAkitaDAOPlugin smart contract using the create(uint64,byte[])void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params) {
        return {
          ...params,
          method: "create(uint64,byte[])void",
          args: Array.isArray(params.args) ? params.args : [params.args.akitaDao, params.args.clearProgram]
        };
      }
    };
  }
  /**
   * Constructs a no op call for the setClearProgram(uint64,bool,byte[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setClearProgram(params) {
    return {
      ...params,
      method: "setClearProgram(uint64,bool,byte[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.clearProgram]
    };
  }
  /**
   * Constructs a no op call for the initBoxedContract(uint64,string,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static initBoxedContract(params) {
    return {
      ...params,
      method: "initBoxedContract(uint64,string,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.version, params.args.size]
    };
  }
  /**
   * Constructs a no op call for the loadBoxedContract(uint64,uint64,byte[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static loadBoxedContract(params) {
    return {
      ...params,
      method: "loadBoxedContract(uint64,uint64,byte[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.offset, params.args.data]
    };
  }
  /**
   * Constructs a no op call for the deleteBoxedContract(uint64,bool)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static deleteBoxedContract(params) {
    return {
      ...params,
      method: "deleteBoxedContract(uint64,bool)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack]
    };
  }
  /**
   * Constructs a no op call for the updateApp(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateApp(params) {
    return {
      ...params,
      method: "updateApp(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId]
    };
  }
  /**
   * Constructs a no op call for the updateAkitaDaoAppIDForApp(uint64,bool,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDaoAppIdForApp(params) {
    return {
      ...params,
      method: "updateAkitaDaoAppIDForApp(uint64,bool,uint64,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.newAkitaDaoAppId]
    };
  }
  /**
   * Constructs a no op call for the updateAkitaDaoEscrowForApp(uint64,bool,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDaoEscrowForApp(params) {
    return {
      ...params,
      method: "updateAkitaDaoEscrowForApp(uint64,bool,uint64,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.newEscrow]
    };
  }
  /**
   * Constructs a no op call for the updateRevocation(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateRevocation(params) {
    return {
      ...params,
      method: "updateRevocation(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.app]
    };
  }
  /**
     * Constructs a no op call for the updateFactoryChildContract(uint64,bool,uint64)void ABI method
     *
    * Updates the factory's child contract bytecode using the contract stored in this plugin's box.
    This allows the factory to deploy new wallets with the updated AbstractedAccount contract.
    
    The contract must first be uploaded to this plugin via initBoxedContract/loadBoxedContract,
    then this method transfers it to the factory's box storage via inner transactions.
    
    Uses itxnCompose to group all inner transactions together so the factory's loadBoxedContract
    validation (which checks gtxn for initBoxedContract) works correctly.
  
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
  static updateFactoryChildContract(params) {
    return {
      ...params,
      method: "updateFactoryChildContract(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.factoryAppId]
    };
  }
};
var UpdateAkitaDaoPluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `UpdateAkitaDaoPluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory6({
      ...params,
      appSpec: APP_SPEC6
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC6;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new UpdateAkitaDaoPluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new UpdateAkitaDaoPluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the UpdateAkitaDAOPlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    var _a;
    const result = await this.appFactory.deploy({
      ...params,
      createParams: ((_a = params.createParams) == null ? void 0 : _a.method) ? UpdateAkitaDaoPluginParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams : void 0
    });
    return { result: result.result, appClient: new UpdateAkitaDaoPluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the UpdateAkitaDAOPlugin smart contract using the create(uint64,byte[])void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params) => {
        return this.appFactory.params.create(UpdateAkitaDaoPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the UpdateAkitaDAOPlugin smart contract using the create(uint64,byte[])void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params) => {
        return this.appFactory.createTransaction.create(UpdateAkitaDaoPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the UpdateAkitaDAOPlugin smart contract using an ABI method call using the create(uint64,byte[])void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params) => {
        const result = await this.appFactory.send.create(UpdateAkitaDaoPluginParamsFactory.create.create(params));
        return { result: { ...result.result, return: result.result.return }, appClient: new UpdateAkitaDaoPluginClient(result.appClient) };
      }
    }
  };
};
var UpdateAkitaDaoPluginClient = class _UpdateAkitaDaoPluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient6 ? appClientOrParams : new _AppClient6({
      ...appClientOrParams,
      appSpec: APP_SPEC6
    });
  }
  /**
   * Returns a new `UpdateAkitaDaoPluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _UpdateAkitaDaoPluginClient(await _AppClient6.fromCreatorAndName({ ...params, appSpec: APP_SPEC6 }));
  }
  /**
   * Returns an `UpdateAkitaDaoPluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _UpdateAkitaDaoPluginClient(await _AppClient6.fromNetwork({ ...params, appSpec: APP_SPEC6 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the UpdateAkitaDAOPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `setClearProgram(uint64,bool,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setClearProgram: (params) => {
      return this.appClient.params.call(UpdateAkitaDaoPluginParamsFactory.setClearProgram(params));
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `initBoxedContract(uint64,string,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    initBoxedContract: (params) => {
      return this.appClient.params.call(UpdateAkitaDaoPluginParamsFactory.initBoxedContract(params));
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `loadBoxedContract(uint64,uint64,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    loadBoxedContract: (params) => {
      return this.appClient.params.call(UpdateAkitaDaoPluginParamsFactory.loadBoxedContract(params));
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `deleteBoxedContract(uint64,bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    deleteBoxedContract: (params) => {
      return this.appClient.params.call(UpdateAkitaDaoPluginParamsFactory.deleteBoxedContract(params));
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `updateApp(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateApp: (params) => {
      return this.appClient.params.call(UpdateAkitaDaoPluginParamsFactory.updateApp(params));
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `updateAkitaDaoAppIDForApp(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDaoAppIdForApp: (params) => {
      return this.appClient.params.call(UpdateAkitaDaoPluginParamsFactory.updateAkitaDaoAppIdForApp(params));
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `updateAkitaDaoEscrowForApp(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDaoEscrowForApp: (params) => {
      return this.appClient.params.call(UpdateAkitaDaoPluginParamsFactory.updateAkitaDaoEscrowForApp(params));
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `updateRevocation(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateRevocation: (params) => {
      return this.appClient.params.call(UpdateAkitaDaoPluginParamsFactory.updateRevocation(params));
    },
    /**
         * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `updateFactoryChildContract(uint64,bool,uint64)void` ABI method.
         *
        * Updates the factory's child contract bytecode using the contract stored in this plugin's box.
        This allows the factory to deploy new wallets with the updated AbstractedAccount contract.
        
        The contract must first be uploaded to this plugin via initBoxedContract/loadBoxedContract,
        then this method transfers it to the factory's box storage via inner transactions.
        
        Uses itxnCompose to group all inner transactions together so the factory's loadBoxedContract
        validation (which checks gtxn for initBoxedContract) works correctly.
    
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
    updateFactoryChildContract: (params) => {
      return this.appClient.params.call(UpdateAkitaDaoPluginParamsFactory.updateFactoryChildContract(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the UpdateAkitaDAOPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `setClearProgram(uint64,bool,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setClearProgram: (params) => {
      return this.appClient.createTransaction.call(UpdateAkitaDaoPluginParamsFactory.setClearProgram(params));
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `initBoxedContract(uint64,string,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    initBoxedContract: (params) => {
      return this.appClient.createTransaction.call(UpdateAkitaDaoPluginParamsFactory.initBoxedContract(params));
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `loadBoxedContract(uint64,uint64,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    loadBoxedContract: (params) => {
      return this.appClient.createTransaction.call(UpdateAkitaDaoPluginParamsFactory.loadBoxedContract(params));
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `deleteBoxedContract(uint64,bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    deleteBoxedContract: (params) => {
      return this.appClient.createTransaction.call(UpdateAkitaDaoPluginParamsFactory.deleteBoxedContract(params));
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `updateApp(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateApp: (params) => {
      return this.appClient.createTransaction.call(UpdateAkitaDaoPluginParamsFactory.updateApp(params));
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `updateAkitaDaoAppIDForApp(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDaoAppIdForApp: (params) => {
      return this.appClient.createTransaction.call(UpdateAkitaDaoPluginParamsFactory.updateAkitaDaoAppIdForApp(params));
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `updateAkitaDaoEscrowForApp(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDaoEscrowForApp: (params) => {
      return this.appClient.createTransaction.call(UpdateAkitaDaoPluginParamsFactory.updateAkitaDaoEscrowForApp(params));
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `updateRevocation(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateRevocation: (params) => {
      return this.appClient.createTransaction.call(UpdateAkitaDaoPluginParamsFactory.updateRevocation(params));
    },
    /**
         * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `updateFactoryChildContract(uint64,bool,uint64)void` ABI method.
         *
        * Updates the factory's child contract bytecode using the contract stored in this plugin's box.
        This allows the factory to deploy new wallets with the updated AbstractedAccount contract.
        
        The contract must first be uploaded to this plugin via initBoxedContract/loadBoxedContract,
        then this method transfers it to the factory's box storage via inner transactions.
        
        Uses itxnCompose to group all inner transactions together so the factory's loadBoxedContract
        validation (which checks gtxn for initBoxedContract) works correctly.
    
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
    updateFactoryChildContract: (params) => {
      return this.appClient.createTransaction.call(UpdateAkitaDaoPluginParamsFactory.updateFactoryChildContract(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the UpdateAkitaDAOPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `setClearProgram(uint64,bool,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setClearProgram: async (params) => {
      const result = await this.appClient.send.call(UpdateAkitaDaoPluginParamsFactory.setClearProgram(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `initBoxedContract(uint64,string,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    initBoxedContract: async (params) => {
      const result = await this.appClient.send.call(UpdateAkitaDaoPluginParamsFactory.initBoxedContract(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `loadBoxedContract(uint64,uint64,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    loadBoxedContract: async (params) => {
      const result = await this.appClient.send.call(UpdateAkitaDaoPluginParamsFactory.loadBoxedContract(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `deleteBoxedContract(uint64,bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    deleteBoxedContract: async (params) => {
      const result = await this.appClient.send.call(UpdateAkitaDaoPluginParamsFactory.deleteBoxedContract(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `updateApp(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateApp: async (params) => {
      const result = await this.appClient.send.call(UpdateAkitaDaoPluginParamsFactory.updateApp(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `updateAkitaDaoAppIDForApp(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDaoAppIdForApp: async (params) => {
      const result = await this.appClient.send.call(UpdateAkitaDaoPluginParamsFactory.updateAkitaDaoAppIdForApp(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `updateAkitaDaoEscrowForApp(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDaoEscrowForApp: async (params) => {
      const result = await this.appClient.send.call(UpdateAkitaDaoPluginParamsFactory.updateAkitaDaoEscrowForApp(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `updateRevocation(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateRevocation: async (params) => {
      const result = await this.appClient.send.call(UpdateAkitaDaoPluginParamsFactory.updateRevocation(params));
      return { ...result, return: result.return };
    },
    /**
         * Makes a call to the UpdateAkitaDAOPlugin smart contract using the `updateFactoryChildContract(uint64,bool,uint64)void` ABI method.
         *
        * Updates the factory's child contract bytecode using the contract stored in this plugin's box.
        This allows the factory to deploy new wallets with the updated AbstractedAccount contract.
        
        The contract must first be uploaded to this plugin via initBoxedContract/loadBoxedContract,
        then this method transfers it to the factory's box storage via inner transactions.
        
        Uses itxnCompose to group all inner transactions together so the factory's loadBoxedContract
        validation (which checks gtxn for initBoxedContract) works correctly.
    
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
    updateFactoryChildContract: async (params) => {
      const result = await this.appClient.send.call(UpdateAkitaDaoPluginParamsFactory.updateFactoryChildContract(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _UpdateAkitaDaoPluginClient(this.appClient.clone(params));
  }
  /**
   * Methods to access state for the current UpdateAkitaDAOPlugin app
   */
  state = {
    /**
     * Methods to access global state for the current UpdateAkitaDAOPlugin app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async () => {
        const result = await this.appClient.state.global.getAll();
        return {
          akitaDao: result.akitaDAO,
          childContractVersion: result.childContractVersion,
          clearProgram: new BinaryStateValue2(result.clearProgram)
        };
      },
      /**
       * Get the current value of the akitaDAO key in global state
       */
      akitaDao: async () => {
        return await this.appClient.state.global.getValue("akitaDAO");
      },
      /**
       * Get the current value of the childContractVersion key in global state
       */
      childContractVersion: async () => {
        return await this.appClient.state.global.getValue("childContractVersion");
      },
      /**
       * Get the current value of the clearProgram key in global state
       */
      clearProgram: async () => {
        return new BinaryStateValue2(await this.appClient.state.global.getValue("clearProgram"));
      }
    },
    /**
     * Methods to access box state for the current UpdateAkitaDAOPlugin app
     */
    box: {
      /**
       * Get all current keyed values from box state
       */
      getAll: async () => {
        const result = await this.appClient.state.box.getAll();
        return {
          boxedContract: new BinaryStateValue2(result.boxedContract)
        };
      },
      /**
       * Get the current value of the boxedContract key in box state
       */
      boxedContract: async () => {
        return new BinaryStateValue2(await this.appClient.state.box.getValue("boxedContract"));
      }
    }
  };
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a setClearProgram(uint64,bool,byte[])void method call against the UpdateAkitaDAOPlugin contract
       */
      setClearProgram(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.setClearProgram(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a initBoxedContract(uint64,string,uint64)void method call against the UpdateAkitaDAOPlugin contract
       */
      initBoxedContract(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.initBoxedContract(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a loadBoxedContract(uint64,uint64,byte[])void method call against the UpdateAkitaDAOPlugin contract
       */
      loadBoxedContract(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.loadBoxedContract(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a deleteBoxedContract(uint64,bool)void method call against the UpdateAkitaDAOPlugin contract
       */
      deleteBoxedContract(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.deleteBoxedContract(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a updateApp(uint64,bool,uint64)void method call against the UpdateAkitaDAOPlugin contract
       */
      updateApp(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateApp(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a updateAkitaDaoAppIDForApp(uint64,bool,uint64,uint64)void method call against the UpdateAkitaDAOPlugin contract
       */
      updateAkitaDaoAppIdForApp(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDaoAppIdForApp(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a updateAkitaDaoEscrowForApp(uint64,bool,uint64,uint64)void method call against the UpdateAkitaDAOPlugin contract
       */
      updateAkitaDaoEscrowForApp(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDaoEscrowForApp(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a updateRevocation(uint64,bool,uint64)void method call against the UpdateAkitaDAOPlugin contract
       */
      updateRevocation(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateRevocation(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a updateFactoryChildContract(uint64,bool,uint64)void method call against the UpdateAkitaDAOPlugin contract
       */
      updateFactoryChildContract(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateFactoryChildContract(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a clear state call to the UpdateAkitaDAOPlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/update-akita-dao.ts
var UpdateAkitaDAOPluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: UpdateAkitaDaoPluginFactory, ...params });
  }
  deleteBoxedContract(args) {
    const methodName = "deleteBoxedContract";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.deleteBoxedContract({
          ...sendParams,
          args: { wallet, rekeyBack }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  updateApp(args) {
    const methodNames = ["initBoxedContract", "loadBoxedContract", "updateApp"];
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: methodNames.map((methodName) => this.client.appClient.getABIMethod(methodName).getSelector()),
        getTxns
      });
    }
    const { sender, signer, appId, version, data } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: methodNames.map((methodName) => this.client.appClient.getABIMethod(methodName).getSelector()),
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const txns = [];
        const initParams = await this.client.params.initBoxedContract({
          ...sendParams,
          args: { wallet, version, size: data.length }
        });
        txns.push({
          type: "methodCall",
          ...initParams
        });
        const CHUNK_SIZE = 2026;
        for (let i = 0; i < data.length; i += CHUNK_SIZE) {
          const chunk = data.slice(i, i + CHUNK_SIZE);
          const loadParams = await this.client.params.loadBoxedContract({
            ...sendParams,
            args: { wallet, offset: i, data: chunk }
          });
          txns.push({
            type: "methodCall",
            ...loadParams
          });
        }
        const updateParams = await this.client.params.updateApp({
          ...sendParams,
          args: { wallet, rekeyBack, appId }
        });
        txns.push({
          type: "methodCall",
          ...updateParams
        });
        return txns;
      }
    });
  }
  updateAkitaDaoAppIDForApp(args) {
    const methodName = "updateAkitaDaoAppIDForApp";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer, appId, newAkitaDaoAppId } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.updateAkitaDaoAppIdForApp({
          ...sendParams,
          args: { wallet, rekeyBack, appId, newAkitaDaoAppId }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  updateAkitaDaoEscrowForApp(args) {
    const methodName = "updateAkitaDaoEscrowForApp";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer, appId, newEscrow } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.updateAkitaDaoEscrowForApp({
          ...sendParams,
          args: { wallet, rekeyBack, appId, newEscrow }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  updateFactoryChildContract(args) {
    const methodNames = ["initBoxedContract", "loadBoxedContract", "updateFactoryChildContract"];
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: methodNames.map((methodName) => this.client.appClient.getABIMethod(methodName).getSelector()),
        getTxns
      });
    }
    const { sender, signer, factoryAppId, version, data } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: methodNames.map((methodName) => this.client.appClient.getABIMethod(methodName).getSelector()),
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const txns = [];
        const initParams = await this.client.params.initBoxedContract({
          ...sendParams,
          args: { wallet, version, size: data.length }
        });
        txns.push({
          type: "methodCall",
          ...initParams
        });
        const CHUNK_SIZE = 2026;
        for (let i = 0; i < data.length; i += CHUNK_SIZE) {
          const chunk = data.slice(i, i + CHUNK_SIZE);
          const loadParams = await this.client.params.loadBoxedContract({
            ...sendParams,
            args: { wallet, offset: i, data: chunk }
          });
          txns.push({
            type: "methodCall",
            ...loadParams
          });
        }
        const updateFactoryParams = await this.client.params.updateFactoryChildContract({
          ...sendParams,
          args: { wallet, rekeyBack, factoryAppId }
        });
        txns.push({
          type: "methodCall",
          ...updateFactoryParams
        });
        return txns;
      }
    });
  }
};

// src/generated/RevenueManagerPluginClient.ts
import { getABIStructFromABITuple as getABIStructFromABITuple4 } from "@algorandfoundation/algokit-utils/types/app-arc56";
import {
  AppClient as _AppClient7
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory7 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC7 = { "name": "RevenueManagerPlugin", "structs": { "EscrowAssetKey": [{ "name": "escrow", "type": "uint64" }, { "name": "asset", "type": "uint64" }], "ReceiveEscrow": [{ "name": "source", "type": "address" }, { "name": "allocatable", "type": "bool" }, { "name": "optinAllowed", "type": "bool" }, { "name": "optinCount", "type": "uint64" }, { "name": "phase", "type": "uint8" }, { "name": "allocationCounter", "type": "uint64" }, { "name": "lastDisbursement", "type": "uint64" }, { "name": "creationDate", "type": "uint64" }], "SplitRef": [{ "name": "app", "type": "uint64" }, { "name": "key", "type": "byte[]" }], "WalletEscrowKey": [{ "name": "wallet", "type": "uint64" }, { "name": "escrow", "type": "string" }] }, "methods": [{ "name": "create", "args": [{ "type": "string", "name": "version" }, { "type": "uint64", "name": "akitaDAO" }], "returns": { "type": "void" }, "actions": { "create": ["NoOp"], "call": [] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "optIn", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64[]", "name": "assets" }, { "type": "pay", "name": "mbrPayment" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "optin exists because revenue manager uses additional metadata to track optin counts for processing payments\nrevenue escrows must be locked to avoid mistracking optins to ensure all opted in assets get processed", "events": [], "recommendations": {} }, { "name": "newReceiveEscrow", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "string", "name": "escrow" }, { "type": "address", "name": "source" }, { "type": "bool", "name": "allocatable" }, { "type": "bool", "name": "optinAllowed" }, { "type": "((uint64,string),uint8,uint64)[]", "name": "splits" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Creates a new receive escrow with direct splits\nUse this when you want to store splits directly in this contract", "events": [], "recommendations": {} }, { "name": "newReceiveEscrowWithRef", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "string", "name": "escrow" }, { "type": "address", "name": "source" }, { "type": "bool", "name": "allocatable" }, { "type": "bool", "name": "optinAllowed" }, { "type": "(uint64,byte[])", "struct": "SplitRef", "name": "splitRef" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Creates a new receive escrow with a reference to splits stored in another contract\nUse this when you want splits to be dynamically read from another contract's global state", "events": [], "recommendations": {} }, { "name": "startEscrowDisbursement", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "processEscrowAllocation", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64[]", "name": "ids" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "finalizeEscrowDisbursement", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64[]", "name": "ids" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "desc": "Cleans up processed asset boxes and resets escrow back to idle state\nMust be called after all assets have been processed (escrow in Finalization phase)\nCan be called in batches - pass the asset IDs that were processed to delete their tracking boxes", "events": [], "recommendations": {} }, { "name": "updateAkitaDAO", "args": [{ "type": "uint64", "name": "akitaDAO" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "opUp", "args": [], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }], "arcs": [22, 28], "desc": "high level overview of how revenue manager works:\n\n1. DAO installs it twice:  \n - once with execution key that can do anything\n - once globally with methods restricted to: optin, startEscrowDisbursement, processEscrowAllocation\n2. DAO proposes 'new escrow'\n2. DAO proposes 'execute plugin' -> revenue-manager:newReceiveEscrow", "networks": {}, "state": { "schema": { "global": { "ints": 1, "bytes": 1 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": { "version": { "keyType": "AVMString", "valueType": "AVMString", "key": "dmVyc2lvbg==", "desc": "the current version of the contract" }, "akitaDAO": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "YWtpdGFfZGFv", "desc": "the app ID of the Akita DAO" } }, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": { "escrows": { "keyType": "WalletEscrowKey", "valueType": "ReceiveEscrow", "desc": "box map of all the escrows", "prefix": "ZQ==" }, "receiveAssets": { "keyType": "EscrowAssetKey", "valueType": "AVMBytes", "desc": "box map of escrow assets that have already been processed during this allocation", "prefix": "YQ==" }, "splits": { "keyType": "WalletEscrowKey", "valueType": "((uint64,string),uint8,uint64)[]", "desc": "how to split revenue & where to send it", "prefix": "cw==" }, "splitRefs": { "keyType": "WalletEscrowKey", "valueType": "SplitRef", "desc": "references to splits stored in other contracts (alternative to direct splits)", "prefix": "cg==" } } } }, "bareActions": { "create": [], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [1325], "errorMessage": "Asset is already allocated" }, { "pc": [2145], "errorMessage": "Asset was not allocated" }, { "pc": [1542], "errorMessage": "Assets and amounts mismatch" }, { "pc": [639, 1221, 1260, 1919, 2095, 2159], "errorMessage": "Box must have value" }, { "pc": [248, 1485], "errorMessage": "Bytes has valid prefix" }, { "pc": [1021, 1194, 2072], "errorMessage": "Controlled address must be escrow" }, { "pc": [1972], "errorMessage": "Either splits or a split reference must be provided" }, { "pc": [267, 431, 998, 1047, 1169, 2051], "errorMessage": "Escrow does not exist" }, { "pc": [1079], "errorMessage": "Escrow is not allocatable" }, { "pc": [542], "errorMessage": "Escrow is not allowed to opt-in" }, { "pc": [1242], "errorMessage": "Escrow is not in allocation phase" }, { "pc": [2108], "errorMessage": "Escrow is not in finalization phase" }, { "pc": [1076], "errorMessage": "Escrow is not in idle phase" }, { "pc": [1096], "errorMessage": "Escrow is not ready for disbursement" }, { "pc": [2453], "errorMessage": "Flat amounts with percentages require a remainder or 100% total" }, { "pc": [456], "errorMessage": "Invalid payment" }, { "pc": [1864], "errorMessage": "Invalid percentage" }, { "pc": [77], "errorMessage": "OnCompletion must be NoOp" }, { "pc": [2230], "errorMessage": "Only the Akita DAO can call this function" }, { "pc": [1789], "errorMessage": "Over allocation of assets in the escrow" }, { "pc": [2428], "errorMessage": "Percentage splits cannot total 100% when using a remainder" }, { "pc": [2478], "errorMessage": "Percentage splits must total 100% or include a remainder" }, { "pc": [485], "errorMessage": "Receive escrow does not exist" }, { "pc": [1997], "errorMessage": "Referenced splits not found in target contract" }, { "pc": [2398], "errorMessage": "Remainder split must be the last split" }, { "pc": [2350], "errorMessage": "Split value must be positive or remainder" }, { "pc": [737, 1269], "errorMessage": "Splits cannot be empty" }, { "pc": [741, 1273], "errorMessage": "Splits cannot be more than 10" }, { "pc": [2415], "errorMessage": "Total percentage splits exceed 100%" }, { "pc": [2244], "errorMessage": "account funded" }, { "pc": [575], "errorMessage": "already opted in" }, { "pc": [323, 525, 1019, 1192, 1511, 2070, 2228], "errorMessage": "application exists" }, { "pc": [1525, 2215], "errorMessage": "check GlobalState exists" }, { "pc": [1380, 2130, 2302], "errorMessage": "index access is out of bounds" }, { "pc": [260, 1497], "errorMessage": "invalid number of bytes for (len+(uint64,bool1)[])" }, { "pc": [412, 1161, 2043], "errorMessage": "invalid number of bytes for (len+uint64[])" }, { "pc": [337, 688, 852], "errorMessage": "invalid number of bytes for (len+utf8[])" }, { "pc": [387, 673, 708, 718, 837, 872, 882, 987, 1138, 2020], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [348, 377, 664, 828, 978, 1128, 2010, 2207], "errorMessage": "invalid number of bytes for uint64" }, { "pc": [700, 864], "errorMessage": "invalid number of bytes for uint8[32]" }, { "pc": [539, 732, 896, 1015], "errorMessage": "only the creator wallet can delete a spending account" }, { "pc": [422], "errorMessage": "transaction type is pay" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDggMiAxMDAwMDAKICAgIGJ5dGVjYmxvY2sgInNwZW5kaW5nX2FkZHJlc3MiICIiIDB4MDAwYSAiZSIgMHgwMCAweDFlICJha2l0YV9kYW8iIDB4MTQgMHg2ODM1ZTNiYyAweDAwMDEwMDAyIDB4YTI0MDNkZGYgMHgxNTFmN2M3NSAweDAwMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjI5CiAgICAvLyBleHBvcnQgY2xhc3MgUmV2ZW51ZU1hbmFnZXJQbHVnaW4gZXh0ZW5kcyBBa2l0YUJhc2VDb250cmFjdCB7CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIG11c3QgYmUgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGJ6IG1haW5fY3JlYXRlX05vT3BAMTIKICAgIGJ5dGVjIDggLy8gbWV0aG9kICJvcHRJbih1aW50NjQsYm9vbCx1aW50NjRbXSxwYXkpdm9pZCIKICAgIHB1c2hieXRlc3MgMHhlYzhkNDNlNSAweDJkODBlNmZjIDB4ODRmMzRjMDQgMHhmZTQxMGY0NCAweDdlN2MwZjcwIDB4MzNlOTJjOTQgMHg4NTRkZWRlMCAvLyBtZXRob2QgIm5ld1JlY2VpdmVFc2Nyb3codWludDY0LGJvb2wsc3RyaW5nLGFkZHJlc3MsYm9vbCxib29sLCgodWludDY0LHN0cmluZyksdWludDgsdWludDY0KVtdKXZvaWQiLCBtZXRob2QgIm5ld1JlY2VpdmVFc2Nyb3dXaXRoUmVmKHVpbnQ2NCxib29sLHN0cmluZyxhZGRyZXNzLGJvb2wsYm9vbCwodWludDY0LGJ5dGVbXSkpdm9pZCIsIG1ldGhvZCAic3RhcnRFc2Nyb3dEaXNidXJzZW1lbnQodWludDY0LGJvb2wpdm9pZCIsIG1ldGhvZCAicHJvY2Vzc0VzY3Jvd0FsbG9jYXRpb24odWludDY0LGJvb2wsdWludDY0W10pdm9pZCIsIG1ldGhvZCAiZmluYWxpemVFc2Nyb3dEaXNidXJzZW1lbnQodWludDY0LGJvb2wsdWludDY0W10pdm9pZCIsIG1ldGhvZCAidXBkYXRlQWtpdGFEQU8odWludDY0KXZvaWQiLCBtZXRob2QgIm9wVXAoKXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBvcHRJbiBuZXdSZWNlaXZlRXNjcm93IG5ld1JlY2VpdmVFc2Nyb3dXaXRoUmVmIHN0YXJ0RXNjcm93RGlzYnVyc2VtZW50IHByb2Nlc3NFc2Nyb3dBbGxvY2F0aW9uIGZpbmFsaXplRXNjcm93RGlzYnVyc2VtZW50IHVwZGF0ZUFraXRhREFPIG1haW5fb3BVcF9yb3V0ZUAxMAogICAgZXJyCgptYWluX29wVXBfcm91dGVAMTA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo0MwogICAgLy8gb3BVcCgpOiB2b2lkIHsgfQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9jcmVhdGVfTm9PcEAxMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjI5CiAgICAvLyBleHBvcnQgY2xhc3MgUmV2ZW51ZU1hbmFnZXJQbHVnaW4gZXh0ZW5kcyBBa2l0YUJhc2VDb250cmFjdCB7CiAgICBwdXNoYnl0ZXMgMHhjZDlhZDY3ZSAvLyBtZXRob2QgImNyZWF0ZShzdHJpbmcsdWludDY0KXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBjcmVhdGUKICAgIGVycgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OmdldEVzY3Jvdyh3YWxsZXQ6IHVpbnQ2NCkgLT4gYnl0ZXM6CmdldEVzY3JvdzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjczCiAgICAvLyBleHBvcnQgZnVuY3Rpb24gZ2V0RXNjcm93KHdhbGxldDogQXBwbGljYXRpb24pOiBzdHJpbmcgewogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI3Ni0yNzkKICAgIC8vIGNvbnN0IFtjdXJyZW50UGx1Z2luQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ3VycmVudFBsdWdpbikKICAgIC8vICkKICAgIGZyYW1lX2RpZyAtMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNzgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0N1cnJlbnRQbHVnaW4pCiAgICBwdXNoYnl0ZXMgImN1cnJlbnRfcGx1Z2luIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNzYtMjc5CiAgICAvLyBjb25zdCBbY3VycmVudFBsdWdpbkJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0N1cnJlbnRQbHVnaW4pCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI4MgogICAgLy8gcmV0dXJuIGN1cnJlbnRQbHVnaW4uZXNjcm93CiAgICBkdXAKICAgIHB1c2hpbnQgNDAgLy8gNDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMQogICAgbGVuCiAgICBzdWJzdHJpbmczCiAgICBleHRyYWN0IDIgMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6bXVzdEdldEVzY3Jvd0luZm8od2FsbGV0OiB1aW50NjQpIC0+IGJ5dGVzOgptdXN0R2V0RXNjcm93SW5mbzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjkzCiAgICAvLyBleHBvcnQgZnVuY3Rpb24gbXVzdEdldEVzY3Jvd0luZm8od2FsbGV0OiBBcHBsaWNhdGlvbik6IEVzY3Jvd0luZm8gewogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI4NgogICAgLy8gY29uc3QgZXNjcm93ID0gZ2V0RXNjcm93KHdhbGxldCkKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiBnZXRFc2Nyb3cKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6Mjg3LTI5MAogICAgLy8gcmV0dXJuIGFiaUNhbGw8dHlwZW9mIEFic3RyYWN0ZWRBY2NvdW50LnByb3RvdHlwZS5hcmM1OF9nZXRFc2Nyb3dzPih7CiAgICAvLyAgIGFwcElkOiB3YWxsZXQuaWQsCiAgICAvLyAgIGFyZ3M6IFtbZXNjcm93XV0KICAgIC8vIH0pLnJldHVyblZhbHVlWzBdCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI4OQogICAgLy8gYXJnczogW1tlc2Nyb3ddXQogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjIDkgLy8gMHgwMDAxMDAwMgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI4Ny0yOTAKICAgIC8vIHJldHVybiBhYmlDYWxsPHR5cGVvZiBBYnN0cmFjdGVkQWNjb3VudC5wcm90b3R5cGUuYXJjNThfZ2V0RXNjcm93cz4oewogICAgLy8gICBhcHBJZDogd2FsbGV0LmlkLAogICAgLy8gICBhcmdzOiBbW2VzY3Jvd11dCiAgICAvLyB9KS5yZXR1cm5WYWx1ZVswXQogICAgYnl0ZWMgMTAgLy8gbWV0aG9kICJhcmM1OF9nZXRFc2Nyb3dzKHN0cmluZ1tdKSh1aW50NjQsYm9vbClbXSIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIGRpZyAxCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWMgMTEgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBCeXRlcyBoYXMgdmFsaWQgcHJlZml4CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCA5IC8vIDkKICAgICoKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBzd2FwCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rKHVpbnQ2NCxib29sMSlbXSkKICAgIGV4dHJhY3QgNiA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI5NQogICAgLy8gYXNzZXJ0KGluZm8uaWQgPiAwLCBFUlJfRVNDUk9XX0RPRVNfTk9UX0VYSVNUKQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGFzc2VydCAvLyBFc2Nyb3cgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6Mjk2CiAgICAvLyByZXR1cm4gaW5mbwogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6cmVrZXlCYWNrSWZOZWNlc3NhcnkocmVrZXlCYWNrOiB1aW50NjQsIHdhbGxldDogdWludDY0KSAtPiB2b2lkOgpyZWtleUJhY2tJZk5lY2Vzc2FyeToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzA3CiAgICAvLyBleHBvcnQgZnVuY3Rpb24gcmVrZXlCYWNrSWZOZWNlc3NhcnkocmVrZXlCYWNrOiBib29sZWFuLCB3YWxsZXQ6IEFwcGxpY2F0aW9uKTogdm9pZCB7CiAgICBwcm90byAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzA4CiAgICAvLyBpZiAocmVrZXlCYWNrKSB7CiAgICBmcmFtZV9kaWcgLTIKICAgIGJ6IHJla2V5QmFja0lmTmVjZXNzYXJ5X2FmdGVyX2lmX2Vsc2VAMwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZnJhbWVfZGlnIC0xCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMCAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzEwLTMxNwogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyLAogICAgLy8gICAgIHJlY2VpdmVyOiBzZW5kZXIsCiAgICAvLyAgICAgYW1vdW50OiAwLAogICAgLy8gICAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMTUKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2RpZyAtMQogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMTQKICAgIC8vIGFtb3VudDogMCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMTAtMzE2CiAgICAvLyBpdHhuCiAgICAvLyAgIC5wYXltZW50KHsKICAgIC8vICAgICBzZW5kZXIsCiAgICAvLyAgICAgcmVjZWl2ZXI6IHNlbmRlciwKICAgIC8vICAgICBhbW91bnQ6IDAsCiAgICAvLyAgICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vICAgfSkKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzEwLTMxNwogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyLAogICAgLy8gICAgIHJlY2VpdmVyOiBzZW5kZXIsCiAgICAvLyAgICAgYW1vdW50OiAwLAogICAgLy8gICAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCnJla2V5QmFja0lmTmVjZXNzYXJ5X2FmdGVyX2lmX2Vsc2VAMzoKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OnJla2V5QWRkcmVzcyhyZWtleUJhY2s6IHVpbnQ2NCwgd2FsbGV0OiB1aW50NjQpIC0+IGJ5dGVzOgpyZWtleUFkZHJlc3M6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMQogICAgLy8gZXhwb3J0IGZ1bmN0aW9uIHJla2V5QWRkcmVzcyhyZWtleUJhY2s6IGJvb2xlYW4sIHdhbGxldDogQXBwbGljYXRpb24pOiBBY2NvdW50IHsKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjIKICAgIC8vIGlmICghcmVrZXlCYWNrKSB7CiAgICBmcmFtZV9kaWcgLTIKICAgIGJueiByZWtleUFkZHJlc3NfYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMwogICAgLy8gcmV0dXJuIEdsb2JhbC56ZXJvQWRkcmVzcwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICByZXRzdWIKCnJla2V5QWRkcmVzc19hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyNgogICAgLy8gcmV0dXJuIHdhbGxldC5hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjpSZXZlbnVlTWFuYWdlclBsdWdpbi5jcmVhdGVbcm91dGluZ10oKSAtPiB2b2lkOgpjcmVhdGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoxMDgKICAgIC8vIEBhYmltZXRob2QoeyBvbkNyZWF0ZTogJ3JlcXVpcmUnIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyNwogICAgLy8gdmVyc2lvbiA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5VmVyc2lvbiB9KQogICAgcHVzaGJ5dGVzICJ2ZXJzaW9uIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MTEwCiAgICAvLyB0aGlzLnZlcnNpb24udmFsdWUgPSB2ZXJzaW9uCiAgICB1bmNvdmVyIDIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjIDYgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjExMQogICAgLy8gdGhpcy5ha2l0YURBTy52YWx1ZSA9IGFraXRhREFPCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MTA4CiAgICAvLyBAYWJpbWV0aG9kKHsgb25DcmVhdGU6ICdyZXF1aXJlJyB9KQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjpSZXZlbnVlTWFuYWdlclBsdWdpbi5vcHRJbltyb3V0aW5nXSgpIC0+IHZvaWQ6Cm9wdEluOgogICAgYnl0ZWNfMSAvLyAiIgogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoxMTgKICAgIC8vIG9wdEluKHdhbGxldDogQXBwbGljYXRpb24sIHJla2V5QmFjazogYm9vbGVhbiwgYXNzZXRzOiB1aW50NjRbXSwgbWJyUGF5bWVudDogZ3R4bi5QYXltZW50VHhuKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGR1cAogICAgaW50Y18yIC8vIDgKICAgICoKICAgIGludGNfMyAvLyAyCiAgICArCiAgICB1bmNvdmVyIDIKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1aW50NjRbXSkKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MTE5CiAgICAvLyBjb25zdCBlc2Nyb3cgPSBnZXRFc2Nyb3cod2FsbGV0KQogICAgZGlnIDIKICAgIGNhbGxzdWIgZ2V0RXNjcm93CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoxMjAKICAgIC8vIGFzc2VydChlc2Nyb3cgIT09ICcnLCBFUlJfRVNDUk9XX0RPRVNfTk9UX0VYSVNUKQogICAgZHVwCiAgICBieXRlY18xIC8vICIiCiAgICAhPQogICAgYXNzZXJ0IC8vIEVzY3JvdyBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18wIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgZHVwCiAgICBjb3ZlciA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoxMjMtMTMyCiAgICAvLyBhc3NlcnRNYXRjaCgKICAgIC8vICAgbWJyUGF5bWVudCwKICAgIC8vICAgewogICAgLy8gICAgIHJlY2VpdmVyOiBzZW5kZXIsCiAgICAvLyAgICAgYW1vdW50OiB7CiAgICAvLyAgICAgICBncmVhdGVyVGhhbkVxOiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UgKiBhc3NldHMubGVuZ3RoCiAgICAvLyAgICAgfQogICAgLy8gICB9LAogICAgLy8gICBFUlJfSU5WQUxJRF9QQVlNRU5UCiAgICAvLyApCiAgICBkaWcgMgogICAgZ3R4bnMgUmVjZWl2ZXIKICAgID09CiAgICB1bmNvdmVyIDIKICAgIGd0eG5zIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MTI4CiAgICAvLyBncmVhdGVyVGhhbkVxOiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UgKiBhc3NldHMubGVuZ3RoCiAgICBnbG9iYWwgQXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIHVuY292ZXIgNAogICAgKgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MTIzLTEzMgogICAgLy8gYXNzZXJ0TWF0Y2goCiAgICAvLyAgIG1iclBheW1lbnQsCiAgICAvLyAgIHsKICAgIC8vICAgICByZWNlaXZlcjogc2VuZGVyLAogICAgLy8gICAgIGFtb3VudDogewogICAgLy8gICAgICAgZ3JlYXRlclRoYW5FcTogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlICogYXNzZXRzLmxlbmd0aAogICAgLy8gICAgIH0KICAgIC8vICAgfSwKICAgIC8vICAgRVJSX0lOVkFMSURfUEFZTUVOVAogICAgLy8gKQogICAgPj0KICAgICYmCiAgICBhc3NlcnQgLy8gSW52YWxpZCBwYXltZW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoxMzQKICAgIC8vIGFzc2VydCh0aGlzLmVzY3Jvd3MoeyB3YWxsZXQsIGVzY3JvdyB9KS5leGlzdHMsIEVSUl9SRUNFSVZFX0VTQ1JPV19ET0VTX05PVF9FWElTVCkKICAgIGRpZyAxCiAgICBpdG9iCiAgICBkaWcgMQogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGJ5dGVjXzIgLy8gMHgwMDBhCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzEKICAgIC8vIGVzY3Jvd3MgPSBCb3hNYXA8V2FsbGV0RXNjcm93S2V5LCBSZWNlaXZlRXNjcm93Pih7IGtleVByZWZpeDogUmV2ZW51ZU1hbmFnZXJCb3hQcmVmaXhFc2Nyb3dzIH0pCiAgICBieXRlY18zIC8vICJlIgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjEzNAogICAgLy8gYXNzZXJ0KHRoaXMuZXNjcm93cyh7IHdhbGxldCwgZXNjcm93IH0pLmV4aXN0cywgRVJSX1JFQ0VJVkVfRVNDUk9XX0RPRVNfTk9UX0VYSVNUKQogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBSZWNlaXZlIGVzY3JvdyBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MTM2CiAgICAvLyBjb25zdCB7IHNvdXJjZSwgb3B0aW5BbGxvd2VkIH0gPSB0aGlzLmVzY3Jvd3MoeyB3YWxsZXQsIGVzY3JvdyB9KS52YWx1ZQogICAgYm94X2dldAogICAgcG9wCiAgICBkdXAKICAgIGV4dHJhY3QgMCAzMgogICAgY292ZXIgMgogICAgcHVzaGludCAyNTcgLy8gMjU3CiAgICBnZXRiaXQKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzAyCiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNSZWtleUluZGV4KQogICAgcHVzaGJ5dGVzICJyZWtleV9pbmRleCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzAwLTMwMwogICAgLy8gY29uc3QgW3Jla2V5SW5kZXhCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzUmVrZXlJbmRleCkKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjEzNwogICAgLy8gY29uc3QgaW5pdGlhdG9yID0gZ3R4bi5UcmFuc2FjdGlvbihnZXRSZWtleUluZGV4KHdhbGxldCkpLnNlbmRlcgogICAgZ3R4bnMgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoxMzgKICAgIC8vIGNvbnN0IGlzQ2hpbGQgPSBHbG9iYWwuY2FsbGVyQXBwbGljYXRpb25JZCAhPT0gMCAmJiBBcHBsaWNhdGlvbihHbG9iYWwuY2FsbGVyQXBwbGljYXRpb25JZCkuY3JlYXRvciA9PT0gc291cmNlCiAgICBnbG9iYWwgQ2FsbGVyQXBwbGljYXRpb25JRAogICAgYnogb3B0SW5fYm9vbF9mYWxzZUA0CiAgICBnbG9iYWwgQ2FsbGVyQXBwbGljYXRpb25JRAogICAgYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgZGlnIDMKICAgID09CiAgICBieiBvcHRJbl9ib29sX2ZhbHNlQDQKICAgIGludGNfMSAvLyAxCgpvcHRJbl9ib29sX21lcmdlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoxMzkKICAgIC8vIGFzc2VydChzb3VyY2UgPT09IGluaXRpYXRvciB8fCBpc0NoaWxkLCBFUlJfRk9SQklEREVOKQogICAgZGlnIDMKICAgIGRpZyAyCiAgICA9PQogICAgfHwKICAgIGFzc2VydCAvLyBvbmx5IHRoZSBjcmVhdG9yIHdhbGxldCBjYW4gZGVsZXRlIGEgc3BlbmRpbmcgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MTQwCiAgICAvLyBhc3NlcnQob3B0aW5BbGxvd2VkLCBFUlJfRVNDUk9XX05PVF9BTExPV0VEX1RPX09QVElOKQogICAgZGlnIDEKICAgIGFzc2VydCAvLyBFc2Nyb3cgaXMgbm90IGFsbG93ZWQgdG8gb3B0LWluCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoxNDIKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBhc3NldHMubGVuZ3RoOyBpKyspIHsKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDExCgpvcHRJbl93aGlsZV90b3BANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjE0MgogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGFzc2V0cy5sZW5ndGg7IGkrKykgewogICAgZGlnIDEwCiAgICBkaWcgNgogICAgPAogICAgYnogb3B0SW5fYWZ0ZXJfd2hpbGVAMTMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjE0MwogICAgLy8gYXNzZXJ0KCFzZW5kZXIuaXNPcHRlZEluKEFzc2V0KGFzc2V0c1tpXSkpLCBFUlJfQUxSRUFEWV9PUFRFRF9JTikKICAgIGRpZyA2CiAgICBleHRyYWN0IDIgMAogICAgZGlnIDExCiAgICBpbnRjXzIgLy8gOAogICAgKgogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgYnVyeSAxMQogICAgZGlnIDUKICAgIHN3YXAKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICAhCiAgICBhc3NlcnQgLy8gYWxyZWFkeSBvcHRlZCBpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MTQ1LTE1MwogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgc2VuZGVyLAogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IHNlbmRlciwKICAgIC8vICAgICBhc3NldEFtb3VudDogMCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IEFzc2V0KGFzc2V0c1tpXSksCiAgICAvLyAgICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjayAmJiAoaSA9PT0gKGFzc2V0cy5sZW5ndGggLSAxKSksIHdhbGxldCkKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpOwogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MTUxCiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrICYmIChpID09PSAoYXNzZXRzLmxlbmd0aCAtIDEpKSwgd2FsbGV0KQogICAgZGlnIDcKICAgIGJ6IG9wdEluX2Jvb2xfZmFsc2VAMTAKICAgIGRpZyA1CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZGlnIDExCiAgICA9PQogICAgYnogb3B0SW5fYm9vbF9mYWxzZUAxMAogICAgaW50Y18xIC8vIDEKCm9wdEluX2Jvb2xfbWVyZ2VAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoxNTEKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2sgJiYgKGkgPT09IChhc3NldHMubGVuZ3RoIC0gMSkpLCB3YWxsZXQpCiAgICBkaWcgOQogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgZGlnIDkKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoxNDkKICAgIC8vIGFzc2V0QW1vdW50OiAwLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGRpZyA0CiAgICBkdXAKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjE0NS0xNTIKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIHNlbmRlciwKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBzZW5kZXIsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyAgICAgeGZlckFzc2V0OiBBc3NldChhc3NldHNbaV0pLAogICAgLy8gICAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2sgJiYgKGkgPT09IChhc3NldHMubGVuZ3RoIC0gMSkpLCB3YWxsZXQpCiAgICAvLyAgIH0pCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoxNDUtMTUzCiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBzZW5kZXIsCiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogc2VuZGVyLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiAwLAogICAgLy8gICAgIHhmZXJBc3NldDogQXNzZXQoYXNzZXRzW2ldKSwKICAgIC8vICAgICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrICYmIChpID09PSAoYXNzZXRzLmxlbmd0aCAtIDEpKSwgd2FsbGV0KQogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCk7CiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MTQyCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgYXNzZXRzLmxlbmd0aDsgaSsrKSB7CiAgICBkaWcgMTAKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBidXJ5IDExCiAgICBiIG9wdEluX3doaWxlX3RvcEA2CgpvcHRJbl9ib29sX2ZhbHNlQDEwOgogICAgaW50Y18wIC8vIDAKICAgIGIgb3B0SW5fYm9vbF9tZXJnZUAxMQoKb3B0SW5fYWZ0ZXJfd2hpbGVAMTM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoxNTYKICAgIC8vIHRoaXMuZXNjcm93cyh7IHdhbGxldCwgZXNjcm93IH0pLnZhbHVlLm9wdGluQ291bnQgKz0gYXNzZXRzLmxlbmd0aAogICAgZGlnIDMKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIHB1c2hpbnQgMzMgLy8gMzMKICAgIGV4dHJhY3RfdWludDY0CiAgICBkaWcgNwogICAgKwogICAgaXRvYgogICAgcHVzaGludCAzMyAvLyAzMwogICAgc3dhcAogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjExOAogICAgLy8gb3B0SW4od2FsbGV0OiBBcHBsaWNhdGlvbiwgcmVrZXlCYWNrOiBib29sZWFuLCBhc3NldHM6IHVpbnQ2NFtdLCBtYnJQYXltZW50OiBndHhuLlBheW1lbnRUeG4pOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm9wdEluX2Jvb2xfZmFsc2VANDoKICAgIGludGNfMCAvLyAwCiAgICBiIG9wdEluX2Jvb2xfbWVyZ2VANQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjpSZXZlbnVlTWFuYWdlclBsdWdpbi5uZXdSZWNlaXZlRXNjcm93W3JvdXRpbmddKCkgLT4gdm9pZDoKbmV3UmVjZWl2ZUVzY3JvdzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjE2My0xNzEKICAgIC8vIG5ld1JlY2VpdmVFc2Nyb3coCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgZXNjcm93OiBzdHJpbmcsCiAgICAvLyAgIHNvdXJjZTogQWNjb3VudCwKICAgIC8vICAgYWxsb2NhdGFibGU6IGJvb2xlYW4sCiAgICAvLyAgIG9wdGluQWxsb3dlZDogYm9vbGVhbiwKICAgIC8vICAgc3BsaXRzOiBTcGxpdFtdCiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDYKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMCAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjE3MwogICAgLy8gYXNzZXJ0KHRoaXMuY29udHJvbHMoc2VuZGVyKSwgRVJSX0ZPUkJJRERFTikKICAgIGNhbGxzdWIgY29udHJvbHMKICAgIGFzc2VydCAvLyBvbmx5IHRoZSBjcmVhdG9yIHdhbGxldCBjYW4gZGVsZXRlIGEgc3BlbmRpbmcgYWNjb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MTc0CiAgICAvLyBhc3NlcnQoc3BsaXRzLmxlbmd0aCA+IDAsIEVSUl9TUExJVFNfQ0FOTk9UX0JFX0VNUFRZKQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGR1cAogICAgYXNzZXJ0IC8vIFNwbGl0cyBjYW5ub3QgYmUgZW1wdHkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjE3NQogICAgLy8gYXNzZXJ0KHNwbGl0cy5sZW5ndGggPD0gMTAsIEVSUl9TUExJVFNfQ0FOTk9UX0JFX01PUkVfVEhBTl8xMCkKICAgIHB1c2hpbnQgMTAgLy8gMTAKICAgIDw9CiAgICBhc3NlcnQgLy8gU3BsaXRzIGNhbm5vdCBiZSBtb3JlIHRoYW4gMTAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjE4NQogICAgLy8gY3JlYXRpb25EYXRlOiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wLAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MTc3LTE4NgogICAgLy8gdGhpcy5lc2Nyb3dzKHsgd2FsbGV0LCBlc2Nyb3cgfSkudmFsdWUgPSB7CiAgICAvLyAgIHNvdXJjZSwKICAgIC8vICAgYWxsb2NhdGFibGUsCiAgICAvLyAgIG9wdGluQWxsb3dlZCwKICAgIC8vICAgb3B0aW5Db3VudDogMCwKICAgIC8vICAgcGhhc2U6IEVzY3Jvd0Rpc2J1cnNlbWVudFBoYXNlSWRsZSwKICAgIC8vICAgYWxsb2NhdGlvbkNvdW50ZXI6IDAsCiAgICAvLyAgIGxhc3REaXNidXJzZW1lbnQ6IDAsCiAgICAvLyAgIGNyZWF0aW9uRGF0ZTogR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCwKICAgIC8vIH0KICAgIGJ5dGVjIDQgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgNQogICAgc2V0Yml0CiAgICBpbnRjXzEgLy8gMQogICAgdW5jb3ZlciA0CiAgICBzZXRiaXQKICAgIHVuY292ZXIgMwogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoxODEKICAgIC8vIG9wdGluQ291bnQ6IDAsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MTc3LTE4NgogICAgLy8gdGhpcy5lc2Nyb3dzKHsgd2FsbGV0LCBlc2Nyb3cgfSkudmFsdWUgPSB7CiAgICAvLyAgIHNvdXJjZSwKICAgIC8vICAgYWxsb2NhdGFibGUsCiAgICAvLyAgIG9wdGluQWxsb3dlZCwKICAgIC8vICAgb3B0aW5Db3VudDogMCwKICAgIC8vICAgcGhhc2U6IEVzY3Jvd0Rpc2J1cnNlbWVudFBoYXNlSWRsZSwKICAgIC8vICAgYWxsb2NhdGlvbkNvdW50ZXI6IDAsCiAgICAvLyAgIGxhc3REaXNidXJzZW1lbnQ6IDAsCiAgICAvLyAgIGNyZWF0aW9uRGF0ZTogR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCwKICAgIC8vIH0KICAgIGl0b2IKICAgIHN3YXAKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjE4MgogICAgLy8gcGhhc2U6IEVzY3Jvd0Rpc2J1cnNlbWVudFBoYXNlSWRsZSwKICAgIGJ5dGVjIDQgLy8gMHgwMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MTc3LTE4NgogICAgLy8gdGhpcy5lc2Nyb3dzKHsgd2FsbGV0LCBlc2Nyb3cgfSkudmFsdWUgPSB7CiAgICAvLyAgIHNvdXJjZSwKICAgIC8vICAgYWxsb2NhdGFibGUsCiAgICAvLyAgIG9wdGluQWxsb3dlZCwKICAgIC8vICAgb3B0aW5Db3VudDogMCwKICAgIC8vICAgcGhhc2U6IEVzY3Jvd0Rpc2J1cnNlbWVudFBoYXNlSWRsZSwKICAgIC8vICAgYWxsb2NhdGlvbkNvdW50ZXI6IDAsCiAgICAvLyAgIGxhc3REaXNidXJzZW1lbnQ6IDAsCiAgICAvLyAgIGNyZWF0aW9uRGF0ZTogR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCwKICAgIC8vIH0KICAgIGNvbmNhdAogICAgZGlnIDEKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBzd2FwCiAgICBpdG9iCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjE3NwogICAgLy8gdGhpcy5lc2Nyb3dzKHsgd2FsbGV0LCBlc2Nyb3cgfSkudmFsdWUgPSB7CiAgICBkaWcgNAogICAgaXRvYgogICAgZGlnIDMKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHVuY292ZXIgNAogICAgY29uY2F0CiAgICBzd2FwCiAgICBieXRlY18yIC8vIDB4MDAwYQogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjMxCiAgICAvLyBlc2Nyb3dzID0gQm94TWFwPFdhbGxldEVzY3Jvd0tleSwgUmVjZWl2ZUVzY3Jvdz4oeyBrZXlQcmVmaXg6IFJldmVudWVNYW5hZ2VyQm94UHJlZml4RXNjcm93cyB9KQogICAgYnl0ZWNfMyAvLyAiZSIKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjE3Ny0xODYKICAgIC8vIHRoaXMuZXNjcm93cyh7IHdhbGxldCwgZXNjcm93IH0pLnZhbHVlID0gewogICAgLy8gICBzb3VyY2UsCiAgICAvLyAgIGFsbG9jYXRhYmxlLAogICAgLy8gICBvcHRpbkFsbG93ZWQsCiAgICAvLyAgIG9wdGluQ291bnQ6IDAsCiAgICAvLyAgIHBoYXNlOiBFc2Nyb3dEaXNidXJzZW1lbnRQaGFzZUlkbGUsCiAgICAvLyAgIGFsbG9jYXRpb25Db3VudGVyOiAwLAogICAgLy8gICBsYXN0RGlzYnVyc2VtZW50OiAwLAogICAgLy8gICBjcmVhdGlvbkRhdGU6IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAsCiAgICAvLyB9CiAgICB1bmNvdmVyIDIKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjE4OQogICAgLy8gdGhpcy52YWxpZGF0ZVNwbGl0cyhzcGxpdHMpCiAgICBzd2FwCiAgICBjYWxsc3ViIHZhbGlkYXRlU3BsaXRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czozNQogICAgLy8gc3BsaXRzID0gQm94TWFwPFdhbGxldEVzY3Jvd0tleSwgU3BsaXRbXT4oeyBrZXlQcmVmaXg6IFJldmVudWVNYW5hZ2VyQm94UHJlZml4U3BsaXRzIH0pCiAgICBwdXNoYnl0ZXMgInMiCiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MTkxCiAgICAvLyB0aGlzLnNwbGl0cyh7IHdhbGxldCwgZXNjcm93IH0pLnZhbHVlID0gY2xvbmUoc3BsaXRzKQogICAgZHVwCiAgICBib3hfZGVsCiAgICBwb3AKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjE5MwogICAgLy8gcmVrZXlCYWNrSWZOZWNlc3NhcnkocmVrZXlCYWNrLCB3YWxsZXQpCiAgICBzd2FwCiAgICBjYWxsc3ViIHJla2V5QmFja0lmTmVjZXNzYXJ5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoxNjMtMTcxCiAgICAvLyBuZXdSZWNlaXZlRXNjcm93KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGVzY3Jvdzogc3RyaW5nLAogICAgLy8gICBzb3VyY2U6IEFjY291bnQsCiAgICAvLyAgIGFsbG9jYXRhYmxlOiBib29sZWFuLAogICAgLy8gICBvcHRpbkFsbG93ZWQ6IGJvb2xlYW4sCiAgICAvLyAgIHNwbGl0czogU3BsaXRbXQogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6OlJldmVudWVNYW5hZ2VyUGx1Z2luLm5ld1JlY2VpdmVFc2Nyb3dXaXRoUmVmW3JvdXRpbmddKCkgLT4gdm9pZDoKbmV3UmVjZWl2ZUVzY3Jvd1dpdGhSZWY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyMDAtMjA4CiAgICAvLyBuZXdSZWNlaXZlRXNjcm93V2l0aFJlZigKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBlc2Nyb3c6IHN0cmluZywKICAgIC8vICAgc291cmNlOiBBY2NvdW50LAogICAgLy8gICBhbGxvY2F0YWJsZTogYm9vbGVhbiwKICAgIC8vICAgb3B0aW5BbGxvd2VkOiBib29sZWFuLAogICAgLy8gICBzcGxpdFJlZjogU3BsaXRSZWYKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1dGY4W10pCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18wIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MjEwCiAgICAvLyBhc3NlcnQodGhpcy5jb250cm9scyhzZW5kZXIpLCBFUlJfRk9SQklEREVOKQogICAgY2FsbHN1YiBjb250cm9scwogICAgYXNzZXJ0IC8vIG9ubHkgdGhlIGNyZWF0b3Igd2FsbGV0IGNhbiBkZWxldGUgYSBzcGVuZGluZyBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyMjAKICAgIC8vIGNyZWF0aW9uRGF0ZTogR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCwKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjIxMi0yMjEKICAgIC8vIHRoaXMuZXNjcm93cyh7IHdhbGxldCwgZXNjcm93IH0pLnZhbHVlID0gewogICAgLy8gICBzb3VyY2UsCiAgICAvLyAgIGFsbG9jYXRhYmxlLAogICAgLy8gICBvcHRpbkFsbG93ZWQsCiAgICAvLyAgIG9wdGluQ291bnQ6IDAsCiAgICAvLyAgIHBoYXNlOiBFc2Nyb3dEaXNidXJzZW1lbnRQaGFzZUlkbGUsCiAgICAvLyAgIGFsbG9jYXRpb25Db3VudGVyOiAwLAogICAgLy8gICBsYXN0RGlzYnVyc2VtZW50OiAwLAogICAgLy8gICBjcmVhdGlvbkRhdGU6IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAsCiAgICAvLyB9CiAgICBieXRlYyA0IC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDUKICAgIHNldGJpdAogICAgaW50Y18xIC8vIDEKICAgIHVuY292ZXIgNAogICAgc2V0Yml0CiAgICB1bmNvdmVyIDMKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MjE2CiAgICAvLyBvcHRpbkNvdW50OiAwLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjIxMi0yMjEKICAgIC8vIHRoaXMuZXNjcm93cyh7IHdhbGxldCwgZXNjcm93IH0pLnZhbHVlID0gewogICAgLy8gICBzb3VyY2UsCiAgICAvLyAgIGFsbG9jYXRhYmxlLAogICAgLy8gICBvcHRpbkFsbG93ZWQsCiAgICAvLyAgIG9wdGluQ291bnQ6IDAsCiAgICAvLyAgIHBoYXNlOiBFc2Nyb3dEaXNidXJzZW1lbnRQaGFzZUlkbGUsCiAgICAvLyAgIGFsbG9jYXRpb25Db3VudGVyOiAwLAogICAgLy8gICBsYXN0RGlzYnVyc2VtZW50OiAwLAogICAgLy8gICBjcmVhdGlvbkRhdGU6IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAsCiAgICAvLyB9CiAgICBpdG9iCiAgICBzd2FwCiAgICBkaWcgMQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyMTcKICAgIC8vIHBoYXNlOiBFc2Nyb3dEaXNidXJzZW1lbnRQaGFzZUlkbGUsCiAgICBieXRlYyA0IC8vIDB4MDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjIxMi0yMjEKICAgIC8vIHRoaXMuZXNjcm93cyh7IHdhbGxldCwgZXNjcm93IH0pLnZhbHVlID0gewogICAgLy8gICBzb3VyY2UsCiAgICAvLyAgIGFsbG9jYXRhYmxlLAogICAgLy8gICBvcHRpbkFsbG93ZWQsCiAgICAvLyAgIG9wdGluQ291bnQ6IDAsCiAgICAvLyAgIHBoYXNlOiBFc2Nyb3dEaXNidXJzZW1lbnRQaGFzZUlkbGUsCiAgICAvLyAgIGFsbG9jYXRpb25Db3VudGVyOiAwLAogICAgLy8gICBsYXN0RGlzYnVyc2VtZW50OiAwLAogICAgLy8gICBjcmVhdGlvbkRhdGU6IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAsCiAgICAvLyB9CiAgICBjb25jYXQKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgc3dhcAogICAgaXRvYgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyMTIKICAgIC8vIHRoaXMuZXNjcm93cyh7IHdhbGxldCwgZXNjcm93IH0pLnZhbHVlID0gewogICAgZGlnIDQKICAgIGl0b2IKICAgIGRpZyAzCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICB1bmNvdmVyIDQKICAgIGNvbmNhdAogICAgc3dhcAogICAgYnl0ZWNfMiAvLyAweDAwMGEKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czozMQogICAgLy8gZXNjcm93cyA9IEJveE1hcDxXYWxsZXRFc2Nyb3dLZXksIFJlY2VpdmVFc2Nyb3c+KHsga2V5UHJlZml4OiBSZXZlbnVlTWFuYWdlckJveFByZWZpeEVzY3Jvd3MgfSkKICAgIGJ5dGVjXzMgLy8gImUiCiAgICBkaWcgMQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyMTItMjIxCiAgICAvLyB0aGlzLmVzY3Jvd3MoeyB3YWxsZXQsIGVzY3JvdyB9KS52YWx1ZSA9IHsKICAgIC8vICAgc291cmNlLAogICAgLy8gICBhbGxvY2F0YWJsZSwKICAgIC8vICAgb3B0aW5BbGxvd2VkLAogICAgLy8gICBvcHRpbkNvdW50OiAwLAogICAgLy8gICBwaGFzZTogRXNjcm93RGlzYnVyc2VtZW50UGhhc2VJZGxlLAogICAgLy8gICBhbGxvY2F0aW9uQ291bnRlcjogMCwKICAgIC8vICAgbGFzdERpc2J1cnNlbWVudDogMCwKICAgIC8vICAgY3JlYXRpb25EYXRlOiBHbG9iYWwubGF0ZXN0VGltZXN0YW1wLAogICAgLy8gfQogICAgdW5jb3ZlciAyCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czozNwogICAgLy8gc3BsaXRSZWZzID0gQm94TWFwPFdhbGxldEVzY3Jvd0tleSwgU3BsaXRSZWY+KHsga2V5UHJlZml4OiBSZXZlbnVlTWFuYWdlckJveFByZWZpeFNwbGl0UmVmcyB9KQogICAgcHVzaGJ5dGVzICJyIgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyMjQKICAgIC8vIHRoaXMuc3BsaXRSZWZzKHsgd2FsbGV0LCBlc2Nyb3cgfSkudmFsdWUgPSBjbG9uZShzcGxpdFJlZikKICAgIGR1cAogICAgYm94X2RlbAogICAgcG9wCiAgICBzd2FwCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyMjYKICAgIC8vIHJla2V5QmFja0lmTmVjZXNzYXJ5KHJla2V5QmFjaywgd2FsbGV0KQogICAgc3dhcAogICAgY2FsbHN1YiByZWtleUJhY2tJZk5lY2Vzc2FyeQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MjAwLTIwOAogICAgLy8gbmV3UmVjZWl2ZUVzY3Jvd1dpdGhSZWYoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgZXNjcm93OiBzdHJpbmcsCiAgICAvLyAgIHNvdXJjZTogQWNjb3VudCwKICAgIC8vICAgYWxsb2NhdGFibGU6IGJvb2xlYW4sCiAgICAvLyAgIG9wdGluQWxsb3dlZDogYm9vbGVhbiwKICAgIC8vICAgc3BsaXRSZWY6IFNwbGl0UmVmCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czo6UmV2ZW51ZU1hbmFnZXJQbHVnaW4uc3RhcnRFc2Nyb3dEaXNidXJzZW1lbnRbcm91dGluZ10oKSAtPiB2b2lkOgpzdGFydEVzY3Jvd0Rpc2J1cnNlbWVudDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjIyOQogICAgLy8gc3RhcnRFc2Nyb3dEaXNidXJzZW1lbnQod2FsbGV0OiBBcHBsaWNhdGlvbiwgcmVrZXlCYWNrOiBib29sZWFuKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MjMwCiAgICAvLyBjb25zdCBlc2Nyb3cgPSBnZXRFc2Nyb3cod2FsbGV0KQogICAgZGlnIDEKICAgIGNhbGxzdWIgZ2V0RXNjcm93CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyMzEKICAgIC8vIGFzc2VydChlc2Nyb3cgIT09ICcnLCBFUlJfRVNDUk9XX0RPRVNfTk9UX0VYSVNUKQogICAgZHVwCiAgICBieXRlY18xIC8vICIiCiAgICAhPQogICAgYXNzZXJ0IC8vIEVzY3JvdyBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MjMyCiAgICAvLyBjb25zdCB7IGlkOiBlc2Nyb3dJRCB9ID0gbXVzdEdldEVzY3Jvd0luZm8od2FsbGV0KQogICAgZGlnIDIKICAgIGNhbGxzdWIgbXVzdEdldEVzY3Jvd0luZm8KICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18wIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MjM0CiAgICAvLyBhc3NlcnQodGhpcy5jb250cm9scyhzZW5kZXIpLCBFUlJfRk9SQklEREVOKQogICAgZHVwCiAgICBjYWxsc3ViIGNvbnRyb2xzCiAgICBhc3NlcnQgLy8gb25seSB0aGUgY3JlYXRvciB3YWxsZXQgY2FuIGRlbGV0ZSBhIHNwZW5kaW5nIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjIzNQogICAgLy8gYXNzZXJ0KHNlbmRlciA9PT0gQXBwbGljYXRpb24oZXNjcm93SUQpLmFkZHJlc3MsIEVSUl9DT05UUk9MTEVEX0FERFJFU1NfTVVTVF9CRV9FU0NST1cpCiAgICBzd2FwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIENvbnRyb2xsZWQgYWRkcmVzcyBtdXN0IGJlIGVzY3JvdwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MjM3CiAgICAvLyBhc3NlcnQodGhpcy5lc2Nyb3dzKHsgd2FsbGV0LCBlc2Nyb3cgfSkuZXhpc3RzLCBFUlJfRVNDUk9XX0RPRVNfTk9UX0VYSVNUKQogICAgZGlnIDIKICAgIGl0b2IKICAgIGRpZyAxCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgYnl0ZWNfMiAvLyAweDAwMGEKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czozMQogICAgLy8gZXNjcm93cyA9IEJveE1hcDxXYWxsZXRFc2Nyb3dLZXksIFJlY2VpdmVFc2Nyb3c+KHsga2V5UHJlZml4OiBSZXZlbnVlTWFuYWdlckJveFByZWZpeEVzY3Jvd3MgfSkKICAgIGJ5dGVjXzMgLy8gImUiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjIzNwogICAgLy8gYXNzZXJ0KHRoaXMuZXNjcm93cyh7IHdhbGxldCwgZXNjcm93IH0pLmV4aXN0cywgRVJSX0VTQ1JPV19ET0VTX05PVF9FWElTVCkKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gRXNjcm93IGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyMzkKICAgIC8vIGNvbnN0IHsgcGhhc2UsIGFsbG9jYXRhYmxlLCBsYXN0RGlzYnVyc2VtZW50LCBjcmVhdGlvbkRhdGUgfSA9IHRoaXMuZXNjcm93cyh7IHdhbGxldCwgZXNjcm93IH0pLnZhbHVlCiAgICBkdXAKICAgIGJveF9nZXQKICAgIHBvcAogICAgZHVwCiAgICBleHRyYWN0IDQxIDEKICAgIGRpZyAxCiAgICBwdXNoaW50IDI1NiAvLyAyNTYKICAgIGdldGJpdAogICAgZGlnIDIKICAgIHB1c2hpbnQgNTAgLy8gNTAKICAgIGV4dHJhY3RfdWludDY0CiAgICB1bmNvdmVyIDMKICAgIHB1c2hpbnQgNTggLy8gNTgKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyNDAKICAgIC8vIGFzc2VydChwaGFzZSA9PT0gRXNjcm93RGlzYnVyc2VtZW50UGhhc2VJZGxlLCBFUlJfRVNDUk9XX05PVF9JRExFKQogICAgdW5jb3ZlciAzCiAgICBieXRlYyA0IC8vIDB4MDAKICAgID09CiAgICBhc3NlcnQgLy8gRXNjcm93IGlzIG5vdCBpbiBpZGxlIHBoYXNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyNDEKICAgIC8vIGFzc2VydChhbGxvY2F0YWJsZSwgRVJSX0VTQ1JPV19OT1RfQUxMT0NBVEFCTEUpCiAgICB1bmNvdmVyIDIKICAgIGFzc2VydCAvLyBFc2Nyb3cgaXMgbm90IGFsbG9jYXRhYmxlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyNDMKICAgIC8vIGNvbnN0IGxhdGVzdFdpbmRvdzogdWludDY0ID0gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCAtICgoR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCAtIGNyZWF0aW9uRGF0ZSkgJSBPTkVfREFZKQogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIC0KICAgIHB1c2hpbnQgODY0MDAgLy8gODY0MDAKICAgICUKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjI0NAogICAgLy8gYXNzZXJ0KGxhdGVzdFdpbmRvdyA+PSBsYXN0RGlzYnVyc2VtZW50LCBFUlJfRVNDUk9XX05PVF9SRUFEWV9GT1JfRElTQlVSU0VNRU5UKQogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgID49CiAgICBhc3NlcnQgLy8gRXNjcm93IGlzIG5vdCByZWFkeSBmb3IgZGlzYnVyc2VtZW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyNDYKICAgIC8vIHRoaXMuZXNjcm93cyh7IHdhbGxldCwgZXNjcm93IH0pLnZhbHVlLnBoYXNlID0gRXNjcm93RGlzYnVyc2VtZW50UGhhc2VBbGxvY2F0aW9uCiAgICBkaWcgMQogICAgcHVzaGludCA0MSAvLyA0MQogICAgYnl0ZWMgNyAvLyAweDE0CiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MjQ3CiAgICAvLyB0aGlzLmVzY3Jvd3MoeyB3YWxsZXQsIGVzY3JvdyB9KS52YWx1ZS5sYXN0RGlzYnVyc2VtZW50ID0gbGF0ZXN0V2luZG93CiAgICBpdG9iCiAgICBwdXNoaW50IDUwIC8vIDUwCiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MjQ5CiAgICAvLyByZWtleUJhY2tJZk5lY2Vzc2FyeShyZWtleUJhY2ssIHdhbGxldCkKICAgIHN3YXAKICAgIGNhbGxzdWIgcmVrZXlCYWNrSWZOZWNlc3NhcnkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjIyOQogICAgLy8gc3RhcnRFc2Nyb3dEaXNidXJzZW1lbnQod2FsbGV0OiBBcHBsaWNhdGlvbiwgcmVrZXlCYWNrOiBib29sZWFuKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6OlJldmVudWVNYW5hZ2VyUGx1Z2luLnByb2Nlc3NFc2Nyb3dBbGxvY2F0aW9uW3JvdXRpbmddKCkgLT4gdm9pZDoKcHJvY2Vzc0VzY3Jvd0FsbG9jYXRpb246CiAgICBpbnRjXzAgLy8gMAogICAgZHVwbiA4CiAgICBieXRlY18xIC8vICIiCiAgICBkdXBuIDEwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyNTIKICAgIC8vIHByb2Nlc3NFc2Nyb3dBbGxvY2F0aW9uKHdhbGxldDogQXBwbGljYXRpb24sIHJla2V5QmFjazogYm9vbGVhbiwgaWRzOiB1aW50NjRbXSk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgc3dhcAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBjb3ZlciAyCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZHVwCiAgICBjb3ZlciAzCiAgICBpbnRjXzIgLy8gOAogICAgKgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIHN3YXAKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1aW50NjRbXSkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjI1MwogICAgLy8gY29uc3QgZXNjcm93ID0gZ2V0RXNjcm93KHdhbGxldCkKICAgIGR1cAogICAgY2FsbHN1YiBnZXRFc2Nyb3cKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjI1NAogICAgLy8gYXNzZXJ0KGVzY3JvdyAhPT0gJycsIEVSUl9FU0NST1dfRE9FU19OT1RfRVhJU1QpCiAgICBkdXAKICAgIGJ5dGVjXzEgLy8gIiIKICAgICE9CiAgICBhc3NlcnQgLy8gRXNjcm93IGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyNTUKICAgIC8vIGNvbnN0IHsgaWQ6IGVzY3Jvd0lEIH0gPSBtdXN0R2V0RXNjcm93SW5mbyh3YWxsZXQpCiAgICBkaWcgMQogICAgY2FsbHN1YiBtdXN0R2V0RXNjcm93SW5mbwogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMCAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIGR1cAogICAgY292ZXIgMgogICAgY292ZXIgNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MjU3CiAgICAvLyBhc3NlcnQoc2VuZGVyID09PSBBcHBsaWNhdGlvbihlc2Nyb3dJRCkuYWRkcmVzcywgRVJSX0NPTlRST0xMRURfQUREUkVTU19NVVNUX0JFX0VTQ1JPVykKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gQ29udHJvbGxlZCBhZGRyZXNzIG11c3QgYmUgZXNjcm93CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyNTkKICAgIC8vIGNvbnN0IHsgcGhhc2UsIG9wdGluQ291bnQsIGFsbG9jYXRpb25Db3VudGVyIH0gPSB0aGlzLmVzY3Jvd3MoeyB3YWxsZXQsIGVzY3JvdyB9KS52YWx1ZQogICAgc3dhcAogICAgaXRvYgogICAgZGlnIDEKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBieXRlY18yIC8vIDB4MDAwYQogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzEKICAgIC8vIGVzY3Jvd3MgPSBCb3hNYXA8V2FsbGV0RXNjcm93S2V5LCBSZWNlaXZlRXNjcm93Pih7IGtleVByZWZpeDogUmV2ZW51ZU1hbmFnZXJCb3hQcmVmaXhFc2Nyb3dzIH0pCiAgICBieXRlY18zIC8vICJlIgogICAgZGlnIDEKICAgIGNvbmNhdAogICAgZHVwCiAgICBjb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyNTkKICAgIC8vIGNvbnN0IHsgcGhhc2UsIG9wdGluQ291bnQsIGFsbG9jYXRpb25Db3VudGVyIH0gPSB0aGlzLmVzY3Jvd3MoeyB3YWxsZXQsIGVzY3JvdyB9KS52YWx1ZQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGR1cAogICAgZXh0cmFjdCA0MSAxCiAgICBkaWcgMQogICAgcHVzaGludCAzMyAvLyAzMwogICAgZXh0cmFjdF91aW50NjQKICAgIHVuY292ZXIgMgogICAgcHVzaGludCA0MiAvLyA0MgogICAgZXh0cmFjdF91aW50NjQKICAgIGNvdmVyIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjI2MAogICAgLy8gYXNzZXJ0KHBoYXNlID09PSBFc2Nyb3dEaXNidXJzZW1lbnRQaGFzZUFsbG9jYXRpb24sIEVSUl9FU0NST1dfTk9UX0lOX0FMTE9DQVRJT05fUEhBU0UpCiAgICBzd2FwCiAgICBieXRlYyA3IC8vIDB4MTQKICAgID09CiAgICBhc3NlcnQgLy8gRXNjcm93IGlzIG5vdCBpbiBhbGxvY2F0aW9uIHBoYXNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyNjEKICAgIC8vIGNvbnN0IHRvdGFsQXNzZXRzVG9Qcm9jZXNzOiB1aW50NjQgPSBvcHRpbkNvdW50ICsgMSAvLyArIDEgdG8gaW5jbHVkZSBhbGdvCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzUKICAgIC8vIHNwbGl0cyA9IEJveE1hcDxXYWxsZXRFc2Nyb3dLZXksIFNwbGl0W10+KHsga2V5UHJlZml4OiBSZXZlbnVlTWFuYWdlckJveFByZWZpeFNwbGl0cyB9KQogICAgcHVzaGJ5dGVzICJzIgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjUxCiAgICAvLyBpZiAodGhpcy5zcGxpdHMoa2V5KS5leGlzdHMpIHsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYnogcHJvY2Vzc0VzY3Jvd0FsbG9jYXRpb25fYWZ0ZXJfaWZfZWxzZUA0MgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6NTIKICAgIC8vIHJldHVybiBjbG9uZSh0aGlzLnNwbGl0cyhrZXkpLnZhbHVlKQogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgYnVyeSAyNAoKcHJvY2Vzc0VzY3Jvd0FsbG9jYXRpb25fYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czo6UmV2ZW51ZU1hbmFnZXJQbHVnaW4ucmVzb2x2ZVNwbGl0c0A0MzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjI2NwogICAgLy8gYXNzZXJ0KHNwbGl0cy5sZW5ndGggPiAwLCBFUlJfU1BMSVRTX0NBTk5PVF9CRV9FTVBUWSkKICAgIGRpZyAyMwogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGR1cAogICAgYXNzZXJ0IC8vIFNwbGl0cyBjYW5ub3QgYmUgZW1wdHkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjI2OAogICAgLy8gYXNzZXJ0KHNwbGl0cy5sZW5ndGggPD0gMTAsIEVSUl9TUExJVFNfQ0FOTk9UX0JFX01PUkVfVEhBTl8xMCkKICAgIHB1c2hpbnQgMTAgLy8gMTAKICAgIDw9CiAgICBhc3NlcnQgLy8gU3BsaXRzIGNhbm5vdCBiZSBtb3JlIHRoYW4gMTAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjI2OQogICAgLy8gdGhpcy52YWxpZGF0ZVNwbGl0cyhzcGxpdHMpCiAgICBjYWxsc3ViIHZhbGlkYXRlU3BsaXRzCiAgICBidXJ5IDI0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyNzIKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDE4Cgpwcm9jZXNzRXNjcm93QWxsb2NhdGlvbl93aGlsZV90b3BAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjI3MgogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkgKz0gMSkgewogICAgZGlnIDE3CiAgICBkaWcgOAogICAgPAogICAgYnogcHJvY2Vzc0VzY3Jvd0FsbG9jYXRpb25fYWZ0ZXJfd2hpbGVAMjgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjI3MwogICAgLy8gY29uc3QgYXNzZXQgPSBpZHNbaV0KICAgIGRpZyA4CiAgICBleHRyYWN0IDIgMAogICAgZGlnIDE4CiAgICBpbnRjXzIgLy8gOAogICAgKgogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgYnVyeSAyMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6Mjc0CiAgICAvLyBhc3NlcnQoIXRoaXMucmVjZWl2ZUFzc2V0cyh7IGVzY3JvdzogZXNjcm93SUQsIGFzc2V0IH0pLmV4aXN0cywgRVJSX0FTU0VUX0FMUkVBRFlfQUxMT0NBVEVEKQogICAgZGlnIDcKICAgIGl0b2IKICAgIGRpZyAxCiAgICBpdG9iCiAgICBkdXAKICAgIGJ1cnkgMzIKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzMKICAgIC8vIHJlY2VpdmVBc3NldHMgPSBCb3hNYXA8RXNjcm93QXNzZXRLZXksIGJ5dGVzPDA+Pih7IGtleVByZWZpeDogUmV2ZW51ZU1hbmFnZXJCb3hQcmVmaXhSZWNlaXZlQXNzZXRzIH0pCiAgICBwdXNoYnl0ZXMgImEiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgYnVyeSAyOQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6Mjc0CiAgICAvLyBhc3NlcnQoIXRoaXMucmVjZWl2ZUFzc2V0cyh7IGVzY3JvdzogZXNjcm93SUQsIGFzc2V0IH0pLmV4aXN0cywgRVJSX0FTU0VUX0FMUkVBRFlfQUxMT0NBVEVEKQogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICAhCiAgICBhc3NlcnQgLy8gQXNzZXQgaXMgYWxyZWFkeSBhbGxvY2F0ZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjI3Ni0yNzgKICAgIC8vIGNvbnN0IGJhbGFuY2U6IHVpbnQ2NCA9IGFzc2V0ID09PSAwCiAgICAvLyAgID8gb3AuYmFsYW5jZShHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcykgLSBHbG9iYWwubWluQmFsYW5jZQogICAgLy8gICA6IEFzc2V0SG9sZGluZy5hc3NldEJhbGFuY2Uoc2VuZGVyLCBhc3NldClbMF0KICAgIGJueiBwcm9jZXNzRXNjcm93QWxsb2NhdGlvbl90ZXJuYXJ5X2ZhbHNlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjI3NwogICAgLy8gPyBvcC5iYWxhbmNlKEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzKSAtIEdsb2JhbC5taW5CYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYmFsYW5jZQogICAgZ2xvYmFsIE1pbkJhbGFuY2UKICAgIC0KCnByb2Nlc3NFc2Nyb3dBbGxvY2F0aW9uX3Rlcm5hcnlfbWVyZ2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjI4MQogICAgLy8gZm9yIChsZXQgajogdWludDY0ID0gMDsgaiA8IHNwbGl0cy5sZW5ndGg7IGorKykgewogICAgaW50Y18wIC8vIDAKICAgIGJ1cnkgMTcKICAgIGJ1cnkgMTQKCnByb2Nlc3NFc2Nyb3dBbGxvY2F0aW9uX3doaWxlX3RvcEA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MjgxCiAgICAvLyBmb3IgKGxldCBqOiB1aW50NjQgPSAwOyBqIDwgc3BsaXRzLmxlbmd0aDsgaisrKSB7CiAgICBkaWcgMjMKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZHVwCiAgICBidXJ5IDIzCiAgICBkaWcgMTYKICAgID4KICAgIGJ6IHByb2Nlc3NFc2Nyb3dBbGxvY2F0aW9uX2FmdGVyX3doaWxlQDI3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyODIKICAgIC8vIGNvbnN0IHsgdHlwZSwgcmVjZWl2ZXIsIHZhbHVlIH0gPSBjbG9uZShzcGxpdHNbal0pCiAgICBkaWcgMjMKICAgIGV4dHJhY3QgMiAwCiAgICBkaWcgMTYKICAgIGR1cAogICAgY292ZXIgMgogICAgaW50Y18zIC8vIDIKICAgICoKICAgIGRpZyAxCiAgICBzd2FwCiAgICBleHRyYWN0X3VpbnQxNgogICAgdW5jb3ZlciAyCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZHVwCiAgICBidXJ5IDE5CiAgICBkaWcgMjQKICAgIGRpZyAxCiAgICAtIC8vIG9uIGVycm9yOiBpbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZGlnIDMKICAgIGxlbgogICAgdW5jb3ZlciAyCiAgICBpbnRjXzMgLy8gMgogICAgKgogICAgZGlnIDQKICAgIHN3YXAKICAgIGV4dHJhY3RfdWludDE2CiAgICB1bmNvdmVyIDIKICAgIHNlbGVjdAogICAgc3Vic3RyaW5nMwogICAgZHVwCiAgICBleHRyYWN0IDIgMQogICAgYnVyeSAyNAogICAgZHVwCiAgICBwdXNoaW50IDMgLy8gMwogICAgZXh0cmFjdF91aW50NjQKICAgIGJ1cnkgMTQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjI4NS0yODgKICAgIC8vIGNvbnN0IHJlY2VpdmVyRXNjcm93SW5mbyA9IGFiaUNhbGw8dHlwZW9mIEFic3RyYWN0ZWRBY2NvdW50LnByb3RvdHlwZS5hcmM1OF9nZXRFc2Nyb3dzPih7CiAgICAvLyAgIGFwcElkOiByZWNlaXZlci53YWxsZXQsCiAgICAvLyAgIGFyZ3M6IFtbcmVjZWl2ZXIuZXNjcm93XV0KICAgIC8vIH0pLnJldHVyblZhbHVlWzBdCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyODYKICAgIC8vIGFwcElkOiByZWNlaXZlci53YWxsZXQsCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZGlnIDEKICAgIGxlbgogICAgc3Vic3RyaW5nMwogICAgZHVwCiAgICBleHRyYWN0IDAgOAogICAgYnVyeSAzMgogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgY292ZXIgMgogICAgYnVyeSAxNwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6Mjg3CiAgICAvLyBhcmdzOiBbW3JlY2VpdmVyLmVzY3Jvd11dCiAgICBkdXAKICAgIGludGNfMiAvLyA4CiAgICBleHRyYWN0X3VpbnQxNgogICAgZGlnIDEKICAgIGxlbgogICAgc3Vic3RyaW5nMwogICAgZHVwCiAgICBidXJ5IDMyCiAgICBleHRyYWN0IDIgMAogICAgZHVwCiAgICBsZW4KICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjIDkgLy8gMHgwMDAxMDAwMgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyODUtMjg4CiAgICAvLyBjb25zdCByZWNlaXZlckVzY3Jvd0luZm8gPSBhYmlDYWxsPHR5cGVvZiBBYnN0cmFjdGVkQWNjb3VudC5wcm90b3R5cGUuYXJjNThfZ2V0RXNjcm93cz4oewogICAgLy8gICBhcHBJZDogcmVjZWl2ZXIud2FsbGV0LAogICAgLy8gICBhcmdzOiBbW3JlY2VpdmVyLmVzY3Jvd11dCiAgICAvLyB9KS5yZXR1cm5WYWx1ZVswXQogICAgYnl0ZWMgMTAgLy8gbWV0aG9kICJhcmM1OF9nZXRFc2Nyb3dzKHN0cmluZ1tdKSh1aW50NjQsYm9vbClbXSIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBkaWcgMQogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjIDExIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgOSAvLyA5CiAgICAqCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgc3dhcAogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuKyh1aW50NjQsYm9vbDEpW10pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyOTAKICAgIC8vIGNvbnN0IHJlY2VpdmVyQWRkcmVzcyA9IEFwcGxpY2F0aW9uKHJlY2VpdmVyRXNjcm93SW5mby5pZCkuYWRkcmVzcwogICAgZXh0cmFjdCA2IDkKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgc3dhcAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBidXJ5IDI3CiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyOTMKICAgIC8vIGlmICghcmVjZWl2ZXJBZGRyZXNzLmlzT3B0ZWRJbihBc3NldChhc3NldCkpKSB7CiAgICBkaWcgMTkKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBibnogcHJvY2Vzc0VzY3Jvd0FsbG9jYXRpb25fYWZ0ZXJfaWZfZWxzZUAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6Mjk0CiAgICAvLyBhcmM1OE9wdEluQW5kU2VuZCh0aGlzLmFraXRhREFPLnZhbHVlLCByZWNlaXZlci53YWxsZXQsIHJlY2VpdmVyLmVzY3JvdywgW2Fzc2V0XSwgWzBdKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWMgNiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6Mjk0CiAgICAvLyBhcmM1OE9wdEluQW5kU2VuZCh0aGlzLmFraXRhREFPLnZhbHVlLCByZWNlaXZlci53YWxsZXQsIHJlY2VpdmVyLmVzY3JvdywgW2Fzc2V0XSwgWzBdKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIHB1c2hieXRlcyAweDAwMDEKICAgIGRpZyAzMAogICAgY29uY2F0CiAgICBkdXAKICAgIGJ1cnkgMzAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzcyCiAgICAvLyBhc3NlcnQoYXNzZXRzLmxlbmd0aCA9PT0gYW1vdW50cy5sZW5ndGgsIEVSUl9BU1NFVFNfQU5EX0FNT1VOVFNfTUlTTUFUQ0gpCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZHVwCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBBc3NldHMgYW5kIGFtb3VudHMgbWlzbWF0Y2gKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NTAKICAgIC8vIGNvbnN0IFtwbHVnaW5BcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzUGx1Z2luQXBwTGlzdCkpCiAgICB1bmNvdmVyIDIKICAgIHB1c2hieXRlcyAicGFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozNzMKICAgIC8vIGNvbnN0IG9wdGluUGx1Z2luID0gZ2V0UGx1Z2luQXBwTGlzdChha2l0YURBTykub3B0aW4KICAgIGR1cAogICAgZXh0cmFjdCAwIDgKICAgIHN3YXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNjEtMTY0CiAgICAvLyBjb25zdCBbY29udHJvbGxlZEFjY291bnRCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0SUQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDE4CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTYzCiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcykKICAgIHB1c2hieXRlcyAiY29udHJvbGxlZF9hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNjEtMTY0CiAgICAvLyBjb25zdCBbY29udHJvbGxlZEFjY291bnRCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0SUQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgZHVwCiAgICBjb3ZlciAzCiAgICBidXJ5IDMyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjM3Ni0zNzkKICAgIC8vIGl0eG5Db21wb3NlLmJlZ2luPHR5cGVvZiBBYnN0cmFjdGVkQWNjb3VudC5wcm90b3R5cGUuYXJjNThfcmVrZXlUb1BsdWdpbj4oewogICAgLy8gICBhcHBJZDogcmVjaXBpZW50V2FsbGV0LmlkLAogICAgLy8gICBhcmdzOiBbb3B0aW5QbHVnaW4sIHRydWUsIGVzY3JvdywgW10sIFtdXQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIHB1c2hieXRlcyAweDU4MmZmMzgyIC8vIG1ldGhvZCAiYXJjNThfcmVrZXlUb1BsdWdpbih1aW50NjQsYm9vbCxzdHJpbmcsdWludDY0W10sKHVpbnQ2NCx1aW50NjQpW10pdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjM3OAogICAgLy8gYXJnczogW29wdGluUGx1Z2luLCB0cnVlLCBlc2Nyb3csIFtdLCBbXV0KICAgIHB1c2hieXRlcyAweDgwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDM0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgYnl0ZWMgMTIgLy8gMHgwMDAwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgYnl0ZWMgMTIgLy8gMHgwMDAwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgc3dhcAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjM3Ni0zNzkKICAgIC8vIGl0eG5Db21wb3NlLmJlZ2luPHR5cGVvZiBBYnN0cmFjdGVkQWNjb3VudC5wcm90b3R5cGUuYXJjNThfcmVrZXlUb1BsdWdpbj4oewogICAgLy8gICBhcHBJZDogcmVjaXBpZW50V2FsbGV0LmlkLAogICAgLy8gICBhcmdzOiBbb3B0aW5QbHVnaW4sIHRydWUsIGVzY3JvdywgW10sIFtdXQogICAgLy8gfSkKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzgxLTM5MgogICAgLy8gaXR4bkNvbXBvc2UubmV4dDx0eXBlb2YgT3B0SW5QbHVnaW4ucHJvdG90eXBlLm9wdEluPih7CiAgICAvLyAgIGFwcElkOiBvcHRpblBsdWdpbiwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIHJlY2lwaWVudFdhbGxldCwKICAgIC8vICAgICB0cnVlLAogICAgLy8gICAgIGFzc2V0cywKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgcmVjZWl2ZXI6IG9yaWdpbiwKICAgIC8vICAgICAgIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlICogYXNzZXRzLmxlbmd0aAogICAgLy8gICAgIH0pCiAgICAvLyAgIF0KICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6Mzg5CiAgICAvLyBhbW91bnQ6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZSAqIGFzc2V0cy5sZW5ndGgKICAgIGdsb2JhbCBBc3NldE9wdEluTWluQmFsYW5jZQogICAgdW5jb3ZlciAzCiAgICAqCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgc3dhcAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozODctMzkwCiAgICAvLyBpdHhuLnBheW1lbnQoewogICAgLy8gICByZWNlaXZlcjogb3JpZ2luLAogICAgLy8gICBhbW91bnQ6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZSAqIGFzc2V0cy5sZW5ndGgKICAgIC8vIH0pCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjM4MS0zOTIKICAgIC8vIGl0eG5Db21wb3NlLm5leHQ8dHlwZW9mIE9wdEluUGx1Z2luLnByb3RvdHlwZS5vcHRJbj4oewogICAgLy8gICBhcHBJZDogb3B0aW5QbHVnaW4sCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICByZWNpcGllbnRXYWxsZXQsCiAgICAvLyAgICAgdHJ1ZSwKICAgIC8vICAgICBhc3NldHMsCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHJlY2VpdmVyOiBvcmlnaW4sCiAgICAvLyAgICAgICBhbW91bnQ6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZSAqIGFzc2V0cy5sZW5ndGgKICAgIC8vICAgICB9KQogICAgLy8gICBdCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICBieXRlYyA4IC8vIG1ldGhvZCAib3B0SW4odWludDY0LGJvb2wsdWludDY0W10scGF5KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDMyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozNzgKICAgIC8vIGFyZ3M6IFtvcHRpblBsdWdpbiwgdHJ1ZSwgZXNjcm93LCBbXSwgW11dCiAgICBwdXNoYnl0ZXMgMHg4MAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzgxLTM5MgogICAgLy8gaXR4bkNvbXBvc2UubmV4dDx0eXBlb2YgT3B0SW5QbHVnaW4ucHJvdG90eXBlLm9wdEluPih7CiAgICAvLyAgIGFwcElkOiBvcHRpblBsdWdpbiwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIHJlY2lwaWVudFdhbGxldCwKICAgIC8vICAgICB0cnVlLAogICAgLy8gICAgIGFzc2V0cywKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgcmVjZWl2ZXI6IG9yaWdpbiwKICAgIC8vICAgICAgIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlICogYXNzZXRzLmxlbmd0aAogICAgLy8gICAgIH0pCiAgICAvLyAgIF0KICAgIC8vIH0pCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjM5NAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGFtb3VudHMubGVuZ3RoOyBpKyspIHsKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDE3Cgpwcm9jZXNzRXNjcm93QWxsb2NhdGlvbl93aGlsZV90b3BAMzQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjM5NAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGFtb3VudHMubGVuZ3RoOyBpKyspIHsKICAgIGRpZyAxNgogICAgaW50Y18xIC8vIDEKICAgIDwKICAgIGJ6IHByb2Nlc3NFc2Nyb3dBbGxvY2F0aW9uX2FmdGVyX3doaWxlQDM4CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjM5NQogICAgLy8gaWYgKGFtb3VudHNbaV0gPiAwKSB7CiAgICBkaWcgMTYKICAgIGludGNfMiAvLyA4CiAgICAqCiAgICBkdXAKICAgIGJ1cnkgMjIKICAgIHB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDAwMDAKICAgIHN3YXAKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGJ1cnkgMTMKICAgIGJ6IHByb2Nlc3NFc2Nyb3dBbGxvY2F0aW9uX2FmdGVyX2lmX2Vsc2VAMzcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6Mzk2LTQwMgogICAgLy8gaXR4bkNvbXBvc2UubmV4dCgKICAgIC8vICAgaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBhc3NldEFtb3VudDogYW1vdW50c1tpXSwKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBvcmlnaW4sCiAgICAvLyAgICAgeGZlckFzc2V0OiBhc3NldHNbaV0KICAgIC8vICAgfSkKICAgIC8vICkKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MDAKICAgIC8vIHhmZXJBc3NldDogYXNzZXRzW2ldCiAgICBkaWcgMjcKICAgIGV4dHJhY3QgMiAwCiAgICBkaWcgMjEKICAgIGV4dHJhY3RfdWludDY0CiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgZGlnIDI1CiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGRpZyAxMQogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozOTctNDAxCiAgICAvLyBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBhc3NldEFtb3VudDogYW1vdW50c1tpXSwKICAgIC8vICAgYXNzZXRSZWNlaXZlcjogb3JpZ2luLAogICAgLy8gICB4ZmVyQXNzZXQ6IGFzc2V0c1tpXQogICAgLy8gfSkKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKCnByb2Nlc3NFc2Nyb3dBbGxvY2F0aW9uX2FmdGVyX2lmX2Vsc2VAMzc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjM5NAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGFtb3VudHMubGVuZ3RoOyBpKyspIHsKICAgIGRpZyAxNgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgMTcKICAgIGIgcHJvY2Vzc0VzY3Jvd0FsbG9jYXRpb25fd2hpbGVfdG9wQDM0Cgpwcm9jZXNzRXNjcm93QWxsb2NhdGlvbl9hZnRlcl93aGlsZUAzODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDA2LTQwOAogICAgLy8gaXR4bkNvbXBvc2UubmV4dDx0eXBlb2YgQWJzdHJhY3RlZEFjY291bnQucHJvdG90eXBlLmFyYzU4X3ZlcmlmeUF1dGhBZGRyZXNzPih7CiAgICAvLyAgIGFwcElkOiByZWNpcGllbnRXYWxsZXQKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIHB1c2hieXRlcyAweDZjYzNmNjA2IC8vIG1ldGhvZCAiYXJjNThfdmVyaWZ5QXV0aEFkZHJlc3MoKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDE0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDEwCiAgICAvLyBpdHhuQ29tcG9zZS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCnByb2Nlc3NFc2Nyb3dBbGxvY2F0aW9uX2FmdGVyX2lmX2Vsc2VAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyOTcKICAgIC8vIGxldCBhbW91bnQ6IHVpbnQ2NCA9IDAKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDIwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyOTkKICAgIC8vIGNhc2UgU3BsaXREaXN0cmlidXRpb25UeXBlRmxhdDoKICAgIGRpZyAyMgogICAgcHVzaGJ5dGVzIDB4MGEKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyOTktMzAxCiAgICAvLyBjYXNlIFNwbGl0RGlzdHJpYnV0aW9uVHlwZUZsYXQ6CiAgICAvLyAgIGFtb3VudCA9IHZhbHVlCiAgICAvLyAgIGJyZWFrCiAgICBieiBwcm9jZXNzRXNjcm93QWxsb2NhdGlvbl9hZnRlcl9pZl9lbHNlQDE0CiAgICBkaWcgMTIKICAgIGJ1cnkgMjAKCnByb2Nlc3NFc2Nyb3dBbGxvY2F0aW9uX2Jsb2NrQDIxOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzEyCiAgICAvLyBhc3NlcnQoYW1vdW50IDw9IHJlbWFpbmluZywgRVJSX09WRVJfQUxMT0NBVElPTikKICAgIGRpZyAxOQogICAgZHVwCiAgICBkaWcgMTUKICAgIGR1cAogICAgY292ZXIgMgogICAgPD0KICAgIGFzc2VydCAvLyBPdmVyIGFsbG9jYXRpb24gb2YgYXNzZXRzIGluIHRoZSBlc2Nyb3cKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjMxMwogICAgLy8gcmVtYWluaW5nIC09IGFtb3VudAogICAgc3dhcAogICAgLQogICAgYnVyeSAxNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzE1CiAgICAvLyBpZiAoYXNzZXQgPT09IDApIHsKICAgIGRpZyAxOAogICAgYm56IHByb2Nlc3NFc2Nyb3dBbGxvY2F0aW9uX2Vsc2VfYm9keUAyNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzE2LTMyMgogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyLAogICAgLy8gICAgIHJlY2VpdmVyOiByZWNlaXZlckFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50CiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgZGlnIDE5CiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgZGlnIDI0CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgNQogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjMxNi0zMjEKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHNlbmRlciwKICAgIC8vICAgICByZWNlaXZlcjogcmVjZWl2ZXJBZGRyZXNzLAogICAgLy8gICAgIGFtb3VudAogICAgLy8gICB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzE2LTMyMgogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyLAogICAgLy8gICAgIHJlY2VpdmVyOiByZWNlaXZlckFkZHJlc3MsCiAgICAvLyAgICAgYW1vdW50CiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIGIgcHJvY2Vzc0VzY3Jvd0FsbG9jYXRpb25fd2hpbGVfdG9wQDcKCnByb2Nlc3NFc2Nyb3dBbGxvY2F0aW9uX2Vsc2VfYm9keUAyNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjMyNC0zMzEKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIHNlbmRlciwKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiByZWNlaXZlckFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGFzc2V0CiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgZGlnIDE4CiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgZGlnIDE5CiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBkaWcgMjQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZGlnIDUKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czozMjQtMzMwCiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBzZW5kZXIsCiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogcmVjZWl2ZXJBZGRyZXNzLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgeGZlckFzc2V0OiBhc3NldAogICAgLy8gICB9KQogICAgcHVzaGludCA0IC8vIDQKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzI0LTMzMQogICAgLy8gaXR4bgogICAgLy8gICAuYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgc2VuZGVyLAogICAgLy8gICAgIGFzc2V0UmVjZWl2ZXI6IHJlY2VpdmVyQWRkcmVzcywKICAgIC8vICAgICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gICAgIHhmZXJBc3NldDogYXNzZXQKICAgIC8vICAgfSkKICAgIC8vICAgLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgYiBwcm9jZXNzRXNjcm93QWxsb2NhdGlvbl93aGlsZV90b3BANwoKcHJvY2Vzc0VzY3Jvd0FsbG9jYXRpb25fYWZ0ZXJfaWZfZWxzZUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjMwMgogICAgLy8gY2FzZSBTcGxpdERpc3RyaWJ1dGlvblR5cGVQZXJjZW50YWdlOgogICAgZGlnIDIyCiAgICBieXRlYyA3IC8vIDB4MTQKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czozMDItMzA1CiAgICAvLyBjYXNlIFNwbGl0RGlzdHJpYnV0aW9uVHlwZVBlcmNlbnRhZ2U6CiAgICAvLyAgIC8vIENhbGN1bGF0ZSBwZXJjZW50YWdlIG9uIHJlbWFpbmluZyBiYWxhbmNlIChhZnRlciBmbGF0IGFtb3VudHMpCiAgICAvLyAgIGFtb3VudCA9IGNhbGNQZXJjZW50KHJlbWFpbmluZywgdmFsdWUpCiAgICAvLyAgIGJyZWFrCiAgICBieiBwcm9jZXNzRXNjcm93QWxsb2NhdGlvbl9hZnRlcl9pZl9lbHNlQDE3CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjEwNAogICAgLy8gYXNzZXJ0KHAgPD0gRElWSVNPUiwgRVJSX0lOVkFMSURfUEVSQ0VOVEFHRSkKICAgIGRpZyAxMgogICAgZHVwCiAgICBpbnRjIDQgLy8gMTAwMDAwCiAgICA8PQogICAgYXNzZXJ0IC8vIEludmFsaWQgcGVyY2VudGFnZQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxMDUKICAgIC8vIHJldHVybiBvcC5kaXZ3KC4uLm9wLm11bHcoYSwgcCksIERJVklTT1IpCiAgICBkaWcgMTQKICAgIG11bHcKICAgIGludGMgNCAvLyAxMDAwMDAKICAgIGRpdncKICAgIGJ1cnkgMjAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjMwNQogICAgLy8gYnJlYWsKICAgIGIgcHJvY2Vzc0VzY3Jvd0FsbG9jYXRpb25fYmxvY2tAMjEKCnByb2Nlc3NFc2Nyb3dBbGxvY2F0aW9uX2FmdGVyX2lmX2Vsc2VAMTc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czozMDYKICAgIC8vIGNhc2UgU3BsaXREaXN0cmlidXRpb25UeXBlUmVtYWluZGVyOgogICAgZGlnIDIyCiAgICBieXRlYyA1IC8vIDB4MWUKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czozMDYtMzA5CiAgICAvLyBjYXNlIFNwbGl0RGlzdHJpYnV0aW9uVHlwZVJlbWFpbmRlcjoKICAgIC8vICAgLy8gUmVtYWluZGVyIGdldHMgd2hhdGV2ZXIgaXMgbGVmdAogICAgLy8gICBhbW91bnQgPSByZW1haW5pbmcKICAgIC8vICAgYnJlYWsKICAgIGJ6IHByb2Nlc3NFc2Nyb3dBbGxvY2F0aW9uX2Jsb2NrQDIxCiAgICBkaWcgMTMKICAgIGJ1cnkgMjAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjMwOQogICAgLy8gYnJlYWsKICAgIGIgcHJvY2Vzc0VzY3Jvd0FsbG9jYXRpb25fYmxvY2tAMjEKCnByb2Nlc3NFc2Nyb3dBbGxvY2F0aW9uX2FmdGVyX3doaWxlQDI3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzM1CiAgICAvLyB0aGlzLnJlY2VpdmVBc3NldHMoeyBlc2Nyb3c6IGVzY3Jvd0lELCBhc3NldCB9KS5jcmVhdGUoKQogICAgZGlnIDI2CiAgICBpbnRjXzAgLy8gMAogICAgYm94X2NyZWF0ZQogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoyNzIKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpICs9IDEpIHsKICAgIGRpZyAxNwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgMTgKICAgIGIgcHJvY2Vzc0VzY3Jvd0FsbG9jYXRpb25fd2hpbGVfdG9wQDIKCnByb2Nlc3NFc2Nyb3dBbGxvY2F0aW9uX3Rlcm5hcnlfZmFsc2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjI3OAogICAgLy8gOiBBc3NldEhvbGRpbmcuYXNzZXRCYWxhbmNlKHNlbmRlciwgYXNzZXQpWzBdCiAgICBkaWcgNQogICAgZGlnIDE5CiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIHBvcAogICAgYiBwcm9jZXNzRXNjcm93QWxsb2NhdGlvbl90ZXJuYXJ5X21lcmdlQDYKCnByb2Nlc3NFc2Nyb3dBbGxvY2F0aW9uX2FmdGVyX3doaWxlQDI4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzM4CiAgICAvLyB0aGlzLmVzY3Jvd3MoeyB3YWxsZXQsIGVzY3JvdyB9KS52YWx1ZS5hbGxvY2F0aW9uQ291bnRlciArPSBpZHMubGVuZ3RoCiAgICBkaWcgMwogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgcHVzaGludCA0MiAvLyA0MgogICAgZXh0cmFjdF91aW50NjQKICAgIGRpZyA5CiAgICBkdXAKICAgIGNvdmVyIDIKICAgICsKICAgIGl0b2IKICAgIHVuY292ZXIgMgogICAgcHVzaGludCA0MiAvLyA0MgogICAgdW5jb3ZlciAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzM5CiAgICAvLyBpZiAoKGFsbG9jYXRpb25Db3VudGVyICsgaWRzLmxlbmd0aCkgPT09IHRvdGFsQXNzZXRzVG9Qcm9jZXNzKSB7CiAgICBkaWcgMwogICAgKwogICAgZGlnIDIKICAgID09CiAgICBieiBwcm9jZXNzRXNjcm93QWxsb2NhdGlvbl9hZnRlcl9pZl9lbHNlQDMwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czozNDAKICAgIC8vIHRoaXMuZXNjcm93cyh7IHdhbGxldCwgZXNjcm93IH0pLnZhbHVlLnBoYXNlID0gRXNjcm93RGlzYnVyc2VtZW50UGhhc2VGaW5hbGl6YXRpb24KICAgIGRpZyAzCiAgICBwdXNoaW50IDQxIC8vIDQxCiAgICBieXRlYyA1IC8vIDB4MWUKICAgIGJveF9yZXBsYWNlCgpwcm9jZXNzRXNjcm93QWxsb2NhdGlvbl9hZnRlcl9pZl9lbHNlQDMwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzQzCiAgICAvLyByZWtleUJhY2tJZk5lY2Vzc2FyeShyZWtleUJhY2ssIHdhbGxldCkKICAgIGRpZyA5CiAgICBkaWcgMTEKICAgIGNhbGxzdWIgcmVrZXlCYWNrSWZOZWNlc3NhcnkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjI1MgogICAgLy8gcHJvY2Vzc0VzY3Jvd0FsbG9jYXRpb24od2FsbGV0OiBBcHBsaWNhdGlvbiwgcmVrZXlCYWNrOiBib29sZWFuLCBpZHM6IHVpbnQ2NFtdKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgpwcm9jZXNzRXNjcm93QWxsb2NhdGlvbl9hZnRlcl9pZl9lbHNlQDQyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzcKICAgIC8vIHNwbGl0UmVmcyA9IEJveE1hcDxXYWxsZXRFc2Nyb3dLZXksIFNwbGl0UmVmPih7IGtleVByZWZpeDogUmV2ZW51ZU1hbmFnZXJCb3hQcmVmaXhTcGxpdFJlZnMgfSkKICAgIHB1c2hieXRlcyAiciIKICAgIGRpZyA1CiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjU2CiAgICAvLyBhc3NlcnQodGhpcy5zcGxpdFJlZnMoa2V5KS5leGlzdHMsIEVSUl9TUExJVFNfT1JfUkVGX1JFUVVJUkVEKQogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBFaXRoZXIgc3BsaXRzIG9yIGEgc3BsaXQgcmVmZXJlbmNlIG11c3QgYmUgcHJvdmlkZWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjU3CiAgICAvLyBjb25zdCB7IGFwcCwga2V5OiByZWZLZXkgfSA9IHRoaXMuc3BsaXRSZWZzKGtleSkudmFsdWUKICAgIGR1cAogICAgYm94X2dldAogICAgcG9wCiAgICBzd2FwCiAgICBpbnRjXzAgLy8gMAogICAgaW50Y18yIC8vIDgKICAgIGJveF9leHRyYWN0CiAgICBidG9pCiAgICBkaWcgMQogICAgaW50Y18yIC8vIDgKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMgogICAgbGVuCiAgICB1bmNvdmVyIDMKICAgIGNvdmVyIDIKICAgIHN1YnN0cmluZzMKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czo2MAogICAgLy8gY29uc3QgW3JlZlNwbGl0c0J5dGVzLCBleGlzdHNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoQXBwbGljYXRpb24oYXBwKSwgQnl0ZXMocmVmS2V5KSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czo2MQogICAgLy8gYXNzZXJ0KGV4aXN0cywgRVJSX1NQTElUX1JFRl9OT1RfRk9VTkQpCiAgICBhc3NlcnQgLy8gUmVmZXJlbmNlZCBzcGxpdHMgbm90IGZvdW5kIGluIHRhcmdldCBjb250cmFjdAogICAgYnVyeSAyNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MjY0CiAgICAvLyBjb25zdCBzcGxpdHMgPSB0aGlzLnJlc29sdmVTcGxpdHMod2FsbGV0LCBlc2Nyb3cpCiAgICBiIHByb2Nlc3NFc2Nyb3dBbGxvY2F0aW9uX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6OlJldmVudWVNYW5hZ2VyUGx1Z2luLnJlc29sdmVTcGxpdHNANDMKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czo6UmV2ZW51ZU1hbmFnZXJQbHVnaW4uZmluYWxpemVFc2Nyb3dEaXNidXJzZW1lbnRbcm91dGluZ10oKSAtPiB2b2lkOgpmaW5hbGl6ZUVzY3Jvd0Rpc2J1cnNlbWVudDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjM1MQogICAgLy8gZmluYWxpemVFc2Nyb3dEaXNidXJzZW1lbnQod2FsbGV0OiBBcHBsaWNhdGlvbiwgcmVrZXlCYWNrOiBib29sZWFuLCBpZHM6IHVpbnQ2NFtdKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGludGNfMiAvLyA4CiAgICAqCiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgc3dhcAogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3VpbnQ2NFtdKQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzUyCiAgICAvLyBjb25zdCBlc2Nyb3cgPSBnZXRFc2Nyb3cod2FsbGV0KQogICAgZHVwCiAgICBjYWxsc3ViIGdldEVzY3JvdwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzUzCiAgICAvLyBhc3NlcnQoZXNjcm93ICE9PSAnJywgRVJSX0VTQ1JPV19ET0VTX05PVF9FWElTVCkKICAgIGR1cAogICAgYnl0ZWNfMSAvLyAiIgogICAgIT0KICAgIGFzc2VydCAvLyBFc2Nyb3cgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjM1NAogICAgLy8gY29uc3QgeyBpZDogZXNjcm93SUQgfSA9IG11c3RHZXRFc2Nyb3dJbmZvKHdhbGxldCkKICAgIGRpZyAxCiAgICBjYWxsc3ViIG11c3RHZXRFc2Nyb3dJbmZvCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18wIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzU2CiAgICAvLyBhc3NlcnQoc2VuZGVyID09PSBBcHBsaWNhdGlvbihlc2Nyb3dJRCkuYWRkcmVzcywgRVJSX0NPTlRST0xMRURfQUREUkVTU19NVVNUX0JFX0VTQ1JPVykKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gQ29udHJvbGxlZCBhZGRyZXNzIG11c3QgYmUgZXNjcm93CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czozNTgKICAgIC8vIGNvbnN0IHsgcGhhc2UsIGFsbG9jYXRpb25Db3VudGVyIH0gPSB0aGlzLmVzY3Jvd3MoeyB3YWxsZXQsIGVzY3JvdyB9KS52YWx1ZQogICAgc3dhcAogICAgaXRvYgogICAgZGlnIDEKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBieXRlY18yIC8vIDB4MDAwYQogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjMxCiAgICAvLyBlc2Nyb3dzID0gQm94TWFwPFdhbGxldEVzY3Jvd0tleSwgUmVjZWl2ZUVzY3Jvdz4oeyBrZXlQcmVmaXg6IFJldmVudWVNYW5hZ2VyQm94UHJlZml4RXNjcm93cyB9KQogICAgYnl0ZWNfMyAvLyAiZSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czozNTgKICAgIC8vIGNvbnN0IHsgcGhhc2UsIGFsbG9jYXRpb25Db3VudGVyIH0gPSB0aGlzLmVzY3Jvd3MoeyB3YWxsZXQsIGVzY3JvdyB9KS52YWx1ZQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGR1cAogICAgZXh0cmFjdCA0MSAxCiAgICBzd2FwCiAgICBwdXNoaW50IDQyIC8vIDQyCiAgICBleHRyYWN0X3VpbnQ2NAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzU5CiAgICAvLyBhc3NlcnQocGhhc2UgPT09IEVzY3Jvd0Rpc2J1cnNlbWVudFBoYXNlRmluYWxpemF0aW9uLCBFUlJfRVNDUk9XX05PVF9JTl9GSU5BTElaQVRJT05fUEhBU0UpCiAgICBieXRlYyA1IC8vIDB4MWUKICAgID09CiAgICBhc3NlcnQgLy8gRXNjcm93IGlzIG5vdCBpbiBmaW5hbGl6YXRpb24gcGhhc2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjM2MgogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykgewogICAgaW50Y18wIC8vIDAKCmZpbmFsaXplRXNjcm93RGlzYnVyc2VtZW50X3doaWxlX3RvcEAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzYyCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7CiAgICBkdXAKICAgIGRpZyA1CiAgICA8CiAgICBieiBmaW5hbGl6ZUVzY3Jvd0Rpc2J1cnNlbWVudF9hZnRlcl93aGlsZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czozNjMKICAgIC8vIGNvbnN0IGFzc2V0ID0gaWRzW2ldCiAgICBkaWcgNQogICAgZXh0cmFjdCAyIDAKICAgIGRpZyAxCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGludGNfMiAvLyA4CiAgICAqCiAgICBpbnRjXzIgLy8gOAogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IGluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czozNjQKICAgIC8vIGFzc2VydCh0aGlzLnJlY2VpdmVBc3NldHMoeyBlc2Nyb3c6IGVzY3Jvd0lELCBhc3NldCB9KS5leGlzdHMsIEVSUl9BU1NFVF9OT1RfQUxMT0NBVEVEKQogICAgZGlnIDUKICAgIGl0b2IKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzMKICAgIC8vIHJlY2VpdmVBc3NldHMgPSBCb3hNYXA8RXNjcm93QXNzZXRLZXksIGJ5dGVzPDA+Pih7IGtleVByZWZpeDogUmV2ZW51ZU1hbmFnZXJCb3hQcmVmaXhSZWNlaXZlQXNzZXRzIH0pCiAgICBwdXNoYnl0ZXMgImEiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjM2NAogICAgLy8gYXNzZXJ0KHRoaXMucmVjZWl2ZUFzc2V0cyh7IGVzY3JvdzogZXNjcm93SUQsIGFzc2V0IH0pLmV4aXN0cywgRVJSX0FTU0VUX05PVF9BTExPQ0FURUQpCiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIEFzc2V0IHdhcyBub3QgYWxsb2NhdGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czozNjUKICAgIC8vIHRoaXMucmVjZWl2ZUFzc2V0cyh7IGVzY3JvdzogZXNjcm93SUQsIGFzc2V0IH0pLmRlbGV0ZSgpCiAgICBib3hfZGVsCiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjM2MgogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykgewogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgMQogICAgYiBmaW5hbGl6ZUVzY3Jvd0Rpc2J1cnNlbWVudF93aGlsZV90b3BAMgoKZmluYWxpemVFc2Nyb3dEaXNidXJzZW1lbnRfYWZ0ZXJfd2hpbGVANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjM2OQogICAgLy8gdGhpcy5lc2Nyb3dzKHsgd2FsbGV0LCBlc2Nyb3cgfSkudmFsdWUuYWxsb2NhdGlvbkNvdW50ZXIgLT0gaWRzLmxlbmd0aAogICAgZGlnIDIKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIHB1c2hpbnQgNDIgLy8gNDIKICAgIGV4dHJhY3RfdWludDY0CiAgICBkaWcgNgogICAgZHVwCiAgICBjb3ZlciAyCiAgICAtCiAgICBpdG9iCiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgNDIgLy8gNDIKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjM3MgogICAgLy8gaWYgKChhbGxvY2F0aW9uQ291bnRlciAtIGlkcy5sZW5ndGgpID09PSAwKSB7CiAgICBkaWcgMgogICAgc3dhcAogICAgLQogICAgYm56IGZpbmFsaXplRXNjcm93RGlzYnVyc2VtZW50X2FmdGVyX2lmX2Vsc2VANgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MzczCiAgICAvLyB0aGlzLmVzY3Jvd3MoeyB3YWxsZXQsIGVzY3JvdyB9KS52YWx1ZS5waGFzZSA9IEVzY3Jvd0Rpc2J1cnNlbWVudFBoYXNlSWRsZQogICAgZGlnIDIKICAgIHB1c2hpbnQgNDEgLy8gNDEKICAgIGJ5dGVjIDQgLy8gMHgwMAogICAgYm94X3JlcGxhY2UKCmZpbmFsaXplRXNjcm93RGlzYnVyc2VtZW50X2FmdGVyX2lmX2Vsc2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjM3NgogICAgLy8gcmVrZXlCYWNrSWZOZWNlc3NhcnkocmVrZXlCYWNrLCB3YWxsZXQpCiAgICBkaWcgNgogICAgZGlnIDgKICAgIGNhbGxzdWIgcmVrZXlCYWNrSWZOZWNlc3NhcnkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjM1MQogICAgLy8gZmluYWxpemVFc2Nyb3dEaXNidXJzZW1lbnQod2FsbGV0OiBBcHBsaWNhdGlvbiwgcmVrZXlCYWNrOiBib29sZWFuLCBpZHM6IHVpbnQ2NFtdKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6OkFraXRhQmFzZUNvbnRyYWN0LnVwZGF0ZUFraXRhREFPW3JvdXRpbmddKCkgLT4gdm9pZDoKdXBkYXRlQWtpdGFEQU86CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozOAogICAgLy8gdXBkYXRlQWtpdGFEQU8oYWtpdGFEQU86IEFwcGxpY2F0aW9uKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzkKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSB0aGlzLmdldEFraXRhREFPV2FsbGV0KCkuYWRkcmVzcywgRVJSX05PVF9BS0lUQV9EQU8pCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozMgogICAgLy8gY29uc3QgW3dhbGxldElEXSA9IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NCh0aGlzLmFraXRhREFPLnZhbHVlLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1dhbGxldCkpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlYyA2IC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozMgogICAgLy8gY29uc3QgW3dhbGxldElEXSA9IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NCh0aGlzLmFraXRhREFPLnZhbHVlLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1dhbGxldCkpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgcHVzaGJ5dGVzICJ3YWxsZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozOQogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gT25seSB0aGUgQWtpdGEgREFPIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWMgNiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NDAKICAgIC8vIHRoaXMuYWtpdGFEQU8udmFsdWUgPSBha2l0YURBTwogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjM4CiAgICAvLyB1cGRhdGVBa2l0YURBTyhha2l0YURBTzogQXBwbGljYXRpb24pOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czo6UmV2ZW51ZU1hbmFnZXJQbHVnaW4uY29udHJvbHMoc2VuZGVyOiBieXRlcykgLT4gdWludDY0Ogpjb250cm9sczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjM5CiAgICAvLyBwcml2YXRlIGNvbnRyb2xzKHNlbmRlcjogQWNjb3VudCk6IGJvb2xlYW4gewogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czo0MAogICAgLy8gcmV0dXJuIHNlbmRlci5hdXRoQWRkcmVzcyA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGZyYW1lX2RpZyAtMQogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RBdXRoQWRkcgogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjpSZXZlbnVlTWFuYWdlclBsdWdpbi52YWxpZGF0ZVNwbGl0cyhzcGxpdHM6IGJ5dGVzKSAtPiBieXRlczoKdmFsaWRhdGVTcGxpdHM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czo2OAogICAgLy8gcHJpdmF0ZSB2YWxpZGF0ZVNwbGl0cyhzcGxpdHM6IFNwbGl0W10pOiB2b2lkIHsKICAgIHByb3RvIDEgMQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gIiIKICAgIGR1cG4gMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6NjkKICAgIC8vIGxldCB0b3RhbFBlcmNlbnRhZ2U6IHVpbnQ2NCA9IDAKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czo3MC03MQogICAgLy8gbGV0IGhhc1JlbWFpbmRlcjogYm9vbGVhbiA9IGZhbHNlCiAgICAvLyBsZXQgaGFzRmxhdDogYm9vbGVhbiA9IGZhbHNlCiAgICBkdXBuIDMKCnZhbGlkYXRlU3BsaXRzX3doaWxlX3RvcEAxOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6NzMKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBzcGxpdHMubGVuZ3RoOyBpKyspIHsKICAgIGZyYW1lX2RpZyAtMQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMQogICAgZnJhbWVfZGlnIDgKICAgID4KICAgIGJ6IHZhbGlkYXRlU3BsaXRzX2FmdGVyX3doaWxlQDE3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czo3NAogICAgLy8gY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gY2xvbmUoc3BsaXRzW2ldKQogICAgZnJhbWVfZGlnIC0xCiAgICBleHRyYWN0IDIgMAogICAgZnJhbWVfZGlnIDgKICAgIGR1cAogICAgY292ZXIgMgogICAgaW50Y18zIC8vIDIKICAgICoKICAgIGRpZyAxCiAgICBzd2FwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZGlnIDIKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMgogICAgZnJhbWVfZGlnIDEKICAgIGR1cAogICAgY292ZXIgNAogICAgZGlnIDEKICAgIC0gLy8gb24gZXJyb3I6IGluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBkaWcgMwogICAgbGVuCiAgICB1bmNvdmVyIDIKICAgIGludGNfMyAvLyAyCiAgICAqCiAgICBkaWcgNAogICAgc3dhcAogICAgZXh0cmFjdF91aW50MTYKICAgIHVuY292ZXIgMgogICAgc2VsZWN0CiAgICBzdWJzdHJpbmczCiAgICBkdXAKICAgIGV4dHJhY3QgMiAxCiAgICBmcmFtZV9idXJ5IDAKICAgIHB1c2hpbnQgMyAvLyAzCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBmcmFtZV9idXJ5IDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjc1CiAgICAvLyBjb25zdCBpc0xhc3QgPSBpID09PSBzcGxpdHMubGVuZ3RoIC0gMQogICAgc3dhcAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIHVuY292ZXIgMgogICAgPT0KICAgIGZyYW1lX2J1cnkgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6NzkKICAgIC8vIHZhbHVlID4gMCB8fCB0eXBlID09PSBTcGxpdERpc3RyaWJ1dGlvblR5cGVSZW1haW5kZXIsCiAgICBibnogdmFsaWRhdGVTcGxpdHNfYm9vbF90cnVlQDQKICAgIGZyYW1lX2RpZyAwCiAgICBieXRlYyA1IC8vIDB4MWUKICAgID09CiAgICBieiB2YWxpZGF0ZVNwbGl0c19ib29sX2ZhbHNlQDUKCnZhbGlkYXRlU3BsaXRzX2Jvb2xfdHJ1ZUA0OgogICAgaW50Y18xIC8vIDEKCnZhbGlkYXRlU3BsaXRzX2Jvb2xfbWVyZ2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjc4LTgxCiAgICAvLyBhc3NlcnQoCiAgICAvLyAgIHZhbHVlID4gMCB8fCB0eXBlID09PSBTcGxpdERpc3RyaWJ1dGlvblR5cGVSZW1haW5kZXIsCiAgICAvLyAgIEVSUl9TUExJVF9WQUxVRV9NVVNUX0JFX1BPU0lUSVZFX09SX1JFTUFJTkRFUgogICAgLy8gKQogICAgYXNzZXJ0IC8vIFNwbGl0IHZhbHVlIG11c3QgYmUgcG9zaXRpdmUgb3IgcmVtYWluZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czo4NAogICAgLy8gY2FzZSBTcGxpdERpc3RyaWJ1dGlvblR5cGVQZXJjZW50YWdlOgogICAgZnJhbWVfZGlnIDAKICAgIGJ5dGVjIDcgLy8gMHgxNAogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjg0LTg2CiAgICAvLyBjYXNlIFNwbGl0RGlzdHJpYnV0aW9uVHlwZVBlcmNlbnRhZ2U6CiAgICAvLyAgIHRvdGFsUGVyY2VudGFnZSArPSB2YWx1ZQogICAgLy8gICBicmVhawogICAgYnogdmFsaWRhdGVTcGxpdHNfYWZ0ZXJfaWZfZWxzZUA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czo4NQogICAgLy8gdG90YWxQZXJjZW50YWdlICs9IHZhbHVlCiAgICBmcmFtZV9kaWcgNQogICAgZnJhbWVfZGlnIDQKICAgICsKICAgIGZyYW1lX2J1cnkgNQoKdmFsaWRhdGVTcGxpdHNfYmxvY2tAMTY6CiAgICBmcmFtZV9kaWcgMgogICAgZnJhbWVfYnVyeSA4CiAgICBiIHZhbGlkYXRlU3BsaXRzX3doaWxlX3RvcEAxCgp2YWxpZGF0ZVNwbGl0c19hZnRlcl9pZl9lbHNlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czo4NwogICAgLy8gY2FzZSBTcGxpdERpc3RyaWJ1dGlvblR5cGVGbGF0OgogICAgZnJhbWVfZGlnIDAKICAgIHB1c2hieXRlcyAweDBhCiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6ODctODkKICAgIC8vIGNhc2UgU3BsaXREaXN0cmlidXRpb25UeXBlRmxhdDoKICAgIC8vICAgaGFzRmxhdCA9IHRydWUKICAgIC8vICAgYnJlYWsKICAgIGJ6IHZhbGlkYXRlU3BsaXRzX2FmdGVyX2lmX2Vsc2VAMTIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjg4CiAgICAvLyBoYXNGbGF0ID0gdHJ1ZQogICAgaW50Y18xIC8vIDEKICAgIGZyYW1lX2J1cnkgNwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6ODkKICAgIC8vIGJyZWFrCiAgICBiIHZhbGlkYXRlU3BsaXRzX2Jsb2NrQDE2Cgp2YWxpZGF0ZVNwbGl0c19hZnRlcl9pZl9lbHNlQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6OTAKICAgIC8vIGNhc2UgU3BsaXREaXN0cmlidXRpb25UeXBlUmVtYWluZGVyOgogICAgZnJhbWVfZGlnIDAKICAgIGJ5dGVjIDUgLy8gMHgxZQogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjkwLTk0CiAgICAvLyBjYXNlIFNwbGl0RGlzdHJpYnV0aW9uVHlwZVJlbWFpbmRlcjoKICAgIC8vICAgLy8gUmVtYWluZGVyIG11c3QgYmUgbGFzdAogICAgLy8gICBhc3NlcnQoaXNMYXN0LCBFUlJfUkVNQUlOREVSX01VU1RfQkVfTEFTVCkKICAgIC8vICAgaGFzUmVtYWluZGVyID0gdHJ1ZQogICAgLy8gICBicmVhawogICAgYnogdmFsaWRhdGVTcGxpdHNfYmxvY2tAMTYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjkyCiAgICAvLyBhc3NlcnQoaXNMYXN0LCBFUlJfUkVNQUlOREVSX01VU1RfQkVfTEFTVCkKICAgIGZyYW1lX2RpZyAzCiAgICBhc3NlcnQgLy8gUmVtYWluZGVyIHNwbGl0IG11c3QgYmUgdGhlIGxhc3Qgc3BsaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjkzCiAgICAvLyBoYXNSZW1haW5kZXIgPSB0cnVlCiAgICBpbnRjXzEgLy8gMQogICAgZnJhbWVfYnVyeSA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czo5NAogICAgLy8gYnJlYWsKICAgIGIgdmFsaWRhdGVTcGxpdHNfYmxvY2tAMTYKCnZhbGlkYXRlU3BsaXRzX2Jvb2xfZmFsc2VANToKICAgIGludGNfMCAvLyAwCiAgICBiIHZhbGlkYXRlU3BsaXRzX2Jvb2xfbWVyZ2VANgoKdmFsaWRhdGVTcGxpdHNfYWZ0ZXJfd2hpbGVAMTc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czo5OQogICAgLy8gYXNzZXJ0KHRvdGFsUGVyY2VudGFnZSA8PSBESVZJU09SLCBFUlJfUEVSQ0VOVEFHRV9FWENFRURTXzEwMCkKICAgIGZyYW1lX2RpZyA1CiAgICBkdXAKICAgIGludGMgNCAvLyAxMDAwMDAKICAgIDw9CiAgICBhc3NlcnQgLy8gVG90YWwgcGVyY2VudGFnZSBzcGxpdHMgZXhjZWVkIDEwMCUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjEwMQogICAgLy8gYXNzZXJ0KHRvdGFsUGVyY2VudGFnZSAhPT0gRElWSVNPUiB8fCAhaGFzUmVtYWluZGVyLCBFUlJfUEVSQ0VOVEFHRV9NVVNUX0JFX05PVF9CRV8xMDBfV0lUSF9SRU1BSU5ERVIpCiAgICBpbnRjIDQgLy8gMTAwMDAwCiAgICAhPQogICAgYm56IHZhbGlkYXRlU3BsaXRzX2Jvb2xfdHJ1ZUAxOQogICAgZnJhbWVfZGlnIDYKICAgIGJueiB2YWxpZGF0ZVNwbGl0c19ib29sX2ZhbHNlQDIwCgp2YWxpZGF0ZVNwbGl0c19ib29sX3RydWVAMTk6CiAgICBpbnRjXzEgLy8gMQoKdmFsaWRhdGVTcGxpdHNfYm9vbF9tZXJnZUAyMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjEwMQogICAgLy8gYXNzZXJ0KHRvdGFsUGVyY2VudGFnZSAhPT0gRElWSVNPUiB8fCAhaGFzUmVtYWluZGVyLCBFUlJfUEVSQ0VOVEFHRV9NVVNUX0JFX05PVF9CRV8xMDBfV0lUSF9SRU1BSU5ERVIpCiAgICBhc3NlcnQgLy8gUGVyY2VudGFnZSBzcGxpdHMgY2Fubm90IHRvdGFsIDEwMCUgd2hlbiB1c2luZyBhIHJlbWFpbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MTAzCiAgICAvLyBhc3NlcnQoIWhhc0ZsYXQgfHwgaGFzUmVtYWluZGVyIHx8IHRvdGFsUGVyY2VudGFnZSA9PT0gMCB8fCB0b3RhbFBlcmNlbnRhZ2UgPT09IERJVklTT1IsIEVSUl9GTEFUX1dJVEhfUEVSQ0VOVEFHRV9SRVFVSVJFU19SRU1BSU5ERVIpCiAgICBmcmFtZV9kaWcgNwogICAgYnogdmFsaWRhdGVTcGxpdHNfYm9vbF90cnVlQDI1CiAgICBmcmFtZV9kaWcgNgogICAgYm56IHZhbGlkYXRlU3BsaXRzX2Jvb2xfdHJ1ZUAyNQogICAgZnJhbWVfZGlnIDUKICAgIGJ6IHZhbGlkYXRlU3BsaXRzX2Jvb2xfdHJ1ZUAyNQogICAgZnJhbWVfZGlnIDUKICAgIGludGMgNCAvLyAxMDAwMDAKICAgID09CiAgICBieiB2YWxpZGF0ZVNwbGl0c19ib29sX2ZhbHNlQDI2Cgp2YWxpZGF0ZVNwbGl0c19ib29sX3RydWVAMjU6CiAgICBpbnRjXzEgLy8gMQoKdmFsaWRhdGVTcGxpdHNfYm9vbF9tZXJnZUAyNzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JldmVudWUtbWFuYWdlci9jb250cmFjdC5hbGdvLnRzOjEwMwogICAgLy8gYXNzZXJ0KCFoYXNGbGF0IHx8IGhhc1JlbWFpbmRlciB8fCB0b3RhbFBlcmNlbnRhZ2UgPT09IDAgfHwgdG90YWxQZXJjZW50YWdlID09PSBESVZJU09SLCBFUlJfRkxBVF9XSVRIX1BFUkNFTlRBR0VfUkVRVUlSRVNfUkVNQUlOREVSKQogICAgYXNzZXJ0IC8vIEZsYXQgYW1vdW50cyB3aXRoIHBlcmNlbnRhZ2VzIHJlcXVpcmUgYSByZW1haW5kZXIgb3IgMTAwJSB0b3RhbAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV2ZW51ZS1tYW5hZ2VyL2NvbnRyYWN0LmFsZ28udHM6MTA1CiAgICAvLyBhc3NlcnQoaGFzUmVtYWluZGVyIHx8IHRvdGFsUGVyY2VudGFnZSA9PT0gRElWSVNPUiB8fCAodG90YWxQZXJjZW50YWdlID09PSAwICYmIGhhc0ZsYXQpLCBFUlJfU1BMSVRTX01VU1RfVE9UQUxfMTAwX09SX0hBVkVfUkVNQUlOREVSKQogICAgZnJhbWVfZGlnIDYKICAgIGJueiB2YWxpZGF0ZVNwbGl0c19ib29sX3RydWVAMzEKICAgIGZyYW1lX2RpZyA1CiAgICBpbnRjIDQgLy8gMTAwMDAwCiAgICA9PQogICAgYm56IHZhbGlkYXRlU3BsaXRzX2Jvb2xfdHJ1ZUAzMQogICAgZnJhbWVfZGlnIDUKICAgIGJueiB2YWxpZGF0ZVNwbGl0c19ib29sX2ZhbHNlQDMyCiAgICBmcmFtZV9kaWcgNwogICAgYnogdmFsaWRhdGVTcGxpdHNfYm9vbF9mYWxzZUAzMgoKdmFsaWRhdGVTcGxpdHNfYm9vbF90cnVlQDMxOgogICAgaW50Y18xIC8vIDEKCnZhbGlkYXRlU3BsaXRzX2Jvb2xfbWVyZ2VAMzM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXZlbnVlLW1hbmFnZXIvY29udHJhY3QuYWxnby50czoxMDUKICAgIC8vIGFzc2VydChoYXNSZW1haW5kZXIgfHwgdG90YWxQZXJjZW50YWdlID09PSBESVZJU09SIHx8ICh0b3RhbFBlcmNlbnRhZ2UgPT09IDAgJiYgaGFzRmxhdCksIEVSUl9TUExJVFNfTVVTVF9UT1RBTF8xMDBfT1JfSEFWRV9SRU1BSU5ERVIpCiAgICBhc3NlcnQgLy8gUGVyY2VudGFnZSBzcGxpdHMgbXVzdCB0b3RhbCAxMDAlIG9yIGluY2x1ZGUgYSByZW1haW5kZXIKICAgIGZyYW1lX2RpZyAtMQogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCnZhbGlkYXRlU3BsaXRzX2Jvb2xfZmFsc2VAMzI6CiAgICBpbnRjXzAgLy8gMAogICAgYiB2YWxpZGF0ZVNwbGl0c19ib29sX21lcmdlQDMzCgp2YWxpZGF0ZVNwbGl0c19ib29sX2ZhbHNlQDI2OgogICAgaW50Y18wIC8vIDAKICAgIGIgdmFsaWRhdGVTcGxpdHNfYm9vbF9tZXJnZUAyNwoKdmFsaWRhdGVTcGxpdHNfYm9vbF9mYWxzZUAyMDoKICAgIGludGNfMCAvLyAwCiAgICBiIHZhbGlkYXRlU3BsaXRzX2Jvb2xfbWVyZ2VAMjEK", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyAFAAEIAqCNBiYNEHNwZW5kaW5nX2FkZHJlc3MAAgAKAWUBAAEeCWFraXRhX2RhbwEUBGg147wEAAEAAgSiQD3fBBUffHUCAAAxGRREMRhBAD8nCIIHBOyNQ+UELYDm/ASE80wEBP5BD0QEfnwPcAQz6SyUBIVN7eA2GgCOCADhAgICpgM8A8wHRAgJAAEAI0OABM2a1n42GgCOAQCmAIoBAYv/gA5jdXJyZW50X3BsdWdpbmVISYEoWUsBFVJXAgCJigEBi/+I/9WxSRUWVwYCTFAnCUxQJwqyGrIai/+yGIEGshAisgGztD5JVwQASwFXAAQnCxJESSJZgQkLJQhMFRJEVwYJSSJbRImKAgCL/kEAHov/KGVIsYv+i/+IABKyICKyCEmyB7IAI7IQIrIBs4mKAgGL/kAAAzIDiYv/cghEiTYaAUkiWSUISwEVEkRXAgA2GgJJFSQSRBeAB3ZlcnNpb25PAmcnBkxnI0MpSTYaAUkVJBJEF0k2GgJJFSMSRCJTTDYaA0lOAkkiWUlOA0kkCyUITwIVEkQxFiMJSTgQIxJESwKI/vRJKRNESwMoZUhJTgVLAjgHEk8COAgyEE8ECw8QREsBFksBFRZXBgJPAlBMKlBMUCtMUElOAkm9RQFEvkhJVwAgTgKBgQJTTIALcmVrZXlfaW5kZXhlSDgAMg1BAIQyDXIHREsDEkEAeSNLA0sCEhFESwFEIkULSwpLBgxBAFFLBlcCAEsLJAtbSUULSwVMcABFARREsUsHQQAxSwUjCUsLEkEAJyNLCYj+3rIgSwmyESKyEksESbIUsgCBBLIQIrIBs0sKIwhFC0L/qyJC/9ZLA0m+RIEhW0sHCBaBIUy7I0MiQv+ENhoBSRUkEkQXNhoCSRUjEkQiUzYaA0kiWSUISwEVEkRXAgA2GgRJFYEgEkQ2GgVJFSMSRCJTNhoGSRUjEkQiUzYaB0sGKGVIiAXhREkiWUlEgQoORDIHJwQiTwVUI08EVE8DTFAiFkxLAVAnBFBLAVBMUEwWUEsEFksDFRZXBgJPBFBMKlBMUCtLAVBPAr9MiAWlgAFzTwJQSbxITL9MiP3aI0M2GgFJFSQSRBc2GgJJFSMSRCJTNhoDSSJZJQhLARUSRFcCADYaBEkVgSASRDYaBUkVIxJEIlM2GgZJFSMSRCJTNhoHSwYoZUiIBT1EMgcnBCJPBVQjTwRUTwNMUCIWTEsBUCcEUEsBUExQTBZQSwQWSwMVFlcGAk8EUEwqUExQK0sBUE8Cv4ABckxQSbxITL9MiP1EI0M2GgFJFSQSRBc2GgJJFSMSRCJTSwGI/L1JKRNESwKI/NciW0sDKGVISYgExkRMcghEEkRLAhZLARUWVwYCTwJQTCpQTFArTFBJvUUBREm+SElXKQFLAYGAAlNLAoEyW08DgTpbTwMnBBJETwJEMgdJTwIJgYCjBRgJSU8CD0RLAYEpJwe7FoEyTLtMiPy0I0MiRwgpRwo2GgFJFSQSRBdJNhoCSRUjEkQiU0w2GgNJTgJJIllJTgMkCyUITBUSREmI/BJJKRNESwGI/CwiW0lOA0sCKGVISU4CTgRyCEQSREwWSwEVFlcGAk8CUEwqUExQSStLAVBJTgK+RElXKQFLAYEhW08CgSpbTgNMJwcSRCMITIABc0xQSb1FAUECwEm+REUYSxdJIllJRIEKDkSIA8xFGCJFEksRSwgMQQJxSwhXAgBLEiQLW0lFFEsHFksBFklFIFCAAWFMUElFHb1FARREQAJAMgpgMgEJIkURRQ5LFyJZSUUXSxANQQIaSxdXAgBLEElOAiULSwFMWU8CIwhJRRNLGEsBCUsDFU8CJQtLBExZTwJNUklXAgFFGEmBA1tFDrFJIllLARVSSVcACEUgSSJbSU4CRRFJJFlLARVSSUUgVwIASRUWVwYCTFAnCUxQJwqyGrIashiBBrIQIrIBs7Q+SVcEAEsBVwAEJwsSREkiWYEJCyUITBUSRFcGCSJbcghMSU4CRRtESxNwAEUBQADzIicGZUSAAgABSx5QSUUeSSJZSSMSRE8CgANwYWxlSElXAAhMIltLEklOAoASY29udHJvbGxlZF9hZGRyZXNzZUhJTgNFILGABFgv84KyGk8DshqAAYCyGksishonDLIaJwyyGkyyGIEGshAisgG2MhBPAwuyCEyyByOyECKyAbYnCLIaSyCyGoABgLIashiyGoEGshAisgEiRRFLECMMQQA8SxAkC0lFFoAIAAAAAAAAAABMW0lFDUEAGrZLG1cCAEsVW7IRSxmyFEsLshKBBLIQIrIBSxAjCEURQv+9toAEbMP2BrIaSw6yGIEGshAisgGzIkUUSxaAAQoSQQBKSwxFFEsTSUsPSU4CDkRMCUUOSxJAABexSxOyCEsYsgdLBbIAI7IQIrIBs0L+HrFLErIRSxOyEksYshRLBbIAgQSyECKyAbNC/gJLFicHEkEAEksMSSEEDkRLDh0hBJdFFEL/oEsWJwUSQf+YSw1FFEL/kUsaIrlISxEjCEUSQv2RSwVLE3AASEL9vEsDSb5EgSpbSwlJTgIIFk8CgSpPArtLAwhLAhJBAAdLA4EpJwW7SwlLC4j5ZSNDgAFySwVQSb1FAURJvkhMIiS6F0sBJFlLAhVPA04CUlcCAGVERRhC/Rw2GgFJFSQSRBdJNhoCSRUjEkQiU0w2GgNJTgJJIllJTgMkCyUITBUSREmI+KBJKRNESwGI+LoiW0lOA0sCKGVITHIIRBJETBZLARUWVwYCTwJQTCpQTFArTFBJvkRJVykBTIEqW0wnBRJEIklLBQxBACZLBVcCAEsBSU4CJAskWEsFFkxQgAFhTFBJvUUBRLxIIwhFAUL/00sCSb5EgSpbSwZJTgIJFk8CgSpPArtLAkwJQAAHSwKBKScEu0sGSwiI+HcjQzYaAUkVJBJEFzEAIicGZUSABndhbGxldGVIcghEEkQnBkxnI0OKAQGL/3MCRDIKEomKAQEiKUcDIkcDi/8iWUmMAYsIDUEAiYv/VwIAiwhJTgIlC0sBTFlLAiMISYwCiwFJTgRLAQlLAxVPAiULSwRMWU8CTVJJVwIBjACBA1tJjARMIwlPAhKMA0AACIsAJwUSQQA4I0SLACcHEkEADosFiwQIjAWLAowIQv+OiwCAAQoSQQAGI4wHQv/qiwAnBRJB/+KLA0QjjAZC/9kiQv/FiwVJIQQORCEEE0AABYsGQABBI0SLB0EAEosGQAANiwVBAAiLBSEEEkEAJCNEiwZAABKLBSEEEkAACosFQAAMiwdBAAcjRIv/jACJIkL/9iJC/9kiQv+8", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var RevenueManagerPluginParamsFactory = class _RevenueManagerPluginParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "create":
          case "create(string,uint64)void":
            return _RevenueManagerPluginParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs create ABI call params for the RevenueManagerPlugin smart contract using the create(string,uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params) {
        return {
          ...params,
          method: "create(string,uint64)void",
          args: Array.isArray(params.args) ? params.args : [params.args.version, params.args.akitaDao]
        };
      }
    };
  }
  /**
     * Constructs a no op call for the optIn(uint64,bool,uint64[],pay)void ABI method
     *
    * optin exists because revenue manager uses additional metadata to track optin counts for processing payments
    revenue escrows must be locked to avoid mistracking optins to ensure all opted in assets get processed
  
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
  static optIn(params) {
    return {
      ...params,
      method: "optIn(uint64,bool,uint64[],pay)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.assets, params.args.mbrPayment]
    };
  }
  /**
     * Constructs a no op call for the newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void ABI method
     *
    * Creates a new receive escrow with direct splits
    Use this when you want to store splits directly in this contract
  
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
  static newReceiveEscrow(params) {
    return {
      ...params,
      method: "newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.escrow, params.args.source, params.args.allocatable, params.args.optinAllowed, params.args.splits]
    };
  }
  /**
     * Constructs a no op call for the newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void ABI method
     *
    * Creates a new receive escrow with a reference to splits stored in another contract
    Use this when you want splits to be dynamically read from another contract's global state
  
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
  static newReceiveEscrowWithRef(params) {
    return {
      ...params,
      method: "newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.escrow, params.args.source, params.args.allocatable, params.args.optinAllowed, params.args.splitRef]
    };
  }
  /**
   * Constructs a no op call for the startEscrowDisbursement(uint64,bool)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static startEscrowDisbursement(params) {
    return {
      ...params,
      method: "startEscrowDisbursement(uint64,bool)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack]
    };
  }
  /**
   * Constructs a no op call for the processEscrowAllocation(uint64,bool,uint64[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static processEscrowAllocation(params) {
    return {
      ...params,
      method: "processEscrowAllocation(uint64,bool,uint64[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.ids]
    };
  }
  /**
     * Constructs a no op call for the finalizeEscrowDisbursement(uint64,bool,uint64[])void ABI method
     *
    * Cleans up processed asset boxes and resets escrow back to idle state
    Must be called after all assets have been processed (escrow in Finalization phase)
    Can be called in batches - pass the asset IDs that were processed to delete their tracking boxes
  
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
  static finalizeEscrowDisbursement(params) {
    return {
      ...params,
      method: "finalizeEscrowDisbursement(uint64,bool,uint64[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.ids]
    };
  }
  /**
   * Constructs a no op call for the updateAkitaDAO(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDao(params) {
    return {
      ...params,
      method: "updateAkitaDAO(uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.akitaDao]
    };
  }
  /**
   * Constructs a no op call for the opUp()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static opUp(params) {
    return {
      ...params,
      method: "opUp()void",
      args: Array.isArray(params.args) ? params.args : []
    };
  }
};
var RevenueManagerPluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `RevenueManagerPluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory7({
      ...params,
      appSpec: APP_SPEC7
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC7;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new RevenueManagerPluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new RevenueManagerPluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the RevenueManagerPlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    var _a;
    const result = await this.appFactory.deploy({
      ...params,
      createParams: ((_a = params.createParams) == null ? void 0 : _a.method) ? RevenueManagerPluginParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams : void 0
    });
    return { result: result.result, appClient: new RevenueManagerPluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the RevenueManagerPlugin smart contract using the create(string,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params) => {
        return this.appFactory.params.create(RevenueManagerPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the RevenueManagerPlugin smart contract using the create(string,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params) => {
        return this.appFactory.createTransaction.create(RevenueManagerPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the RevenueManagerPlugin smart contract using an ABI method call using the create(string,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params) => {
        const result = await this.appFactory.send.create(RevenueManagerPluginParamsFactory.create.create(params));
        return { result: { ...result.result, return: result.result.return }, appClient: new RevenueManagerPluginClient(result.appClient) };
      }
    }
  };
};
var RevenueManagerPluginClient = class _RevenueManagerPluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient7 ? appClientOrParams : new _AppClient7({
      ...appClientOrParams,
      appSpec: APP_SPEC7
    });
  }
  /**
   * Returns a new `RevenueManagerPluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _RevenueManagerPluginClient(await _AppClient7.fromCreatorAndName({ ...params, appSpec: APP_SPEC7 }));
  }
  /**
   * Returns an `RevenueManagerPluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _RevenueManagerPluginClient(await _AppClient7.fromNetwork({ ...params, appSpec: APP_SPEC7 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the RevenueManagerPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `optIn(uint64,bool,uint64[],pay)void` ABI method.
         *
        * optin exists because revenue manager uses additional metadata to track optin counts for processing payments
        revenue escrows must be locked to avoid mistracking optins to ensure all opted in assets get processed
    
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
    optIn: (params) => {
      return this.appClient.params.call(RevenueManagerPluginParamsFactory.optIn(params));
    },
    /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void` ABI method.
         *
        * Creates a new receive escrow with direct splits
        Use this when you want to store splits directly in this contract
    
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
    newReceiveEscrow: (params) => {
      return this.appClient.params.call(RevenueManagerPluginParamsFactory.newReceiveEscrow(params));
    },
    /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void` ABI method.
         *
        * Creates a new receive escrow with a reference to splits stored in another contract
        Use this when you want splits to be dynamically read from another contract's global state
    
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
    newReceiveEscrowWithRef: (params) => {
      return this.appClient.params.call(RevenueManagerPluginParamsFactory.newReceiveEscrowWithRef(params));
    },
    /**
     * Makes a call to the RevenueManagerPlugin smart contract using the `startEscrowDisbursement(uint64,bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    startEscrowDisbursement: (params) => {
      return this.appClient.params.call(RevenueManagerPluginParamsFactory.startEscrowDisbursement(params));
    },
    /**
     * Makes a call to the RevenueManagerPlugin smart contract using the `processEscrowAllocation(uint64,bool,uint64[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    processEscrowAllocation: (params) => {
      return this.appClient.params.call(RevenueManagerPluginParamsFactory.processEscrowAllocation(params));
    },
    /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `finalizeEscrowDisbursement(uint64,bool,uint64[])void` ABI method.
         *
        * Cleans up processed asset boxes and resets escrow back to idle state
        Must be called after all assets have been processed (escrow in Finalization phase)
        Can be called in batches - pass the asset IDs that were processed to delete their tracking boxes
    
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
    finalizeEscrowDisbursement: (params) => {
      return this.appClient.params.call(RevenueManagerPluginParamsFactory.finalizeEscrowDisbursement(params));
    },
    /**
     * Makes a call to the RevenueManagerPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDao: (params) => {
      return this.appClient.params.call(RevenueManagerPluginParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the RevenueManagerPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.params.call(RevenueManagerPluginParamsFactory.opUp(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the RevenueManagerPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `optIn(uint64,bool,uint64[],pay)void` ABI method.
         *
        * optin exists because revenue manager uses additional metadata to track optin counts for processing payments
        revenue escrows must be locked to avoid mistracking optins to ensure all opted in assets get processed
    
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
    optIn: (params) => {
      return this.appClient.createTransaction.call(RevenueManagerPluginParamsFactory.optIn(params));
    },
    /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void` ABI method.
         *
        * Creates a new receive escrow with direct splits
        Use this when you want to store splits directly in this contract
    
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
    newReceiveEscrow: (params) => {
      return this.appClient.createTransaction.call(RevenueManagerPluginParamsFactory.newReceiveEscrow(params));
    },
    /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void` ABI method.
         *
        * Creates a new receive escrow with a reference to splits stored in another contract
        Use this when you want splits to be dynamically read from another contract's global state
    
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
    newReceiveEscrowWithRef: (params) => {
      return this.appClient.createTransaction.call(RevenueManagerPluginParamsFactory.newReceiveEscrowWithRef(params));
    },
    /**
     * Makes a call to the RevenueManagerPlugin smart contract using the `startEscrowDisbursement(uint64,bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    startEscrowDisbursement: (params) => {
      return this.appClient.createTransaction.call(RevenueManagerPluginParamsFactory.startEscrowDisbursement(params));
    },
    /**
     * Makes a call to the RevenueManagerPlugin smart contract using the `processEscrowAllocation(uint64,bool,uint64[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    processEscrowAllocation: (params) => {
      return this.appClient.createTransaction.call(RevenueManagerPluginParamsFactory.processEscrowAllocation(params));
    },
    /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `finalizeEscrowDisbursement(uint64,bool,uint64[])void` ABI method.
         *
        * Cleans up processed asset boxes and resets escrow back to idle state
        Must be called after all assets have been processed (escrow in Finalization phase)
        Can be called in batches - pass the asset IDs that were processed to delete their tracking boxes
    
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
    finalizeEscrowDisbursement: (params) => {
      return this.appClient.createTransaction.call(RevenueManagerPluginParamsFactory.finalizeEscrowDisbursement(params));
    },
    /**
     * Makes a call to the RevenueManagerPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDao: (params) => {
      return this.appClient.createTransaction.call(RevenueManagerPluginParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the RevenueManagerPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.createTransaction.call(RevenueManagerPluginParamsFactory.opUp(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the RevenueManagerPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `optIn(uint64,bool,uint64[],pay)void` ABI method.
         *
        * optin exists because revenue manager uses additional metadata to track optin counts for processing payments
        revenue escrows must be locked to avoid mistracking optins to ensure all opted in assets get processed
    
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
    optIn: async (params) => {
      const result = await this.appClient.send.call(RevenueManagerPluginParamsFactory.optIn(params));
      return { ...result, return: result.return };
    },
    /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void` ABI method.
         *
        * Creates a new receive escrow with direct splits
        Use this when you want to store splits directly in this contract
    
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
    newReceiveEscrow: async (params) => {
      const result = await this.appClient.send.call(RevenueManagerPluginParamsFactory.newReceiveEscrow(params));
      return { ...result, return: result.return };
    },
    /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void` ABI method.
         *
        * Creates a new receive escrow with a reference to splits stored in another contract
        Use this when you want splits to be dynamically read from another contract's global state
    
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
    newReceiveEscrowWithRef: async (params) => {
      const result = await this.appClient.send.call(RevenueManagerPluginParamsFactory.newReceiveEscrowWithRef(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RevenueManagerPlugin smart contract using the `startEscrowDisbursement(uint64,bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    startEscrowDisbursement: async (params) => {
      const result = await this.appClient.send.call(RevenueManagerPluginParamsFactory.startEscrowDisbursement(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RevenueManagerPlugin smart contract using the `processEscrowAllocation(uint64,bool,uint64[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    processEscrowAllocation: async (params) => {
      const result = await this.appClient.send.call(RevenueManagerPluginParamsFactory.processEscrowAllocation(params));
      return { ...result, return: result.return };
    },
    /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `finalizeEscrowDisbursement(uint64,bool,uint64[])void` ABI method.
         *
        * Cleans up processed asset boxes and resets escrow back to idle state
        Must be called after all assets have been processed (escrow in Finalization phase)
        Can be called in batches - pass the asset IDs that were processed to delete their tracking boxes
    
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
    finalizeEscrowDisbursement: async (params) => {
      const result = await this.appClient.send.call(RevenueManagerPluginParamsFactory.finalizeEscrowDisbursement(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RevenueManagerPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDao: async (params) => {
      const result = await this.appClient.send.call(RevenueManagerPluginParamsFactory.updateAkitaDao(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RevenueManagerPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    opUp: async (params = { args: [] }) => {
      const result = await this.appClient.send.call(RevenueManagerPluginParamsFactory.opUp(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _RevenueManagerPluginClient(this.appClient.clone(params));
  }
  /**
   * Methods to access state for the current RevenueManagerPlugin app
   */
  state = {
    /**
     * Methods to access global state for the current RevenueManagerPlugin app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async () => {
        const result = await this.appClient.state.global.getAll();
        return {
          version: result.version,
          akitaDao: result.akitaDAO
        };
      },
      /**
       * Get the current value of the version key in global state
       */
      version: async () => {
        return await this.appClient.state.global.getValue("version");
      },
      /**
       * Get the current value of the akitaDAO key in global state
       */
      akitaDao: async () => {
        return await this.appClient.state.global.getValue("akitaDAO");
      }
    },
    /**
     * Methods to access box state for the current RevenueManagerPlugin app
     */
    box: {
      /**
       * Get all current keyed values from box state
       */
      getAll: async () => {
        const result = await this.appClient.state.box.getAll();
        return {};
      },
      /**
       * Get values from the escrows map in box state
       */
      escrows: {
        /**
         * Get all current values of the escrows map in box state
         */
        getMap: async () => {
          return await this.appClient.state.box.getMap("escrows");
        },
        /**
         * Get a current value of the escrows map by key from box state
         */
        value: async (key) => {
          return await this.appClient.state.box.getMapValue("escrows", key);
        }
      },
      /**
       * Get values from the receiveAssets map in box state
       */
      receiveAssets: {
        /**
         * Get all current values of the receiveAssets map in box state
         */
        getMap: async () => {
          return await this.appClient.state.box.getMap("receiveAssets");
        },
        /**
         * Get a current value of the receiveAssets map by key from box state
         */
        value: async (key) => {
          return await this.appClient.state.box.getMapValue("receiveAssets", key);
        }
      },
      /**
       * Get values from the splits map in box state
       */
      splits: {
        /**
         * Get all current values of the splits map in box state
         */
        getMap: async () => {
          return await this.appClient.state.box.getMap("splits");
        },
        /**
         * Get a current value of the splits map by key from box state
         */
        value: async (key) => {
          return await this.appClient.state.box.getMapValue("splits", key);
        }
      },
      /**
       * Get values from the splitRefs map in box state
       */
      splitRefs: {
        /**
         * Get all current values of the splitRefs map in box state
         */
        getMap: async () => {
          return await this.appClient.state.box.getMap("splitRefs");
        },
        /**
         * Get a current value of the splitRefs map by key from box state
         */
        value: async (key) => {
          return await this.appClient.state.box.getMapValue("splitRefs", key);
        }
      }
    }
  };
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a optIn(uint64,bool,uint64[],pay)void method call against the RevenueManagerPlugin contract
       */
      optIn(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.optIn(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void method call against the RevenueManagerPlugin contract
       */
      newReceiveEscrow(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.newReceiveEscrow(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void method call against the RevenueManagerPlugin contract
       */
      newReceiveEscrowWithRef(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.newReceiveEscrowWithRef(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a startEscrowDisbursement(uint64,bool)void method call against the RevenueManagerPlugin contract
       */
      startEscrowDisbursement(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.startEscrowDisbursement(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a processEscrowAllocation(uint64,bool,uint64[])void method call against the RevenueManagerPlugin contract
       */
      processEscrowAllocation(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.processEscrowAllocation(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a finalizeEscrowDisbursement(uint64,bool,uint64[])void method call against the RevenueManagerPlugin contract
       */
      finalizeEscrowDisbursement(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.finalizeEscrowDisbursement(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a updateAkitaDAO(uint64)void method call against the RevenueManagerPlugin contract
       */
      updateAkitaDao(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDao(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a opUp()void method call against the RevenueManagerPlugin contract
       */
      opUp(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.opUp(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a clear state call to the RevenueManagerPlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/revenue-manager.ts
import algosdk5 from "algosdk";
import { microAlgo as microAlgo5 } from "@algorandfoundation/algokit-utils";
var assetOptInCost2 = 1e5;
var RevenueManagerPluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: RevenueManagerPluginFactory, ...params });
  }
  optIn(args) {
    const methodName = "optIn";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer, assets } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const mbrPayment = this.client.algorand.createTransaction.payment({
          ...sendParams,
          amount: microAlgo5(assetOptInCost2 * assets.length),
          receiver: spendingAddress ? spendingAddress : algosdk5.getApplicationAddress(wallet)
        });
        const params = await this.client.params.optIn({
          ...sendParams,
          args: { wallet, rekeyBack, assets, mbrPayment }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  newReceiveEscrow(args) {
    const methodName = "newReceiveEscrow";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer, escrow, source, allocatable, optinAllowed, splits } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.newReceiveEscrow({
          ...sendParams,
          args: { wallet, rekeyBack, escrow, source, allocatable, optinAllowed, splits }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  newReceiveEscrowWithRef(args) {
    const methodName = "newReceiveEscrowWithRef";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer, escrow, source, allocatable, optinAllowed, splitRef } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.newReceiveEscrowWithRef({
          ...sendParams,
          args: { wallet, rekeyBack, escrow, source, allocatable, optinAllowed, splitRef }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  startEscrowDisbursement(args) {
    const methodName = "startEscrowDisbursement";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.startEscrowDisbursement({
          ...sendParams,
          args: { wallet, rekeyBack }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  processEscrowAllocation(args) {
    const methodName = "processEscrowAllocation";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer, ids } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.processEscrowAllocation({
          ...sendParams,
          args: { wallet, rekeyBack, ids }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  finalizeEscrowDisbursement(args) {
    const methodName = "finalizeEscrowDisbursement";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer, ids } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.finalizeEscrowDisbursement({
          ...sendParams,
          args: { wallet, rekeyBack, ids }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
};

// src/generated/AuctionPluginClient.ts
import { getArc56ReturnValue as getArc56ReturnValue5, getABIStructFromABITuple as getABIStructFromABITuple5 } from "@algorandfoundation/algokit-utils/types/app-arc56";
import {
  AppClient as _AppClient8
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory8 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC8 = { "name": "AuctionPlugin", "structs": { "AuctionMBRData": [{ "name": "bids", "type": "uint64" }, { "name": "weights", "type": "uint64" }, { "name": "bidsByAddress", "type": "uint64" }, { "name": "locations", "type": "uint64" }] }, "methods": [{ "name": "create", "args": [{ "type": "string", "name": "version" }, { "type": "uint64", "name": "factory" }, { "type": "uint64", "name": "akitaDAO" }], "returns": { "type": "void" }, "actions": { "create": ["NoOp"], "call": [] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "new", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "prizeID" }, { "type": "uint64", "name": "prizeAmount" }, { "type": "string", "name": "name" }, { "type": "byte[32][]", "name": "proof" }, { "type": "uint64", "name": "bidAssetID" }, { "type": "uint64", "name": "bidFee" }, { "type": "uint64", "name": "startingBid" }, { "type": "uint64", "name": "bidMinimumIncrease" }, { "type": "uint64", "name": "startTimestamp" }, { "type": "uint64", "name": "endtimestamp" }, { "type": "uint64", "name": "gateID" }, { "type": "address", "name": "marketplace" }, { "type": "uint64", "name": "weightsListCount" }], "returns": { "type": "uint64" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "clearWeightsBoxes", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "auctionAppID" }, { "type": "uint64", "name": "iterationAmount" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "deleteAuctionApp", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "bid", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "uint64", "name": "amount" }, { "type": "byte[][]", "name": "args" }, { "type": "address", "name": "marketplace" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "refundBid", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "uint64", "name": "id" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "claimPrize", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "claimRafflePrize", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "raffle", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "findWinner", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "auctionAppID" }, { "type": "uint64", "name": "iterationAmount" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "deleteApplication", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["DeleteApplication"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "cancel", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "updateAkitaDAO", "args": [{ "type": "uint64", "name": "akitaDAO" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "opUp", "args": [], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "mbr", "args": [], "returns": { "type": "(uint64,uint64,uint64,uint64)", "struct": "AuctionMBRData" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": true, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 2, "bytes": 1 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": { "factory": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "YXVjdGlvbl9mYWN0b3J5" }, "version": { "keyType": "AVMString", "valueType": "AVMString", "key": "dmVyc2lvbg==", "desc": "the current version of the contract" }, "akitaDAO": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "YWtpdGFfZGFv", "desc": "the app ID of the Akita DAO" } }, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": [], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [829, 952, 1683], "errorMessage": "Bytes has valid prefix" }, { "pc": [900, 1007, 1183, 1765, 1846, 1924, 1995, 2089, 2170, 2248], "errorMessage": "Creator is not the auction factory" }, { "pc": [541], "errorMessage": "Not enough asset" }, { "pc": [265], "errorMessage": "OnCompletion must be DeleteApplication && can only call when not creating" }, { "pc": [95], "errorMessage": "OnCompletion must be NoOp" }, { "pc": [2308], "errorMessage": "Only the Akita DAO can call this function" }, { "pc": [284, 548, 565, 609, 627, 696, 701, 888, 896, 995, 1003, 1152, 1174, 1181, 1233, 1414, 1417, 1756, 1763, 1837, 1844, 1915, 1922, 1986, 1993, 2080, 2087, 2161, 2168, 2239, 2246, 2306], "errorMessage": "application exists" }, { "pc": [534], "errorMessage": "auction prize cannot be algo" }, { "pc": [545, 561, 606, 623, 692, 892, 999, 1178, 1250, 1428, 1760, 1841, 1919, 1990, 2084, 2165, 2243, 2293], "errorMessage": "check GlobalState exists" }, { "pc": [424], "errorMessage": "invalid number of bytes for (len+uint8[32][])" }, { "pc": [299, 405], "errorMessage": "invalid number of bytes for (len+utf8[])" }, { "pc": [359, 865, 973, 1064, 1688, 1725, 1815, 1893, 1971, 2049, 2139, 2217], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [310, 319, 349, 373, 385, 435, 448, 458, 468, 478, 488, 498, 520, 834, 856, 875, 884, 956, 964, 983, 1054, 1075, 1087, 1716, 1735, 1744, 1806, 1825, 1884, 1903, 1962, 1981, 2040, 2059, 2068, 2130, 2149, 2208, 2227, 2286], "errorMessage": "invalid number of bytes for uint64" }, { "pc": [509, 1106], "errorMessage": "invalid number of bytes for uint8[32]" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCA4IDEgNgogICAgYnl0ZWNibG9jayAiYXVjdGlvbl9mYWN0b3J5IiAic3BlbmRpbmdfYWRkcmVzcyIgImFraXRhX2RhbyIgMHgxNTFmN2M3NSAweDM5NGVhZWIyICJhYWwiICJnYXRlX2lkIiAweDQzOTIyNjU1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MjEKICAgIC8vIGV4cG9ydCBjbGFzcyBBdWN0aW9uUGx1Z2luIGV4dGVuZHMgY2xhc3NlcyhCYXNlQXVjdGlvbiwgQWtpdGFCYXNlQ29udHJhY3QpIHsKICAgIHB1c2hieXRlcyAweGJlZGZjOTNiIC8vIG1ldGhvZCAiZGVsZXRlQXBwbGljYXRpb24odWludDY0LGJvb2wsdWludDY0KXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX2RlbGV0ZUFwcGxpY2F0aW9uX3JvdXRlQDQKCm1haW5fc3dpdGNoX2Nhc2VfbmV4dEA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjIxCiAgICAvLyBleHBvcnQgY2xhc3MgQXVjdGlvblBsdWdpbiBleHRlbmRzIGNsYXNzZXMoQmFzZUF1Y3Rpb24sIEFraXRhQmFzZUNvbnRyYWN0KSB7CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIG11c3QgYmUgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGJ6IG1haW5fY3JlYXRlX05vT3BAMjEKICAgIHB1c2hieXRlc3MgMHg5ZTBiOTA3ZCAweDhiOWQ1ZTkzIDB4ZTI0ZGJiZDIgMHhiY2NmYmE0OSAweDZlNDQyMmViIDB4MjkxNmRiZmQgMHhiZDMyMDQ2NSAweGE0Mzg1ZTFiIDB4MGVlNTYzZTcgMHg5MWRiNDhmMCAweDMzZTkyYzk0IDB4ODU0ZGVkZTAgMHg3MzExMTA3MCAvLyBtZXRob2QgIm5ldyh1aW50NjQsYm9vbCx1aW50NjQsdWludDY0LHN0cmluZyxieXRlWzMyXVtdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCl1aW50NjQiLCBtZXRob2QgImNsZWFyV2VpZ2h0c0JveGVzKHVpbnQ2NCxib29sLHVpbnQ2NCx1aW50NjQpdm9pZCIsIG1ldGhvZCAiZGVsZXRlQXVjdGlvbkFwcCh1aW50NjQsYm9vbCx1aW50NjQpdm9pZCIsIG1ldGhvZCAiYmlkKHVpbnQ2NCxib29sLHVpbnQ2NCx1aW50NjQsYnl0ZVtdW10sYWRkcmVzcyl2b2lkIiwgbWV0aG9kICJyZWZ1bmRCaWQodWludDY0LGJvb2wsdWludDY0LHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJjbGFpbVByaXplKHVpbnQ2NCxib29sLHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJjbGFpbVJhZmZsZVByaXplKHVpbnQ2NCxib29sLHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJyYWZmbGUodWludDY0LGJvb2wsdWludDY0KXZvaWQiLCBtZXRob2QgImZpbmRXaW5uZXIodWludDY0LGJvb2wsdWludDY0LHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJjYW5jZWwodWludDY0LGJvb2wsdWludDY0KXZvaWQiLCBtZXRob2QgInVwZGF0ZUFraXRhREFPKHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJvcFVwKCl2b2lkIiwgbWV0aG9kICJtYnIoKSh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggbmV3IGNsZWFyV2VpZ2h0c0JveGVzIGRlbGV0ZUF1Y3Rpb25BcHAgYmlkIHJlZnVuZEJpZCBjbGFpbVByaXplIGNsYWltUmFmZmxlUHJpemUgcmFmZmxlIGZpbmRXaW5uZXIgY2FuY2VsIHVwZGF0ZUFraXRhREFPIG1haW5fb3BVcF9yb3V0ZUAxOCBtYWluX21icl9yb3V0ZUAxOQogICAgZXJyCgptYWluX21icl9yb3V0ZUAxOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hdWN0aW9uL2Jhc2UudHM6NwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICBwdXNoYnl0ZXMgMHgxNTFmN2M3NTAwMDAwMDAwMDAwMDg4NTQwMDAwMDAwMDAwYzgxN2Q0MDAwMDAwMDAwMDAwNDg0NDAwMDAwMDAwMDAwMDQ5ZDQKICAgIGxvZwogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKbWFpbl9vcFVwX3JvdXRlQDE4OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NDMKICAgIC8vIG9wVXAoKTogdm9pZCB7IH0KICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCm1haW5fY3JlYXRlX05vT3BAMjE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MjEKICAgIC8vIGV4cG9ydCBjbGFzcyBBdWN0aW9uUGx1Z2luIGV4dGVuZHMgY2xhc3NlcyhCYXNlQXVjdGlvbiwgQWtpdGFCYXNlQ29udHJhY3QpIHsKICAgIHB1c2hieXRlcyAweDg4Yzk0MGY4IC8vIG1ldGhvZCAiY3JlYXRlKHN0cmluZyx1aW50NjQsdWludDY0KXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBjcmVhdGUKICAgIGVycgoKbWFpbl9kZWxldGVBcHBsaWNhdGlvbl9yb3V0ZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjM4Ny0zOTEKICAgIC8vIGRlbGV0ZUFwcGxpY2F0aW9uKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbgogICAgLy8gKTogdm9pZCB7CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICBwdXNoaW50IDUgLy8gRGVsZXRlQXBwbGljYXRpb24KICAgID09CiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgJiYKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gbXVzdCBiZSBEZWxldGVBcHBsaWNhdGlvbiAmJiBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICBiIGRlbGV0ZUFwcGxpY2F0aW9uCgoKLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6cmVrZXlBZGRyZXNzKHJla2V5QmFjazogdWludDY0LCB3YWxsZXQ6IHVpbnQ2NCkgLT4gYnl0ZXM6CnJla2V5QWRkcmVzczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzIxCiAgICAvLyBleHBvcnQgZnVuY3Rpb24gcmVrZXlBZGRyZXNzKHJla2V5QmFjazogYm9vbGVhbiwgd2FsbGV0OiBBcHBsaWNhdGlvbik6IEFjY291bnQgewogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMgogICAgLy8gaWYgKCFyZWtleUJhY2spIHsKICAgIGZyYW1lX2RpZyAtMgogICAgYm56IHJla2V5QWRkcmVzc19hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzIzCiAgICAvLyByZXR1cm4gR2xvYmFsLnplcm9BZGRyZXNzCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIHJldHN1YgoKcmVrZXlBZGRyZXNzX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzI2CiAgICAvLyByZXR1cm4gd2FsbGV0LmFkZHJlc3MKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjpBdWN0aW9uUGx1Z2luLmNyZWF0ZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmNyZWF0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyOQogICAgLy8gQGFiaW1ldGhvZCh7IG9uQ3JlYXRlOiAncmVxdWlyZScgfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1dGY4W10pCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyNwogICAgLy8gdmVyc2lvbiA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5VmVyc2lvbiB9KQogICAgcHVzaGJ5dGVzICJ2ZXJzaW9uIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjMxCiAgICAvLyB0aGlzLnZlcnNpb24udmFsdWUgPSB2ZXJzaW9uCiAgICB1bmNvdmVyIDMKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MjUKICAgIC8vIGZhY3RvcnkgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEF1Y3Rpb25QbHVnaW5HbG9iYWxTdGF0ZUtleUZhY3RvcnkgfSkKICAgIGJ5dGVjXzAgLy8gImF1Y3Rpb25fZmFjdG9yeSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czozMgogICAgLy8gdGhpcy5mYWN0b3J5LnZhbHVlID0gQXBwbGljYXRpb24oZmFjdG9yeSkKICAgIHVuY292ZXIgMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjMzCiAgICAvLyB0aGlzLmFraXRhREFPLnZhbHVlID0gQXBwbGljYXRpb24oYWtpdGFEQU8pCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI5CiAgICAvLyBAYWJpbWV0aG9kKHsgb25DcmVhdGU6ICdyZXF1aXJlJyB9KQogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czo6QXVjdGlvblBsdWdpbi5uZXdbcm91dGluZ10oKSAtPiB2b2lkOgpuZXc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MzgtNTQKICAgIC8vIG5ldygKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBwcml6ZUlEOiB1aW50NjQsIC8vIDAgfCBBc3NldCB8IEFwcGxpY2F0aW9uCiAgICAvLyAgIHByaXplQW1vdW50OiB1aW50NjQsCiAgICAvLyAgIG5hbWU6IHN0cmluZywKICAgIC8vICAgcHJvb2Y6IFByb29mLAogICAgLy8gICBiaWRBc3NldElEOiB1aW50NjQsIC8vIDAgfCBBc3NldAogICAgLy8gICBiaWRGZWU6IHVpbnQ2NCwKICAgIC8vICAgc3RhcnRpbmdCaWQ6IHVpbnQ2NCwKICAgIC8vICAgYmlkTWluaW11bUluY3JlYXNlOiB1aW50NjQsCiAgICAvLyAgIHN0YXJ0VGltZXN0YW1wOiB1aW50NjQsCiAgICAvLyAgIGVuZHRpbWVzdGFtcDogdWludDY0LAogICAgLy8gICBnYXRlSUQ6IHVpbnQ2NCwKICAgIC8vICAgbWFya2V0cGxhY2U6IEFjY291bnQsCiAgICAvLyAgIHdlaWdodHNMaXN0Q291bnQ6IHVpbnQ2NCwKICAgIC8vICk6IHVpbnQ2NCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGR1cAogICAgY292ZXIgNAogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBzd2FwCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgZHVwCiAgICBjb3ZlciA0CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAzMiAvLyAzMgogICAgKgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIHN3YXAKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1aW50OFszMl1bXSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDcKICAgIGR1cAogICAgY292ZXIgNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGNvdmVyIDMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDgKICAgIGR1cAogICAgY292ZXIgNAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA5CiAgICBkdXAKICAgIGNvdmVyIDQKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMTAKICAgIGR1cAogICAgY292ZXIgNAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxMQogICAgZHVwCiAgICBjb3ZlciA0CiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEyCiAgICBkdXAKICAgIGNvdmVyIDQKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMTMKICAgIGR1cAogICAgY292ZXIgNAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxNAogICAgZHVwCiAgICBjb3ZlciA0CiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMTUKICAgIGR1cAogICAgY292ZXIgNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGNvdmVyIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIHVuY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czo1NwogICAgLy8gYXNzZXJ0KHByaXplSUQgIT09IDAsIEVSUl9BVUNUSU9OX1BSSVpFX0NBTk5PVF9CRV9BTEdPKQogICAgZGlnIDIKICAgIGFzc2VydCAvLyBhdWN0aW9uIHByaXplIGNhbm5vdCBiZSBhbGdvCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6NTgKICAgIC8vIGNvbnN0IHNlbmRlclByaXplQmFsYW5jZSA9IEFzc2V0SG9sZGluZy5hc3NldEJhbGFuY2Uoc2VuZGVyLCBwcml6ZUlEKVswXQogICAgZGlnIDIKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6NTkKICAgIC8vIGFzc2VydChzZW5kZXJQcml6ZUJhbGFuY2UgPj0gcHJpemVBbW91bnQsIEVSUl9OT1RfRU5PVUdIX0FTU0VUKQogICAgPD0KICAgIGFzc2VydCAvLyBOb3QgZW5vdWdoIGFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6NjEKICAgIC8vIGlmICghdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MuaXNPcHRlZEluKEFzc2V0KHByaXplSUQpKSkgewogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyNQogICAgLy8gZmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogQXVjdGlvblBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAiYXVjdGlvbl9mYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjYxCiAgICAvLyBpZiAoIXRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLmlzT3B0ZWRJbihBc3NldChwcml6ZUlEKSkpIHsKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBzd2FwCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYm56IG5ld19hZnRlcl9pZl9lbHNlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czo2Mi03MwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQXVjdGlvbkZhY3RvcnkucHJvdG90eXBlLm9wdEluPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZmFjdG9yeS52YWx1ZSwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZQogICAgLy8gICAgIH0pLAogICAgLy8gICAgIEFzc2V0KHByaXplSUQpLAogICAgLy8gICBdCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjY4CiAgICAvLyByZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI1CiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBBdWN0aW9uUGx1Z2luR2xvYmFsU3RhdGVLZXlGYWN0b3J5IH0pCiAgICBieXRlY18wIC8vICJhdWN0aW9uX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6NjgKICAgIC8vIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czo2OQogICAgLy8gYW1vdW50OiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIGdsb2JhbCBBc3NldE9wdEluTWluQmFsYW5jZQogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGRpZyAxCiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6NjYtNzAKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZQogICAgLy8gfSksCiAgICBpbnRjXzIgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6NjItNzMKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEF1Y3Rpb25GYWN0b3J5LnByb3RvdHlwZS5vcHRJbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBBc3NldChwcml6ZUlEKSwKICAgIC8vICAgXQogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgYnl0ZWMgNCAvLyBtZXRob2QgIm9wdEluKHBheSx1aW50NjQpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTgKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAoKbmV3X2FmdGVyX2lmX2Vsc2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czo3NgogICAgLy8gaWYgKCF0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcy5pc09wdGVkSW4oQXNzZXQoYmlkQXNzZXRJRCkpKSB7CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI1CiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBBdWN0aW9uUGx1Z2luR2xvYmFsU3RhdGVLZXlGYWN0b3J5IH0pCiAgICBieXRlY18wIC8vICJhdWN0aW9uX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6NzYKICAgIC8vIGlmICghdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MuaXNPcHRlZEluKEFzc2V0KGJpZEFzc2V0SUQpKSkgewogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGRpZyAxMQogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBidXJ5IDEKICAgIGJueiBuZXdfYWZ0ZXJfaWZfZWxzZUA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6NzctODgKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEF1Y3Rpb25GYWN0b3J5LnByb3RvdHlwZS5vcHRJbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBBc3NldChiaWRBc3NldElEKSwKICAgIC8vICAgXQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czo4MwogICAgLy8gcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyNQogICAgLy8gZmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogQXVjdGlvblBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAiYXVjdGlvbl9mYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjgzCiAgICAvLyByZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6ODQKICAgIC8vIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICBnbG9iYWwgQXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgMQogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjgxLTg1CiAgICAvLyBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIC8vIH0pLAogICAgaW50Y18yIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjc3LTg4CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBdWN0aW9uRmFjdG9yeS5wcm90b3R5cGUub3B0SW4+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgQXNzZXQoYmlkQXNzZXRJRCksCiAgICAvLyAgIF0KICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIGJ5dGVjIDQgLy8gbWV0aG9kICJvcHRJbihwYXksdWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDEzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKCm5ld19hZnRlcl9pZl9lbHNlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6OTItOTQKICAgIC8vIGNvbnN0IG9wdGluTUJSOiB1aW50NjQgPSBpc0FsZ29CaWQKICAgIC8vICAgPyBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIC8vICAgOiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UgKiAyCiAgICBkaWcgMTAKICAgIGJueiBuZXdfdGVybmFyeV9mYWxzZUAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjkzCiAgICAvLyA/IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZQogICAgZ2xvYmFsIEFzc2V0T3B0SW5NaW5CYWxhbmNlCgpuZXdfdGVybmFyeV9tZXJnZUAxMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoxMDEtMTAzCiAgICAvLyBNQVhfUFJPR1JBTV9QQUdFUyArCiAgICAvLyAoR0xPQkFMX1NUQVRFX0tFWV9VSU5UX0NPU1QgKiBhdWN0aW9uLmdsb2JhbFVpbnRzKSArCiAgICAvLyAoR0xPQkFMX1NUQVRFX0tFWV9CWVRFU19DT1NUICogYXVjdGlvbi5nbG9iYWxCeXRlcykgKwogICAgcHVzaGludCAxNTkxMDAwIC8vIDE1OTEwMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoxMDQKICAgIC8vIEdsb2JhbC5taW5CYWxhbmNlICsKICAgIGdsb2JhbCBNaW5CYWxhbmNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MTAxLTEwNAogICAgLy8gTUFYX1BST0dSQU1fUEFHRVMgKwogICAgLy8gKEdMT0JBTF9TVEFURV9LRVlfVUlOVF9DT1NUICogYXVjdGlvbi5nbG9iYWxVaW50cykgKwogICAgLy8gKEdMT0JBTF9TVEFURV9LRVlfQllURVNfQ09TVCAqIGF1Y3Rpb24uZ2xvYmFsQnl0ZXMpICsKICAgIC8vIEdsb2JhbC5taW5CYWxhbmNlICsKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoxMDEtMTA1CiAgICAvLyBNQVhfUFJPR1JBTV9QQUdFUyArCiAgICAvLyAoR0xPQkFMX1NUQVRFX0tFWV9VSU5UX0NPU1QgKiBhdWN0aW9uLmdsb2JhbFVpbnRzKSArCiAgICAvLyAoR0xPQkFMX1NUQVRFX0tFWV9CWVRFU19DT1NUICogYXVjdGlvbi5nbG9iYWxCeXRlcykgKwogICAgLy8gR2xvYmFsLm1pbkJhbGFuY2UgKwogICAgLy8gb3B0aW5NQlIgKwogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjEwNgogICAgLy8gKHdlaWdodHNMaXN0Q291bnQgKiBjb3N0cy53ZWlnaHRzKQogICAgZGlnIDIKICAgIHB1c2hpbnQgMTMxMTMzMDAgLy8gMTMxMTMzMDAKICAgICoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoxMDEtMTA2CiAgICAvLyBNQVhfUFJPR1JBTV9QQUdFUyArCiAgICAvLyAoR0xPQkFMX1NUQVRFX0tFWV9VSU5UX0NPU1QgKiBhdWN0aW9uLmdsb2JhbFVpbnRzKSArCiAgICAvLyAoR0xPQkFMX1NUQVRFX0tFWV9CWVRFU19DT1NUICogYXVjdGlvbi5nbG9iYWxCeXRlcykgKwogICAgLy8gR2xvYmFsLm1pbkJhbGFuY2UgKwogICAgLy8gb3B0aW5NQlIgKwogICAgLy8gKHdlaWdodHNMaXN0Q291bnQgKiBjb3N0cy53ZWlnaHRzKQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjExMQogICAgLy8gcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyNQogICAgLy8gZmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogQXVjdGlvblBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAiYXVjdGlvbl9mYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjExMQogICAgLy8gcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjExNwogICAgLy8gYXNzZXRSZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICBkaWcgMQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjEyMi0xNDEKICAgIC8vIGNvbnN0IG5ld0F1Y3Rpb24gPSBhYmlDYWxsPHR5cGVvZiBBdWN0aW9uRmFjdG9yeS5wcm90b3R5cGUubmV3QXVjdGlvbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJUeG4sCiAgICAvLyAgICAgcHJpemVUeG4sCiAgICAvLyAgICAgbmFtZSwKICAgIC8vICAgICBwcm9vZiwKICAgIC8vICAgICBiaWRBc3NldElELAogICAgLy8gICAgIGJpZEZlZSwKICAgIC8vICAgICBzdGFydGluZ0JpZCwKICAgIC8vICAgICBiaWRNaW5pbXVtSW5jcmVhc2UsCiAgICAvLyAgICAgc3RhcnRUaW1lc3RhbXAsCiAgICAvLyAgICAgZW5kdGltZXN0YW1wLAogICAgLy8gICAgIGdhdGVJRCwKICAgIC8vICAgICBtYXJrZXRwbGFjZSwKICAgIC8vICAgICB3ZWlnaHRzTGlzdENvdW50CiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgMgogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjEwOS0xMTMKICAgIC8vIGNvbnN0IG1iclR4biA9IGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IGNoaWxkQ29udHJhY3RNQlIKICAgIC8vIH0pCiAgICBpbnRjXzIgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MTI3CiAgICAvLyBwcml6ZVR4biwKICAgIGl0eG5fbmV4dAogICAgZGlnIDE4CiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgZGlnIDE3CiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoxMTUtMTIwCiAgICAvLyBjb25zdCBwcml6ZVR4biA9IGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXNzZXRSZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgIGFzc2V0QW1vdW50OiBwcml6ZUFtb3VudCwKICAgIC8vICAgeGZlckFzc2V0OiBBc3NldChwcml6ZUlEKQogICAgLy8gfSkKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoxMjItMTQxCiAgICAvLyBjb25zdCBuZXdBdWN0aW9uID0gYWJpQ2FsbDx0eXBlb2YgQXVjdGlvbkZhY3RvcnkucHJvdG90eXBlLm5ld0F1Y3Rpb24+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyVHhuLAogICAgLy8gICAgIHByaXplVHhuLAogICAgLy8gICAgIG5hbWUsCiAgICAvLyAgICAgcHJvb2YsCiAgICAvLyAgICAgYmlkQXNzZXRJRCwKICAgIC8vICAgICBiaWRGZWUsCiAgICAvLyAgICAgc3RhcnRpbmdCaWQsCiAgICAvLyAgICAgYmlkTWluaW11bUluY3JlYXNlLAogICAgLy8gICAgIHN0YXJ0VGltZXN0YW1wLAogICAgLy8gICAgIGVuZHRpbWVzdGFtcCwKICAgIC8vICAgICBnYXRlSUQsCiAgICAvLyAgICAgbWFya2V0cGxhY2UsCiAgICAvLyAgICAgd2VpZ2h0c0xpc3RDb3VudAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MTQwCiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICBkaWcgMTkKICAgIGRpZyAyMQogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoxMjItMTQxCiAgICAvLyBjb25zdCBuZXdBdWN0aW9uID0gYWJpQ2FsbDx0eXBlb2YgQXVjdGlvbkZhY3RvcnkucHJvdG90eXBlLm5ld0F1Y3Rpb24+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyVHhuLAogICAgLy8gICAgIHByaXplVHhuLAogICAgLy8gICAgIG5hbWUsCiAgICAvLyAgICAgcHJvb2YsCiAgICAvLyAgICAgYmlkQXNzZXRJRCwKICAgIC8vICAgICBiaWRGZWUsCiAgICAvLyAgICAgc3RhcnRpbmdCaWQsCiAgICAvLyAgICAgYmlkTWluaW11bUluY3JlYXNlLAogICAgLy8gICAgIHN0YXJ0VGltZXN0YW1wLAogICAgLy8gICAgIGVuZHRpbWVzdGFtcCwKICAgIC8vICAgICBnYXRlSUQsCiAgICAvLyAgICAgbWFya2V0cGxhY2UsCiAgICAvLyAgICAgd2VpZ2h0c0xpc3RDb3VudAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgcHVzaGJ5dGVzIDB4ZDE1NDhmZmYgLy8gbWV0aG9kICJuZXdBdWN0aW9uKHBheSxheGZlcixzdHJpbmcsYnl0ZVszMl1bXSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyx1aW50NjQpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxNgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxNQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA5CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDgKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBnaXR4biAyIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18zIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czozOC01NAogICAgLy8gbmV3KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIHByaXplSUQ6IHVpbnQ2NCwgLy8gMCB8IEFzc2V0IHwgQXBwbGljYXRpb24KICAgIC8vICAgcHJpemVBbW91bnQ6IHVpbnQ2NCwKICAgIC8vICAgbmFtZTogc3RyaW5nLAogICAgLy8gICBwcm9vZjogUHJvb2YsCiAgICAvLyAgIGJpZEFzc2V0SUQ6IHVpbnQ2NCwgLy8gMCB8IEFzc2V0CiAgICAvLyAgIGJpZEZlZTogdWludDY0LAogICAgLy8gICBzdGFydGluZ0JpZDogdWludDY0LAogICAgLy8gICBiaWRNaW5pbXVtSW5jcmVhc2U6IHVpbnQ2NCwKICAgIC8vICAgc3RhcnRUaW1lc3RhbXA6IHVpbnQ2NCwKICAgIC8vICAgZW5kdGltZXN0YW1wOiB1aW50NjQsCiAgICAvLyAgIGdhdGVJRDogdWludDY0LAogICAgLy8gICBtYXJrZXRwbGFjZTogQWNjb3VudCwKICAgIC8vICAgd2VpZ2h0c0xpc3RDb3VudDogdWludDY0LAogICAgLy8gKTogdWludDY0IHsKICAgIGJ5dGVjXzMgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCm5ld190ZXJuYXJ5X2ZhbHNlQDExOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjk0CiAgICAvLyA6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZSAqIDIKICAgIGdsb2JhbCBBc3NldE9wdEluTWluQmFsYW5jZQogICAgcHVzaGludCAyIC8vIDIKICAgICoKICAgIGIgbmV3X3Rlcm5hcnlfbWVyZ2VAMTIKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6OkF1Y3Rpb25QbHVnaW4uY2xlYXJXZWlnaHRzQm94ZXNbcm91dGluZ10oKSAtPiB2b2lkOgpjbGVhcldlaWdodHNCb3hlczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoxNDYtMTUxCiAgICAvLyBjbGVhcldlaWdodHNCb3hlcygKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhdWN0aW9uQXBwSUQ6IHVpbnQ2NCwKICAgIC8vICAgaXRlcmF0aW9uQW1vdW50OiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjE1MgogICAgLy8gYXNzZXJ0KEFwcGxpY2F0aW9uKGF1Y3Rpb25BcHBJRCkuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9DUkVBVE9SX05PVF9BVUNUSU9OX0ZBQ1RPUlkpCiAgICBzd2FwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI1CiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBBdWN0aW9uUGx1Z2luR2xvYmFsU3RhdGVLZXlGYWN0b3J5IH0pCiAgICBieXRlY18wIC8vICJhdWN0aW9uX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MTUyCiAgICAvLyBhc3NlcnQoQXBwbGljYXRpb24oYXVjdGlvbkFwcElEKS5jcmVhdG9yID09PSB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywgRVJSX0NSRUFUT1JfTk9UX0FVQ1RJT05fRkFDVE9SWSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIHVuY292ZXIgMgogICAgPT0KICAgIGFzc2VydCAvLyBDcmVhdG9yIGlzIG5vdCB0aGUgYXVjdGlvbiBmYWN0b3J5CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MTU1LTE2MAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQXVjdGlvbi5wcm90b3R5cGUuY2xlYXJXZWlnaHRzQm94ZXM+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbaXRlcmF0aW9uQW1vdW50XSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoxNTkKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciA0CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjE1NS0xNjAKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEF1Y3Rpb24ucHJvdG90eXBlLmNsZWFyV2VpZ2h0c0JveGVzPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZmFjdG9yeS52YWx1ZSwKICAgIC8vICAgYXJnczogW2l0ZXJhdGlvbkFtb3VudF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHgwNWU1ZGU0ZCAvLyBtZXRob2QgImNsZWFyV2VpZ2h0c0JveGVzKHVpbnQ2NCl1aW50NjQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMyAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MTQ2LTE1MQogICAgLy8gY2xlYXJXZWlnaHRzQm94ZXMoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXVjdGlvbkFwcElEOiB1aW50NjQsCiAgICAvLyAgIGl0ZXJhdGlvbkFtb3VudDogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIHJldHVybiAvLyBvbiBlcnJvcjogaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czo6QXVjdGlvblBsdWdpbi5kZWxldGVBdWN0aW9uQXBwW3JvdXRpbmddKCkgLT4gdm9pZDoKZGVsZXRlQXVjdGlvbkFwcDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoxNjMtMTY3CiAgICAvLyBkZWxldGVBdWN0aW9uQXBwKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbgogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGR1cAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjE3MAogICAgLy8gYXNzZXJ0KGFwcElkLmNyZWF0b3IgPT09IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLCBFUlJfQ1JFQVRPUl9OT1RfQVVDVElPTl9GQUNUT1JZKQogICAgYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyNQogICAgLy8gZmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogQXVjdGlvblBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAiYXVjdGlvbl9mYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjE3MAogICAgLy8gYXNzZXJ0KGFwcElkLmNyZWF0b3IgPT09IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLCBFUlJfQ1JFQVRPUl9OT1RfQVVDVElPTl9GQUNUT1JZKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgdW5jb3ZlciAyCiAgICA9PQogICAgYXNzZXJ0IC8vIENyZWF0b3IgaXMgbm90IHRoZSBhdWN0aW9uIGZhY3RvcnkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoxNzItMTc3CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBdWN0aW9uRmFjdG9yeS5wcm90b3R5cGUuZGVsZXRlQXVjdGlvbkFwcD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFthcHBJZF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MTc2CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgNAogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoxNzItMTc3CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBdWN0aW9uRmFjdG9yeS5wcm90b3R5cGUuZGVsZXRlQXVjdGlvbkFwcD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFthcHBJZF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHgxNzE0ZGE2NSAvLyBtZXRob2QgImRlbGV0ZUF1Y3Rpb25BcHAodWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjE2My0xNjcKICAgIC8vIGRlbGV0ZUF1Y3Rpb25BcHAoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6OkF1Y3Rpb25QbHVnaW4uYmlkW3JvdXRpbmddKCkgLT4gdm9pZDoKYmlkOgogICAgaW50Y18wIC8vIDAKICAgIHB1c2hieXRlcyAiIgogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MTgwLTE4NwogICAgLy8gYmlkKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbiwKICAgIC8vICAgYW1vdW50OiB1aW50NjQsCiAgICAvLyAgIGFyZ3M6IEdhdGVBcmdzLAogICAgLy8gICBtYXJrZXRwbGFjZTogQWNjb3VudAogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBjb3ZlciAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBjb3ZlciAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA2CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE2MS0xNjQKICAgIC8vIGNvbnN0IFtjb250cm9sbGVkQWNjb3VudEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXRJRCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MpCiAgICAvLyApCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTYzCiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcykKICAgIHB1c2hieXRlcyAiY29udHJvbGxlZF9hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNjEtMTY0CiAgICAvLyBjb25zdCBbY29udHJvbGxlZEFjY291bnRCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0SUQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMSAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTY5LTE3MgogICAgLy8gY29uc3QgW3JlZmVycmVyQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldElELAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNSZWZlcnJlcikKICAgIC8vICkKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNzEKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1JlZmVycmVyKQogICAgcHVzaGJ5dGVzICJyZWZlcnJlciIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTY5LTE3MgogICAgLy8gY29uc3QgW3JlZmVycmVyQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldElELAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNSZWZlcnJlcikKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjU4CiAgICAvLyB3YWxsZXRBZGRyZXNzOiB3YWxsZXQuYWRkcmVzcywKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjU3LTI2MgogICAgLy8gcmV0dXJuIHsKICAgIC8vICAgd2FsbGV0QWRkcmVzczogd2FsbGV0LmFkZHJlc3MsCiAgICAvLyAgIG9yaWdpbiwKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWZlcnJlcgogICAgLy8gfQogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoxODgKICAgIC8vIGNvbnN0IHsgb3JpZ2luLCBzZW5kZXIgfSA9IGdldEFjY291bnRzKHdhbGxldCkKICAgIGR1cAogICAgZXh0cmFjdCAzMiAzMgogICAgY292ZXIgMgogICAgZXh0cmFjdCA2NCAzMgogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjE5MAogICAgLy8gYXNzZXJ0KGFwcElkLmNyZWF0b3IgPT09IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLCBFUlJfQ1JFQVRPUl9OT1RfQVVDVElPTl9GQUNUT1JZKQogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI1CiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBBdWN0aW9uUGx1Z2luR2xvYmFsU3RhdGVLZXlGYWN0b3J5IH0pCiAgICBieXRlY18wIC8vICJhdWN0aW9uX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MTkwCiAgICAvLyBhc3NlcnQoYXBwSWQuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9DUkVBVE9SX05PVF9BVUNUSU9OX0ZBQ1RPUlkpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBDcmVhdG9yIGlzIG5vdCB0aGUgYXVjdGlvbiBmYWN0b3J5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MTkyCiAgICAvLyBjb25zdCB7IGJpZHMsIGJpZHNCeUFkZHJlc3MsIGxvY2F0aW9ucyB9ID0gdGhpcy5tYnIoKQogICAgcHVzaGludCAzNDkwMCAvLyAzNDkwMAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjE5NAogICAgLy8gY29uc3QgYmlkRmVlID0gYnRvaShvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhhcHBJZCwgQnl0ZXMoQXVjdGlvbkdsb2JhbFN0YXRlS2V5QmlkRmVlKSlbMF0pCiAgICBwdXNoYnl0ZXMgImJpZF9mZWUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MTk1CiAgICAvLyBpZiAoYmlkRmVlID4gMCkgewogICAgYm56IGJpZF9pZl9ib2R5QDIKICAgIGR1cAogICAgYnVyeSAxMAoKYmlkX2FmdGVyX2lmX2Vsc2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyMDgKICAgIC8vIGNvbnN0IGJpZEFzc2V0ID0gQXNzZXQoYnRvaShvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhhcHBJZCwgQnl0ZXMoQXVjdGlvbkdsb2JhbFN0YXRlS2V5QmlkQXNzZXQpKVswXSkpCiAgICBkaWcgNgogICAgcHVzaGJ5dGVzICJiaWRfYXNzZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBidG9pCiAgICBkdXAKICAgIGJ1cnkgMTIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyMDkKICAgIC8vIGlmIChiaWRBc3NldC5pZCA9PT0gMCkgewogICAgYm56IGJpZF9lbHNlX2JvZHlAMTYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyMTMKICAgIC8vIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgZGlnIDYKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyMTQKICAgIC8vIGFtb3VudDogYW1vdW50ICsgbWJyCiAgICBkaWcgNgogICAgZGlnIDExCiAgICArCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MjE3CiAgICAvLyBpZiAoYXJncy5sZW5ndGggPiAwKSB7CiAgICBkaWcgNgogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBieiBiaWRfZWxzZV9ib2R5QDEyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MjE4CiAgICAvLyBjb25zdCBnYXRlID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLmdhdGUKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzIgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyMTgKICAgIC8vIGNvbnN0IGdhdGUgPSBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuZ2F0ZQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDAKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBcHBMaXN0KSkKICAgIGJ5dGVjIDUgLy8gImFhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyMTgKICAgIC8vIGNvbnN0IGdhdGUgPSBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuZ2F0ZQogICAgcHVzaGludCA0MCAvLyA0MAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyMTkKICAgIC8vIGNvbnN0IGdhdGVJRCA9IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NChhcHBJZCwgQnl0ZXMoQXVjdGlvbkdsb2JhbFN0YXRlS2V5R2F0ZUlEKSlbMF0KICAgIGRpZyA5CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGJ5dGVjIDYgLy8gImdhdGVfaWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MjIxLTIzOQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQXVjdGlvbi5wcm90b3R5cGUuZ2F0ZWRCaWQ+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgaXR4bi5hcHBsaWNhdGlvbkNhbGwoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgYXBwSWQ6IGdhdGUsCiAgICAvLyAgICAgICBhcHBBcmdzOiBbCiAgICAvLyAgICAgICAgIG1ldGhvZFNlbGVjdG9yKEdhdGVNdXN0Q2hlY2tBYmlNZXRob2QpLAogICAgLy8gICAgICAgICBvcmlnaW4sCiAgICAvLyAgICAgICAgIGdhdGVJRCwKICAgIC8vICAgICAgICAgZW5jb2RlQXJjNChhcmdzKQogICAgLy8gICAgICAgXQogICAgLy8gICAgIH0pLAogICAgLy8gICAgIG1hcmtldHBsYWNlLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgdW5jb3ZlciA0CiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgNAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjIxMS0yMTUKICAgIC8vIGNvbnN0IG1iclBheW1lbnQgPSBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IGFtb3VudCArIG1icgogICAgLy8gfSkKICAgIGludGNfMiAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyMjYtMjM1CiAgICAvLyBpdHhuLmFwcGxpY2F0aW9uQ2FsbCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdhdGUsCiAgICAvLyAgIGFwcEFyZ3M6IFsKICAgIC8vICAgICBtZXRob2RTZWxlY3RvcihHYXRlTXVzdENoZWNrQWJpTWV0aG9kKSwKICAgIC8vICAgICBvcmlnaW4sCiAgICAvLyAgICAgZ2F0ZUlELAogICAgLy8gICAgIGVuY29kZUFyYzQoYXJncykKICAgIC8vICAgXQogICAgLy8gfSksCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyMzIKICAgIC8vIGdhdGVJRCwKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyMzAKICAgIC8vIG1ldGhvZFNlbGVjdG9yKEdhdGVNdXN0Q2hlY2tBYmlNZXRob2QpLAogICAgYnl0ZWMgNyAvLyBtZXRob2QgIm11c3RDaGVjayhhZGRyZXNzLHVpbnQ2NCxieXRlW11bXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA3CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgc3dhcAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MjI2LTIzNQogICAgLy8gaXR4bi5hcHBsaWNhdGlvbkNhbGwoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBnYXRlLAogICAgLy8gICBhcHBBcmdzOiBbCiAgICAvLyAgICAgbWV0aG9kU2VsZWN0b3IoR2F0ZU11c3RDaGVja0FiaU1ldGhvZCksCiAgICAvLyAgICAgb3JpZ2luLAogICAgLy8gICAgIGdhdGVJRCwKICAgIC8vICAgICBlbmNvZGVBcmM0KGFyZ3MpCiAgICAvLyAgIF0KICAgIC8vIH0pLAogICAgaW50Y18zIC8vIDYKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjIyMS0yMzkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEF1Y3Rpb24ucHJvdG90eXBlLmdhdGVkQmlkPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJQYXltZW50LAogICAgLy8gICAgIGl0eG4uYXBwbGljYXRpb25DYWxsKHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIGFwcElkOiBnYXRlLAogICAgLy8gICAgICAgYXBwQXJnczogWwogICAgLy8gICAgICAgICBtZXRob2RTZWxlY3RvcihHYXRlTXVzdENoZWNrQWJpTWV0aG9kKSwKICAgIC8vICAgICAgICAgb3JpZ2luLAogICAgLy8gICAgICAgICBnYXRlSUQsCiAgICAvLyAgICAgICAgIGVuY29kZUFyYzQoYXJncykKICAgIC8vICAgICAgIF0KICAgIC8vICAgICB9KSwKICAgIC8vICAgICBtYXJrZXRwbGFjZSwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjIzOAogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgZGlnIDkKICAgIGRpZyAxMQogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyMjEtMjM5CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBdWN0aW9uLnByb3RvdHlwZS5nYXRlZEJpZD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICBpdHhuLmFwcGxpY2F0aW9uQ2FsbCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICBhcHBJZDogZ2F0ZSwKICAgIC8vICAgICAgIGFwcEFyZ3M6IFsKICAgIC8vICAgICAgICAgbWV0aG9kU2VsZWN0b3IoR2F0ZU11c3RDaGVja0FiaU1ldGhvZCksCiAgICAvLyAgICAgICAgIG9yaWdpbiwKICAgIC8vICAgICAgICAgZ2F0ZUlELAogICAgLy8gICAgICAgICBlbmNvZGVBcmM0KGFyZ3MpCiAgICAvLyAgICAgICBdCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgbWFya2V0cGxhY2UsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHg5ODM2Yzg5ZiAvLyBtZXRob2QgImdhdGVkQmlkKHBheSxhcHBsLGFkZHJlc3Mpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKCmJpZF9hZnRlcl9pZl9lbHNlQDI3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjE4MC0xODcKICAgIC8vIGJpZCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24sCiAgICAvLyAgIGFtb3VudDogdWludDY0LAogICAgLy8gICBhcmdzOiBHYXRlQXJncywKICAgIC8vICAgbWFya2V0cGxhY2U6IEFjY291bnQKICAgIC8vICk6IHZvaWQgewogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKYmlkX2Vsc2VfYm9keUAxMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyNDEtMjQ5CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBdWN0aW9uLnByb3RvdHlwZS5iaWQ+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgbWFya2V0cGxhY2UsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgZGlnIDEKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyMTEtMjE1CiAgICAvLyBjb25zdCBtYnJQYXltZW50ID0gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBhbW91bnQgKyBtYnIKICAgIC8vIH0pCiAgICBpbnRjXzIgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MjQxLTI0OQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQXVjdGlvbi5wcm90b3R5cGUuYmlkPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJQYXltZW50LAogICAgLy8gICAgIG1hcmtldHBsYWNlLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MjQ4CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICBkaWcgOAogICAgZGlnIDEwCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI0MS0yNDkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEF1Y3Rpb24ucHJvdG90eXBlLmJpZD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICBtYXJrZXRwbGFjZSwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDRkNTg1Njk3IC8vIG1ldGhvZCAiYmlkKHBheSxhZGRyZXNzKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGRpZyA3CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgYiBiaWRfYWZ0ZXJfaWZfZWxzZUAyNwoKYmlkX2Vsc2VfYm9keUAxNjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyNTQKICAgIC8vIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgZGlnIDYKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgc3dhcAogICAgYnVyeSAxNAogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI2MAogICAgLy8gYXNzZXRSZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyNjUKICAgIC8vIGlmIChhcmdzLmxlbmd0aCA+IDApIHsKICAgIGRpZyA1CiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGJ6IGJpZF9lbHNlX2JvZHlAMjIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyNjYKICAgIC8vIGNvbnN0IGdhdGUgPSBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuZ2F0ZQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI2NgogICAgLy8gY29uc3QgZ2F0ZSA9IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5nYXRlCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWMgNSAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI2NgogICAgLy8gY29uc3QgZ2F0ZSA9IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5nYXRlCiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI2NwogICAgLy8gY29uc3QgZ2F0ZUlEID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KGFwcElkLCBCeXRlcyhBdWN0aW9uR2xvYmFsU3RhdGVLZXlHYXRlSUQpKVswXQogICAgZGlnIDgKICAgIGR1cAogICAgY292ZXIgMgogICAgYnl0ZWMgNiAvLyAiZ2F0ZV9pZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyNjktMjg4CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBdWN0aW9uLnByb3RvdHlwZS5nYXRlZEJpZEFzYT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyVHhuLAogICAgLy8gICAgIHhmZXJUeG4sCiAgICAvLyAgICAgaXR4bi5hcHBsaWNhdGlvbkNhbGwoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgYXBwSWQ6IGdhdGUsCiAgICAvLyAgICAgICBhcHBBcmdzOiBbCiAgICAvLyAgICAgICAgIG1ldGhvZFNlbGVjdG9yKEdhdGVNdXN0Q2hlY2tBYmlNZXRob2QpLAogICAgLy8gICAgICAgICBvcmlnaW4sCiAgICAvLyAgICAgICAgIGdhdGVJRCwKICAgIC8vICAgICAgICAgZW5jb2RlQXJjNChhcmdzKQogICAgLy8gICAgICAgXQogICAgLy8gICAgIH0pLAogICAgLy8gICAgIG1hcmtldHBsYWNlLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgZGlnIDEzCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgZGlnIDE1CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgNQogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI1Mi0yNTYKICAgIC8vIGNvbnN0IG1iclR4biA9IGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogbWJyCiAgICAvLyB9KQogICAgaW50Y18yIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI3NAogICAgLy8geGZlclR4biwKICAgIGl0eG5fbmV4dAogICAgZGlnIDE1CiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgZGlnIDEwCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICB1bmNvdmVyIDQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI1OC0yNjMKICAgIC8vIGNvbnN0IHhmZXJUeG4gPSBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgIHhmZXJBc3NldDogYmlkQXNzZXQKICAgIC8vIH0pCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6Mjc1LTI4NAogICAgLy8gaXR4bi5hcHBsaWNhdGlvbkNhbGwoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBnYXRlLAogICAgLy8gICBhcHBBcmdzOiBbCiAgICAvLyAgICAgbWV0aG9kU2VsZWN0b3IoR2F0ZU11c3RDaGVja0FiaU1ldGhvZCksCiAgICAvLyAgICAgb3JpZ2luLAogICAgLy8gICAgIGdhdGVJRCwKICAgIC8vICAgICBlbmNvZGVBcmM0KGFyZ3MpCiAgICAvLyAgIF0KICAgIC8vIH0pLAogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MjgxCiAgICAvLyBnYXRlSUQsCiAgICBzd2FwCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6Mjc5CiAgICAvLyBtZXRob2RTZWxlY3RvcihHYXRlTXVzdENoZWNrQWJpTWV0aG9kKSwKICAgIGJ5dGVjIDcgLy8gbWV0aG9kICJtdXN0Q2hlY2soYWRkcmVzcyx1aW50NjQsYnl0ZVtdW10pdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI3NS0yODQKICAgIC8vIGl0eG4uYXBwbGljYXRpb25DYWxsKHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogZ2F0ZSwKICAgIC8vICAgYXBwQXJnczogWwogICAgLy8gICAgIG1ldGhvZFNlbGVjdG9yKEdhdGVNdXN0Q2hlY2tBYmlNZXRob2QpLAogICAgLy8gICAgIG9yaWdpbiwKICAgIC8vICAgICBnYXRlSUQsCiAgICAvLyAgICAgZW5jb2RlQXJjNChhcmdzKQogICAgLy8gICBdCiAgICAvLyB9KSwKICAgIGludGNfMyAvLyA2CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyNjktMjg4CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBdWN0aW9uLnByb3RvdHlwZS5nYXRlZEJpZEFzYT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyVHhuLAogICAgLy8gICAgIHhmZXJUeG4sCiAgICAvLyAgICAgaXR4bi5hcHBsaWNhdGlvbkNhbGwoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgYXBwSWQ6IGdhdGUsCiAgICAvLyAgICAgICBhcHBBcmdzOiBbCiAgICAvLyAgICAgICAgIG1ldGhvZFNlbGVjdG9yKEdhdGVNdXN0Q2hlY2tBYmlNZXRob2QpLAogICAgLy8gICAgICAgICBvcmlnaW4sCiAgICAvLyAgICAgICAgIGdhdGVJRCwKICAgIC8vICAgICAgICAgZW5jb2RlQXJjNChhcmdzKQogICAgLy8gICAgICAgXQogICAgLy8gICAgIH0pLAogICAgLy8gICAgIG1hcmtldHBsYWNlLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6Mjg3CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICBkaWcgOQogICAgZGlnIDExCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI2OS0yODgKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEF1Y3Rpb24ucHJvdG90eXBlLmdhdGVkQmlkQXNhPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJUeG4sCiAgICAvLyAgICAgeGZlclR4biwKICAgIC8vICAgICBpdHhuLmFwcGxpY2F0aW9uQ2FsbCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICBhcHBJZDogZ2F0ZSwKICAgIC8vICAgICAgIGFwcEFyZ3M6IFsKICAgIC8vICAgICAgICAgbWV0aG9kU2VsZWN0b3IoR2F0ZU11c3RDaGVja0FiaU1ldGhvZCksCiAgICAvLyAgICAgICAgIG9yaWdpbiwKICAgIC8vICAgICAgICAgZ2F0ZUlELAogICAgLy8gICAgICAgICBlbmNvZGVBcmM0KGFyZ3MpCiAgICAvLyAgICAgICBdCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgbWFya2V0cGxhY2UsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHhkOWY0ZjAzYSAvLyBtZXRob2QgImdhdGVkQmlkQXNhKHBheSxheGZlcixhcHBsLGFkZHJlc3Mpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGIgYmlkX2FmdGVyX2lmX2Vsc2VAMjcKCmJpZF9lbHNlX2JvZHlAMjI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MjkwLTI5OQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQXVjdGlvbi5wcm90b3R5cGUuYmlkQXNhPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJUeG4sCiAgICAvLyAgICAgeGZlclR4biwKICAgIC8vICAgICBtYXJrZXRwbGFjZSwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIGRpZyAxMAogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGRpZyAxMgogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZGlnIDIKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyNTItMjU2CiAgICAvLyBjb25zdCBtYnJUeG4gPSBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IG1icgogICAgLy8gfSkKICAgIGludGNfMiAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyOTUKICAgIC8vIHhmZXJUeG4sCiAgICBpdHhuX25leHQKICAgIGRpZyAxMgogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIGRpZyA3CiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyNTgtMjYzCiAgICAvLyBjb25zdCB4ZmVyVHhuID0gaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhc3NldFJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gICB4ZmVyQXNzZXQ6IGJpZEFzc2V0CiAgICAvLyB9KQogICAgcHVzaGludCA0IC8vIDQKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI5MC0yOTkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEF1Y3Rpb24ucHJvdG90eXBlLmJpZEFzYT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyVHhuLAogICAgLy8gICAgIHhmZXJUeG4sCiAgICAvLyAgICAgbWFya2V0cGxhY2UsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyOTgKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIGRpZyA4CiAgICBkaWcgMTAKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MjkwLTI5OQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQXVjdGlvbi5wcm90b3R5cGUuYmlkQXNhPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJUeG4sCiAgICAvLyAgICAgeGZlclR4biwKICAgIC8vICAgICBtYXJrZXRwbGFjZSwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDc2OTUyOTMxIC8vIG1ldGhvZCAiYmlkQXNhKHBheSxheGZlcixhZGRyZXNzKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGRpZyA3CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgYiBiaWRfYWZ0ZXJfaWZfZWxzZUAyNwoKYmlkX2lmX2JvZHlAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoxOTYtMjAxCiAgICAvLyBjb25zdCBoYXNCaWQgPSBhYmlDYWxsPHR5cGVvZiBBdWN0aW9uLnByb3RvdHlwZS5oYXNCaWQ+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtzZW5kZXJdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjIwMAogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgZGlnIDcKICAgIGRpZyA5CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjE5Ni0yMDEKICAgIC8vIGNvbnN0IGhhc0JpZCA9IGFiaUNhbGw8dHlwZW9mIEF1Y3Rpb24ucHJvdG90eXBlLmhhc0JpZD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBhcHBJZCwKICAgIC8vICAgYXJnczogW3NlbmRlcl0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBwdXNoYnl0ZXMgMHg2MDgyMzAzYyAvLyBtZXRob2QgImhhc0JpZChhZGRyZXNzKWJvb2wiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDIKICAgIGR1cAogICAgY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgZGlnIDcKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18zIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjIwMwogICAgLy8gaWYgKCFoYXNCaWQpIHsKICAgIGJ6IGJpZF9pZl9ib2R5QDQKICAgIGR1cAogICAgYnVyeSAxMAogICAgYiBiaWRfYWZ0ZXJfaWZfZWxzZUA2CgpiaWRfaWZfYm9keUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjIwNAogICAgLy8gbWJyICs9IChiaWRzQnlBZGRyZXNzICsgbG9jYXRpb25zKQogICAgcHVzaGludCA3MjMwMCAvLyA3MjMwMAogICAgYnVyeSAxMAogICAgYiBiaWRfYWZ0ZXJfaWZfZWxzZUA2CgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjpBdWN0aW9uUGx1Z2luLnJlZnVuZEJpZFtyb3V0aW5nXSgpIC0+IHZvaWQ6CnJlZnVuZEJpZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czozMDQtMzA5CiAgICAvLyByZWZ1bmRCaWQoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICBpZDogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMSAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czozMTIKICAgIC8vIGFzc2VydChhcHBJZC5jcmVhdG9yID09PSB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywgRVJSX0NSRUFUT1JfTk9UX0FVQ1RJT05fRkFDVE9SWSkKICAgIGRpZyAxCiAgICBhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI1CiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBBdWN0aW9uUGx1Z2luR2xvYmFsU3RhdGVLZXlGYWN0b3J5IH0pCiAgICBieXRlY18wIC8vICJhdWN0aW9uX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MzEyCiAgICAvLyBhc3NlcnQoYXBwSWQuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9DUkVBVE9SX05PVF9BVUNUSU9OX0ZBQ1RPUlkpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBDcmVhdG9yIGlzIG5vdCB0aGUgYXVjdGlvbiBmYWN0b3J5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MzE0LTMxOQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQXVjdGlvbi5wcm90b3R5cGUucmVmdW5kQmlkPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtpZF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MzE4CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgNAogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czozMTQtMzE5CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBdWN0aW9uLnByb3RvdHlwZS5yZWZ1bmRCaWQ+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW2lkXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweGI5ZTM5YzVjIC8vIG1ldGhvZCAicmVmdW5kQmlkKHVpbnQ2NCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MzA0LTMwOQogICAgLy8gcmVmdW5kQmlkKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbiwKICAgIC8vICAgaWQ6IHVpbnQ2NAogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjpBdWN0aW9uUGx1Z2luLmNsYWltUHJpemVbcm91dGluZ10oKSAtPiB2b2lkOgpjbGFpbVByaXplOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjMyMi0zMjYKICAgIC8vIGNsYWltUHJpemUoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uCiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjMyOQogICAgLy8gYXNzZXJ0KGFwcElkLmNyZWF0b3IgPT09IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLCBFUlJfQ1JFQVRPUl9OT1RfQVVDVElPTl9GQUNUT1JZKQogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI1CiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBBdWN0aW9uUGx1Z2luR2xvYmFsU3RhdGVLZXlGYWN0b3J5IH0pCiAgICBieXRlY18wIC8vICJhdWN0aW9uX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MzI5CiAgICAvLyBhc3NlcnQoYXBwSWQuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9DUkVBVE9SX05PVF9BVUNUSU9OX0ZBQ1RPUlkpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBDcmVhdG9yIGlzIG5vdCB0aGUgYXVjdGlvbiBmYWN0b3J5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MzMxLTMzNQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQXVjdGlvbi5wcm90b3R5cGUuY2xhaW1Qcml6ZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjMzNAogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgc3dhcAogICAgdW5jb3ZlciAzCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjMzMS0zMzUKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEF1Y3Rpb24ucHJvdG90eXBlLmNsYWltUHJpemU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDlkYWYwNTBhIC8vIG1ldGhvZCAiY2xhaW1Qcml6ZSgpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MzIyLTMyNgogICAgLy8gY2xhaW1Qcml6ZSgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24KICAgIC8vICk6IHZvaWQgewogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czo6QXVjdGlvblBsdWdpbi5jbGFpbVJhZmZsZVByaXplW3JvdXRpbmddKCkgLT4gdm9pZDoKY2xhaW1SYWZmbGVQcml6ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czozMzgtMzQyCiAgICAvLyBjbGFpbVJhZmZsZVByaXplKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbgogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMSAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czozNDUKICAgIC8vIGFzc2VydChhcHBJZC5jcmVhdG9yID09PSB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywgRVJSX0NSRUFUT1JfTk9UX0FVQ1RJT05fRkFDVE9SWSkKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czoyNQogICAgLy8gZmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogQXVjdGlvblBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAiYXVjdGlvbl9mYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjM0NQogICAgLy8gYXNzZXJ0KGFwcElkLmNyZWF0b3IgPT09IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLCBFUlJfQ1JFQVRPUl9OT1RfQVVDVElPTl9GQUNUT1JZKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gQ3JlYXRvciBpcyBub3QgdGhlIGF1Y3Rpb24gZmFjdG9yeQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjM0Ny0zNTEKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEF1Y3Rpb24ucHJvdG90eXBlLmNsYWltUmFmZmxlUHJpemU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czozNTAKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIHN3YXAKICAgIHVuY292ZXIgMwogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czozNDctMzUxCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBdWN0aW9uLnByb3RvdHlwZS5jbGFpbVJhZmZsZVByaXplPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHg2NWZjYTk4YiAvLyBtZXRob2QgImNsYWltUmFmZmxlUHJpemUoKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjMzOC0zNDIKICAgIC8vIGNsYWltUmFmZmxlUHJpemUoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6OkF1Y3Rpb25QbHVnaW4ucmFmZmxlW3JvdXRpbmddKCkgLT4gdm9pZDoKcmFmZmxlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjM1NC0zNTgKICAgIC8vIHJhZmZsZSgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24KICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MzU5CiAgICAvLyBhc3NlcnQoYXBwSWQuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9DUkVBVE9SX05PVF9BVUNUSU9OX0ZBQ1RPUlkpCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcENyZWF0b3IKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MjUKICAgIC8vIGZhY3RvcnkgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEF1Y3Rpb25QbHVnaW5HbG9iYWxTdGF0ZUtleUZhY3RvcnkgfSkKICAgIGJ5dGVjXzAgLy8gImF1Y3Rpb25fZmFjdG9yeSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czozNTkKICAgIC8vIGFzc2VydChhcHBJZC5jcmVhdG9yID09PSB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywgRVJSX0NSRUFUT1JfTk9UX0FVQ1RJT05fRkFDVE9SWSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIENyZWF0b3IgaXMgbm90IHRoZSBhdWN0aW9uIGZhY3RvcnkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMSAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czozNjItMzY2CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBdWN0aW9uLnByb3RvdHlwZS5yYWZmbGU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czozNjUKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIHVuY292ZXIgMgogICAgdW5jb3ZlciAzCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjM2Mi0zNjYKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEF1Y3Rpb24ucHJvdG90eXBlLnJhZmZsZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4Njk2NTAxZGUgLy8gbWV0aG9kICJyYWZmbGUoKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjM1NC0zNTgKICAgIC8vIHJhZmZsZSgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24KICAgIC8vICk6IHZvaWQgewogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czo6QXVjdGlvblBsdWdpbi5maW5kV2lubmVyW3JvdXRpbmddKCkgLT4gdm9pZDoKZmluZFdpbm5lcjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czozNjktMzc0CiAgICAvLyBmaW5kV2lubmVyKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGF1Y3Rpb25BcHBJRDogdWludDY0LAogICAgLy8gICBpdGVyYXRpb25BbW91bnQ6IHVpbnQ2NAogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBjb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6Mzc3CiAgICAvLyBhc3NlcnQoQXBwbGljYXRpb24oYXVjdGlvbkFwcElEKS5jcmVhdG9yID09PSB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywgRVJSX0NSRUFUT1JfTk9UX0FVQ1RJT05fRkFDVE9SWSkKICAgIGRpZyAxCiAgICBhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI1CiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBBdWN0aW9uUGx1Z2luR2xvYmFsU3RhdGVLZXlGYWN0b3J5IH0pCiAgICBieXRlY18wIC8vICJhdWN0aW9uX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6Mzc3CiAgICAvLyBhc3NlcnQoQXBwbGljYXRpb24oYXVjdGlvbkFwcElEKS5jcmVhdG9yID09PSB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywgRVJSX0NSRUFUT1JfTk9UX0FVQ1RJT05fRkFDVE9SWSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIENyZWF0b3IgaXMgbm90IHRoZSBhdWN0aW9uIGZhY3RvcnkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czozNzktMzg0CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBdWN0aW9uLnByb3RvdHlwZS5maW5kV2lubmVyPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGF1Y3Rpb25BcHBJRCwKICAgIC8vICAgYXJnczogW2l0ZXJhdGlvbkFtb3VudF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MzgzCiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgNAogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czozNzktMzg0CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBdWN0aW9uLnByb3RvdHlwZS5maW5kV2lubmVyPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGF1Y3Rpb25BcHBJRCwKICAgIC8vICAgYXJnczogW2l0ZXJhdGlvbkFtb3VudF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHhiZDFiMjdkMSAvLyBtZXRob2QgImZpbmRXaW5uZXIodWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czozNjktMzc0CiAgICAvLyBmaW5kV2lubmVyKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGF1Y3Rpb25BcHBJRDogdWludDY0LAogICAgLy8gICBpdGVyYXRpb25BbW91bnQ6IHVpbnQ2NAogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjpBdWN0aW9uUGx1Z2luLmRlbGV0ZUFwcGxpY2F0aW9uW3JvdXRpbmddKCkgLT4gdm9pZDoKZGVsZXRlQXBwbGljYXRpb246CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6Mzg3LTM5MQogICAgLy8gZGVsZXRlQXBwbGljYXRpb24oCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uCiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjM5NAogICAgLy8gYXNzZXJ0KGFwcElkLmNyZWF0b3IgPT09IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLCBFUlJfQ1JFQVRPUl9OT1RfQVVDVElPTl9GQUNUT1JZKQogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjI1CiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBBdWN0aW9uUGx1Z2luR2xvYmFsU3RhdGVLZXlGYWN0b3J5IH0pCiAgICBieXRlY18wIC8vICJhdWN0aW9uX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6Mzk0CiAgICAvLyBhc3NlcnQoYXBwSWQuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9DUkVBVE9SX05PVF9BVUNUSU9OX0ZBQ1RPUlkpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBDcmVhdG9yIGlzIG5vdCB0aGUgYXVjdGlvbiBmYWN0b3J5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6Mzk2LTQwMAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQXVjdGlvbi5wcm90b3R5cGUuZGVsZXRlQXBwbGljYXRpb24+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czozOTkKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIHN3YXAKICAgIHVuY292ZXIgMwogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czozOTYtNDAwCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBdWN0aW9uLnByb3RvdHlwZS5kZWxldGVBcHBsaWNhdGlvbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4MjQ4N2MzMmMgLy8gbWV0aG9kICJkZWxldGVBcHBsaWNhdGlvbigpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6Mzg3LTM5MQogICAgLy8gZGVsZXRlQXBwbGljYXRpb24oCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6OkF1Y3Rpb25QbHVnaW4uY2FuY2VsW3JvdXRpbmddKCkgLT4gdm9pZDoKY2FuY2VsOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvYXVjdGlvbi9jb250cmFjdC5hbGdvLnRzOjQwMy00MDcKICAgIC8vIGNhbmNlbCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24KICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBjb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6NDEwCiAgICAvLyBhc3NlcnQoYXBwSWQuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9DUkVBVE9SX05PVF9BVUNUSU9OX0ZBQ1RPUlkpCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcENyZWF0b3IKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9hdWN0aW9uL2NvbnRyYWN0LmFsZ28udHM6MjUKICAgIC8vIGZhY3RvcnkgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEF1Y3Rpb25QbHVnaW5HbG9iYWxTdGF0ZUtleUZhY3RvcnkgfSkKICAgIGJ5dGVjXzAgLy8gImF1Y3Rpb25fZmFjdG9yeSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czo0MTAKICAgIC8vIGFzc2VydChhcHBJZC5jcmVhdG9yID09PSB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywgRVJSX0NSRUFUT1JfTk9UX0FVQ1RJT05fRkFDVE9SWSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIENyZWF0b3IgaXMgbm90IHRoZSBhdWN0aW9uIGZhY3RvcnkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czo0MTItNDE2CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBdWN0aW9uLnByb3RvdHlwZS5jYW5jZWw+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czo0MTUKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIHN3YXAKICAgIHVuY292ZXIgMwogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czo0MTItNDE2CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBdWN0aW9uLnByb3RvdHlwZS5jYW5jZWw+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDMxZjI2YTliIC8vIG1ldGhvZCAiY2FuY2VsKCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2F1Y3Rpb24vY29udHJhY3QuYWxnby50czo0MDMtNDA3CiAgICAvLyBjYW5jZWwoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo6QWtpdGFCYXNlQ29udHJhY3QudXBkYXRlQWtpdGFEQU9bcm91dGluZ10oKSAtPiB2b2lkOgp1cGRhdGVBa2l0YURBTzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjM4CiAgICAvLyB1cGRhdGVBa2l0YURBTyhha2l0YURBTzogQXBwbGljYXRpb24pOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozOQogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMyCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzIgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMyCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBwdXNoYnl0ZXMgIndhbGxldCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjM5CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5nZXRBa2l0YURBT1dhbGxldCgpLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IHRoZSBBa2l0YSBEQU8gY2FuIGNhbGwgdGhpcyBmdW5jdGlvbgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18yIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo0MAogICAgLy8gdGhpcy5ha2l0YURBTy52YWx1ZSA9IGFraXRhREFPCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzgKICAgIC8vIHVwZGF0ZUFraXRhREFPKGFraXRhREFPOiBBcHBsaWNhdGlvbik6IHZvaWQgewogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgo=", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyAEAAgBBiYID2F1Y3Rpb25fZmFjdG9yeRBzcGVuZGluZ19hZGRyZXNzCWFraXRhX2RhbwQVH3x1BDlOrrIDYWFsB2dhdGVfaWQEQ5ImVYAEvt/JOzYaAI4BAKUxGRREMRhBAI6CDQSeC5B9BIudXpME4k270gS8z7pJBG5EIusEKRbb/QS9MgRlBKQ4XhsEDuVj5wSR20jwBDPpLJQEhU3t4ARzERBwNhoAjg0AjwKKAvYDTAXmBkAGjgbcByoH0gggACoAAQCAJBUffHUAAAAAAACIVAAAAAAAyBfUAAAAAAAASEQAAAAAAABJ1LAkQyRDgASIyUD4NhoAjgEAHgAxGYEFEjEYEERCBz6KAgGL/kAAAzIDiYv/cghEiTYaAUkiWYECCEsBFRJEVwIANhoCSRUjEkQXNhoDSRUjEkQXgAd2ZXJzaW9uTwNnKE8CZypMZyRDNhoBSRUjEkQXSTYaAkkVJBJEIlNMNhoDSU4CSRUjEkQXSU4CNhoESRUjEkQXSU4DNhoFSU4ESSJZgQIITBUSRDYaBklOBEkiWYEgC4ECCEwVEkQ2GgdJTgRJFSMSRBdOAzYaCElOBBUjEkQ2GglJTgQVIxJENhoKSU4EFSMSRDYaC0lOBBUjEkQ2GgxJTgQVIxJENhoNSU4EFSMSRDYaDklOBBWBIBJENhoPSU4ESRUjEkQXTgNPAillSElOA0sCREsCcABIDkQiKGVEcghETHAARQFAAC6xIihlRElyCEQyELIIsgdLAUmyACSyECKyAbYnBLIaSxKyGrIAshglshAisgGzIihlRHIIREsLcABFAUAALrEiKGVESXIIRDIQsgiyB0sBSbIAJLIQIrIBticEshpLDbIasgCyGCWyECKyAbNLCkAAqzIQgdiNYTIBCAhLAoHUr6AGCwgiKGVESXIIREsBcghEsU8DsghMsgdLAkmyACSyECKyAbZLErIRSxGyEkyyFEmyAIEEshAisgG2SxNLFYj+HoAE0VSP/7IaSxCyGksPshpLDrIaSwyyGksLshpLCrIaSwmyGksIshpLB7IaSwayGksFshqyILIAshglshAisgGztwI+SVcEAExXAAQrEkRJFSMSRCtMULAkQzIQgQILQv9PNhoBSRUjEkQXNhoCSRUkEkQiUzYaA0kVIxJEFzYaBEkVIxJETHIHRCIoZURJcghETwISREsDKWVITLFPA08EiP16gAQF5d5NshpPA7IasiCyGLIAJbIQIrIBs7Q+SVcEAExXAAQrEkQVIxJDNhoBSRUjEkQXNhoCSRUkEkQiUzYaA0kVIxJESRdLAyllSE4CcgdEIihlRElyCERPAhJEsU8DTwSI/RWABBcU2mWyGk8CshqyILIYsgAlshAisgGzJEMigABJNhoBSRUjEkQXSTYaAkkVJBJEIlNMNhoDSRUjEkQXSU8CNhoESRUjEkQXTgI2GgVOAjYaBklOAxWBIBJESYASY29udHJvbGxlZF9hZGRyZXNzZUhMSSllSExJgAhyZWZlcnJlcmVITHIIRE8DUE8CUExQSVcgIE4CV0AgTElyB0QiKGVEcghEEkSB1JACTIAHYmlkX2ZlZWVIF0ABrUlFCksGgAliaWRfYXNzZXRlSBdJRQxAALFLBnIIREsGSwsITEsGIllBAGkiKmVEJwVlSIEoW0sJSU4CJwZlSLFPBLIITwOyB0sESU4CsgAkshAisgG2FicHshpLBrIashpLB7IaTLIYSbIAJbIQIrIBtksJSwuI++CABJg2yJ+yGksGshqyILIAshglshAisgGzJEOxsgeyCEsBSbIAJLIQIrIBtksISwqI+62ABE1YVpeyGksFshqyIEsHshiyACWyECKyAbNC/8hLBklyCExFDkRyCERLBSJZQQCAIiplRCcFZUiBKFtLCElOAicGZUixSw2yCEsPsgdLBUmyACSyECKyAbZLD7IRSwqyEk8EshRJsgCBBLIQIrIBtkwWJweyGksGshqyGksHshpMshhJsgAlshAisgG2SwlLC4j7GIAE2fTwOrIaSwayGrIgsgCyGCWyECKyAbNC/zWxSwqyCEsMsgdLAkmyACSyECKyAbZLDLIRSweyEkyyFEmyAIEEshAisgG2SwhLCoj6yoAEdpUpMbIaSwWyGrIgSweyGLIAJbIQIrIBs0L+5bFLB0sJiPqkgARggjA8shpLAklOArIasiBLB7IYsgAlshAisgGztD5JVwQATFcABCsSREkVJBJEIlNBAAZJRQpC/hOB7LQERQpC/go2GgFJFSMSRBc2GgJJFSQSRCJTNhoDSRUjEkQXNhoESRUjEkRLAyllSE4CSwFyB0QiKGVEcghEEkSxTwNPBIj6H4AEueOcXLIasiCyGrIYsgAlshAisgGzJEM2GgFJFSMSRBc2GgJJFSQSRCJTNhoDSRUjEkQXSwIpZUhOAklyB0QiKGVEcghEEkSxTE8DiPnPgASdrwUKshqyILIYsgAlshAisgGzJEM2GgFJFSMSRBc2GgJJFSQSRCJTNhoDSRUjEkQXSwIpZUhOAklyB0QiKGVEcghEEkSxTE8DiPmBgARl/KmLshqyILIYsgAlshAisgGzJEM2GgFJFSMSRBc2GgJJFSQSRCJTNhoDSRUjEkQXSXIHRCIoZURyCEQSREsCKWVITLFPAk8DiPkzgARpZQHeshqyILIYsgAlshAisgGzJEM2GgFJFSMSRBc2GgJJFSQSRCJTNhoDSRUjEkQXNhoESRUjEkRLAyllSE4CSwFyB0QiKGVEcghEEkSxTwNPBIj424AEvRsn0bIasiCyGrIYsgAlshAisgGzJEM2GgFJFSMSRBc2GgJJFSQSRCJTNhoDSRUjEkQXSwIpZUhOAklyB0QiKGVEcghEEkSxTE8DiPiLgAQkh8MsshqyILIYsgAlshAisgGzJEM2GgFJFSMSRBc2GgJJFSQSRCJTNhoDSRUjEkQXSwIpZUhOAklyB0QiKGVEcghEEkSxTE8DiPg9gAQx8mqbshqyILIYsgAlshAisgGzJEM2GgFJFSMSRBcxACIqZUSABndhbGxldGVIcghEEkQqTGckQw==", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var AuctionPluginParamsFactory = class _AuctionPluginParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "create":
          case "create(string,uint64,uint64)void":
            return _AuctionPluginParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs create ABI call params for the AuctionPlugin smart contract using the create(string,uint64,uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params) {
        return {
          ...params,
          method: "create(string,uint64,uint64)void",
          args: Array.isArray(params.args) ? params.args : [params.args.version, params.args.factory, params.args.akitaDao]
        };
      }
    };
  }
  /**
   * Gets available delete ABI call param factories
   */
  static get delete() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "deleteApplication":
          case "deleteApplication(uint64,bool,uint64)void":
            return _AuctionPluginParamsFactory.delete.deleteApplication(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs delete ABI call params for the AuctionPlugin smart contract using the deleteApplication(uint64,bool,uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      deleteApplication(params) {
        return {
          ...params,
          method: "deleteApplication(uint64,bool,uint64)void",
          args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId]
        };
      }
    };
  }
  /**
   * Constructs a no op call for the new(uint64,bool,uint64,uint64,string,byte[32][],uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,uint64)uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static new(params) {
    return {
      ...params,
      method: "new(uint64,bool,uint64,uint64,string,byte[32][],uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,uint64)uint64",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.prizeId, params.args.prizeAmount, params.args.name, params.args.proof, params.args.bidAssetId, params.args.bidFee, params.args.startingBid, params.args.bidMinimumIncrease, params.args.startTimestamp, params.args.endtimestamp, params.args.gateId, params.args.marketplace, params.args.weightsListCount]
    };
  }
  /**
   * Constructs a no op call for the clearWeightsBoxes(uint64,bool,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static clearWeightsBoxes(params) {
    return {
      ...params,
      method: "clearWeightsBoxes(uint64,bool,uint64,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.auctionAppId, params.args.iterationAmount]
    };
  }
  /**
   * Constructs a no op call for the deleteAuctionApp(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static deleteAuctionApp(params) {
    return {
      ...params,
      method: "deleteAuctionApp(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId]
    };
  }
  /**
   * Constructs a no op call for the bid(uint64,bool,uint64,uint64,byte[][],address)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static bid(params) {
    return {
      ...params,
      method: "bid(uint64,bool,uint64,uint64,byte[][],address)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.amount, params.args.args, params.args.marketplace]
    };
  }
  /**
   * Constructs a no op call for the refundBid(uint64,bool,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static refundBid(params) {
    return {
      ...params,
      method: "refundBid(uint64,bool,uint64,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.id]
    };
  }
  /**
   * Constructs a no op call for the claimPrize(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static claimPrize(params) {
    return {
      ...params,
      method: "claimPrize(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId]
    };
  }
  /**
   * Constructs a no op call for the claimRafflePrize(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static claimRafflePrize(params) {
    return {
      ...params,
      method: "claimRafflePrize(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId]
    };
  }
  /**
   * Constructs a no op call for the raffle(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static raffle(params) {
    return {
      ...params,
      method: "raffle(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId]
    };
  }
  /**
   * Constructs a no op call for the findWinner(uint64,bool,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static findWinner(params) {
    return {
      ...params,
      method: "findWinner(uint64,bool,uint64,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.auctionAppId, params.args.iterationAmount]
    };
  }
  /**
   * Constructs a no op call for the cancel(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static cancel(params) {
    return {
      ...params,
      method: "cancel(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId]
    };
  }
  /**
   * Constructs a no op call for the updateAkitaDAO(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDao(params) {
    return {
      ...params,
      method: "updateAkitaDAO(uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.akitaDao]
    };
  }
  /**
   * Constructs a no op call for the opUp()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static opUp(params) {
    return {
      ...params,
      method: "opUp()void",
      args: Array.isArray(params.args) ? params.args : []
    };
  }
  /**
   * Constructs a no op call for the mbr()(uint64,uint64,uint64,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mbr(params) {
    return {
      ...params,
      method: "mbr()(uint64,uint64,uint64,uint64)",
      args: Array.isArray(params.args) ? params.args : []
    };
  }
};
var AuctionPluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `AuctionPluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory8({
      ...params,
      appSpec: APP_SPEC8
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC8;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new AuctionPluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new AuctionPluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the AuctionPlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    var _a, _b;
    const result = await this.appFactory.deploy({
      ...params,
      createParams: ((_a = params.createParams) == null ? void 0 : _a.method) ? AuctionPluginParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams : void 0,
      deleteParams: ((_b = params.deleteParams) == null ? void 0 : _b.method) ? AuctionPluginParamsFactory.delete._resolveByMethod(params.deleteParams) : params.deleteParams ? params.deleteParams : void 0
    });
    return { result: result.result, appClient: new AuctionPluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the AuctionPlugin smart contract using the create(string,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params) => {
        return this.appFactory.params.create(AuctionPluginParamsFactory.create.create(params));
      }
    },
    /**
     * Gets available deployDelete methods
     */
    deployDelete: {
      /**
       * Deletes an existing instance of the AuctionPlugin smart contract using the deleteApplication(uint64,bool,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The deployDelete params
       */
      deleteApplication: (params) => {
        return this.appFactory.params.deployDelete(AuctionPluginParamsFactory.delete.deleteApplication(params));
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the AuctionPlugin smart contract using the create(string,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params) => {
        return this.appFactory.createTransaction.create(AuctionPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the AuctionPlugin smart contract using an ABI method call using the create(string,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params) => {
        const result = await this.appFactory.send.create(AuctionPluginParamsFactory.create.create(params));
        return { result: { ...result.result, return: result.result.return }, appClient: new AuctionPluginClient(result.appClient) };
      }
    }
  };
};
var AuctionPluginClient = class _AuctionPluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient8 ? appClientOrParams : new _AppClient8({
      ...appClientOrParams,
      appSpec: APP_SPEC8
    });
  }
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue(method, returnValue) {
    return returnValue !== void 0 ? getArc56ReturnValue5(returnValue, this.appClient.getABIMethod(method), APP_SPEC8.structs) : void 0;
  }
  /**
   * Returns a new `AuctionPluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _AuctionPluginClient(await _AppClient8.fromCreatorAndName({ ...params, appSpec: APP_SPEC8 }));
  }
  /**
   * Returns an `AuctionPluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _AuctionPluginClient(await _AppClient8.fromNetwork({ ...params, appSpec: APP_SPEC8 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available delete methods
     */
    delete: {
      /**
       * Deletes an existing instance of the AuctionPlugin smart contract using the `deleteApplication(uint64,bool,uint64)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The delete params
       */
      deleteApplication: (params) => {
        return this.appClient.params.delete(AuctionPluginParamsFactory.delete.deleteApplication(params));
      }
    },
    /**
     * Makes a clear_state call to an existing instance of the AuctionPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `new(uint64,bool,uint64,uint64,string,byte[32][],uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,uint64)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    new: (params) => {
      return this.appClient.params.call(AuctionPluginParamsFactory.new(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `clearWeightsBoxes(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    clearWeightsBoxes: (params) => {
      return this.appClient.params.call(AuctionPluginParamsFactory.clearWeightsBoxes(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `deleteAuctionApp(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    deleteAuctionApp: (params) => {
      return this.appClient.params.call(AuctionPluginParamsFactory.deleteAuctionApp(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `bid(uint64,bool,uint64,uint64,byte[][],address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    bid: (params) => {
      return this.appClient.params.call(AuctionPluginParamsFactory.bid(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `refundBid(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    refundBid: (params) => {
      return this.appClient.params.call(AuctionPluginParamsFactory.refundBid(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `claimPrize(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    claimPrize: (params) => {
      return this.appClient.params.call(AuctionPluginParamsFactory.claimPrize(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `claimRafflePrize(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    claimRafflePrize: (params) => {
      return this.appClient.params.call(AuctionPluginParamsFactory.claimRafflePrize(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `raffle(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    raffle: (params) => {
      return this.appClient.params.call(AuctionPluginParamsFactory.raffle(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `findWinner(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    findWinner: (params) => {
      return this.appClient.params.call(AuctionPluginParamsFactory.findWinner(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `cancel(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    cancel: (params) => {
      return this.appClient.params.call(AuctionPluginParamsFactory.cancel(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDao: (params) => {
      return this.appClient.params.call(AuctionPluginParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.params.call(AuctionPluginParamsFactory.opUp(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `mbr()(uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    mbr: (params = { args: [] }) => {
      return this.appClient.params.call(AuctionPluginParamsFactory.mbr(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available delete methods
     */
    delete: {
      /**
       * Deletes an existing instance of the AuctionPlugin smart contract using the `deleteApplication(uint64,bool,uint64)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The delete transaction
       */
      deleteApplication: (params) => {
        return this.appClient.createTransaction.delete(AuctionPluginParamsFactory.delete.deleteApplication(params));
      }
    },
    /**
     * Makes a clear_state call to an existing instance of the AuctionPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `new(uint64,bool,uint64,uint64,string,byte[32][],uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,uint64)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    new: (params) => {
      return this.appClient.createTransaction.call(AuctionPluginParamsFactory.new(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `clearWeightsBoxes(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    clearWeightsBoxes: (params) => {
      return this.appClient.createTransaction.call(AuctionPluginParamsFactory.clearWeightsBoxes(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `deleteAuctionApp(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    deleteAuctionApp: (params) => {
      return this.appClient.createTransaction.call(AuctionPluginParamsFactory.deleteAuctionApp(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `bid(uint64,bool,uint64,uint64,byte[][],address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    bid: (params) => {
      return this.appClient.createTransaction.call(AuctionPluginParamsFactory.bid(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `refundBid(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    refundBid: (params) => {
      return this.appClient.createTransaction.call(AuctionPluginParamsFactory.refundBid(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `claimPrize(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    claimPrize: (params) => {
      return this.appClient.createTransaction.call(AuctionPluginParamsFactory.claimPrize(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `claimRafflePrize(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    claimRafflePrize: (params) => {
      return this.appClient.createTransaction.call(AuctionPluginParamsFactory.claimRafflePrize(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `raffle(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    raffle: (params) => {
      return this.appClient.createTransaction.call(AuctionPluginParamsFactory.raffle(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `findWinner(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    findWinner: (params) => {
      return this.appClient.createTransaction.call(AuctionPluginParamsFactory.findWinner(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `cancel(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    cancel: (params) => {
      return this.appClient.createTransaction.call(AuctionPluginParamsFactory.cancel(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDao: (params) => {
      return this.appClient.createTransaction.call(AuctionPluginParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.createTransaction.call(AuctionPluginParamsFactory.opUp(params));
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `mbr()(uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    mbr: (params = { args: [] }) => {
      return this.appClient.createTransaction.call(AuctionPluginParamsFactory.mbr(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available delete methods
     */
    delete: {
      /**
       * Deletes an existing instance of the AuctionPlugin smart contract using the `deleteApplication(uint64,bool,uint64)void` ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The delete result
       */
      deleteApplication: async (params) => {
        const result = await this.appClient.send.delete(AuctionPluginParamsFactory.delete.deleteApplication(params));
        return { ...result, return: result.return };
      }
    },
    /**
     * Makes a clear_state call to an existing instance of the AuctionPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `new(uint64,bool,uint64,uint64,string,byte[32][],uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,uint64)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    new: async (params) => {
      const result = await this.appClient.send.call(AuctionPluginParamsFactory.new(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `clearWeightsBoxes(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    clearWeightsBoxes: async (params) => {
      const result = await this.appClient.send.call(AuctionPluginParamsFactory.clearWeightsBoxes(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `deleteAuctionApp(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    deleteAuctionApp: async (params) => {
      const result = await this.appClient.send.call(AuctionPluginParamsFactory.deleteAuctionApp(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `bid(uint64,bool,uint64,uint64,byte[][],address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    bid: async (params) => {
      const result = await this.appClient.send.call(AuctionPluginParamsFactory.bid(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `refundBid(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    refundBid: async (params) => {
      const result = await this.appClient.send.call(AuctionPluginParamsFactory.refundBid(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `claimPrize(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    claimPrize: async (params) => {
      const result = await this.appClient.send.call(AuctionPluginParamsFactory.claimPrize(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `claimRafflePrize(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    claimRafflePrize: async (params) => {
      const result = await this.appClient.send.call(AuctionPluginParamsFactory.claimRafflePrize(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `raffle(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    raffle: async (params) => {
      const result = await this.appClient.send.call(AuctionPluginParamsFactory.raffle(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `findWinner(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    findWinner: async (params) => {
      const result = await this.appClient.send.call(AuctionPluginParamsFactory.findWinner(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `cancel(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    cancel: async (params) => {
      const result = await this.appClient.send.call(AuctionPluginParamsFactory.cancel(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDao: async (params) => {
      const result = await this.appClient.send.call(AuctionPluginParamsFactory.updateAkitaDao(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    opUp: async (params = { args: [] }) => {
      const result = await this.appClient.send.call(AuctionPluginParamsFactory.opUp(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AuctionPlugin smart contract using the `mbr()(uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mbr: async (params = { args: [] }) => {
      const result = await this.appClient.send.call(AuctionPluginParamsFactory.mbr(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _AuctionPluginClient(this.appClient.clone(params));
  }
  /**
   * Makes a readonly (simulated) call to the AuctionPlugin smart contract using the `mbr()(uint64,uint64,uint64,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async mbr(params = { args: [] }) {
    const result = await this.appClient.send.call(AuctionPluginParamsFactory.mbr(params));
    return result.return;
  }
  /**
   * Methods to access state for the current AuctionPlugin app
   */
  state = {
    /**
     * Methods to access global state for the current AuctionPlugin app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async () => {
        const result = await this.appClient.state.global.getAll();
        return {
          factory: result.factory,
          version: result.version,
          akitaDao: result.akitaDAO
        };
      },
      /**
       * Get the current value of the factory key in global state
       */
      factory: async () => {
        return await this.appClient.state.global.getValue("factory");
      },
      /**
       * Get the current value of the version key in global state
       */
      version: async () => {
        return await this.appClient.state.global.getValue("version");
      },
      /**
       * Get the current value of the akitaDAO key in global state
       */
      akitaDao: async () => {
        return await this.appClient.state.global.getValue("akitaDAO");
      }
    }
  };
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a new(uint64,bool,uint64,uint64,string,byte[32][],uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,uint64)uint64 method call against the AuctionPlugin contract
       */
      new(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.new(params)));
        resultMappers.push((v) => client.decodeReturnValue("new(uint64,bool,uint64,uint64,string,byte[32][],uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,uint64)uint64", v));
        return this;
      },
      /**
       * Add a clearWeightsBoxes(uint64,bool,uint64,uint64)void method call against the AuctionPlugin contract
       */
      clearWeightsBoxes(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.clearWeightsBoxes(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a deleteAuctionApp(uint64,bool,uint64)void method call against the AuctionPlugin contract
       */
      deleteAuctionApp(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.deleteAuctionApp(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a bid(uint64,bool,uint64,uint64,byte[][],address)void method call against the AuctionPlugin contract
       */
      bid(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.bid(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a refundBid(uint64,bool,uint64,uint64)void method call against the AuctionPlugin contract
       */
      refundBid(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.refundBid(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a claimPrize(uint64,bool,uint64)void method call against the AuctionPlugin contract
       */
      claimPrize(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.claimPrize(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a claimRafflePrize(uint64,bool,uint64)void method call against the AuctionPlugin contract
       */
      claimRafflePrize(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.claimRafflePrize(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a raffle(uint64,bool,uint64)void method call against the AuctionPlugin contract
       */
      raffle(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.raffle(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a findWinner(uint64,bool,uint64,uint64)void method call against the AuctionPlugin contract
       */
      findWinner(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.findWinner(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a cancel(uint64,bool,uint64)void method call against the AuctionPlugin contract
       */
      cancel(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.cancel(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a updateAkitaDAO(uint64)void method call against the AuctionPlugin contract
       */
      updateAkitaDao(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDao(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a opUp()void method call against the AuctionPlugin contract
       */
      opUp(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.opUp(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a mbr()(uint64,uint64,uint64,uint64) method call against the AuctionPlugin contract
       */
      mbr(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mbr(params)));
        resultMappers.push((v) => client.decodeReturnValue("mbr()(uint64,uint64,uint64,uint64)", v));
        return this;
      },
      get delete() {
        return {
          deleteApplication: (params) => {
            promiseChain = promiseChain.then(async () => composer.addAppDeleteMethodCall(await client.params.delete.deleteApplication(params)));
            resultMappers.push(void 0);
            return this;
          }
        };
      },
      /**
       * Add a clear state call to the AuctionPlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/auction.ts
var AuctionPluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: AuctionPluginFactory, ...params });
  }
  new(args) {
    const methodName = "new";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.new({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  bid(args) {
    const methodName = "bid";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.bid({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  claimPrize(args) {
    const methodName = "claimPrize";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.claimPrize({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  refundBid(args) {
    const methodName = "refundBid";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.refundBid({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  cancel(args) {
    const methodName = "cancel";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.cancel({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
};

// src/generated/AkitaDAOPluginClient.ts
import { getArc56ReturnValue as getArc56ReturnValue6 } from "@algorandfoundation/algokit-utils/types/app-arc56";
import {
  AppClient as _AppClient9
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory9 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC9 = { "name": "AkitaDAOPlugin", "structs": {}, "methods": [{ "name": "create", "args": [{ "type": "uint64", "name": "daoAppID" }], "returns": { "type": "void" }, "actions": { "create": ["NoOp"], "call": [] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "setup", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "string", "name": "nickname" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "newProposal", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "byte[36]", "name": "cid" }, { "type": "(uint8,byte[])[]", "name": "actions" }], "returns": { "type": "uint64" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "editProposal", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "id" }, { "type": "byte[36]", "name": "cid" }, { "type": "(uint8,byte[])[]", "name": "actions" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "submitProposal", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "proposalID" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "voteProposal", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "proposalID" }, { "type": "uint8", "name": "vote" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "finalizeProposal", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "proposalID" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "executeProposal", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "proposalID" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 1, "bytes": 0 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": { "daoAppID": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "ZGFvX2lk" } }, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": [], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [242, 359, 446, 556, 607], "errorMessage": "Bytes has valid prefix" }, { "pc": [46], "errorMessage": "OnCompletion must be NoOp" }, { "pc": [574], "errorMessage": "Proposal does not exist" }, { "pc": [138, 377, 630, 862], "errorMessage": "application exists" }, { "pc": [197, 289, 316, 373, 521, 626, 699, 780, 858, 958, 1030], "errorMessage": "check GlobalState exists" }, { "pc": [186], "errorMessage": "invalid number of bytes for (len+utf8[])" }, { "pc": [364, 612], "errorMessage": "invalid number of bytes for (uint64,uint64,uint64,uint64,uint64,uint64,uint64)" }, { "pc": [170, 264, 475, 759, 831, 937, 1009], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [147, 161, 246, 254, 451, 465, 490, 750, 769, 822, 841, 928, 947, 1e3, 1019], "errorMessage": "invalid number of bytes for uint64" }, { "pc": [849], "errorMessage": "invalid number of bytes for uint8" }, { "pc": [278, 501], "errorMessage": "invalid number of bytes for uint8[36]" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDggNgogICAgYnl0ZWNibG9jayAiZGFvX2lkIiAic3BlbmRpbmdfYWRkcmVzcyIgMHgxNTFmN2M3NSAweDhjNTY0NzY4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxNQogICAgLy8gZXhwb3J0IGNsYXNzIEFraXRhREFPUGx1Z2luIGV4dGVuZHMgQ29udHJhY3QgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBieiBtYWluX2NyZWF0ZV9Ob09wQDExCiAgICBwdXNoYnl0ZXNzIDB4NjY5ZDMwZGEgMHgwNTY3N2YwZSAweDU1ZmUzYjEwIDB4NjIyNTYwYTQgMHhmMDM0OTNiNCAweGNmN2UxYWU2IDB4OTM0MDE4MTMgLy8gbWV0aG9kICJzZXR1cCh1aW50NjQsYm9vbCxzdHJpbmcpdm9pZCIsIG1ldGhvZCAibmV3UHJvcG9zYWwodWludDY0LGJvb2wsYnl0ZVszNl0sKHVpbnQ4LGJ5dGVbXSlbXSl1aW50NjQiLCBtZXRob2QgImVkaXRQcm9wb3NhbCh1aW50NjQsYm9vbCx1aW50NjQsYnl0ZVszNl0sKHVpbnQ4LGJ5dGVbXSlbXSl2b2lkIiwgbWV0aG9kICJzdWJtaXRQcm9wb3NhbCh1aW50NjQsYm9vbCx1aW50NjQpdm9pZCIsIG1ldGhvZCAidm90ZVByb3Bvc2FsKHVpbnQ2NCxib29sLHVpbnQ2NCx1aW50OCl2b2lkIiwgbWV0aG9kICJmaW5hbGl6ZVByb3Bvc2FsKHVpbnQ2NCxib29sLHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJleGVjdXRlUHJvcG9zYWwodWludDY0LGJvb2wsdWludDY0KXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBzZXR1cCBuZXdQcm9wb3NhbCBlZGl0UHJvcG9zYWwgc3VibWl0UHJvcG9zYWwgdm90ZVByb3Bvc2FsIGZpbmFsaXplUHJvcG9zYWwgZXhlY3V0ZVByb3Bvc2FsCiAgICBlcnIKCm1haW5fY3JlYXRlX05vT3BAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxNQogICAgLy8gZXhwb3J0IGNsYXNzIEFraXRhREFPUGx1Z2luIGV4dGVuZHMgQ29udHJhY3QgewogICAgcHVzaGJ5dGVzIDB4MjQwZDJmNjcgLy8gbWV0aG9kICJjcmVhdGUodWludDY0KXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBjcmVhdGUKICAgIGVycgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OnJla2V5QWRkcmVzcyhyZWtleUJhY2s6IHVpbnQ2NCwgd2FsbGV0OiB1aW50NjQpIC0+IGJ5dGVzOgpyZWtleUFkZHJlc3M6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMQogICAgLy8gZXhwb3J0IGZ1bmN0aW9uIHJla2V5QWRkcmVzcyhyZWtleUJhY2s6IGJvb2xlYW4sIHdhbGxldDogQXBwbGljYXRpb24pOiBBY2NvdW50IHsKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjIKICAgIC8vIGlmICghcmVrZXlCYWNrKSB7CiAgICBmcmFtZV9kaWcgLTIKICAgIGJueiByZWtleUFkZHJlc3NfYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMwogICAgLy8gcmV0dXJuIEdsb2JhbC56ZXJvQWRkcmVzcwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICByZXRzdWIKCnJla2V5QWRkcmVzc19hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyNgogICAgLy8gcmV0dXJuIHdhbGxldC5hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjpBa2l0YURBT1BsdWdpbi5jcmVhdGVbcm91dGluZ10oKSAtPiB2b2lkOgpjcmVhdGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoyMwogICAgLy8gQGFiaW1ldGhvZCh7IG9uQ3JlYXRlOiAncmVxdWlyZScgfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxOQogICAgLy8gZGFvQXBwSUQgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEFraXRhREFPUGx1Z2luR2xvYmFsU3RhdGVLZXlzREFPQXBwSUQgfSkKICAgIGJ5dGVjXzAgLy8gImRhb19pZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjI1CiAgICAvLyB0aGlzLmRhb0FwcElELnZhbHVlID0gQXBwbGljYXRpb24oZGFvQXBwSUQpCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MjMKICAgIC8vIEBhYmltZXRob2QoeyBvbkNyZWF0ZTogJ3JlcXVpcmUnIH0pCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6OkFraXRhREFPUGx1Z2luLnNldHVwW3JvdXRpbmddKCkgLT4gdm9pZDoKc2V0dXA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czozMAogICAgLy8gc2V0dXAod2FsbGV0OiBBcHBsaWNhdGlvbiwgcmVrZXlCYWNrOiBib29sZWFuLCBuaWNrbmFtZTogc3RyaW5nKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMSAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjMzLTM4CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YURBT0RlcGxveWFibGUucHJvdG90eXBlLnNldHVwPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZGFvQXBwSUQudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFtuaWNrbmFtZV0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czozNQogICAgLy8gYXBwSWQ6IHRoaXMuZGFvQXBwSUQudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTkKICAgIC8vIGRhb0FwcElEID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBBa2l0YURBT1BsdWdpbkdsb2JhbFN0YXRlS2V5c0RBT0FwcElEIH0pCiAgICBieXRlY18wIC8vICJkYW9faWQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czozNQogICAgLy8gYXBwSWQ6IHRoaXMuZGFvQXBwSUQudmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MzcKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciA0CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MzMtMzgKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhREFPRGVwbG95YWJsZS5wcm90b3R5cGUuc2V0dXA+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5kYW9BcHBJRC52YWx1ZSwKICAgIC8vICAgYXJnczogW25pY2tuYW1lXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweGQ5YmFjZDk0IC8vIG1ldGhvZCAic2V0dXAoc3RyaW5nKXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18yIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjMwCiAgICAvLyBzZXR1cCh3YWxsZXQ6IEFwcGxpY2F0aW9uLCByZWtleUJhY2s6IGJvb2xlYW4sIG5pY2tuYW1lOiBzdHJpbmcpOiB2b2lkIHsKICAgIHJldHVybiAvLyBvbiBlcnJvcjogaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjpBa2l0YURBT1BsdWdpbi5uZXdQcm9wb3NhbFtyb3V0aW5nXSgpIC0+IHZvaWQ6Cm5ld1Byb3Bvc2FsOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6NDEKICAgIC8vIG5ld1Byb3Bvc2FsKHdhbGxldDogQXBwbGljYXRpb24sIHJla2V5QmFjazogYm9vbGVhbiwgY2lkOiBDSUQsIGFjdGlvbnM6IFByb3Bvc2FsQWN0aW9uW10pOiB1aW50NjQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgc3dhcAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBjb3ZlciAyCiAgICBsZW4KICAgIHB1c2hpbnQgMzYgLy8gMzYKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzM2XQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czo0NgogICAgLy8gdGhpcy5kYW9BcHBJRC52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxOQogICAgLy8gZGFvQXBwSUQgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEFraXRhREFPUGx1Z2luR2xvYmFsU3RhdGVLZXlzREFPQXBwSUQgfSkKICAgIGJ5dGVjXzAgLy8gImRhb19pZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjQ2CiAgICAvLyB0aGlzLmRhb0FwcElELnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjQ3CiAgICAvLyBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0luaXRpYWxpemVkKQogICAgcHVzaGJ5dGVzICJpbml0aWFsaXplZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjQ1LTQ4CiAgICAvLyBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgdGhpcy5kYW9BcHBJRC52YWx1ZSwKICAgIC8vICAgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNJbml0aWFsaXplZCkKICAgIC8vIClbMF0KICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjQ0LTQ5CiAgICAvLyBjb25zdCBpbml0aWFsaXplZCA9IGRlY29kZUFyYzQ8Ym9vbGVhbj4oCiAgICAvLyAgIG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICAgIHRoaXMuZGFvQXBwSUQudmFsdWUsCiAgICAvLyAgICAgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNJbml0aWFsaXplZCkKICAgIC8vICAgKVswXQogICAgLy8gKQogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6NTIKICAgIC8vIGxldCB0b3RhbDogdWludDY0ID0gMDsKICAgIGludGNfMCAvLyAwCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czo1MwogICAgLy8gaWYgKGluaXRpYWxpemVkKSB7CiAgICBieiBuZXdQcm9wb3NhbF9hZnRlcl9pZl9lbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjU0LTU5CiAgICAvLyAoeyB0b3RhbCB9ID0gYWJpQ2FsbDx0eXBlb2YgQWtpdGFEQU8ucHJvdG90eXBlLnByb3Bvc2FsQ29zdD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmRhb0FwcElELnZhbHVlLAogICAgLy8gICBhcmdzOiBbYWN0aW9uc10sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pLnJldHVyblZhbHVlKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6NTYKICAgIC8vIGFwcElkOiB0aGlzLmRhb0FwcElELnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjE5CiAgICAvLyBkYW9BcHBJRCA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogQWtpdGFEQU9QbHVnaW5HbG9iYWxTdGF0ZUtleXNEQU9BcHBJRCB9KQogICAgYnl0ZWNfMCAvLyAiZGFvX2lkIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6NTYKICAgIC8vIGFwcElkOiB0aGlzLmRhb0FwcElELnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjU4CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICBkaWcgNQogICAgZGlnIDcKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czo1NC01OQogICAgLy8gKHsgdG90YWwgfSA9IGFiaUNhbGw8dHlwZW9mIEFraXRhREFPLnByb3RvdHlwZS5wcm9wb3NhbENvc3Q+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5kYW9BcHBJRC52YWx1ZSwKICAgIC8vICAgYXJnczogW2FjdGlvbnNdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KS5yZXR1cm5WYWx1ZSkKICAgIGJ5dGVjXzMgLy8gbWV0aG9kICJwcm9wb3NhbENvc3QoKHVpbnQ4LGJ5dGVbXSlbXSkodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIGRpZyAxCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMiAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGxlbgogICAgcHVzaGludCA1NiAvLyA1NgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBleHRyYWN0X3VpbnQ2NAogICAgYnVyeSAxCgpuZXdQcm9wb3NhbF9hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czo2NAogICAgLy8gcmVjZWl2ZXI6IHRoaXMuZGFvQXBwSUQudmFsdWUuYWRkcmVzcywKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxOQogICAgLy8gZGFvQXBwSUQgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEFraXRhREFPUGx1Z2luR2xvYmFsU3RhdGVLZXlzREFPQXBwSUQgfSkKICAgIGJ5dGVjXzAgLy8gImRhb19pZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjY0CiAgICAvLyByZWNlaXZlcjogdGhpcy5kYW9BcHBJRC52YWx1ZS5hZGRyZXNzLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6NjgtNzcKICAgIC8vIHJldHVybiBhYmlDYWxsPHR5cGVvZiBBa2l0YURBTy5wcm90b3R5cGUubmV3UHJvcG9zYWw+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5kYW9BcHBJRC52YWx1ZSwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGFjdGlvbnNQYXltZW50LAogICAgLy8gICAgIGNpZCwKICAgIC8vICAgICBhY3Rpb25zCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICBkaWcgMgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGRpZyAyCiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czo2Mi02NgogICAgLy8gY29uc3QgYWN0aW9uc1BheW1lbnQgPSBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiB0aGlzLmRhb0FwcElELnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogdG90YWwsCiAgICAvLyB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6NjgtNzcKICAgIC8vIHJldHVybiBhYmlDYWxsPHR5cGVvZiBBa2l0YURBTy5wcm90b3R5cGUubmV3UHJvcG9zYWw+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5kYW9BcHBJRC52YWx1ZSwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGFjdGlvbnNQYXltZW50LAogICAgLy8gICAgIGNpZCwKICAgIC8vICAgICBhY3Rpb25zCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjc2CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICBkaWcgNgogICAgZGlnIDgKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czo2OC03NwogICAgLy8gcmV0dXJuIGFiaUNhbGw8dHlwZW9mIEFraXRhREFPLnByb3RvdHlwZS5uZXdQcm9wb3NhbD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmRhb0FwcElELnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgYWN0aW9uc1BheW1lbnQsCiAgICAvLyAgICAgY2lkLAogICAgLy8gICAgIGFjdGlvbnMKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweDAxOThmZTNiIC8vIG1ldGhvZCAibmV3UHJvcG9zYWwocGF5LGJ5dGVbMzZdLCh1aW50OCxieXRlW10pW10pdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBnaXR4biAxIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18yIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjQxCiAgICAvLyBuZXdQcm9wb3NhbCh3YWxsZXQ6IEFwcGxpY2F0aW9uLCByZWtleUJhY2s6IGJvb2xlYW4sIGNpZDogQ0lELCBhY3Rpb25zOiBQcm9wb3NhbEFjdGlvbltdKTogdWludDY0IHsKICAgIGJ5dGVjXzIgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czo6QWtpdGFEQU9QbHVnaW4uZWRpdFByb3Bvc2FsW3JvdXRpbmddKCkgLT4gdm9pZDoKZWRpdFByb3Bvc2FsOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6ODAKICAgIC8vIGVkaXRQcm9wb3NhbCh3YWxsZXQ6IEFwcGxpY2F0aW9uLCByZWtleUJhY2s6IGJvb2xlYW4sIGlkOiB1aW50NjQsIGNpZDogQ0lELCBhY3Rpb25zOiBQcm9wb3NhbEFjdGlvbltdKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBjb3ZlciAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGNvdmVyIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGNvdmVyIDUKICAgIGxlbgogICAgcHVzaGludCAzNiAvLyAzNgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzZdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGNvdmVyIDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgZHVwCiAgICBjb3ZlciA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czo4My04NwogICAgLy8gY29uc3QgeyBzdGF0dXMsIGZlZXNQYWlkIH0gPSBhYmlDYWxsPHR5cGVvZiBBa2l0YURBTy5wcm90b3R5cGUuZ2V0UHJvcG9zYWw+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5kYW9BcHBJRC52YWx1ZSwKICAgIC8vICAgYXJnczogW2lkXSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czo4NQogICAgLy8gYXBwSWQ6IHRoaXMuZGFvQXBwSUQudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTkKICAgIC8vIGRhb0FwcElEID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBBa2l0YURBT1BsdWdpbkdsb2JhbFN0YXRlS2V5c0RBT0FwcElEIH0pCiAgICBieXRlY18wIC8vICJkYW9faWQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czo4NQogICAgLy8gYXBwSWQ6IHRoaXMuZGFvQXBwSUQudmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6ODMtODcKICAgIC8vIGNvbnN0IHsgc3RhdHVzLCBmZWVzUGFpZCB9ID0gYWJpQ2FsbDx0eXBlb2YgQWtpdGFEQU8ucHJvdG90eXBlLmdldFByb3Bvc2FsPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZGFvQXBwSUQudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFtpZF0sCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgcHVzaGJ5dGVzIDB4MWY5ZjhiMjAgLy8gbWV0aG9kICJnZXRQcm9wb3NhbCh1aW50NjQpKHVpbnQ4LGJ5dGVbMzZdLCh1aW50NjQsdWludDY0LHVpbnQ2NCksYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCwodWludDgsYnl0ZVtdKVtdKSIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkdXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18yIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBleHRyYWN0IDQgMQogICAgc3dhcAogICAgcHVzaGludCAxMTMgLy8gMTEzCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBjb3ZlciA0CiAgICBjb3ZlciA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvdHlwZXMvYmFzZS50czo0CiAgICAvLyByZXR1cm4gbmV3IGFyYzQuVWludDgodikKICAgIHB1c2hieXRlcyAweDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czo4OQogICAgLy8gYXNzZXJ0KHN0YXR1cyAhPT0gdWludDgoMCksIEVSUl9QUk9QT1NBTF9ET0VTX05PVF9FWElTVCkKICAgICE9CiAgICBhc3NlcnQgLy8gUHJvcG9zYWwgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjkxLTk1CiAgICAvLyBjb25zdCB7IHRvdGFsIH0gPSBhYmlDYWxsPHR5cGVvZiBBa2l0YURBTy5wcm90b3R5cGUucHJvcG9zYWxDb3N0Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZGFvQXBwSUQudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFthY3Rpb25zXSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICBieXRlY18zIC8vIG1ldGhvZCAicHJvcG9zYWxDb3N0KCh1aW50OCxieXRlW10pW10pKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgZGlnIDEKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18yIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgbGVuCiAgICBwdXNoaW50IDU2IC8vIDU2CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KQogICAgcHVzaGludCA0IC8vIDQKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGNvdmVyIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjk3CiAgICAvLyBpZiAoZmVlc1BhaWQgPCB0b3RhbCkgewogICAgPAogICAgYnogZWRpdFByb3Bvc2FsX2Vsc2VfYm9keUA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxMDAKICAgIC8vIHJlY2VpdmVyOiB0aGlzLmRhb0FwcElELnZhbHVlLmFkZHJlc3MsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTkKICAgIC8vIGRhb0FwcElEID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBBa2l0YURBT1BsdWdpbkdsb2JhbFN0YXRlS2V5c0RBT0FwcElEIH0pCiAgICBieXRlY18wIC8vICJkYW9faWQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxMDAKICAgIC8vIHJlY2VpdmVyOiB0aGlzLmRhb0FwcElELnZhbHVlLmFkZHJlc3MsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxMDEKICAgIC8vIGFtb3VudDogdG90YWwgLSBmZWVzUGFpZCwKICAgIGRpZyA0CiAgICBkaWcgNgogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTA0LTExNAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFEQU8ucHJvdG90eXBlLmVkaXRQcm9wb3NhbFdpdGhQYXltZW50Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZGFvQXBwSUQudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBhY3Rpb25zUGF5bWVudCwKICAgIC8vICAgICBpZCwKICAgIC8vICAgICBjaWQsCiAgICAvLyAgICAgYWN0aW9ucwogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGRpZyA1CiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czo5OC0xMDIKICAgIC8vIGNvbnN0IGFjdGlvbnNQYXltZW50ID0gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogdGhpcy5kYW9BcHBJRC52YWx1ZS5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IHRvdGFsIC0gZmVlc1BhaWQsCiAgICAvLyB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTA0LTExNAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFEQU8ucHJvdG90eXBlLmVkaXRQcm9wb3NhbFdpdGhQYXltZW50Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZGFvQXBwSUQudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBhY3Rpb25zUGF5bWVudCwKICAgIC8vICAgICBpZCwKICAgIC8vICAgICBjaWQsCiAgICAvLyAgICAgYWN0aW9ucwogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxMTMKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciAzCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTA0LTExNAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFEQU8ucHJvdG90eXBlLmVkaXRQcm9wb3NhbFdpdGhQYXltZW50Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZGFvQXBwSUQudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBhY3Rpb25zUGF5bWVudCwKICAgIC8vICAgICBpZCwKICAgIC8vICAgICBjaWQsCiAgICAvLyAgICAgYWN0aW9ucwogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4Y2IzN2U2NjggLy8gbWV0aG9kICJlZGl0UHJvcG9zYWxXaXRoUGF5bWVudChwYXksdWludDY0LGJ5dGVbMzZdLCh1aW50OCxieXRlW10pW10pdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgOAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA3CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDYKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CgplZGl0UHJvcG9zYWxfYWZ0ZXJfaWZfZWxzZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6ODAKICAgIC8vIGVkaXRQcm9wb3NhbCh3YWxsZXQ6IEFwcGxpY2F0aW9uLCByZWtleUJhY2s6IGJvb2xlYW4sIGlkOiB1aW50NjQsIGNpZDogQ0lELCBhY3Rpb25zOiBQcm9wb3NhbEFjdGlvbltdKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgplZGl0UHJvcG9zYWxfZWxzZV9ib2R5QDc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxMTYtMTI1CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YURBTy5wcm90b3R5cGUuZWRpdFByb3Bvc2FsPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZGFvQXBwSUQudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpZCwKICAgIC8vICAgICBjaWQsCiAgICAvLyAgICAgYWN0aW9ucwogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTE4CiAgICAvLyBhcHBJZDogdGhpcy5kYW9BcHBJRC52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxOQogICAgLy8gZGFvQXBwSUQgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEFraXRhREFPUGx1Z2luR2xvYmFsU3RhdGVLZXlzREFPQXBwSUQgfSkKICAgIGJ5dGVjXzAgLy8gImRhb19pZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjExOAogICAgLy8gYXBwSWQ6IHRoaXMuZGFvQXBwSUQudmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTI0CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICBjb3ZlciAyCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTE2LTEyNQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFEQU8ucHJvdG90eXBlLmVkaXRQcm9wb3NhbD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmRhb0FwcElELnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaWQsCiAgICAvLyAgICAgY2lkLAogICAgLy8gICAgIGFjdGlvbnMKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweGZlMjBjMjY5IC8vIG1ldGhvZCAiZWRpdFByb3Bvc2FsKHVpbnQ2NCxieXRlWzM2XSwodWludDgsYnl0ZVtdKVtdKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDcKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA1CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGRpZyAyCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGIgZWRpdFByb3Bvc2FsX2FmdGVyX2lmX2Vsc2VAOQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjpBa2l0YURBT1BsdWdpbi5zdWJtaXRQcm9wb3NhbFtyb3V0aW5nXSgpIC0+IHZvaWQ6CnN1Ym1pdFByb3Bvc2FsOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTI5CiAgICAvLyBzdWJtaXRQcm9wb3NhbCh3YWxsZXQ6IEFwcGxpY2F0aW9uLCByZWtleUJhY2s6IGJvb2xlYW4sIHByb3Bvc2FsSUQ6IHVpbnQ2NCk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxMzItMTM3CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YURBTy5wcm90b3R5cGUuc3VibWl0UHJvcG9zYWw+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5kYW9BcHBJRC52YWx1ZSwKICAgIC8vICAgYXJnczogW3Byb3Bvc2FsSURdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTM0CiAgICAvLyBhcHBJZDogdGhpcy5kYW9BcHBJRC52YWx1ZSwKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxOQogICAgLy8gZGFvQXBwSUQgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEFraXRhREFPUGx1Z2luR2xvYmFsU3RhdGVLZXlzREFPQXBwSUQgfSkKICAgIGJ5dGVjXzAgLy8gImRhb19pZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjEzNAogICAgLy8gYXBwSWQ6IHRoaXMuZGFvQXBwSUQudmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTM2CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgNAogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjEzMi0xMzcKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhREFPLnByb3RvdHlwZS5zdWJtaXRQcm9wb3NhbD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmRhb0FwcElELnZhbHVlLAogICAgLy8gICBhcmdzOiBbcHJvcG9zYWxJRF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHgxMDNhNmI4OCAvLyBtZXRob2QgInN1Ym1pdFByb3Bvc2FsKHVpbnQ2NCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjEyOQogICAgLy8gc3VibWl0UHJvcG9zYWwod2FsbGV0OiBBcHBsaWNhdGlvbiwgcmVrZXlCYWNrOiBib29sZWFuLCBwcm9wb3NhbElEOiB1aW50NjQpOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czo6QWtpdGFEQU9QbHVnaW4udm90ZVByb3Bvc2FsW3JvdXRpbmddKCkgLT4gdm9pZDoKdm90ZVByb3Bvc2FsOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTQwCiAgICAvLyB2b3RlUHJvcG9zYWwod2FsbGV0OiBBcHBsaWNhdGlvbiwgcmVrZXlCYWNrOiBib29sZWFuLCBwcm9wb3NhbElEOiB1aW50NjQsIHZvdGU6IFByb3Bvc2FsVm90ZVR5cGUpOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTQ1CiAgICAvLyByZWNlaXZlcjogdGhpcy5kYW9BcHBJRC52YWx1ZS5hZGRyZXNzLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjE5CiAgICAvLyBkYW9BcHBJRCA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogQWtpdGFEQU9QbHVnaW5HbG9iYWxTdGF0ZUtleXNEQU9BcHBJRCB9KQogICAgYnl0ZWNfMCAvLyAiZGFvX2lkIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTQ1CiAgICAvLyByZWNlaXZlcjogdGhpcy5kYW9BcHBJRC52YWx1ZS5hZGRyZXNzLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTQ5LTE1OAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFEQU8ucHJvdG90eXBlLnZvdGVQcm9wb3NhbD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmRhb0FwcElELnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICBwcm9wb3NhbElELAogICAgLy8gICAgIHZvdGUKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjE0NgogICAgLy8gYW1vdW50OiBEQU9Qcm9wb3NhbFZvdGVzTUJSCiAgICBwdXNoaW50IDIyNTAwIC8vIDIyNTAwCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxNDMtMTQ3CiAgICAvLyBjb25zdCBtYnJQYXltZW50ID0gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogdGhpcy5kYW9BcHBJRC52YWx1ZS5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IERBT1Byb3Bvc2FsVm90ZXNNQlIKICAgIC8vIH0pCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxNDktMTU4CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YURBTy5wcm90b3R5cGUudm90ZVByb3Bvc2FsPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZGFvQXBwSUQudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJQYXltZW50LAogICAgLy8gICAgIHByb3Bvc2FsSUQsCiAgICAvLyAgICAgdm90ZQogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxNTcKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIHVuY292ZXIgNAogICAgdW5jb3ZlciA1CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTQ5LTE1OAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFEQU8ucHJvdG90eXBlLnZvdGVQcm9wb3NhbD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmRhb0FwcElELnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICBwcm9wb3NhbElELAogICAgLy8gICAgIHZvdGUKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweGE0YjIzNmI2IC8vIG1ldGhvZCAidm90ZVByb3Bvc2FsKHBheSx1aW50NjQsdWludDgpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxNDAKICAgIC8vIHZvdGVQcm9wb3NhbCh3YWxsZXQ6IEFwcGxpY2F0aW9uLCByZWtleUJhY2s6IGJvb2xlYW4sIHByb3Bvc2FsSUQ6IHVpbnQ2NCwgdm90ZTogUHJvcG9zYWxWb3RlVHlwZSk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjpBa2l0YURBT1BsdWdpbi5maW5hbGl6ZVByb3Bvc2FsW3JvdXRpbmddKCkgLT4gdm9pZDoKZmluYWxpemVQcm9wb3NhbDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjE2MQogICAgLy8gZmluYWxpemVQcm9wb3NhbCh3YWxsZXQ6IEFwcGxpY2F0aW9uLCByZWtleUJhY2s6IGJvb2xlYW4sIHByb3Bvc2FsSUQ6IHVpbnQ2NCk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxNjQtMTY5CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YURBTy5wcm90b3R5cGUuZmluYWxpemVQcm9wb3NhbD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmRhb0FwcElELnZhbHVlLAogICAgLy8gICBhcmdzOiBbcHJvcG9zYWxJRF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxNjYKICAgIC8vIGFwcElkOiB0aGlzLmRhb0FwcElELnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjE5CiAgICAvLyBkYW9BcHBJRCA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogQWtpdGFEQU9QbHVnaW5HbG9iYWxTdGF0ZUtleXNEQU9BcHBJRCB9KQogICAgYnl0ZWNfMCAvLyAiZGFvX2lkIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTY2CiAgICAvLyBhcHBJZDogdGhpcy5kYW9BcHBJRC52YWx1ZSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxNjgKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciA0CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTY0LTE2OQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFEQU8ucHJvdG90eXBlLmZpbmFsaXplUHJvcG9zYWw+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5kYW9BcHBJRC52YWx1ZSwKICAgIC8vICAgYXJnczogW3Byb3Bvc2FsSURdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4NjJjZTliNWIgLy8gbWV0aG9kICJmaW5hbGl6ZVByb3Bvc2FsKHVpbnQ2NCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjE2MQogICAgLy8gZmluYWxpemVQcm9wb3NhbCh3YWxsZXQ6IEFwcGxpY2F0aW9uLCByZWtleUJhY2s6IGJvb2xlYW4sIHByb3Bvc2FsSUQ6IHVpbnQ2NCk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjpBa2l0YURBT1BsdWdpbi5leGVjdXRlUHJvcG9zYWxbcm91dGluZ10oKSAtPiB2b2lkOgpleGVjdXRlUHJvcG9zYWw6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxNzIKICAgIC8vIGV4ZWN1dGVQcm9wb3NhbCh3YWxsZXQ6IEFwcGxpY2F0aW9uLCByZWtleUJhY2s6IGJvb2xlYW4sIHByb3Bvc2FsSUQ6IHVpbnQ2NCk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxNzUtMTgwCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YURBTy5wcm90b3R5cGUuZXhlY3V0ZVByb3Bvc2FsPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZGFvQXBwSUQudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFtwcm9wb3NhbElEXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjE3NwogICAgLy8gYXBwSWQ6IHRoaXMuZGFvQXBwSUQudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZGFvL2NvbnRyYWN0LmFsZ28udHM6MTkKICAgIC8vIGRhb0FwcElEID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBBa2l0YURBT1BsdWdpbkdsb2JhbFN0YXRlS2V5c0RBT0FwcElEIH0pCiAgICBieXRlY18wIC8vICJkYW9faWQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxNzcKICAgIC8vIGFwcElkOiB0aGlzLmRhb0FwcElELnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjE3OQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDQKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kYW8vY29udHJhY3QuYWxnby50czoxNzUtMTgwCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YURBTy5wcm90b3R5cGUuZXhlY3V0ZVByb3Bvc2FsPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZGFvQXBwSUQudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFtwcm9wb3NhbElEXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweGYxZmYyOGFhIC8vIG1ldGhvZCAiZXhlY3V0ZVByb3Bvc2FsKHVpbnQ2NCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2Rhby9jb250cmFjdC5hbGdvLnRzOjE3MgogICAgLy8gZXhlY3V0ZVByb3Bvc2FsKHdhbGxldDogQXBwbGljYXRpb24sIHJla2V5QmFjazogYm9vbGVhbiwgcHJvcG9zYWxJRDogdWludDY0KTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCg==", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyAEAAEIBiYEBmRhb19pZBBzcGVuZGluZ19hZGRyZXNzBBUffHUEjFZHaDEZFEQxGEEAOYIHBGadMNoEBWd/DgRV/jsQBGIlYKQE8DSTtATPfhrmBJNAGBM2GgCOBwAuAIsBXgJ7AsMDLQN1AIAEJA0vZzYaAI4BABIAigIBi/5AAAMyA4mL/3IIRIk2GgFJFSQSRBcoTGcjQzYaAUkVJBJEFzYaAkkVIxJEIlM2GgNJIlmBAghLARUSREsCKWVITLEiKGVETwNPBIj/roAE2brNlLIaTwKyGrIgshiyACWyECKyAbO0PklXBABMVwAEKhJEFSQSQzYaAUkVJBJEF0k2GgJJFSMSRCJTTDYaA0lOAhWBJBJENhoETCllSCIoZUSAC2luaXRpYWxpemVkZUgiUyJMQQA6sSIoZURLBUsHiP83K7IaSwSyGrIgshhLAbIAJbIQIrIBs7Q+SVcEAEsBVwAEKhJEFYE4EkSBBFtFASIoZURJcghEsUsCsgiyB0sCSbIAI7IQIrIBtksGSwiI/ueABAGY/juyGksGshpLBbIasiCyALIYJbIQIrIBs7cBPklXBABMVwAEKhJESRUkEkQqTFCwI0M2GgFJFSQSRBdJNhoCSRUjEkQiU04CNhoDSU4ESRUkEkQ2GgRJTgUVgSQSRDYaBUlOA04FTCllSElOBbEiKGVEgAQfn4sgshpPArIaSbIYSwGyACWyECKyAbO0PklXAAQqEkRJVwQBTIFxW0lOBE4HgAEAE0SxK7IaTwOyGrIYsgAlshAisgGztD5JVwQASwFXAAQqEkQVgTgSRIEEW0lOBAxBAEgiKGVESXIIREsESwYJsbIIsgdLBUmyACOyECKyAbZPA08DiP3ngATLN+ZoshpLCLIaSweyGksGshqyILIAshglshAisgGzI0OxIihlRE4CiP26gAT+IMJpshpLB7IaSwayGksFshqyILIYSwKyACWyECKyAbNC/842GgFJFSQSRBc2GgJJFSMSRCJTNhoDSRUkEkRLAillSEyxIihlRE8DTwSI/WeABBA6a4iyGk8CshqyILIYsgAlshAisgGzI0M2GgFJFSQSRBc2GgJJFSMSRCJTNhoDSRUkEkQ2GgRJFSMSREsDKWVIIihlRElyCESxgeSvAbIIsgdLAbIAI7IQIrIBtk8ETwWI/QGABKSyNrayGk8EshpPA7IasiCyGLIAJbIQIrIBsyNDNhoBSRUkEkQXNhoCSRUjEkQiUzYaA0kVJBJESwIpZUhMsSIoZURPA08EiPy1gARizptbshpPArIasiCyGLIAJbIQIrIBsyNDNhoBSRUkEkQXNhoCSRUjEkQiUzYaA0kVJBJESwIpZUhMsSIoZURPA08EiPxtgATx/yiqshpPArIasiCyGLIAJbIQIrIBsyND", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var AkitaDaoPluginParamsFactory = class _AkitaDaoPluginParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "create":
          case "create(uint64)void":
            return _AkitaDaoPluginParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs create ABI call params for the AkitaDAOPlugin smart contract using the create(uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params) {
        return {
          ...params,
          method: "create(uint64)void",
          args: Array.isArray(params.args) ? params.args : [params.args.daoAppId]
        };
      }
    };
  }
  /**
   * Constructs a no op call for the setup(uint64,bool,string)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setup(params) {
    return {
      ...params,
      method: "setup(uint64,bool,string)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.nickname]
    };
  }
  /**
   * Constructs a no op call for the newProposal(uint64,bool,byte[36],(uint8,byte[])[])uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static newProposal(params) {
    return {
      ...params,
      method: "newProposal(uint64,bool,byte[36],(uint8,byte[])[])uint64",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.cid, params.args.actions]
    };
  }
  /**
   * Constructs a no op call for the editProposal(uint64,bool,uint64,byte[36],(uint8,byte[])[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static editProposal(params) {
    return {
      ...params,
      method: "editProposal(uint64,bool,uint64,byte[36],(uint8,byte[])[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.id, params.args.cid, params.args.actions]
    };
  }
  /**
   * Constructs a no op call for the submitProposal(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static submitProposal(params) {
    return {
      ...params,
      method: "submitProposal(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.proposalId]
    };
  }
  /**
   * Constructs a no op call for the voteProposal(uint64,bool,uint64,uint8)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static voteProposal(params) {
    return {
      ...params,
      method: "voteProposal(uint64,bool,uint64,uint8)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.proposalId, params.args.vote]
    };
  }
  /**
   * Constructs a no op call for the finalizeProposal(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static finalizeProposal(params) {
    return {
      ...params,
      method: "finalizeProposal(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.proposalId]
    };
  }
  /**
   * Constructs a no op call for the executeProposal(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static executeProposal(params) {
    return {
      ...params,
      method: "executeProposal(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.proposalId]
    };
  }
};
var AkitaDaoPluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `AkitaDaoPluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory9({
      ...params,
      appSpec: APP_SPEC9
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC9;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new AkitaDaoPluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new AkitaDaoPluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the AkitaDAOPlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    var _a;
    const result = await this.appFactory.deploy({
      ...params,
      createParams: ((_a = params.createParams) == null ? void 0 : _a.method) ? AkitaDaoPluginParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams : void 0
    });
    return { result: result.result, appClient: new AkitaDaoPluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the AkitaDAOPlugin smart contract using the create(uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params) => {
        return this.appFactory.params.create(AkitaDaoPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the AkitaDAOPlugin smart contract using the create(uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params) => {
        return this.appFactory.createTransaction.create(AkitaDaoPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the AkitaDAOPlugin smart contract using an ABI method call using the create(uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params) => {
        const result = await this.appFactory.send.create(AkitaDaoPluginParamsFactory.create.create(params));
        return { result: { ...result.result, return: result.result.return }, appClient: new AkitaDaoPluginClient(result.appClient) };
      }
    }
  };
};
var AkitaDaoPluginClient = class _AkitaDaoPluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient9 ? appClientOrParams : new _AppClient9({
      ...appClientOrParams,
      appSpec: APP_SPEC9
    });
  }
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue(method, returnValue) {
    return returnValue !== void 0 ? getArc56ReturnValue6(returnValue, this.appClient.getABIMethod(method), APP_SPEC9.structs) : void 0;
  }
  /**
   * Returns a new `AkitaDaoPluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _AkitaDaoPluginClient(await _AppClient9.fromCreatorAndName({ ...params, appSpec: APP_SPEC9 }));
  }
  /**
   * Returns an `AkitaDaoPluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _AkitaDaoPluginClient(await _AppClient9.fromNetwork({ ...params, appSpec: APP_SPEC9 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the AkitaDAOPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `setup(uint64,bool,string)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setup: (params) => {
      return this.appClient.params.call(AkitaDaoPluginParamsFactory.setup(params));
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `newProposal(uint64,bool,byte[36],(uint8,byte[])[])uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    newProposal: (params) => {
      return this.appClient.params.call(AkitaDaoPluginParamsFactory.newProposal(params));
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `editProposal(uint64,bool,uint64,byte[36],(uint8,byte[])[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    editProposal: (params) => {
      return this.appClient.params.call(AkitaDaoPluginParamsFactory.editProposal(params));
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `submitProposal(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    submitProposal: (params) => {
      return this.appClient.params.call(AkitaDaoPluginParamsFactory.submitProposal(params));
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `voteProposal(uint64,bool,uint64,uint8)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    voteProposal: (params) => {
      return this.appClient.params.call(AkitaDaoPluginParamsFactory.voteProposal(params));
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `finalizeProposal(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    finalizeProposal: (params) => {
      return this.appClient.params.call(AkitaDaoPluginParamsFactory.finalizeProposal(params));
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `executeProposal(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    executeProposal: (params) => {
      return this.appClient.params.call(AkitaDaoPluginParamsFactory.executeProposal(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the AkitaDAOPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `setup(uint64,bool,string)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setup: (params) => {
      return this.appClient.createTransaction.call(AkitaDaoPluginParamsFactory.setup(params));
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `newProposal(uint64,bool,byte[36],(uint8,byte[])[])uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    newProposal: (params) => {
      return this.appClient.createTransaction.call(AkitaDaoPluginParamsFactory.newProposal(params));
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `editProposal(uint64,bool,uint64,byte[36],(uint8,byte[])[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    editProposal: (params) => {
      return this.appClient.createTransaction.call(AkitaDaoPluginParamsFactory.editProposal(params));
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `submitProposal(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    submitProposal: (params) => {
      return this.appClient.createTransaction.call(AkitaDaoPluginParamsFactory.submitProposal(params));
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `voteProposal(uint64,bool,uint64,uint8)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    voteProposal: (params) => {
      return this.appClient.createTransaction.call(AkitaDaoPluginParamsFactory.voteProposal(params));
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `finalizeProposal(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    finalizeProposal: (params) => {
      return this.appClient.createTransaction.call(AkitaDaoPluginParamsFactory.finalizeProposal(params));
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `executeProposal(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    executeProposal: (params) => {
      return this.appClient.createTransaction.call(AkitaDaoPluginParamsFactory.executeProposal(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the AkitaDAOPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `setup(uint64,bool,string)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setup: async (params) => {
      const result = await this.appClient.send.call(AkitaDaoPluginParamsFactory.setup(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `newProposal(uint64,bool,byte[36],(uint8,byte[])[])uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    newProposal: async (params) => {
      const result = await this.appClient.send.call(AkitaDaoPluginParamsFactory.newProposal(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `editProposal(uint64,bool,uint64,byte[36],(uint8,byte[])[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    editProposal: async (params) => {
      const result = await this.appClient.send.call(AkitaDaoPluginParamsFactory.editProposal(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `submitProposal(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    submitProposal: async (params) => {
      const result = await this.appClient.send.call(AkitaDaoPluginParamsFactory.submitProposal(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `voteProposal(uint64,bool,uint64,uint8)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    voteProposal: async (params) => {
      const result = await this.appClient.send.call(AkitaDaoPluginParamsFactory.voteProposal(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `finalizeProposal(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    finalizeProposal: async (params) => {
      const result = await this.appClient.send.call(AkitaDaoPluginParamsFactory.finalizeProposal(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaDAOPlugin smart contract using the `executeProposal(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    executeProposal: async (params) => {
      const result = await this.appClient.send.call(AkitaDaoPluginParamsFactory.executeProposal(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _AkitaDaoPluginClient(this.appClient.clone(params));
  }
  /**
   * Methods to access state for the current AkitaDAOPlugin app
   */
  state = {
    /**
     * Methods to access global state for the current AkitaDAOPlugin app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async () => {
        const result = await this.appClient.state.global.getAll();
        return {
          daoAppId: result.daoAppID
        };
      },
      /**
       * Get the current value of the daoAppID key in global state
       */
      daoAppId: async () => {
        return await this.appClient.state.global.getValue("daoAppID");
      }
    }
  };
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a setup(uint64,bool,string)void method call against the AkitaDAOPlugin contract
       */
      setup(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.setup(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a newProposal(uint64,bool,byte[36],(uint8,byte[])[])uint64 method call against the AkitaDAOPlugin contract
       */
      newProposal(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.newProposal(params)));
        resultMappers.push((v) => client.decodeReturnValue("newProposal(uint64,bool,byte[36],(uint8,byte[])[])uint64", v));
        return this;
      },
      /**
       * Add a editProposal(uint64,bool,uint64,byte[36],(uint8,byte[])[])void method call against the AkitaDAOPlugin contract
       */
      editProposal(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.editProposal(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a submitProposal(uint64,bool,uint64)void method call against the AkitaDAOPlugin contract
       */
      submitProposal(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.submitProposal(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a voteProposal(uint64,bool,uint64,uint8)void method call against the AkitaDAOPlugin contract
       */
      voteProposal(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.voteProposal(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a finalizeProposal(uint64,bool,uint64)void method call against the AkitaDAOPlugin contract
       */
      finalizeProposal(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.finalizeProposal(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a executeProposal(uint64,bool,uint64)void method call against the AkitaDAOPlugin contract
       */
      executeProposal(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.executeProposal(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a clear state call to the AkitaDAOPlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/dao.ts
var DAOPluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: AkitaDaoPluginFactory, ...params });
  }
  setup(args) {
    const methodName = "setup";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.setup({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  newProposal(args) {
    const methodName = "newProposal";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.newProposal({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  voteProposal(args) {
    const methodName = "voteProposal";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.voteProposal({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  finalizeProposal(args) {
    const methodName = "finalizeProposal";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.finalizeProposal({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  executeProposal(args) {
    const methodName = "executeProposal";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.executeProposal({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
};

// src/generated/DualStakePluginClient.ts
import {
  AppClient as _AppClient10
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory10 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC10 = { "name": "DualStakePlugin", "structs": {}, "methods": [{ "name": "create", "args": [{ "type": "uint64", "name": "registry" }], "returns": { "type": "void" }, "actions": { "create": ["NoOp"], "call": [] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "mint", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "uint64", "name": "amount" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "redeem", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 1, "bytes": 0 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": { "registry": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "cmVnaXN0cnk=" } }, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": [], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [245], "errorMessage": "Bytes has valid prefix" }, { "pc": [190, 462], "errorMessage": "Invalid dual stake app" }, { "pc": [339], "errorMessage": "Not enough ASA to pay for minting" }, { "pc": [43], "errorMessage": "OnCompletion must be NoOp" }, { "pc": [100, 183, 188, 194, 345, 455, 460], "errorMessage": "application exists" }, { "pc": [180, 452], "errorMessage": "check GlobalState exists" }, { "pc": [137, 430], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [109, 127, 148, 160, 250, 421, 440], "errorMessage": "invalid number of bytes for uint64" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCA4IDEgNgogICAgYnl0ZWNibG9jayAicmVnaXN0cnkiICJzcGVuZGluZ19hZGRyZXNzIiAweDU1ODhkY2I0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kdWFsLXN0YWtlL2NvbnRyYWN0LmFsZ28udHM6MTEKICAgIC8vIGV4cG9ydCBjbGFzcyBEdWFsU3Rha2VQbHVnaW4gZXh0ZW5kcyBDb250cmFjdCB7CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIG11c3QgYmUgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGJ6IG1haW5fY3JlYXRlX05vT3BANgogICAgcHVzaGJ5dGVzcyAweDEzNGFlYjg3IDB4ZGZmN2NkMTUgLy8gbWV0aG9kICJtaW50KHVpbnQ2NCxib29sLHVpbnQ2NCx1aW50NjQpdm9pZCIsIG1ldGhvZCAicmVkZWVtKHVpbnQ2NCxib29sLHVpbnQ2NCl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggbWludCByZWRlZW0KICAgIGVycgoKbWFpbl9jcmVhdGVfTm9PcEA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZHVhbC1zdGFrZS9jb250cmFjdC5hbGdvLnRzOjExCiAgICAvLyBleHBvcnQgY2xhc3MgRHVhbFN0YWtlUGx1Z2luIGV4dGVuZHMgQ29udHJhY3QgewogICAgcHVzaGJ5dGVzIDB4MjQwZDJmNjcgLy8gbWV0aG9kICJjcmVhdGUodWludDY0KXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBjcmVhdGUKICAgIGVycgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OnJla2V5QWRkcmVzcyhyZWtleUJhY2s6IHVpbnQ2NCwgd2FsbGV0OiB1aW50NjQpIC0+IGJ5dGVzOgpyZWtleUFkZHJlc3M6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMQogICAgLy8gZXhwb3J0IGZ1bmN0aW9uIHJla2V5QWRkcmVzcyhyZWtleUJhY2s6IGJvb2xlYW4sIHdhbGxldDogQXBwbGljYXRpb24pOiBBY2NvdW50IHsKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjIKICAgIC8vIGlmICghcmVrZXlCYWNrKSB7CiAgICBmcmFtZV9kaWcgLTIKICAgIGJueiByZWtleUFkZHJlc3NfYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMwogICAgLy8gcmV0dXJuIEdsb2JhbC56ZXJvQWRkcmVzcwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICByZXRzdWIKCnJla2V5QWRkcmVzc19hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyNgogICAgLy8gcmV0dXJuIHdhbGxldC5hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2R1YWwtc3Rha2UvY29udHJhY3QuYWxnby50czo6RHVhbFN0YWtlUGx1Z2luLmNyZWF0ZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmNyZWF0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2R1YWwtc3Rha2UvY29udHJhY3QuYWxnby50czoxOQogICAgLy8gQGFiaW1ldGhvZCh7IG9uQ3JlYXRlOiAncmVxdWlyZScgfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kdWFsLXN0YWtlL2NvbnRyYWN0LmFsZ28udHM6MTUKICAgIC8vIHJlZ2lzdHJ5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBEdWFsU3Rha2VQbHVnaW5HbG9iYWxTdGF0ZUtleSB9KQogICAgYnl0ZWNfMCAvLyAicmVnaXN0cnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kdWFsLXN0YWtlL2NvbnRyYWN0LmFsZ28udHM6MjEKICAgIC8vIHRoaXMucmVnaXN0cnkudmFsdWUgPSBBcHBsaWNhdGlvbihyZWdpc3RyeSkKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kdWFsLXN0YWtlL2NvbnRyYWN0LmFsZ28udHM6MTkKICAgIC8vIEBhYmltZXRob2QoeyBvbkNyZWF0ZTogJ3JlcXVpcmUnIH0pCiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZHVhbC1zdGFrZS9jb250cmFjdC5hbGdvLnRzOjpEdWFsU3Rha2VQbHVnaW4ubWludFtyb3V0aW5nXSgpIC0+IHZvaWQ6Cm1pbnQ6CiAgICBwdXNoYnl0ZXMgIiIKICAgIGR1cG4gMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZHVhbC1zdGFrZS9jb250cmFjdC5hbGdvLnRzOjI2LTMxCiAgICAvLyBtaW50KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbiwKICAgIC8vICAgYW1vdW50OiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgc3dhcAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgY292ZXIgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgY292ZXIgMgogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMSAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIGR1cAogICAgY292ZXIgMgogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZHVhbC1zdGFrZS9jb250cmFjdC5hbGdvLnRzOjM0CiAgICAvLyBhc3NlcnQodGhpcy5yZWdpc3RyeS52YWx1ZS5hZGRyZXNzID09PSBhcHBJZC5jcmVhdG9yLCBFUlJfTk9UX0FfRFVBTFNUQUtFX0FQUCkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kdWFsLXN0YWtlL2NvbnRyYWN0LmFsZ28udHM6MTUKICAgIC8vIHJlZ2lzdHJ5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBEdWFsU3Rha2VQbHVnaW5HbG9iYWxTdGF0ZUtleSB9KQogICAgYnl0ZWNfMCAvLyAicmVnaXN0cnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kdWFsLXN0YWtlL2NvbnRyYWN0LmFsZ28udHM6MzQKICAgIC8vIGFzc2VydCh0aGlzLnJlZ2lzdHJ5LnZhbHVlLmFkZHJlc3MgPT09IGFwcElkLmNyZWF0b3IsIEVSUl9OT1RfQV9EVUFMU1RBS0VfQVBQKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGRpZyAxCiAgICBhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIEludmFsaWQgZHVhbCBzdGFrZSBhcHAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2R1YWwtc3Rha2UvY29udHJhY3QuYWxnby50czozNi00MgogICAgLy8gaXR4bkNvbXBvc2UuYmVnaW4oCiAgICAvLyAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyLAogICAgLy8gICAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogYW1vdW50CiAgICAvLyAgIH0pCiAgICAvLyApCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kdWFsLXN0YWtlL2NvbnRyYWN0LmFsZ28udHM6MzkKICAgIC8vIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZHVhbC1zdGFrZS9jb250cmFjdC5hbGdvLnRzOjM3LTQxCiAgICAvLyBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IGFtb3VudAogICAgLy8gfSkKICAgIGludGNfMiAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2R1YWwtc3Rha2UvY29udHJhY3QuYWxnby50czo0NAogICAgLy8gY29uc3QgcmF0ZSA9IGFiaUNhbGw8dHlwZW9mIER1YWxTdGFrZS5wcm90b3R5cGUuZ2V0X3JhdGU+KHsgc2VuZGVyIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICBwdXNoYnl0ZXMgMHg4ZDQ0ZDFmMyAvLyBtZXRob2QgImdldF9yYXRlKCl1aW50NjQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBwdXNoYnl0ZXMgMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBCeXRlcyBoYXMgdmFsaWQgcHJlZml4CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kdWFsLXN0YWtlL2NvbnRyYWN0LmFsZ28udHM6NDYKICAgIC8vIGlmIChyYXRlID4gMCkgewogICAgYnogbWludF9hZnRlcl9pZl9lbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2R1YWwtc3Rha2UvY29udHJhY3QuYWxnby50czo0OC01MQogICAgLy8gaXR4bkNvbXBvc2UubmV4dDx0eXBlb2YgRHVhbFN0YWtlLnByb3RvdHlwZS5taW50Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIGJ5dGVjXzIgLy8gbWV0aG9kICJtaW50KCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAzCiAgICBkdXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgZGlnIDIKICAgIGR1cAogICAgY292ZXIgMgogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2R1YWwtc3Rha2UvY29udHJhY3QuYWxnby50czo1MwogICAgLy8gY29uc3QgYXNhSUQgPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQoYXBwSWQsIEJ5dGVzKER1YWxTdGFrZUdsb2JhbFN0YXRlS2V5QXNhSUQpKVswXQogICAgZHVwCiAgICBwdXNoYnl0ZXMgImFzYV9pZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIGR1cAogICAgY292ZXIgMgogICAgYnVyeSAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZHVhbC1zdGFrZS9jb250cmFjdC5hbGdvLnRzOjU0CiAgICAvLyBjb25zdCBwcmVjaXNpb24gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQoYXBwSWQsIEJ5dGVzKER1YWxTdGFrZUdsb2JhbFN0YXRlS2V5UmF0ZVByZWNpc2lvbikpWzBdCiAgICBwdXNoYnl0ZXMgInJhdGVfcHJlY2lzaW9uIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZHVhbC1zdGFrZS9jb250cmFjdC5hbGdvLnRzOjU1CiAgICAvLyBjb25zdCBhc2FBbW91bnQgPSBvcC5kaXZ3KC4uLm9wLm11bHcoYW1vdW50LCByYXRlKSwgcHJlY2lzaW9uKQogICAgZGlnIDUKICAgIGRpZyA0CiAgICBtdWx3CiAgICB1bmNvdmVyIDIKICAgIGRpdncKICAgIGJ1cnkgMTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2R1YWwtc3Rha2UvY29udHJhY3QuYWxnby50czo1NwogICAgLy8gY29uc3QgW2hvbGRpbmdzLCBpc09wdGVkSW5dID0gb3AuQXNzZXRIb2xkaW5nLmFzc2V0QmFsYW5jZShzZW5kZXIsIGFzYUlEKQogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBzd2FwCiAgICBidXJ5IDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2R1YWwtc3Rha2UvY29udHJhY3QuYWxnby50czo1OAogICAgLy8gYXNzZXJ0KGlzT3B0ZWRJbiAmJiBob2xkaW5ncyA+PSBhc2FBbW91bnQsIEVSUl9OT1RfRU5PVUdIX09GX0FTQSkKICAgIGJ6IG1pbnRfYm9vbF9mYWxzZUA2CiAgICBkaWcgNgogICAgZGlnIDkKICAgID49CiAgICBieiBtaW50X2Jvb2xfZmFsc2VANgogICAgaW50Y18yIC8vIDEKCm1pbnRfYm9vbF9tZXJnZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZHVhbC1zdGFrZS9jb250cmFjdC5hbGdvLnRzOjU4CiAgICAvLyBhc3NlcnQoaXNPcHRlZEluICYmIGhvbGRpbmdzID49IGFzYUFtb3VudCwgRVJSX05PVF9FTk9VR0hfT0ZfQVNBKQogICAgYXNzZXJ0IC8vIE5vdCBlbm91Z2ggQVNBIHRvIHBheSBmb3IgbWludGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZHVhbC1zdGFrZS9jb250cmFjdC5hbGdvLnRzOjYwLTY4CiAgICAvLyBpdHhuQ29tcG9zZS5uZXh0KAogICAgLy8gICBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIHNlbmRlciwKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgIGFzc2V0QW1vdW50OiBhc2FBbW91bnQsCiAgICAvLyAgICAgeGZlckFzc2V0OiBhc2FJRCwKICAgIC8vICAgICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyAgIH0pCiAgICAvLyApCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2R1YWwtc3Rha2UvY29udHJhY3QuYWxnby50czo2MwogICAgLy8gYXNzZXRSZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIGRpZyAzCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kdWFsLXN0YWtlL2NvbnRyYWN0LmFsZ28udHM6NjYKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIGRpZyA1CiAgICBkaWcgNwogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgZGlnIDgKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBkaWcgOQogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2R1YWwtc3Rha2UvY29udHJhY3QuYWxnby50czo2MS02NwogICAgLy8gaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhc3NldFJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICBhc3NldEFtb3VudDogYXNhQW1vdW50LAogICAgLy8gICB4ZmVyQXNzZXQ6IGFzYUlELAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGludCA0IC8vIDQKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZHVhbC1zdGFrZS9jb250cmFjdC5hbGdvLnRzOjcwCiAgICAvLyBpdHhuQ29tcG9zZS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCm1pbnRfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kdWFsLXN0YWtlL2NvbnRyYWN0LmFsZ28udHM6OkR1YWxTdGFrZVBsdWdpbi5taW50QDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kdWFsLXN0YWtlL2NvbnRyYWN0LmFsZ28udHM6MjYtMzEKICAgIC8vIG1pbnQoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICBhbW91bnQ6IHVpbnQ2NAogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgptaW50X2Jvb2xfZmFsc2VANjoKICAgIGludGNfMCAvLyAwCiAgICBiIG1pbnRfYm9vbF9tZXJnZUA3CgptaW50X2FmdGVyX2lmX2Vsc2VAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2R1YWwtc3Rha2UvY29udHJhY3QuYWxnby50czo3Ni04MAogICAgLy8gaXR4bkNvbXBvc2UubmV4dDx0eXBlb2YgRHVhbFN0YWtlLnByb3RvdHlwZS5taW50Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2R1YWwtc3Rha2UvY29udHJhY3QuYWxnby50czo3OQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgZGlnIDQKICAgIGRpZyA2CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZHVhbC1zdGFrZS9jb250cmFjdC5hbGdvLnRzOjc2LTgwCiAgICAvLyBpdHhuQ29tcG9zZS5uZXh0PHR5cGVvZiBEdWFsU3Rha2UucHJvdG90eXBlLm1pbnQ+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGJ5dGVjXzIgLy8gbWV0aG9kICJtaW50KCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgZGlnIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kdWFsLXN0YWtlL2NvbnRyYWN0LmFsZ28udHM6ODIKICAgIC8vIGl0eG5Db21wb3NlLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZHVhbC1zdGFrZS9jb250cmFjdC5hbGdvLnRzOjI2LTMxCiAgICAvLyBtaW50KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbiwKICAgIC8vICAgYW1vdW50OiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgYiBtaW50X2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZHVhbC1zdGFrZS9jb250cmFjdC5hbGdvLnRzOjpEdWFsU3Rha2VQbHVnaW4ubWludEA5CgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZHVhbC1zdGFrZS9jb250cmFjdC5hbGdvLnRzOjpEdWFsU3Rha2VQbHVnaW4ucmVkZWVtW3JvdXRpbmddKCkgLT4gdm9pZDoKcmVkZWVtOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZHVhbC1zdGFrZS9jb250cmFjdC5hbGdvLnRzOjg1CiAgICAvLyByZWRlZW0od2FsbGV0OiBBcHBsaWNhdGlvbiwgcmVrZXlCYWNrOiBib29sZWFuLCBhcHBJZDogQXBwbGljYXRpb24pOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZHVhbC1zdGFrZS9jb250cmFjdC5hbGdvLnRzOjg4CiAgICAvLyBhc3NlcnQodGhpcy5yZWdpc3RyeS52YWx1ZS5hZGRyZXNzID09PSBhcHBJZC5jcmVhdG9yLCBFUlJfTk9UX0FfRFVBTFNUQUtFX0FQUCkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kdWFsLXN0YWtlL2NvbnRyYWN0LmFsZ28udHM6MTUKICAgIC8vIHJlZ2lzdHJ5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBEdWFsU3Rha2VQbHVnaW5HbG9iYWxTdGF0ZUtleSB9KQogICAgYnl0ZWNfMCAvLyAicmVnaXN0cnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9kdWFsLXN0YWtlL2NvbnRyYWN0LmFsZ28udHM6ODgKICAgIC8vIGFzc2VydCh0aGlzLnJlZ2lzdHJ5LnZhbHVlLmFkZHJlc3MgPT09IGFwcElkLmNyZWF0b3IsIEVSUl9OT1RfQV9EVUFMU1RBS0VfQVBQKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGRpZyAxCiAgICBhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIEludmFsaWQgZHVhbCBzdGFrZSBhcHAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2R1YWwtc3Rha2UvY29udHJhY3QuYWxnby50czo5MC05NAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgRHVhbFN0YWtlLnByb3RvdHlwZS5yZWRlZW0+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2R1YWwtc3Rha2UvY29udHJhY3QuYWxnby50czo5MwogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgc3dhcAogICAgdW5jb3ZlciAzCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZHVhbC1zdGFrZS9jb250cmFjdC5hbGdvLnRzOjkwLTk0CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBEdWFsU3Rha2UucHJvdG90eXBlLnJlZGVlbT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4MjcxNzJmNGEgLy8gbWV0aG9kICJyZWRlZW0oKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZHVhbC1zdGFrZS9jb250cmFjdC5hbGdvLnRzOjg1CiAgICAvLyByZWRlZW0od2FsbGV0OiBBcHBsaWNhdGlvbiwgcmVrZXlCYWNrOiBib29sZWFuLCBhcHBJZDogQXBwbGljYXRpb24pOiB2b2lkIHsKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4K", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyAEAAgBBiYDCHJlZ2lzdHJ5EHNwZW5kaW5nX2FkZHJlc3MEVYjctDEZFEQxGEEAFoICBBNK64cE3/fNFTYaAI4CAC4BWACABCQNL2c2GgCOAQASAIoCAYv+QAADMgOJi/9yCESJNhoBSRUjEkQXKExnJEOAAEcCNhoBSRUjEkQXSTYaAkkVJBJEIlNMNhoDSRUjEkQXSU4CNhoESRUjEkQXSU4CTgNPAillSElOAk4DIihlRHIIREsBcgdEEkSxcghETwKyCLIHSbIAJLIQIrIBsYAEjUTR87IasgAlshAisgGztD5JVwQATFcABIAEFR98dRJESRUjEkQXSUEAf7YqshpLA0myGEsCSU4CsgAlshAisgFJgAZhc2FfaWRlSElOAkULgA5yYXRlX3ByZWNpc2lvbmVISwVLBB1PApdFC3AATEUIQQAxSwZLCQ9BACkkRLZLA3IIREsFSweI/vSyIEsIshFLCbISshRLAbIAgQSyECKyAbMkQyJC/9S2SwRLBoj+ziqyGrIgSwOyGEsBsgAlshAisgGzQv/bNhoBSRUjEkQXNhoCSRUkEkQiUzYaA0kVIxJEF0sCKWVITgIiKGVEcghESwFyB0QSRLFMTwOI/n+ABCcXL0qyGrIgshiyACWyECKyAbMkQw==", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var DualStakePluginParamsFactory = class _DualStakePluginParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "create":
          case "create(uint64)void":
            return _DualStakePluginParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs create ABI call params for the DualStakePlugin smart contract using the create(uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params) {
        return {
          ...params,
          method: "create(uint64)void",
          args: Array.isArray(params.args) ? params.args : [params.args.registry]
        };
      }
    };
  }
  /**
   * Constructs a no op call for the mint(uint64,bool,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mint(params) {
    return {
      ...params,
      method: "mint(uint64,bool,uint64,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.amount]
    };
  }
  /**
   * Constructs a no op call for the redeem(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static redeem(params) {
    return {
      ...params,
      method: "redeem(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId]
    };
  }
};
var DualStakePluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `DualStakePluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory10({
      ...params,
      appSpec: APP_SPEC10
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC10;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new DualStakePluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new DualStakePluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the DualStakePlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    var _a;
    const result = await this.appFactory.deploy({
      ...params,
      createParams: ((_a = params.createParams) == null ? void 0 : _a.method) ? DualStakePluginParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams : void 0
    });
    return { result: result.result, appClient: new DualStakePluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the DualStakePlugin smart contract using the create(uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params) => {
        return this.appFactory.params.create(DualStakePluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the DualStakePlugin smart contract using the create(uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params) => {
        return this.appFactory.createTransaction.create(DualStakePluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the DualStakePlugin smart contract using an ABI method call using the create(uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params) => {
        const result = await this.appFactory.send.create(DualStakePluginParamsFactory.create.create(params));
        return { result: { ...result.result, return: result.result.return }, appClient: new DualStakePluginClient(result.appClient) };
      }
    }
  };
};
var DualStakePluginClient = class _DualStakePluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient10 ? appClientOrParams : new _AppClient10({
      ...appClientOrParams,
      appSpec: APP_SPEC10
    });
  }
  /**
   * Returns a new `DualStakePluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _DualStakePluginClient(await _AppClient10.fromCreatorAndName({ ...params, appSpec: APP_SPEC10 }));
  }
  /**
   * Returns an `DualStakePluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _DualStakePluginClient(await _AppClient10.fromNetwork({ ...params, appSpec: APP_SPEC10 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the DualStakePlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the DualStakePlugin smart contract using the `mint(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    mint: (params) => {
      return this.appClient.params.call(DualStakePluginParamsFactory.mint(params));
    },
    /**
     * Makes a call to the DualStakePlugin smart contract using the `redeem(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    redeem: (params) => {
      return this.appClient.params.call(DualStakePluginParamsFactory.redeem(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the DualStakePlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the DualStakePlugin smart contract using the `mint(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    mint: (params) => {
      return this.appClient.createTransaction.call(DualStakePluginParamsFactory.mint(params));
    },
    /**
     * Makes a call to the DualStakePlugin smart contract using the `redeem(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    redeem: (params) => {
      return this.appClient.createTransaction.call(DualStakePluginParamsFactory.redeem(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the DualStakePlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the DualStakePlugin smart contract using the `mint(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mint: async (params) => {
      const result = await this.appClient.send.call(DualStakePluginParamsFactory.mint(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the DualStakePlugin smart contract using the `redeem(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    redeem: async (params) => {
      const result = await this.appClient.send.call(DualStakePluginParamsFactory.redeem(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _DualStakePluginClient(this.appClient.clone(params));
  }
  /**
   * Methods to access state for the current DualStakePlugin app
   */
  state = {
    /**
     * Methods to access global state for the current DualStakePlugin app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async () => {
        const result = await this.appClient.state.global.getAll();
        return {
          registry: result.registry
        };
      },
      /**
       * Get the current value of the registry key in global state
       */
      registry: async () => {
        return await this.appClient.state.global.getValue("registry");
      }
    }
  };
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a mint(uint64,bool,uint64,uint64)void method call against the DualStakePlugin contract
       */
      mint(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mint(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a redeem(uint64,bool,uint64)void method call against the DualStakePlugin contract
       */
      redeem(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.redeem(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a clear state call to the DualStakePlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/dual-stake.ts
var DualStakePluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: DualStakePluginFactory, ...params });
  }
  mint(args) {
    const methodName = "mint";
    if (args === void 0) {
      return (_spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (_spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.mint({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  redeem(args) {
    const methodName = "redeem";
    if (args === void 0) {
      return (_spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (_spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.redeem({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
};

// src/generated/GatePluginClient.ts
import {
  AppClient as _AppClient11
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory11 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC11 = { "name": "GatePlugin", "structs": {}, "methods": [{ "name": "create", "args": [{ "type": "uint64", "name": "gateAppID" }], "returns": { "type": "void" }, "actions": { "create": ["NoOp"], "call": [] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "register", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "(uint64,uint64,uint8)[]", "name": "filters" }, { "type": "byte[][]", "name": "args" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 1, "bytes": 0 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": { "gateAppID": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "Z2F0ZV9hcHBfaWQ=" } }, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": [], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [243], "errorMessage": "Bytes has valid prefix" }, { "pc": [25], "errorMessage": "OnCompletion must be NoOp" }, { "pc": [159, 252], "errorMessage": "application exists" }, { "pc": [156], "errorMessage": "check GlobalState exists" }, { "pc": [113], "errorMessage": "invalid number of bytes for (len+(uint64,uint64,uint8)[])" }, { "pc": [90], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [66, 80, 247], "errorMessage": "invalid number of bytes for uint64" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCA4IDEgNjEwMAogICAgYnl0ZWNibG9jayAiZ2F0ZV9hcHBfaWQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9nYXRlL2NvbnRyYWN0LmFsZ28udHM6MTMKICAgIC8vIGV4cG9ydCBjbGFzcyBHYXRlUGx1Z2luIGV4dGVuZHMgQmFzZUdhdGUgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBieiBtYWluX2NyZWF0ZV9Ob09wQDUKICAgIHB1c2hieXRlcyAweDJmYTMxMjM2IC8vIG1ldGhvZCAicmVnaXN0ZXIodWludDY0LGJvb2wsKHVpbnQ2NCx1aW50NjQsdWludDgpW10sYnl0ZVtdW10pdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIHJlZ2lzdGVyCiAgICBlcnIKCm1haW5fY3JlYXRlX05vT3BANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2dhdGUvY29udHJhY3QuYWxnby50czoxMwogICAgLy8gZXhwb3J0IGNsYXNzIEdhdGVQbHVnaW4gZXh0ZW5kcyBCYXNlR2F0ZSB7CiAgICBwdXNoYnl0ZXMgMHgyNDBkMmY2NyAvLyBtZXRob2QgImNyZWF0ZSh1aW50NjQpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIGNyZWF0ZQogICAgZXJyCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZ2F0ZS9jb250cmFjdC5hbGdvLnRzOjpHYXRlUGx1Z2luLmNyZWF0ZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmNyZWF0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2dhdGUvY29udHJhY3QuYWxnby50czoyMQogICAgLy8gQGFiaW1ldGhvZCh7IG9uQ3JlYXRlOiAncmVxdWlyZScgfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9nYXRlL2NvbnRyYWN0LmFsZ28udHM6MTcKICAgIC8vIGdhdGVBcHBJRCA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2F0ZVBsdWdpbkdsb2JhbFN0YXRlS2V5R2F0ZUFwcElEIH0pCiAgICBieXRlY18wIC8vICJnYXRlX2FwcF9pZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2dhdGUvY29udHJhY3QuYWxnby50czoyMwogICAgLy8gdGhpcy5nYXRlQXBwSUQudmFsdWUgPSBBcHBsaWNhdGlvbihnYXRlQXBwSUQpCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZ2F0ZS9jb250cmFjdC5hbGdvLnRzOjIxCiAgICAvLyBAYWJpbWV0aG9kKHsgb25DcmVhdGU6ICdyZXF1aXJlJyB9KQogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2dhdGUvY29udHJhY3QuYWxnby50czo6R2F0ZVBsdWdpbi5yZWdpc3Rlcltyb3V0aW5nXSgpIC0+IHZvaWQ6CnJlZ2lzdGVyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZ2F0ZS9jb250cmFjdC5hbGdvLnRzOjI4LTMzCiAgICAvLyByZWdpc3RlcigKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBmaWx0ZXJzOiBHYXRlRmlsdGVyW10sCiAgICAvLyAgIGFyZ3M6IEdhdGVBcmdzCiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgY292ZXIgMwogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGR1cAogICAgcHVzaGludCAxNyAvLyAxNwogICAgKgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIHVuY292ZXIgMgogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuKyh1aW50NjQsdWludDY0LHVpbnQ4KVtdKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgcHVzaGJ5dGVzICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBjb3ZlciAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9nYXRlL2NvbnRyYWN0LmFsZ28udHM6MzYtNDkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEdhdGUucHJvdG90eXBlLnJlZ2lzdGVyPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZ2F0ZUFwcElELnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiB0aGlzLmdhdGVBcHBJRC52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiB0aGlzLm1icihmaWx0ZXJzLmxlbmd0aCkuZ2F0ZVJlZ2lzdHJ5CiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgZmlsdGVycywKICAgIC8vICAgICBhcmdzLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZ2F0ZS9jb250cmFjdC5hbGdvLnRzOjQyCiAgICAvLyByZWNlaXZlcjogdGhpcy5nYXRlQXBwSUQudmFsdWUuYWRkcmVzcywKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9nYXRlL2NvbnRyYWN0LmFsZ28udHM6MTcKICAgIC8vIGdhdGVBcHBJRCA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2F0ZVBsdWdpbkdsb2JhbFN0YXRlS2V5R2F0ZUFwcElEIH0pCiAgICBieXRlY18wIC8vICJnYXRlX2FwcF9pZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2dhdGUvY29udHJhY3QuYWxnby50czo0MgogICAgLy8gcmVjZWl2ZXI6IHRoaXMuZ2F0ZUFwcElELnZhbHVlLmFkZHJlc3MsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgc3dhcAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBjb3ZlciA1CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZ2F0ZXMvYmFzZS50czo4CiAgICAvLyBnYXRlUmVnaXN0cnk6IDZfMTAwICsgKDQwMCAqICgzMiAqIGxlbmd0aCkpLAogICAgc3dhcAogICAgcHVzaGludCAxMjgwMCAvLyAxMjgwMAogICAgKgogICAgaW50Y18zIC8vIDYxMDAKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9nYXRlcy9iYXNlLnRzOjcKICAgIC8vIGFwcFJlZ2lzdHJ5OiA2XzEwMCwKICAgIGludGNfMyAvLyA2MTAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZ2F0ZXMvYmFzZS50czo2LTkKICAgIC8vIHJldHVybiB7CiAgICAvLyAgIGFwcFJlZ2lzdHJ5OiA2XzEwMCwKICAgIC8vICAgZ2F0ZVJlZ2lzdHJ5OiA2XzEwMCArICg0MDAgKiAoMzIgKiBsZW5ndGgpKSwKICAgIC8vIH0KICAgIGl0b2IKICAgIHN3YXAKICAgIGl0b2IKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZ2F0ZS9jb250cmFjdC5hbGdvLnRzOjQzCiAgICAvLyBhbW91bnQ6IHRoaXMubWJyKGZpbHRlcnMubGVuZ3RoKS5nYXRlUmVnaXN0cnkKICAgIGludGNfMSAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9nYXRlL2NvbnRyYWN0LmFsZ28udHM6NDAtNDQKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IHRoaXMuZ2F0ZUFwcElELnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogdGhpcy5tYnIoZmlsdGVycy5sZW5ndGgpLmdhdGVSZWdpc3RyeQogICAgLy8gfSksCiAgICBpbnRjXzIgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9nYXRlL2NvbnRyYWN0LmFsZ28udHM6MzYtNDkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEdhdGUucHJvdG90eXBlLnJlZ2lzdGVyPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZ2F0ZUFwcElELnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiB0aGlzLmdhdGVBcHBJRC52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiB0aGlzLm1icihmaWx0ZXJzLmxlbmd0aCkuZ2F0ZVJlZ2lzdHJ5CiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgZmlsdGVycywKICAgIC8vICAgICBhcmdzLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMgogICAgLy8gaWYgKCFyZWtleUJhY2spIHsKICAgIGJueiByZWdpc3Rlcl9hZnRlcl9pZl9lbHNlQDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzIzCiAgICAvLyByZXR1cm4gR2xvYmFsLnplcm9BZGRyZXNzCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKCnJlZ2lzdGVyX2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6cmVrZXlBZGRyZXNzQDg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9nYXRlL2NvbnRyYWN0LmFsZ28udHM6MzYtNDkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEdhdGUucHJvdG90eXBlLnJlZ2lzdGVyPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZ2F0ZUFwcElELnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiB0aGlzLmdhdGVBcHBJRC52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiB0aGlzLm1icihmaWx0ZXJzLmxlbmd0aCkuZ2F0ZVJlZ2lzdHJ5CiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgZmlsdGVycywKICAgIC8vICAgICBhcmdzLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4YzIxYzdiYTAgLy8gbWV0aG9kICJyZWdpc3RlcihwYXksKHVpbnQ2NCx1aW50NjQsdWludDgpW10sYnl0ZVtdW10pdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGR1cAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBnaXR4biAxIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBwdXNoYnl0ZXMgMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBCeXRlcyBoYXMgdmFsaWQgcHJlZml4CiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvZ2F0ZS9jb250cmFjdC5hbGdvLnRzOjI4LTMzCiAgICAvLyByZWdpc3RlcigKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBmaWx0ZXJzOiBHYXRlRmlsdGVyW10sCiAgICAvLyAgIGFyZ3M6IEdhdGVBcmdzCiAgICAvLyApOiB2b2lkIHsKICAgIHJldHVybiAvLyBvbiBlcnJvcjogaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAoKcmVnaXN0ZXJfYWZ0ZXJfaWZfZWxzZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjYKICAgIC8vIHJldHVybiB3YWxsZXQuYWRkcmVzcwogICAgZGlnIDQKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2dhdGUvY29udHJhY3QuYWxnby50czo0OAogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgYiByZWdpc3Rlcl9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OnJla2V5QWRkcmVzc0A4Cg==", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyAEAAgB1C8mAQtnYXRlX2FwcF9pZDEZFEQxGEEADoAEL6MSNjYaAI4BAB0AgAQkDS9nNhoAjgEAAQA2GgFJFSMSRBcoTGckQzYaAUkVIxJEF0k2GgJJFSQSRCJTNhoDSU4DSSJZSYERC4ECCE8CFRJENhoETgNPAoAQc3BlbmRpbmdfYWRkcmVzc2VISU4CTgOxIihlTElOAk4FRHIIREyBgGQLJQglFkwWUCNbsgiyB7IAJLIQIrIBtkAAOjIDgATCHHugshpLBLIaSwOyGrIgSbIYSwGyAIEGshAisgGztwE+SVcEAExXAASABBUffHUSRBUjEkNLBHIIREL/wA==", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var GatePluginParamsFactory = class _GatePluginParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "create":
          case "create(uint64)void":
            return _GatePluginParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs create ABI call params for the GatePlugin smart contract using the create(uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params) {
        return {
          ...params,
          method: "create(uint64)void",
          args: Array.isArray(params.args) ? params.args : [params.args.gateAppId]
        };
      }
    };
  }
  /**
   * Constructs a no op call for the register(uint64,bool,(uint64,uint64,uint8)[],byte[][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static register(params) {
    return {
      ...params,
      method: "register(uint64,bool,(uint64,uint64,uint8)[],byte[][])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.filters, params.args.args]
    };
  }
};
var GatePluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `GatePluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory11({
      ...params,
      appSpec: APP_SPEC11
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC11;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new GatePluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new GatePluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the GatePlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    var _a;
    const result = await this.appFactory.deploy({
      ...params,
      createParams: ((_a = params.createParams) == null ? void 0 : _a.method) ? GatePluginParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams : void 0
    });
    return { result: result.result, appClient: new GatePluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the GatePlugin smart contract using the create(uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params) => {
        return this.appFactory.params.create(GatePluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the GatePlugin smart contract using the create(uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params) => {
        return this.appFactory.createTransaction.create(GatePluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the GatePlugin smart contract using an ABI method call using the create(uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params) => {
        const result = await this.appFactory.send.create(GatePluginParamsFactory.create.create(params));
        return { result: { ...result.result, return: result.result.return }, appClient: new GatePluginClient(result.appClient) };
      }
    }
  };
};
var GatePluginClient = class _GatePluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient11 ? appClientOrParams : new _AppClient11({
      ...appClientOrParams,
      appSpec: APP_SPEC11
    });
  }
  /**
   * Returns a new `GatePluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _GatePluginClient(await _AppClient11.fromCreatorAndName({ ...params, appSpec: APP_SPEC11 }));
  }
  /**
   * Returns an `GatePluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _GatePluginClient(await _AppClient11.fromNetwork({ ...params, appSpec: APP_SPEC11 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the GatePlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the GatePlugin smart contract using the `register(uint64,bool,(uint64,uint64,uint8)[],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    register: (params) => {
      return this.appClient.params.call(GatePluginParamsFactory.register(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the GatePlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the GatePlugin smart contract using the `register(uint64,bool,(uint64,uint64,uint8)[],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    register: (params) => {
      return this.appClient.createTransaction.call(GatePluginParamsFactory.register(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the GatePlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the GatePlugin smart contract using the `register(uint64,bool,(uint64,uint64,uint8)[],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    register: async (params) => {
      const result = await this.appClient.send.call(GatePluginParamsFactory.register(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _GatePluginClient(this.appClient.clone(params));
  }
  /**
   * Methods to access state for the current GatePlugin app
   */
  state = {
    /**
     * Methods to access global state for the current GatePlugin app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async () => {
        const result = await this.appClient.state.global.getAll();
        return {
          gateAppId: result.gateAppID
        };
      },
      /**
       * Get the current value of the gateAppID key in global state
       */
      gateAppId: async () => {
        return await this.appClient.state.global.getValue("gateAppID");
      }
    }
  };
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a register(uint64,bool,(uint64,uint64,uint8)[],byte[][])void method call against the GatePlugin contract
       */
      register(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.register(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a clear state call to the GatePlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/gate.ts
var GatePluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: GatePluginFactory, ...params });
  }
  register(args) {
    const methodName = "register";
    if (args === void 0) {
      return (_spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (_spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.register({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
};

// src/generated/HyperSwapPluginClient.ts
import { getArc56ReturnValue as getArc56ReturnValue7, getABIStructFromABITuple as getABIStructFromABITuple7 } from "@algorandfoundation/algokit-utils/types/app-arc56";
import {
  AppClient as _AppClient12
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory12 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC12 = { "name": "HyperSwapPlugin", "structs": { "Object57CB3C34": [{ "name": "root", "type": "uint64" }, { "name": "data", "type": "uint64" }], "HyperSwapMBRData": [{ "name": "offers", "type": "uint64" }, { "name": "participants", "type": "uint64" }, { "name": "hashes", "type": "uint64" }, { "name": "mm", "type": "Object57CB3C34" }] }, "methods": [{ "name": "create", "args": [{ "type": "string", "name": "version" }, { "type": "uint64", "name": "akitaDAO" }], "returns": { "type": "void" }, "actions": { "create": ["NoOp"], "call": [] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "offer", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "byte[32]", "name": "root" }, { "type": "uint64", "name": "leaves" }, { "type": "byte[32]", "name": "participantsRoot" }, { "type": "uint64", "name": "participantLeaves" }, { "type": "uint64", "name": "expiration" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "accept", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "id" }, { "type": "byte[32][]", "name": "proof" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "escrow", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "id" }, { "type": "address", "name": "receiver" }, { "type": "uint64", "name": "asset" }, { "type": "uint64", "name": "amount" }, { "type": "byte[32][]", "name": "proof" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "disburse", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "id" }, { "type": "uint64", "name": "receiverWallet" }, { "type": "address", "name": "receiver" }, { "type": "uint64", "name": "asset" }, { "type": "uint64", "name": "amount" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "cancel", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "id" }, { "type": "byte[32][]", "name": "proof" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "withdraw", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "id" }, { "type": "address", "name": "receiver" }, { "type": "uint64", "name": "asset" }, { "type": "uint64", "name": "amount" }, { "type": "byte[32][]", "name": "proof" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "updateAkitaDAO", "args": [{ "type": "uint64", "name": "akitaDAO" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "opUp", "args": [], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "mbr", "args": [], "returns": { "type": "(uint64,uint64,uint64,(uint64,uint64))", "struct": "HyperSwapMBRData" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": true, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 1, "bytes": 1 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": { "version": { "keyType": "AVMString", "valueType": "AVMString", "key": "dmVyc2lvbg==", "desc": "the current version of the contract" }, "akitaDAO": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "YWtpdGFfZGFv", "desc": "the app ID of the Akita DAO" } }, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": [], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [46], "errorMessage": "OnCompletion must be NoOp" }, { "pc": [1235], "errorMessage": "Only the Akita DAO can call this function" }, { "pc": [203, 326, 459, 630, 724, 746, 770, 1233], "errorMessage": "application exists" }, { "pc": [315, 448, 614, 914, 1025, 1148, 1220], "errorMessage": "check GlobalState exists" }, { "pc": [439, 605, 1014, 1137], "errorMessage": "invalid number of bytes for (len+uint8[32][])" }, { "pc": [218], "errorMessage": "invalid number of bytes for (len+utf8[])" }, { "pc": [264, 413, 535, 861, 988, 1087], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [229, 255, 282, 298, 306, 404, 423, 525, 548, 569, 584, 852, 871, 879, 895, 903, 979, 998, 1078, 1097, 1113, 1121, 1213], "errorMessage": "invalid number of bytes for uint64" }, { "pc": [274, 290, 558, 887, 1105], "errorMessage": "invalid number of bytes for uint8[32]" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCA4IDEgMzIgMzQ5MDAKICAgIGJ5dGVjYmxvY2sgImFraXRhX2RhbyIgInNwZW5kaW5nX2FkZHJlc3MiICJhYWwiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MTIKICAgIC8vIGV4cG9ydCBjbGFzcyBIeXBlclN3YXBQbHVnaW4gZXh0ZW5kcyBjbGFzc2VzKEJhc2VIeXBlclN3YXAsIEFraXRhQmFzZUNvbnRyYWN0KSB7CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIG11c3QgYmUgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGJ6IG1haW5fY3JlYXRlX05vT3BAMTUKICAgIHB1c2hieXRlc3MgMHg2Y2RmODQzMSAweGY5ZGJkNTBjIDB4OWUyOTAzOTYgMHhiNjc4ZTViNSAweDdmMGFkMTk4IDB4YjYzYWIwZDMgMHgzM2U5MmM5NCAweDg1NGRlZGUwIDB4ODQwNzMzZGQgLy8gbWV0aG9kICJvZmZlcih1aW50NjQsYm9vbCxieXRlWzMyXSx1aW50NjQsYnl0ZVszMl0sdWludDY0LHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJhY2NlcHQodWludDY0LGJvb2wsdWludDY0LGJ5dGVbMzJdW10pdm9pZCIsIG1ldGhvZCAiZXNjcm93KHVpbnQ2NCxib29sLHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsYnl0ZVszMl1bXSl2b2lkIiwgbWV0aG9kICJkaXNidXJzZSh1aW50NjQsYm9vbCx1aW50NjQsdWludDY0LGFkZHJlc3MsdWludDY0LHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJjYW5jZWwodWludDY0LGJvb2wsdWludDY0LGJ5dGVbMzJdW10pdm9pZCIsIG1ldGhvZCAid2l0aGRyYXcodWludDY0LGJvb2wsdWludDY0LGFkZHJlc3MsdWludDY0LHVpbnQ2NCxieXRlWzMyXVtdKXZvaWQiLCBtZXRob2QgInVwZGF0ZUFraXRhREFPKHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJvcFVwKCl2b2lkIiwgbWV0aG9kICJtYnIoKSh1aW50NjQsdWludDY0LHVpbnQ2NCwodWludDY0LHVpbnQ2NCkpIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggb2ZmZXIgYWNjZXB0IGVzY3JvdyBkaXNidXJzZSBjYW5jZWwgd2l0aGRyYXcgdXBkYXRlQWtpdGFEQU8gbWFpbl9vcFVwX3JvdXRlQDEyIG1haW5fbWJyX3JvdXRlQDEzCiAgICBlcnIKCm1haW5fbWJyX3JvdXRlQDEzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2h5cGVyLXN3YXAvYmFzZS50czo2CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHB1c2hieXRlcyAweDE1MWY3Yzc1MDAwMDAwMDAwMDAwYzZkNDAwMDAwMDAwMDAwMDg4NTQwMDAwMDAwMDAwMDA4ODU0MDAwMDAwMDAwMDAwOWZjNDAwMDAwMDAwMDAwMDZhYTQKICAgIGxvZwogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKbWFpbl9vcFVwX3JvdXRlQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NDMKICAgIC8vIG9wVXAoKTogdm9pZCB7IH0KICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCm1haW5fY3JlYXRlX05vT3BAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MTIKICAgIC8vIGV4cG9ydCBjbGFzcyBIeXBlclN3YXBQbHVnaW4gZXh0ZW5kcyBjbGFzc2VzKEJhc2VIeXBlclN3YXAsIEFraXRhQmFzZUNvbnRyYWN0KSB7CiAgICBwdXNoYnl0ZXMgMHhjZDlhZDY3ZSAvLyBtZXRob2QgImNyZWF0ZShzdHJpbmcsdWludDY0KXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBjcmVhdGUKICAgIGVycgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OnJla2V5QWRkcmVzcyhyZWtleUJhY2s6IHVpbnQ2NCwgd2FsbGV0OiB1aW50NjQpIC0+IGJ5dGVzOgpyZWtleUFkZHJlc3M6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMQogICAgLy8gZXhwb3J0IGZ1bmN0aW9uIHJla2V5QWRkcmVzcyhyZWtleUJhY2s6IGJvb2xlYW4sIHdhbGxldDogQXBwbGljYXRpb24pOiBBY2NvdW50IHsKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjIKICAgIC8vIGlmICghcmVrZXlCYWNrKSB7CiAgICBmcmFtZV9kaWcgLTIKICAgIGJueiByZWtleUFkZHJlc3NfYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMwogICAgLy8gcmV0dXJuIEdsb2JhbC56ZXJvQWRkcmVzcwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICByZXRzdWIKCnJla2V5QWRkcmVzc19hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyNgogICAgLy8gcmV0dXJuIHdhbGxldC5hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czo6SHlwZXJTd2FwUGx1Z2luLmNyZWF0ZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmNyZWF0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czoxNAogICAgLy8gQGFiaW1ldGhvZCh7IG9uQ3JlYXRlOiAncmVxdWlyZScgfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1dGY4W10pCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI3CiAgICAvLyB2ZXJzaW9uID0gR2xvYmFsU3RhdGU8c3RyaW5nPih7IGtleTogR2xvYmFsU3RhdGVLZXlWZXJzaW9uIH0pCiAgICBwdXNoYnl0ZXMgInZlcnNpb24iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MTYKICAgIC8vIHRoaXMudmVyc2lvbi52YWx1ZSA9IHZlcnNpb24KICAgIHVuY292ZXIgMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjE3CiAgICAvLyB0aGlzLmFraXRhREFPLnZhbHVlID0gYWtpdGFEQU8KICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MTQKICAgIC8vIEBhYmltZXRob2QoeyBvbkNyZWF0ZTogJ3JlcXVpcmUnIH0pCiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjpIeXBlclN3YXBQbHVnaW4ub2ZmZXJbcm91dGluZ10oKSAtPiB2b2lkOgpvZmZlcjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czoyMi0zMAogICAgLy8gb2ZmZXIoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgcm9vdDogYnl0ZXM8MzI+LAogICAgLy8gICBsZWF2ZXM6IHVpbnQ2NCwKICAgIC8vICAgcGFydGljaXBhbnRzUm9vdDogYnl0ZXM8MzI+LAogICAgLy8gICBwYXJ0aWNpcGFudExlYXZlczogdWludDY0LAogICAgLy8gICBleHBpcmF0aW9uOiB1aW50NjQKICAgIC8vICkgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDcKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgNgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MzYKICAgIC8vIGNvbnN0IGFwcElkID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLmh5cGVyU3dhcCkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czozNgogICAgLy8gY29uc3QgYXBwSWQgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuaHlwZXJTd2FwKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDAKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBcHBMaXN0KSkKICAgIGJ5dGVjXzIgLy8gImFhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czozNgogICAgLy8gY29uc3QgYXBwSWQgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuaHlwZXJTd2FwKQogICAgcHVzaGludCA1NiAvLyA1NgogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czozOC01NAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgSHlwZXJTd2FwLnByb3RvdHlwZS5vZmZlcj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBoeXBlclN3YXBPZmZlck1CUkFtb3VudAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIHJvb3QsCiAgICAvLyAgICAgbGVhdmVzLAogICAgLy8gICAgIHBhcnRpY2lwYW50c1Jvb3QsCiAgICAvLyAgICAgcGFydGljaXBhbnRMZWF2ZXMsCiAgICAvLyAgICAgZXhwaXJhdGlvbiwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czo0NAogICAgLy8gcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czozNQogICAgLy8gY29uc3QgaHlwZXJTd2FwT2ZmZXJNQlJBbW91bnQ6IHVpbnQ2NCA9IGNvc3RzLm9mZmVycyArIGNvc3RzLnBhcnRpY2lwYW50cyArIChtZXRhTWVya2xlc0Nvc3QgKiAyKQogICAgcHVzaGludCAyMjIyMDAgLy8gMjIyMjAwCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6NDItNDYKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogaHlwZXJTd2FwT2ZmZXJNQlJBbW91bnQKICAgIC8vIH0pLAogICAgaW50Y18yIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjM4LTU0CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBIeXBlclN3YXAucHJvdG90eXBlLm9mZmVyPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IGh5cGVyU3dhcE9mZmVyTUJSQW1vdW50CiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgcm9vdCwKICAgIC8vICAgICBsZWF2ZXMsCiAgICAvLyAgICAgcGFydGljaXBhbnRzUm9vdCwKICAgIC8vICAgICBwYXJ0aWNpcGFudExlYXZlcywKICAgIC8vICAgICBleHBpcmF0aW9uLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6NTMKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIHVuY292ZXIgNwogICAgdW5jb3ZlciA4CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjM4LTU0CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBIeXBlclN3YXAucHJvdG90eXBlLm9mZmVyPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IGh5cGVyU3dhcE9mZmVyTUJSQW1vdW50CiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgcm9vdCwKICAgIC8vICAgICBsZWF2ZXMsCiAgICAvLyAgICAgcGFydGljaXBhbnRzUm9vdCwKICAgIC8vICAgICBwYXJ0aWNpcGFudExlYXZlcywKICAgIC8vICAgICBleHBpcmF0aW9uLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4MGRiM2E0NGIgLy8gbWV0aG9kICJvZmZlcihwYXksYnl0ZVszMl0sdWludDY0LGJ5dGVbMzJdLHVpbnQ2NCx1aW50NjQpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDcKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDYKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MjItMzAKICAgIC8vIG9mZmVyKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIHJvb3Q6IGJ5dGVzPDMyPiwKICAgIC8vICAgbGVhdmVzOiB1aW50NjQsCiAgICAvLyAgIHBhcnRpY2lwYW50c1Jvb3Q6IGJ5dGVzPDMyPiwKICAgIC8vICAgcGFydGljaXBhbnRMZWF2ZXM6IHVpbnQ2NCwKICAgIC8vICAgZXhwaXJhdGlvbjogdWludDY0CiAgICAvLyApIHsKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6Okh5cGVyU3dhcFBsdWdpbi5hY2NlcHRbcm91dGluZ10oKSAtPiB2b2lkOgphY2NlcHQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6NTctNjIKICAgIC8vIGFjY2VwdCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBpZDogdWludDY0LAogICAgLy8gICBwcm9vZjogUHJvb2YKICAgIC8vICkgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18zIC8vIDMyCiAgICAqCiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1aW50OFszMl1bXSkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMSAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czo2NQogICAgLy8gY29uc3QgYXBwSWQgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuaHlwZXJTd2FwKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjY1CiAgICAvLyBjb25zdCBhcHBJZCA9IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5oeXBlclN3YXApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMiAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjY1CiAgICAvLyBjb25zdCBhcHBJZCA9IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5oeXBlclN3YXApCiAgICBwdXNoaW50IDU2IC8vIDU2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjY3LTgwCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBIeXBlclN3YXAucHJvdG90eXBlLmFjY2VwdD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiB0aGlzLm1icigpLnBhcnRpY2lwYW50cwogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGlkLAogICAgLy8gICAgIHByb29mLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjczCiAgICAvLyByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjc0CiAgICAvLyBhbW91bnQ6IHRoaXMubWJyKCkucGFydGljaXBhbnRzCiAgICBpbnRjIDQgLy8gMzQ5MDAKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czo3MS03NQogICAgLy8gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiB0aGlzLm1icigpLnBhcnRpY2lwYW50cwogICAgLy8gfSksCiAgICBpbnRjXzIgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6NjctODAKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEh5cGVyU3dhcC5wcm90b3R5cGUuYWNjZXB0Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IHRoaXMubWJyKCkucGFydGljaXBhbnRzCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgaWQsCiAgICAvLyAgICAgcHJvb2YsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czo3OQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciA0CiAgICB1bmNvdmVyIDUKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6NjctODAKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEh5cGVyU3dhcC5wcm90b3R5cGUuYWNjZXB0Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IHRoaXMubWJyKCkucGFydGljaXBhbnRzCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgaWQsCiAgICAvLyAgICAgcHJvb2YsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHhiZGUxYTExZSAvLyBtZXRob2QgImFjY2VwdChwYXksdWludDY0LGJ5dGVbMzJdW10pdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6NTctNjIKICAgIC8vIGFjY2VwdCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBpZDogdWludDY0LAogICAgLy8gICBwcm9vZjogUHJvb2YKICAgIC8vICkgewogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czo6SHlwZXJTd2FwUGx1Z2luLmVzY3Jvd1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmVzY3JvdzoKICAgIHB1c2hieXRlcyAiIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjgzLTkxCiAgICAvLyBlc2Nyb3coCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgaWQ6IHVpbnQ2NCwKICAgIC8vICAgcmVjZWl2ZXI6IEFjY291bnQsCiAgICAvLyAgIGFzc2V0OiB1aW50NjQsCiAgICAvLyAgIGFtb3VudDogdWludDY0LAogICAgLy8gICBwcm9vZjogUHJvb2YKICAgIC8vICkgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgc3dhcAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBjb3ZlciAyCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgY292ZXIgMgogICAgbGVuCiAgICBpbnRjXzMgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICBjb3ZlciAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA2CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBjb3ZlciAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA3CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzMgLy8gMzIKICAgICoKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBzd2FwCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdWludDhbMzJdW10pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMSAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czo5MwogICAgLy8gY29uc3QgaHlwZXJTd2FwQXBwID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLmh5cGVyU3dhcCkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czo5MwogICAgLy8gY29uc3QgaHlwZXJTd2FwQXBwID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLmh5cGVyU3dhcCkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQwCiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBieXRlY18yIC8vICJhYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6OTMKICAgIC8vIGNvbnN0IGh5cGVyU3dhcEFwcCA9IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5oeXBlclN3YXApCiAgICBwdXNoaW50IDU2IC8vIDU2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjk1CiAgICAvLyBpZiAoYXNzZXQgPT09IDApIHsKICAgIGJueiBlc2Nyb3dfZWxzZV9ib2R5QDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czo5Ny0xMTIKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEh5cGVyU3dhcC5wcm90b3R5cGUuZXNjcm93Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGh5cGVyU3dhcEFwcCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogaHlwZXJTd2FwQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IGFtb3VudCArIHRoaXMubWJyKCkuaGFzaGVzCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgaWQsCiAgICAvLyAgICAgcmVjZWl2ZXIsCiAgICAvLyAgICAgYW1vdW50LAogICAgLy8gICAgIHByb29mLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjEwMwogICAgLy8gcmVjZWl2ZXI6IGh5cGVyU3dhcEFwcC5hZGRyZXNzLAogICAgZHVwbiAyCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MTA0CiAgICAvLyBhbW91bnQ6IGFtb3VudCArIHRoaXMubWJyKCkuaGFzaGVzCiAgICBkaWcgNQogICAgaW50YyA0IC8vIDM0OTAwCiAgICArCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZGlnIDIKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czoxMDEtMTA1CiAgICAvLyBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBoeXBlclN3YXBBcHAuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBhbW91bnQgKyB0aGlzLm1icigpLmhhc2hlcwogICAgLy8gfSksCiAgICBpbnRjXzIgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6OTctMTEyCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBIeXBlclN3YXAucHJvdG90eXBlLmVzY3Jvdz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBoeXBlclN3YXBBcHAsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGh5cGVyU3dhcEFwcC5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBhbW91bnQgKyB0aGlzLm1icigpLmhhc2hlcwogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGlkLAogICAgLy8gICAgIHJlY2VpdmVyLAogICAgLy8gICAgIGFtb3VudCwKICAgIC8vICAgICBwcm9vZiwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjExMQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgZGlnIDExCiAgICBkaWcgMTMKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6OTctMTEyCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBIeXBlclN3YXAucHJvdG90eXBlLmVzY3Jvdz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBoeXBlclN3YXBBcHAsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGh5cGVyU3dhcEFwcC5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBhbW91bnQgKyB0aGlzLm1icigpLmhhc2hlcwogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGlkLAogICAgLy8gICAgIHJlY2VpdmVyLAogICAgLy8gICAgIGFtb3VudCwKICAgIC8vICAgICBwcm9vZiwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweGQ4NWZlYmRkIC8vIG1ldGhvZCAiZXNjcm93KHBheSx1aW50NjQsYWRkcmVzcyx1aW50NjQsYnl0ZVszMl1bXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA3CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0Cgplc2Nyb3dfYWZ0ZXJfaWZfZWxzZUAxMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czo4My05MQogICAgLy8gZXNjcm93KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGlkOiB1aW50NjQsCiAgICAvLyAgIHJlY2VpdmVyOiBBY2NvdW50LAogICAgLy8gICBhc3NldDogdWludDY0LAogICAgLy8gICBhbW91bnQ6IHVpbnQ2NCwKICAgIC8vICAgcHJvb2Y6IFByb29mCiAgICAvLyApIHsKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCmVzY3Jvd19lbHNlX2JvZHlANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czoxMTUKICAgIC8vIGxldCBtYnJBbW91bnQgPSB0aGlzLm1icigpLmhhc2hlcwogICAgaW50YyA0IC8vIDM0OTAwCiAgICBidXJ5IDEyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MTE4CiAgICAvLyBpZiAoIXJlY2VpdmVyLmlzT3B0ZWRJbihBc3NldChhc3NldCkpKSB7CiAgICBkaWcgNwogICAgZGlnIDYKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBibnogZXNjcm93X2FmdGVyX2lmX2Vsc2VANwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjExNQogICAgLy8gbGV0IG1ickFtb3VudCA9IHRoaXMubWJyKCkuaGFzaGVzCiAgICBpbnRjIDQgLy8gMzQ5MDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czoxMTkKICAgIC8vIG1ickFtb3VudCArPSBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIGdsb2JhbCBBc3NldE9wdEluTWluQmFsYW5jZQogICAgKwogICAgYnVyeSAxMgoKZXNjcm93X2FmdGVyX2lmX2Vsc2VANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czoxMjMKICAgIC8vIGlmICghaHlwZXJTd2FwQXBwLmFkZHJlc3MuaXNPcHRlZEluKEFzc2V0KGFzc2V0KSkpIHsKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgZGlnIDYKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBibnogZXNjcm93X2FmdGVyX2lmX2Vsc2VAOQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjEyNAogICAgLy8gbWJyQW1vdW50ICs9IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZQogICAgZGlnIDExCiAgICBnbG9iYWwgQXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgICsKICAgIGJ1cnkgMTIKCmVzY3Jvd19hZnRlcl9pZl9lbHNlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MTI3LTE0OQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgSHlwZXJTd2FwLnByb3RvdHlwZS5lc2Nyb3dBc2E+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogaHlwZXJTd2FwQXBwLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiBoeXBlclN3YXBBcHAuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogbWJyQW1vdW50CiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IGh5cGVyU3dhcEFwcC5hZGRyZXNzLAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICAgIHhmZXJBc3NldDogYXNzZXQKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBpZCwKICAgIC8vICAgICByZWNlaXZlciwKICAgIC8vICAgICBhc3NldCwKICAgIC8vICAgICBhbW91bnQsCiAgICAvLyAgICAgcHJvb2YsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MTMzCiAgICAvLyByZWNlaXZlcjogaHlwZXJTd2FwQXBwLmFkZHJlc3MsCiAgICBkdXBuIDIKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGRpZyAxMwogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGRpZyAyCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MTMxLTEzNQogICAgLy8gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogaHlwZXJTd2FwQXBwLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogbWJyQW1vdW50CiAgICAvLyB9KSwKICAgIGludGNfMiAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czoxMzYtMTQxCiAgICAvLyBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IGh5cGVyU3dhcEFwcC5hZGRyZXNzLAogICAgLy8gICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gICB4ZmVyQXNzZXQ6IGFzc2V0CiAgICAvLyB9KSwKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjEzOAogICAgLy8gYXNzZXRSZWNlaXZlcjogaHlwZXJTd2FwQXBwLmFkZHJlc3MsCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGRpZyA4CiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgZGlnIDYKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MTM2LTE0MQogICAgLy8gaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhc3NldFJlY2VpdmVyOiBoeXBlclN3YXBBcHAuYWRkcmVzcywKICAgIC8vICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgeGZlckFzc2V0OiBhc3NldAogICAgLy8gfSksCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MTI3LTE0OQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgSHlwZXJTd2FwLnByb3RvdHlwZS5lc2Nyb3dBc2E+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogaHlwZXJTd2FwQXBwLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiBoeXBlclN3YXBBcHAuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogbWJyQW1vdW50CiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IGh5cGVyU3dhcEFwcC5hZGRyZXNzLAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICAgIHhmZXJBc3NldDogYXNzZXQKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBpZCwKICAgIC8vICAgICByZWNlaXZlciwKICAgIC8vICAgICBhc3NldCwKICAgIC8vICAgICBhbW91bnQsCiAgICAvLyAgICAgcHJvb2YsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czoxNDgKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIGRpZyAxMQogICAgZGlnIDEzCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjEyNy0xNDkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEh5cGVyU3dhcC5wcm90b3R5cGUuZXNjcm93QXNhPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGh5cGVyU3dhcEFwcCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogaHlwZXJTd2FwQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IG1ickFtb3VudAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiBoeXBlclN3YXBBcHAuYWRkcmVzcywKICAgIC8vICAgICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0CiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgaWQsCiAgICAvLyAgICAgcmVjZWl2ZXIsCiAgICAvLyAgICAgYXNzZXQsCiAgICAvLyAgICAgYW1vdW50LAogICAgLy8gICAgIHByb29mLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4NDY2Zjg3MWEgLy8gbWV0aG9kICJlc2Nyb3dBc2EocGF5LGF4ZmVyLHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsYnl0ZVszMl1bXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA5CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDcKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGIgZXNjcm93X2FmdGVyX2lmX2Vsc2VAMTMKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6Okh5cGVyU3dhcFBsdWdpbi5kaXNidXJzZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmRpc2J1cnNlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjE1My0xNjEKICAgIC8vIGRpc2J1cnNlKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGlkOiB1aW50NjQsCiAgICAvLyAgIHJlY2VpdmVyV2FsbGV0OiB1aW50NjQsCiAgICAvLyAgIHJlY2VpdmVyOiBBY2NvdW50LAogICAgLy8gICBhc3NldDogdWludDY0LAogICAgLy8gICBhbW91bnQ6IHVpbnQ2NAogICAgLy8gKSB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDYKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA3CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjE2NC0xNzUKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEh5cGVyU3dhcC5wcm90b3R5cGUuZGlzYnVyc2U+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLmh5cGVyU3dhcCksCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpZCwKICAgIC8vICAgICByZWNlaXZlcldhbGxldCwKICAgIC8vICAgICByZWNlaXZlciwKICAgIC8vICAgICBhc3NldCwKICAgIC8vICAgICBhbW91bnQsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MTY2CiAgICAvLyBhcHBJZDogQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLmh5cGVyU3dhcCksCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MTY2CiAgICAvLyBhcHBJZDogQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLmh5cGVyU3dhcCksCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMiAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjE2NgogICAgLy8gYXBwSWQ6IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5oeXBlclN3YXApLAogICAgcHVzaGludCA1NiAvLyA1NgogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czoxNzQKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIHVuY292ZXIgNwogICAgdW5jb3ZlciA4CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjE2NC0xNzUKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEh5cGVyU3dhcC5wcm90b3R5cGUuZGlzYnVyc2U+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLmh5cGVyU3dhcCksCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpZCwKICAgIC8vICAgICByZWNlaXZlcldhbGxldCwKICAgIC8vICAgICByZWNlaXZlciwKICAgIC8vICAgICBhc3NldCwKICAgIC8vICAgICBhbW91bnQsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHg1NjZhNjJiMiAvLyBtZXRob2QgImRpc2J1cnNlKHVpbnQ2NCx1aW50NjQsYWRkcmVzcyx1aW50NjQsdWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA3CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA1CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjE1My0xNjEKICAgIC8vIGRpc2J1cnNlKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGlkOiB1aW50NjQsCiAgICAvLyAgIHJlY2VpdmVyV2FsbGV0OiB1aW50NjQsCiAgICAvLyAgIHJlY2VpdmVyOiBBY2NvdW50LAogICAgLy8gICBhc3NldDogdWludDY0LAogICAgLy8gICBhbW91bnQ6IHVpbnQ2NAogICAgLy8gKSB7CiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjpIeXBlclN3YXBQbHVnaW4uY2FuY2VsW3JvdXRpbmddKCkgLT4gdm9pZDoKY2FuY2VsOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjE3OC0xODMKICAgIC8vIGNhbmNlbCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBpZDogdWludDY0LAogICAgLy8gICBwcm9vZjogUHJvb2YKICAgIC8vICkgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18zIC8vIDMyCiAgICAqCiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1aW50OFszMl1bXSkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMSAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czoxODYtMTkxCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBIeXBlclN3YXAucHJvdG90eXBlLmNhbmNlbD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuaHlwZXJTd2FwKSwKICAgIC8vICAgYXJnczogW2lkLCBwcm9vZl0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MTg4CiAgICAvLyBhcHBJZDogQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLmh5cGVyU3dhcCksCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MTg4CiAgICAvLyBhcHBJZDogQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLmh5cGVyU3dhcCksCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMiAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjE4OAogICAgLy8gYXBwSWQ6IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5oeXBlclN3YXApLAogICAgcHVzaGludCA1NiAvLyA1NgogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czoxOTAKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIHVuY292ZXIgNAogICAgdW5jb3ZlciA1CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjE4Ni0xOTEKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEh5cGVyU3dhcC5wcm90b3R5cGUuY2FuY2VsPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5oeXBlclN3YXApLAogICAgLy8gICBhcmdzOiBbaWQsIHByb29mXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDBjN2FiNDJlIC8vIG1ldGhvZCAiY2FuY2VsKHVpbnQ2NCxieXRlWzMyXVtdKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjE3OC0xODMKICAgIC8vIGNhbmNlbCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBpZDogdWludDY0LAogICAgLy8gICBwcm9vZjogUHJvb2YKICAgIC8vICkgewogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czo6SHlwZXJTd2FwUGx1Z2luLndpdGhkcmF3W3JvdXRpbmddKCkgLT4gdm9pZDoKd2l0aGRyYXc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MTk0LTIwMgogICAgLy8gd2l0aGRyYXcoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgaWQ6IHVpbnQ2NCwKICAgIC8vICAgcmVjZWl2ZXI6IEFjY291bnQsCiAgICAvLyAgIGFzc2V0OiB1aW50NjQsCiAgICAvLyAgIGFtb3VudDogdWludDY0LAogICAgLy8gICBwcm9vZjogUHJvb2YKICAgIC8vICkgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA2CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNwogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMyAvLyAzMgogICAgKgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdWludDhbMzJdW10pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgNgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MjA1LTIxMAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgSHlwZXJTd2FwLnByb3RvdHlwZS53aXRoZHJhdz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuaHlwZXJTd2FwKSwKICAgIC8vICAgYXJnczogW2lkLCByZWNlaXZlciwgYXNzZXQsIGFtb3VudCwgcHJvb2ZdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjIwNwogICAgLy8gYXBwSWQ6IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5oeXBlclN3YXApLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvaHlwZXItc3dhcC9jb250cmFjdC5hbGdvLnRzOjIwNwogICAgLy8gYXBwSWQ6IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5oeXBlclN3YXApLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDAKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBcHBMaXN0KSkKICAgIGJ5dGVjXzIgLy8gImFhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czoyMDcKICAgIC8vIGFwcElkOiBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuaHlwZXJTd2FwKSwKICAgIHB1c2hpbnQgNTYgLy8gNTYKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9oeXBlci1zd2FwL2NvbnRyYWN0LmFsZ28udHM6MjA5CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICB1bmNvdmVyIDcKICAgIHVuY292ZXIgOAogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czoyMDUtMjEwCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBIeXBlclN3YXAucHJvdG90eXBlLndpdGhkcmF3Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5oeXBlclN3YXApLAogICAgLy8gICBhcmdzOiBbaWQsIHJlY2VpdmVyLCBhc3NldCwgYW1vdW50LCBwcm9vZl0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHgwNjMxODY4YiAvLyBtZXRob2QgIndpdGhkcmF3KHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsYnl0ZVszMl1bXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL2h5cGVyLXN3YXAvY29udHJhY3QuYWxnby50czoxOTQtMjAyCiAgICAvLyB3aXRoZHJhdygKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBpZDogdWludDY0LAogICAgLy8gICByZWNlaXZlcjogQWNjb3VudCwKICAgIC8vICAgYXNzZXQ6IHVpbnQ2NCwKICAgIC8vICAgYW1vdW50OiB1aW50NjQsCiAgICAvLyAgIHByb29mOiBQcm9vZgogICAgLy8gKSB7CiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6OkFraXRhQmFzZUNvbnRyYWN0LnVwZGF0ZUFraXRhREFPW3JvdXRpbmddKCkgLT4gdm9pZDoKdXBkYXRlQWtpdGFEQU86CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozOAogICAgLy8gdXBkYXRlQWtpdGFEQU8oYWtpdGFEQU86IEFwcGxpY2F0aW9uKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzkKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSB0aGlzLmdldEFraXRhREFPV2FsbGV0KCkuYWRkcmVzcywgRVJSX05PVF9BS0lUQV9EQU8pCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozMgogICAgLy8gY29uc3QgW3dhbGxldElEXSA9IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NCh0aGlzLmFraXRhREFPLnZhbHVlLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1dhbGxldCkpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozMgogICAgLy8gY29uc3QgW3dhbGxldElEXSA9IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NCh0aGlzLmFraXRhREFPLnZhbHVlLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1dhbGxldCkpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgcHVzaGJ5dGVzICJ3YWxsZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozOQogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gT25seSB0aGUgQWtpdGEgREFPIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NDAKICAgIC8vIHRoaXMuYWtpdGFEQU8udmFsdWUgPSBha2l0YURBTwogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjM4CiAgICAvLyB1cGRhdGVBa2l0YURBTyhha2l0YURBTzogQXBwbGljYXRpb24pOiB2b2lkIHsKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4K", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyAFAAgBINSQAiYDCWFraXRhX2RhbxBzcGVuZGluZ19hZGRyZXNzA2FhbDEZFEQxGEEAeoIJBGzfhDEE+dvVDASeKQOWBLZ45bUEfwrRmAS2OrDTBDPpLJQEhU3t4ASEBzPdNhoAjgkAfgETAYoC0wNSA7UEPAAyAAEAgCwVH3x1AAAAAAAAxtQAAAAAAACIVAAAAAAAAIhUAAAAAAAAn8QAAAAAAABqpLAkQyRDgATNmtZ+NhoAjgEAEgCKAgGL/kAAAzIDiYv/cghEiTYaAUkiWYECCEsBFRJEVwIANhoCSRUjEkQXgAd2ZXJzaW9uTwJnKExnJEM2GgFJFSMSRBc2GgJJFSQSRCJTNhoDSRUlEkQ2GgRJFSMSRDYaBUkVJRJENhoGSRUjEkQ2GgdJFSMSREsGKWVIIihlRCplSIE4W7FJcghEgfjHDbIIsgdLAbIAJLIQIrIBtk8HTwiI/1uABA2zpEuyGk8HshpPBrIaTwWyGk8EshpPA7IasiCyGLIAgQayECKyAbMkQzYaAUkVIxJEFzYaAkkVJBJEIlM2GgNJFSMSRDYaBEkiWSULgQIISwEVEkRLAyllSCIoZUQqZUiBOFuxSXIIRCEEsgiyB0sBsgAkshAisgG2TwRPBYj+2IAEveGhHrIaTwSyGk8DshqyILIYsgCBBrIQIrIBsyRDgAA2GgFJFSMSRBdJNhoCSRUkEkQiU0w2GgNJTgIVIxJENhoESU4CFSUSRDYaBUlOAkkVIxJEF0lOAjYaBklOA0kVIxJEF04CNhoHSU4DSSJZJQuBAghMFRJETCllSEwiKGVEKmVIgThbTEAASrFHAnIIREsFIQQIsgiyB0sCSbIAJLIQIrIBtksLSw2I/imABNhf692yGksLshpLCrIaSweyGksFshqyILIAshiBBrIQIrIBsyRDIQRFDEsHSwZwAEUBQAAHIQQyEAhFDElyCERLBnAARQFAAAdLCzIQCEUMsUcCcghESw2yCLIHSwJJTgKyACSyECKyAbZJcghESwiyEUsGshKyFEsBsgCBBLIQIrIBtksLSw2I/ZyABEZvhxqyGksLshpLCrIaSwmyGksHshpLBbIasiCyGLIAgQayECKyAbNC/2w2GgFJFSMSRBc2GgJJFSQSRCJTNhoDSRUjEkQ2GgRJFSMSRDYaBUkVJRJENhoGSRUjEkQ2GgdJFSMSREsGKWVITLEiKGVEKmVIgThbTwdPCIj9HIAEVmpisrIaTweyGk8GshpPBbIaTwSyGk8CshqyILIYsgCBBrIQIrIBsyRDNhoBSRUjEkQXNhoCSRUkEkQiUzYaA0kVIxJENhoESSJZJQuBAghLARUSREsDKWVITLEiKGVEKmVIgThbTwRPBYj8rYAEDHq0LrIaTwSyGk8CshqyILIYsgCBBrIQIrIBsyRDNhoBSRUjEkQXNhoCSRUkEkQiUzYaA0kVIxJENhoESRUlEkQ2GgVJFSMSRDYaBkkVIxJENhoHSSJZJQuBAghLARUSREsGKWVITLEiKGVEKmVIgThbTwdPCIj8MoAEBjGGi7IaTweyGk8GshpPBbIaTwSyGk8CshqyILIYsgCBBrIQIrIBsyRDNhoBSRUjEkQXMQAiKGVEgAZ3YWxsZXRlSHIIRBJEKExnJEM=", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var HyperSwapPluginParamsFactory = class _HyperSwapPluginParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "create":
          case "create(string,uint64)void":
            return _HyperSwapPluginParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs create ABI call params for the HyperSwapPlugin smart contract using the create(string,uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params) {
        return {
          ...params,
          method: "create(string,uint64)void",
          args: Array.isArray(params.args) ? params.args : [params.args.version, params.args.akitaDao]
        };
      }
    };
  }
  /**
   * Constructs a no op call for the offer(uint64,bool,byte[32],uint64,byte[32],uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static offer(params) {
    return {
      ...params,
      method: "offer(uint64,bool,byte[32],uint64,byte[32],uint64,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.root, params.args.leaves, params.args.participantsRoot, params.args.participantLeaves, params.args.expiration]
    };
  }
  /**
   * Constructs a no op call for the accept(uint64,bool,uint64,byte[32][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static accept(params) {
    return {
      ...params,
      method: "accept(uint64,bool,uint64,byte[32][])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.id, params.args.proof]
    };
  }
  /**
   * Constructs a no op call for the escrow(uint64,bool,uint64,address,uint64,uint64,byte[32][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static escrow(params) {
    return {
      ...params,
      method: "escrow(uint64,bool,uint64,address,uint64,uint64,byte[32][])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.id, params.args.receiver, params.args.asset, params.args.amount, params.args.proof]
    };
  }
  /**
   * Constructs a no op call for the disburse(uint64,bool,uint64,uint64,address,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static disburse(params) {
    return {
      ...params,
      method: "disburse(uint64,bool,uint64,uint64,address,uint64,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.id, params.args.receiverWallet, params.args.receiver, params.args.asset, params.args.amount]
    };
  }
  /**
   * Constructs a no op call for the cancel(uint64,bool,uint64,byte[32][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static cancel(params) {
    return {
      ...params,
      method: "cancel(uint64,bool,uint64,byte[32][])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.id, params.args.proof]
    };
  }
  /**
   * Constructs a no op call for the withdraw(uint64,bool,uint64,address,uint64,uint64,byte[32][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static withdraw(params) {
    return {
      ...params,
      method: "withdraw(uint64,bool,uint64,address,uint64,uint64,byte[32][])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.id, params.args.receiver, params.args.asset, params.args.amount, params.args.proof]
    };
  }
  /**
   * Constructs a no op call for the updateAkitaDAO(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDao(params) {
    return {
      ...params,
      method: "updateAkitaDAO(uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.akitaDao]
    };
  }
  /**
   * Constructs a no op call for the opUp()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static opUp(params) {
    return {
      ...params,
      method: "opUp()void",
      args: Array.isArray(params.args) ? params.args : []
    };
  }
  /**
   * Constructs a no op call for the mbr()(uint64,uint64,uint64,(uint64,uint64)) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mbr(params) {
    return {
      ...params,
      method: "mbr()(uint64,uint64,uint64,(uint64,uint64))",
      args: Array.isArray(params.args) ? params.args : []
    };
  }
};
var HyperSwapPluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `HyperSwapPluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory12({
      ...params,
      appSpec: APP_SPEC12
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC12;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new HyperSwapPluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new HyperSwapPluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the HyperSwapPlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    var _a;
    const result = await this.appFactory.deploy({
      ...params,
      createParams: ((_a = params.createParams) == null ? void 0 : _a.method) ? HyperSwapPluginParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams : void 0
    });
    return { result: result.result, appClient: new HyperSwapPluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the HyperSwapPlugin smart contract using the create(string,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params) => {
        return this.appFactory.params.create(HyperSwapPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the HyperSwapPlugin smart contract using the create(string,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params) => {
        return this.appFactory.createTransaction.create(HyperSwapPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the HyperSwapPlugin smart contract using an ABI method call using the create(string,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params) => {
        const result = await this.appFactory.send.create(HyperSwapPluginParamsFactory.create.create(params));
        return { result: { ...result.result, return: result.result.return }, appClient: new HyperSwapPluginClient(result.appClient) };
      }
    }
  };
};
var HyperSwapPluginClient = class _HyperSwapPluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient12 ? appClientOrParams : new _AppClient12({
      ...appClientOrParams,
      appSpec: APP_SPEC12
    });
  }
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue(method, returnValue) {
    return returnValue !== void 0 ? getArc56ReturnValue7(returnValue, this.appClient.getABIMethod(method), APP_SPEC12.structs) : void 0;
  }
  /**
   * Returns a new `HyperSwapPluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _HyperSwapPluginClient(await _AppClient12.fromCreatorAndName({ ...params, appSpec: APP_SPEC12 }));
  }
  /**
   * Returns an `HyperSwapPluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _HyperSwapPluginClient(await _AppClient12.fromNetwork({ ...params, appSpec: APP_SPEC12 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the HyperSwapPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `offer(uint64,bool,byte[32],uint64,byte[32],uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    offer: (params) => {
      return this.appClient.params.call(HyperSwapPluginParamsFactory.offer(params));
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `accept(uint64,bool,uint64,byte[32][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    accept: (params) => {
      return this.appClient.params.call(HyperSwapPluginParamsFactory.accept(params));
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `escrow(uint64,bool,uint64,address,uint64,uint64,byte[32][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    escrow: (params) => {
      return this.appClient.params.call(HyperSwapPluginParamsFactory.escrow(params));
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `disburse(uint64,bool,uint64,uint64,address,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    disburse: (params) => {
      return this.appClient.params.call(HyperSwapPluginParamsFactory.disburse(params));
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `cancel(uint64,bool,uint64,byte[32][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    cancel: (params) => {
      return this.appClient.params.call(HyperSwapPluginParamsFactory.cancel(params));
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `withdraw(uint64,bool,uint64,address,uint64,uint64,byte[32][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    withdraw: (params) => {
      return this.appClient.params.call(HyperSwapPluginParamsFactory.withdraw(params));
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDao: (params) => {
      return this.appClient.params.call(HyperSwapPluginParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.params.call(HyperSwapPluginParamsFactory.opUp(params));
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `mbr()(uint64,uint64,uint64,(uint64,uint64))` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    mbr: (params = { args: [] }) => {
      return this.appClient.params.call(HyperSwapPluginParamsFactory.mbr(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the HyperSwapPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `offer(uint64,bool,byte[32],uint64,byte[32],uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    offer: (params) => {
      return this.appClient.createTransaction.call(HyperSwapPluginParamsFactory.offer(params));
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `accept(uint64,bool,uint64,byte[32][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    accept: (params) => {
      return this.appClient.createTransaction.call(HyperSwapPluginParamsFactory.accept(params));
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `escrow(uint64,bool,uint64,address,uint64,uint64,byte[32][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    escrow: (params) => {
      return this.appClient.createTransaction.call(HyperSwapPluginParamsFactory.escrow(params));
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `disburse(uint64,bool,uint64,uint64,address,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    disburse: (params) => {
      return this.appClient.createTransaction.call(HyperSwapPluginParamsFactory.disburse(params));
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `cancel(uint64,bool,uint64,byte[32][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    cancel: (params) => {
      return this.appClient.createTransaction.call(HyperSwapPluginParamsFactory.cancel(params));
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `withdraw(uint64,bool,uint64,address,uint64,uint64,byte[32][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    withdraw: (params) => {
      return this.appClient.createTransaction.call(HyperSwapPluginParamsFactory.withdraw(params));
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDao: (params) => {
      return this.appClient.createTransaction.call(HyperSwapPluginParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.createTransaction.call(HyperSwapPluginParamsFactory.opUp(params));
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `mbr()(uint64,uint64,uint64,(uint64,uint64))` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    mbr: (params = { args: [] }) => {
      return this.appClient.createTransaction.call(HyperSwapPluginParamsFactory.mbr(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the HyperSwapPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `offer(uint64,bool,byte[32],uint64,byte[32],uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    offer: async (params) => {
      const result = await this.appClient.send.call(HyperSwapPluginParamsFactory.offer(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `accept(uint64,bool,uint64,byte[32][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    accept: async (params) => {
      const result = await this.appClient.send.call(HyperSwapPluginParamsFactory.accept(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `escrow(uint64,bool,uint64,address,uint64,uint64,byte[32][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    escrow: async (params) => {
      const result = await this.appClient.send.call(HyperSwapPluginParamsFactory.escrow(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `disburse(uint64,bool,uint64,uint64,address,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    disburse: async (params) => {
      const result = await this.appClient.send.call(HyperSwapPluginParamsFactory.disburse(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `cancel(uint64,bool,uint64,byte[32][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    cancel: async (params) => {
      const result = await this.appClient.send.call(HyperSwapPluginParamsFactory.cancel(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `withdraw(uint64,bool,uint64,address,uint64,uint64,byte[32][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    withdraw: async (params) => {
      const result = await this.appClient.send.call(HyperSwapPluginParamsFactory.withdraw(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDao: async (params) => {
      const result = await this.appClient.send.call(HyperSwapPluginParamsFactory.updateAkitaDao(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    opUp: async (params = { args: [] }) => {
      const result = await this.appClient.send.call(HyperSwapPluginParamsFactory.opUp(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the HyperSwapPlugin smart contract using the `mbr()(uint64,uint64,uint64,(uint64,uint64))` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mbr: async (params = { args: [] }) => {
      const result = await this.appClient.send.call(HyperSwapPluginParamsFactory.mbr(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _HyperSwapPluginClient(this.appClient.clone(params));
  }
  /**
   * Makes a readonly (simulated) call to the HyperSwapPlugin smart contract using the `mbr()(uint64,uint64,uint64,(uint64,uint64))` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async mbr(params = { args: [] }) {
    const result = await this.appClient.send.call(HyperSwapPluginParamsFactory.mbr(params));
    return result.return;
  }
  /**
   * Methods to access state for the current HyperSwapPlugin app
   */
  state = {
    /**
     * Methods to access global state for the current HyperSwapPlugin app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async () => {
        const result = await this.appClient.state.global.getAll();
        return {
          version: result.version,
          akitaDao: result.akitaDAO
        };
      },
      /**
       * Get the current value of the version key in global state
       */
      version: async () => {
        return await this.appClient.state.global.getValue("version");
      },
      /**
       * Get the current value of the akitaDAO key in global state
       */
      akitaDao: async () => {
        return await this.appClient.state.global.getValue("akitaDAO");
      }
    }
  };
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a offer(uint64,bool,byte[32],uint64,byte[32],uint64,uint64)void method call against the HyperSwapPlugin contract
       */
      offer(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.offer(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a accept(uint64,bool,uint64,byte[32][])void method call against the HyperSwapPlugin contract
       */
      accept(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.accept(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a escrow(uint64,bool,uint64,address,uint64,uint64,byte[32][])void method call against the HyperSwapPlugin contract
       */
      escrow(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.escrow(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a disburse(uint64,bool,uint64,uint64,address,uint64,uint64)void method call against the HyperSwapPlugin contract
       */
      disburse(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.disburse(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a cancel(uint64,bool,uint64,byte[32][])void method call against the HyperSwapPlugin contract
       */
      cancel(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.cancel(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a withdraw(uint64,bool,uint64,address,uint64,uint64,byte[32][])void method call against the HyperSwapPlugin contract
       */
      withdraw(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.withdraw(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a updateAkitaDAO(uint64)void method call against the HyperSwapPlugin contract
       */
      updateAkitaDao(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDao(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a opUp()void method call against the HyperSwapPlugin contract
       */
      opUp(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.opUp(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a mbr()(uint64,uint64,uint64,(uint64,uint64)) method call against the HyperSwapPlugin contract
       */
      mbr(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mbr(params)));
        resultMappers.push((v) => client.decodeReturnValue("mbr()(uint64,uint64,uint64,(uint64,uint64))", v));
        return this;
      },
      /**
       * Add a clear state call to the HyperSwapPlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/hyper-swap.ts
var HyperSwapPluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: HyperSwapPluginFactory, ...params });
  }
  offer(args) {
    const methodName = "offer";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.offer({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  accept(args) {
    const methodName = "accept";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.accept({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  escrow(args) {
    const methodName = "escrow";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.escrow({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  disburse(args) {
    const methodName = "disburse";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.disburse({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  cancel(args) {
    const methodName = "cancel";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.cancel({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  withdraw(args) {
    const methodName = "withdraw";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.withdraw({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
};

// src/generated/MarketplacePluginClient.ts
import { getArc56ReturnValue as getArc56ReturnValue8 } from "@algorandfoundation/algokit-utils/types/app-arc56";
import {
  AppClient as _AppClient13
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory13 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC13 = { "name": "MarketplacePlugin", "structs": {}, "methods": [{ "name": "createApplication", "args": [{ "type": "string", "name": "version" }, { "type": "uint64", "name": "factory" }, { "type": "uint64", "name": "akitaDAO" }], "returns": { "type": "void" }, "actions": { "create": ["NoOp"], "call": [] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "list", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "asset" }, { "type": "uint64", "name": "assetAmount" }, { "type": "uint64", "name": "price" }, { "type": "uint64", "name": "paymentAsset" }, { "type": "uint64", "name": "expiration" }, { "type": "address", "name": "reservedFor" }, { "type": "uint64", "name": "gateID" }, { "type": "address", "name": "marketplace" }, { "type": "string", "name": "name" }, { "type": "byte[32][]", "name": "proof" }], "returns": { "type": "uint64" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "purchase", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "address", "name": "marketplace" }, { "type": "byte[][]", "name": "args" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "changePrice", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "uint64", "name": "price" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "delist", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "updateAkitaDAO", "args": [{ "type": "uint64", "name": "akitaDAO" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "opUp", "args": [], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 2, "bytes": 1 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": { "factory": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "ZmFjdG9yeQ==" }, "version": { "keyType": "AVMString", "valueType": "AVMString", "key": "dmVyc2lvbg==", "desc": "the current version of the contract" }, "akitaDAO": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "YWtpdGFfZGFv", "desc": "the app ID of the Akita DAO" } }, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": [], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [509, 699], "errorMessage": "Bytes has valid prefix" }, { "pc": [847, 1317, 1398], "errorMessage": "Creator is not the marketplace" }, { "pc": [382], "errorMessage": "Not enough asset" }, { "pc": [74], "errorMessage": "OnCompletion must be NoOp" }, { "pc": [1460], "errorMessage": "Only the Akita DAO can call this function" }, { "pc": [161, 389, 406, 450, 521, 579, 603, 816, 838, 845, 913, 1007, 1098, 1198, 1308, 1315, 1389, 1396, 1458], "errorMessage": "application exists" }, { "pc": [386, 402, 447, 464, 575, 842, 890, 909, 1003, 1075, 1094, 1194, 1312, 1393, 1445], "errorMessage": "check GlobalState exists" }, { "pc": [367], "errorMessage": "invalid number of bytes for (len+uint8[32][])" }, { "pc": [176, 348], "errorMessage": "invalid number of bytes for (len+utf8[])" }, { "pc": [236, 736, 1277, 1367], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [187, 196, 226, 250, 262, 276, 287, 300, 321, 514, 704, 726, 750, 1268, 1287, 1296, 1358, 1377, 1438], "errorMessage": "invalid number of bytes for uint64" }, { "pc": [311, 332, 765], "errorMessage": "invalid number of bytes for uint8[32]" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCA4IDEgNgogICAgYnl0ZWNibG9jayAiZmFjdG9yeSIgImFraXRhX2RhbyIgInNwZW5kaW5nX2FkZHJlc3MiIDB4MTUxZjdjNzUgMHgzOTRlYWViMiAiYWFsIiAiZ2F0ZV9pZCIgMHg0MzkyMjY1NQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxOQogICAgLy8gZXhwb3J0IGNsYXNzIE1hcmtldHBsYWNlUGx1Z2luIGV4dGVuZHMgQWtpdGFCYXNlQ29udHJhY3QgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBieiBtYWluX2NyZWF0ZV9Ob09wQDEwCiAgICBwdXNoYnl0ZXNzIDB4ZGVhN2NkOWQgMHgyNjllNGJiMCAweDRkOTZiYTQ0IDB4NTk0NjZlZjIgMHgzM2U5MmM5NCAweDg1NGRlZGUwIC8vIG1ldGhvZCAibGlzdCh1aW50NjQsYm9vbCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LGFkZHJlc3MsdWludDY0LGFkZHJlc3Msc3RyaW5nLGJ5dGVbMzJdW10pdWludDY0IiwgbWV0aG9kICJwdXJjaGFzZSh1aW50NjQsYm9vbCx1aW50NjQsYWRkcmVzcyxieXRlW11bXSl2b2lkIiwgbWV0aG9kICJjaGFuZ2VQcmljZSh1aW50NjQsYm9vbCx1aW50NjQsdWludDY0KXZvaWQiLCBtZXRob2QgImRlbGlzdCh1aW50NjQsYm9vbCx1aW50NjQpdm9pZCIsIG1ldGhvZCAidXBkYXRlQWtpdGFEQU8odWludDY0KXZvaWQiLCBtZXRob2QgIm9wVXAoKXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBsaXN0IHB1cmNoYXNlIGNoYW5nZVByaWNlIGRlbGlzdCB1cGRhdGVBa2l0YURBTyBtYWluX29wVXBfcm91dGVAOAogICAgZXJyCgptYWluX29wVXBfcm91dGVAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjQzCiAgICAvLyBvcFVwKCk6IHZvaWQgeyB9CiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgptYWluX2NyZWF0ZV9Ob09wQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxOQogICAgLy8gZXhwb3J0IGNsYXNzIE1hcmtldHBsYWNlUGx1Z2luIGV4dGVuZHMgQWtpdGFCYXNlQ29udHJhY3QgewogICAgcHVzaGJ5dGVzIDB4NGViM2RmYmMgLy8gbWV0aG9kICJjcmVhdGVBcHBsaWNhdGlvbihzdHJpbmcsdWludDY0LHVpbnQ2NCl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggY3JlYXRlQXBwbGljYXRpb24KICAgIGVycgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OnJla2V5QWRkcmVzcyhyZWtleUJhY2s6IHVpbnQ2NCwgd2FsbGV0OiB1aW50NjQpIC0+IGJ5dGVzOgpyZWtleUFkZHJlc3M6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMQogICAgLy8gZXhwb3J0IGZ1bmN0aW9uIHJla2V5QWRkcmVzcyhyZWtleUJhY2s6IGJvb2xlYW4sIHdhbGxldDogQXBwbGljYXRpb24pOiBBY2NvdW50IHsKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjIKICAgIC8vIGlmICghcmVrZXlCYWNrKSB7CiAgICBmcmFtZV9kaWcgLTIKICAgIGJueiByZWtleUFkZHJlc3NfYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMwogICAgLy8gcmV0dXJuIEdsb2JhbC56ZXJvQWRkcmVzcwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICByZXRzdWIKCnJla2V5QWRkcmVzc19hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyNgogICAgLy8gcmV0dXJuIHdhbGxldC5hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6Ok1hcmtldHBsYWNlUGx1Z2luLmNyZWF0ZUFwcGxpY2F0aW9uW3JvdXRpbmddKCkgLT4gdm9pZDoKY3JlYXRlQXBwbGljYXRpb246CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjI3CiAgICAvLyBAYWJpbWV0aG9kKHsgb25DcmVhdGU6ICdyZXF1aXJlJyB9KQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI3CiAgICAvLyB2ZXJzaW9uID0gR2xvYmFsU3RhdGU8c3RyaW5nPih7IGtleTogR2xvYmFsU3RhdGVLZXlWZXJzaW9uIH0pCiAgICBwdXNoYnl0ZXMgInZlcnNpb24iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjI5CiAgICAvLyB0aGlzLnZlcnNpb24udmFsdWUgPSB2ZXJzaW9uCiAgICB1bmNvdmVyIDMKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjIzCiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBNYXJrZXRwbGFjZVBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAiZmFjdG9yeSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MzAKICAgIC8vIHRoaXMuZmFjdG9yeS52YWx1ZSA9IGZhY3RvcnkKICAgIHVuY292ZXIgMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMSAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czozMQogICAgLy8gdGhpcy5ha2l0YURBTy52YWx1ZSA9IGFraXRhREFPCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoyNwogICAgLy8gQGFiaW1ldGhvZCh7IG9uQ3JlYXRlOiAncmVxdWlyZScgfSkKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjpNYXJrZXRwbGFjZVBsdWdpbi5saXN0W3JvdXRpbmddKCkgLT4gdm9pZDoKbGlzdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MzYtNDkKICAgIC8vIGxpc3QoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXNzZXQ6IHVpbnQ2NCwgLy8gMCB8IEFzc2V0CiAgICAvLyAgIGFzc2V0QW1vdW50OiB1aW50NjQsCiAgICAvLyAgIHByaWNlOiB1aW50NjQsCiAgICAvLyAgIHBheW1lbnRBc3NldDogdWludDY0LCAvLyAwIHwgQXNzZXQKICAgIC8vICAgZXhwaXJhdGlvbjogdWludDY0LAogICAgLy8gICByZXNlcnZlZEZvcjogQWNjb3VudCwKICAgIC8vICAgZ2F0ZUlEOiB1aW50NjQsCiAgICAvLyAgIG1hcmtldHBsYWNlOiBBY2NvdW50LAogICAgLy8gICBuYW1lOiBzdHJpbmcsCiAgICAvLyAgIHByb29mOiBQcm9vZiwKICAgIC8vICk6IHVpbnQ2NCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGR1cAogICAgY292ZXIgNAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA2CiAgICBkdXAKICAgIGNvdmVyIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBjb3ZlciAzCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA3CiAgICBkdXAKICAgIGNvdmVyIDQKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgOAogICAgZHVwCiAgICBjb3ZlciA0CiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgOQogICAgZHVwCiAgICBjb3ZlciA0CiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEwCiAgICBkdXAKICAgIGNvdmVyIDQKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxMQogICAgZHVwCiAgICBjb3ZlciA0CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIHN3YXAKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1dGY4W10pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxMgogICAgZHVwCiAgICBjb3ZlciA0CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAzMiAvLyAzMgogICAgKgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIHN3YXAKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1aW50OFszMl1bXSkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIHVuY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzIgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6NTIKICAgIC8vIGFzc2VydChBc3NldEhvbGRpbmcuYXNzZXRCYWxhbmNlKHNlbmRlciwgYXNzZXQpWzBdID49IGFzc2V0QW1vdW50LCBFUlJfTk9UX0VOT1VHSF9BU1NFVCkKICAgIGRpZyAyCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIHBvcAogICAgPD0KICAgIGFzc2VydCAvLyBOb3QgZW5vdWdoIGFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjU0CiAgICAvLyBpZiAoIXRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLmlzT3B0ZWRJbihBc3NldChhc3NldCkpKSB7CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoyMwogICAgLy8gZmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogTWFya2V0cGxhY2VQbHVnaW5HbG9iYWxTdGF0ZUtleUZhY3RvcnkgfSkKICAgIGJ5dGVjXzAgLy8gImZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjU0CiAgICAvLyBpZiAoIXRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLmlzT3B0ZWRJbihBc3NldChhc3NldCkpKSB7CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgc3dhcAogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBidXJ5IDEKICAgIGJueiBsaXN0X2FmdGVyX2lmX2Vsc2VANQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czo1NS02NgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgTWFya2V0cGxhY2UucHJvdG90eXBlLm9wdEluPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZmFjdG9yeS52YWx1ZSwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZQogICAgLy8gICAgIH0pLAogICAgLy8gICAgIEFzc2V0KGFzc2V0KSwKICAgIC8vICAgXQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6NjEKICAgIC8vIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjIzCiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBNYXJrZXRwbGFjZVBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAiZmFjdG9yeSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6NjEKICAgIC8vIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6NjIKICAgIC8vIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICBnbG9iYWwgQXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgMQogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czo1OS02MwogICAgLy8gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICAvLyB9KSwKICAgIGludGNfMiAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6NTUtNjYKICAgIC8vIGFiaUNhbGw8dHlwZW9mIE1hcmtldHBsYWNlLnByb3RvdHlwZS5vcHRJbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBBc3NldChhc3NldCksCiAgICAvLyAgIF0KICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIGJ5dGVjIDQgLy8gbWV0aG9kICJvcHRJbihwYXksdWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDE0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKCmxpc3RfYWZ0ZXJfaWZfZWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czo2OQogICAgLy8gaWYgKCF0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcy5pc09wdGVkSW4oQXNzZXQocGF5bWVudEFzc2V0KSkpIHsKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjIzCiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBNYXJrZXRwbGFjZVBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAiZmFjdG9yeSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6NjkKICAgIC8vIGlmICghdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MuaXNPcHRlZEluKEFzc2V0KHBheW1lbnRBc3NldCkpKSB7CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgZGlnIDgKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBibnogbGlzdF9hZnRlcl9pZl9lbHNlQDEwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjcwLTc0CiAgICAvLyBjb25zdCBvcHRpbk1CUiA9IGFiaUNhbGw8dHlwZW9mIE1hcmtldHBsYWNlLnByb3RvdHlwZS5vcHRJbkNvc3Q+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbQXNzZXQocGF5bWVudEFzc2V0KV0KICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjcyCiAgICAvLyBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MjMKICAgIC8vIGZhY3RvcnkgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IE1hcmtldHBsYWNlUGx1Z2luR2xvYmFsU3RhdGVLZXlGYWN0b3J5IH0pCiAgICBieXRlY18wIC8vICJmYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czo3MgogICAgLy8gYXBwSWQ6IHRoaXMuZmFjdG9yeS52YWx1ZSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjcwLTc0CiAgICAvLyBjb25zdCBvcHRpbk1CUiA9IGFiaUNhbGw8dHlwZW9mIE1hcmtldHBsYWNlLnByb3RvdHlwZS5vcHRJbkNvc3Q+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbQXNzZXQocGF5bWVudEFzc2V0KV0KICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBwdXNoYnl0ZXMgMHgzM2Y3ODgwOCAvLyBtZXRob2QgIm9wdEluQ29zdCh1aW50NjQpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA5CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkdXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgZGlnIDIKICAgIGR1cAogICAgY292ZXIgMgogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18zIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6NzYtODcKICAgIC8vIGFiaUNhbGw8dHlwZW9mIE1hcmtldHBsYWNlLnByb3RvdHlwZS5vcHRJbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBvcHRpbk1CUgogICAgLy8gICAgIH0pLAogICAgLy8gICAgIEFzc2V0KHBheW1lbnRBc3NldCksCiAgICAvLyAgIF0KICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjgyCiAgICAvLyByZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICBkaWcgMQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGRpZyAxCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czo4MC04NAogICAgLy8gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogb3B0aW5NQlIKICAgIC8vIH0pLAogICAgaW50Y18yIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czo3Ni04NwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgTWFya2V0cGxhY2UucHJvdG90eXBlLm9wdEluPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZmFjdG9yeS52YWx1ZSwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IG9wdGluTUJSCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgQXNzZXQocGF5bWVudEFzc2V0KSwKICAgIC8vICAgXQogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgYnl0ZWMgNCAvLyBtZXRob2QgIm9wdEluKHBheSx1aW50NjQpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAoKbGlzdF9hZnRlcl9pZl9lbHNlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czo5MAogICAgLy8gY29uc3Qgb3B0aW5NQlI6IHVpbnQ2NCA9IHBheW1lbnRBc3NldCA9PT0gMCA/IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZSA6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZSAqIDIKICAgIGRpZyA3CiAgICBibnogbGlzdF90ZXJuYXJ5X2ZhbHNlQDEyCiAgICBnbG9iYWwgQXNzZXRPcHRJbk1pbkJhbGFuY2UKCmxpc3RfdGVybmFyeV9tZXJnZUAxMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6OTUtOTcKICAgIC8vIE1JTl9QUk9HUkFNX1BBR0VTICsKICAgIC8vIChHTE9CQUxfU1RBVEVfS0VZX1VJTlRfQ09TVCAqIGxpc3RpbmcuZ2xvYmFsVWludHMpICsKICAgIC8vIChHTE9CQUxfU1RBVEVfS0VZX0JZVEVTX0NPU1QgKiBsaXN0aW5nLmdsb2JhbEJ5dGVzKSArCiAgICBwdXNoaW50IDYwNjUwMCAvLyA2MDY1MDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6OTgKICAgIC8vIEdsb2JhbC5taW5CYWxhbmNlICsKICAgIGdsb2JhbCBNaW5CYWxhbmNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjk1LTk4CiAgICAvLyBNSU5fUFJPR1JBTV9QQUdFUyArCiAgICAvLyAoR0xPQkFMX1NUQVRFX0tFWV9VSU5UX0NPU1QgKiBsaXN0aW5nLmdsb2JhbFVpbnRzKSArCiAgICAvLyAoR0xPQkFMX1NUQVRFX0tFWV9CWVRFU19DT1NUICogbGlzdGluZy5nbG9iYWxCeXRlcykgKwogICAgLy8gR2xvYmFsLm1pbkJhbGFuY2UgKwogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czo5NS05OQogICAgLy8gTUlOX1BST0dSQU1fUEFHRVMgKwogICAgLy8gKEdMT0JBTF9TVEFURV9LRVlfVUlOVF9DT1NUICogbGlzdGluZy5nbG9iYWxVaW50cykgKwogICAgLy8gKEdMT0JBTF9TVEFURV9LRVlfQllURVNfQ09TVCAqIGxpc3RpbmcuZ2xvYmFsQnl0ZXMpICsKICAgIC8vIEdsb2JhbC5taW5CYWxhbmNlICsKICAgIC8vIG9wdGluTUJSCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjEwMi0xMjgKICAgIC8vIHJldHVybiBhYmlDYWxsPHR5cGVvZiBNYXJrZXRwbGFjZS5wcm90b3R5cGUubGlzdD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBjaGlsZENvbnRyYWN0TUJSCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IGFzc2V0QW1vdW50LAogICAgLy8gICAgICAgeGZlckFzc2V0OiBhc3NldAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIHByaWNlLAogICAgLy8gICAgIHBheW1lbnRBc3NldCwKICAgIC8vICAgICBleHBpcmF0aW9uLAogICAgLy8gICAgIHJlc2VydmVkRm9yLAogICAgLy8gICAgIGdhdGVJRCwKICAgIC8vICAgICBtYXJrZXRwbGFjZSwKICAgIC8vICAgICBuYW1lLAogICAgLy8gICAgIHByb29mLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gICBmZWU6IDAsCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxMDgKICAgIC8vIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjIzCiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBNYXJrZXRwbGFjZVBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAiZmFjdG9yeSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MTA4CiAgICAvLyByZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgMQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxMDYtMTEwCiAgICAvLyBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBjaGlsZENvbnRyYWN0TUJSCiAgICAvLyB9KSwKICAgIGludGNfMiAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MTExLTExNgogICAgLy8gaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhc3NldFJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIC8vICAgYXNzZXRBbW91bnQ6IGFzc2V0QW1vdW50LAogICAgLy8gICB4ZmVyQXNzZXQ6IGFzc2V0CiAgICAvLyB9KSwKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxMTMKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBkaWcgMTQKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBkaWcgMTMKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjExMS0xMTYKICAgIC8vIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXNzZXRSZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgIGFzc2V0QW1vdW50OiBhc3NldEFtb3VudCwKICAgIC8vICAgeGZlckFzc2V0OiBhc3NldAogICAgLy8gfSksCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjEwMi0xMjgKICAgIC8vIHJldHVybiBhYmlDYWxsPHR5cGVvZiBNYXJrZXRwbGFjZS5wcm90b3R5cGUubGlzdD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBjaGlsZENvbnRyYWN0TUJSCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IGFzc2V0QW1vdW50LAogICAgLy8gICAgICAgeGZlckFzc2V0OiBhc3NldAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIHByaWNlLAogICAgLy8gICAgIHBheW1lbnRBc3NldCwKICAgIC8vICAgICBleHBpcmF0aW9uLAogICAgLy8gICAgIHJlc2VydmVkRm9yLAogICAgLy8gICAgIGdhdGVJRCwKICAgIC8vICAgICBtYXJrZXRwbGFjZSwKICAgIC8vICAgICBuYW1lLAogICAgLy8gICAgIHByb29mLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gICBmZWU6IDAsCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjEyNgogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIGRpZyAxNQogICAgZGlnIDE3CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxMDItMTI4CiAgICAvLyByZXR1cm4gYWJpQ2FsbDx0eXBlb2YgTWFya2V0cGxhY2UucHJvdG90eXBlLmxpc3Q+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogY2hpbGRDb250cmFjdE1CUgogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICAgIGFzc2V0QW1vdW50OiBhc3NldEFtb3VudCwKICAgIC8vICAgICAgIHhmZXJBc3NldDogYXNzZXQKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBwcmljZSwKICAgIC8vICAgICBwYXltZW50QXNzZXQsCiAgICAvLyAgICAgZXhwaXJhdGlvbiwKICAgIC8vICAgICByZXNlcnZlZEZvciwKICAgIC8vICAgICBnYXRlSUQsCiAgICAvLyAgICAgbWFya2V0cGxhY2UsCiAgICAvLyAgICAgbmFtZSwKICAgIC8vICAgICBwcm9vZiwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vICAgZmVlOiAwLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweGUyZmE5ZTIxIC8vIG1ldGhvZCAibGlzdChwYXksYXhmZXIsdWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyx1aW50NjQsYWRkcmVzcyxzdHJpbmcsYnl0ZVszMl1bXSl1aW50NjQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDEyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDExCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDkKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgOAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA3CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDYKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxMjcKICAgIC8vIGZlZTogMCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxMDItMTI4CiAgICAvLyByZXR1cm4gYWJpQ2FsbDx0eXBlb2YgTWFya2V0cGxhY2UucHJvdG90eXBlLmxpc3Q+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogY2hpbGRDb250cmFjdE1CUgogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICAgIGFzc2V0QW1vdW50OiBhc3NldEFtb3VudCwKICAgIC8vICAgICAgIHhmZXJBc3NldDogYXNzZXQKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBwcmljZSwKICAgIC8vICAgICBwYXltZW50QXNzZXQsCiAgICAvLyAgICAgZXhwaXJhdGlvbiwKICAgIC8vICAgICByZXNlcnZlZEZvciwKICAgIC8vICAgICBnYXRlSUQsCiAgICAvLyAgICAgbWFya2V0cGxhY2UsCiAgICAvLyAgICAgbmFtZSwKICAgIC8vICAgICBwcm9vZiwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vICAgZmVlOiAwLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fc3VibWl0CiAgICBnaXR4biAyIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18zIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MzYtNDkKICAgIC8vIGxpc3QoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXNzZXQ6IHVpbnQ2NCwgLy8gMCB8IEFzc2V0CiAgICAvLyAgIGFzc2V0QW1vdW50OiB1aW50NjQsCiAgICAvLyAgIHByaWNlOiB1aW50NjQsCiAgICAvLyAgIHBheW1lbnRBc3NldDogdWludDY0LCAvLyAwIHwgQXNzZXQKICAgIC8vICAgZXhwaXJhdGlvbjogdWludDY0LAogICAgLy8gICByZXNlcnZlZEZvcjogQWNjb3VudCwKICAgIC8vICAgZ2F0ZUlEOiB1aW50NjQsCiAgICAvLyAgIG1hcmtldHBsYWNlOiBBY2NvdW50LAogICAgLy8gICBuYW1lOiBzdHJpbmcsCiAgICAvLyAgIHByb29mOiBQcm9vZiwKICAgIC8vICk6IHVpbnQ2NCB7CiAgICBieXRlY18zIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgpsaXN0X3Rlcm5hcnlfZmFsc2VAMTI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjkwCiAgICAvLyBjb25zdCBvcHRpbk1CUjogdWludDY0ID0gcGF5bWVudEFzc2V0ID09PSAwID8gR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlIDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlICogMgogICAgZ2xvYmFsIEFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICBwdXNoaW50IDIgLy8gMgogICAgKgogICAgYiBsaXN0X3Rlcm5hcnlfbWVyZ2VAMTMKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjpNYXJrZXRwbGFjZVBsdWdpbi5wdXJjaGFzZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CnB1cmNoYXNlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxMzEtMTM3CiAgICAvLyBwdXJjaGFzZSgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24sCiAgICAvLyAgIG1hcmtldHBsYWNlOiBBY2NvdW50LAogICAgLy8gICBhcmdzOiBHYXRlQXJncwogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBjb3ZlciAzCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNjEtMTY0CiAgICAvLyBjb25zdCBbY29udHJvbGxlZEFjY291bnRCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0SUQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzKQogICAgLy8gKQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE2MwogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MpCiAgICBwdXNoYnl0ZXMgImNvbnRyb2xsZWRfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTYxLTE2NAogICAgLy8gY29uc3QgW2NvbnRyb2xsZWRBY2NvdW50Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldElELAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzIgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE2OS0xNzIKICAgIC8vIGNvbnN0IFtyZWZlcnJlckJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXRJRCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzUmVmZXJyZXIpCiAgICAvLyApCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTcxCiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNSZWZlcnJlcikKICAgIHB1c2hieXRlcyAicmVmZXJyZXIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE2OS0xNzIKICAgIC8vIGNvbnN0IFtyZWZlcnJlckJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXRJRCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzUmVmZXJyZXIpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI1OAogICAgLy8gd2FsbGV0QWRkcmVzczogd2FsbGV0LmFkZHJlc3MsCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI1Ny0yNjIKICAgIC8vIHJldHVybiB7CiAgICAvLyAgIHdhbGxldEFkZHJlc3M6IHdhbGxldC5hZGRyZXNzLAogICAgLy8gICBvcmlnaW4sCiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVmZXJyZXIKICAgIC8vIH0KICAgIHVuY292ZXIgMwogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjEzOAogICAgLy8gY29uc3QgeyBvcmlnaW4sIHNlbmRlciB9ID0gZ2V0QWNjb3VudHMod2FsbGV0KQogICAgZHVwCiAgICBleHRyYWN0IDMyIDMyCiAgICBjb3ZlciAyCiAgICBleHRyYWN0IDY0IDMyCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjE0MAogICAgLy8gYXNzZXJ0KGFwcElkLmNyZWF0b3IgPT09IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLCBFUlJfTElTVElOR19DUkVBVE9SX05PVF9NQVJLRVRQTEFDRSkKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MjMKICAgIC8vIGZhY3RvcnkgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IE1hcmtldHBsYWNlUGx1Z2luR2xvYmFsU3RhdGVLZXlGYWN0b3J5IH0pCiAgICBieXRlY18wIC8vICJmYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxNDAKICAgIC8vIGFzc2VydChhcHBJZC5jcmVhdG9yID09PSB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywgRVJSX0xJU1RJTkdfQ1JFQVRPUl9OT1RfTUFSS0VUUExBQ0UpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBDcmVhdG9yIGlzIG5vdCB0aGUgbWFya2V0cGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MTQyCiAgICAvLyBjb25zdCBwcmljZSA9IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NChhcHBJZCwgQnl0ZXMoTGlzdGluZ0dsb2JhbFN0YXRlS2V5UHJpY2UpKVswXQogICAgZHVwCiAgICBwdXNoYnl0ZXMgInByaWNlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxNDMKICAgIC8vIGNvbnN0IHBheW1lbnRBc3NldCA9IEFzc2V0KG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NChhcHBJZCwgQnl0ZXMoTGlzdGluZ0dsb2JhbFN0YXRlS2V5UGF5bWVudEFzc2V0KSlbMF0pCiAgICBwdXNoYnl0ZXMgInBheW1lbnRfYXNzZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MTQ1CiAgICAvLyBpZiAocGF5bWVudEFzc2V0LmlkID09PSAwKSB7CiAgICBibnogcHVyY2hhc2VfZWxzZV9ib2R5QDExCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjE0NgogICAgLy8gaWYgKGFyZ3MubGVuZ3RoID4gMCkgewogICAgZGlnIDQKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgYnogcHVyY2hhc2VfZWxzZV9ib2R5QDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MTQ3CiAgICAvLyBjb25zdCB7IGdhdGUgfSA9IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMSAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxNDcKICAgIC8vIGNvbnN0IHsgZ2F0ZSB9ID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWMgNSAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxNDcKICAgIC8vIGNvbnN0IHsgZ2F0ZSB9ID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxNDgKICAgIC8vIGNvbnN0IGdhdGVJRCA9IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NChhcHBJZCwgQnl0ZXMoTGlzdGluZ0dsb2JhbFN0YXRlS2V5R2F0ZUlEKSlbMF0KICAgIGRpZyA3CiAgICBieXRlYyA2IC8vICJnYXRlX2lkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxNTUKICAgIC8vIGdhdGVJRCwKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MTYwLTE3NAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgTWFya2V0cGxhY2UucHJvdG90eXBlLmdhdGVkUHVyY2hhc2U+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogcHJpY2UKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBnYXRlVHhuLAogICAgLy8gICAgIGFwcElkLAogICAgLy8gICAgIG1hcmtldHBsYWNlLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxNjYKICAgIC8vIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjIzCiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBNYXJrZXRwbGFjZVBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAiZmFjdG9yeSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MTY2CiAgICAvLyByZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBkaWcgNQogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGRpZyA1CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjE2NC0xNjgKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IHByaWNlCiAgICAvLyB9KSwKICAgIGludGNfMiAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MTY5CiAgICAvLyBnYXRlVHhuLAogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjE1MwogICAgLy8gbWV0aG9kU2VsZWN0b3IoR2F0ZU11c3RDaGVja0FiaU1ldGhvZCksCiAgICBieXRlYyA3IC8vIG1ldGhvZCAibXVzdENoZWNrKGFkZHJlc3MsdWludDY0LGJ5dGVbXVtdKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDcKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjE1MC0xNTgKICAgIC8vIGNvbnN0IGdhdGVUeG4gPSBpdHhuLmFwcGxpY2F0aW9uQ2FsbCh7CiAgICAvLyAgIGFwcElkOiBnYXRlLAogICAgLy8gICBhcHBBcmdzOiBbCiAgICAvLyAgICAgbWV0aG9kU2VsZWN0b3IoR2F0ZU11c3RDaGVja0FiaU1ldGhvZCksCiAgICAvLyAgICAgb3JpZ2luLAogICAgLy8gICAgIGdhdGVJRCwKICAgIC8vICAgICBlbmNvZGVBcmM0KGFyZ3MpCiAgICAvLyAgIF0sCiAgICAvLyB9KQogICAgaW50Y18zIC8vIDYKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxNjAtMTc0CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBNYXJrZXRwbGFjZS5wcm90b3R5cGUuZ2F0ZWRQdXJjaGFzZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBwcmljZQogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGdhdGVUeG4sCiAgICAvLyAgICAgYXBwSWQsCiAgICAvLyAgICAgbWFya2V0cGxhY2UsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MTczCiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICBkaWcgMTAKICAgIGRpZyAxMgogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MTYwLTE3NAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgTWFya2V0cGxhY2UucHJvdG90eXBlLmdhdGVkUHVyY2hhc2U+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogcHJpY2UKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBnYXRlVHhuLAogICAgLy8gICAgIGFwcElkLAogICAgLy8gICAgIG1hcmtldHBsYWNlLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4NmU5MDM1Y2MgLy8gbWV0aG9kICJnYXRlZFB1cmNoYXNlKHBheSxhcHBsLHVpbnQ2NCxhZGRyZXNzKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDEwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDgKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CgpwdXJjaGFzZV9hZnRlcl9pZl9lbHNlQDIwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxMzEtMTM3CiAgICAvLyBwdXJjaGFzZSgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24sCiAgICAvLyAgIG1hcmtldHBsYWNlOiBBY2NvdW50LAogICAgLy8gICBhcmdzOiBHYXRlQXJncwogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgpwdXJjaGFzZV9lbHNlX2JvZHlANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MTc2LTE4OQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgTWFya2V0cGxhY2UucHJvdG90eXBlLnB1cmNoYXNlPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZmFjdG9yeS52YWx1ZSwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IHByaWNlCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgYXBwSWQsCiAgICAvLyAgICAgbWFya2V0cGxhY2UKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MTgyCiAgICAvLyByZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoyMwogICAgLy8gZmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogTWFya2V0cGxhY2VQbHVnaW5HbG9iYWxTdGF0ZUtleUZhY3RvcnkgfSkKICAgIGJ5dGVjXzAgLy8gImZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjE4MgogICAgLy8gcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgZGlnIDMKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgMwogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxODAtMTg0CiAgICAvLyBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBwcmljZQogICAgLy8gfSksCiAgICBpbnRjXzIgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjE3Ni0xODkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIE1hcmtldHBsYWNlLnByb3RvdHlwZS5wdXJjaGFzZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBwcmljZQogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGFwcElkLAogICAgLy8gICAgIG1hcmtldHBsYWNlCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MTg4CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICBkaWcgMTAKICAgIGRpZyAxMgogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MTc2LTE4OQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgTWFya2V0cGxhY2UucHJvdG90eXBlLnB1cmNoYXNlPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZmFjdG9yeS52YWx1ZSwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IHByaWNlCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgYXBwSWQsCiAgICAvLyAgICAgbWFya2V0cGxhY2UKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDVkN2E2MTc3IC8vIG1ldGhvZCAicHVyY2hhc2UocGF5LHVpbnQ2NCxhZGRyZXNzKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDEwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDgKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBiIHB1cmNoYXNlX2FmdGVyX2lmX2Vsc2VAMjAKCnB1cmNoYXNlX2Vsc2VfYm9keUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MTkyCiAgICAvLyBpZiAoYXJncy5sZW5ndGggPiAwKSB7CiAgICBkaWcgNAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBieiBwdXJjaGFzZV9lbHNlX2JvZHlAMTYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MTkzCiAgICAvLyBjb25zdCB7IGdhdGUgfSA9IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMSAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxOTMKICAgIC8vIGNvbnN0IHsgZ2F0ZSB9ID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWMgNSAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxOTMKICAgIC8vIGNvbnN0IHsgZ2F0ZSB9ID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoxOTQKICAgIC8vIGNvbnN0IGdhdGVJRCA9IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NChhcHBJZCwgQnl0ZXMoTGlzdGluZ0dsb2JhbFN0YXRlS2V5R2F0ZUlEKSlbMF0KICAgIGRpZyA3CiAgICBieXRlYyA2IC8vICJnYXRlX2lkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoyMDEKICAgIC8vIGdhdGVJRCwKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MjA2LTIyMQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgTWFya2V0cGxhY2UucHJvdG90eXBlLmdhdGVkUHVyY2hhc2VBc2E+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IHByaWNlLAogICAgLy8gICAgICAgeGZlckFzc2V0OiBwYXltZW50QXNzZXQKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBnYXRlVHhuLAogICAgLy8gICAgIGFwcElkLAogICAgLy8gICAgIG1hcmtldHBsYWNlCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjIxMgogICAgLy8gYXNzZXRSZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoyMwogICAgLy8gZmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogTWFya2V0cGxhY2VQbHVnaW5HbG9iYWxTdGF0ZUtleUZhY3RvcnkgfSkKICAgIGJ5dGVjXzAgLy8gImZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjIxMgogICAgLy8gYXNzZXRSZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBkaWcgNAogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIGRpZyA1CiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGRpZyA1CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjIxMC0yMTUKICAgIC8vIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXNzZXRSZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgIGFzc2V0QW1vdW50OiBwcmljZSwKICAgIC8vICAgeGZlckFzc2V0OiBwYXltZW50QXNzZXQKICAgIC8vIH0pLAogICAgcHVzaGludCA0IC8vIDQKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoyMTYKICAgIC8vIGdhdGVUeG4sCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MTk5CiAgICAvLyBtZXRob2RTZWxlY3RvcihHYXRlTXVzdENoZWNrQWJpTWV0aG9kKSwKICAgIGJ5dGVjIDcgLy8gbWV0aG9kICJtdXN0Q2hlY2soYWRkcmVzcyx1aW50NjQsYnl0ZVtdW10pdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA3CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MTk2LTIwNAogICAgLy8gY29uc3QgZ2F0ZVR4biA9IGl0eG4uYXBwbGljYXRpb25DYWxsKHsKICAgIC8vICAgYXBwSWQ6IGdhdGUsCiAgICAvLyAgIGFwcEFyZ3M6IFsKICAgIC8vICAgICBtZXRob2RTZWxlY3RvcihHYXRlTXVzdENoZWNrQWJpTWV0aG9kKSwKICAgIC8vICAgICBvcmlnaW4sCiAgICAvLyAgICAgZ2F0ZUlELAogICAgLy8gICAgIGVuY29kZUFyYzQoYXJncykKICAgIC8vICAgXSwKICAgIC8vIH0pCiAgICBpbnRjXzMgLy8gNgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjIwNi0yMjEKICAgIC8vIGFiaUNhbGw8dHlwZW9mIE1hcmtldHBsYWNlLnByb3RvdHlwZS5nYXRlZFB1cmNoYXNlQXNhPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZmFjdG9yeS52YWx1ZSwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICAgIGFzc2V0QW1vdW50OiBwcmljZSwKICAgIC8vICAgICAgIHhmZXJBc3NldDogcGF5bWVudEFzc2V0CiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgZ2F0ZVR4biwKICAgIC8vICAgICBhcHBJZCwKICAgIC8vICAgICBtYXJrZXRwbGFjZQogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjIyMAogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgZGlnIDEwCiAgICBkaWcgMTIKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjIwNi0yMjEKICAgIC8vIGFiaUNhbGw8dHlwZW9mIE1hcmtldHBsYWNlLnByb3RvdHlwZS5nYXRlZFB1cmNoYXNlQXNhPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZmFjdG9yeS52YWx1ZSwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICAgIGFzc2V0QW1vdW50OiBwcmljZSwKICAgIC8vICAgICAgIHhmZXJBc3NldDogcGF5bWVudEFzc2V0CiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgZ2F0ZVR4biwKICAgIC8vICAgICBhcHBJZCwKICAgIC8vICAgICBtYXJrZXRwbGFjZQogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4ZGFhOTc1MTYgLy8gbWV0aG9kICJnYXRlZFB1cmNoYXNlQXNhKGF4ZmVyLGFwcGwsdWludDY0LGFkZHJlc3Mpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgOAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGIgcHVyY2hhc2VfYWZ0ZXJfaWZfZWxzZUAyMAoKcHVyY2hhc2VfZWxzZV9ib2R5QDE2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoyMjMtMjM3CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBNYXJrZXRwbGFjZS5wcm90b3R5cGUucHVyY2hhc2VBc2E+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IHByaWNlLAogICAgLy8gICAgICAgeGZlckFzc2V0OiBwYXltZW50QXNzZXQKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBhcHBJZCwKICAgIC8vICAgICBtYXJrZXRwbGFjZQogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoyMjkKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MjMKICAgIC8vIGZhY3RvcnkgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IE1hcmtldHBsYWNlUGx1Z2luR2xvYmFsU3RhdGVLZXlGYWN0b3J5IH0pCiAgICBieXRlY18wIC8vICJmYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoyMjkKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgZGlnIDIKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBkaWcgMwogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBkaWcgMwogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoyMjctMjMyCiAgICAvLyBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICBhc3NldEFtb3VudDogcHJpY2UsCiAgICAvLyAgIHhmZXJBc3NldDogcGF5bWVudEFzc2V0CiAgICAvLyB9KSwKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MjIzLTIzNwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgTWFya2V0cGxhY2UucHJvdG90eXBlLnB1cmNoYXNlQXNhPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZmFjdG9yeS52YWx1ZSwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICAgIGFzc2V0QW1vdW50OiBwcmljZSwKICAgIC8vICAgICAgIHhmZXJBc3NldDogcGF5bWVudEFzc2V0CiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgYXBwSWQsCiAgICAvLyAgICAgbWFya2V0cGxhY2UKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoyMzYKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIGRpZyAxMAogICAgZGlnIDEyCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoyMjMtMjM3CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBNYXJrZXRwbGFjZS5wcm90b3R5cGUucHVyY2hhc2VBc2E+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IHByaWNlLAogICAgLy8gICAgICAgeGZlckFzc2V0OiBwYXltZW50QXNzZXQKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBhcHBJZCwKICAgIC8vICAgICBtYXJrZXRwbGFjZQogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4MDJjZmIxY2YgLy8gbWV0aG9kICJwdXJjaGFzZUFzYShheGZlcix1aW50NjQsYWRkcmVzcyl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA4CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgYiBwdXJjaGFzZV9hZnRlcl9pZl9lbHNlQDIwCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czo6TWFya2V0cGxhY2VQbHVnaW4uY2hhbmdlUHJpY2Vbcm91dGluZ10oKSAtPiB2b2lkOgpjaGFuZ2VQcmljZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MjQyLTI0NwogICAgLy8gY2hhbmdlUHJpY2UoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICBwcmljZTogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMiAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MjUwCiAgICAvLyBhc3NlcnQoYXBwSWQuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9MSVNUSU5HX0NSRUFUT1JfTk9UX01BUktFVFBMQUNFKQogICAgZGlnIDEKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcENyZWF0b3IKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjIzCiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBNYXJrZXRwbGFjZVBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAiZmFjdG9yeSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MjUwCiAgICAvLyBhc3NlcnQoYXBwSWQuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9MSVNUSU5HX0NSRUFUT1JfTk9UX01BUktFVFBMQUNFKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gQ3JlYXRvciBpcyBub3QgdGhlIG1hcmtldHBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjI1Mi0yNTcKICAgIC8vIGFiaUNhbGw8dHlwZW9mIExpc3RpbmcucHJvdG90eXBlLmNoYW5nZVByaWNlPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtwcmljZV0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjI1NgogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDQKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjI1Mi0yNTcKICAgIC8vIGFiaUNhbGw8dHlwZW9mIExpc3RpbmcucHJvdG90eXBlLmNoYW5nZVByaWNlPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtwcmljZV0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHgxOTM5NmM0YSAvLyBtZXRob2QgImNoYW5nZVByaWNlKHVpbnQ2NCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjI0Mi0yNDcKICAgIC8vIGNoYW5nZVByaWNlKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcHJpY2U6IHVpbnQ2NAogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czo6TWFya2V0cGxhY2VQbHVnaW4uZGVsaXN0W3JvdXRpbmddKCkgLT4gdm9pZDoKZGVsaXN0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoyNjAtMjY0CiAgICAvLyBkZWxpc3QoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uCiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18yIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoyNjcKICAgIC8vIGFzc2VydChhcHBJZC5jcmVhdG9yID09PSB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywgRVJSX0xJU1RJTkdfQ1JFQVRPUl9OT1RfTUFSS0VUUExBQ0UpCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcENyZWF0b3IKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjIzCiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBNYXJrZXRwbGFjZVBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAiZmFjdG9yeSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL21hcmtldHBsYWNlL2NvbnRyYWN0LmFsZ28udHM6MjY3CiAgICAvLyBhc3NlcnQoYXBwSWQuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9MSVNUSU5HX0NSRUFUT1JfTk9UX01BUktFVFBMQUNFKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gQ3JlYXRvciBpcyBub3QgdGhlIG1hcmtldHBsYWNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjI2OS0yNzMKICAgIC8vIGFiaUNhbGw8dHlwZW9mIExpc3RpbmcucHJvdG90eXBlLmRlbGlzdD4oewogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW3NlbmRlcl0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9tYXJrZXRwbGFjZS9jb250cmFjdC5hbGdvLnRzOjI3MgogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgc3dhcAogICAgdW5jb3ZlciAzCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoyNjktMjczCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBMaXN0aW5nLnByb3RvdHlwZS5kZWxpc3Q+KHsKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtzZW5kZXJdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4NjhlODYzNDMgLy8gbWV0aG9kICJkZWxpc3QoYWRkcmVzcyl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbWFya2V0cGxhY2UvY29udHJhY3QuYWxnby50czoyNjAtMjY0CiAgICAvLyBkZWxpc3QoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo6QWtpdGFCYXNlQ29udHJhY3QudXBkYXRlQWtpdGFEQU9bcm91dGluZ10oKSAtPiB2b2lkOgp1cGRhdGVBa2l0YURBTzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjM4CiAgICAvLyB1cGRhdGVBa2l0YURBTyhha2l0YURBTzogQXBwbGljYXRpb24pOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozOQogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMyCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzEgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMyCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBwdXNoYnl0ZXMgIndhbGxldCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjM5CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5nZXRBa2l0YURBT1dhbGxldCgpLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IHRoZSBBa2l0YSBEQU8gY2FuIGNhbGwgdGhpcyBmdW5jdGlvbgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18xIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo0MAogICAgLy8gdGhpcy5ha2l0YURBTy52YWx1ZSA9IGFraXRhREFPCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzgKICAgIC8vIHVwZGF0ZUFraXRhREFPKGFraXRhREFPOiBBcHBsaWNhdGlvbik6IHZvaWQgewogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgo=", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyAEAAgBBiYIB2ZhY3RvcnkJYWtpdGFfZGFvEHNwZW5kaW5nX2FkZHJlc3MEFR98dQQ5Tq6yA2FhbAdnYXRlX2lkBEOSJlUxGRREMRhBADSCBgTep82dBCaeS7AETZa6RARZRm7yBDPpLJQEhU3t4DYaAI4GAFoCTgRsBMYFFgABACRDgAROs9+8NhoAjgEAEgCKAgGL/kAAAzIDiYv/cghEiTYaAUkiWYECCEsBFRJEVwIANhoCSRUjEkQXNhoDSRUjEkQXgAd2ZXJzaW9uTwNnKE8CZylMZyRDNhoBSRUjEkQXSTYaAkkVJBJEIlNMNhoDSU4CSRUjEkQXSU4CNhoESRUjEkQXSU4DNhoFSU4EFSMSRDYaBklOBEkVIxJEF04DNhoHSU4EFSMSRDYaCElOBBWBIBJENhoJSU4EFSMSRDYaCklOBBWBIBJENhoLSU4ESSJZgQIITBUSRDYaDElOBEkiWYEgC4ECCEwVEkRPAiplSElOA0sCcABIDkQiKGVEcghETHAARQFAAC6xIihlRElyCEQyELIIsgdLAUmyACSyECKyAbYnBLIaSw6yGrIAshglshAisgGzIihlRHIIREsIcABFAUAAYLEiKGVEgAQz94gIshpLCUlOArIaSbIYSwJJTgKyACWyECKyAbO0PklXBABMVwAEKxJESRUjEkQXsUsBcghEsgeyCEsBsgAkshAisgG2JwSyGk8CshqyGLIAJbIQIrIBs0sHQACWMhCBpIIlMgEICLEiKGVESXIIRE8CsgiyB0sBSU4CsgAkshAisgG2SXIIREsOshFLDbISshRLAbIAgQSyECKyAbZLD0sRiP4ZgATi+p4hshpLDLIaSwuyGksJshpLCLIaSweyGksGshpLBbIaSwSyGrIgshiyACWyECKyAbO3Aj5JVwQATFcABCsSREkVIxJEK0xQsCRDMhCBAgtC/2Q2GgFJFSMSRBdJNhoCSRUkEkQiU0w2GgNJTgJJFSMSRBdJTwI2GgRJTgMVgSASRDYaBU4CSYASY29udHJvbGxlZF9hZGRyZXNzZUhMSSplSExJgAhyZWZlcnJlcmVITHIIRE8DUE8CUExQSVcgIE4CV0AgTElyB0QiKGVEcghEEkRJgAVwcmljZWVITIANcGF5bWVudF9hc3NldGVISUAAuUsEIllBAHAiKWVEJwVlSIEoW0sHJwZlSBaxIihlRElyCERLBbIIsgdLBUlOArIAJLIQIrIBticHshpLB7IaTwKyGksHshpPArIYJbIQIrIBtksKSwyI/MqABG6QNcyyGksKshpLCLIasiCyGLIAJbIQIrIBsyRDsSIoZURJcghESwOyCLIHSwNJsgAkshAisgG2SwpLDIj8iYAEXXphd7IaSwqyGksIshqyILIAshglshAisgGzQv+8SwQiWUEAdiIpZUQnBWVIgShbSwcnBmVIFrEiKGVESXIIREsEshFLBbISshRLBUlOArIAgQSyECKyAbYnB7IaSweyGk8CshpLB7IaTwKyGCWyECKyAbZLCksMiPwMgATaqXUWshpLCrIaSwiyGrIgshiyACWyECKyAbNC/z+xIihlRElyCERLArIRSwOyErIUSwNJsgCBBLIQIrIBtksKSwyI+8WABALPsc+yGksKshpLCLIasiCyALIYJbIQIrIBs0L++DYaAUkVIxJEFzYaAkkVJBJEIlM2GgNJFSMSRBc2GgRJFSMSREsDKmVITgJLAXIHRCIoZURyCEQSRLFPA08EiPtkgAQZOWxKshqyILIashiyACWyECKyAbMkQzYaAUkVIxJEFzYaAkkVJBJEIlM2GgNJFSMSRBdLAiplSE4CSXIHRCIoZURyCEQSRLFMTwOI+xSABGjoY0OyGk8CshqyILIYJbIQIrIBsyRDNhoBSRUjEkQXMQAiKWVEgAZ3YWxsZXRlSHIIRBJEKUxnJEM=", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var MarketplacePluginParamsFactory = class _MarketplacePluginParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "createApplication":
          case "createApplication(string,uint64,uint64)void":
            return _MarketplacePluginParamsFactory.create.createApplication(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs create ABI call params for the MarketplacePlugin smart contract using the createApplication(string,uint64,uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      createApplication(params) {
        return {
          ...params,
          method: "createApplication(string,uint64,uint64)void",
          args: Array.isArray(params.args) ? params.args : [params.args.version, params.args.factory, params.args.akitaDao]
        };
      }
    };
  }
  /**
   * Constructs a no op call for the list(uint64,bool,uint64,uint64,uint64,uint64,uint64,address,uint64,address,string,byte[32][])uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static list(params) {
    return {
      ...params,
      method: "list(uint64,bool,uint64,uint64,uint64,uint64,uint64,address,uint64,address,string,byte[32][])uint64",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.asset, params.args.assetAmount, params.args.price, params.args.paymentAsset, params.args.expiration, params.args.reservedFor, params.args.gateId, params.args.marketplace, params.args.name, params.args.proof]
    };
  }
  /**
   * Constructs a no op call for the purchase(uint64,bool,uint64,address,byte[][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static purchase(params) {
    return {
      ...params,
      method: "purchase(uint64,bool,uint64,address,byte[][])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.marketplace, params.args.args]
    };
  }
  /**
   * Constructs a no op call for the changePrice(uint64,bool,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static changePrice(params) {
    return {
      ...params,
      method: "changePrice(uint64,bool,uint64,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.price]
    };
  }
  /**
   * Constructs a no op call for the delist(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static delist(params) {
    return {
      ...params,
      method: "delist(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId]
    };
  }
  /**
   * Constructs a no op call for the updateAkitaDAO(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDao(params) {
    return {
      ...params,
      method: "updateAkitaDAO(uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.akitaDao]
    };
  }
  /**
   * Constructs a no op call for the opUp()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static opUp(params) {
    return {
      ...params,
      method: "opUp()void",
      args: Array.isArray(params.args) ? params.args : []
    };
  }
};
var MarketplacePluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `MarketplacePluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory13({
      ...params,
      appSpec: APP_SPEC13
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC13;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new MarketplacePluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new MarketplacePluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the MarketplacePlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    var _a;
    const result = await this.appFactory.deploy({
      ...params,
      createParams: ((_a = params.createParams) == null ? void 0 : _a.method) ? MarketplacePluginParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams : void 0
    });
    return { result: result.result, appClient: new MarketplacePluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the MarketplacePlugin smart contract using the createApplication(string,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      createApplication: (params) => {
        return this.appFactory.params.create(MarketplacePluginParamsFactory.create.createApplication(params));
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the MarketplacePlugin smart contract using the createApplication(string,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      createApplication: (params) => {
        return this.appFactory.createTransaction.create(MarketplacePluginParamsFactory.create.createApplication(params));
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the MarketplacePlugin smart contract using an ABI method call using the createApplication(string,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      createApplication: async (params) => {
        const result = await this.appFactory.send.create(MarketplacePluginParamsFactory.create.createApplication(params));
        return { result: { ...result.result, return: result.result.return }, appClient: new MarketplacePluginClient(result.appClient) };
      }
    }
  };
};
var MarketplacePluginClient = class _MarketplacePluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient13 ? appClientOrParams : new _AppClient13({
      ...appClientOrParams,
      appSpec: APP_SPEC13
    });
  }
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue(method, returnValue) {
    return returnValue !== void 0 ? getArc56ReturnValue8(returnValue, this.appClient.getABIMethod(method), APP_SPEC13.structs) : void 0;
  }
  /**
   * Returns a new `MarketplacePluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _MarketplacePluginClient(await _AppClient13.fromCreatorAndName({ ...params, appSpec: APP_SPEC13 }));
  }
  /**
   * Returns an `MarketplacePluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _MarketplacePluginClient(await _AppClient13.fromNetwork({ ...params, appSpec: APP_SPEC13 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the MarketplacePlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the MarketplacePlugin smart contract using the `list(uint64,bool,uint64,uint64,uint64,uint64,uint64,address,uint64,address,string,byte[32][])uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    list: (params) => {
      return this.appClient.params.call(MarketplacePluginParamsFactory.list(params));
    },
    /**
     * Makes a call to the MarketplacePlugin smart contract using the `purchase(uint64,bool,uint64,address,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    purchase: (params) => {
      return this.appClient.params.call(MarketplacePluginParamsFactory.purchase(params));
    },
    /**
     * Makes a call to the MarketplacePlugin smart contract using the `changePrice(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    changePrice: (params) => {
      return this.appClient.params.call(MarketplacePluginParamsFactory.changePrice(params));
    },
    /**
     * Makes a call to the MarketplacePlugin smart contract using the `delist(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    delist: (params) => {
      return this.appClient.params.call(MarketplacePluginParamsFactory.delist(params));
    },
    /**
     * Makes a call to the MarketplacePlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDao: (params) => {
      return this.appClient.params.call(MarketplacePluginParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the MarketplacePlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.params.call(MarketplacePluginParamsFactory.opUp(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the MarketplacePlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the MarketplacePlugin smart contract using the `list(uint64,bool,uint64,uint64,uint64,uint64,uint64,address,uint64,address,string,byte[32][])uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    list: (params) => {
      return this.appClient.createTransaction.call(MarketplacePluginParamsFactory.list(params));
    },
    /**
     * Makes a call to the MarketplacePlugin smart contract using the `purchase(uint64,bool,uint64,address,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    purchase: (params) => {
      return this.appClient.createTransaction.call(MarketplacePluginParamsFactory.purchase(params));
    },
    /**
     * Makes a call to the MarketplacePlugin smart contract using the `changePrice(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    changePrice: (params) => {
      return this.appClient.createTransaction.call(MarketplacePluginParamsFactory.changePrice(params));
    },
    /**
     * Makes a call to the MarketplacePlugin smart contract using the `delist(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    delist: (params) => {
      return this.appClient.createTransaction.call(MarketplacePluginParamsFactory.delist(params));
    },
    /**
     * Makes a call to the MarketplacePlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDao: (params) => {
      return this.appClient.createTransaction.call(MarketplacePluginParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the MarketplacePlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.createTransaction.call(MarketplacePluginParamsFactory.opUp(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the MarketplacePlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the MarketplacePlugin smart contract using the `list(uint64,bool,uint64,uint64,uint64,uint64,uint64,address,uint64,address,string,byte[32][])uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    list: async (params) => {
      const result = await this.appClient.send.call(MarketplacePluginParamsFactory.list(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the MarketplacePlugin smart contract using the `purchase(uint64,bool,uint64,address,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    purchase: async (params) => {
      const result = await this.appClient.send.call(MarketplacePluginParamsFactory.purchase(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the MarketplacePlugin smart contract using the `changePrice(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    changePrice: async (params) => {
      const result = await this.appClient.send.call(MarketplacePluginParamsFactory.changePrice(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the MarketplacePlugin smart contract using the `delist(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    delist: async (params) => {
      const result = await this.appClient.send.call(MarketplacePluginParamsFactory.delist(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the MarketplacePlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDao: async (params) => {
      const result = await this.appClient.send.call(MarketplacePluginParamsFactory.updateAkitaDao(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the MarketplacePlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    opUp: async (params = { args: [] }) => {
      const result = await this.appClient.send.call(MarketplacePluginParamsFactory.opUp(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _MarketplacePluginClient(this.appClient.clone(params));
  }
  /**
   * Methods to access state for the current MarketplacePlugin app
   */
  state = {
    /**
     * Methods to access global state for the current MarketplacePlugin app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async () => {
        const result = await this.appClient.state.global.getAll();
        return {
          factory: result.factory,
          version: result.version,
          akitaDao: result.akitaDAO
        };
      },
      /**
       * Get the current value of the factory key in global state
       */
      factory: async () => {
        return await this.appClient.state.global.getValue("factory");
      },
      /**
       * Get the current value of the version key in global state
       */
      version: async () => {
        return await this.appClient.state.global.getValue("version");
      },
      /**
       * Get the current value of the akitaDAO key in global state
       */
      akitaDao: async () => {
        return await this.appClient.state.global.getValue("akitaDAO");
      }
    }
  };
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a list(uint64,bool,uint64,uint64,uint64,uint64,uint64,address,uint64,address,string,byte[32][])uint64 method call against the MarketplacePlugin contract
       */
      list(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.list(params)));
        resultMappers.push((v) => client.decodeReturnValue("list(uint64,bool,uint64,uint64,uint64,uint64,uint64,address,uint64,address,string,byte[32][])uint64", v));
        return this;
      },
      /**
       * Add a purchase(uint64,bool,uint64,address,byte[][])void method call against the MarketplacePlugin contract
       */
      purchase(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.purchase(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a changePrice(uint64,bool,uint64,uint64)void method call against the MarketplacePlugin contract
       */
      changePrice(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.changePrice(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a delist(uint64,bool,uint64)void method call against the MarketplacePlugin contract
       */
      delist(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.delist(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a updateAkitaDAO(uint64)void method call against the MarketplacePlugin contract
       */
      updateAkitaDao(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDao(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a opUp()void method call against the MarketplacePlugin contract
       */
      opUp(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.opUp(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a clear state call to the MarketplacePlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/marketplace.ts
var MarketplacePluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: MarketplacePluginFactory, ...params });
  }
  list(args) {
    const methodName = "list";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.list({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  purchase(args) {
    const methodName = "purchase";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.purchase({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  delist(args) {
    const methodName = "delist";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.delist({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
};

// src/generated/NFDPluginClient.ts
import {
  AppClient as _AppClient14
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory14 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC14 = { "name": "NFDPlugin", "structs": {}, "methods": [{ "name": "create", "args": [{ "type": "uint64", "name": "registry" }], "returns": { "type": "void" }, "actions": { "create": ["NoOp"], "call": [] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "deleteFields", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "byte[][]", "name": "fieldNames" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "updateFields", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "byte[][]", "name": "fieldAndVals" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "offerForSale", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "uint64", "name": "sellAmount" }, { "type": "address", "name": "reservedFor" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "cancelSale", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "postOffer", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "uint64", "name": "offer" }, { "type": "string", "name": "note" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "purchase", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "updateHash", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "byte[]", "name": "hash" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "contractLock", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "bool", "name": "lock" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "segmentLock", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "bool", "name": "lock" }, { "type": "uint64", "name": "usdPrice" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "vaultOptInLock", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "bool", "name": "lock" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "vaultOptIn", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "uint64[]", "name": "assets" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "vaultSend", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "uint64", "name": "amount" }, { "type": "address", "name": "receiver" }, { "type": "string", "name": "note" }, { "type": "uint64", "name": "asset" }, { "type": "uint64[]", "name": "otherAssets" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "renew", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "uint64", "name": "years" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "setPrimaryAddress", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "string", "name": "fieldName" }, { "type": "address", "name": "address" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 1, "bytes": 0 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": { "registry": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "bmZkX3JlZ2lzdHJ5" } }, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": [], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [1387, 1615], "errorMessage": "Bytes has valid prefix" }, { "pc": [673], "errorMessage": "No sale amount set" }, { "pc": [247, 324, 414, 491, 583, 659, 780, 862, 951, 1037, 1126, 1254, 1351, 1510], "errorMessage": "Not a valid NFD app id" }, { "pc": [47], "errorMessage": "OnCompletion must be NoOp" }, { "pc": [188, 679, 1399], "errorMessage": "application exists" }, { "pc": [1567], "errorMessage": "check GlobalState exists" }, { "pc": [1114, 1242], "errorMessage": "invalid number of bytes for (len+uint64[])" }, { "pc": [768], "errorMessage": "invalid number of bytes for (len+uint8[])" }, { "pc": [571, 1218, 1489], "errorMessage": "invalid number of bytes for (len+utf8[])" }, { "pc": [220, 297, 374, 468, 538, 637, 743, 830, 849, 912, 931, 1005, 1024, 1087, 1176, 1320, 1464, 1620], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [197, 211, 230, 288, 307, 365, 384, 393, 459, 478, 529, 548, 557, 628, 647, 734, 753, 821, 840, 903, 922, 939, 996, 1015, 1078, 1097, 1167, 1186, 1195, 1226, 1311, 1330, 1339, 1392, 1455, 1474], "errorMessage": "invalid number of bytes for uint64" }, { "pc": [402, 1204, 1498], "errorMessage": "invalid number of bytes for uint8[32]" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCA4IDEgNgogICAgYnl0ZWNibG9jayAic3BlbmRpbmdfYWRkcmVzcyIgIm5mZF9yZWdpc3RyeSIgMHgxNTFmN2M3NQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MTMKICAgIC8vIGV4cG9ydCBjbGFzcyBORkRQbHVnaW4gZXh0ZW5kcyBDb250cmFjdCB7CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIG11c3QgYmUgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGJ6IG1haW5fY3JlYXRlX05vT3BAMTgKICAgIHB1c2hieXRlc3MgMHgwZDg0ZTdhNCAweDgyMGNkNGE2IDB4N2I3MDMyYTAgMHhmYWNhZTAzNSAweDFmODU2ZWQyIDB4MjNkY2VlNmMgMHhhMzhmOGNhOCAweDNmMWI3YWU5IDB4ZDFiOTgyNDMgMHg0NGZjYWU1ZiAweDc4ODZkYzJhIDB4NTM3NWYyNDMgMHhhMzcxMGE4OSAweDQ0NjEzZjU4IC8vIG1ldGhvZCAiZGVsZXRlRmllbGRzKHVpbnQ2NCxib29sLHVpbnQ2NCxieXRlW11bXSl2b2lkIiwgbWV0aG9kICJ1cGRhdGVGaWVsZHModWludDY0LGJvb2wsdWludDY0LGJ5dGVbXVtdKXZvaWQiLCBtZXRob2QgIm9mZmVyRm9yU2FsZSh1aW50NjQsYm9vbCx1aW50NjQsdWludDY0LGFkZHJlc3Mpdm9pZCIsIG1ldGhvZCAiY2FuY2VsU2FsZSh1aW50NjQsYm9vbCx1aW50NjQpdm9pZCIsIG1ldGhvZCAicG9zdE9mZmVyKHVpbnQ2NCxib29sLHVpbnQ2NCx1aW50NjQsc3RyaW5nKXZvaWQiLCBtZXRob2QgInB1cmNoYXNlKHVpbnQ2NCxib29sLHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJ1cGRhdGVIYXNoKHVpbnQ2NCxib29sLHVpbnQ2NCxieXRlW10pdm9pZCIsIG1ldGhvZCAiY29udHJhY3RMb2NrKHVpbnQ2NCxib29sLHVpbnQ2NCxib29sKXZvaWQiLCBtZXRob2QgInNlZ21lbnRMb2NrKHVpbnQ2NCxib29sLHVpbnQ2NCxib29sLHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJ2YXVsdE9wdEluTG9jayh1aW50NjQsYm9vbCx1aW50NjQsYm9vbCl2b2lkIiwgbWV0aG9kICJ2YXVsdE9wdEluKHVpbnQ2NCxib29sLHVpbnQ2NCx1aW50NjRbXSl2b2lkIiwgbWV0aG9kICJ2YXVsdFNlbmQodWludDY0LGJvb2wsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHN0cmluZyx1aW50NjQsdWludDY0W10pdm9pZCIsIG1ldGhvZCAicmVuZXcodWludDY0LGJvb2wsdWludDY0LHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJzZXRQcmltYXJ5QWRkcmVzcyh1aW50NjQsYm9vbCx1aW50NjQsc3RyaW5nLGFkZHJlc3Mpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIGRlbGV0ZUZpZWxkcyB1cGRhdGVGaWVsZHMgb2ZmZXJGb3JTYWxlIGNhbmNlbFNhbGUgcG9zdE9mZmVyIHB1cmNoYXNlIHVwZGF0ZUhhc2ggY29udHJhY3RMb2NrIHNlZ21lbnRMb2NrIHZhdWx0T3B0SW5Mb2NrIHZhdWx0T3B0SW4gdmF1bHRTZW5kIHJlbmV3IHNldFByaW1hcnlBZGRyZXNzCiAgICBlcnIKCm1haW5fY3JlYXRlX05vT3BAMTg6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoxMwogICAgLy8gZXhwb3J0IGNsYXNzIE5GRFBsdWdpbiBleHRlbmRzIENvbnRyYWN0IHsKICAgIHB1c2hieXRlcyAweDI0MGQyZjY3IC8vIG1ldGhvZCAiY3JlYXRlKHVpbnQ2NCl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggY3JlYXRlCiAgICBlcnIKCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjpyZWtleUFkZHJlc3MocmVrZXlCYWNrOiB1aW50NjQsIHdhbGxldDogdWludDY0KSAtPiBieXRlczoKcmVrZXlBZGRyZXNzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjEKICAgIC8vIGV4cG9ydCBmdW5jdGlvbiByZWtleUFkZHJlc3MocmVrZXlCYWNrOiBib29sZWFuLCB3YWxsZXQ6IEFwcGxpY2F0aW9uKTogQWNjb3VudCB7CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzIyCiAgICAvLyBpZiAoIXJla2V5QmFjaykgewogICAgZnJhbWVfZGlnIC0yCiAgICBibnogcmVrZXlBZGRyZXNzX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjMKICAgIC8vIHJldHVybiBHbG9iYWwuemVyb0FkZHJlc3MKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgcmV0c3ViCgpyZWtleUFkZHJlc3NfYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjYKICAgIC8vIHJldHVybiB3YWxsZXQuYWRkcmVzcwogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czo6TkZEUGx1Z2luLmNyZWF0ZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmNyZWF0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjMyCiAgICAvLyBAYWJpbWV0aG9kKHsgb25DcmVhdGU6ICdyZXF1aXJlJyB9KQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjE3CiAgICAvLyByZWdpc3RyeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogTkZEUGx1Z2luR2xvYmFsU3RhdGVLZXlSZWdpc3RyeSB9KQogICAgYnl0ZWNfMSAvLyAibmZkX3JlZ2lzdHJ5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MzQKICAgIC8vIHRoaXMucmVnaXN0cnkudmFsdWUgPSBBcHBsaWNhdGlvbihyZWdpc3RyeSkKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czozMgogICAgLy8gQGFiaW1ldGhvZCh7IG9uQ3JlYXRlOiAncmVxdWlyZScgfSkKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czo6TkZEUGx1Z2luLmRlbGV0ZUZpZWxkc1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmRlbGV0ZUZpZWxkczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjM5LTQ0CiAgICAvLyBkZWxldGVGaWVsZHMoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICBmaWVsZE5hbWVzOiBieXRlc1tdCiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18wIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6NDcKICAgIC8vIGFzc2VydCh0aGlzLmlzTkZEKGFwcElkKSwgRVJSX05PVF9BTl9ORkQpCiAgICBkaWcgMQogICAgY2FsbHN1YiBpc05GRAogICAgYXNzZXJ0IC8vIE5vdCBhIHZhbGlkIE5GRCBhcHAgaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjQ5LTU0CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBORkQucHJvdG90eXBlLmRlbGV0ZUZpZWxkcz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbZmllbGROYW1lc10sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czo1MwogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciAyCiAgICB1bmNvdmVyIDQKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czo0OS01NAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgTkZELnByb3RvdHlwZS5kZWxldGVGaWVsZHM+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW2ZpZWxkTmFtZXNdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4NTEzMmRmNzUgLy8gbWV0aG9kICJkZWxldGVGaWVsZHMoYnl0ZVtdW10pdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MzktNDQKICAgIC8vIGRlbGV0ZUZpZWxkcygKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24sCiAgICAvLyAgIGZpZWxkTmFtZXM6IGJ5dGVzW10KICAgIC8vICk6IHZvaWQgewogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjpORkRQbHVnaW4udXBkYXRlRmllbGRzW3JvdXRpbmddKCkgLT4gdm9pZDoKdXBkYXRlRmllbGRzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6NTctNjIKICAgIC8vIHVwZGF0ZUZpZWxkcygKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24sCiAgICAvLyAgIGZpZWxkQW5kVmFsczogYnl0ZXNbXQogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMCAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIGNvdmVyIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjY2CiAgICAvLyBhc3NlcnQodGhpcy5pc05GRChhcHBJZCksIEVSUl9OT1RfQU5fTkZEKQogICAgZGlnIDEKICAgIGNhbGxzdWIgaXNORkQKICAgIGFzc2VydCAvLyBOb3QgYSB2YWxpZCBORkQgYXBwIGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czo2OC03MwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgTkZELnByb3RvdHlwZS51cGRhdGVGaWVsZHM+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW2ZpZWxkQW5kVmFsc10sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czo3MgogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciAyCiAgICB1bmNvdmVyIDQKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czo2OC03MwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgTkZELnByb3RvdHlwZS51cGRhdGVGaWVsZHM+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW2ZpZWxkQW5kVmFsc10sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHg3OGY0MjcxMSAvLyBtZXRob2QgInVwZGF0ZUZpZWxkcyhieXRlW11bXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czo1Ny02MgogICAgLy8gdXBkYXRlRmllbGRzKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbiwKICAgIC8vICAgZmllbGRBbmRWYWxzOiBieXRlc1tdCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czo6TkZEUGx1Z2luLm9mZmVyRm9yU2FsZVtyb3V0aW5nXSgpIC0+IHZvaWQ6Cm9mZmVyRm9yU2FsZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjc2LTgyCiAgICAvLyBvZmZlckZvclNhbGUoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICBzZWxsQW1vdW50OiB1aW50NjQsCiAgICAvLyAgIHJlc2VydmVkRm9yOiBBY2NvdW50CiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMCAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjg2CiAgICAvLyBhc3NlcnQodGhpcy5pc05GRChhcHBJZCksIEVSUl9OT1RfQU5fTkZEKQogICAgZGlnIDMKICAgIGNhbGxzdWIgaXNORkQKICAgIGFzc2VydCAvLyBOb3QgYSB2YWxpZCBORkQgYXBwIGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czo4OC05MwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgTkZELnByb3RvdHlwZS5vZmZlckZvclNhbGU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW3NlbGxBbW91bnQsIHJlc2VydmVkRm9yXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjkyCiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICB1bmNvdmVyIDQKICAgIHVuY292ZXIgNQogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjg4LTkzCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBORkQucHJvdG90eXBlLm9mZmVyRm9yU2FsZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbc2VsbEFtb3VudCwgcmVzZXJ2ZWRGb3JdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4NTA3NmQ5Y2EgLy8gbWV0aG9kICJvZmZlckZvclNhbGUodWludDY0LGFkZHJlc3Mpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6NzYtODIKICAgIC8vIG9mZmVyRm9yU2FsZSgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24sCiAgICAvLyAgIHNlbGxBbW91bnQ6IHVpbnQ2NCwKICAgIC8vICAgcmVzZXJ2ZWRGb3I6IEFjY291bnQKICAgIC8vICk6IHZvaWQgewogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjpORkRQbHVnaW4uY2FuY2VsU2FsZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmNhbmNlbFNhbGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czo5Ni0xMDAKICAgIC8vIGNhbmNlbFNhbGUoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uCiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18wIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MTA0CiAgICAvLyBhc3NlcnQodGhpcy5pc05GRChhcHBJZCksIEVSUl9OT1RfQU5fTkZEKQogICAgZHVwCiAgICBjYWxsc3ViIGlzTkZECiAgICBhc3NlcnQgLy8gTm90IGEgdmFsaWQgTkZEIGFwcCBpZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MTA2LTExMQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgTkZELnByb3RvdHlwZS5jYW5jZWxTYWxlPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MTEwCiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICBzd2FwCiAgICB1bmNvdmVyIDMKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoxMDYtMTExCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBORkQucHJvdG90eXBlLmNhbmNlbFNhbGU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW10sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHg5OWY1ZDUwZCAvLyBtZXRob2QgImNhbmNlbFNhbGUoKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6OTYtMTAwCiAgICAvLyBjYW5jZWxTYWxlKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbgogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6Ok5GRFBsdWdpbi5wb3N0T2ZmZXJbcm91dGluZ10oKSAtPiB2b2lkOgpwb3N0T2ZmZXI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoxMTQtMTIwCiAgICAvLyBwb3N0T2ZmZXIoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICBvZmZlcjogdWludDY0LAogICAgLy8gICBub3RlOiBzdHJpbmcKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMCAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjEyNAogICAgLy8gYXNzZXJ0KHRoaXMuaXNORkQoYXBwSWQpLCBFUlJfTk9UX0FOX05GRCkKICAgIGRpZyAzCiAgICBjYWxsc3ViIGlzTkZECiAgICBhc3NlcnQgLy8gTm90IGEgdmFsaWQgTkZEIGFwcCBpZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MTI2LTEzMQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgTkZELnByb3RvdHlwZS5wb3N0T2ZmZXI+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW29mZmVyLCBub3RlXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjEzMAogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciA0CiAgICB1bmNvdmVyIDUKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoxMjYtMTMxCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBORkQucHJvdG90eXBlLnBvc3RPZmZlcj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbb2ZmZXIsIG5vdGVdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4OTEzMTEyZWYgLy8gbWV0aG9kICJwb3N0T2ZmZXIodWludDY0LHN0cmluZyl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoxMTQtMTIwCiAgICAvLyBwb3N0T2ZmZXIoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICBvZmZlcjogdWludDY0LAogICAgLy8gICBub3RlOiBzdHJpbmcKICAgIC8vICk6IHZvaWQgewogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjpORkRQbHVnaW4ucHVyY2hhc2Vbcm91dGluZ10oKSAtPiB2b2lkOgpwdXJjaGFzZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjEzNC0xMzgKICAgIC8vIHB1cmNoYXNlKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbiwKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzAgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoxNDIKICAgIC8vIGFzc2VydCh0aGlzLmlzTkZEKGFwcElkKSwgRVJSX05PVF9BTl9ORkQpCiAgICBkdXAKICAgIGNhbGxzdWIgaXNORkQKICAgIGFzc2VydCAvLyBOb3QgYSB2YWxpZCBORkQgYXBwIGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoxNDQKICAgIC8vIGNvbnN0IFtzYWxlQW1vdW50Qnl0ZXMsIHNhbGVBbW91bnRCeXRlc0V4aXN0c10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhhcHBJZC5pZCwgQnl0ZXMoTkZER2xvYmFsU3RhdGVLZXlTYWxlQW1vdW50S2V5KSkKICAgIGR1cAogICAgcHVzaGJ5dGVzICJpLnNhbGVhbXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MTQ1CiAgICAvLyBhc3NlcnQoc2FsZUFtb3VudEJ5dGVzRXhpc3RzLCAnTm8gc2FsZSBhbW91bnQgc2V0JykKICAgIGFzc2VydCAvLyBObyBzYWxlIGFtb3VudCBzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjE0Ny0xNTgKICAgIC8vIGFiaUNhbGw8dHlwZW9mIE5GRC5wcm90b3R5cGUucHVyY2hhc2U+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogYnRvaShzYWxlQW1vdW50Qnl0ZXMpCiAgICAvLyAgICAgfSksCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoxNTMKICAgIC8vIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgZGlnIDEKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjE1NAogICAgLy8gYW1vdW50OiBidG9pKHNhbGVBbW91bnRCeXRlcykKICAgIHN3YXAKICAgIGJ0b2kKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjE1MS0xNTUKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogYnRvaShzYWxlQW1vdW50Qnl0ZXMpCiAgICAvLyB9KSwKICAgIGludGNfMiAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjE0Ny0xNTgKICAgIC8vIGFiaUNhbGw8dHlwZW9mIE5GRC5wcm90b3R5cGUucHVyY2hhc2U+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogYnRvaShzYWxlQW1vdW50Qnl0ZXMpCiAgICAvLyAgICAgfSksCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjE1NwogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciAyCiAgICB1bmNvdmVyIDMKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoxNDctMTU4CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBORkQucHJvdG90eXBlLnB1cmNoYXNlPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IGJ0b2koc2FsZUFtb3VudEJ5dGVzKQogICAgLy8gICAgIH0pLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4YTM5MmFlODIgLy8gbWV0aG9kICJwdXJjaGFzZShwYXkpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoxMzQtMTM4CiAgICAvLyBwdXJjaGFzZSgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24sCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czo6TkZEUGx1Z2luLnVwZGF0ZUhhc2hbcm91dGluZ10oKSAtPiB2b2lkOgp1cGRhdGVIYXNoOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MTYxLTE2NgogICAgLy8gdXBkYXRlSGFzaCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24sCiAgICAvLyAgIGhhc2g6IGJ5dGVzCiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3VpbnQ4W10pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzAgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoxNzAKICAgIC8vIGFzc2VydCh0aGlzLmlzTkZEKGFwcElkKSwgRVJSX05PVF9BTl9ORkQpCiAgICBkaWcgMgogICAgY2FsbHN1YiBpc05GRAogICAgYXNzZXJ0IC8vIE5vdCBhIHZhbGlkIE5GRCBhcHAgaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjE3Mi0xNzcKICAgIC8vIGFiaUNhbGw8dHlwZW9mIE5GRC5wcm90b3R5cGUudXBkYXRlSGFzaD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbaGFzaF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoxNzYKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciA0CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MTcyLTE3NwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgTkZELnByb3RvdHlwZS51cGRhdGVIYXNoPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtoYXNoXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDc2MmU4MmRhIC8vIG1ldGhvZCAidXBkYXRlSGFzaChieXRlW10pdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MTYxLTE2NgogICAgLy8gdXBkYXRlSGFzaCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24sCiAgICAvLyAgIGhhc2g6IGJ5dGVzCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czo6TkZEUGx1Z2luLmNvbnRyYWN0TG9ja1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmNvbnRyYWN0TG9jazoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjE4MC0xODUKICAgIC8vIGNvbnRyYWN0TG9jaygKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24sCiAgICAvLyAgIGxvY2s6IGJvb2xlYW4KICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzAgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBjb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoxODkKICAgIC8vIGFzc2VydCh0aGlzLmlzTkZEKGFwcElkKSwgRVJSX05PVF9BTl9ORkQpCiAgICBkaWcgMQogICAgY2FsbHN1YiBpc05GRAogICAgYXNzZXJ0IC8vIE5vdCBhIHZhbGlkIE5GRCBhcHAgaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjE5MS0xOTYKICAgIC8vIGFiaUNhbGw8dHlwZW9mIE5GRC5wcm90b3R5cGUuY29udHJhY3RMb2NrPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtsb2NrXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjE5NQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDQKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoxOTEtMTk2CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBORkQucHJvdG90eXBlLmNvbnRyYWN0TG9jaz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbbG9ja10sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHg4ZWJjMmM4MyAvLyBtZXRob2QgImNvbnRyYWN0TG9jayhib29sKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjE4MC0xODUKICAgIC8vIGNvbnRyYWN0TG9jaygKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24sCiAgICAvLyAgIGxvY2s6IGJvb2xlYW4KICAgIC8vICk6IHZvaWQgewogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjpORkRQbHVnaW4uc2VnbWVudExvY2tbcm91dGluZ10oKSAtPiB2b2lkOgpzZWdtZW50TG9jazoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjE5OS0yMDUKICAgIC8vIHNlZ21lbnRMb2NrKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbiwKICAgIC8vICAgbG9jazogYm9vbGVhbiwKICAgIC8vICAgdXNkUHJpY2U6IHVpbnQ2NAogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgNAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzAgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoyMDkKICAgIC8vIGFzc2VydCh0aGlzLmlzTkZEKGFwcElkKSwgRVJSX05PVF9BTl9ORkQpCiAgICBkaWcgMwogICAgY2FsbHN1YiBpc05GRAogICAgYXNzZXJ0IC8vIE5vdCBhIHZhbGlkIE5GRCBhcHAgaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjIxMS0yMTYKICAgIC8vIGFiaUNhbGw8dHlwZW9mIE5GRC5wcm90b3R5cGUuc2VnbWVudExvY2s+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW2xvY2ssIHVzZFByaWNlXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjIxNQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciA0CiAgICB1bmNvdmVyIDUKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoyMTEtMjE2CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBORkQucHJvdG90eXBlLnNlZ21lbnRMb2NrPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtsb2NrLCB1c2RQcmljZV0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHhjZDUzNThhNiAvLyBtZXRob2QgInNlZ21lbnRMb2NrKGJvb2wsdWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjE5OS0yMDUKICAgIC8vIHNlZ21lbnRMb2NrKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbiwKICAgIC8vICAgbG9jazogYm9vbGVhbiwKICAgIC8vICAgdXNkUHJpY2U6IHVpbnQ2NAogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6Ok5GRFBsdWdpbi52YXVsdE9wdEluTG9ja1tyb3V0aW5nXSgpIC0+IHZvaWQ6CnZhdWx0T3B0SW5Mb2NrOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MjE5LTIyNAogICAgLy8gdmF1bHRPcHRJbkxvY2soCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICBsb2NrOiBib29sZWFuCiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18wIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MjI4CiAgICAvLyBhc3NlcnQodGhpcy5pc05GRChhcHBJZCksIEVSUl9OT1RfQU5fTkZEKQogICAgZGlnIDEKICAgIGNhbGxzdWIgaXNORkQKICAgIGFzc2VydCAvLyBOb3QgYSB2YWxpZCBORkQgYXBwIGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoyMzAtMjM1CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBORkQucHJvdG90eXBlLnZhdWx0T3B0SW5Mb2NrPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtsb2NrXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjIzNAogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDQKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoyMzAtMjM1CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBORkQucHJvdG90eXBlLnZhdWx0T3B0SW5Mb2NrPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtsb2NrXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDNhNjU3ZDc3IC8vIG1ldGhvZCAidmF1bHRPcHRJbkxvY2soYm9vbCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoyMTktMjI0CiAgICAvLyB2YXVsdE9wdEluTG9jaygKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24sCiAgICAvLyAgIGxvY2s6IGJvb2xlYW4KICAgIC8vICk6IHZvaWQgewogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjpORkRQbHVnaW4udmF1bHRPcHRJbltyb3V0aW5nXSgpIC0+IHZvaWQ6CnZhdWx0T3B0SW46CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoyMzgtMjQzCiAgICAvLyB2YXVsdE9wdEluKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbiwKICAgIC8vICAgYXNzZXRzOiB1aW50NjRbXQogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzEgLy8gOAogICAgKgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdWludDY0W10pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzAgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoyNDcKICAgIC8vIGFzc2VydCh0aGlzLmlzTkZEKGFwcElkKSwgRVJSX05PVF9BTl9ORkQpCiAgICBkaWcgMgogICAgY2FsbHN1YiBpc05GRAogICAgYXNzZXJ0IC8vIE5vdCBhIHZhbGlkIE5GRCBhcHAgaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjI0OS0yNTQKICAgIC8vIGFiaUNhbGw8dHlwZW9mIE5GRC5wcm90b3R5cGUudmF1bHRPcHRJbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbYXNzZXRzXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjI1MwogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDQKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoyNDktMjU0CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBORkQucHJvdG90eXBlLnZhdWx0T3B0SW4+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW2Fzc2V0c10sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHg0MTNkMTUyMyAvLyBtZXRob2QgInZhdWx0T3B0SW4odWludDY0W10pdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MjM4LTI0MwogICAgLy8gdmF1bHRPcHRJbigKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24sCiAgICAvLyAgIGFzc2V0czogdWludDY0W10KICAgIC8vICk6IHZvaWQgewogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjpORkRQbHVnaW4udmF1bHRTZW5kW3JvdXRpbmddKCkgLT4gdm9pZDoKdmF1bHRTZW5kOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MjU3LTI2NgogICAgLy8gdmF1bHRTZW5kKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbiwKICAgIC8vICAgYW1vdW50OiB1aW50NjQsCiAgICAvLyAgIHJlY2VpdmVyOiBBY2NvdW50LAogICAgLy8gICBub3RlOiBzdHJpbmcsCiAgICAvLyAgIGFzc2V0OiB1aW50NjQsCiAgICAvLyAgIG90aGVyQXNzZXRzOiB1aW50NjRbXQogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA2CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDgKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzEgLy8gOAogICAgKgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdWludDY0W10pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgNwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzAgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoyNzAKICAgIC8vIGFzc2VydCh0aGlzLmlzTkZEKGFwcElkKSwgRVJSX05PVF9BTl9ORkQpCiAgICBkaWcgNgogICAgY2FsbHN1YiBpc05GRAogICAgYXNzZXJ0IC8vIE5vdCBhIHZhbGlkIE5GRCBhcHAgaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjI3Mi0yNzcKICAgIC8vIGFiaUNhbGw8dHlwZW9mIE5GRC5wcm90b3R5cGUudmF1bHRTZW5kPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFthbW91bnQsIHJlY2VpdmVyLCBub3RlLCBhc3NldCwgb3RoZXJBc3NldHNdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6Mjc2CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICB1bmNvdmVyIDcKICAgIHVuY292ZXIgOAogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjI3Mi0yNzcKICAgIC8vIGFiaUNhbGw8dHlwZW9mIE5GRC5wcm90b3R5cGUudmF1bHRTZW5kPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFthbW91bnQsIHJlY2VpdmVyLCBub3RlLCBhc3NldCwgb3RoZXJBc3NldHNdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4NjY4MjFjMWEgLy8gbWV0aG9kICJ2YXVsdFNlbmQodWludDY0LGFkZHJlc3Msc3RyaW5nLHVpbnQ2NCx1aW50NjRbXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoyNTctMjY2CiAgICAvLyB2YXVsdFNlbmQoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICBhbW91bnQ6IHVpbnQ2NCwKICAgIC8vICAgcmVjZWl2ZXI6IEFjY291bnQsCiAgICAvLyAgIG5vdGU6IHN0cmluZywKICAgIC8vICAgYXNzZXQ6IHVpbnQ2NCwKICAgIC8vICAgb3RoZXJBc3NldHM6IHVpbnQ2NFtdCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czo6TkZEUGx1Z2luLnJlbmV3W3JvdXRpbmddKCkgLT4gdm9pZDoKcmVuZXc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoyODAtMjg1CiAgICAvLyByZW5ldygKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24sCiAgICAvLyAgIHllYXJzOiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18wIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6Mjg5CiAgICAvLyBhc3NlcnQodGhpcy5pc05GRChhcHBJZCksIEVSUl9OT1RfQU5fTkZEKQogICAgZGlnIDIKICAgIGNhbGxzdWIgaXNORkQKICAgIGFzc2VydCAvLyBOb3QgYSB2YWxpZCBORkQgYXBwIGlkCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoyOTEtMjk1CiAgICAvLyBjb25zdCBwcmljZSA9IGFiaUNhbGw8dHlwZW9mIE5GRC5wcm90b3R5cGUuZ2V0UmVuZXdQcmljZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbXQogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIHB1c2hieXRlcyAweDUwZjQ5MGMyIC8vIG1ldGhvZCAiZ2V0UmVuZXdQcmljZSgpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18yIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjI5Ny0zMDgKICAgIC8vIGFiaUNhbGw8dHlwZW9mIE5GRC5wcm90b3R5cGUucmVuZXc+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogKHByaWNlICogeWVhcnMpCiAgICAvLyAgICAgfSkKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjMwMwogICAgLy8gcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICBkaWcgMwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MzA0CiAgICAvLyBhbW91bnQ6IChwcmljZSAqIHllYXJzKQogICAgc3dhcAogICAgdW5jb3ZlciAzCiAgICAqCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MzAxLTMwNQogICAgLy8gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiAocHJpY2UgKiB5ZWFycykKICAgIC8vIH0pCiAgICBpbnRjXzIgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoyOTctMzA4CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBORkQucHJvdG90eXBlLnJlbmV3Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IChwcmljZSAqIHllYXJzKQogICAgLy8gICAgIH0pCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjMwNwogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciAyCiAgICB1bmNvdmVyIDMKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoyOTctMzA4CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBORkQucHJvdG90eXBlLnJlbmV3Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IChwcmljZSAqIHllYXJzKQogICAgLy8gICAgIH0pCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHg3N2ZkNWI3NCAvLyBtZXRob2QgInJlbmV3KHBheSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjI4MC0yODUKICAgIC8vIHJlbmV3KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbiwKICAgIC8vICAgeWVhcnM6IHVpbnQ2NAogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6Ok5GRFBsdWdpbi5zZXRQcmltYXJ5QWRkcmVzc1tyb3V0aW5nXSgpIC0+IHZvaWQ6CnNldFByaW1hcnlBZGRyZXNzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MzExLTMxNwogICAgLy8gc2V0UHJpbWFyeUFkZHJlc3MoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICBmaWVsZE5hbWU6IHN0cmluZywKICAgIC8vICAgYWRkcmVzczogQWNjb3VudAogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1dGY4W10pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgNAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzAgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czozMjAKICAgIC8vIGFzc2VydCh0aGlzLmlzTkZEKGFwcElkKSwgRVJSX05PVF9BTl9ORkQpCiAgICBkaWcgMwogICAgY2FsbHN1YiBpc05GRAogICAgYXNzZXJ0IC8vIE5vdCBhIHZhbGlkIE5GRCBhcHAgaWQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjMyMi0zMjcKICAgIC8vIGFiaUNhbGw8dHlwZW9mIE5GRC5wcm90b3R5cGUuc2V0UHJpbWFyeUFkZHJlc3M+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW2ZpZWxkTmFtZSwgYWRkcmVzc10sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czozMjYKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIHVuY292ZXIgNAogICAgdW5jb3ZlciA1CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MzIyLTMyNwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgTkZELnByb3RvdHlwZS5zZXRQcmltYXJ5QWRkcmVzcz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbZmllbGROYW1lLCBhZGRyZXNzXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDk3YjZkODZjIC8vIG1ldGhvZCAic2V0UHJpbWFyeUFkZHJlc3Moc3RyaW5nLGFkZHJlc3Mpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MzExLTMxNwogICAgLy8gc2V0UHJpbWFyeUFkZHJlc3MoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICBmaWVsZE5hbWU6IHN0cmluZywKICAgIC8vICAgYWRkcmVzczogQWNjb3VudAogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6Ok5GRFBsdWdpbi5pc05GRChORkRBcHA6IHVpbnQ2NCkgLT4gdWludDY0Ogppc05GRDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjIxCiAgICAvLyBwcml2YXRlIGlzTkZEKE5GREFwcDogQXBwbGljYXRpb24pOiBib29sZWFuIHsKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MjIKICAgIC8vIGNvbnN0IG5mZE5hbWVCeXRlcyA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKE5GREFwcCwgQnl0ZXMoTkZER2xvYmFsU3RhdGVLZXlzTmFtZSkpWzBdCiAgICBmcmFtZV9kaWcgLTEKICAgIHB1c2hieXRlcyAiaS5uYW1lIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MjQtMjcKICAgIC8vIHJldHVybiBhYmlDYWxsPHR5cGVvZiBORkRSZWdpc3RyeS5wcm90b3R5cGUuaXNWYWxpZE5mZEFwcElkPih7CiAgICAvLyAgIGFwcElkOiB0aGlzLnJlZ2lzdHJ5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbU3RyaW5nKG5mZE5hbWVCeXRlcyksIE5GREFwcC5pZF0KICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoyNQogICAgLy8gYXBwSWQ6IHRoaXMucmVnaXN0cnkudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MTcKICAgIC8vIHJlZ2lzdHJ5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBORkRQbHVnaW5HbG9iYWxTdGF0ZUtleVJlZ2lzdHJ5IH0pCiAgICBieXRlY18xIC8vICJuZmRfcmVnaXN0cnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9uZmQvY29udHJhY3QuYWxnby50czoyNQogICAgLy8gYXBwSWQ6IHRoaXMucmVnaXN0cnkudmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvbmZkL2NvbnRyYWN0LmFsZ28udHM6MjYKICAgIC8vIGFyZ3M6IFtTdHJpbmcobmZkTmFtZUJ5dGVzKSwgTkZEQXBwLmlkXQogICAgZGlnIDEKICAgIGxlbgogICAgaXRvYgogICAgZXh0cmFjdCA2IDIKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL25mZC9jb250cmFjdC5hbGdvLnRzOjI0LTI3CiAgICAvLyByZXR1cm4gYWJpQ2FsbDx0eXBlb2YgTkZEUmVnaXN0cnkucHJvdG90eXBlLmlzVmFsaWROZmRBcHBJZD4oewogICAgLy8gICBhcHBJZDogdGhpcy5yZWdpc3RyeS52YWx1ZSwKICAgIC8vICAgYXJnczogW1N0cmluZyhuZmROYW1lQnl0ZXMpLCBORkRBcHAuaWRdCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgcHVzaGJ5dGVzIDB4NGJlMjJmYzYgLy8gbWV0aG9kICJpc1ZhbGlkTmZkQXBwSWQoc3RyaW5nLHVpbnQ2NClib29sIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMiAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHJldHN1Ygo=", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyAEAAgBBiYDEHNwZW5kaW5nX2FkZHJlc3MMbmZkX3JlZ2lzdHJ5BBUffHUxGRREMRhBAGqCDgQNhOekBIIM1KYEe3AyoAT6yuA1BB+FbtIEI9zubASjj4yoBD8beukE0bmCQwRE/K5fBHiG3CoEU3XyQwSjcQqJBERhP1g2GgCODgAuAHsAyAEmAWwBzwI5ApAC4gM/A5ED6gR6BQoAgAQkDS9nNhoAjgEAEgCKAgGL/kAAAzIDiYv/cghEiTYaAUkVIxJEFylMZyRDNhoBSRUjEkQXNhoCSRUkEkQiUzYaA0kVIxJEFzYaBEsDKGVITgNLAYgFFUSxTwJPBIj/rYAEUTLfdbIasiCyGrIYsgAlshAisgGzJEM2GgFJFSMSRBc2GgJJFSQSRCJTNhoDSRUjEkQXNhoESwMoZUhOA0sBiATIRLFPAk8EiP9ggAR49CcRshqyILIashiyACWyECKyAbMkQzYaAUkVIxJEFzYaAkkVJBJEIlM2GgNJFSMSRBc2GgRJFSMSRDYaBUkVgSASREsEKGVITEsDiARuRLFPBE8FiP8GgARQdtnKshpPA7IasiCyGrIAshglshAisgGzJEM2GgFJFSMSRBc2GgJJFSQSRCJTNhoDSRUjEkQXSwIoZUhOAkmIBCFEsUxPA4j+uoAEmfXVDbIasiCyGLIAJbIQIrIBsyRDNhoBSRUjEkQXNhoCSRUkEkQiUzYaA0kVIxJEFzYaBEkVIxJENhoFSSJZgQIISwEVEkRLBChlSExLA4gDxUSxTwRPBYj+XYAEkTES77IaTwOyGrIgshqyALIYJbIQIrIBsyRDNhoBSRUjEkQXNhoCSRUkEkQiUzYaA0kVIxJEF0sCKGVITEmIA3lESYAJaS5zYWxlYW10ZUSxSwFyCERMF7IIsgdLAbIAJLIQIrIBtk8CTwOI/e2ABKOSroKyGrIgshiyACWyECKyAbMkQzYaAUkVIxJEFzYaAkkVJBJEIlM2GgNJFSMSRBc2GgRJIlmBAghLARUSREsDKGVITEsCiAMARLFPA08EiP2YgAR2LoLashqyILIasgCyGCWyECKyAbMkQzYaAUkVIxJEFzYaAkkVJBJEIlM2GgNJFSMSRBc2GgRJFSQSREsDKGVITgJLAYgCrkSxTwNPBIj9RoAEjrwsg7IasiCyGrIYsgAlshAisgGzJEM2GgFJFSMSRBc2GgJJFSQSRCJTNhoDSRUjEkQXNhoESRUkEkQ2GgVJFSMSREsEKGVITEsDiAJVRLFPBE8FiPztgATNU1imshpPA7IasiCyGrIAshglshAisgGzJEM2GgFJFSMSRBc2GgJJFSQSRCJTNhoDSRUjEkQXNhoESRUkEkRLAyhlSE4CSwGIAf9EsU8DTwSI/JeABDplfXeyGrIgshqyGLIAJbIQIrIBsyRDNhoBSRUjEkQXNhoCSRUkEkQiUzYaA0kVIxJEFzYaBEkiWSMLgQIISwEVEkRLAyhlSExLAogBpkSxTwNPBIj8PoAEQT0VI7IasiCyGrIAshglshAisgGzJEM2GgFJFSMSRBc2GgJJFSQSRCJTNhoDSRUjEkQXNhoESRUjEkQ2GgVJFYEgEkQ2GgZJIlmBAghLARUSRDYaB0kVIxJENhoISSJZIwuBAghLARUSREsHKGVITEsGiAEmRLFPB08IiPu+gARmghwashpPBrIaTwWyGk8EshpPA7IasiCyGrIAshglshAisgGzJEM2GgFJFSMSRBc2GgJJFSQSRCJTNhoDSRUjEkQXNhoESRUjEkQXSwMoZUhLAogAxUSxgARQ9JDCshpLArIYSbIAJbIQIrIBs7Q+SVcEAExXAAQqEkRJFSMSRBexSwNyCERMTwMLsgiyB0myACSyECKyAbZPAk8DiPscgAR3/Vt0shqyILIAshglshAisgGzJEM2GgFJFSMSRBc2GgJJFSQSRCJTNhoDSRUjEkQXNhoESSJZgQIISwEVEkQ2GgVJFYEgEkRLBChlSExLA4gAJkSxTwRPBYj6voAEl7bYbLIaTwOyGrIgshqyALIYJbIQIrIBsyRDigEBi/+ABmkubmFtZWVIsSIpZURLARUWVwYCTwJQi/8WgARL4i/GshpMshqyGrIYJbIQIrIBs7Q+SVcEAExXAAQqEkRJFSQSRCJTiQ==", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var NfdPluginParamsFactory = class _NfdPluginParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "create":
          case "create(uint64)void":
            return _NfdPluginParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs create ABI call params for the NFDPlugin smart contract using the create(uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params) {
        return {
          ...params,
          method: "create(uint64)void",
          args: Array.isArray(params.args) ? params.args : [params.args.registry]
        };
      }
    };
  }
  /**
   * Constructs a no op call for the deleteFields(uint64,bool,uint64,byte[][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static deleteFields(params) {
    return {
      ...params,
      method: "deleteFields(uint64,bool,uint64,byte[][])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.fieldNames]
    };
  }
  /**
   * Constructs a no op call for the updateFields(uint64,bool,uint64,byte[][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateFields(params) {
    return {
      ...params,
      method: "updateFields(uint64,bool,uint64,byte[][])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.fieldAndVals]
    };
  }
  /**
   * Constructs a no op call for the offerForSale(uint64,bool,uint64,uint64,address)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static offerForSale(params) {
    return {
      ...params,
      method: "offerForSale(uint64,bool,uint64,uint64,address)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.sellAmount, params.args.reservedFor]
    };
  }
  /**
   * Constructs a no op call for the cancelSale(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static cancelSale(params) {
    return {
      ...params,
      method: "cancelSale(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId]
    };
  }
  /**
   * Constructs a no op call for the postOffer(uint64,bool,uint64,uint64,string)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static postOffer(params) {
    return {
      ...params,
      method: "postOffer(uint64,bool,uint64,uint64,string)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.offer, params.args.note]
    };
  }
  /**
   * Constructs a no op call for the purchase(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static purchase(params) {
    return {
      ...params,
      method: "purchase(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId]
    };
  }
  /**
   * Constructs a no op call for the updateHash(uint64,bool,uint64,byte[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateHash(params) {
    return {
      ...params,
      method: "updateHash(uint64,bool,uint64,byte[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.hash]
    };
  }
  /**
   * Constructs a no op call for the contractLock(uint64,bool,uint64,bool)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static contractLock(params) {
    return {
      ...params,
      method: "contractLock(uint64,bool,uint64,bool)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.lock]
    };
  }
  /**
   * Constructs a no op call for the segmentLock(uint64,bool,uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static segmentLock(params) {
    return {
      ...params,
      method: "segmentLock(uint64,bool,uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.lock, params.args.usdPrice]
    };
  }
  /**
   * Constructs a no op call for the vaultOptInLock(uint64,bool,uint64,bool)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static vaultOptInLock(params) {
    return {
      ...params,
      method: "vaultOptInLock(uint64,bool,uint64,bool)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.lock]
    };
  }
  /**
   * Constructs a no op call for the vaultOptIn(uint64,bool,uint64,uint64[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static vaultOptIn(params) {
    return {
      ...params,
      method: "vaultOptIn(uint64,bool,uint64,uint64[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.assets]
    };
  }
  /**
   * Constructs a no op call for the vaultSend(uint64,bool,uint64,uint64,address,string,uint64,uint64[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static vaultSend(params) {
    return {
      ...params,
      method: "vaultSend(uint64,bool,uint64,uint64,address,string,uint64,uint64[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.amount, params.args.receiver, params.args.note, params.args.asset, params.args.otherAssets]
    };
  }
  /**
   * Constructs a no op call for the renew(uint64,bool,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static renew(params) {
    return {
      ...params,
      method: "renew(uint64,bool,uint64,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.years]
    };
  }
  /**
   * Constructs a no op call for the setPrimaryAddress(uint64,bool,uint64,string,address)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setPrimaryAddress(params) {
    return {
      ...params,
      method: "setPrimaryAddress(uint64,bool,uint64,string,address)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.fieldName, params.args.address]
    };
  }
};
var NfdPluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `NfdPluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory14({
      ...params,
      appSpec: APP_SPEC14
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC14;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new NfdPluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new NfdPluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the NFDPlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    var _a;
    const result = await this.appFactory.deploy({
      ...params,
      createParams: ((_a = params.createParams) == null ? void 0 : _a.method) ? NfdPluginParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams : void 0
    });
    return { result: result.result, appClient: new NfdPluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the NFDPlugin smart contract using the create(uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params) => {
        return this.appFactory.params.create(NfdPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the NFDPlugin smart contract using the create(uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params) => {
        return this.appFactory.createTransaction.create(NfdPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the NFDPlugin smart contract using an ABI method call using the create(uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params) => {
        const result = await this.appFactory.send.create(NfdPluginParamsFactory.create.create(params));
        return { result: { ...result.result, return: result.result.return }, appClient: new NfdPluginClient(result.appClient) };
      }
    }
  };
};
var NfdPluginClient = class _NfdPluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient14 ? appClientOrParams : new _AppClient14({
      ...appClientOrParams,
      appSpec: APP_SPEC14
    });
  }
  /**
   * Returns a new `NfdPluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _NfdPluginClient(await _AppClient14.fromCreatorAndName({ ...params, appSpec: APP_SPEC14 }));
  }
  /**
   * Returns an `NfdPluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _NfdPluginClient(await _AppClient14.fromNetwork({ ...params, appSpec: APP_SPEC14 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the NFDPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `deleteFields(uint64,bool,uint64,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    deleteFields: (params) => {
      return this.appClient.params.call(NfdPluginParamsFactory.deleteFields(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `updateFields(uint64,bool,uint64,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateFields: (params) => {
      return this.appClient.params.call(NfdPluginParamsFactory.updateFields(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `offerForSale(uint64,bool,uint64,uint64,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    offerForSale: (params) => {
      return this.appClient.params.call(NfdPluginParamsFactory.offerForSale(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `cancelSale(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    cancelSale: (params) => {
      return this.appClient.params.call(NfdPluginParamsFactory.cancelSale(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `postOffer(uint64,bool,uint64,uint64,string)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    postOffer: (params) => {
      return this.appClient.params.call(NfdPluginParamsFactory.postOffer(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `purchase(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    purchase: (params) => {
      return this.appClient.params.call(NfdPluginParamsFactory.purchase(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `updateHash(uint64,bool,uint64,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateHash: (params) => {
      return this.appClient.params.call(NfdPluginParamsFactory.updateHash(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `contractLock(uint64,bool,uint64,bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    contractLock: (params) => {
      return this.appClient.params.call(NfdPluginParamsFactory.contractLock(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `segmentLock(uint64,bool,uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    segmentLock: (params) => {
      return this.appClient.params.call(NfdPluginParamsFactory.segmentLock(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `vaultOptInLock(uint64,bool,uint64,bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    vaultOptInLock: (params) => {
      return this.appClient.params.call(NfdPluginParamsFactory.vaultOptInLock(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `vaultOptIn(uint64,bool,uint64,uint64[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    vaultOptIn: (params) => {
      return this.appClient.params.call(NfdPluginParamsFactory.vaultOptIn(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `vaultSend(uint64,bool,uint64,uint64,address,string,uint64,uint64[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    vaultSend: (params) => {
      return this.appClient.params.call(NfdPluginParamsFactory.vaultSend(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `renew(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    renew: (params) => {
      return this.appClient.params.call(NfdPluginParamsFactory.renew(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `setPrimaryAddress(uint64,bool,uint64,string,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setPrimaryAddress: (params) => {
      return this.appClient.params.call(NfdPluginParamsFactory.setPrimaryAddress(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the NFDPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `deleteFields(uint64,bool,uint64,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    deleteFields: (params) => {
      return this.appClient.createTransaction.call(NfdPluginParamsFactory.deleteFields(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `updateFields(uint64,bool,uint64,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateFields: (params) => {
      return this.appClient.createTransaction.call(NfdPluginParamsFactory.updateFields(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `offerForSale(uint64,bool,uint64,uint64,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    offerForSale: (params) => {
      return this.appClient.createTransaction.call(NfdPluginParamsFactory.offerForSale(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `cancelSale(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    cancelSale: (params) => {
      return this.appClient.createTransaction.call(NfdPluginParamsFactory.cancelSale(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `postOffer(uint64,bool,uint64,uint64,string)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    postOffer: (params) => {
      return this.appClient.createTransaction.call(NfdPluginParamsFactory.postOffer(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `purchase(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    purchase: (params) => {
      return this.appClient.createTransaction.call(NfdPluginParamsFactory.purchase(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `updateHash(uint64,bool,uint64,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateHash: (params) => {
      return this.appClient.createTransaction.call(NfdPluginParamsFactory.updateHash(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `contractLock(uint64,bool,uint64,bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    contractLock: (params) => {
      return this.appClient.createTransaction.call(NfdPluginParamsFactory.contractLock(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `segmentLock(uint64,bool,uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    segmentLock: (params) => {
      return this.appClient.createTransaction.call(NfdPluginParamsFactory.segmentLock(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `vaultOptInLock(uint64,bool,uint64,bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    vaultOptInLock: (params) => {
      return this.appClient.createTransaction.call(NfdPluginParamsFactory.vaultOptInLock(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `vaultOptIn(uint64,bool,uint64,uint64[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    vaultOptIn: (params) => {
      return this.appClient.createTransaction.call(NfdPluginParamsFactory.vaultOptIn(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `vaultSend(uint64,bool,uint64,uint64,address,string,uint64,uint64[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    vaultSend: (params) => {
      return this.appClient.createTransaction.call(NfdPluginParamsFactory.vaultSend(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `renew(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    renew: (params) => {
      return this.appClient.createTransaction.call(NfdPluginParamsFactory.renew(params));
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `setPrimaryAddress(uint64,bool,uint64,string,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setPrimaryAddress: (params) => {
      return this.appClient.createTransaction.call(NfdPluginParamsFactory.setPrimaryAddress(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the NFDPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `deleteFields(uint64,bool,uint64,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    deleteFields: async (params) => {
      const result = await this.appClient.send.call(NfdPluginParamsFactory.deleteFields(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `updateFields(uint64,bool,uint64,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateFields: async (params) => {
      const result = await this.appClient.send.call(NfdPluginParamsFactory.updateFields(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `offerForSale(uint64,bool,uint64,uint64,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    offerForSale: async (params) => {
      const result = await this.appClient.send.call(NfdPluginParamsFactory.offerForSale(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `cancelSale(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    cancelSale: async (params) => {
      const result = await this.appClient.send.call(NfdPluginParamsFactory.cancelSale(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `postOffer(uint64,bool,uint64,uint64,string)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    postOffer: async (params) => {
      const result = await this.appClient.send.call(NfdPluginParamsFactory.postOffer(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `purchase(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    purchase: async (params) => {
      const result = await this.appClient.send.call(NfdPluginParamsFactory.purchase(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `updateHash(uint64,bool,uint64,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateHash: async (params) => {
      const result = await this.appClient.send.call(NfdPluginParamsFactory.updateHash(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `contractLock(uint64,bool,uint64,bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    contractLock: async (params) => {
      const result = await this.appClient.send.call(NfdPluginParamsFactory.contractLock(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `segmentLock(uint64,bool,uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    segmentLock: async (params) => {
      const result = await this.appClient.send.call(NfdPluginParamsFactory.segmentLock(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `vaultOptInLock(uint64,bool,uint64,bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    vaultOptInLock: async (params) => {
      const result = await this.appClient.send.call(NfdPluginParamsFactory.vaultOptInLock(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `vaultOptIn(uint64,bool,uint64,uint64[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    vaultOptIn: async (params) => {
      const result = await this.appClient.send.call(NfdPluginParamsFactory.vaultOptIn(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `vaultSend(uint64,bool,uint64,uint64,address,string,uint64,uint64[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    vaultSend: async (params) => {
      const result = await this.appClient.send.call(NfdPluginParamsFactory.vaultSend(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `renew(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    renew: async (params) => {
      const result = await this.appClient.send.call(NfdPluginParamsFactory.renew(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the NFDPlugin smart contract using the `setPrimaryAddress(uint64,bool,uint64,string,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setPrimaryAddress: async (params) => {
      const result = await this.appClient.send.call(NfdPluginParamsFactory.setPrimaryAddress(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _NfdPluginClient(this.appClient.clone(params));
  }
  /**
   * Methods to access state for the current NFDPlugin app
   */
  state = {
    /**
     * Methods to access global state for the current NFDPlugin app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async () => {
        const result = await this.appClient.state.global.getAll();
        return {
          registry: result.registry
        };
      },
      /**
       * Get the current value of the registry key in global state
       */
      registry: async () => {
        return await this.appClient.state.global.getValue("registry");
      }
    }
  };
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a deleteFields(uint64,bool,uint64,byte[][])void method call against the NFDPlugin contract
       */
      deleteFields(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.deleteFields(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a updateFields(uint64,bool,uint64,byte[][])void method call against the NFDPlugin contract
       */
      updateFields(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateFields(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a offerForSale(uint64,bool,uint64,uint64,address)void method call against the NFDPlugin contract
       */
      offerForSale(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.offerForSale(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a cancelSale(uint64,bool,uint64)void method call against the NFDPlugin contract
       */
      cancelSale(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.cancelSale(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a postOffer(uint64,bool,uint64,uint64,string)void method call against the NFDPlugin contract
       */
      postOffer(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.postOffer(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a purchase(uint64,bool,uint64)void method call against the NFDPlugin contract
       */
      purchase(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.purchase(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a updateHash(uint64,bool,uint64,byte[])void method call against the NFDPlugin contract
       */
      updateHash(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateHash(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a contractLock(uint64,bool,uint64,bool)void method call against the NFDPlugin contract
       */
      contractLock(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.contractLock(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a segmentLock(uint64,bool,uint64,bool,uint64)void method call against the NFDPlugin contract
       */
      segmentLock(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.segmentLock(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a vaultOptInLock(uint64,bool,uint64,bool)void method call against the NFDPlugin contract
       */
      vaultOptInLock(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.vaultOptInLock(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a vaultOptIn(uint64,bool,uint64,uint64[])void method call against the NFDPlugin contract
       */
      vaultOptIn(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.vaultOptIn(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a vaultSend(uint64,bool,uint64,uint64,address,string,uint64,uint64[])void method call against the NFDPlugin contract
       */
      vaultSend(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.vaultSend(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a renew(uint64,bool,uint64,uint64)void method call against the NFDPlugin contract
       */
      renew(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.renew(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a setPrimaryAddress(uint64,bool,uint64,string,address)void method call against the NFDPlugin contract
       */
      setPrimaryAddress(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.setPrimaryAddress(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a clear state call to the NFDPlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/nfd.ts
var NFDPluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: NfdPluginFactory, ...params });
  }
  deleteFields(args) {
    const methodName = "deleteFields";
    if (args === void 0) {
      return (_spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (_spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.deleteFields({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  updateFields(args) {
    const methodName = "updateFields";
    if (args === void 0) {
      return (_spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (_spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.updateFields({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  offerForSale(args) {
    const methodName = "offerForSale";
    if (args === void 0) {
      return (_spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (_spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.offerForSale({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  cancelSale(args) {
    const methodName = "cancelSale";
    if (args === void 0) {
      return (_spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (_spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.cancelSale({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  postOffer(args) {
    const methodName = "postOffer";
    if (args === void 0) {
      return (_spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (_spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.postOffer({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  purchase(args) {
    const methodName = "purchase";
    if (args === void 0) {
      return (_spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (_spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.purchase({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  updateHash(args) {
    const methodName = "updateHash";
    if (args === void 0) {
      return (_spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (_spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.updateHash({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  contractLock(args) {
    const methodName = "contractLock";
    if (args === void 0) {
      return (_spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (_spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.contractLock({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  segmentLock(args) {
    const methodName = "segmentLock";
    if (args === void 0) {
      return (_spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (_spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.segmentLock({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  vaultOptInLock(args) {
    const methodName = "vaultOptInLock";
    if (args === void 0) {
      return (_spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (_spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.vaultOptInLock({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  vaultOptIn(args) {
    const methodName = "vaultOptIn";
    if (args === void 0) {
      return (_spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (_spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.vaultOptIn({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  vaultSend(args) {
    const methodName = "vaultSend";
    if (args === void 0) {
      return (_spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (_spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.vaultSend({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  renew(args) {
    const methodName = "renew";
    if (args === void 0) {
      return (_spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (_spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.renew({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  setPrimaryAddress(args) {
    const methodName = "setPrimaryAddress";
    if (args === void 0) {
      return (_spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (_spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.setPrimaryAddress({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
};

// src/generated/PaySiloPluginClient.ts
import {
  AppClient as _AppClient15
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory15 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC15 = { "name": "PaySiloPlugin", "structs": {}, "methods": [{ "name": "create", "args": [{ "type": "address", "name": "recipient" }], "returns": { "type": "void" }, "actions": { "create": ["NoOp"], "call": [] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "pay", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "(uint64,uint64)[]", "name": "payments" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 0, "bytes": 1 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": { "recipient": { "keyType": "AVMString", "valueType": "address", "key": "cmVjaXBpZW50" } }, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": [], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [22], "errorMessage": "OnCompletion must be NoOp" }, { "pc": [71], "errorMessage": "application exists" }, { "pc": [195, 254], "errorMessage": "check GlobalState exists" }, { "pc": [172], "errorMessage": "index access is out of bounds" }, { "pc": [133], "errorMessage": "invalid number of bytes for (len+(uint64,uint64)[])" }, { "pc": [109], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [99], "errorMessage": "invalid number of bytes for uint64" }, { "pc": [81], "errorMessage": "invalid number of bytes for uint8[32]" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDE2IDgKICAgIGJ5dGVjYmxvY2sgInJlY2lwaWVudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS1zaWxvL2NvbnRyYWN0LmFsZ28udHM6NwogICAgLy8gZXhwb3J0IGNsYXNzIFBheVNpbG9QbHVnaW4gZXh0ZW5kcyBDb250cmFjdCB7CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIG11c3QgYmUgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGJ6IG1haW5fY3JlYXRlX05vT3BANQogICAgcHVzaGJ5dGVzIDB4ZTA0NzUyNjIgLy8gbWV0aG9kICJwYXkodWludDY0LGJvb2wsKHVpbnQ2NCx1aW50NjQpW10pdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIHBheQogICAgZXJyCgptYWluX2NyZWF0ZV9Ob09wQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXktc2lsby9jb250cmFjdC5hbGdvLnRzOjcKICAgIC8vIGV4cG9ydCBjbGFzcyBQYXlTaWxvUGx1Z2luIGV4dGVuZHMgQ29udHJhY3QgewogICAgcHVzaGJ5dGVzIDB4Y2M2OTRlYWEgLy8gbWV0aG9kICJjcmVhdGUoYWRkcmVzcyl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggY3JlYXRlCiAgICBlcnIKCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjpyZWtleUFkZHJlc3MocmVrZXlCYWNrOiB1aW50NjQsIHdhbGxldDogdWludDY0KSAtPiBieXRlczoKcmVrZXlBZGRyZXNzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjEKICAgIC8vIGV4cG9ydCBmdW5jdGlvbiByZWtleUFkZHJlc3MocmVrZXlCYWNrOiBib29sZWFuLCB3YWxsZXQ6IEFwcGxpY2F0aW9uKTogQWNjb3VudCB7CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzIyCiAgICAvLyBpZiAoIXJla2V5QmFjaykgewogICAgZnJhbWVfZGlnIC0yCiAgICBibnogcmVrZXlBZGRyZXNzX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjMKICAgIC8vIHJldHVybiBHbG9iYWwuemVyb0FkZHJlc3MKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgcmV0c3ViCgpyZWtleUFkZHJlc3NfYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjYKICAgIC8vIHJldHVybiB3YWxsZXQuYWRkcmVzcwogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXktc2lsby9jb250cmFjdC5hbGdvLnRzOjpQYXlTaWxvUGx1Z2luLmNyZWF0ZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmNyZWF0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS1zaWxvL2NvbnRyYWN0LmFsZ28udHM6MTEKICAgIC8vIEBhYmltZXRob2QoeyBvbkNyZWF0ZTogJ3JlcXVpcmUnIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXktc2lsby9jb250cmFjdC5hbGdvLnRzOjkKICAgIC8vIHJlY2lwaWVudCA9IEdsb2JhbFN0YXRlPEFjY291bnQ+KHsga2V5OiBQYXlTaWxvUGx1Z2luR2xvYmFsU3RhdGVLZXlSZWNpcGllbnQgfSkKICAgIGJ5dGVjXzAgLy8gInJlY2lwaWVudCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS1zaWxvL2NvbnRyYWN0LmFsZ28udHM6MTMKICAgIC8vIHRoaXMucmVjaXBpZW50LnZhbHVlID0gcmVjaXBpZW50CiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcGF5LXNpbG8vY29udHJhY3QuYWxnby50czoxMQogICAgLy8gQGFiaW1ldGhvZCh7IG9uQ3JlYXRlOiAncmVxdWlyZScgfSkKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXktc2lsby9jb250cmFjdC5hbGdvLnRzOjpQYXlTaWxvUGx1Z2luLnBheVtyb3V0aW5nXSgpIC0+IHZvaWQ6CnBheToKICAgIGludGNfMCAvLyAwCiAgICBkdXAKICAgIHB1c2hieXRlcyAiIgogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXktc2lsby9jb250cmFjdC5hbGdvLnRzOjE2CiAgICAvLyBwYXkod2FsbGV0OiBBcHBsaWNhdGlvbiwgcmVrZXlCYWNrOiBib29sZWFuLCBwYXltZW50czogUGF5U2lsb1BhcmFtc1tdKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGludGNfMiAvLyAxNgogICAgKgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIHN3YXAKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbisodWludDY0LHVpbnQ2NClbXSkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBwdXNoYnl0ZXMgInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXktc2lsby9jb250cmFjdC5hbGdvLnRzOjE5CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgcGF5bWVudHMubGVuZ3RoOyBpKyspIHsKICAgIGludGNfMCAvLyAwCgpwYXlfd2hpbGVfdG9wQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXktc2lsby9jb250cmFjdC5hbGdvLnRzOjE5CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgcGF5bWVudHMubGVuZ3RoOyBpKyspIHsKICAgIGR1cAogICAgZGlnIDMKICAgIDwKICAgIGJ6IHBheV9hZnRlcl93aGlsZUAxNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcGF5LXNpbG8vY29udHJhY3QuYWxnby50czoyMAogICAgLy8gY29uc3QgeyBhc3NldCwgYW1vdW50IH0gPSBwYXltZW50c1tpXTsKICAgIGRpZyAzCiAgICBleHRyYWN0IDIgMAogICAgZGlnIDEKICAgIGludGNfMiAvLyAxNgogICAgKgogICAgaW50Y18yIC8vIDE2CiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogaW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGJ1cnkgOQogICAgaW50Y18zIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICBidXJ5IDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS1zaWxvL2NvbnRyYWN0LmFsZ28udHM6MjIKICAgIC8vIGlmIChhc3NldCA9PT0gMCkgewogICAgYm56IHBheV9lbHNlX2JvZHlAOQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcGF5LXNpbG8vY29udHJhY3QuYWxnby50czoyMy0zMAogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyLAogICAgLy8gICAgIHJlY2VpdmVyOiB0aGlzLnJlY2lwaWVudC52YWx1ZSwKICAgIC8vICAgICBhbW91bnQsCiAgICAvLyAgICAgcmVrZXlUbzogaSA8IChwYXltZW50cy5sZW5ndGggLSAxKSA/IEdsb2JhbC56ZXJvQWRkcmVzcyA6IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcGF5LXNpbG8vY29udHJhY3QuYWxnby50czoyNgogICAgLy8gcmVjZWl2ZXI6IHRoaXMucmVjaXBpZW50LnZhbHVlLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS1zaWxvL2NvbnRyYWN0LmFsZ28udHM6OQogICAgLy8gcmVjaXBpZW50ID0gR2xvYmFsU3RhdGU8QWNjb3VudD4oeyBrZXk6IFBheVNpbG9QbHVnaW5HbG9iYWxTdGF0ZUtleVJlY2lwaWVudCB9KQogICAgYnl0ZWNfMCAvLyAicmVjaXBpZW50IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcGF5LXNpbG8vY29udHJhY3QuYWxnby50czoyNgogICAgLy8gcmVjZWl2ZXI6IHRoaXMucmVjaXBpZW50LnZhbHVlLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHN3YXAKICAgIGJ1cnkgMTEKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS1zaWxvL2NvbnRyYWN0LmFsZ28udHM6MjgKICAgIC8vIHJla2V5VG86IGkgPCAocGF5bWVudHMubGVuZ3RoIC0gMSkgPyBHbG9iYWwuemVyb0FkZHJlc3MgOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgZGlnIDIKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkaWcgMQogICAgPgogICAgYnogcGF5X3Rlcm5hcnlfZmFsc2VANgogICAgZ2xvYmFsIFplcm9BZGRyZXNzCgpwYXlfdGVybmFyeV9tZXJnZUA3OgogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBkaWcgNwogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGRpZyA5CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS1zaWxvL2NvbnRyYWN0LmFsZ28udHM6MjMtMjkKICAgIC8vIGl0eG4KICAgIC8vICAgLnBheW1lbnQoewogICAgLy8gICAgIHNlbmRlciwKICAgIC8vICAgICByZWNlaXZlcjogdGhpcy5yZWNpcGllbnQudmFsdWUsCiAgICAvLyAgICAgYW1vdW50LAogICAgLy8gICAgIHJla2V5VG86IGkgPCAocGF5bWVudHMubGVuZ3RoIC0gMSkgPyBHbG9iYWwuemVyb0FkZHJlc3MgOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gICB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcGF5LXNpbG8vY29udHJhY3QuYWxnby50czoyMy0zMAogICAgLy8gaXR4bgogICAgLy8gICAucGF5bWVudCh7CiAgICAvLyAgICAgc2VuZGVyLAogICAgLy8gICAgIHJlY2VpdmVyOiB0aGlzLnJlY2lwaWVudC52YWx1ZSwKICAgIC8vICAgICBhbW91bnQsCiAgICAvLyAgICAgcmVrZXlUbzogaSA8IChwYXltZW50cy5sZW5ndGggLSAxKSA/IEdsb2JhbC56ZXJvQWRkcmVzcyA6IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCnBheV9hZnRlcl9pZl9lbHNlQDE0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcGF5LXNpbG8vY29udHJhY3QuYWxnby50czoxOQogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IHBheW1lbnRzLmxlbmd0aDsgaSsrKSB7CiAgICBkdXAKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBidXJ5IDEKICAgIGIgcGF5X3doaWxlX3RvcEAyCgpwYXlfdGVybmFyeV9mYWxzZUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcGF5LXNpbG8vY29udHJhY3QuYWxnby50czoyOAogICAgLy8gcmVrZXlUbzogaSA8IChwYXltZW50cy5sZW5ndGggLSAxKSA/IEdsb2JhbC56ZXJvQWRkcmVzcyA6IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICBkaWcgNAogICAgZGlnIDYKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICBiIHBheV90ZXJuYXJ5X21lcmdlQDcKCnBheV9lbHNlX2JvZHlAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS1zaWxvL2NvbnRyYWN0LmFsZ28udHM6MzItNDAKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIHNlbmRlciwKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLnJlY2lwaWVudC52YWx1ZSwKICAgIC8vICAgICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgICAgcmVrZXlUbzogaSA8IChwYXltZW50cy5sZW5ndGggLSAxKSA/IEdsb2JhbC56ZXJvQWRkcmVzcyA6IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyAgIH0pCiAgICAvLyAgIC5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcGF5LXNpbG8vY29udHJhY3QuYWxnby50czozNQogICAgLy8gYXNzZXRSZWNlaXZlcjogdGhpcy5yZWNpcGllbnQudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcGF5LXNpbG8vY29udHJhY3QuYWxnby50czo5CiAgICAvLyByZWNpcGllbnQgPSBHbG9iYWxTdGF0ZTxBY2NvdW50Pih7IGtleTogUGF5U2lsb1BsdWdpbkdsb2JhbFN0YXRlS2V5UmVjaXBpZW50IH0pCiAgICBieXRlY18wIC8vICJyZWNpcGllbnQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXktc2lsby9jb250cmFjdC5hbGdvLnRzOjM1CiAgICAvLyBhc3NldFJlY2VpdmVyOiB0aGlzLnJlY2lwaWVudC52YWx1ZSwKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBidXJ5IDEwCiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXktc2lsby9jb250cmFjdC5hbGdvLnRzOjM4CiAgICAvLyByZWtleVRvOiBpIDwgKHBheW1lbnRzLmxlbmd0aCAtIDEpID8gR2xvYmFsLnplcm9BZGRyZXNzIDogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIGRpZyAyCiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZGlnIDEKICAgID4KICAgIGJ6IHBheV90ZXJuYXJ5X2ZhbHNlQDExCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKCnBheV90ZXJuYXJ5X21lcmdlQDEyOgogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBkaWcgNgogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIGRpZyA3CiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBkaWcgOAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS1zaWxvL2NvbnRyYWN0LmFsZ28udHM6MzItMzkKICAgIC8vIGl0eG4KICAgIC8vICAgLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgIHNlbmRlciwKICAgIC8vICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLnJlY2lwaWVudC52YWx1ZSwKICAgIC8vICAgICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgICAgcmVrZXlUbzogaSA8IChwYXltZW50cy5sZW5ndGggLSAxKSA/IEdsb2JhbC56ZXJvQWRkcmVzcyA6IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyAgIH0pCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXktc2lsby9jb250cmFjdC5hbGdvLnRzOjMyLTQwCiAgICAvLyBpdHhuCiAgICAvLyAgIC5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICBzZW5kZXIsCiAgICAvLyAgICAgYXNzZXRSZWNlaXZlcjogdGhpcy5yZWNpcGllbnQudmFsdWUsCiAgICAvLyAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICAgIHJla2V5VG86IGkgPCAocGF5bWVudHMubGVuZ3RoIC0gMSkgPyBHbG9iYWwuemVyb0FkZHJlc3MgOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gICB9KQogICAgLy8gICAuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICBiIHBheV9hZnRlcl9pZl9lbHNlQDE0CgpwYXlfdGVybmFyeV9mYWxzZUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS1zaWxvL2NvbnRyYWN0LmFsZ28udHM6MzgKICAgIC8vIHJla2V5VG86IGkgPCAocGF5bWVudHMubGVuZ3RoIC0gMSkgPyBHbG9iYWwuemVyb0FkZHJlc3MgOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgZGlnIDQKICAgIGRpZyA2CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgYiBwYXlfdGVybmFyeV9tZXJnZUAxMgoKcGF5X2FmdGVyX3doaWxlQDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcGF5LXNpbG8vY29udHJhY3QuYWxnby50czoxNgogICAgLy8gcGF5KHdhbGxldDogQXBwbGljYXRpb24sIHJla2V5QmFjazogYm9vbGVhbiwgcGF5bWVudHM6IFBheVNpbG9QYXJhbXNbXSk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgo=", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyAEAAEQCCYBCXJlY2lwaWVudDEZFEQxGEEADoAE4EdSYjYaAI4BAC4AgATMaU6qNhoAjgEAEgCKAgGL/kAAAzIDiYv/cghEiTYaAUkVgSASRChMZyNDIkmAAEk2GgFJFSUSRBdJNhoCSRUjEkQiU0w2GgNJTgJJIllJTgMkC4ECCEwVEkSAEHNwZW5kaW5nX2FkZHJlc3NlSCJJSwMMQQCQSwNXAgBLASQLJFhJIltJTgJFCSVbRQlAADuxIihlTEULREsCIwlLAQ1BAB8yA7IgSweyCEsJsgdLAbIAI7IQIrIBs0kjCEUBQv+uSwRLBoj/REL/2bEiKGVMRQpESwIjCUsBDUEAHzIDsiBLBrIRSweyEksIshRLAbIAgQSyECKyAbNC/71LBEsGiP8JQv/ZI0M=", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var PaySiloPluginParamsFactory = class _PaySiloPluginParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "create":
          case "create(address)void":
            return _PaySiloPluginParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs create ABI call params for the PaySiloPlugin smart contract using the create(address)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params) {
        return {
          ...params,
          method: "create(address)void",
          args: Array.isArray(params.args) ? params.args : [params.args.recipient]
        };
      }
    };
  }
  /**
   * Constructs a no op call for the pay(uint64,bool,(uint64,uint64)[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static pay(params) {
    return {
      ...params,
      method: "pay(uint64,bool,(uint64,uint64)[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.payments]
    };
  }
};
var PaySiloPluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `PaySiloPluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory15({
      ...params,
      appSpec: APP_SPEC15
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC15;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new PaySiloPluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new PaySiloPluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the PaySiloPlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    var _a;
    const result = await this.appFactory.deploy({
      ...params,
      createParams: ((_a = params.createParams) == null ? void 0 : _a.method) ? PaySiloPluginParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams : void 0
    });
    return { result: result.result, appClient: new PaySiloPluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the PaySiloPlugin smart contract using the create(address)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params) => {
        return this.appFactory.params.create(PaySiloPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the PaySiloPlugin smart contract using the create(address)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params) => {
        return this.appFactory.createTransaction.create(PaySiloPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the PaySiloPlugin smart contract using an ABI method call using the create(address)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params) => {
        const result = await this.appFactory.send.create(PaySiloPluginParamsFactory.create.create(params));
        return { result: { ...result.result, return: result.result.return }, appClient: new PaySiloPluginClient(result.appClient) };
      }
    }
  };
};
var PaySiloPluginClient = class _PaySiloPluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient15 ? appClientOrParams : new _AppClient15({
      ...appClientOrParams,
      appSpec: APP_SPEC15
    });
  }
  /**
   * Returns a new `PaySiloPluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _PaySiloPluginClient(await _AppClient15.fromCreatorAndName({ ...params, appSpec: APP_SPEC15 }));
  }
  /**
   * Returns an `PaySiloPluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _PaySiloPluginClient(await _AppClient15.fromNetwork({ ...params, appSpec: APP_SPEC15 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the PaySiloPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the PaySiloPlugin smart contract using the `pay(uint64,bool,(uint64,uint64)[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    pay: (params) => {
      return this.appClient.params.call(PaySiloPluginParamsFactory.pay(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the PaySiloPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the PaySiloPlugin smart contract using the `pay(uint64,bool,(uint64,uint64)[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    pay: (params) => {
      return this.appClient.createTransaction.call(PaySiloPluginParamsFactory.pay(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the PaySiloPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the PaySiloPlugin smart contract using the `pay(uint64,bool,(uint64,uint64)[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    pay: async (params) => {
      const result = await this.appClient.send.call(PaySiloPluginParamsFactory.pay(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _PaySiloPluginClient(this.appClient.clone(params));
  }
  /**
   * Methods to access state for the current PaySiloPlugin app
   */
  state = {
    /**
     * Methods to access global state for the current PaySiloPlugin app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async () => {
        const result = await this.appClient.state.global.getAll();
        return {
          recipient: result.recipient
        };
      },
      /**
       * Get the current value of the recipient key in global state
       */
      recipient: async () => {
        return await this.appClient.state.global.getValue("recipient");
      }
    }
  };
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a pay(uint64,bool,(uint64,uint64)[])void method call against the PaySiloPlugin contract
       */
      pay(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.pay(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a clear state call to the PaySiloPlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/pay-silo.ts
var PaySiloPluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: PaySiloPluginFactory, ...params });
  }
  pay(args) {
    const methodName = "pay";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.pay({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
};

// src/generated/PaySiloFactoryPluginClient.ts
import { getArc56ReturnValue as getArc56ReturnValue9 } from "@algorandfoundation/algokit-utils/types/app-arc56";
import {
  AppClient as _AppClient16
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory16 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC16 = { "name": "PaySiloFactoryPlugin", "structs": {}, "methods": [{ "name": "mint", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "address", "name": "recipient" }], "returns": { "type": "uint64" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 0, "bytes": 0 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": {}, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": ["NoOp"], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [41], "errorMessage": "OnCompletion must be NoOp && can only call when creating" }, { "pc": [30], "errorMessage": "OnCompletion must be NoOp && can only call when not creating" }, { "pc": [484], "errorMessage": "application exists" }, { "pc": [60], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [50], "errorMessage": "invalid number of bytes for uint64" }, { "pc": [73], "errorMessage": "invalid number of bytes for uint8[32]" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXktc2lsby9mYWN0b3J5LmFsZ28udHM6MTUKICAgIC8vIGV4cG9ydCBjbGFzcyBQYXlTaWxvRmFjdG9yeVBsdWdpbiBleHRlbmRzIENvbnRyYWN0IHsKICAgIHR4biBOdW1BcHBBcmdzCiAgICBieiBtYWluX19fYWxnb3RzX18uZGVmYXVsdENyZWF0ZUA1CiAgICBwdXNoYnl0ZXMgMHgwZDliNmM1ZSAvLyBtZXRob2QgIm1pbnQodWludDY0LGJvb2wsYWRkcmVzcyl1aW50NjQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX21pbnRfcm91dGVAMwogICAgZXJyCgptYWluX21pbnRfcm91dGVAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS1zaWxvL2ZhY3RvcnkuYWxnby50czoxNy0yMQogICAgLy8gbWludCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICByZWNpcGllbnQ6IEFjY291bnQKICAgIC8vICk6IHVpbnQ2NCB7CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgJiYKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gbXVzdCBiZSBOb09wICYmIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGIgbWludAoKbWFpbl9fX2FsZ290c19fLmRlZmF1bHRDcmVhdGVANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS1zaWxvL2ZhY3RvcnkuYWxnby50czoxNQogICAgLy8gZXhwb3J0IGNsYXNzIFBheVNpbG9GYWN0b3J5UGx1Z2luIGV4dGVuZHMgQ29udHJhY3QgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgICYmCiAgICByZXR1cm4gLy8gb24gZXJyb3I6IE9uQ29tcGxldGlvbiBtdXN0IGJlIE5vT3AgJiYgY2FuIG9ubHkgY2FsbCB3aGVuIGNyZWF0aW5nCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcGF5LXNpbG8vZmFjdG9yeS5hbGdvLnRzOjpQYXlTaWxvRmFjdG9yeVBsdWdpbi5taW50W3JvdXRpbmddKCkgLT4gdm9pZDoKbWludDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS1zaWxvL2ZhY3RvcnkuYWxnby50czoxNy0yMQogICAgLy8gbWludCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICByZWNpcGllbnQ6IEFjY291bnQKICAgIC8vICk6IHVpbnQ2NCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCA4IC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgcHVzaGJ5dGVzICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcGF5LXNpbG8vZmFjdG9yeS5hbGdvLnRzOjI2LTMwCiAgICAvLyBjb25zdCByZXN1bHQgPSBwYXlTaWxvLmNhbGwuY3JlYXRlKHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcmdzOiBbcmVjaXBpZW50XSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzIyCiAgICAvLyBpZiAoIXJla2V5QmFjaykgewogICAgYm56IG1pbnRfYWZ0ZXJfaWZfZWxzZUA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMwogICAgLy8gcmV0dXJuIEdsb2JhbC56ZXJvQWRkcmVzcwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCgptaW50X2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6cmVrZXlBZGRyZXNzQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wYXktc2lsby9mYWN0b3J5LmFsZ28udHM6MjYtMzAKICAgIC8vIGNvbnN0IHJlc3VsdCA9IHBheVNpbG8uY2FsbC5jcmVhdGUoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFyZ3M6IFtyZWNpcGllbnRdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4Y2M2OTRlYWEgLy8gbWV0aG9kICJjcmVhdGUoYWRkcmVzcyl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcGF5LXNpbG8vZmFjdG9yeS5hbGdvLnRzOjI0CiAgICAvLyBjb25zdCBwYXlTaWxvID0gY29tcGlsZUFyYzQoUGF5U2lsb1BsdWdpbikKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEV4dHJhUHJvZ3JhbVBhZ2VzCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBMb2NhbE51bVVpbnQKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIExvY2FsTnVtQnl0ZVNsaWNlCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBHbG9iYWxOdW1CeXRlU2xpY2UKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEdsb2JhbE51bVVpbnQKICAgIHB1c2hieXRlcyBiYXNlNjQoQzRFQlF3PT0pCiAgICBpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtUGFnZXMKICAgIHB1c2hieXRlcyBiYXNlNjQoQ3lBRUFBRVFDQ1lCQ1hKbFkybHdhV1Z1ZERFWkZFUXhHRUVBRG9BRTRFZFNZallhQUk0QkFDNEFnQVRNYVU2cU5ob0FqZ0VBRWdDS0FnR0wva0FBQXpJRGlZdi9jZ2hFaVRZYUFVa1ZnU0FTUkNoTVp5TkRJa21BQUVrMkdnRkpGU1VTUkJkSk5ob0NTUlVqRWtRaVUwdzJHZ05KVGdKSklsbEpUZ01rQzRFQ0NFd1ZFa1NBRUhOd1pXNWthVzVuWDJGa1pISmxjM05sU0NKSlN3TU1RUUNRU3dOWEFnQkxBU1FMSkZoSklsdEpUZ0pGQ1NWYlJRbEFBRHV4SWlobFRFVUxSRXNDSXdsTEFRMUJBQjh5QTdJZ1N3ZXlDRXNKc2dkTEFiSUFJN0lRSXJJQnMwa2pDRVVCUXYrdVN3UkxCb2ovUkVMLzJiRWlLR1ZNUlFwRVN3SWpDVXNCRFVFQUh6SURzaUJMQnJJUlN3ZXlFa3NJc2hSTEFiSUFnUVN5RUNLeUFiTkMvNzFMQkVzR2lQOEpRdi9aSTBNPSkKICAgIGl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtUGFnZXMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS1zaWxvL2ZhY3RvcnkuYWxnby50czoyNi0zMAogICAgLy8gY29uc3QgcmVzdWx0ID0gcGF5U2lsby5jYWxsLmNyZWF0ZSh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXJnczogW3JlY2lwaWVudF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gQ3JlYXRlZEFwcGxpY2F0aW9uSUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS1zaWxvL2ZhY3RvcnkuYWxnby50czoxNy0yMQogICAgLy8gbWludCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICByZWNpcGllbnQ6IEFjY291bnQKICAgIC8vICk6IHVpbnQ2NCB7CiAgICBpdG9iCiAgICBwdXNoYnl0ZXMgMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1pbnRfYWZ0ZXJfaWZfZWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjYKICAgIC8vIHJldHVybiB3YWxsZXQuYWRkcmVzcwogICAgZGlnIDIKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BheS1zaWxvL2ZhY3RvcnkuYWxnby50czoyOQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgYiBtaW50X2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6cmVrZXlBZGRyZXNzQDYK", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyACAAExG0EAGIAEDZtsXjYaAI4BAAEAMRkUMRgQREIACDEZFDEYFBBDNhoBSRWBCBJEF0k2GgJJFSMSRCJTNhoDSU4DFYEgEkRMgBBzcGVuZGluZ19hZGRyZXNzZUhMsUABfDIDgATMaU6qshpLArIaIrI4IrI2IrI3I7I1IrI0gAQLgQFDskKAtAILIAQAARAIJgEJcmVjaXBpZW50MRkURDEYQQAOgATgR1JiNhoAjgEALgCABMxpTqo2GgCOAQASAIoCAYv+QAADMgOJi/9yCESJNhoBSRWBIBJEKExnI0MiSYAASTYaAUkVJRJEF0k2GgJJFSMSRCJTTDYaA0lOAkkiWUlOAyQLgQIITBUSRIAQc3BlbmRpbmdfYWRkcmVzc2VIIklLAwxBAJBLA1cCAEsBJAskWEkiW0lOAkUJJVtFCUAAO7EiKGVMRQtESwIjCUsBDUEAHzIDsiBLB7IISwmyB0sBsgAjshAisgGzSSMIRQFC/65LBEsGiP9EQv/ZsSIoZUxFCkRLAiMJSwENQQAfMgOyIEsGshFLB7ISSwiyFEsBsgCBBLIQIrIBs0L/vUsESwaI/wlC/9kjQ7JAIrIZsiBJsgCBBrIQIrIBs7Q9FoAEFR98dUxQsCNDSwJyCERC/n4=", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var PaySiloFactoryPluginParamsFactory = class {
  /**
   * Constructs a no op call for the mint(uint64,bool,address)uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mint(params) {
    return {
      ...params,
      method: "mint(uint64,bool,address)uint64",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.recipient]
    };
  }
};
var PaySiloFactoryPluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `PaySiloFactoryPluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory16({
      ...params,
      appSpec: APP_SPEC16
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC16;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new PaySiloFactoryPluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new PaySiloFactoryPluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the PaySiloFactoryPlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    const result = await this.appFactory.deploy({
      ...params
    });
    return { result: result.result, appClient: new PaySiloFactoryPluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the PaySiloFactoryPlugin smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The params for a create call
       */
      bare: (params) => {
        return this.appFactory.params.bare.create(params);
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the PaySiloFactoryPlugin smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The transaction for a create call
       */
      bare: (params) => {
        return this.appFactory.createTransaction.bare.create(params);
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the PaySiloFactoryPlugin smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The create result
       */
      bare: async (params) => {
        const result = await this.appFactory.send.bare.create(params);
        return { result: result.result, appClient: new PaySiloFactoryPluginClient(result.appClient) };
      }
    }
  };
};
var PaySiloFactoryPluginClient = class _PaySiloFactoryPluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient16 ? appClientOrParams : new _AppClient16({
      ...appClientOrParams,
      appSpec: APP_SPEC16
    });
  }
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue(method, returnValue) {
    return returnValue !== void 0 ? getArc56ReturnValue9(returnValue, this.appClient.getABIMethod(method), APP_SPEC16.structs) : void 0;
  }
  /**
   * Returns a new `PaySiloFactoryPluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _PaySiloFactoryPluginClient(await _AppClient16.fromCreatorAndName({ ...params, appSpec: APP_SPEC16 }));
  }
  /**
   * Returns an `PaySiloFactoryPluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _PaySiloFactoryPluginClient(await _AppClient16.fromNetwork({ ...params, appSpec: APP_SPEC16 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the PaySiloFactoryPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the PaySiloFactoryPlugin smart contract using the `mint(uint64,bool,address)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    mint: (params) => {
      return this.appClient.params.call(PaySiloFactoryPluginParamsFactory.mint(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the PaySiloFactoryPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the PaySiloFactoryPlugin smart contract using the `mint(uint64,bool,address)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    mint: (params) => {
      return this.appClient.createTransaction.call(PaySiloFactoryPluginParamsFactory.mint(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the PaySiloFactoryPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the PaySiloFactoryPlugin smart contract using the `mint(uint64,bool,address)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mint: async (params) => {
      const result = await this.appClient.send.call(PaySiloFactoryPluginParamsFactory.mint(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _PaySiloFactoryPluginClient(this.appClient.clone(params));
  }
  /**
   * Methods to access state for the current PaySiloFactoryPlugin app
   */
  state = {};
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a mint(uint64,bool,address)uint64 method call against the PaySiloFactoryPlugin contract
       */
      mint(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mint(params)));
        resultMappers.push((v) => client.decodeReturnValue("mint(uint64,bool,address)uint64", v));
        return this;
      },
      /**
       * Add a clear state call to the PaySiloFactoryPlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/pay-silo-factory.ts
var PaySiloFactoryPluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: PaySiloFactoryPluginFactory, ...params });
  }
  mint(args) {
    const methodName = "mint";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.mint({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
};

// src/generated/PollPluginContractClient.ts
import { getArc56ReturnValue as getArc56ReturnValue10 } from "@algorandfoundation/algokit-utils/types/app-arc56";
import {
  AppClient as _AppClient17
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory17 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC17 = { "name": "PollPluginContract", "structs": {}, "methods": [{ "name": "create", "args": [{ "type": "string", "name": "version" }, { "type": "uint64", "name": "factory" }, { "type": "uint64", "name": "akitaDAO" }], "returns": { "type": "void" }, "actions": { "create": ["NoOp"], "call": [] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "new", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint8", "name": "type" }, { "type": "uint64", "name": "endTime" }, { "type": "uint64", "name": "maxSelected" }, { "type": "string", "name": "question" }, { "type": "string[]", "name": "options" }, { "type": "uint64", "name": "gateID" }], "returns": { "type": "uint64" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "deleteBoxes", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "pollAppID" }, { "type": "address[]", "name": "addresses" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "vote", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "pollAppID" }, { "type": "uint64[]", "name": "votes" }, { "type": "byte[][]", "name": "args" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "updateAkitaDAO", "args": [{ "type": "uint64", "name": "akitaDAO" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "opUp", "args": [], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 2, "bytes": 1 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": { "factory": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "cG9sbF9mYWN0b3J5" }, "version": { "keyType": "AVMString", "valueType": "AVMString", "key": "dmVyc2lvbg==", "desc": "the current version of the contract" }, "akitaDAO": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "YWtpdGFfZGFv", "desc": "the app ID of the Akita DAO" } }, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": [], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [363], "errorMessage": "Bytes has valid prefix" }, { "pc": [440, 613], "errorMessage": "Creator is not the Poll Factory" }, { "pc": [57], "errorMessage": "OnCompletion must be NoOp" }, { "pc": [831], "errorMessage": "Only the Akita DAO can call this function" }, { "pc": [137, 283, 431, 438, 581, 604, 611, 619, 829], "errorMessage": "application exists" }, { "pc": [279, 435, 608, 628, 816], "errorMessage": "check GlobalState exists" }, { "pc": [527], "errorMessage": "invalid number of bytes for (len+uint64[])" }, { "pc": [419], "errorMessage": "invalid number of bytes for (len+uint8[32][])" }, { "pc": [152, 251], "errorMessage": "invalid number of bytes for (len+utf8[])" }, { "pc": [211, 391, 491], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [163, 172, 202, 229, 237, 262, 368, 382, 401, 481, 503, 809], "errorMessage": "invalid number of bytes for uint64" }, { "pc": [221], "errorMessage": "invalid number of bytes for uint8" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDggNgogICAgYnl0ZWNibG9jayAicG9sbF9mYWN0b3J5IiAiYWtpdGFfZGFvIiAic3BlbmRpbmdfYWRkcmVzcyIgMHgxNTFmN2M3NQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcG9sbC9jb250cmFjdC5hbGdvLnRzOjE4CiAgICAvLyBleHBvcnQgY2xhc3MgUG9sbFBsdWdpbkNvbnRyYWN0IGV4dGVuZHMgQWtpdGFCYXNlQ29udHJhY3QgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBieiBtYWluX2NyZWF0ZV9Ob09wQDkKICAgIHB1c2hieXRlc3MgMHgwZGZkZDlhMSAweDIzZDNhMmUxIDB4OWI3MDk2MTcgMHgzM2U5MmM5NCAweDg1NGRlZGUwIC8vIG1ldGhvZCAibmV3KHVpbnQ2NCxib29sLHVpbnQ4LHVpbnQ2NCx1aW50NjQsc3RyaW5nLHN0cmluZ1tdLHVpbnQ2NCl1aW50NjQiLCBtZXRob2QgImRlbGV0ZUJveGVzKHVpbnQ2NCxib29sLHVpbnQ2NCxhZGRyZXNzW10pdm9pZCIsIG1ldGhvZCAidm90ZSh1aW50NjQsYm9vbCx1aW50NjQsdWludDY0W10sYnl0ZVtdW10pdm9pZCIsIG1ldGhvZCAidXBkYXRlQWtpdGFEQU8odWludDY0KXZvaWQiLCBtZXRob2QgIm9wVXAoKXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBuZXcgZGVsZXRlQm94ZXMgdm90ZSB1cGRhdGVBa2l0YURBTyBtYWluX29wVXBfcm91dGVANwogICAgZXJyCgptYWluX29wVXBfcm91dGVANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjQzCiAgICAvLyBvcFVwKCk6IHZvaWQgeyB9CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2NyZWF0ZV9Ob09wQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6MTgKICAgIC8vIGV4cG9ydCBjbGFzcyBQb2xsUGx1Z2luQ29udHJhY3QgZXh0ZW5kcyBBa2l0YUJhc2VDb250cmFjdCB7CiAgICBwdXNoYnl0ZXMgMHg4OGM5NDBmOCAvLyBtZXRob2QgImNyZWF0ZShzdHJpbmcsdWludDY0LHVpbnQ2NCl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggY3JlYXRlCiAgICBlcnIKCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjpyZWtleUFkZHJlc3MocmVrZXlCYWNrOiB1aW50NjQsIHdhbGxldDogdWludDY0KSAtPiBieXRlczoKcmVrZXlBZGRyZXNzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjEKICAgIC8vIGV4cG9ydCBmdW5jdGlvbiByZWtleUFkZHJlc3MocmVrZXlCYWNrOiBib29sZWFuLCB3YWxsZXQ6IEFwcGxpY2F0aW9uKTogQWNjb3VudCB7CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzIyCiAgICAvLyBpZiAoIXJla2V5QmFjaykgewogICAgZnJhbWVfZGlnIC0yCiAgICBibnogcmVrZXlBZGRyZXNzX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjMKICAgIC8vIHJldHVybiBHbG9iYWwuemVyb0FkZHJlc3MKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgcmV0c3ViCgpyZWtleUFkZHJlc3NfYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjYKICAgIC8vIHJldHVybiB3YWxsZXQuYWRkcmVzcwogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6OlBvbGxQbHVnaW5Db250cmFjdC5jcmVhdGVbcm91dGluZ10oKSAtPiB2b2lkOgpjcmVhdGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6MjYKICAgIC8vIEBhYmltZXRob2QoeyBvbkNyZWF0ZTogJ3JlcXVpcmUnIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjcKICAgIC8vIHZlcnNpb24gPSBHbG9iYWxTdGF0ZTxzdHJpbmc+KHsga2V5OiBHbG9iYWxTdGF0ZUtleVZlcnNpb24gfSkKICAgIHB1c2hieXRlcyAidmVyc2lvbiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czoyOAogICAgLy8gdGhpcy52ZXJzaW9uLnZhbHVlID0gdmVyc2lvbgogICAgdW5jb3ZlciAzCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcG9sbC9jb250cmFjdC5hbGdvLnRzOjIyCiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBQb2xsUGx1Z2luR2xvYmFsU3RhdGVLZXlGYWN0b3J5IH0pCiAgICBieXRlY18wIC8vICJwb2xsX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6MjkKICAgIC8vIHRoaXMuZmFjdG9yeS52YWx1ZSA9IEFwcGxpY2F0aW9uKGZhY3RvcnkpCiAgICB1bmNvdmVyIDIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzEgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czozMAogICAgLy8gdGhpcy5ha2l0YURBTy52YWx1ZSA9IEFwcGxpY2F0aW9uKGFraXRhREFPKQogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czoyNgogICAgLy8gQGFiaW1ldGhvZCh7IG9uQ3JlYXRlOiAncmVxdWlyZScgfSkKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6OlBvbGxQbHVnaW5Db250cmFjdC5uZXdbcm91dGluZ10oKSAtPiB2b2lkOgpuZXc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6MzUtNDQKICAgIC8vIG5ldygKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICB0eXBlOiBQb2xsVHlwZSwKICAgIC8vICAgZW5kVGltZTogdWludDY0LAogICAgLy8gICBtYXhTZWxlY3RlZDogdWludDY0LAogICAgLy8gICBxdWVzdGlvbjogc3RyaW5nLAogICAgLy8gICBvcHRpb25zOiBzdHJpbmdbXSwKICAgIC8vICAgZ2F0ZUlEOiB1aW50NjQsCiAgICAvLyApOiB1aW50NjQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDgKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDcKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDgKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgNwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzIgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6NTAtNTIKICAgIC8vIE1JTl9QUk9HUkFNX1BBR0VTICsKICAgIC8vIChHTE9CQUxfU1RBVEVfS0VZX1VJTlRfQ09TVCAqIHBvbGwuZ2xvYmFsVWludHMpICsKICAgIC8vIChHTE9CQUxfU1RBVEVfS0VZX0JZVEVTX0NPU1QgKiBwb2xsLmdsb2JhbEJ5dGVzKSArCiAgICBwdXNoaW50IDgxMzUwMCAvLyA4MTM1MDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czo1MwogICAgLy8gR2xvYmFsLm1pbkJhbGFuY2UKICAgIGdsb2JhbCBNaW5CYWxhbmNlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6NTAtNTMKICAgIC8vIE1JTl9QUk9HUkFNX1BBR0VTICsKICAgIC8vIChHTE9CQUxfU1RBVEVfS0VZX1VJTlRfQ09TVCAqIHBvbGwuZ2xvYmFsVWludHMpICsKICAgIC8vIChHTE9CQUxfU1RBVEVfS0VZX0JZVEVTX0NPU1QgKiBwb2xsLmdsb2JhbEJ5dGVzKSArCiAgICAvLyBHbG9iYWwubWluQmFsYW5jZQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcG9sbC9jb250cmFjdC5hbGdvLnRzOjU3CiAgICAvLyByZWNlaXZlcjogQXBwbGljYXRpb24odGhpcy5mYWN0b3J5LnZhbHVlLmlkKS5hZGRyZXNzLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czoyMgogICAgLy8gZmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogUG9sbFBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAicG9sbF9mYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcG9sbC9jb250cmFjdC5hbGdvLnRzOjU3CiAgICAvLyByZWNlaXZlcjogQXBwbGljYXRpb24odGhpcy5mYWN0b3J5LnZhbHVlLmlkKS5hZGRyZXNzLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcG9sbC9jb250cmFjdC5hbGdvLnRzOjYxLTc0CiAgICAvLyByZXR1cm4gYWJpQ2FsbDx0eXBlb2YgUG9sbEZhY3RvcnkucHJvdG90eXBlLm5ldz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUuaWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJQYXltZW50LAogICAgLy8gICAgIHR5cGUsCiAgICAvLyAgICAgZW5kVGltZSwKICAgIC8vICAgICBtYXhTZWxlY3RlZCwKICAgIC8vICAgICBxdWVzdGlvbiwKICAgIC8vICAgICBvcHRpb25zLAogICAgLy8gICAgIGdhdGVJRAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czo1Ni01OQogICAgLy8gY29uc3QgbWJyUGF5bWVudCA9IGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHJlY2VpdmVyOiBBcHBsaWNhdGlvbih0aGlzLmZhY3RvcnkudmFsdWUuaWQpLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogYW1vdW50LAogICAgLy8gfSkKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czo2MS03NAogICAgLy8gcmV0dXJuIGFiaUNhbGw8dHlwZW9mIFBvbGxGYWN0b3J5LnByb3RvdHlwZS5uZXc+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLmlkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICB0eXBlLAogICAgLy8gICAgIGVuZFRpbWUsCiAgICAvLyAgICAgbWF4U2VsZWN0ZWQsCiAgICAvLyAgICAgcXVlc3Rpb24sCiAgICAvLyAgICAgb3B0aW9ucywKICAgIC8vICAgICBnYXRlSUQKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czo3MwogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIHVuY292ZXIgOAogICAgdW5jb3ZlciA5CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcG9sbC9jb250cmFjdC5hbGdvLnRzOjYxLTc0CiAgICAvLyByZXR1cm4gYWJpQ2FsbDx0eXBlb2YgUG9sbEZhY3RvcnkucHJvdG90eXBlLm5ldz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUuaWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJQYXltZW50LAogICAgLy8gICAgIHR5cGUsCiAgICAvLyAgICAgZW5kVGltZSwKICAgIC8vICAgICBtYXhTZWxlY3RlZCwKICAgIC8vICAgICBxdWVzdGlvbiwKICAgIC8vICAgICBvcHRpb25zLAogICAgLy8gICAgIGdhdGVJRAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweDExOWJjNjk4IC8vIG1ldGhvZCAibmV3KHBheSx1aW50OCx1aW50NjQsdWludDY0LHN0cmluZyxzdHJpbmdbXSx1aW50NjQpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgOAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGdpdHhuIDEgTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzMgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBCeXRlcyBoYXMgdmFsaWQgcHJlZml4CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcG9sbC9jb250cmFjdC5hbGdvLnRzOjM1LTQ0CiAgICAvLyBuZXcoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgdHlwZTogUG9sbFR5cGUsCiAgICAvLyAgIGVuZFRpbWU6IHVpbnQ2NCwKICAgIC8vICAgbWF4U2VsZWN0ZWQ6IHVpbnQ2NCwKICAgIC8vICAgcXVlc3Rpb246IHN0cmluZywKICAgIC8vICAgb3B0aW9uczogc3RyaW5nW10sCiAgICAvLyAgIGdhdGVJRDogdWludDY0LAogICAgLy8gKTogdWludDY0IHsKICAgIGJ5dGVjXzMgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6OlBvbGxQbHVnaW5Db250cmFjdC5kZWxldGVCb3hlc1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmRlbGV0ZUJveGVzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcG9sbC9jb250cmFjdC5hbGdvLnRzOjc3CiAgICAvLyBkZWxldGVCb3hlcyh3YWxsZXQ6IEFwcGxpY2F0aW9uLCByZWtleUJhY2s6IGJvb2xlYW4sIHBvbGxBcHBJRDogdWludDY0LCBhZGRyZXNzZXM6IEFjY291bnRbXSk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAzMiAvLyAzMgogICAgKgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdWludDhbMzJdW10pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzIgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBjb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6ODAKICAgIC8vIGFzc2VydChBcHBsaWNhdGlvbihwb2xsQXBwSUQpLmNyZWF0b3IgPT09IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLCBFUlJfQ1JFQVRPUl9OT1RfUE9MTF9GQUNUT1JZKQogICAgZGlnIDEKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcENyZWF0b3IKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6MjIKICAgIC8vIGZhY3RvcnkgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IFBvbGxQbHVnaW5HbG9iYWxTdGF0ZUtleUZhY3RvcnkgfSkKICAgIGJ5dGVjXzAgLy8gInBvbGxfZmFjdG9yeSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czo4MAogICAgLy8gYXNzZXJ0KEFwcGxpY2F0aW9uKHBvbGxBcHBJRCkuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9DUkVBVE9SX05PVF9QT0xMX0ZBQ1RPUlkpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBDcmVhdG9yIGlzIG5vdCB0aGUgUG9sbCBGYWN0b3J5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6ODItODcKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFBvbGwucHJvdG90eXBlLmRlbGV0ZUJveGVzPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHBvbGxBcHBJRCwKICAgIC8vICAgYXJnczogW2FkZHJlc3Nlc10sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcG9sbC9jb250cmFjdC5hbGdvLnRzOjg2CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDQKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6ODItODcKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFBvbGwucHJvdG90eXBlLmRlbGV0ZUJveGVzPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHBvbGxBcHBJRCwKICAgIC8vICAgYXJnczogW2FkZHJlc3Nlc10sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4ZTE0MTkwODAgLy8gbWV0aG9kICJkZWxldGVCb3hlcyhhZGRyZXNzW10pdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcG9sbC9jb250cmFjdC5hbGdvLnRzOjc3CiAgICAvLyBkZWxldGVCb3hlcyh3YWxsZXQ6IEFwcGxpY2F0aW9uLCByZWtleUJhY2s6IGJvb2xlYW4sIHBvbGxBcHBJRDogdWludDY0LCBhZGRyZXNzZXM6IEFjY291bnRbXSk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czo6UG9sbFBsdWdpbkNvbnRyYWN0LnZvdGVbcm91dGluZ10oKSAtPiB2b2lkOgp2b3RlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcG9sbC9jb250cmFjdC5hbGdvLnRzOjkwCiAgICAvLyB2b3RlKHdhbGxldDogQXBwbGljYXRpb24sIHJla2V5QmFjazogYm9vbGVhbiwgcG9sbEFwcElEOiB1aW50NjQsIHZvdGVzOiB1aW50NjRbXSwgYXJnczogR2F0ZUFyZ3MpOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIGNvdmVyIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGNvdmVyIDQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgY292ZXIgNQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMiAvLyA4CiAgICAqCiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgc3dhcAogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3VpbnQ2NFtdKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgZHVwCiAgICBjb3ZlciAzCiAgICBjb3ZlciA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE2MS0xNjQKICAgIC8vIGNvbnN0IFtjb250cm9sbGVkQWNjb3VudEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXRJRCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MpCiAgICAvLyApCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTYzCiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcykKICAgIHB1c2hieXRlcyAiY29udHJvbGxlZF9hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNjEtMTY0CiAgICAvLyBjb25zdCBbY29udHJvbGxlZEFjY291bnRCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0SUQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMiAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTY5LTE3MgogICAgLy8gY29uc3QgW3JlZmVycmVyQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldElELAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNSZWZlcnJlcikKICAgIC8vICkKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNzEKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1JlZmVycmVyKQogICAgcHVzaGJ5dGVzICJyZWZlcnJlciIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTY5LTE3MgogICAgLy8gY29uc3QgW3JlZmVycmVyQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldElELAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNSZWZlcnJlcikKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjU4CiAgICAvLyB3YWxsZXRBZGRyZXNzOiB3YWxsZXQuYWRkcmVzcywKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjU3LTI2MgogICAgLy8gcmV0dXJuIHsKICAgIC8vICAgd2FsbGV0QWRkcmVzczogd2FsbGV0LmFkZHJlc3MsCiAgICAvLyAgIG9yaWdpbiwKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWZlcnJlcgogICAgLy8gfQogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czo5MQogICAgLy8gY29uc3QgeyBvcmlnaW4sIHNlbmRlciB9ID0gZ2V0QWNjb3VudHMod2FsbGV0KQogICAgZHVwCiAgICBleHRyYWN0IDMyIDMyCiAgICBjb3ZlciA1CiAgICBleHRyYWN0IDY0IDMyCiAgICBjb3ZlciA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6OTMKICAgIC8vIGFzc2VydChBcHBsaWNhdGlvbihwb2xsQXBwSUQpLmNyZWF0b3IgPT09IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLCBFUlJfQ1JFQVRPUl9OT1RfUE9MTF9GQUNUT1JZKQogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcG9sbC9jb250cmFjdC5hbGdvLnRzOjIyCiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBQb2xsUGx1Z2luR2xvYmFsU3RhdGVLZXlGYWN0b3J5IH0pCiAgICBieXRlY18wIC8vICJwb2xsX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6OTMKICAgIC8vIGFzc2VydChBcHBsaWNhdGlvbihwb2xsQXBwSUQpLmNyZWF0b3IgPT09IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLCBFUlJfQ1JFQVRPUl9OT1RfUE9MTF9GQUNUT1JZKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gQ3JlYXRvciBpcyBub3QgdGhlIFBvbGwgRmFjdG9yeQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcG9sbC9jb250cmFjdC5hbGdvLnRzOjk3CiAgICAvLyByZWNlaXZlcjogQXBwbGljYXRpb24ocG9sbEFwcElEKS5hZGRyZXNzLAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgc3dhcAogICAgY292ZXIgNQogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcG9sbC9jb250cmFjdC5hbGdvLnRzOjEwMQogICAgLy8gaWYgKGFyZ3MubGVuZ3RoID4gMCkgewogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBieiB2b3RlX2Vsc2VfYm9keUA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6MTAyCiAgICAvLyBjb25zdCBnYXRlID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLmdhdGUKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzEgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czoxMDIKICAgIC8vIGNvbnN0IGdhdGUgPSBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuZ2F0ZQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDAKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBcHBMaXN0KSkKICAgIHB1c2hieXRlcyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcG9sbC9jb250cmFjdC5hbGdvLnRzOjEwMgogICAgLy8gY29uc3QgZ2F0ZSA9IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5nYXRlCiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcG9sbC9jb250cmFjdC5hbGdvLnRzOjEwMwogICAgLy8gY29uc3QgZ2F0ZUlEID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHBvbGxBcHBJRCwgQnl0ZXMoUG9sbEdsb2JhbFN0YXRlS2V5R2F0ZUlEKSlbMF0KICAgIGRpZyA4CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIHB1c2hieXRlcyAiZ2F0ZV9pZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czoxMDUtMTI0CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBQb2xsLnByb3RvdHlwZS5nYXRlZFZvdGU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogcG9sbEFwcElELAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICBpdHhuLmFwcGxpY2F0aW9uQ2FsbCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICBhcHBJZDogZ2F0ZSwKICAgIC8vICAgICAgIGFwcEFyZ3M6IFsKICAgIC8vICAgICAgICAgbWV0aG9kU2VsZWN0b3IoR2F0ZU11c3RDaGVja0FiaU1ldGhvZCksCiAgICAvLyAgICAgICAgIG9yaWdpbiwKICAgIC8vICAgICAgICAgZ2F0ZUlELAogICAgLy8gICAgICAgICBlbmNvZGVBcmM0KGFyZ3MpCiAgICAvLyAgICAgICBdCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgdm90ZXMKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0KICAgIC8vICkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czo5OAogICAgLy8gYW1vdW50OiB2b3Rlc01CUgogICAgcHVzaGludCAxNTMwMCAvLyAxNTMwMAogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIHVuY292ZXIgNgogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgdW5jb3ZlciA1CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6OTUtOTkKICAgIC8vIGNvbnN0IG1iclBheW1lbnQgPSBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihwb2xsQXBwSUQpLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogdm90ZXNNQlIKICAgIC8vIH0pCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6MTEwLTExOQogICAgLy8gaXR4bi5hcHBsaWNhdGlvbkNhbGwoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBnYXRlLAogICAgLy8gICBhcHBBcmdzOiBbCiAgICAvLyAgICAgbWV0aG9kU2VsZWN0b3IoR2F0ZU11c3RDaGVja0FiaU1ldGhvZCksCiAgICAvLyAgICAgb3JpZ2luLAogICAgLy8gICAgIGdhdGVJRCwKICAgIC8vICAgICBlbmNvZGVBcmM0KGFyZ3MpCiAgICAvLyAgIF0KICAgIC8vIH0pLAogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6MTE2CiAgICAvLyBnYXRlSUQsCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6MTE0CiAgICAvLyBtZXRob2RTZWxlY3RvcihHYXRlTXVzdENoZWNrQWJpTWV0aG9kKSwKICAgIHB1c2hieXRlcyAweDQzOTIyNjU1IC8vIG1ldGhvZCAibXVzdENoZWNrKGFkZHJlc3MsdWludDY0LGJ5dGVbXVtdKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDYKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDYKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czoxMTAtMTE5CiAgICAvLyBpdHhuLmFwcGxpY2F0aW9uQ2FsbCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdhdGUsCiAgICAvLyAgIGFwcEFyZ3M6IFsKICAgIC8vICAgICBtZXRob2RTZWxlY3RvcihHYXRlTXVzdENoZWNrQWJpTWV0aG9kKSwKICAgIC8vICAgICBvcmlnaW4sCiAgICAvLyAgICAgZ2F0ZUlELAogICAgLy8gICAgIGVuY29kZUFyYzQoYXJncykKICAgIC8vICAgXQogICAgLy8gfSksCiAgICBpbnRjXzMgLy8gNgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6MTA1LTEyNAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUG9sbC5wcm90b3R5cGUuZ2F0ZWRWb3RlPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHBvbGxBcHBJRCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgaXR4bi5hcHBsaWNhdGlvbkNhbGwoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgYXBwSWQ6IGdhdGUsCiAgICAvLyAgICAgICBhcHBBcmdzOiBbCiAgICAvLyAgICAgICAgIG1ldGhvZFNlbGVjdG9yKEdhdGVNdXN0Q2hlY2tBYmlNZXRob2QpLAogICAgLy8gICAgICAgICBvcmlnaW4sCiAgICAvLyAgICAgICAgIGdhdGVJRCwKICAgIC8vICAgICAgICAgZW5jb2RlQXJjNChhcmdzKQogICAgLy8gICAgICAgXQogICAgLy8gICAgIH0pLAogICAgLy8gICAgIHZvdGVzCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9CiAgICAvLyApCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czoxMjIKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgMwogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czoxMDUtMTI0CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBQb2xsLnByb3RvdHlwZS5nYXRlZFZvdGU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogcG9sbEFwcElELAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICBpdHhuLmFwcGxpY2F0aW9uQ2FsbCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICBhcHBJZDogZ2F0ZSwKICAgIC8vICAgICAgIGFwcEFyZ3M6IFsKICAgIC8vICAgICAgICAgbWV0aG9kU2VsZWN0b3IoR2F0ZU11c3RDaGVja0FiaU1ldGhvZCksCiAgICAvLyAgICAgICAgIG9yaWdpbiwKICAgIC8vICAgICAgICAgZ2F0ZUlELAogICAgLy8gICAgICAgICBlbmNvZGVBcmM0KGFyZ3MpCiAgICAvLyAgICAgICBdCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgdm90ZXMKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0KICAgIC8vICkKICAgIHB1c2hieXRlcyAweDViY2Y5MTAwIC8vIG1ldGhvZCAiZ2F0ZWRWb3RlKHBheSxhcHBsLHVpbnQ2NFtdKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0Cgp2b3RlX2FmdGVyX2lmX2Vsc2VAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czo5MAogICAgLy8gdm90ZSh3YWxsZXQ6IEFwcGxpY2F0aW9uLCByZWtleUJhY2s6IGJvb2xlYW4sIHBvbGxBcHBJRDogdWludDY0LCB2b3RlczogdWludDY0W10sIGFyZ3M6IEdhdGVBcmdzKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgp2b3RlX2Vsc2VfYm9keUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcG9sbC9jb250cmFjdC5hbGdvLnRzOjEyNi0xMzEKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFBvbGwucHJvdG90eXBlLnZvdGU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogcG9sbEFwcElELAogICAgLy8gICBhcmdzOiBbbWJyUGF5bWVudCwgdm90ZXNdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czo5OAogICAgLy8gYW1vdW50OiB2b3Rlc01CUgogICAgcHVzaGludCAxNTMwMCAvLyAxNTMwMAogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIHVuY292ZXIgMwogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgdW5jb3ZlciAyCiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6OTUtOTkKICAgIC8vIGNvbnN0IG1iclBheW1lbnQgPSBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihwb2xsQXBwSUQpLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogdm90ZXNNQlIKICAgIC8vIH0pCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6MTI2LTEzMQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUG9sbC5wcm90b3R5cGUudm90ZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBwb2xsQXBwSUQsCiAgICAvLyAgIGFyZ3M6IFttYnJQYXltZW50LCB2b3Rlc10sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9wb2xsL2NvbnRyYWN0LmFsZ28udHM6MTMwCiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgY292ZXIgMgogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3BvbGwvY29udHJhY3QuYWxnby50czoxMjYtMTMxCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBQb2xsLnByb3RvdHlwZS52b3RlPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHBvbGxBcHBJRCwKICAgIC8vICAgYXJnczogW21iclBheW1lbnQsIHZvdGVzXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHhkZDMwOWM3YiAvLyBtZXRob2QgInZvdGUocGF5LHVpbnQ2NFtdKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGRpZyA0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgYiB2b3RlX2FmdGVyX2lmX2Vsc2VAOQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjpBa2l0YUJhc2VDb250cmFjdC51cGRhdGVBa2l0YURBT1tyb3V0aW5nXSgpIC0+IHZvaWQ6CnVwZGF0ZUFraXRhREFPOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzgKICAgIC8vIHVwZGF0ZUFraXRhREFPKGFraXRhREFPOiBBcHBsaWNhdGlvbik6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjM5CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5nZXRBa2l0YURBT1dhbGxldCgpLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzIKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMSAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzIKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIHB1c2hieXRlcyAid2FsbGV0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzkKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSB0aGlzLmdldEFraXRhREFPV2FsbGV0KCkuYWRkcmVzcywgRVJSX05PVF9BS0lUQV9EQU8pCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgdGhlIEFraXRhIERBTyBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzEgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjQwCiAgICAvLyB0aGlzLmFraXRhREFPLnZhbHVlID0gYWtpdGFEQU8KICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozOAogICAgLy8gdXBkYXRlQWtpdGFEQU8oYWtpdGFEQU86IEFwcGxpY2F0aW9uKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCg==", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyAEAAEIBiYEDHBvbGxfZmFjdG9yeQlha2l0YV9kYW8Qc3BlbmRpbmdfYWRkcmVzcwQVH3x1MRkURDEYQQAtggUEDf3ZoQQj06LhBJtwlhcEM+kslASFTe3gNhoAjgUAWgEOAXECuQABACNDgASIyUD4NhoAjgEAEgCKAgGL/kAAAzIDiYv/cghEiTYaAUkiWYECCEsBFRJEVwIANhoCSRUkEkQXNhoDSRUkEkQXgAd2ZXJzaW9uTwNnKE8CZylMZyNDNhoBSRUkEkQXNhoCSRUjEkQiUzYaA0kVIxJENhoESRUkEkQ2GgVJFSQSRDYaBkkiWYECCEsBFRJENhoHNhoISRUkEkRLByplSEyBvNMxMgEIIihlRElyCESxTwKyCLIHI7IQIrIBtk8ITwmI/0mABBGbxpiyGk8IshpPB7IaTwayGk8FshpPBLIaTwKyGrIgshiyACWyECKyAbO3AT5JVwQATFcABCsSREkVJBJEK0xQsCNDNhoBSRUkEkQXNhoCSRUjEkQiUzYaA0kVJBJEFzYaBEkiWYEgC4ECCEsBFRJESwMqZUhOAksBcgdEIihlRHIIRBJEsU8DTwSI/rmABOFBkICyGrIgshqyGLIAJbIQIrIBsyNDNhoBSRUkEkQXSTYaAkkVIxJEIlNOAjYaA0kVJBJEF0lOAk4ENhoESU4FSSJZJAuBAghMFRJENhoFSU4DTgVJgBJjb250cm9sbGVkX2FkZHJlc3NlSExJKmVITEmACHJlZmVycmVyZUhMcghETwNQTwJQTFBJVyAgTgVXQCBOBElyB0QiKGVEcghEEkRyCExOBUQiWUEAeCIpZUSAA2FhbGVIgShbSwhJTgKAB2dhdGVfaWRlSLGBxHeyCE8GsgdPBUlOArIAI7IQIrIBthaABEOSJlWyGksGshqyGksGshpMshhJsgAlshAisgG2TwNPA4j9rIAEW8+RALIaSwWyGrIgsgCyGCWyECKyAbMjQ7GBxHeyCE8DsgdPAkmyACOyECKyAbZOAoj9doAE3TCce7IaSwSyGrIgSwSyGLIAJbIQIrIBs0L/xTYaAUkVJBJEFzEAIillRIAGd2FsbGV0ZUhyCEQSRClMZyND", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var PollPluginContractParamsFactory = class _PollPluginContractParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "create":
          case "create(string,uint64,uint64)void":
            return _PollPluginContractParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs create ABI call params for the PollPluginContract smart contract using the create(string,uint64,uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params) {
        return {
          ...params,
          method: "create(string,uint64,uint64)void",
          args: Array.isArray(params.args) ? params.args : [params.args.version, params.args.factory, params.args.akitaDao]
        };
      }
    };
  }
  /**
   * Constructs a no op call for the new(uint64,bool,uint8,uint64,uint64,string,string[],uint64)uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static new(params) {
    return {
      ...params,
      method: "new(uint64,bool,uint8,uint64,uint64,string,string[],uint64)uint64",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.type, params.args.endTime, params.args.maxSelected, params.args.question, params.args.options, params.args.gateId]
    };
  }
  /**
   * Constructs a no op call for the deleteBoxes(uint64,bool,uint64,address[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static deleteBoxes(params) {
    return {
      ...params,
      method: "deleteBoxes(uint64,bool,uint64,address[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.pollAppId, params.args.addresses]
    };
  }
  /**
   * Constructs a no op call for the vote(uint64,bool,uint64,uint64[],byte[][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static vote(params) {
    return {
      ...params,
      method: "vote(uint64,bool,uint64,uint64[],byte[][])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.pollAppId, params.args.votes, params.args.args]
    };
  }
  /**
   * Constructs a no op call for the updateAkitaDAO(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDao(params) {
    return {
      ...params,
      method: "updateAkitaDAO(uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.akitaDao]
    };
  }
  /**
   * Constructs a no op call for the opUp()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static opUp(params) {
    return {
      ...params,
      method: "opUp()void",
      args: Array.isArray(params.args) ? params.args : []
    };
  }
};
var PollPluginContractFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `PollPluginContractFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory17({
      ...params,
      appSpec: APP_SPEC17
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC17;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new PollPluginContractClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new PollPluginContractClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the PollPluginContract smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    var _a;
    const result = await this.appFactory.deploy({
      ...params,
      createParams: ((_a = params.createParams) == null ? void 0 : _a.method) ? PollPluginContractParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams : void 0
    });
    return { result: result.result, appClient: new PollPluginContractClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the PollPluginContract smart contract using the create(string,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params) => {
        return this.appFactory.params.create(PollPluginContractParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the PollPluginContract smart contract using the create(string,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params) => {
        return this.appFactory.createTransaction.create(PollPluginContractParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the PollPluginContract smart contract using an ABI method call using the create(string,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params) => {
        const result = await this.appFactory.send.create(PollPluginContractParamsFactory.create.create(params));
        return { result: { ...result.result, return: result.result.return }, appClient: new PollPluginContractClient(result.appClient) };
      }
    }
  };
};
var PollPluginContractClient = class _PollPluginContractClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient17 ? appClientOrParams : new _AppClient17({
      ...appClientOrParams,
      appSpec: APP_SPEC17
    });
  }
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue(method, returnValue) {
    return returnValue !== void 0 ? getArc56ReturnValue10(returnValue, this.appClient.getABIMethod(method), APP_SPEC17.structs) : void 0;
  }
  /**
   * Returns a new `PollPluginContractClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _PollPluginContractClient(await _AppClient17.fromCreatorAndName({ ...params, appSpec: APP_SPEC17 }));
  }
  /**
   * Returns an `PollPluginContractClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _PollPluginContractClient(await _AppClient17.fromNetwork({ ...params, appSpec: APP_SPEC17 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the PollPluginContract smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the PollPluginContract smart contract using the `new(uint64,bool,uint8,uint64,uint64,string,string[],uint64)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    new: (params) => {
      return this.appClient.params.call(PollPluginContractParamsFactory.new(params));
    },
    /**
     * Makes a call to the PollPluginContract smart contract using the `deleteBoxes(uint64,bool,uint64,address[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    deleteBoxes: (params) => {
      return this.appClient.params.call(PollPluginContractParamsFactory.deleteBoxes(params));
    },
    /**
     * Makes a call to the PollPluginContract smart contract using the `vote(uint64,bool,uint64,uint64[],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    vote: (params) => {
      return this.appClient.params.call(PollPluginContractParamsFactory.vote(params));
    },
    /**
     * Makes a call to the PollPluginContract smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDao: (params) => {
      return this.appClient.params.call(PollPluginContractParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the PollPluginContract smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.params.call(PollPluginContractParamsFactory.opUp(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the PollPluginContract smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the PollPluginContract smart contract using the `new(uint64,bool,uint8,uint64,uint64,string,string[],uint64)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    new: (params) => {
      return this.appClient.createTransaction.call(PollPluginContractParamsFactory.new(params));
    },
    /**
     * Makes a call to the PollPluginContract smart contract using the `deleteBoxes(uint64,bool,uint64,address[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    deleteBoxes: (params) => {
      return this.appClient.createTransaction.call(PollPluginContractParamsFactory.deleteBoxes(params));
    },
    /**
     * Makes a call to the PollPluginContract smart contract using the `vote(uint64,bool,uint64,uint64[],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    vote: (params) => {
      return this.appClient.createTransaction.call(PollPluginContractParamsFactory.vote(params));
    },
    /**
     * Makes a call to the PollPluginContract smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDao: (params) => {
      return this.appClient.createTransaction.call(PollPluginContractParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the PollPluginContract smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.createTransaction.call(PollPluginContractParamsFactory.opUp(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the PollPluginContract smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the PollPluginContract smart contract using the `new(uint64,bool,uint8,uint64,uint64,string,string[],uint64)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    new: async (params) => {
      const result = await this.appClient.send.call(PollPluginContractParamsFactory.new(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the PollPluginContract smart contract using the `deleteBoxes(uint64,bool,uint64,address[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    deleteBoxes: async (params) => {
      const result = await this.appClient.send.call(PollPluginContractParamsFactory.deleteBoxes(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the PollPluginContract smart contract using the `vote(uint64,bool,uint64,uint64[],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    vote: async (params) => {
      const result = await this.appClient.send.call(PollPluginContractParamsFactory.vote(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the PollPluginContract smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDao: async (params) => {
      const result = await this.appClient.send.call(PollPluginContractParamsFactory.updateAkitaDao(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the PollPluginContract smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    opUp: async (params = { args: [] }) => {
      const result = await this.appClient.send.call(PollPluginContractParamsFactory.opUp(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _PollPluginContractClient(this.appClient.clone(params));
  }
  /**
   * Methods to access state for the current PollPluginContract app
   */
  state = {
    /**
     * Methods to access global state for the current PollPluginContract app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async () => {
        const result = await this.appClient.state.global.getAll();
        return {
          factory: result.factory,
          version: result.version,
          akitaDao: result.akitaDAO
        };
      },
      /**
       * Get the current value of the factory key in global state
       */
      factory: async () => {
        return await this.appClient.state.global.getValue("factory");
      },
      /**
       * Get the current value of the version key in global state
       */
      version: async () => {
        return await this.appClient.state.global.getValue("version");
      },
      /**
       * Get the current value of the akitaDAO key in global state
       */
      akitaDao: async () => {
        return await this.appClient.state.global.getValue("akitaDAO");
      }
    }
  };
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a new(uint64,bool,uint8,uint64,uint64,string,string[],uint64)uint64 method call against the PollPluginContract contract
       */
      new(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.new(params)));
        resultMappers.push((v) => client.decodeReturnValue("new(uint64,bool,uint8,uint64,uint64,string,string[],uint64)uint64", v));
        return this;
      },
      /**
       * Add a deleteBoxes(uint64,bool,uint64,address[])void method call against the PollPluginContract contract
       */
      deleteBoxes(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.deleteBoxes(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a vote(uint64,bool,uint64,uint64[],byte[][])void method call against the PollPluginContract contract
       */
      vote(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.vote(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a updateAkitaDAO(uint64)void method call against the PollPluginContract contract
       */
      updateAkitaDao(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDao(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a opUp()void method call against the PollPluginContract contract
       */
      opUp(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.opUp(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a clear state call to the PollPluginContract contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/poll.ts
var PollPluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: PollPluginContractFactory, ...params });
  }
  new(args) {
    const methodName = "new";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.new({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  deleteBoxes(args) {
    const methodName = "deleteBoxes";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.deleteBoxes({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  vote(args) {
    const methodName = "vote";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.vote({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
};

// src/generated/RafflePluginClient.ts
import { getArc56ReturnValue as getArc56ReturnValue11, getABIStructFromABITuple as getABIStructFromABITuple11 } from "@algorandfoundation/algokit-utils/types/app-arc56";
import {
  AppClient as _AppClient18
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory18 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC18 = { "name": "RafflePlugin", "structs": { "RaffleMBRData": [{ "name": "entries", "type": "uint64" }, { "name": "weights", "type": "uint64" }, { "name": "entriesByAddress", "type": "uint64" }] }, "methods": [{ "name": "create", "args": [{ "type": "string", "name": "version" }, { "type": "uint64", "name": "factory" }], "returns": { "type": "void" }, "actions": { "create": ["NoOp"], "call": [] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "newRaffle", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "prizeID" }, { "type": "uint64", "name": "prizeAmount" }, { "type": "uint64", "name": "ticketAssetID" }, { "type": "uint64", "name": "startTimestamp" }, { "type": "uint64", "name": "endTimestamp" }, { "type": "uint64", "name": "minTickets" }, { "type": "uint64", "name": "maxTickets" }, { "type": "uint64", "name": "gateID" }, { "type": "address", "name": "marketplace" }, { "type": "string", "name": "name" }, { "type": "byte[32][]", "name": "proof" }, { "type": "uint64", "name": "weightsListCount" }], "returns": { "type": "uint64" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "newPrizeBoxRaffle", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "prizeBox" }, { "type": "uint64", "name": "ticketAssetID" }, { "type": "uint64", "name": "startTimestamp" }, { "type": "uint64", "name": "endTimestamp" }, { "type": "uint64", "name": "minTickets" }, { "type": "uint64", "name": "maxTickets" }, { "type": "uint64", "name": "gateID" }, { "type": "address", "name": "marketplace" }, { "type": "uint64", "name": "weightsListCount" }], "returns": { "type": "uint64" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "enter", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "uint64", "name": "amount" }, { "type": "address", "name": "marketplace" }, { "type": "byte[][]", "name": "args" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "add", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "uint64", "name": "amount" }, { "type": "byte[][]", "name": "args" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "raffle", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "findWinner", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "uint64", "name": "iterationAmount" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "claimRafflePrize", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "deleteRaffleApplication", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "updateAkitaDAO", "args": [{ "type": "uint64", "name": "akitaDAO" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "opUp", "args": [], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "mbr", "args": [], "returns": { "type": "(uint64,uint64,uint64)", "struct": "RaffleMBRData" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": true, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 2, "bytes": 1 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": { "factory": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "cmFmZmxlX2ZhY3Rvcnk=" }, "version": { "keyType": "AVMString", "valueType": "AVMString", "key": "dmVyc2lvbg==", "desc": "the current version of the contract" }, "akitaDAO": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "YWtpdGFfZGFv", "desc": "the app ID of the Akita DAO" } }, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": [], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [678, 868, 1197], "errorMessage": "Bytes has valid prefix" }, { "pc": [1288, 1526, 1709, 1796, 1877, 1955], "errorMessage": "Creator is not the raffle factory" }, { "pc": [1029], "errorMessage": "Not a prize box" }, { "pc": [1044], "errorMessage": "Not prize box owner" }, { "pc": [83], "errorMessage": "OnCompletion must be NoOp" }, { "pc": [2016], "errorMessage": "Only the Akita DAO can call this function" }, { "pc": [238, 474, 491, 546, 564, 619, 690, 739, 744, 1013, 1027, 1052, 1100, 1279, 1286, 1306, 1372, 1396, 1517, 1524, 1544, 1603, 1700, 1707, 1787, 1794, 1868, 1875, 1946, 1953, 2014], "errorMessage": "application exists" }, { "pc": [471, 487, 543, 560, 616, 633, 735, 1008, 1049, 1096, 1283, 1521, 1704, 1791, 1872, 1950, 2001], "errorMessage": "check GlobalState exists" }, { "pc": [442], "errorMessage": "invalid number of bytes for (len+uint8[32][])" }, { "pc": [253, 423], "errorMessage": "invalid number of bytes for (len+utf8[])" }, { "pc": [302, 897, 1226, 1475, 1678, 1756, 1846, 1924], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [264, 292, 316, 328, 343, 356, 366, 376, 386, 396, 452, 683, 873, 887, 911, 923, 934, 944, 954, 964, 974, 995, 1202, 1216, 1238, 1250, 1465, 1487, 1499, 1669, 1688, 1747, 1766, 1775, 1837, 1856, 1915, 1934, 1993], "errorMessage": "invalid number of bytes for uint64" }, { "pc": [407, 985, 1264], "errorMessage": "invalid number of bytes for uint8[32]" }, { "pc": [467], "errorMessage": "not enough asset" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCA4IDEgNiAxMzk4NTAwIDUwNjAwCiAgICBieXRlY2Jsb2NrICJyYWZmbGVfZmFjdG9yeSIgInNwZW5kaW5nX2FkZHJlc3MiIDB4MTUxZjdjNzUgMHgzOTRlYWViMiAiYWtpdGFfZGFvIiAidGlja2V0X2Fzc2V0IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjIKICAgIC8vIGV4cG9ydCBjbGFzcyBSYWZmbGVQbHVnaW4gZXh0ZW5kcyBjbGFzc2VzKEJhc2VSYWZmbGUsIEFraXRhQmFzZUNvbnRyYWN0KSB7CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIG11c3QgYmUgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGJ6IG1haW5fY3JlYXRlX05vT3BAMTcKICAgIHB1c2hieXRlc3MgMHg1N2I1MzY2YyAweDY5NjE5ZWJkIDB4ODAxMjI3ODMgMHg0NGUzZjQ1NSAweGE0Mzg1ZTFiIDB4MGVlNTYzZTcgMHhiZDMyMDQ2NSAweDc3MmIyNDg3IDB4MzNlOTJjOTQgMHg4NTRkZWRlMCAweGQ5YTM1ZmE0IC8vIG1ldGhvZCAibmV3UmFmZmxlKHVpbnQ2NCxib29sLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyxzdHJpbmcsYnl0ZVszMl1bXSx1aW50NjQpdWludDY0IiwgbWV0aG9kICJuZXdQcml6ZUJveFJhZmZsZSh1aW50NjQsYm9vbCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyx1aW50NjQpdWludDY0IiwgbWV0aG9kICJlbnRlcih1aW50NjQsYm9vbCx1aW50NjQsdWludDY0LGFkZHJlc3MsYnl0ZVtdW10pdm9pZCIsIG1ldGhvZCAiYWRkKHVpbnQ2NCxib29sLHVpbnQ2NCx1aW50NjQsYnl0ZVtdW10pdm9pZCIsIG1ldGhvZCAicmFmZmxlKHVpbnQ2NCxib29sLHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJmaW5kV2lubmVyKHVpbnQ2NCxib29sLHVpbnQ2NCx1aW50NjQpdm9pZCIsIG1ldGhvZCAiY2xhaW1SYWZmbGVQcml6ZSh1aW50NjQsYm9vbCx1aW50NjQpdm9pZCIsIG1ldGhvZCAiZGVsZXRlUmFmZmxlQXBwbGljYXRpb24odWludDY0LGJvb2wsdWludDY0KXZvaWQiLCBtZXRob2QgInVwZGF0ZUFraXRhREFPKHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJvcFVwKCl2b2lkIiwgbWV0aG9kICJtYnIoKSh1aW50NjQsdWludDY0LHVpbnQ2NCkiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBuZXdSYWZmbGUgbmV3UHJpemVCb3hSYWZmbGUgZW50ZXIgYWRkIHJhZmZsZSBmaW5kV2lubmVyIGNsYWltUmFmZmxlUHJpemUgZGVsZXRlUmFmZmxlQXBwbGljYXRpb24gdXBkYXRlQWtpdGFEQU8gbWFpbl9vcFVwX3JvdXRlQDE0IG1haW5fbWJyX3JvdXRlQDE1CiAgICBlcnIKCm1haW5fbWJyX3JvdXRlQDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3JhZmZsZS9iYXNlLnRzOjYKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgcHVzaGJ5dGVzIDB4MTUxZjdjNzUwMDAwMDAwMDAwMDA3YmQ0MDAwMDAwMDAwMGM4MTdkNDAwMDAwMDAwMDAwMDQ5ZDQKICAgIGxvZwogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKbWFpbl9vcFVwX3JvdXRlQDE0OgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NDMKICAgIC8vIG9wVXAoKTogdm9pZCB7IH0KICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCm1haW5fY3JlYXRlX05vT3BAMTc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoyMgogICAgLy8gZXhwb3J0IGNsYXNzIFJhZmZsZVBsdWdpbiBleHRlbmRzIGNsYXNzZXMoQmFzZVJhZmZsZSwgQWtpdGFCYXNlQ29udHJhY3QpIHsKICAgIHB1c2hieXRlcyAweGNkOWFkNjdlIC8vIG1ldGhvZCAiY3JlYXRlKHN0cmluZyx1aW50NjQpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIGNyZWF0ZQogICAgZXJyCgoKLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6cmVrZXlBZGRyZXNzKHJla2V5QmFjazogdWludDY0LCB3YWxsZXQ6IHVpbnQ2NCkgLT4gYnl0ZXM6CnJla2V5QWRkcmVzczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzIxCiAgICAvLyBleHBvcnQgZnVuY3Rpb24gcmVrZXlBZGRyZXNzKHJla2V5QmFjazogYm9vbGVhbiwgd2FsbGV0OiBBcHBsaWNhdGlvbik6IEFjY291bnQgewogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMgogICAgLy8gaWYgKCFyZWtleUJhY2spIHsKICAgIGZyYW1lX2RpZyAtMgogICAgYm56IHJla2V5QWRkcmVzc19hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzIzCiAgICAvLyByZXR1cm4gR2xvYmFsLnplcm9BZGRyZXNzCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIHJldHN1YgoKcmVrZXlBZGRyZXNzX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzI2CiAgICAvLyByZXR1cm4gd2FsbGV0LmFkZHJlc3MKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6OlJhZmZsZVBsdWdpbi5jcmVhdGVbcm91dGluZ10oKSAtPiB2b2lkOgpjcmVhdGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozMAogICAgLy8gQGFiaW1ldGhvZCh7IG9uQ3JlYXRlOiAncmVxdWlyZScgfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1dGY4W10pCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI3CiAgICAvLyB2ZXJzaW9uID0gR2xvYmFsU3RhdGU8c3RyaW5nPih7IGtleTogR2xvYmFsU3RhdGVLZXlWZXJzaW9uIH0pCiAgICBwdXNoYnl0ZXMgInZlcnNpb24iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozMgogICAgLy8gdGhpcy52ZXJzaW9uLnZhbHVlID0gdmVyc2lvbgogICAgdW5jb3ZlciAyCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjYKICAgIC8vIGZhY3RvcnkgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IFJhZmZsZVBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAicmFmZmxlX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozMwogICAgLy8gdGhpcy5mYWN0b3J5LnZhbHVlID0gZmFjdG9yeQogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjMwCiAgICAvLyBAYWJpbWV0aG9kKHsgb25DcmVhdGU6ICdyZXF1aXJlJyB9KQogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjpSYWZmbGVQbHVnaW4ubmV3UmFmZmxlW3JvdXRpbmddKCkgLT4gdm9pZDoKbmV3UmFmZmxlOgogICAgcHVzaGJ5dGVzICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozOC01MwogICAgLy8gbmV3UmFmZmxlKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIHByaXplSUQ6IHVpbnQ2NCwgLy8gMCB8IEFzc2V0CiAgICAvLyAgIHByaXplQW1vdW50OiB1aW50NjQsCiAgICAvLyAgIHRpY2tldEFzc2V0SUQ6IHVpbnQ2NCwKICAgIC8vICAgc3RhcnRUaW1lc3RhbXA6IHVpbnQ2NCwKICAgIC8vICAgZW5kVGltZXN0YW1wOiB1aW50NjQsCiAgICAvLyAgIG1pblRpY2tldHM6IHVpbnQ2NCwKICAgIC8vICAgbWF4VGlja2V0czogdWludDY0LAogICAgLy8gICBnYXRlSUQ6IHVpbnQ2NCwKICAgIC8vICAgbWFya2V0cGxhY2U6IEFjY291bnQsCiAgICAvLyAgIG5hbWU6IHN0cmluZywKICAgIC8vICAgcHJvb2Y6IFByb29mLAogICAgLy8gICB3ZWlnaHRzTGlzdENvdW50OiB1aW50NjQKICAgIC8vICk6IHVpbnQ2NCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGR1cAogICAgY292ZXIgNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGNvdmVyIDMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDYKICAgIGR1cAogICAgY292ZXIgNAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA3CiAgICBkdXAKICAgIGNvdmVyIDQKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgOAogICAgZHVwCiAgICBjb3ZlciA0CiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDkKICAgIGR1cAogICAgY292ZXIgNAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxMAogICAgZHVwCiAgICBjb3ZlciA0CiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDExCiAgICBkdXAKICAgIGNvdmVyIDQKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxMgogICAgZHVwCiAgICBjb3ZlciA0CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIHN3YXAKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1dGY4W10pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxMwogICAgZHVwCiAgICBjb3ZlciA0CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAzMiAvLyAzMgogICAgKgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIHN3YXAKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1aW50OFszMl1bXSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDE0CiAgICBkdXAKICAgIGNvdmVyIDQKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMSAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIGR1cAogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6NTUKICAgIC8vIGNvbnN0IHNlbmRlclByaXplQmFsYW5jZSA9IEFzc2V0SG9sZGluZy5hc3NldEJhbGFuY2Uoc2VuZGVyLCBwcml6ZUlEKVswXQogICAgZGlnIDIKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czo1NgogICAgLy8gYXNzZXJ0KHNlbmRlclByaXplQmFsYW5jZSA+PSBwcml6ZUFtb3VudCwgRVJSX05PVF9FTk9VR0hfQVNTRVQpCiAgICA8PQogICAgYXNzZXJ0IC8vIG5vdCBlbm91Z2ggYXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjU4CiAgICAvLyBpZiAoIXRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLmlzT3B0ZWRJbihBc3NldChwcml6ZUlEKSkpIHsKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoyNgogICAgLy8gZmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogUmFmZmxlUGx1Z2luR2xvYmFsU3RhdGVLZXlGYWN0b3J5IH0pCiAgICBieXRlY18wIC8vICJyYWZmbGVfZmFjdG9yeSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjU4CiAgICAvLyBpZiAoIXRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLmlzT3B0ZWRJbihBc3NldChwcml6ZUlEKSkpIHsKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBzd2FwCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYm56IG5ld1JhZmZsZV9hZnRlcl9pZl9lbHNlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjU5LTcwCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSYWZmbGVGYWN0b3J5LnByb3RvdHlwZS5vcHRJbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgQXNzZXQocHJpemVJRCksCiAgICAvLyAgIF0sCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6NjUKICAgIC8vIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoyNgogICAgLy8gZmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogUmFmZmxlUGx1Z2luR2xvYmFsU3RhdGVLZXlGYWN0b3J5IH0pCiAgICBieXRlY18wIC8vICJyYWZmbGVfZmFjdG9yeSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjY1CiAgICAvLyByZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czo2NgogICAgLy8gYW1vdW50OiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UsCiAgICBnbG9iYWwgQXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgMQogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6NjMtNjcKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZSwKICAgIC8vIH0pLAogICAgaW50Y18yIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6NTktNzAKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFJhZmZsZUZhY3RvcnkucHJvdG90eXBlLm9wdEluPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZmFjdG9yeS52YWx1ZSwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZSwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBBc3NldChwcml6ZUlEKSwKICAgIC8vICAgXSwKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIGJ5dGVjXzMgLy8gbWV0aG9kICJvcHRJbihwYXksdWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDE2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKCm5ld1JhZmZsZV9hZnRlcl9pZl9lbHNlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czo3MwogICAgLy8gbGV0IG9wdGluTUJSOiB1aW50NjQgPSAwCiAgICBpbnRjXzAgLy8gMAogICAgYnVyeSAxOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6NzUKICAgIC8vIGlmICghcHJpemVBc3NldElzQWxnbykgewogICAgZGlnIDEzCiAgICBieiBuZXdSYWZmbGVfYWZ0ZXJfaWZfZWxzZUAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6NzYKICAgIC8vIG9wdGluTUJSID0gR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICBnbG9iYWwgQXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIGJ1cnkgMTgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjc4CiAgICAvLyBpZiAoIXRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLmlzT3B0ZWRJbihBc3NldChwcml6ZUlEKSkpIHsKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoyNgogICAgLy8gZmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogUmFmZmxlUGx1Z2luR2xvYmFsU3RhdGVLZXlGYWN0b3J5IH0pCiAgICBieXRlY18wIC8vICJyYWZmbGVfZmFjdG9yeSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjc4CiAgICAvLyBpZiAoIXRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLmlzT3B0ZWRJbihBc3NldChwcml6ZUlEKSkpIHsKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBkaWcgMTQKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBibnogbmV3UmFmZmxlX2FmdGVyX2lmX2Vsc2VAMTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjc5LTkwCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSYWZmbGVGYWN0b3J5LnByb3RvdHlwZS5vcHRJbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBBc3NldChwcml6ZUlEKSwKICAgIC8vICAgXQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjg1CiAgICAvLyByZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjYKICAgIC8vIGZhY3RvcnkgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IFJhZmZsZVBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAicmFmZmxlX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czo4NQogICAgLy8gcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6ODYKICAgIC8vIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICBnbG9iYWwgQXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgMQogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6ODMtODcKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZQogICAgLy8gfSksCiAgICBpbnRjXzIgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czo3OS05MAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmFmZmxlRmFjdG9yeS5wcm90b3R5cGUub3B0SW4+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgQXNzZXQocHJpemVJRCksCiAgICAvLyAgIF0KICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIGJ5dGVjXzMgLy8gbWV0aG9kICJvcHRJbihwYXksdWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDE2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKCm5ld1JhZmZsZV9hZnRlcl9pZl9lbHNlQDExOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6OTUKICAgIC8vIGlmICghdGlja2V0QXNzZXRJc0FsZ28pIHsKICAgIGRpZyAxMAogICAgYnogbmV3UmFmZmxlX2FmdGVyX2lmX2Vsc2VAMTgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjk2CiAgICAvLyBvcHRpbk1CUiArPSBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIGRpZyAxNwogICAgZ2xvYmFsIEFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICArCiAgICBidXJ5IDE4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czo5OAogICAgLy8gaWYgKCF0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcy5pc09wdGVkSW4oQXNzZXQodGlja2V0QXNzZXRJRCkpKSB7CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjYKICAgIC8vIGZhY3RvcnkgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IFJhZmZsZVBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAicmFmZmxlX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czo5OAogICAgLy8gaWYgKCF0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcy5pc09wdGVkSW4oQXNzZXQodGlja2V0QXNzZXRJRCkpKSB7CiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgZGlnIDExCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYm56IG5ld1JhZmZsZV9hZnRlcl9pZl9lbHNlQDE4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czo5OS0xMDMKICAgIC8vIGNvbnN0IG9wdGluQ29zdCA9IGFiaUNhbGw8dHlwZW9mIFJhZmZsZUZhY3RvcnkucHJvdG90eXBlLm9wdEluQ29zdD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFtBc3NldCh0aWNrZXRBc3NldElEKV0KICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoxMDEKICAgIC8vIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjYKICAgIC8vIGZhY3RvcnkgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IFJhZmZsZVBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAicmFmZmxlX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoxMDEKICAgIC8vIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6OTktMTAzCiAgICAvLyBjb25zdCBvcHRpbkNvc3QgPSBhYmlDYWxsPHR5cGVvZiBSYWZmbGVGYWN0b3J5LnByb3RvdHlwZS5vcHRJbkNvc3Q+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbQXNzZXQodGlja2V0QXNzZXRJRCldCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgcHVzaGJ5dGVzIDB4MzNmNzg4MDggLy8gbWV0aG9kICJvcHRJbkNvc3QodWludDY0KXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTIKICAgIGR1cAogICAgY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGR1cAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBkaWcgMgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzIgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBCeXRlcyBoYXMgdmFsaWQgcHJlZml4CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MTA1LTExNgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmFmZmxlRmFjdG9yeS5wcm90b3R5cGUub3B0SW4+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogb3B0aW5Db3N0CiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgQXNzZXQodGlja2V0QXNzZXRJRCksCiAgICAvLyAgIF0KICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoxMTEKICAgIC8vIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIGRpZyAxCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoxMDktMTEzCiAgICAvLyBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBvcHRpbkNvc3QKICAgIC8vIH0pLAogICAgaW50Y18yIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MTA1LTExNgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmFmZmxlRmFjdG9yeS5wcm90b3R5cGUub3B0SW4+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogb3B0aW5Db3N0CiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgQXNzZXQodGlja2V0QXNzZXRJRCksCiAgICAvLyAgIF0KICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIGJ5dGVjXzMgLy8gbWV0aG9kICJvcHRJbihwYXksdWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKCm5ld1JhZmZsZV9hZnRlcl9pZl9lbHNlQDE4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MTIzLTEyNQogICAgLy8gTUFYX1BST0dSQU1fUEFHRVMgKwogICAgLy8gKEdMT0JBTF9TVEFURV9LRVlfVUlOVF9DT1NUICogcmFmZmxlLmdsb2JhbFVpbnRzKSArCiAgICAvLyAoR0xPQkFMX1NUQVRFX0tFWV9CWVRFU19DT1NUICogcmFmZmxlLmdsb2JhbEJ5dGVzKSArCiAgICBpbnRjIDQgLy8gMTM5ODUwMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MTI2CiAgICAvLyBHbG9iYWwubWluQmFsYW5jZSArCiAgICBnbG9iYWwgTWluQmFsYW5jZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MTIzLTEyNgogICAgLy8gTUFYX1BST0dSQU1fUEFHRVMgKwogICAgLy8gKEdMT0JBTF9TVEFURV9LRVlfVUlOVF9DT1NUICogcmFmZmxlLmdsb2JhbFVpbnRzKSArCiAgICAvLyAoR0xPQkFMX1NUQVRFX0tFWV9CWVRFU19DT1NUICogcmFmZmxlLmdsb2JhbEJ5dGVzKSArCiAgICAvLyBHbG9iYWwubWluQmFsYW5jZSArCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoxMjMtMTI3CiAgICAvLyBNQVhfUFJPR1JBTV9QQUdFUyArCiAgICAvLyAoR0xPQkFMX1NUQVRFX0tFWV9VSU5UX0NPU1QgKiByYWZmbGUuZ2xvYmFsVWludHMpICsKICAgIC8vIChHTE9CQUxfU1RBVEVfS0VZX0JZVEVTX0NPU1QgKiByYWZmbGUuZ2xvYmFsQnl0ZXMpICsKICAgIC8vIEdsb2JhbC5taW5CYWxhbmNlICsKICAgIC8vIG9wdGluTUJSCiAgICBkaWcgMTgKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjEzMgogICAgLy8gcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjI2CiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBSYWZmbGVQbHVnaW5HbG9iYWxTdGF0ZUtleUZhY3RvcnkgfSkKICAgIGJ5dGVjXzAgLy8gInJhZmZsZV9mYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MTMyCiAgICAvLyByZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoxMzgKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgZGlnIDEKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjE0My0xNjEKICAgIC8vIGNvbnN0IHJhZmZsZUFwcCA9IGFiaUNhbGw8dHlwZW9mIFJhZmZsZUZhY3RvcnkucHJvdG90eXBlLm5ld1JhZmZsZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJUeG4sCiAgICAvLyAgICAgcHJpemVUeG4sCiAgICAvLyAgICAgdGlja2V0QXNzZXRJRCwKICAgIC8vICAgICBzdGFydFRpbWVzdGFtcCwKICAgIC8vICAgICBlbmRUaW1lc3RhbXAsCiAgICAvLyAgICAgbWluVGlja2V0cywKICAgIC8vICAgICBtYXhUaWNrZXRzLAogICAgLy8gICAgIGdhdGVJRCwKICAgIC8vICAgICBtYXJrZXRwbGFjZSwKICAgIC8vICAgICBuYW1lLAogICAgLy8gICAgIHByb29mLAogICAgLy8gICAgIHdlaWdodHNMaXN0Q291bnQKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgMgogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MTMwLTEzNAogICAgLy8gY29uc3QgbWJyVHhuID0gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogY2hpbGRDb250cmFjdE1CUiwKICAgIC8vIH0pCiAgICBpbnRjXzIgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoxNDgKICAgIC8vIHByaXplVHhuLAogICAgaXR4bl9uZXh0CiAgICBkaWcgMTYKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBkaWcgMTUKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MTM2LTE0MQogICAgLy8gY29uc3QgcHJpemVUeG4gPSBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICBhc3NldEFtb3VudDogcHJpemVBbW91bnQsCiAgICAvLyAgIHhmZXJBc3NldDogcHJpemVJRCwKICAgIC8vIH0pCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoxNDMtMTYxCiAgICAvLyBjb25zdCByYWZmbGVBcHAgPSBhYmlDYWxsPHR5cGVvZiBSYWZmbGVGYWN0b3J5LnByb3RvdHlwZS5uZXdSYWZmbGU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyVHhuLAogICAgLy8gICAgIHByaXplVHhuLAogICAgLy8gICAgIHRpY2tldEFzc2V0SUQsCiAgICAvLyAgICAgc3RhcnRUaW1lc3RhbXAsCiAgICAvLyAgICAgZW5kVGltZXN0YW1wLAogICAgLy8gICAgIG1pblRpY2tldHMsCiAgICAvLyAgICAgbWF4VGlja2V0cywKICAgIC8vICAgICBnYXRlSUQsCiAgICAvLyAgICAgbWFya2V0cGxhY2UsCiAgICAvLyAgICAgbmFtZSwKICAgIC8vICAgICBwcm9vZiwKICAgIC8vICAgICB3ZWlnaHRzTGlzdENvdW50CiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoxNjAKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICBkaWcgMTcKICAgIGRpZyAxOQogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjE0My0xNjEKICAgIC8vIGNvbnN0IHJhZmZsZUFwcCA9IGFiaUNhbGw8dHlwZW9mIFJhZmZsZUZhY3RvcnkucHJvdG90eXBlLm5ld1JhZmZsZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJUeG4sCiAgICAvLyAgICAgcHJpemVUeG4sCiAgICAvLyAgICAgdGlja2V0QXNzZXRJRCwKICAgIC8vICAgICBzdGFydFRpbWVzdGFtcCwKICAgIC8vICAgICBlbmRUaW1lc3RhbXAsCiAgICAvLyAgICAgbWluVGlja2V0cywKICAgIC8vICAgICBtYXhUaWNrZXRzLAogICAgLy8gICAgIGdhdGVJRCwKICAgIC8vICAgICBtYXJrZXRwbGFjZSwKICAgIC8vICAgICBuYW1lLAogICAgLy8gICAgIHByb29mLAogICAgLy8gICAgIHdlaWdodHNMaXN0Q291bnQKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBwdXNoYnl0ZXMgMHgxODU4NGYyMCAvLyBtZXRob2QgIm5ld1JhZmZsZShwYXksYXhmZXIsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyxzdHJpbmcsYnl0ZVszMl1bXSx1aW50NjQpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA5CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDgKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGdpdHhuIDIgTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzIgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBCeXRlcyBoYXMgdmFsaWQgcHJlZml4CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MzgtNTMKICAgIC8vIG5ld1JhZmZsZSgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBwcml6ZUlEOiB1aW50NjQsIC8vIDAgfCBBc3NldAogICAgLy8gICBwcml6ZUFtb3VudDogdWludDY0LAogICAgLy8gICB0aWNrZXRBc3NldElEOiB1aW50NjQsCiAgICAvLyAgIHN0YXJ0VGltZXN0YW1wOiB1aW50NjQsCiAgICAvLyAgIGVuZFRpbWVzdGFtcDogdWludDY0LAogICAgLy8gICBtaW5UaWNrZXRzOiB1aW50NjQsCiAgICAvLyAgIG1heFRpY2tldHM6IHVpbnQ2NCwKICAgIC8vICAgZ2F0ZUlEOiB1aW50NjQsCiAgICAvLyAgIG1hcmtldHBsYWNlOiBBY2NvdW50LAogICAgLy8gICBuYW1lOiBzdHJpbmcsCiAgICAvLyAgIHByb29mOiBQcm9vZiwKICAgIC8vICAgd2VpZ2h0c0xpc3RDb3VudDogdWludDY0CiAgICAvLyApOiB1aW50NjQgewogICAgYnl0ZWNfMiAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjpSYWZmbGVQbHVnaW4ubmV3UHJpemVCb3hSYWZmbGVbcm91dGluZ10oKSAtPiB2b2lkOgpuZXdQcml6ZUJveFJhZmZsZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjE2Ni0xNzgKICAgIC8vIG5ld1ByaXplQm94UmFmZmxlKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIHByaXplQm94OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgdGlja2V0QXNzZXRJRDogdWludDY0LAogICAgLy8gICBzdGFydFRpbWVzdGFtcDogdWludDY0LAogICAgLy8gICBlbmRUaW1lc3RhbXA6IHVpbnQ2NCwKICAgIC8vICAgbWluVGlja2V0czogdWludDY0LAogICAgLy8gICBtYXhUaWNrZXRzOiB1aW50NjQsCiAgICAvLyAgIGdhdGVJRDogdWludDY0LAogICAgLy8gICBtYXJrZXRwbGFjZTogQWNjb3VudCwKICAgIC8vICAgd2VpZ2h0c0xpc3RDb3VudDogdWludDY0CiAgICAvLyApOiB1aW50NjQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgc3dhcAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBjb3ZlciAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBjb3ZlciAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgZHVwCiAgICBjb3ZlciA0CiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDYKICAgIGR1cAogICAgY292ZXIgNAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA3CiAgICBkdXAKICAgIGNvdmVyIDQKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgOAogICAgZHVwCiAgICBjb3ZlciA0CiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDkKICAgIGR1cAogICAgY292ZXIgNAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxMAogICAgZHVwCiAgICBjb3ZlciA0CiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMTEKICAgIGR1cAogICAgY292ZXIgNAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICB1bmNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgZHVwCiAgICBjb3ZlciAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoxODEKICAgIC8vIGFzc2VydChnZXRQcml6ZUJveE93bmVyKHRoaXMuYWtpdGFEQU8udmFsdWUsIHByaXplQm94KSA9PT0gc2VuZGVyLCBFUlJfTk9UX1BSSVpFX0JPWF9PV05FUikKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjIDQgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjE4MQogICAgLy8gYXNzZXJ0KGdldFByaXplQm94T3duZXIodGhpcy5ha2l0YURBTy52YWx1ZSwgcHJpemVCb3gpID09PSBzZW5kZXIsIEVSUl9OT1RfUFJJWkVfQk9YX09XTkVSKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDQ1CiAgICAvLyBhc3NlcnQocHJpemVCb3guY3JlYXRvciA9PT0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KGFraXRhREFPKS5wcml6ZUJveCkuYWRkcmVzcywgRVJSX05PVF9BX1BSSVpFX0JPWCkKICAgIGRpZyAzCiAgICBhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQwCiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBzd2FwCiAgICBwdXNoYnl0ZXMgImFhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDQ1CiAgICAvLyBhc3NlcnQocHJpemVCb3guY3JlYXRvciA9PT0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KGFraXRhREFPKS5wcml6ZUJveCkuYWRkcmVzcywgRVJSX05PVF9BX1BSSVpFX0JPWCkKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIGV4dHJhY3RfdWludDY0CiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIE5vdCBhIHByaXplIGJveAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0NDYKICAgIC8vIGNvbnN0IFtvd25lckJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKHByaXplQm94LCBCeXRlcyhQcml6ZUJveEdsb2JhbFN0YXRlS2V5T3duZXIpKQogICAgZGlnIDIKICAgIHB1c2hieXRlcyAib3duZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoxODEKICAgIC8vIGFzc2VydChnZXRQcml6ZUJveE93bmVyKHRoaXMuYWtpdGFEQU8udmFsdWUsIHByaXplQm94KSA9PT0gc2VuZGVyLCBFUlJfTk9UX1BSSVpFX0JPWF9PV05FUikKICAgIGRpZyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIE5vdCBwcml6ZSBib3ggb3duZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjE4My0xODcKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFByaXplQm94LnByb3RvdHlwZS50cmFuc2Zlcj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBwcml6ZUJveCwKICAgIC8vICAgYXJnczogW3RoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzXSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoxODYKICAgIC8vIGFyZ3M6IFt0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzc10sCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjYKICAgIC8vIGZhY3RvcnkgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IFJhZmZsZVBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAicmFmZmxlX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoxODYKICAgIC8vIGFyZ3M6IFt0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzc10sCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MTgzLTE4NwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUHJpemVCb3gucHJvdG90eXBlLnRyYW5zZmVyPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHByaXplQm94LAogICAgLy8gICBhcmdzOiBbdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3NdLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweGFkZjkyYWU0IC8vIG1ldGhvZCAidHJhbnNmZXIoYWRkcmVzcyl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoxODkKICAgIC8vIGxldCBvcHRpbk1CUjogdWludDY0ID0gMAogICAgaW50Y18wIC8vIDAKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjE5MQogICAgLy8gaWYgKHRpY2tldEFzc2V0SXNBbGdvKSB7CiAgICBibnogbmV3UHJpemVCb3hSYWZmbGVfYWZ0ZXJfaWZfZWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoxOTIKICAgIC8vIG9wdGluTUJSICs9IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZQogICAgZ2xvYmFsIEFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICBidXJ5IDEKCm5ld1ByaXplQm94UmFmZmxlX2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjE5OC0yMDAKICAgIC8vIE1BWF9QUk9HUkFNX1BBR0VTICsKICAgIC8vIChHTE9CQUxfU1RBVEVfS0VZX1VJTlRfQ09TVCAqIHJhZmZsZS5nbG9iYWxVaW50cykgKwogICAgLy8gKEdMT0JBTF9TVEFURV9LRVlfQllURVNfQ09TVCAqIHJhZmZsZS5nbG9iYWxCeXRlcykgKwogICAgaW50YyA0IC8vIDEzOTg1MDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjIwMQogICAgLy8gR2xvYmFsLm1pbkJhbGFuY2UgKwogICAgZ2xvYmFsIE1pbkJhbGFuY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjE5OC0yMDEKICAgIC8vIE1BWF9QUk9HUkFNX1BBR0VTICsKICAgIC8vIChHTE9CQUxfU1RBVEVfS0VZX1VJTlRfQ09TVCAqIHJhZmZsZS5nbG9iYWxVaW50cykgKwogICAgLy8gKEdMT0JBTF9TVEFURV9LRVlfQllURVNfQ09TVCAqIHJhZmZsZS5nbG9iYWxCeXRlcykgKwogICAgLy8gR2xvYmFsLm1pbkJhbGFuY2UgKwogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MTk4LTIwMgogICAgLy8gTUFYX1BST0dSQU1fUEFHRVMgKwogICAgLy8gKEdMT0JBTF9TVEFURV9LRVlfVUlOVF9DT1NUICogcmFmZmxlLmdsb2JhbFVpbnRzKSArCiAgICAvLyAoR0xPQkFMX1NUQVRFX0tFWV9CWVRFU19DT1NUICogcmFmZmxlLmdsb2JhbEJ5dGVzKSArCiAgICAvLyBHbG9iYWwubWluQmFsYW5jZSArCiAgICAvLyBvcHRpbk1CUgogICAgZGlnIDEKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjIwNwogICAgLy8gcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjI2CiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBSYWZmbGVQbHVnaW5HbG9iYWxTdGF0ZUtleUZhY3RvcnkgfSkKICAgIGJ5dGVjXzAgLy8gInJhZmZsZV9mYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjA3CiAgICAvLyByZWNlaXZlcjogdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoyMTEtMjI3CiAgICAvLyBjb25zdCByYWZmbGVBcHAgPSBhYmlDYWxsPHR5cGVvZiBSYWZmbGVGYWN0b3J5LnByb3RvdHlwZS5uZXdQcml6ZUJveFJhZmZsZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJUeG4sCiAgICAvLyAgICAgcHJpemVCb3gsCiAgICAvLyAgICAgdGlja2V0QXNzZXRJRCwKICAgIC8vICAgICBzdGFydFRpbWVzdGFtcCwKICAgIC8vICAgICBlbmRUaW1lc3RhbXAsCiAgICAvLyAgICAgbWluVGlja2V0cywKICAgIC8vICAgICBtYXhUaWNrZXRzLAogICAgLy8gICAgIGdhdGVJRCwKICAgIC8vICAgICBtYXJrZXRwbGFjZSwKICAgIC8vICAgICB3ZWlnaHRzTGlzdENvdW50CiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9iZWdpbgogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZGlnIDIKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjIwNS0yMDkKICAgIC8vIGNvbnN0IG1iclR4biA9IGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IGNoaWxkQ29udHJhY3RNQlIsCiAgICAvLyB9KQogICAgaW50Y18yIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjExLTIyNwogICAgLy8gY29uc3QgcmFmZmxlQXBwID0gYWJpQ2FsbDx0eXBlb2YgUmFmZmxlRmFjdG9yeS5wcm90b3R5cGUubmV3UHJpemVCb3hSYWZmbGU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyVHhuLAogICAgLy8gICAgIHByaXplQm94LAogICAgLy8gICAgIHRpY2tldEFzc2V0SUQsCiAgICAvLyAgICAgc3RhcnRUaW1lc3RhbXAsCiAgICAvLyAgICAgZW5kVGltZXN0YW1wLAogICAgLy8gICAgIG1pblRpY2tldHMsCiAgICAvLyAgICAgbWF4VGlja2V0cywKICAgIC8vICAgICBnYXRlSUQsCiAgICAvLyAgICAgbWFya2V0cGxhY2UsCiAgICAvLyAgICAgd2VpZ2h0c0xpc3RDb3VudAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjI2CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgZGlnIDEzCiAgICBkaWcgMTUKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoyMTEtMjI3CiAgICAvLyBjb25zdCByYWZmbGVBcHAgPSBhYmlDYWxsPHR5cGVvZiBSYWZmbGVGYWN0b3J5LnByb3RvdHlwZS5uZXdQcml6ZUJveFJhZmZsZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJUeG4sCiAgICAvLyAgICAgcHJpemVCb3gsCiAgICAvLyAgICAgdGlja2V0QXNzZXRJRCwKICAgIC8vICAgICBzdGFydFRpbWVzdGFtcCwKICAgIC8vICAgICBlbmRUaW1lc3RhbXAsCiAgICAvLyAgICAgbWluVGlja2V0cywKICAgIC8vICAgICBtYXhUaWNrZXRzLAogICAgLy8gICAgIGdhdGVJRCwKICAgIC8vICAgICBtYXJrZXRwbGFjZSwKICAgIC8vICAgICB3ZWlnaHRzTGlzdENvdW50CiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgcHVzaGJ5dGVzIDB4MjkyNDU2NWUgLy8gbWV0aG9kICJuZXdQcml6ZUJveFJhZmZsZShwYXksdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LGFkZHJlc3MsdWludDY0KXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgOQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA4CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDcKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA1CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgZ2l0eG4gMSBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMiAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoxNjYtMTc4CiAgICAvLyBuZXdQcml6ZUJveFJhZmZsZSgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBwcml6ZUJveDogQXBwbGljYXRpb24sCiAgICAvLyAgIHRpY2tldEFzc2V0SUQ6IHVpbnQ2NCwKICAgIC8vICAgc3RhcnRUaW1lc3RhbXA6IHVpbnQ2NCwKICAgIC8vICAgZW5kVGltZXN0YW1wOiB1aW50NjQsCiAgICAvLyAgIG1pblRpY2tldHM6IHVpbnQ2NCwKICAgIC8vICAgbWF4VGlja2V0czogdWludDY0LAogICAgLy8gICBnYXRlSUQ6IHVpbnQ2NCwKICAgIC8vICAgbWFya2V0cGxhY2U6IEFjY291bnQsCiAgICAvLyAgIHdlaWdodHNMaXN0Q291bnQ6IHVpbnQ2NAogICAgLy8gKTogdWludDY0IHsKICAgIGJ5dGVjXzIgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czo6UmFmZmxlUGx1Z2luLmVudGVyW3JvdXRpbmddKCkgLT4gdm9pZDoKZW50ZXI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoyMzItMjM5CiAgICAvLyBlbnRlcigKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24sCiAgICAvLyAgIGFtb3VudDogdWludDY0LAogICAgLy8gICBtYXJrZXRwbGFjZTogQWNjb3VudCwKICAgIC8vICAgYXJnczogR2F0ZUFyZ3MKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgY292ZXIgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgY292ZXIgNAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGNvdmVyIDQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGR1cAogICAgY292ZXIgNQogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDYKICAgIGNvdmVyIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjQyCiAgICAvLyBhc3NlcnQoYXBwSWQuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9DUkVBVE9SX05PVF9SQUZGTEVfRkFDVE9SWSkKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjI2CiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBSYWZmbGVQbHVnaW5HbG9iYWxTdGF0ZUtleUZhY3RvcnkgfSkKICAgIGJ5dGVjXzAgLy8gInJhZmZsZV9mYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjQyCiAgICAvLyBhc3NlcnQoYXBwSWQuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9DUkVBVE9SX05PVF9SQUZGTEVfRkFDVE9SWSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIENyZWF0b3IgaXMgbm90IHRoZSByYWZmbGUgZmFjdG9yeQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjQ3CiAgICAvLyBjb25zdCB0aWNrZXRBc3NldCA9IEFzc2V0KGJ0b2kob3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYXBwSWQsIEJ5dGVzKFJhZmZsZUdsb2JhbFN0YXRlS2V5VGlja2V0QXNzZXQpKVswXSkpCiAgICBieXRlYyA1IC8vICJ0aWNrZXRfYXNzZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjI0OAogICAgLy8gaWYgKHRpY2tldEFzc2V0LmlkID09PSAwKSB7CiAgICBibnogZW50ZXJfZWxzZV9ib2R5QDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjI0OS0yNjIKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFJhZmZsZS5wcm90b3R5cGUuZW50ZXI+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogYW1vdW50ICsgbWJyLAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIG1hcmtldHBsYWNlLAogICAgLy8gICAgIGFyZ3MsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjU1CiAgICAvLyByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIGRpZyA3CiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjI1NgogICAgLy8gYW1vdW50OiBhbW91bnQgKyBtYnIsCiAgICBkaWcgOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjQ1CiAgICAvLyBjb25zdCBtYnI6IHVpbnQ2NCA9IGVudHJpZXMgKyBlbnRyaWVzQnlBZGRyZXNzCiAgICBpbnRjIDUgLy8gNTA2MDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjI1NgogICAgLy8gYW1vdW50OiBhbW91bnQgKyBtYnIsCiAgICArCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgdW5jb3ZlciAzCiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoyNTMtMjU3CiAgICAvLyBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IGFtb3VudCArIG1iciwKICAgIC8vIH0pLAogICAgaW50Y18yIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjQ5LTI2MgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmFmZmxlLnByb3RvdHlwZS5lbnRlcj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBhbW91bnQgKyBtYnIsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgbWFya2V0cGxhY2UsCiAgICAvLyAgICAgYXJncywKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjI2MQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciAzCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjQ5LTI2MgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmFmZmxlLnByb3RvdHlwZS5lbnRlcj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBhbW91bnQgKyBtYnIsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgbWFya2V0cGxhY2UsCiAgICAvLyAgICAgYXJncywKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHg5NzM5Y2JiNiAvLyBtZXRob2QgImVudGVyKHBheSxhZGRyZXNzLGJ5dGVbXVtdKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKCmVudGVyX2FmdGVyX2lmX2Vsc2VAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjIzMi0yMzkKICAgIC8vIGVudGVyKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbiwKICAgIC8vICAgYW1vdW50OiB1aW50NjQsCiAgICAvLyAgIG1hcmtldHBsYWNlOiBBY2NvdW50LAogICAgLy8gICBhcmdzOiBHYXRlQXJncwogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgplbnRlcl9lbHNlX2JvZHlANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjI2NC0yODMKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFJhZmZsZS5wcm90b3R5cGUuZW50ZXJBc2E+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogbWJyLAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICAgIHhmZXJBc3NldDogdGlja2V0QXNzZXQsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgbWFya2V0cGxhY2UsCiAgICAvLyAgICAgYXJncywKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoyNzAKICAgIC8vIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgZGlnIDcKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjQ1CiAgICAvLyBjb25zdCBtYnI6IHVpbnQ2NCA9IGVudHJpZXMgKyBlbnRyaWVzQnlBZGRyZXNzCiAgICBpbnRjIDUgLy8gNTA2MDAKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICB1bmNvdmVyIDMKICAgIGR1cAogICAgY292ZXIgMgogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjI2OC0yNzIKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogbWJyLAogICAgLy8gfSksCiAgICBpbnRjXzIgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoyNzMtMjc4CiAgICAvLyBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgIHhmZXJBc3NldDogdGlja2V0QXNzZXQsCiAgICAvLyB9KSwKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6Mjc1CiAgICAvLyBhc3NldFJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBkaWcgNQogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIGRpZyA4CiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGRpZyAxCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjczLTI3OAogICAgLy8gaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhc3NldFJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gICB4ZmVyQXNzZXQ6IHRpY2tldEFzc2V0LAogICAgLy8gfSksCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoyNjQtMjgzCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSYWZmbGUucHJvdG90eXBlLmVudGVyQXNhPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IG1iciwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgYXNzZXRSZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgICB4ZmVyQXNzZXQ6IHRpY2tldEFzc2V0LAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIG1hcmtldHBsYWNlLAogICAgLy8gICAgIGFyZ3MsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoyODIKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgMwogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjI2NC0yODMKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFJhZmZsZS5wcm90b3R5cGUuZW50ZXJBc2E+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogbWJyLAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICAgIHhmZXJBc3NldDogdGlja2V0QXNzZXQsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgbWFya2V0cGxhY2UsCiAgICAvLyAgICAgYXJncywKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHhlM2EyMWQ1MiAvLyBtZXRob2QgImVudGVyQXNhKHBheSxheGZlcixhZGRyZXNzLGJ5dGVbXVtdKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGIgZW50ZXJfYWZ0ZXJfaWZfZWxzZUA5CgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6OlJhZmZsZVBsdWdpbi5hZGRbcm91dGluZ10oKSAtPiB2b2lkOgphZGQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czoyODctMjkzCiAgICAvLyBhZGQoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICBhbW91bnQ6IHVpbnQ2NCwKICAgIC8vICAgYXJnczogR2F0ZUFyZ3MKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgY292ZXIgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgY292ZXIgNAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGNvdmVyIDQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGNvdmVyIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6Mjk2CiAgICAvLyBhc3NlcnQoYXBwSWQuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9DUkVBVE9SX05PVF9SQUZGTEVfRkFDVE9SWSkKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjI2CiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBSYWZmbGVQbHVnaW5HbG9iYWxTdGF0ZUtleUZhY3RvcnkgfSkKICAgIGJ5dGVjXzAgLy8gInJhZmZsZV9mYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6Mjk2CiAgICAvLyBhc3NlcnQoYXBwSWQuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9DUkVBVE9SX05PVF9SQUZGTEVfRkFDVE9SWSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIENyZWF0b3IgaXMgbm90IHRoZSByYWZmbGUgZmFjdG9yeQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6Mjk4CiAgICAvLyBjb25zdCB0aWNrZXRBc3NldCA9IEFzc2V0KGJ0b2kob3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYXBwSWQsIEJ5dGVzKFJhZmZsZUdsb2JhbFN0YXRlS2V5VGlja2V0QXNzZXQpKVswXSkpCiAgICBieXRlYyA1IC8vICJ0aWNrZXRfYXNzZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjI5OQogICAgLy8gaWYgKHRpY2tldEFzc2V0LmlkID09PSAwKSB7CiAgICBibnogYWRkX2Vsc2VfYm9keUA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozMDAtMzEyCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSYWZmbGUucHJvdG90eXBlLmFkZD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgYXJncywKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozMDYKICAgIC8vIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgZGlnIDYKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgZGlnIDcKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICB1bmNvdmVyIDMKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjMwNC0zMDgKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogYW1vdW50LAogICAgLy8gfSksCiAgICBpbnRjXzIgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozMDAtMzEyCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSYWZmbGUucHJvdG90eXBlLmFkZD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgYXJncywKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjMxMQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciAzCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MzAwLTMxMgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmFmZmxlLnByb3RvdHlwZS5hZGQ+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogYW1vdW50LAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGFyZ3MsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4MDU0YTMwMjAgLy8gbWV0aG9kICJhZGQocGF5LGJ5dGVbXVtdKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CgphZGRfYWZ0ZXJfaWZfZWxzZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6Mjg3LTI5MwogICAgLy8gYWRkKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbiwKICAgIC8vICAgYW1vdW50OiB1aW50NjQsCiAgICAvLyAgIGFyZ3M6IEdhdGVBcmdzCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCmFkZF9lbHNlX2JvZHlANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjMxNC0zMjcKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFJhZmZsZS5wcm90b3R5cGUuYWRkQXNhPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgYXNzZXRSZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgICB4ZmVyQXNzZXQ6IHRpY2tldEFzc2V0LAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGFyZ3MsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MzIwCiAgICAvLyBhc3NldFJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgZGlnIDYKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgZGlnIDUKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBkaWcgNwogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICB1bmNvdmVyIDMKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjMxOC0zMjMKICAgIC8vIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXNzZXRSZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgeGZlckFzc2V0OiB0aWNrZXRBc3NldCwKICAgIC8vIH0pLAogICAgcHVzaGludCA0IC8vIDQKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MzE0LTMyNwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmFmZmxlLnByb3RvdHlwZS5hZGRBc2E+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICAgIHhmZXJBc3NldDogdGlja2V0QXNzZXQsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgYXJncywKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjMyNgogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciAzCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MzE0LTMyNwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmFmZmxlLnByb3RvdHlwZS5hZGRBc2E+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICAgIHhmZXJBc3NldDogdGlja2V0QXNzZXQsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgYXJncywKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHg0ODIxMjFjMyAvLyBtZXRob2QgImFkZEFzYShheGZlcixieXRlW11bXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgYiBhZGRfYWZ0ZXJfaWZfZWxzZUA4CgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6OlJhZmZsZVBsdWdpbi5yYWZmbGVbcm91dGluZ10oKSAtPiB2b2lkOgpyYWZmbGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozMzEtMzM1CiAgICAvLyByYWZmbGUoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uCiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MzM4CiAgICAvLyBhc3NlcnQoYXBwSWQuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9DUkVBVE9SX05PVF9SQUZGTEVfRkFDVE9SWSkKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjI2CiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBSYWZmbGVQbHVnaW5HbG9iYWxTdGF0ZUtleUZhY3RvcnkgfSkKICAgIGJ5dGVjXzAgLy8gInJhZmZsZV9mYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MzM4CiAgICAvLyBhc3NlcnQoYXBwSWQuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9DUkVBVE9SX05PVF9SQUZGTEVfRkFDVE9SWSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIENyZWF0b3IgaXMgbm90IHRoZSByYWZmbGUgZmFjdG9yeQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MzQwLTM0NAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmFmZmxlLnByb3RvdHlwZS5yYWZmbGU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozNDMKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICBzd2FwCiAgICB1bmNvdmVyIDMKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozNDAtMzQ0CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSYWZmbGUucHJvdG90eXBlLnJhZmZsZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDY5NjUwMWRlIC8vIG1ldGhvZCAicmFmZmxlKCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjMzMS0zMzUKICAgIC8vIHJhZmZsZSgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24KICAgIC8vICk6IHZvaWQgewogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjpSYWZmbGVQbHVnaW4uZmluZFdpbm5lcltyb3V0aW5nXSgpIC0+IHZvaWQ6CmZpbmRXaW5uZXI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozNDctMzUyCiAgICAvLyBmaW5kV2lubmVyKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbiwKICAgIC8vICAgaXRlcmF0aW9uQW1vdW50OiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MzU1CiAgICAvLyBhc3NlcnQoYXBwSWQuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9DUkVBVE9SX05PVF9SQUZGTEVfRkFDVE9SWSkKICAgIGRpZyAxCiAgICBhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjYKICAgIC8vIGZhY3RvcnkgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IFJhZmZsZVBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAicmFmZmxlX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozNTUKICAgIC8vIGFzc2VydChhcHBJZC5jcmVhdG9yID09PSB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywgRVJSX0NSRUFUT1JfTk9UX1JBRkZMRV9GQUNUT1JZKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gQ3JlYXRvciBpcyBub3QgdGhlIHJhZmZsZSBmYWN0b3J5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozNTctMzYyCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSYWZmbGUucHJvdG90eXBlLmZpbmRXaW5uZXI+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW2l0ZXJhdGlvbkFtb3VudF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MzYxCiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDQKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozNTctMzYyCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSYWZmbGUucHJvdG90eXBlLmZpbmRXaW5uZXI+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW2l0ZXJhdGlvbkFtb3VudF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4YmQxYjI3ZDEgLy8gbWV0aG9kICJmaW5kV2lubmVyKHVpbnQ2NCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozNDctMzUyCiAgICAvLyBmaW5kV2lubmVyKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbiwKICAgIC8vICAgaXRlcmF0aW9uQW1vdW50OiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3JhZmZsZS9jb250cmFjdC5hbGdvLnRzOjpSYWZmbGVQbHVnaW4uY2xhaW1SYWZmbGVQcml6ZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmNsYWltUmFmZmxlUHJpemU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozNjUtMzY5CiAgICAvLyBjbGFpbVJhZmZsZVByaXplKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbiwKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBjb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozNzIKICAgIC8vIGFzc2VydChhcHBJZC5jcmVhdG9yID09PSB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywgRVJSX0NSRUFUT1JfTk9UX1JBRkZMRV9GQUNUT1JZKQogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjYKICAgIC8vIGZhY3RvcnkgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IFJhZmZsZVBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAicmFmZmxlX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozNzIKICAgIC8vIGFzc2VydChhcHBJZC5jcmVhdG9yID09PSB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywgRVJSX0NSRUFUT1JfTk9UX1JBRkZMRV9GQUNUT1JZKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gQ3JlYXRvciBpcyBub3QgdGhlIHJhZmZsZSBmYWN0b3J5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozNzQtMzc4CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSYWZmbGUucHJvdG90eXBlLmNsYWltUmFmZmxlUHJpemU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozNzcKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICBzd2FwCiAgICB1bmNvdmVyIDMKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozNzQtMzc4CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSYWZmbGUucHJvdG90eXBlLmNsYWltUmFmZmxlUHJpemU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHg2NWZjYTk4YiAvLyBtZXRob2QgImNsYWltUmFmZmxlUHJpemUoKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MzY1LTM2OQogICAgLy8gY2xhaW1SYWZmbGVQcml6ZSgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24sCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czo6UmFmZmxlUGx1Z2luLmRlbGV0ZVJhZmZsZUFwcGxpY2F0aW9uW3JvdXRpbmddKCkgLT4gdm9pZDoKZGVsZXRlUmFmZmxlQXBwbGljYXRpb246CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozODEtMzg1CiAgICAvLyBkZWxldGVSYWZmbGVBcHBsaWNhdGlvbigKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24KICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBjb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozODgKICAgIC8vIGFzc2VydChhcHBJZC5jcmVhdG9yID09PSB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywgRVJSX0NSRUFUT1JfTk9UX1JBRkZMRV9GQUNUT1JZKQogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MjYKICAgIC8vIGZhY3RvcnkgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IFJhZmZsZVBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAicmFmZmxlX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozODgKICAgIC8vIGFzc2VydChhcHBJZC5jcmVhdG9yID09PSB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywgRVJSX0NSRUFUT1JfTk9UX1JBRkZMRV9GQUNUT1JZKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gQ3JlYXRvciBpcyBub3QgdGhlIHJhZmZsZSBmYWN0b3J5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yYWZmbGUvY29udHJhY3QuYWxnby50czozOTAtMzk0CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSYWZmbGUucHJvdG90eXBlLmRlbGV0ZUFwcGxpY2F0aW9uPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MzkzCiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgc3dhcAogICAgdW5jb3ZlciAzCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MzkwLTM5NAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmFmZmxlLnByb3RvdHlwZS5kZWxldGVBcHBsaWNhdGlvbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDI0ODdjMzJjIC8vIG1ldGhvZCAiZGVsZXRlQXBwbGljYXRpb24oKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmFmZmxlL2NvbnRyYWN0LmFsZ28udHM6MzgxLTM4NQogICAgLy8gZGVsZXRlUmFmZmxlQXBwbGljYXRpb24oCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo6QWtpdGFCYXNlQ29udHJhY3QudXBkYXRlQWtpdGFEQU9bcm91dGluZ10oKSAtPiB2b2lkOgp1cGRhdGVBa2l0YURBTzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjM4CiAgICAvLyB1cGRhdGVBa2l0YURBTyhha2l0YURBTzogQXBwbGljYXRpb24pOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozOQogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIHR4biBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMyCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjIDQgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjMyCiAgICAvLyBjb25zdCBbd2FsbGV0SURdID0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHRoaXMuYWtpdGFEQU8udmFsdWUsIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzV2FsbGV0KSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBwdXNoYnl0ZXMgIndhbGxldCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjM5CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5nZXRBa2l0YURBT1dhbGxldCgpLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBPbmx5IHRoZSBBa2l0YSBEQU8gY2FuIGNhbGwgdGhpcyBmdW5jdGlvbgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlYyA0IC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo0MAogICAgLy8gdGhpcy5ha2l0YURBTy52YWx1ZSA9IGFraXRhREFPCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzgKICAgIC8vIHVwZGF0ZUFraXRhREFPKGFraXRhREFPOiBBcHBsaWNhdGlvbik6IHZvaWQgewogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgo=", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyAGAAgBBuStVaiLAyYGDnJhZmZsZV9mYWN0b3J5EHNwZW5kaW5nX2FkZHJlc3MEFR98dQQ5Tq6yCWFraXRhX2Rhbwx0aWNrZXRfYXNzZXQxGRREMRhBAHiCCwRXtTZsBGlhnr0EgBIngwRE4/RVBKQ4XhsEDuVj5wS9MgRlBHcrJIcEM+kslASFTe3gBNmjX6Q2GgCOCwBuAsMEDAUFBdEGHwZ5BscHFQAiAAEAgBwVH3x1AAAAAAAAe9QAAAAAAMgX1AAAAAAAAEnUsCRDJEOABM2a1n42GgCOAQASAIoCAYv+QAADMgOJi/9yCESJNhoBSSJZgQIISwEVEkRXAgA2GgJJFSMSRBeAB3ZlcnNpb25PAmcoTGckQ4AANhoBSRUjEkQXSTYaAkkVJBJEIlNMNhoDSU4CSRUjEkQXSU4CNhoESRUjEkQXSU4DNhoFSU4ESRUjEkQXTgM2GgZJTgQVIxJENhoHSU4EFSMSRDYaCElOBBUjEkQ2GglJTgQVIxJENhoKSU4EFSMSRDYaC0lOBBWBIBJENhoMSU4ESSJZgQIITBUSRDYaDUlOBEkiWYEgC4ECCEwVEkQ2Gg5JTgQVIxJETwIpZUhJTgNLAnAASA5EIihlRHIIRExwAEUBQAAtsSIoZURJcghEMhCyCLIHSwFJsgAkshAisgG2K7IaSxCyGrIAshglshAisgGzIkUSSw1BAEEyEEUSIihlRHIIREsOcABFAUAALbEiKGVESXIIRDIQsgiyB0sBSbIAJLIQIrIBtiuyGksQshqyALIYJbIQIrIBs0sKQQB2SxEyEAhFEiIoZURyCERLC3AARQFAAF+xIihlRIAEM/eICLIaSwxJTgKyGkmyGEsCSU4CsgAlshAisgGztD5JVwQATFcABCoSREkVIxJEF7FLAXIIRLIHsghLAbIAJLIQIrIBtiuyGk8CshqyGLIAJbIQIrIBsyEEMgEISxIIIihlRElyCERLAXIIRLFPA7IITLIHSwJJsgAkshAisgG2SxCyEUsPshJMshRJsgCBBLIQIrIBtksRSxOI/cWABBhYTyCyGksOshpLDLIaSwuyGksKshpLCbIaSwiyGksHshpLBrIaSwWyGksEshqyILIAshglshAisgGztwI+SVcEAExXAAQqEkRJFSMSRCpMULAkQzYaAUkVIxJEF0k2GgJJFSQSRCJTTDYaA0lOAkkVIxJEFzYaBElOA0kVIxJEFzYaBUlOBBUjEkQ2GgZJTgQVIxJENhoHSU4EFSMSRDYaCElOBBUjEkQ2GglJTgQVIxJENhoKSU4EFYEgEkQ2GgtJTgQVIxJETwIpZUhJTgMiJwRlREsDcgdETIADYWFsZUiBGFtyCEQSREsCgAVvd25lcmVISwESRLEiKGVEcghEgASt+SrkshqyGk8CshiyACWyECKyAbMiTEAABDIQRQEhBDIBCEsBCCIoZURJcghEsU8CsgiyB0sCSbIAJLIQIrIBtksNSw+I/HiABCkkVl6yGksNshpLDLIaSwuyGksKshpLCbIaSwiyGksHshpLBrIaSwWyGrIgsgCyGCWyECKyAbO3AT5JVwQATFcABCoSREkVIxJEKkxQsCRDNhoBSRUjEkQXSTYaAkkVJBJEIlNOAjYaA0kVIxJEF0lOBDYaBEkVIxJEF04ENhoFSU4FFYEgEkQ2GgZOBEwpZUhOA0lyB0QiKGVEcghEEkQnBWVIF0lOBEAAQrFLB0lyCERLCCEFCLIIsgdPA0myACSyECKyAbZPA08DiPuogASXOcu2shpLBbIaSwSyGrIgsgCyGCWyECKyAbMkQ7FLB0lyCEQhBbIIsgdPA0lOArIAJLIQIrIBtklyCERLBbIRSwiyErIUSwGyAIEEshAisgG2TwNPA4j7TYAE46IdUrIaSwWyGksEshqyILIYsgAlshAisgGzQv+iNhoBSRUjEkQXSTYaAkkVJBJEIlNOAjYaA0kVIxJEF0lOBDYaBEkVIxJEF04ENhoFTgRMKWVITgNJcgdEIihlRHIIRBJEJwVlSBdJTgRAADuxSwZJcghESweyCLIHTwNJsgAkshAisgG2TwNPA4j6vYAEBUowILIaSwSyGrIgsgCyGCWyECKyAbMkQ7FLBklyCERLBbIRSweyErIUTwNJsgCBBLIQIrIBtk8DTwOI+n2ABEghIcOyGksEshqyILIAshglshAisgGzQv+9NhoBSRUjEkQXNhoCSRUkEkQiUzYaA0kVIxJEF0sCKWVITgJJcgdEIihlRHIIRBJEsUxPA4j6KoAEaWUB3rIasiCyGLIAJbIQIrIBsyRDNhoBSRUjEkQXNhoCSRUkEkQiUzYaA0kVIxJEFzYaBEkVIxJESwMpZUhOAksBcgdEIihlRHIIRBJEsU8DTwSI+dKABL0bJ9GyGrIgshqyGLIAJbIQIrIBsyRDNhoBSRUjEkQXNhoCSRUkEkQiUzYaA0kVIxJEF0sCKWVITgJJcgdEIihlRHIIRBJEsUxPA4j5goAEZfypi7IasiCyGLIAJbIQIrIBsyRDNhoBSRUjEkQXNhoCSRUkEkQiUzYaA0kVIxJEF0sCKWVITgJJcgdEIihlRHIIRBJEsUxPA4j5NIAEJIfDLLIasiCyGLIAJbIQIrIBsyRDNhoBSRUjEkQXMQAiJwRlRIAGd2FsbGV0ZUhyCEQSRCcETGckQw==", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var RafflePluginParamsFactory = class _RafflePluginParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "create":
          case "create(string,uint64)void":
            return _RafflePluginParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs create ABI call params for the RafflePlugin smart contract using the create(string,uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params) {
        return {
          ...params,
          method: "create(string,uint64)void",
          args: Array.isArray(params.args) ? params.args : [params.args.version, params.args.factory]
        };
      }
    };
  }
  /**
   * Constructs a no op call for the newRaffle(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,string,byte[32][],uint64)uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static newRaffle(params) {
    return {
      ...params,
      method: "newRaffle(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,string,byte[32][],uint64)uint64",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.prizeId, params.args.prizeAmount, params.args.ticketAssetId, params.args.startTimestamp, params.args.endTimestamp, params.args.minTickets, params.args.maxTickets, params.args.gateId, params.args.marketplace, params.args.name, params.args.proof, params.args.weightsListCount]
    };
  }
  /**
   * Constructs a no op call for the newPrizeBoxRaffle(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,uint64)uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static newPrizeBoxRaffle(params) {
    return {
      ...params,
      method: "newPrizeBoxRaffle(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,uint64)uint64",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.prizeBox, params.args.ticketAssetId, params.args.startTimestamp, params.args.endTimestamp, params.args.minTickets, params.args.maxTickets, params.args.gateId, params.args.marketplace, params.args.weightsListCount]
    };
  }
  /**
   * Constructs a no op call for the enter(uint64,bool,uint64,uint64,address,byte[][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static enter(params) {
    return {
      ...params,
      method: "enter(uint64,bool,uint64,uint64,address,byte[][])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.amount, params.args.marketplace, params.args.args]
    };
  }
  /**
   * Constructs a no op call for the add(uint64,bool,uint64,uint64,byte[][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static add(params) {
    return {
      ...params,
      method: "add(uint64,bool,uint64,uint64,byte[][])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.amount, params.args.args]
    };
  }
  /**
   * Constructs a no op call for the raffle(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static raffle(params) {
    return {
      ...params,
      method: "raffle(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId]
    };
  }
  /**
   * Constructs a no op call for the findWinner(uint64,bool,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static findWinner(params) {
    return {
      ...params,
      method: "findWinner(uint64,bool,uint64,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.iterationAmount]
    };
  }
  /**
   * Constructs a no op call for the claimRafflePrize(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static claimRafflePrize(params) {
    return {
      ...params,
      method: "claimRafflePrize(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId]
    };
  }
  /**
   * Constructs a no op call for the deleteRaffleApplication(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static deleteRaffleApplication(params) {
    return {
      ...params,
      method: "deleteRaffleApplication(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId]
    };
  }
  /**
   * Constructs a no op call for the updateAkitaDAO(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDao(params) {
    return {
      ...params,
      method: "updateAkitaDAO(uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.akitaDao]
    };
  }
  /**
   * Constructs a no op call for the opUp()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static opUp(params) {
    return {
      ...params,
      method: "opUp()void",
      args: Array.isArray(params.args) ? params.args : []
    };
  }
  /**
   * Constructs a no op call for the mbr()(uint64,uint64,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mbr(params) {
    return {
      ...params,
      method: "mbr()(uint64,uint64,uint64)",
      args: Array.isArray(params.args) ? params.args : []
    };
  }
};
var RafflePluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `RafflePluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory18({
      ...params,
      appSpec: APP_SPEC18
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC18;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new RafflePluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new RafflePluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the RafflePlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    var _a;
    const result = await this.appFactory.deploy({
      ...params,
      createParams: ((_a = params.createParams) == null ? void 0 : _a.method) ? RafflePluginParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams : void 0
    });
    return { result: result.result, appClient: new RafflePluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the RafflePlugin smart contract using the create(string,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params) => {
        return this.appFactory.params.create(RafflePluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the RafflePlugin smart contract using the create(string,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params) => {
        return this.appFactory.createTransaction.create(RafflePluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the RafflePlugin smart contract using an ABI method call using the create(string,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params) => {
        const result = await this.appFactory.send.create(RafflePluginParamsFactory.create.create(params));
        return { result: { ...result.result, return: result.result.return }, appClient: new RafflePluginClient(result.appClient) };
      }
    }
  };
};
var RafflePluginClient = class _RafflePluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient18 ? appClientOrParams : new _AppClient18({
      ...appClientOrParams,
      appSpec: APP_SPEC18
    });
  }
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue(method, returnValue) {
    return returnValue !== void 0 ? getArc56ReturnValue11(returnValue, this.appClient.getABIMethod(method), APP_SPEC18.structs) : void 0;
  }
  /**
   * Returns a new `RafflePluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _RafflePluginClient(await _AppClient18.fromCreatorAndName({ ...params, appSpec: APP_SPEC18 }));
  }
  /**
   * Returns an `RafflePluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _RafflePluginClient(await _AppClient18.fromNetwork({ ...params, appSpec: APP_SPEC18 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the RafflePlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `newRaffle(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,string,byte[32][],uint64)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    newRaffle: (params) => {
      return this.appClient.params.call(RafflePluginParamsFactory.newRaffle(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `newPrizeBoxRaffle(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,uint64)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    newPrizeBoxRaffle: (params) => {
      return this.appClient.params.call(RafflePluginParamsFactory.newPrizeBoxRaffle(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `enter(uint64,bool,uint64,uint64,address,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    enter: (params) => {
      return this.appClient.params.call(RafflePluginParamsFactory.enter(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `add(uint64,bool,uint64,uint64,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    add: (params) => {
      return this.appClient.params.call(RafflePluginParamsFactory.add(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `raffle(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    raffle: (params) => {
      return this.appClient.params.call(RafflePluginParamsFactory.raffle(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `findWinner(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    findWinner: (params) => {
      return this.appClient.params.call(RafflePluginParamsFactory.findWinner(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `claimRafflePrize(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    claimRafflePrize: (params) => {
      return this.appClient.params.call(RafflePluginParamsFactory.claimRafflePrize(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `deleteRaffleApplication(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    deleteRaffleApplication: (params) => {
      return this.appClient.params.call(RafflePluginParamsFactory.deleteRaffleApplication(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDao: (params) => {
      return this.appClient.params.call(RafflePluginParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.params.call(RafflePluginParamsFactory.opUp(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `mbr()(uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    mbr: (params = { args: [] }) => {
      return this.appClient.params.call(RafflePluginParamsFactory.mbr(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the RafflePlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `newRaffle(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,string,byte[32][],uint64)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    newRaffle: (params) => {
      return this.appClient.createTransaction.call(RafflePluginParamsFactory.newRaffle(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `newPrizeBoxRaffle(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,uint64)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    newPrizeBoxRaffle: (params) => {
      return this.appClient.createTransaction.call(RafflePluginParamsFactory.newPrizeBoxRaffle(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `enter(uint64,bool,uint64,uint64,address,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    enter: (params) => {
      return this.appClient.createTransaction.call(RafflePluginParamsFactory.enter(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `add(uint64,bool,uint64,uint64,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    add: (params) => {
      return this.appClient.createTransaction.call(RafflePluginParamsFactory.add(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `raffle(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    raffle: (params) => {
      return this.appClient.createTransaction.call(RafflePluginParamsFactory.raffle(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `findWinner(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    findWinner: (params) => {
      return this.appClient.createTransaction.call(RafflePluginParamsFactory.findWinner(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `claimRafflePrize(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    claimRafflePrize: (params) => {
      return this.appClient.createTransaction.call(RafflePluginParamsFactory.claimRafflePrize(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `deleteRaffleApplication(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    deleteRaffleApplication: (params) => {
      return this.appClient.createTransaction.call(RafflePluginParamsFactory.deleteRaffleApplication(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDao: (params) => {
      return this.appClient.createTransaction.call(RafflePluginParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.createTransaction.call(RafflePluginParamsFactory.opUp(params));
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `mbr()(uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    mbr: (params = { args: [] }) => {
      return this.appClient.createTransaction.call(RafflePluginParamsFactory.mbr(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the RafflePlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `newRaffle(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,string,byte[32][],uint64)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    newRaffle: async (params) => {
      const result = await this.appClient.send.call(RafflePluginParamsFactory.newRaffle(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `newPrizeBoxRaffle(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,uint64)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    newPrizeBoxRaffle: async (params) => {
      const result = await this.appClient.send.call(RafflePluginParamsFactory.newPrizeBoxRaffle(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `enter(uint64,bool,uint64,uint64,address,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    enter: async (params) => {
      const result = await this.appClient.send.call(RafflePluginParamsFactory.enter(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `add(uint64,bool,uint64,uint64,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    add: async (params) => {
      const result = await this.appClient.send.call(RafflePluginParamsFactory.add(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `raffle(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    raffle: async (params) => {
      const result = await this.appClient.send.call(RafflePluginParamsFactory.raffle(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `findWinner(uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    findWinner: async (params) => {
      const result = await this.appClient.send.call(RafflePluginParamsFactory.findWinner(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `claimRafflePrize(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    claimRafflePrize: async (params) => {
      const result = await this.appClient.send.call(RafflePluginParamsFactory.claimRafflePrize(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `deleteRaffleApplication(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    deleteRaffleApplication: async (params) => {
      const result = await this.appClient.send.call(RafflePluginParamsFactory.deleteRaffleApplication(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDao: async (params) => {
      const result = await this.appClient.send.call(RafflePluginParamsFactory.updateAkitaDao(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    opUp: async (params = { args: [] }) => {
      const result = await this.appClient.send.call(RafflePluginParamsFactory.opUp(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RafflePlugin smart contract using the `mbr()(uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mbr: async (params = { args: [] }) => {
      const result = await this.appClient.send.call(RafflePluginParamsFactory.mbr(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _RafflePluginClient(this.appClient.clone(params));
  }
  /**
   * Makes a readonly (simulated) call to the RafflePlugin smart contract using the `mbr()(uint64,uint64,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async mbr(params = { args: [] }) {
    const result = await this.appClient.send.call(RafflePluginParamsFactory.mbr(params));
    return result.return;
  }
  /**
   * Methods to access state for the current RafflePlugin app
   */
  state = {
    /**
     * Methods to access global state for the current RafflePlugin app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async () => {
        const result = await this.appClient.state.global.getAll();
        return {
          factory: result.factory,
          version: result.version,
          akitaDao: result.akitaDAO
        };
      },
      /**
       * Get the current value of the factory key in global state
       */
      factory: async () => {
        return await this.appClient.state.global.getValue("factory");
      },
      /**
       * Get the current value of the version key in global state
       */
      version: async () => {
        return await this.appClient.state.global.getValue("version");
      },
      /**
       * Get the current value of the akitaDAO key in global state
       */
      akitaDao: async () => {
        return await this.appClient.state.global.getValue("akitaDAO");
      }
    }
  };
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a newRaffle(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,string,byte[32][],uint64)uint64 method call against the RafflePlugin contract
       */
      newRaffle(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.newRaffle(params)));
        resultMappers.push((v) => client.decodeReturnValue("newRaffle(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,string,byte[32][],uint64)uint64", v));
        return this;
      },
      /**
       * Add a newPrizeBoxRaffle(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,uint64)uint64 method call against the RafflePlugin contract
       */
      newPrizeBoxRaffle(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.newPrizeBoxRaffle(params)));
        resultMappers.push((v) => client.decodeReturnValue("newPrizeBoxRaffle(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,uint64)uint64", v));
        return this;
      },
      /**
       * Add a enter(uint64,bool,uint64,uint64,address,byte[][])void method call against the RafflePlugin contract
       */
      enter(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.enter(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a add(uint64,bool,uint64,uint64,byte[][])void method call against the RafflePlugin contract
       */
      add(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.add(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a raffle(uint64,bool,uint64)void method call against the RafflePlugin contract
       */
      raffle(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.raffle(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a findWinner(uint64,bool,uint64,uint64)void method call against the RafflePlugin contract
       */
      findWinner(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.findWinner(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a claimRafflePrize(uint64,bool,uint64)void method call against the RafflePlugin contract
       */
      claimRafflePrize(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.claimRafflePrize(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a deleteRaffleApplication(uint64,bool,uint64)void method call against the RafflePlugin contract
       */
      deleteRaffleApplication(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.deleteRaffleApplication(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a updateAkitaDAO(uint64)void method call against the RafflePlugin contract
       */
      updateAkitaDao(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDao(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a opUp()void method call against the RafflePlugin contract
       */
      opUp(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.opUp(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a mbr()(uint64,uint64,uint64) method call against the RafflePlugin contract
       */
      mbr(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mbr(params)));
        resultMappers.push((v) => client.decodeReturnValue("mbr()(uint64,uint64,uint64)", v));
        return this;
      },
      /**
       * Add a clear state call to the RafflePlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/raffle.ts
var RafflePluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: RafflePluginFactory, ...params });
  }
  newRaffle(args) {
    const methodName = "newRaffle";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.newRaffle({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  enter(args) {
    const methodName = "enter";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.enter({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  add(args) {
    const methodName = "add";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.add({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
};

// src/generated/RewardsPluginClient.ts
import { getArc56ReturnValue as getArc56ReturnValue12, getABIStructFromABITuple as getABIStructFromABITuple12 } from "@algorandfoundation/algokit-utils/types/app-arc56";
import {
  AppClient as _AppClient19
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory19 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC19 = { "name": "RewardsPlugin", "structs": { "RewardsMBRData": [{ "name": "disbursements", "type": "uint64" }, { "name": "userAllocations", "type": "uint64" }] }, "methods": [{ "name": "create", "args": [{ "type": "string", "name": "version" }, { "type": "uint64", "name": "akitaDAO" }], "returns": { "type": "void" }, "actions": { "create": ["NoOp"], "call": [] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "createDisbursement", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "string", "name": "title" }, { "type": "uint64", "name": "timeToUnlock" }, { "type": "uint64", "name": "expiration" }, { "type": "string", "name": "note" }], "returns": { "type": "uint64" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "editDisbursement", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "id" }, { "type": "string", "name": "title" }, { "type": "uint64", "name": "timeToUnlock" }, { "type": "uint64", "name": "expiration" }, { "type": "string", "name": "note" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "createUserAllocations", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "id" }, { "type": "(address,uint64)[]", "name": "allocations" }, { "type": "uint64", "name": "sum" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "createAsaUserAllocations", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "id" }, { "type": "uint64", "name": "assetID" }, { "type": "(address,uint64)[]", "name": "allocations" }, { "type": "uint64", "name": "sum" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "finalizeDisbursement", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "id" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "claimRewards", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "(uint64,uint64)[]", "name": "rewards" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "reclaimRewards", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "id" }, { "type": "(address,uint64)[]", "name": "reclaims" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "updateAkitaDAO", "args": [{ "type": "uint64", "name": "akitaDAO" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "opUp", "args": [], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "mbr", "args": [{ "type": "string", "name": "title" }, { "type": "string", "name": "note" }], "returns": { "type": "(uint64,uint64)", "struct": "RewardsMBRData" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": true, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 1, "bytes": 1 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": { "version": { "keyType": "AVMString", "valueType": "AVMString", "key": "dmVyc2lvbg==", "desc": "the current version of the contract" }, "akitaDAO": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "YWtpdGFfZGFv", "desc": "the app ID of the Akita DAO" } }, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": [], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [378], "errorMessage": "Bytes has valid prefix" }, { "pc": [48], "errorMessage": "OnCompletion must be NoOp" }, { "pc": [1169], "errorMessage": "Only the Akita DAO can call this function" }, { "pc": [163, 303, 613, 775, 793, 816, 1167], "errorMessage": "application exists" }, { "pc": [293, 469, 588, 751, 915, 1001, 1095, 1154], "errorMessage": "check GlobalState exists" }, { "pc": [990], "errorMessage": "invalid number of bytes for (len+(uint64,uint64)[])" }, { "pc": [569, 730, 1084], "errorMessage": "invalid number of bytes for (len+(uint8[32],uint64)[])" }, { "pc": [177, 238, 271, 429, 458, 1187, 1203], "errorMessage": "invalid number of bytes for (len+utf8[])" }, { "pc": [223, 406, 542, 685, 894, 972, 1058], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [188, 214, 250, 258, 383, 397, 416, 437, 445, 533, 552, 577, 675, 698, 706, 738, 885, 904, 963, 1049, 1068, 1147], "errorMessage": "invalid number of bytes for uint64" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCA4IDEgMgogICAgYnl0ZWNibG9jayAiYWtpdGFfZGFvIiAic3BlbmRpbmdfYWRkcmVzcyIgImFhbCIgMHgxNTFmN2M3NQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjEyCiAgICAvLyBleHBvcnQgY2xhc3MgUmV3YXJkc1BsdWdpbiBleHRlbmRzIGNsYXNzZXMoQmFzZVJld2FyZHMsIEFraXRhQmFzZUNvbnRyYWN0KSB7CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIG11c3QgYmUgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGJ6IG1haW5fY3JlYXRlX05vT3BAMTYKICAgIHB1c2hieXRlc3MgMHgwOGMyNWVmZiAweGFlZTAyM2M1IDB4NTA0ZTQ3ZmQgMHg1YzJjOTEwZiAweDg2OTllZDRjIDB4ZTQ0MGEzYTYgMHg3YjFkMjIzNiAweDMzZTkyYzk0IDB4ODU0ZGVkZTAgMHhkNTRiYmFkOSAvLyBtZXRob2QgImNyZWF0ZURpc2J1cnNlbWVudCh1aW50NjQsYm9vbCxzdHJpbmcsdWludDY0LHVpbnQ2NCxzdHJpbmcpdWludDY0IiwgbWV0aG9kICJlZGl0RGlzYnVyc2VtZW50KHVpbnQ2NCxib29sLHVpbnQ2NCxzdHJpbmcsdWludDY0LHVpbnQ2NCxzdHJpbmcpdm9pZCIsIG1ldGhvZCAiY3JlYXRlVXNlckFsbG9jYXRpb25zKHVpbnQ2NCxib29sLHVpbnQ2NCwoYWRkcmVzcyx1aW50NjQpW10sdWludDY0KXZvaWQiLCBtZXRob2QgImNyZWF0ZUFzYVVzZXJBbGxvY2F0aW9ucyh1aW50NjQsYm9vbCx1aW50NjQsdWludDY0LChhZGRyZXNzLHVpbnQ2NClbXSx1aW50NjQpdm9pZCIsIG1ldGhvZCAiZmluYWxpemVEaXNidXJzZW1lbnQodWludDY0LGJvb2wsdWludDY0KXZvaWQiLCBtZXRob2QgImNsYWltUmV3YXJkcyh1aW50NjQsYm9vbCwodWludDY0LHVpbnQ2NClbXSl2b2lkIiwgbWV0aG9kICJyZWNsYWltUmV3YXJkcyh1aW50NjQsYm9vbCx1aW50NjQsKGFkZHJlc3MsdWludDY0KVtdKXZvaWQiLCBtZXRob2QgInVwZGF0ZUFraXRhREFPKHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJvcFVwKCl2b2lkIiwgbWV0aG9kICJtYnIoc3RyaW5nLHN0cmluZykodWludDY0LHVpbnQ2NCkiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBjcmVhdGVEaXNidXJzZW1lbnQgZWRpdERpc2J1cnNlbWVudCBjcmVhdGVVc2VyQWxsb2NhdGlvbnMgY3JlYXRlQXNhVXNlckFsbG9jYXRpb25zIGZpbmFsaXplRGlzYnVyc2VtZW50IGNsYWltUmV3YXJkcyByZWNsYWltUmV3YXJkcyB1cGRhdGVBa2l0YURBTyBtYWluX29wVXBfcm91dGVAMTMgbWJyCiAgICBlcnIKCm1haW5fb3BVcF9yb3V0ZUAxMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjQzCiAgICAvLyBvcFVwKCk6IHZvaWQgeyB9CiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgptYWluX2NyZWF0ZV9Ob09wQDE2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjEyCiAgICAvLyBleHBvcnQgY2xhc3MgUmV3YXJkc1BsdWdpbiBleHRlbmRzIGNsYXNzZXMoQmFzZVJld2FyZHMsIEFraXRhQmFzZUNvbnRyYWN0KSB7CiAgICBwdXNoYnl0ZXMgMHhjZDlhZDY3ZSAvLyBtZXRob2QgImNyZWF0ZShzdHJpbmcsdWludDY0KXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBjcmVhdGUKICAgIGVycgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OnJla2V5QWRkcmVzcyhyZWtleUJhY2s6IHVpbnQ2NCwgd2FsbGV0OiB1aW50NjQpIC0+IGJ5dGVzOgpyZWtleUFkZHJlc3M6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMQogICAgLy8gZXhwb3J0IGZ1bmN0aW9uIHJla2V5QWRkcmVzcyhyZWtleUJhY2s6IGJvb2xlYW4sIHdhbGxldDogQXBwbGljYXRpb24pOiBBY2NvdW50IHsKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjIKICAgIC8vIGlmICghcmVrZXlCYWNrKSB7CiAgICBmcmFtZV9kaWcgLTIKICAgIGJueiByZWtleUFkZHJlc3NfYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMwogICAgLy8gcmV0dXJuIEdsb2JhbC56ZXJvQWRkcmVzcwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICByZXRzdWIKCnJla2V5QWRkcmVzc19hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyNgogICAgLy8gcmV0dXJuIHdhbGxldC5hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czo6UmV3YXJkc1BsdWdpbi5jcmVhdGVbcm91dGluZ10oKSAtPiB2b2lkOgpjcmVhdGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MTQKICAgIC8vIEBhYmltZXRob2QoeyBvbkNyZWF0ZTogJ3JlcXVpcmUnIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyNwogICAgLy8gdmVyc2lvbiA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5VmVyc2lvbiB9KQogICAgcHVzaGJ5dGVzICJ2ZXJzaW9uIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjE2CiAgICAvLyB0aGlzLnZlcnNpb24udmFsdWUgPSB2ZXJzaW9uCiAgICB1bmNvdmVyIDIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czoxNwogICAgLy8gdGhpcy5ha2l0YURBTy52YWx1ZSA9IGFraXRhREFPCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjE0CiAgICAvLyBAYWJpbWV0aG9kKHsgb25DcmVhdGU6ICdyZXF1aXJlJyB9KQogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czo6UmV3YXJkc1BsdWdpbi5jcmVhdGVEaXNidXJzZW1lbnRbcm91dGluZ10oKSAtPiB2b2lkOgpjcmVhdGVEaXNidXJzZW1lbnQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MjAtMjcKICAgIC8vIGNyZWF0ZURpc2J1cnNlbWVudCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICB0aXRsZTogc3RyaW5nLAogICAgLy8gICB0aW1lVG9VbmxvY2s6IHVpbnQ2NCwKICAgIC8vICAgZXhwaXJhdGlvbjogdWludDY0LAogICAgLy8gICBub3RlOiBzdHJpbmcKICAgIC8vICk6IHVpbnQ2NCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGR1cAogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGR1cAogICAgZXh0cmFjdCAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMSAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czozMAogICAgLy8gY29uc3QgeyBkaXNidXJzZW1lbnRzOiBtYnJBbW91bnQgfSA9IHRoaXMubWJyKHRpdGxlLCBub3RlKQogICAgdW5jb3ZlciA1CiAgICBzd2FwCiAgICBjYWxsc3ViIHNtYXJ0X2NvbnRyYWN0cy9yZXdhcmRzL2Jhc2UudHM6OkJhc2VSZXdhcmRzLm1icgogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MzEKICAgIC8vIGNvbnN0IHJld2FyZHNJRCA9IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MzEKICAgIC8vIGNvbnN0IHJld2FyZHNJRCA9IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMiAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjMxCiAgICAvLyBjb25zdCByZXdhcmRzSUQgPSBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkucmV3YXJkcwogICAgaW50Y18xIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MzMtNDgKICAgIC8vIHJldHVybiBhYmlDYWxsPHR5cGVvZiBSZXdhcmRzLnByb3RvdHlwZS5jcmVhdGVEaXNidXJzZW1lbnQ+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogcmV3YXJkc0lELAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIGFtb3VudDogbWJyQW1vdW50LAogICAgLy8gICAgICAgcmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHJld2FyZHNJRCkuYWRkcmVzcywKICAgIC8vICAgICB9KSwKICAgIC8vICAgICB0aXRsZSwKICAgIC8vICAgICB0aW1lVG9VbmxvY2ssCiAgICAvLyAgICAgZXhwaXJhdGlvbiwKICAgIC8vICAgICBub3RlLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czo0MAogICAgLy8gcmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHJld2FyZHNJRCkuYWRkcmVzcywKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgc3dhcAogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGRpZyAxCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjM3LTQxCiAgICAvLyBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFtb3VudDogbWJyQW1vdW50LAogICAgLy8gICByZWNlaXZlcjogQXBwbGljYXRpb24ocmV3YXJkc0lEKS5hZGRyZXNzLAogICAgLy8gfSksCiAgICBpbnRjXzIgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MzMtNDgKICAgIC8vIHJldHVybiBhYmlDYWxsPHR5cGVvZiBSZXdhcmRzLnByb3RvdHlwZS5jcmVhdGVEaXNidXJzZW1lbnQ+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogcmV3YXJkc0lELAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIGFtb3VudDogbWJyQW1vdW50LAogICAgLy8gICAgICAgcmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHJld2FyZHNJRCkuYWRkcmVzcywKICAgIC8vICAgICB9KSwKICAgIC8vICAgICB0aXRsZSwKICAgIC8vICAgICB0aW1lVG9VbmxvY2ssCiAgICAvLyAgICAgZXhwaXJhdGlvbiwKICAgIC8vICAgICBub3RlLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjQ3CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgdW5jb3ZlciA2CiAgICB1bmNvdmVyIDcKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MzMtNDgKICAgIC8vIHJldHVybiBhYmlDYWxsPHR5cGVvZiBSZXdhcmRzLnByb3RvdHlwZS5jcmVhdGVEaXNidXJzZW1lbnQ+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogcmV3YXJkc0lELAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIGFtb3VudDogbWJyQW1vdW50LAogICAgLy8gICAgICAgcmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHJld2FyZHNJRCkuYWRkcmVzcywKICAgIC8vICAgICB9KSwKICAgIC8vICAgICB0aXRsZSwKICAgIC8vICAgICB0aW1lVG9VbmxvY2ssCiAgICAvLyAgICAgZXhwaXJhdGlvbiwKICAgIC8vICAgICBub3RlLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweDFjOWViYmRiIC8vIG1ldGhvZCAiY3JlYXRlRGlzYnVyc2VtZW50KHBheSxzdHJpbmcsdWludDY0LHVpbnQ2NCxzdHJpbmcpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGdpdHhuIDEgTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzMgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBCeXRlcyBoYXMgdmFsaWQgcHJlZml4CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjIwLTI3CiAgICAvLyBjcmVhdGVEaXNidXJzZW1lbnQoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgdGl0bGU6IHN0cmluZywKICAgIC8vICAgdGltZVRvVW5sb2NrOiB1aW50NjQsCiAgICAvLyAgIGV4cGlyYXRpb246IHVpbnQ2NCwKICAgIC8vICAgbm90ZTogc3RyaW5nCiAgICAvLyApOiB1aW50NjQgewogICAgYnl0ZWNfMyAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czo6UmV3YXJkc1BsdWdpbi5lZGl0RGlzYnVyc2VtZW50W3JvdXRpbmddKCkgLT4gdm9pZDoKZWRpdERpc2J1cnNlbWVudDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czo1MS01OQogICAgLy8gZWRpdERpc2J1cnNlbWVudCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBpZDogdWludDY0LAogICAgLy8gICB0aXRsZTogc3RyaW5nLAogICAgLy8gICB0aW1lVG9VbmxvY2s6IHVpbnQ2NCwKICAgIC8vICAgZXhwaXJhdGlvbjogdWludDY0LAogICAgLy8gICBub3RlOiBzdHJpbmcKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDYKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA3CiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjYyLTY3CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSZXdhcmRzLnByb3RvdHlwZS5lZGl0RGlzYnVyc2VtZW50Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzLAogICAgLy8gICBhcmdzOiBbaWQsIHRpdGxlLCB0aW1lVG9VbmxvY2ssIGV4cGlyYXRpb24sIG5vdGVdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czo2NAogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjY0CiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnJld2FyZHMsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMiAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjY0CiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnJld2FyZHMsCiAgICBpbnRjXzEgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czo2NgogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIHVuY292ZXIgNwogICAgdW5jb3ZlciA4CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjYyLTY3CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSZXdhcmRzLnByb3RvdHlwZS5lZGl0RGlzYnVyc2VtZW50Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzLAogICAgLy8gICBhcmdzOiBbaWQsIHRpdGxlLCB0aW1lVG9VbmxvY2ssIGV4cGlyYXRpb24sIG5vdGVdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDhmNDkyNjJkIC8vIG1ldGhvZCAiZWRpdERpc2J1cnNlbWVudCh1aW50NjQsc3RyaW5nLHVpbnQ2NCx1aW50NjQsc3RyaW5nKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA3CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA1CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjUxLTU5CiAgICAvLyBlZGl0RGlzYnVyc2VtZW50KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGlkOiB1aW50NjQsCiAgICAvLyAgIHRpdGxlOiBzdHJpbmcsCiAgICAvLyAgIHRpbWVUb1VubG9jazogdWludDY0LAogICAgLy8gICBleHBpcmF0aW9uOiB1aW50NjQsCiAgICAvLyAgIG5vdGU6IHN0cmluZwogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjpSZXdhcmRzUGx1Z2luLmNyZWF0ZVVzZXJBbGxvY2F0aW9uc1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmNyZWF0ZVVzZXJBbGxvY2F0aW9uczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czo3MC03NgogICAgLy8gY3JlYXRlVXNlckFsbG9jYXRpb25zKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGlkOiB1aW50NjQsCiAgICAvLyAgIGFsbG9jYXRpb25zOiBVc2VyQWxsb2NhdGlvbltdLAogICAgLy8gICBzdW06IHVpbnQ2NAogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBkdXAKICAgIHB1c2hpbnQgNDAgLy8gNDAKICAgICoKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBkaWcgMgogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuKyh1aW50OFszMl0sdWludDY0KVtdKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMSAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czo3OAogICAgLy8gY29uc3QgcmV3YXJkc0lEID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnJld2FyZHMKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czo3OAogICAgLy8gY29uc3QgcmV3YXJkc0lEID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnJld2FyZHMKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQwCiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBieXRlY18yIC8vICJhYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6NzgKICAgIC8vIGNvbnN0IHJld2FyZHNJRCA9IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzCiAgICBpbnRjXzEgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czo4MAogICAgLy8gY29uc3QgbWJyQW1vdW50OiB1aW50NjQgPSB0aGlzLm1icignJywgJycpLnVzZXJBbGxvY2F0aW9ucyAqIGFsbG9jYXRpb25zLmxlbmd0aAogICAgcHVzaGJ5dGVzICIiCiAgICBkdXAKICAgIGNhbGxzdWIgc21hcnRfY29udHJhY3RzL3Jld2FyZHMvYmFzZS50czo6QmFzZVJld2FyZHMubWJyCiAgICBpbnRjXzEgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIHVuY292ZXIgNAogICAgKgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjgyLTk1CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSZXdhcmRzLnByb3RvdHlwZS5jcmVhdGVVc2VyQWxsb2NhdGlvbnM+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogcmV3YXJkc0lELAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIGFtb3VudDogbWJyQW1vdW50ICsgc3VtLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHJld2FyZHNJRCkuYWRkcmVzcywKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBpZCwKICAgIC8vICAgICBhbGxvY2F0aW9ucywKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6ODgKICAgIC8vIGFtb3VudDogbWJyQW1vdW50ICsgc3VtLAogICAgdW5jb3ZlciAyCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6ODkKICAgIC8vIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihyZXdhcmRzSUQpLmFkZHJlc3MsCiAgICBkaWcgMQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGRpZyAxCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjg2LTkwCiAgICAvLyBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFtb3VudDogbWJyQW1vdW50ICsgc3VtLAogICAgLy8gICByZWNlaXZlcjogQXBwbGljYXRpb24ocmV3YXJkc0lEKS5hZGRyZXNzLAogICAgLy8gfSksCiAgICBpbnRjXzIgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6ODItOTUKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFJld2FyZHMucHJvdG90eXBlLmNyZWF0ZVVzZXJBbGxvY2F0aW9ucz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiByZXdhcmRzSUQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgYW1vdW50OiBtYnJBbW91bnQgKyBzdW0sCiAgICAvLyAgICAgICByZWNlaXZlcjogQXBwbGljYXRpb24ocmV3YXJkc0lEKS5hZGRyZXNzLAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGlkLAogICAgLy8gICAgIGFsbG9jYXRpb25zLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjk0CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgdW5jb3ZlciA0CiAgICB1bmNvdmVyIDUKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6ODItOTUKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFJld2FyZHMucHJvdG90eXBlLmNyZWF0ZVVzZXJBbGxvY2F0aW9ucz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiByZXdhcmRzSUQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgYW1vdW50OiBtYnJBbW91bnQgKyBzdW0sCiAgICAvLyAgICAgICByZWNlaXZlcjogQXBwbGljYXRpb24ocmV3YXJkc0lEKS5hZGRyZXNzLAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGlkLAogICAgLy8gICAgIGFsbG9jYXRpb25zLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDU2NTZhY2Y5IC8vIG1ldGhvZCAiY3JlYXRlVXNlckFsbG9jYXRpb25zKHBheSx1aW50NjQsKGFkZHJlc3MsdWludDY0KVtdKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjcwLTc2CiAgICAvLyBjcmVhdGVVc2VyQWxsb2NhdGlvbnMoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgaWQ6IHVpbnQ2NCwKICAgIC8vICAgYWxsb2NhdGlvbnM6IFVzZXJBbGxvY2F0aW9uW10sCiAgICAvLyAgIHN1bTogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMiAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6OlJld2FyZHNQbHVnaW4uY3JlYXRlQXNhVXNlckFsbG9jYXRpb25zW3JvdXRpbmddKCkgLT4gdm9pZDoKY3JlYXRlQXNhVXNlckFsbG9jYXRpb25zOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjk4LTEwNQogICAgLy8gY3JlYXRlQXNhVXNlckFsbG9jYXRpb25zKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGlkOiB1aW50NjQsCiAgICAvLyAgIGFzc2V0SUQ6IHVpbnQ2NCwKICAgIC8vICAgYWxsb2NhdGlvbnM6IFVzZXJBbGxvY2F0aW9uW10sCiAgICAvLyAgIHN1bTogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHN3YXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgY292ZXIgMgogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGR1cAogICAgY292ZXIgMwogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGR1cAogICAgcHVzaGludCA0MCAvLyA0MAogICAgKgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIHVuY292ZXIgMgogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuKyh1aW50OFszMl0sdWludDY0KVtdKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGNvdmVyIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjEwNwogICAgLy8gY29uc3QgcmV3YXJkc0lEID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnJld2FyZHMKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czoxMDcKICAgIC8vIGNvbnN0IHJld2FyZHNJRCA9IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMiAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjEwNwogICAgLy8gY29uc3QgcmV3YXJkc0lEID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnJld2FyZHMKICAgIGludGNfMSAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBjb3ZlciAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MTEwCiAgICAvLyBsZXQgbWJyQW1vdW50OiB1aW50NjQgPSB0aGlzLm1icignJywgJycpLnVzZXJBbGxvY2F0aW9ucyAqIGFsbG9jYXRpb25zLmxlbmd0aAogICAgcHVzaGJ5dGVzICIiCiAgICBkdXAKICAgIGNhbGxzdWIgc21hcnRfY29udHJhY3RzL3Jld2FyZHMvYmFzZS50czo6QmFzZVJld2FyZHMubWJyCiAgICBpbnRjXzEgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIHVuY292ZXIgMgogICAgKgogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjExMQogICAgLy8gaWYgKCFyZXdhcmRzQXBwLmFkZHJlc3MuaXNPcHRlZEluKEFzc2V0KGFzc2V0SUQpKSkgewogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgc3dhcAogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBidXJ5IDEKICAgIGJueiBjcmVhdGVBc2FVc2VyQWxsb2NhdGlvbnNfYWZ0ZXJfaWZfZWxzZUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MTEyCiAgICAvLyBtYnJBbW91bnQgKz0gR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICBnbG9iYWwgQXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgICsKCmNyZWF0ZUFzYVVzZXJBbGxvY2F0aW9uc19hZnRlcl9pZl9lbHNlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MTE1LTEzNAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmV3YXJkcy5wcm90b3R5cGUuY3JlYXRlQXNhVXNlckFsbG9jYXRpb25zPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHJld2FyZHNBcHAsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgYW1vdW50OiBtYnJBbW91bnQsCiAgICAvLyAgICAgICByZWNlaXZlcjogcmV3YXJkc0FwcC5hZGRyZXNzLAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgICBhc3NldEFtb3VudDogc3VtLAogICAgLy8gICAgICAgeGZlckFzc2V0OiBhc3NldElELAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGlkLAogICAgLy8gICAgIGFsbG9jYXRpb25zCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjEyMgogICAgLy8gcmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIGRpZyAxCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBkaWcgMgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjExOS0xMjMKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYW1vdW50OiBtYnJBbW91bnQsCiAgICAvLyAgIHJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyB9KSwKICAgIGludGNfMiAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czoxMjQtMTI5CiAgICAvLyBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIC8vICAgYXNzZXRBbW91bnQ6IHN1bSwKICAgIC8vICAgeGZlckFzc2V0OiBhc3NldElELAogICAgLy8gfSksCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czoxMjYKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgZGlnIDcKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBkaWcgNQogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czoxMjQtMTI5CiAgICAvLyBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIC8vICAgYXNzZXRBbW91bnQ6IHN1bSwKICAgIC8vICAgeGZlckFzc2V0OiBhc3NldElELAogICAgLy8gfSksCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MTE1LTEzNAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmV3YXJkcy5wcm90b3R5cGUuY3JlYXRlQXNhVXNlckFsbG9jYXRpb25zPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHJld2FyZHNBcHAsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgYW1vdW50OiBtYnJBbW91bnQsCiAgICAvLyAgICAgICByZWNlaXZlcjogcmV3YXJkc0FwcC5hZGRyZXNzLAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgICBhc3NldEFtb3VudDogc3VtLAogICAgLy8gICAgICAgeGZlckFzc2V0OiBhc3NldElELAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGlkLAogICAgLy8gICAgIGFsbG9jYXRpb25zCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MTMzCiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgZGlnIDgKICAgIGRpZyAxMAogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czoxMTUtMTM0CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBSZXdhcmRzLnByb3RvdHlwZS5jcmVhdGVBc2FVc2VyQWxsb2NhdGlvbnM+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogcmV3YXJkc0FwcCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICBhbW91bnQ6IG1ickFtb3VudCwKICAgIC8vICAgICAgIHJlY2VpdmVyOiByZXdhcmRzQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IHJld2FyZHNBcHAuYWRkcmVzcywKICAgIC8vICAgICAgIGFzc2V0QW1vdW50OiBzdW0sCiAgICAvLyAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0SUQsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgaWQsCiAgICAvLyAgICAgYWxsb2NhdGlvbnMKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHgzYzYwZGZhMCAvLyBtZXRob2QgImNyZWF0ZUFzYVVzZXJBbGxvY2F0aW9ucyhwYXksYXhmZXIsdWludDY0LChhZGRyZXNzLHVpbnQ2NClbXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA4CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDYKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6OTgtMTA1CiAgICAvLyBjcmVhdGVBc2FVc2VyQWxsb2NhdGlvbnMoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgaWQ6IHVpbnQ2NCwKICAgIC8vICAgYXNzZXRJRDogdWludDY0LAogICAgLy8gICBhbGxvY2F0aW9uczogVXNlckFsbG9jYXRpb25bXSwKICAgIC8vICAgc3VtOiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czo6UmV3YXJkc1BsdWdpbi5maW5hbGl6ZURpc2J1cnNlbWVudFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmZpbmFsaXplRGlzYnVyc2VtZW50OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjEzNy0xNDEKICAgIC8vIGZpbmFsaXplRGlzYnVyc2VtZW50KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGlkOiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MTQ0LTE0OQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmV3YXJkcy5wcm90b3R5cGUuZmluYWxpemVEaXNidXJzZW1lbnQ+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnJld2FyZHMsCiAgICAvLyAgIGFyZ3M6IFtpZF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjE0NgogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjE0NgogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDAKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBcHBMaXN0KSkKICAgIGJ5dGVjXzIgLy8gImFhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czoxNDYKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkucmV3YXJkcywKICAgIGludGNfMSAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjE0OAogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciA0CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjE0NC0xNDkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFJld2FyZHMucHJvdG90eXBlLmZpbmFsaXplRGlzYnVyc2VtZW50Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzLAogICAgLy8gICBhcmdzOiBbaWRdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDU0MjRhNTkxIC8vIG1ldGhvZCAiZmluYWxpemVEaXNidXJzZW1lbnQodWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjEzNy0xNDEKICAgIC8vIGZpbmFsaXplRGlzYnVyc2VtZW50KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGlkOiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czo6UmV3YXJkc1BsdWdpbi5jbGFpbVJld2FyZHNbcm91dGluZ10oKSAtPiB2b2lkOgpjbGFpbVJld2FyZHM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MTUyLTE1NgogICAgLy8gY2xhaW1SZXdhcmRzKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIHJld2FyZHM6IENsYWltRGV0YWlsc1tdCiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAxNiAvLyAxNgogICAgKgogICAgaW50Y18zIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rKHVpbnQ2NCx1aW50NjQpW10pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MTU5LTE2NAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmV3YXJkcy5wcm90b3R5cGUuY2xhaW1SZXdhcmRzPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzLAogICAgLy8gICBhcmdzOiBbcmV3YXJkc10sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjE2MQogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzLAogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjE2MQogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzLAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDAKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBcHBMaXN0KSkKICAgIGJ5dGVjXzIgLy8gImFhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czoxNjEKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkucmV3YXJkcywKICAgIGludGNfMSAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjE2MwogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciA0CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjE1OS0xNjQKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFJld2FyZHMucHJvdG90eXBlLmNsYWltUmV3YXJkcz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkucmV3YXJkcywKICAgIC8vICAgYXJnczogW3Jld2FyZHNdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDNlYzQwYWE0IC8vIG1ldGhvZCAiY2xhaW1SZXdhcmRzKCh1aW50NjQsdWludDY0KVtdKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjE1Mi0xNTYKICAgIC8vIGNsYWltUmV3YXJkcygKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICByZXdhcmRzOiBDbGFpbURldGFpbHNbXQogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjpSZXdhcmRzUGx1Z2luLnJlY2xhaW1SZXdhcmRzW3JvdXRpbmddKCkgLT4gdm9pZDoKcmVjbGFpbVJld2FyZHM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MTY3LTE3MgogICAgLy8gcmVjbGFpbVJld2FyZHMoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgaWQ6IHVpbnQ2NCwKICAgIC8vICAgcmVjbGFpbXM6IEFsbG9jYXRpb25SZWNsYWltRGV0YWlsc1tdCiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgNDAgLy8gNDAKICAgICoKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuKyh1aW50OFszMl0sdWludDY0KVtdKQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjE3NS0xODAKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFJld2FyZHMucHJvdG90eXBlLnJlY2xhaW1SZXdhcmRzPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzLAogICAgLy8gICBhcmdzOiBbaWQsIHJlY2xhaW1zXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MTc3CiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnJld2FyZHMsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MTc3CiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnJld2FyZHMsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMiAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvcmV3YXJkcy9jb250cmFjdC5hbGdvLnRzOjE3NwogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5yZXdhcmRzLAogICAgaW50Y18xIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MTc5CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgdW5jb3ZlciA0CiAgICB1bmNvdmVyIDUKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9yZXdhcmRzL2NvbnRyYWN0LmFsZ28udHM6MTc1LTE4MAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgUmV3YXJkcy5wcm90b3R5cGUucmVjbGFpbVJld2FyZHM+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnJld2FyZHMsCiAgICAvLyAgIGFyZ3M6IFtpZCwgcmVjbGFpbXNdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweGJkM2NkMDkwIC8vIG1ldGhvZCAicmVjbGFpbVJld2FyZHModWludDY0LChhZGRyZXNzLHVpbnQ2NClbXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3Jld2FyZHMvY29udHJhY3QuYWxnby50czoxNjctMTcyCiAgICAvLyByZWNsYWltUmV3YXJkcygKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBpZDogdWludDY0LAogICAgLy8gICByZWNsYWltczogQWxsb2NhdGlvblJlY2xhaW1EZXRhaWxzW10KICAgIC8vICk6IHZvaWQgewogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjpBa2l0YUJhc2VDb250cmFjdC51cGRhdGVBa2l0YURBT1tyb3V0aW5nXSgpIC0+IHZvaWQ6CnVwZGF0ZUFraXRhREFPOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzgKICAgIC8vIHVwZGF0ZUFraXRhREFPKGFraXRhREFPOiBBcHBsaWNhdGlvbik6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjM5CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5nZXRBa2l0YURBT1dhbGxldCgpLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzIKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzIKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIHB1c2hieXRlcyAid2FsbGV0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzkKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSB0aGlzLmdldEFraXRhREFPV2FsbGV0KCkuYWRkcmVzcywgRVJSX05PVF9BS0lUQV9EQU8pCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgdGhlIEFraXRhIERBTyBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjQwCiAgICAvLyB0aGlzLmFraXRhREFPLnZhbHVlID0gYWtpdGFEQU8KICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozOAogICAgLy8gdXBkYXRlQWtpdGFEQU8oYWtpdGFEQU86IEFwcGxpY2F0aW9uKTogdm9pZCB7CiAgICBpbnRjXzIgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL3Jld2FyZHMvYmFzZS50czo6QmFzZVJld2FyZHMubWJyW3JvdXRpbmddKCkgLT4gdm9pZDoKbWJyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jld2FyZHMvYmFzZS50czo3CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzMgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1dGY4W10pCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMyAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICBjYWxsc3ViIHNtYXJ0X2NvbnRyYWN0cy9yZXdhcmRzL2Jhc2UudHM6OkJhc2VSZXdhcmRzLm1icgogICAgYnl0ZWNfMyAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18yIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9yZXdhcmRzL2Jhc2UudHM6OkJhc2VSZXdhcmRzLm1icih0aXRsZTogYnl0ZXMsIG5vdGU6IGJ5dGVzKSAtPiBieXRlczoKc21hcnRfY29udHJhY3RzL3Jld2FyZHMvYmFzZS50czo6QmFzZVJld2FyZHMubWJyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jld2FyZHMvYmFzZS50czo3LTgKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgLy8gbWJyKHRpdGxlOiBzdHJpbmcsIG5vdGU6IHN0cmluZyk6IFJld2FyZHNNQlJEYXRhIHsKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Jld2FyZHMvYmFzZS50czoxMAogICAgLy8gZGlzYnVyc2VtZW50czogTWluRGlzYnVyc2VtZW50c01CUiArIChCb3hDb3N0UGVyQnl0ZSAqIChCeXRlcyh0aXRsZSkubGVuZ3RoICsgQnl0ZXMobm90ZSkubGVuZ3RoKSksCiAgICBmcmFtZV9kaWcgLTIKICAgIGxlbgogICAgZnJhbWVfZGlnIC0xCiAgICBsZW4KICAgICsKICAgIHB1c2hpbnQgNDAwIC8vIDQwMAogICAgKgogICAgcHVzaGludCAzNTMwMCAvLyAzNTMwMAogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3Jld2FyZHMvYmFzZS50czo5LTEyCiAgICAvLyByZXR1cm4gewogICAgLy8gICBkaXNidXJzZW1lbnRzOiBNaW5EaXNidXJzZW1lbnRzTUJSICsgKEJveENvc3RQZXJCeXRlICogKEJ5dGVzKHRpdGxlKS5sZW5ndGggKyBCeXRlcyhub3RlKS5sZW5ndGgpKSwKICAgIC8vICAgdXNlckFsbG9jYXRpb25zOiBVc2VyQWxsb2NhdGlvbk1CUgogICAgLy8gfQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jld2FyZHMvYmFzZS50czoxMQogICAgLy8gdXNlckFsbG9jYXRpb25zOiBVc2VyQWxsb2NhdGlvbk1CUgogICAgcHVzaGludCAyNTMwMCAvLyAyNTMwMAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jld2FyZHMvYmFzZS50czo5LTEyCiAgICAvLyByZXR1cm4gewogICAgLy8gICBkaXNidXJzZW1lbnRzOiBNaW5EaXNidXJzZW1lbnRzTUJSICsgKEJveENvc3RQZXJCeXRlICogKEJ5dGVzKHRpdGxlKS5sZW5ndGggKyBCeXRlcyhub3RlKS5sZW5ndGgpKSwKICAgIC8vICAgdXNlckFsbG9jYXRpb25zOiBVc2VyQWxsb2NhdGlvbk1CUgogICAgLy8gfQogICAgaXRvYgogICAgY29uY2F0CiAgICByZXRzdWIK", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyAEAAgBAiYECWFraXRhX2RhbxBzcGVuZGluZ19hZGRyZXNzA2FhbAQVH3x1MRkURDEYQQBQggoECMJe/wSu4CPFBFBOR/0EXCyRDwSGme1MBORAo6YEex0iNgQz6SyUBIVN7eAE1Uu62TYaAI4KAEwBAwGLAhkC6wM5A48D8QABBBQAJEOABM2a1n42GgCOAQASAIoCAYv+QAADMgOJi/9yCESJNhoBSSJZJQhLARUSRFcCADYaAkkVIxJEF4AHdmVyc2lvbk8CZyhMZyRDNhoBSRUjEkQXNhoCSRUkEkQiUzYaA0kiWSUISwEVEkRJVwIANhoESRUjEkQ2GgVJFSMSRDYaBkkiWSUISwEVEkRJVwIASwcpZUhMTwVMiAOgIlsiKGVEKmVII1uxSXIIRLIHTLIISwGyACSyECKyAbZPBk8HiP9NgAQcnrvbshpPBrIaTwWyGk8EshpPA7IasiCyGLIAgQayECKyAbO3AT5JVwQATFcABCsSREkVIxJEK0xQsCRDNhoBSRUjEkQXNhoCSRUkEkQiUzYaA0kVIxJENhoESSJZJQhLARUSRDYaBUkVIxJENhoGSRUjEkQ2GgdJIlklCEsBFRJESwYpZUhMsSIoZUQqZUgjW08HTwiI/rKABI9JJi2yGk8HshpPBrIaTwWyGk8EshpPArIasiCyGLIAgQayECKyAbMkQzYaAUkVIxJEFzYaAkkVJBJEIlM2GgNJFSMSRDYaBEkiWUmBKAslCEsCFRJENhoFSRUjEkQXSwUpZUhMIihlRCplSCNbgABJiAJoI1tPBAuxTwIISwFyCESyB7IISwGyACSyECKyAbZPBE8FiP4YgARWVqz5shpPBLIaTwOyGrIgshiyAIEGshAisgGzJEM2GgFJFSMSRBdJNhoCSRUkEkQiU0w2GgNJTgIVIxJENhoESRUjEkQXSU8CNhoFSU4DSSJZSYEoCyUITwIVEkQ2GgZJFSMSRBdOA0wpZUhOAiIoZUQqZUgjW0lOA4AASYgBwiNbTwILTgJyCERMcABFAUAAAzIQCLFLAUlyCESyB0yyCEsCSU4CsgAkshAisgG2SXIIREsHshFLBbISshRLAbIAgQSyECKyAbZLCEsKiP1GgAQ8YN+gshpLCLIaSwayGrIgshiyAIEGshAisgGzJEM2GgFJFSMSRBc2GgJJFSQSRCJTNhoDSRUjEkRLAillSEyxIihlRCplSCNbTwNPBIj89IAEVCSlkbIaTwKyGrIgshiyAIEGshAisgGzJEM2GgFJFSMSRBc2GgJJFSQSRCJTNhoDSSJZgRALJQhLARUSREsCKWVITLEiKGVEKmVII1tPA08EiPyegAQ+xAqkshpPArIasiCyGLIAgQayECKyAbMkQzYaAUkVIxJEFzYaAkkVJBJEIlM2GgNJFSMSRDYaBEkiWYEoCyUISwEVEkRLAyllSEyxIihlRCplSCNbTwRPBYj8QIAEvTzQkLIaTwSyGk8CshqyILIYsgCBBrIQIrIBsyRDNhoBSRUjEkQXMQAiKGVEgAZ3YWxsZXRlSHIIRBJEKExnJEM2GgFJIlklCEsBFRJEVwIANhoCSSJZJQhLARUSRFcCAIgABitMULAkQ4oCAYv+FYv/FQiBkAMLgeSTAggWgdTFARZQiQ==", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var RewardsPluginParamsFactory = class _RewardsPluginParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "create":
          case "create(string,uint64)void":
            return _RewardsPluginParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs create ABI call params for the RewardsPlugin smart contract using the create(string,uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params) {
        return {
          ...params,
          method: "create(string,uint64)void",
          args: Array.isArray(params.args) ? params.args : [params.args.version, params.args.akitaDao]
        };
      }
    };
  }
  /**
   * Constructs a no op call for the createDisbursement(uint64,bool,string,uint64,uint64,string)uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static createDisbursement(params) {
    return {
      ...params,
      method: "createDisbursement(uint64,bool,string,uint64,uint64,string)uint64",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.title, params.args.timeToUnlock, params.args.expiration, params.args.note]
    };
  }
  /**
   * Constructs a no op call for the editDisbursement(uint64,bool,uint64,string,uint64,uint64,string)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static editDisbursement(params) {
    return {
      ...params,
      method: "editDisbursement(uint64,bool,uint64,string,uint64,uint64,string)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.id, params.args.title, params.args.timeToUnlock, params.args.expiration, params.args.note]
    };
  }
  /**
   * Constructs a no op call for the createUserAllocations(uint64,bool,uint64,(address,uint64)[],uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static createUserAllocations(params) {
    return {
      ...params,
      method: "createUserAllocations(uint64,bool,uint64,(address,uint64)[],uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.id, params.args.allocations, params.args.sum]
    };
  }
  /**
   * Constructs a no op call for the createAsaUserAllocations(uint64,bool,uint64,uint64,(address,uint64)[],uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static createAsaUserAllocations(params) {
    return {
      ...params,
      method: "createAsaUserAllocations(uint64,bool,uint64,uint64,(address,uint64)[],uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.id, params.args.assetId, params.args.allocations, params.args.sum]
    };
  }
  /**
   * Constructs a no op call for the finalizeDisbursement(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static finalizeDisbursement(params) {
    return {
      ...params,
      method: "finalizeDisbursement(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.id]
    };
  }
  /**
   * Constructs a no op call for the claimRewards(uint64,bool,(uint64,uint64)[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static claimRewards(params) {
    return {
      ...params,
      method: "claimRewards(uint64,bool,(uint64,uint64)[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.rewards]
    };
  }
  /**
   * Constructs a no op call for the reclaimRewards(uint64,bool,uint64,(address,uint64)[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static reclaimRewards(params) {
    return {
      ...params,
      method: "reclaimRewards(uint64,bool,uint64,(address,uint64)[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.id, params.args.reclaims]
    };
  }
  /**
   * Constructs a no op call for the updateAkitaDAO(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDao(params) {
    return {
      ...params,
      method: "updateAkitaDAO(uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.akitaDao]
    };
  }
  /**
   * Constructs a no op call for the opUp()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static opUp(params) {
    return {
      ...params,
      method: "opUp()void",
      args: Array.isArray(params.args) ? params.args : []
    };
  }
  /**
   * Constructs a no op call for the mbr(string,string)(uint64,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mbr(params) {
    return {
      ...params,
      method: "mbr(string,string)(uint64,uint64)",
      args: Array.isArray(params.args) ? params.args : [params.args.title, params.args.note]
    };
  }
};
var RewardsPluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `RewardsPluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory19({
      ...params,
      appSpec: APP_SPEC19
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC19;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new RewardsPluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new RewardsPluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the RewardsPlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    var _a;
    const result = await this.appFactory.deploy({
      ...params,
      createParams: ((_a = params.createParams) == null ? void 0 : _a.method) ? RewardsPluginParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams : void 0
    });
    return { result: result.result, appClient: new RewardsPluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the RewardsPlugin smart contract using the create(string,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params) => {
        return this.appFactory.params.create(RewardsPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the RewardsPlugin smart contract using the create(string,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params) => {
        return this.appFactory.createTransaction.create(RewardsPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the RewardsPlugin smart contract using an ABI method call using the create(string,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params) => {
        const result = await this.appFactory.send.create(RewardsPluginParamsFactory.create.create(params));
        return { result: { ...result.result, return: result.result.return }, appClient: new RewardsPluginClient(result.appClient) };
      }
    }
  };
};
var RewardsPluginClient = class _RewardsPluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient19 ? appClientOrParams : new _AppClient19({
      ...appClientOrParams,
      appSpec: APP_SPEC19
    });
  }
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue(method, returnValue) {
    return returnValue !== void 0 ? getArc56ReturnValue12(returnValue, this.appClient.getABIMethod(method), APP_SPEC19.structs) : void 0;
  }
  /**
   * Returns a new `RewardsPluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _RewardsPluginClient(await _AppClient19.fromCreatorAndName({ ...params, appSpec: APP_SPEC19 }));
  }
  /**
   * Returns an `RewardsPluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _RewardsPluginClient(await _AppClient19.fromNetwork({ ...params, appSpec: APP_SPEC19 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the RewardsPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `createDisbursement(uint64,bool,string,uint64,uint64,string)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    createDisbursement: (params) => {
      return this.appClient.params.call(RewardsPluginParamsFactory.createDisbursement(params));
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `editDisbursement(uint64,bool,uint64,string,uint64,uint64,string)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    editDisbursement: (params) => {
      return this.appClient.params.call(RewardsPluginParamsFactory.editDisbursement(params));
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `createUserAllocations(uint64,bool,uint64,(address,uint64)[],uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    createUserAllocations: (params) => {
      return this.appClient.params.call(RewardsPluginParamsFactory.createUserAllocations(params));
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `createAsaUserAllocations(uint64,bool,uint64,uint64,(address,uint64)[],uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    createAsaUserAllocations: (params) => {
      return this.appClient.params.call(RewardsPluginParamsFactory.createAsaUserAllocations(params));
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `finalizeDisbursement(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    finalizeDisbursement: (params) => {
      return this.appClient.params.call(RewardsPluginParamsFactory.finalizeDisbursement(params));
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `claimRewards(uint64,bool,(uint64,uint64)[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    claimRewards: (params) => {
      return this.appClient.params.call(RewardsPluginParamsFactory.claimRewards(params));
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `reclaimRewards(uint64,bool,uint64,(address,uint64)[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    reclaimRewards: (params) => {
      return this.appClient.params.call(RewardsPluginParamsFactory.reclaimRewards(params));
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDao: (params) => {
      return this.appClient.params.call(RewardsPluginParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.params.call(RewardsPluginParamsFactory.opUp(params));
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `mbr(string,string)(uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    mbr: (params) => {
      return this.appClient.params.call(RewardsPluginParamsFactory.mbr(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the RewardsPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `createDisbursement(uint64,bool,string,uint64,uint64,string)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    createDisbursement: (params) => {
      return this.appClient.createTransaction.call(RewardsPluginParamsFactory.createDisbursement(params));
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `editDisbursement(uint64,bool,uint64,string,uint64,uint64,string)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    editDisbursement: (params) => {
      return this.appClient.createTransaction.call(RewardsPluginParamsFactory.editDisbursement(params));
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `createUserAllocations(uint64,bool,uint64,(address,uint64)[],uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    createUserAllocations: (params) => {
      return this.appClient.createTransaction.call(RewardsPluginParamsFactory.createUserAllocations(params));
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `createAsaUserAllocations(uint64,bool,uint64,uint64,(address,uint64)[],uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    createAsaUserAllocations: (params) => {
      return this.appClient.createTransaction.call(RewardsPluginParamsFactory.createAsaUserAllocations(params));
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `finalizeDisbursement(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    finalizeDisbursement: (params) => {
      return this.appClient.createTransaction.call(RewardsPluginParamsFactory.finalizeDisbursement(params));
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `claimRewards(uint64,bool,(uint64,uint64)[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    claimRewards: (params) => {
      return this.appClient.createTransaction.call(RewardsPluginParamsFactory.claimRewards(params));
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `reclaimRewards(uint64,bool,uint64,(address,uint64)[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    reclaimRewards: (params) => {
      return this.appClient.createTransaction.call(RewardsPluginParamsFactory.reclaimRewards(params));
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDao: (params) => {
      return this.appClient.createTransaction.call(RewardsPluginParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.createTransaction.call(RewardsPluginParamsFactory.opUp(params));
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `mbr(string,string)(uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    mbr: (params) => {
      return this.appClient.createTransaction.call(RewardsPluginParamsFactory.mbr(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the RewardsPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `createDisbursement(uint64,bool,string,uint64,uint64,string)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    createDisbursement: async (params) => {
      const result = await this.appClient.send.call(RewardsPluginParamsFactory.createDisbursement(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `editDisbursement(uint64,bool,uint64,string,uint64,uint64,string)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    editDisbursement: async (params) => {
      const result = await this.appClient.send.call(RewardsPluginParamsFactory.editDisbursement(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `createUserAllocations(uint64,bool,uint64,(address,uint64)[],uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    createUserAllocations: async (params) => {
      const result = await this.appClient.send.call(RewardsPluginParamsFactory.createUserAllocations(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `createAsaUserAllocations(uint64,bool,uint64,uint64,(address,uint64)[],uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    createAsaUserAllocations: async (params) => {
      const result = await this.appClient.send.call(RewardsPluginParamsFactory.createAsaUserAllocations(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `finalizeDisbursement(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    finalizeDisbursement: async (params) => {
      const result = await this.appClient.send.call(RewardsPluginParamsFactory.finalizeDisbursement(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `claimRewards(uint64,bool,(uint64,uint64)[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    claimRewards: async (params) => {
      const result = await this.appClient.send.call(RewardsPluginParamsFactory.claimRewards(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `reclaimRewards(uint64,bool,uint64,(address,uint64)[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    reclaimRewards: async (params) => {
      const result = await this.appClient.send.call(RewardsPluginParamsFactory.reclaimRewards(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDao: async (params) => {
      const result = await this.appClient.send.call(RewardsPluginParamsFactory.updateAkitaDao(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    opUp: async (params = { args: [] }) => {
      const result = await this.appClient.send.call(RewardsPluginParamsFactory.opUp(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the RewardsPlugin smart contract using the `mbr(string,string)(uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mbr: async (params) => {
      const result = await this.appClient.send.call(RewardsPluginParamsFactory.mbr(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _RewardsPluginClient(this.appClient.clone(params));
  }
  /**
   * Makes a readonly (simulated) call to the RewardsPlugin smart contract using the `mbr(string,string)(uint64,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async mbr(params) {
    const result = await this.appClient.send.call(RewardsPluginParamsFactory.mbr(params));
    return result.return;
  }
  /**
   * Methods to access state for the current RewardsPlugin app
   */
  state = {
    /**
     * Methods to access global state for the current RewardsPlugin app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async () => {
        const result = await this.appClient.state.global.getAll();
        return {
          version: result.version,
          akitaDao: result.akitaDAO
        };
      },
      /**
       * Get the current value of the version key in global state
       */
      version: async () => {
        return await this.appClient.state.global.getValue("version");
      },
      /**
       * Get the current value of the akitaDAO key in global state
       */
      akitaDao: async () => {
        return await this.appClient.state.global.getValue("akitaDAO");
      }
    }
  };
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a createDisbursement(uint64,bool,string,uint64,uint64,string)uint64 method call against the RewardsPlugin contract
       */
      createDisbursement(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.createDisbursement(params)));
        resultMappers.push((v) => client.decodeReturnValue("createDisbursement(uint64,bool,string,uint64,uint64,string)uint64", v));
        return this;
      },
      /**
       * Add a editDisbursement(uint64,bool,uint64,string,uint64,uint64,string)void method call against the RewardsPlugin contract
       */
      editDisbursement(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.editDisbursement(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a createUserAllocations(uint64,bool,uint64,(address,uint64)[],uint64)void method call against the RewardsPlugin contract
       */
      createUserAllocations(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.createUserAllocations(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a createAsaUserAllocations(uint64,bool,uint64,uint64,(address,uint64)[],uint64)void method call against the RewardsPlugin contract
       */
      createAsaUserAllocations(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.createAsaUserAllocations(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a finalizeDisbursement(uint64,bool,uint64)void method call against the RewardsPlugin contract
       */
      finalizeDisbursement(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.finalizeDisbursement(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a claimRewards(uint64,bool,(uint64,uint64)[])void method call against the RewardsPlugin contract
       */
      claimRewards(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.claimRewards(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a reclaimRewards(uint64,bool,uint64,(address,uint64)[])void method call against the RewardsPlugin contract
       */
      reclaimRewards(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.reclaimRewards(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a updateAkitaDAO(uint64)void method call against the RewardsPlugin contract
       */
      updateAkitaDao(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDao(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a opUp()void method call against the RewardsPlugin contract
       */
      opUp(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.opUp(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a mbr(string,string)(uint64,uint64) method call against the RewardsPlugin contract
       */
      mbr(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mbr(params)));
        resultMappers.push((v) => client.decodeReturnValue("mbr(string,string)(uint64,uint64)", v));
        return this;
      },
      /**
       * Add a clear state call to the RewardsPlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/rewards.ts
var RewardsPluginSDK = class _RewardsPluginSDK extends BaseSDK {
  constructor(params) {
    super({ factory: RewardsPluginFactory, ...params });
  }
  /**
   * Each claim consumes foreign references across multiple types (COMBINED limit of 8 per txn):
   *   - Boxes: allocation box on rewards contract (2 slots: box + foreignApp for non-zero app)
   *   - Assets: 1 ASA reference for the inner transfer
   *   - Asset holdings: receiver opt-in check (account + asset, ~2 slots amortized)
   *   - Accounts: receiver account for inner transfer (shared but counted per-claim)
   * The combined per-txn limit means boxes with non-zero app IDs are expensive (2 slots each).
   * Each app call in the group provides 8 pooled slots across ALL reference types.
   * The group is capped at 16 transactions, with 2 reserved (plugin call + verifyAuthAddr).
   */
  static REFS_PER_CLAIM = 8;
  static BASE_REF_OVERHEAD = 10;
  // plugin app, rewards app, wallet app, wallet boxes, sender, contract accounts, etc.
  static REFS_PER_TXN = 8;
  static MAX_OPUP_COUNT = 14;
  // 16 max group size - 2 reserved (plugin call + verifyAuthAddr)
  static getMaxClaimsPerTransaction() {
    const totalRefs = (1 + _RewardsPluginSDK.MAX_OPUP_COUNT) * _RewardsPluginSDK.REFS_PER_TXN;
    return Math.floor((totalRefs - _RewardsPluginSDK.BASE_REF_OVERHEAD) / _RewardsPluginSDK.REFS_PER_CLAIM);
  }
  static computeOpUpCount(numClaims) {
    const refsNeeded = _RewardsPluginSDK.BASE_REF_OVERHEAD + _RewardsPluginSDK.REFS_PER_CLAIM * numClaims;
    const opUpCount = Math.max(0, Math.ceil((refsNeeded - _RewardsPluginSDK.REFS_PER_TXN) / _RewardsPluginSDK.REFS_PER_TXN));
    if (opUpCount > _RewardsPluginSDK.MAX_OPUP_COUNT) {
      const max = _RewardsPluginSDK.getMaxClaimsPerTransaction();
      throw new Error(
        `Too many reward claims in a single transaction (${numClaims}). Maximum is ${max} claims per transaction. Split into multiple calls.`
      );
    }
    return opUpCount;
  }
  claimRewards(args) {
    var _a;
    const methodName = "claimRewards";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const numClaims = ((_a = args.rewards) == null ? void 0 : _a.length) ?? 0;
    const opUpCount = _RewardsPluginSDK.computeOpUpCount(numClaims);
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.claimRewards({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      },
      opUpCount
    });
  }
};

// src/generated/AkitaSocialPluginClient.ts
import { getArc56ReturnValue as getArc56ReturnValue13, getABIStructFromABITuple as getABIStructFromABITuple13 } from "@algorandfoundation/algokit-utils/types/app-arc56";
import {
  AppClient as _AppClient20
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory20 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC20 = { "name": "AkitaSocialPlugin", "structs": { "AkitaSocialMBRData": [{ "name": "follows", "type": "uint64" }, { "name": "blocks", "type": "uint64" }, { "name": "posts", "type": "uint64" }, { "name": "votes", "type": "uint64" }, { "name": "votelist", "type": "uint64" }, { "name": "reactions", "type": "uint64" }, { "name": "reactionlist", "type": "uint64" }, { "name": "meta", "type": "uint64" }, { "name": "moderators", "type": "uint64" }, { "name": "banned", "type": "uint64" }, { "name": "actions", "type": "uint64" }], "ViewPayWallValue": [{ "name": "userPayInfo", "type": "(uint8,uint64,uint64)[]" }, { "name": "agentPayInfo", "type": "(uint8,uint64,uint64)[]" }], "tipMBRInfo": [{ "name": "type", "type": "uint8" }, { "name": "arc58", "type": "uint64" }] }, "methods": [{ "name": "create", "args": [{ "type": "string", "name": "version" }, { "type": "uint64", "name": "akitaDAO" }, { "type": "uint64", "name": "escrow" }], "returns": { "type": "void" }, "actions": { "create": ["NoOp"], "call": [] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "post", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "timestamp" }, { "type": "byte[24]", "name": "nonce" }, { "type": "byte[36]", "name": "cid" }, { "type": "uint64", "name": "gateID" }, { "type": "bool", "name": "usePayWall" }, { "type": "uint64", "name": "payWallID" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "editPost", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "byte[36]", "name": "cid" }, { "type": "byte[32]", "name": "amendment" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "gatedReply", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "timestamp" }, { "type": "byte[24]", "name": "nonce" }, { "type": "byte[36]", "name": "cid" }, { "type": "byte[]", "name": "ref" }, { "type": "uint8", "name": "type" }, { "type": "uint64", "name": "gateID" }, { "type": "byte[][]", "name": "args" }, { "type": "bool", "name": "usePayWall" }, { "type": "uint64", "name": "payWallID" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "reply", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "timestamp" }, { "type": "byte[24]", "name": "nonce" }, { "type": "byte[36]", "name": "cid" }, { "type": "byte[]", "name": "ref" }, { "type": "uint8", "name": "type" }, { "type": "uint64", "name": "gateID" }, { "type": "bool", "name": "usePayWall" }, { "type": "uint64", "name": "payWallID" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "gatedEditReply", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "byte[36]", "name": "cid" }, { "type": "byte[32]", "name": "amendment" }, { "type": "byte[][]", "name": "args" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "editReply", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "byte[36]", "name": "cid" }, { "type": "byte[32]", "name": "amendment" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "vote", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "byte[]", "name": "ref" }, { "type": "uint8", "name": "type" }, { "type": "bool", "name": "isUp" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "editVote", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "byte[32]", "name": "ref" }, { "type": "bool", "name": "flip" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "gatedReact", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "byte[]", "name": "ref" }, { "type": "uint8", "name": "type" }, { "type": "uint64", "name": "NFT" }, { "type": "byte[][]", "name": "args" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "react", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "byte[]", "name": "ref" }, { "type": "uint8", "name": "type" }, { "type": "uint64", "name": "NFT" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "deleteReaction", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "byte[32]", "name": "ref" }, { "type": "uint64", "name": "NFT" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "gatedFollow", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "address", "name": "address" }, { "type": "byte[][]", "name": "args" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "follow", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "address", "name": "address" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "unfollow", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "address", "name": "address" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "block", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "address", "name": "address" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "unblock", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "address", "name": "address" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "addModerator", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "address", "name": "address" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "removeModerator", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "address", "name": "address" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "ban", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "address", "name": "address" }, { "type": "uint64", "name": "expiration" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "flagPost", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "byte[32]", "name": "ref" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "unflagPost", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "byte[32]", "name": "ref" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "unban", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "address", "name": "address" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "addAction", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "actionAppID" }, { "type": "byte[36]", "name": "content" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "removeAction", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "actionAppID" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "initMeta", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "address", "name": "user" }, { "type": "bool", "name": "automated" }, { "type": "uint64", "name": "subscriptionIndex" }, { "type": "uint64", "name": "NFD" }, { "type": "uint64", "name": "akitaNFT" }], "returns": { "type": "uint64" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "updateMeta", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "followGateID" }, { "type": "uint64", "name": "addressGateID" }, { "type": "uint64", "name": "subscriptionIndex" }, { "type": "uint64", "name": "NFD" }, { "type": "uint64", "name": "akitaNFT" }, { "type": "uint64", "name": "defaultPayWallID" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "updateAkitaDAO", "args": [{ "type": "uint64", "name": "akitaDAO" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "opUp", "args": [], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "mbr", "args": [{ "type": "byte[]", "name": "ref" }], "returns": { "type": "(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)", "struct": "AkitaSocialMBRData" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "payWallMbr", "args": [{ "type": "((uint8,uint64,uint64)[],(uint8,uint64,uint64)[])", "struct": "ViewPayWallValue", "name": "paywall" }], "returns": { "type": "uint64" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "checkTipMbrRequirements", "args": [{ "type": "uint64", "name": "akitaDAO" }, { "type": "address", "name": "creator" }, { "type": "uint64", "name": "wallet" }], "returns": { "type": "(uint8,uint64)", "struct": "tipMBRInfo" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 1, "bytes": 1 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": { "version": { "keyType": "AVMString", "valueType": "AVMString", "key": "dmVyc2lvbg==", "desc": "the current version of the contract" }, "akitaDAO": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "YWtpdGFfZGFv", "desc": "the app ID of the Akita DAO" } }, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": [], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [1831, 2186, 2790, 3139, 3533, 3949, 5311, 5678, 5730, 5799, 5983, 6172], "errorMessage": "Bytes has valid prefix" }, { "pc": [1075, 1481, 1873, 2228, 2491, 3103, 3497, 5943], "errorMessage": "Length must be 32" }, { "pc": [101], "errorMessage": "OnCompletion must be NoOp" }, { "pc": [5489], "errorMessage": "Only the Akita DAO can call this function" }, { "pc": [398, 423, 586, 609, 785, 808, 1156, 1179, 1555, 1578, 1928, 1951, 2275, 2298, 2560, 2583, 2808, 2826, 3253, 3276, 3640, 3663, 3962, 4093, 4274, 4456, 4648, 5002, 5221, 5487, 5932], "errorMessage": "application exists" }, { "pc": [5885], "errorMessage": "asset exists" }, { "pc": [553, 590, 748, 789, 1026, 1122, 1160, 1442, 1521, 1559, 1756, 1900, 1932, 2121, 2247, 2279, 2461, 2526, 2564, 2737, 2835, 2869, 3077, 3219, 3257, 3481, 3606, 3644, 3802, 3894, 4084, 4188, 4265, 4369, 4446, 4552, 4638, 4748, 4827, 4906, 4992, 5101, 5211, 5399, 5474, 5612], "errorMessage": "check GlobalState exists" }, { "pc": [3954, 5804], "errorMessage": "invalid number of bytes for (bool1,uint64,uint64,uint64,uint64,uint64,uint64,bool1,uint64,uint64,uint64)" }, { "pc": [956, 1386, 2420, 3024, 3442, 5508], "errorMessage": "invalid number of bytes for (len+uint8[])" }, { "pc": [438], "errorMessage": "invalid number of bytes for (len+utf8[])" }, { "pc": [2796], "errorMessage": "invalid number of bytes for (uint64,bool1)" }, { "pc": [491, 535, 718, 903, 995, 1333, 1420, 1701, 2080, 2400, 2445, 2697, 2723, 3004, 3144, 3422, 3538, 3773, 3863, 4064, 4167, 4245, 4348, 4426, 4531, 4610, 4727, 4806, 4885, 4964, 5081, 5159, 5178, 5339, 5735, 5988, 6177], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [449, 457, 482, 501, 527, 543, 709, 893, 916, 980, 1005, 1323, 1346, 1410, 1430, 1691, 2070, 2390, 2687, 2994, 3051, 3412, 3469, 3764, 3792, 3854, 4055, 4158, 4236, 4339, 4417, 4522, 4601, 4629, 4718, 4797, 4876, 4955, 4974, 5072, 5091, 5150, 5186, 5194, 5202, 5316, 5330, 5349, 5357, 5365, 5373, 5381, 5389, 5467, 5575, 5593], "errorMessage": "invalid number of bytes for uint64" }, { "pc": [970, 1400, 2434, 3040, 3458], "errorMessage": "invalid number of bytes for uint8" }, { "pc": [510, 927, 1357], "errorMessage": "invalid number of bytes for uint8[24]" }, { "pc": [738, 1728, 2107, 2712, 3784, 3874, 4075, 4178, 4256, 4359, 4437, 4542, 4621, 4738, 4817, 4896, 5170, 5585], "errorMessage": "invalid number of bytes for uint8[32]" }, { "pc": [519, 729, 939, 1369, 1716, 2095, 4983], "errorMessage": "invalid number of bytes for uint8[36]" }, { "pc": [5646], "errorMessage": "invalid size" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDggNgogICAgYnl0ZWNibG9jayAiYWtpdGFfZGFvIiAic2FsIiAic3BlbmRpbmdfYWRkcmVzcyIgMHgxNTFmN2M3NSAiYWtpdGFfYXNzZXRzIiAic29jaWFsX2ZlZXMiIDB4MTQgImFhbCIgMHg0MzkyMjY1NSAweDBhIDB4OTg0YmFlZjUgMHhmMTM2MDBkMSAweDczOWVhNzBiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxOQogICAgLy8gZXhwb3J0IGNsYXNzIEFraXRhU29jaWFsUGx1Z2luIGV4dGVuZHMgY2xhc3NlcyhCYXNlU29jaWFsLCBBa2l0YUJhc2VDb250cmFjdCkgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBieiBtYWluX2NyZWF0ZV9Ob09wQDM3CiAgICBwdXNoYnl0ZXNzIDB4MTY1OWMxYTcgMHg0YTdlYjU0ZCAweGNhZjhlNzEzIDB4YzE5ODQ1OWQgMHg1YjQ1ZTM2YiAweDY2YjcyOTYyIDB4NzVhZTQwYTQgMHhlYzViY2ViMSAweDM1YzZlMzk2IDB4NWZhYTNhODMgMHg3ZmQ0Y2FiNyAweDNmZDg1ZjRkIDB4YjQ2NTQ5ZmEgMHg5YzMwYWNlZCAweGJlYzg2YzM0IDB4OWY1OWE5NzAgMHhhYTc2NTYwMSAweDkwOTFkY2E1IDB4NDkzZTkwOGYgMHgwZDhiNjc3MSAweDFiMmQwOGUyIDB4NjhlOGRiNzggMHgyNTQ5ODIyOSAweDVjZjdlMGE1IDB4YWEyOTA0OGIgMHg3NjIzZWYzMyAweDMzZTkyYzk0IDB4ODU0ZGVkZTAgMHg5MmU2ZGQzYiAweGExMzRhMjc4IDB4MzQ0MTc1ZjAgLy8gbWV0aG9kICJwb3N0KHVpbnQ2NCxib29sLHVpbnQ2NCxieXRlWzI0XSxieXRlWzM2XSx1aW50NjQsYm9vbCx1aW50NjQpdm9pZCIsIG1ldGhvZCAiZWRpdFBvc3QodWludDY0LGJvb2wsYnl0ZVszNl0sYnl0ZVszMl0pdm9pZCIsIG1ldGhvZCAiZ2F0ZWRSZXBseSh1aW50NjQsYm9vbCx1aW50NjQsYnl0ZVsyNF0sYnl0ZVszNl0sYnl0ZVtdLHVpbnQ4LHVpbnQ2NCxieXRlW11bXSxib29sLHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJyZXBseSh1aW50NjQsYm9vbCx1aW50NjQsYnl0ZVsyNF0sYnl0ZVszNl0sYnl0ZVtdLHVpbnQ4LHVpbnQ2NCxib29sLHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJnYXRlZEVkaXRSZXBseSh1aW50NjQsYm9vbCxieXRlWzM2XSxieXRlWzMyXSxieXRlW11bXSl2b2lkIiwgbWV0aG9kICJlZGl0UmVwbHkodWludDY0LGJvb2wsYnl0ZVszNl0sYnl0ZVszMl0pdm9pZCIsIG1ldGhvZCAidm90ZSh1aW50NjQsYm9vbCxieXRlW10sdWludDgsYm9vbCl2b2lkIiwgbWV0aG9kICJlZGl0Vm90ZSh1aW50NjQsYm9vbCxieXRlWzMyXSxib29sKXZvaWQiLCBtZXRob2QgImdhdGVkUmVhY3QodWludDY0LGJvb2wsYnl0ZVtdLHVpbnQ4LHVpbnQ2NCxieXRlW11bXSl2b2lkIiwgbWV0aG9kICJyZWFjdCh1aW50NjQsYm9vbCxieXRlW10sdWludDgsdWludDY0KXZvaWQiLCBtZXRob2QgImRlbGV0ZVJlYWN0aW9uKHVpbnQ2NCxib29sLGJ5dGVbMzJdLHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJnYXRlZEZvbGxvdyh1aW50NjQsYm9vbCxhZGRyZXNzLGJ5dGVbXVtdKXZvaWQiLCBtZXRob2QgImZvbGxvdyh1aW50NjQsYm9vbCxhZGRyZXNzKXZvaWQiLCBtZXRob2QgInVuZm9sbG93KHVpbnQ2NCxib29sLGFkZHJlc3Mpdm9pZCIsIG1ldGhvZCAiYmxvY2sodWludDY0LGJvb2wsYWRkcmVzcyl2b2lkIiwgbWV0aG9kICJ1bmJsb2NrKHVpbnQ2NCxib29sLGFkZHJlc3Mpdm9pZCIsIG1ldGhvZCAiYWRkTW9kZXJhdG9yKHVpbnQ2NCxib29sLGFkZHJlc3Mpdm9pZCIsIG1ldGhvZCAicmVtb3ZlTW9kZXJhdG9yKHVpbnQ2NCxib29sLGFkZHJlc3Mpdm9pZCIsIG1ldGhvZCAiYmFuKHVpbnQ2NCxib29sLGFkZHJlc3MsdWludDY0KXZvaWQiLCBtZXRob2QgImZsYWdQb3N0KHVpbnQ2NCxib29sLGJ5dGVbMzJdKXZvaWQiLCBtZXRob2QgInVuZmxhZ1Bvc3QodWludDY0LGJvb2wsYnl0ZVszMl0pdm9pZCIsIG1ldGhvZCAidW5iYW4odWludDY0LGJvb2wsYWRkcmVzcyl2b2lkIiwgbWV0aG9kICJhZGRBY3Rpb24odWludDY0LGJvb2wsdWludDY0LGJ5dGVbMzZdKXZvaWQiLCBtZXRob2QgInJlbW92ZUFjdGlvbih1aW50NjQsYm9vbCx1aW50NjQpdm9pZCIsIG1ldGhvZCAiaW5pdE1ldGEodWludDY0LGJvb2wsYWRkcmVzcyxib29sLHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NCIsIG1ldGhvZCAidXBkYXRlTWV0YSh1aW50NjQsYm9vbCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJ1cGRhdGVBa2l0YURBTyh1aW50NjQpdm9pZCIsIG1ldGhvZCAib3BVcCgpdm9pZCIsIG1ldGhvZCAibWJyKGJ5dGVbXSkodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkiLCBtZXRob2QgInBheVdhbGxNYnIoKCh1aW50OCx1aW50NjQsdWludDY0KVtdLCh1aW50OCx1aW50NjQsdWludDY0KVtdKSl1aW50NjQiLCBtZXRob2QgImNoZWNrVGlwTWJyUmVxdWlyZW1lbnRzKHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCkodWludDgsdWludDY0KSIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIHBvc3QgZWRpdFBvc3QgZ2F0ZWRSZXBseSByZXBseSBnYXRlZEVkaXRSZXBseSBlZGl0UmVwbHkgdm90ZSBlZGl0Vm90ZSBnYXRlZFJlYWN0IHJlYWN0IGRlbGV0ZVJlYWN0aW9uIGdhdGVkRm9sbG93IGZvbGxvdyB1bmZvbGxvdyBibG9jayB1bmJsb2NrIGFkZE1vZGVyYXRvciByZW1vdmVNb2RlcmF0b3IgYmFuIGZsYWdQb3N0IHVuZmxhZ1Bvc3QgdW5iYW4gYWRkQWN0aW9uIHJlbW92ZUFjdGlvbiBpbml0TWV0YSB1cGRhdGVNZXRhIHVwZGF0ZUFraXRhREFPIG1haW5fb3BVcF9yb3V0ZUAzMiBtYnIgcGF5V2FsbE1iciBjaGVja1RpcE1iclJlcXVpcmVtZW50cwogICAgZXJyCgptYWluX29wVXBfcm91dGVAMzI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czo0MwogICAgLy8gb3BVcCgpOiB2b2lkIHsgfQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9jcmVhdGVfTm9PcEAzNzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjE5CiAgICAvLyBleHBvcnQgY2xhc3MgQWtpdGFTb2NpYWxQbHVnaW4gZXh0ZW5kcyBjbGFzc2VzKEJhc2VTb2NpYWwsIEFraXRhQmFzZUNvbnRyYWN0KSB7CiAgICBwdXNoYnl0ZXMgMHg4OGM5NDBmOCAvLyBtZXRob2QgImNyZWF0ZShzdHJpbmcsdWludDY0LHVpbnQ2NCl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggY3JlYXRlCiAgICBlcnIKCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjpnZXRBY2NvdW50cyh3YWxsZXQ6IHVpbnQ2NCkgLT4gYnl0ZXM6CmdldEFjY291bnRzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNTMKICAgIC8vIGV4cG9ydCBmdW5jdGlvbiBnZXRBY2NvdW50cyh3YWxsZXQ6IEFwcGxpY2F0aW9uKTogQXJjNThBY2NvdW50cyB7CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTYxLTE2NAogICAgLy8gY29uc3QgW2NvbnRyb2xsZWRBY2NvdW50Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldElELAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcykKICAgIC8vICkKICAgIGZyYW1lX2RpZyAtMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNjMKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzKQogICAgcHVzaGJ5dGVzICJjb250cm9sbGVkX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE2MS0xNjQKICAgIC8vIGNvbnN0IFtjb250cm9sbGVkQWNjb3VudEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXRJRCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBmcmFtZV9kaWcgLTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18yIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNjktMTcyCiAgICAvLyBjb25zdCBbcmVmZXJyZXJCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0SUQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1JlZmVycmVyKQogICAgLy8gKQogICAgZnJhbWVfZGlnIC0xCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE3MQogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzUmVmZXJyZXIpCiAgICBwdXNoYnl0ZXMgInJlZmVycmVyIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNjktMTcyCiAgICAvLyBjb25zdCBbcmVmZXJyZXJCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0SUQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1JlZmVycmVyKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNTgKICAgIC8vIHdhbGxldEFkZHJlc3M6IHdhbGxldC5hZGRyZXNzLAogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI1Ny0yNjIKICAgIC8vIHJldHVybiB7CiAgICAvLyAgIHdhbGxldEFkZHJlc3M6IHdhbGxldC5hZGRyZXNzLAogICAgLy8gICBvcmlnaW4sCiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVmZXJyZXIKICAgIC8vIH0KICAgIHVuY292ZXIgMwogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjpyZWtleUFkZHJlc3MocmVrZXlCYWNrOiB1aW50NjQsIHdhbGxldDogdWludDY0KSAtPiBieXRlczoKcmVrZXlBZGRyZXNzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjEKICAgIC8vIGV4cG9ydCBmdW5jdGlvbiByZWtleUFkZHJlc3MocmVrZXlCYWNrOiBib29sZWFuLCB3YWxsZXQ6IEFwcGxpY2F0aW9uKTogQWNjb3VudCB7CiAgICBwcm90byAyIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzIyCiAgICAvLyBpZiAoIXJla2V5QmFjaykgewogICAgZnJhbWVfZGlnIC0yCiAgICBibnogcmVrZXlBZGRyZXNzX2FmdGVyX2lmX2Vsc2VAMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjMKICAgIC8vIHJldHVybiBHbG9iYWwuemVyb0FkZHJlc3MKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgcmV0c3ViCgpyZWtleUFkZHJlc3NfYWZ0ZXJfaWZfZWxzZUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjYKICAgIC8vIHJldHVybiB3YWxsZXQuYWRkcmVzcwogICAgZnJhbWVfZGlnIC0xCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo6QWtpdGFTb2NpYWxQbHVnaW4uY3JlYXRlW3JvdXRpbmddKCkgLT4gdm9pZDoKY3JlYXRlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MjMKICAgIC8vIEBhYmltZXRob2QoeyBvbkNyZWF0ZTogJ3JlcXVpcmUnIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdXRmOFtdKQogICAgZXh0cmFjdCAyIDAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI3CiAgICAvLyB2ZXJzaW9uID0gR2xvYmFsU3RhdGU8c3RyaW5nPih7IGtleTogR2xvYmFsU3RhdGVLZXlWZXJzaW9uIH0pCiAgICBwdXNoYnl0ZXMgInZlcnNpb24iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoyNQogICAgLy8gdGhpcy52ZXJzaW9uLnZhbHVlID0gdmVyc2lvbgogICAgdW5jb3ZlciAyCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoyNgogICAgLy8gdGhpcy5ha2l0YURBTy52YWx1ZSA9IEFwcGxpY2F0aW9uKGFraXRhREFPKQogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjIzCiAgICAvLyBAYWJpbWV0aG9kKHsgb25DcmVhdGU6ICdyZXF1aXJlJyB9KQogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjpBa2l0YVNvY2lhbFBsdWdpbi5wb3N0W3JvdXRpbmddKCkgLT4gdm9pZDoKcG9zdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjg4LTk3CiAgICAvLyBwb3N0KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIHRpbWVzdGFtcDogdWludDY0LAogICAgLy8gICBub25jZTogYnl0ZXM8MjQ+LAogICAgLy8gICBjaWQ6IENJRCwKICAgIC8vICAgZ2F0ZUlEOiB1aW50NjQsCiAgICAvLyAgIHVzZVBheVdhbGw6IGJvb2xlYW4sCiAgICAvLyAgIHBheVdhbGxJRDogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzI0XQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzYgLy8gMzYKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzM2XQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDcKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDgKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgNwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzIgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxMDAKICAgIC8vIGNvbnN0IGFraXRhU29jaWFsID0gQXBwbGljYXRpb24oZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnNvY2lhbCkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjEwMAogICAgLy8gY29uc3QgYWtpdGFTb2NpYWwgPSBBcHBsaWNhdGlvbihnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc29jaWFsKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDUKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFTb2NpYWxBcHBMaXN0KSkKICAgIGJ5dGVjXzEgLy8gInNhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjEwMAogICAgLy8gY29uc3QgYWtpdGFTb2NpYWwgPSBBcHBsaWNhdGlvbihnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc29jaWFsKQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxMDEKICAgIC8vIGNvbnN0IHsgcG9zdHMsIHZvdGVzLCB2b3RlbGlzdCB9ID0gdGhpcy5tYnIoY2lkKQogICAgZGlnIDUKICAgIGNhbGxzdWIgc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjpCYXNlU29jaWFsLm1icgogICAgZHVwCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDEKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIGV4dHJhY3RfdWludDY0CiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxMDMKICAgIC8vIGNvbnN0IG1ickFtb3VudDogdWludDY0ID0gcG9zdHMgKyB2b3RlcyArIHZvdGVsaXN0CiAgICBjb3ZlciAyCiAgICArCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxMDYKICAgIC8vIHJlY2VpdmVyOiBha2l0YVNvY2lhbC5hZGRyZXNzLAogICAgZGlnIDEKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjExMAogICAgLy8gY29uc3QgYWt0YSA9IEFzc2V0KGdldEFraXRhQXNzZXRzKHRoaXMuYWtpdGFEQU8udmFsdWUpLmFrdGEpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxMTAKICAgIC8vIGNvbnN0IGFrdGEgPSBBc3NldChnZXRBa2l0YUFzc2V0cyh0aGlzLmFraXRhREFPLnZhbHVlKS5ha3RhKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OTQKICAgIC8vIGNvbnN0IGFraXRhQXNzZXRzQnl0ZXMgPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFzc2V0cykpWzBdCiAgICBkdXAKICAgIGJ5dGVjIDQgLy8gImFraXRhX2Fzc2V0cyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjExMAogICAgLy8gY29uc3QgYWt0YSA9IEFzc2V0KGdldEFraXRhQXNzZXRzKHRoaXMuYWtpdGFEQU8udmFsdWUpLmFrdGEpCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NjkKICAgIC8vIGNvbnN0IFtzb2NpYWxGZWVzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzU29jaWFsRmVlcykpCiAgICBzd2FwCiAgICBieXRlYyA1IC8vICJzb2NpYWxfZmVlcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjExMQogICAgLy8gY29uc3QgeyBwb3N0RmVlIH0gPSBnZXRTb2NpYWxGZWVzKHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjExNAogICAgLy8gYXNzZXRSZWNlaXZlcjogYWtpdGFTb2NpYWwuYWRkcmVzcywKICAgIGRpZyA0CiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxMTktMTMzCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbC5wcm90b3R5cGUucG9zdD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBha2l0YVNvY2lhbCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgdGlwLAogICAgLy8gICAgIHRpbWVzdGFtcCwKICAgIC8vICAgICBub25jZSwKICAgIC8vICAgICBjaWQsCiAgICAvLyAgICAgZ2F0ZUlELAogICAgLy8gICAgIHVzZVBheVdhbGwsCiAgICAvLyAgICAgcGF5V2FsbElECiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICB1bmNvdmVyIDQKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGRpZyA1CiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTA0LTEwOAogICAgLy8gY29uc3QgbWJyUGF5bWVudCA9IGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IGFraXRhU29jaWFsLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogbWJyQW1vdW50CiAgICAvLyB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTI0CiAgICAvLyB0aXAsCiAgICBpdHhuX25leHQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIGRpZyAyCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTEyLTExNwogICAgLy8gY29uc3QgdGlwID0gaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhc3NldFJlY2VpdmVyOiBha2l0YVNvY2lhbC5hZGRyZXNzLAogICAgLy8gICB4ZmVyQXNzZXQ6IGFrdGEsCiAgICAvLyAgIGFzc2V0QW1vdW50OiBwb3N0RmVlCiAgICAvLyB9KQogICAgcHVzaGludCA0IC8vIDQKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTE5LTEzMwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWwucHJvdG90eXBlLnBvc3Q+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogYWtpdGFTb2NpYWwsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJQYXltZW50LAogICAgLy8gICAgIHRpcCwKICAgIC8vICAgICB0aW1lc3RhbXAsCiAgICAvLyAgICAgbm9uY2UsCiAgICAvLyAgICAgY2lkLAogICAgLy8gICAgIGdhdGVJRCwKICAgIC8vICAgICB1c2VQYXlXYWxsLAogICAgLy8gICAgIHBheVdhbGxJRAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxMzIKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIHVuY292ZXIgOAogICAgdW5jb3ZlciA5CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTE5LTEzMwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWwucHJvdG90eXBlLnBvc3Q+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogYWtpdGFTb2NpYWwsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJQYXltZW50LAogICAgLy8gICAgIHRpcCwKICAgIC8vICAgICB0aW1lc3RhbXAsCiAgICAvLyAgICAgbm9uY2UsCiAgICAvLyAgICAgY2lkLAogICAgLy8gICAgIGdhdGVJRCwKICAgIC8vICAgICB1c2VQYXlXYWxsLAogICAgLy8gICAgIHBheVdhbGxJRAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4NzEwNWJiYWQgLy8gbWV0aG9kICJwb3N0KHBheSxheGZlcix1aW50NjQsYnl0ZVsyNF0sYnl0ZVszNl0sdWludDY0LGJvb2wsdWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA4CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA3CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA1CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6ODgtOTcKICAgIC8vIHBvc3QoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgdGltZXN0YW1wOiB1aW50NjQsCiAgICAvLyAgIG5vbmNlOiBieXRlczwyND4sCiAgICAvLyAgIGNpZDogQ0lELAogICAgLy8gICBnYXRlSUQ6IHVpbnQ2NCwKICAgIC8vICAgdXNlUGF5V2FsbDogYm9vbGVhbiwKICAgIC8vICAgcGF5V2FsbElEOiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjpBa2l0YVNvY2lhbFBsdWdpbi5lZGl0UG9zdFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmVkaXRQb3N0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTM2LTE0MQogICAgLy8gZWRpdFBvc3QoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgY2lkOiBDSUQsCiAgICAvLyAgIGFtZW5kbWVudDogYnl0ZXM8MzI+CiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzNiAvLyAzNgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzZdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzIgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxNDQKICAgIC8vIGNvbnN0IHsgc29jaWFsIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjE0NAogICAgLy8gY29uc3QgeyBzb2NpYWwgfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDUKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFTb2NpYWxBcHBMaXN0KSkKICAgIGJ5dGVjXzEgLy8gInNhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjE0NAogICAgLy8gY29uc3QgeyBzb2NpYWwgfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxNDUKICAgIC8vIGNvbnN0IHsgcG9zdHMsIHZvdGVzLCB2b3RlbGlzdCB9ID0gdGhpcy5tYnIoY2lkKQogICAgZGlnIDMKICAgIGNhbGxzdWIgc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjpCYXNlU29jaWFsLm1icgogICAgZHVwCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDEKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIGV4dHJhY3RfdWludDY0CiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxNDYKICAgIC8vIGNvbnN0IG1ickFtb3VudDogdWludDY0ID0gcG9zdHMgKyB2b3RlcyArIHZvdGVsaXN0ICsgQW1lbmRtZW50TUJSCiAgICBjb3ZlciAyCiAgICArCiAgICArCiAgICBwdXNoaW50IDEzMjAwIC8vIDEzMjAwCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxNDkKICAgIC8vIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihzb2NpYWwpLmFkZHJlc3MsCiAgICBkaWcgMQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTUzCiAgICAvLyBjb25zdCBha3RhID0gQXNzZXQoZ2V0QWtpdGFBc3NldHModGhpcy5ha2l0YURBTy52YWx1ZSkuYWt0YSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjE1MwogICAgLy8gY29uc3QgYWt0YSA9IEFzc2V0KGdldEFraXRhQXNzZXRzKHRoaXMuYWtpdGFEQU8udmFsdWUpLmFrdGEpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo5NAogICAgLy8gY29uc3QgYWtpdGFBc3NldHNCeXRlcyA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXNzZXRzKSlbMF0KICAgIGR1cAogICAgYnl0ZWMgNCAvLyAiYWtpdGFfYXNzZXRzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTUzCiAgICAvLyBjb25zdCBha3RhID0gQXNzZXQoZ2V0QWtpdGFBc3NldHModGhpcy5ha2l0YURBTy52YWx1ZSkuYWt0YSkKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo2OQogICAgLy8gY29uc3QgW3NvY2lhbEZlZXNCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNTb2NpYWxGZWVzKSkKICAgIHN3YXAKICAgIGJ5dGVjIDUgLy8gInNvY2lhbF9mZWVzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTU0CiAgICAvLyBjb25zdCB7IHBvc3RGZWUgfSA9IGdldFNvY2lhbEZlZXModGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTU3CiAgICAvLyBhc3NldFJlY2VpdmVyOiBBcHBsaWNhdGlvbihzb2NpYWwpLmFkZHJlc3MsCiAgICBkaWcgNAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTYzLTE3MwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWwucHJvdG90eXBlLmVkaXRQb3N0Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgdGlwLAogICAgLy8gICAgIGNpZCwKICAgIC8vICAgICBhbWVuZG1lbnQKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIHVuY292ZXIgNAogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIHVuY292ZXIgMwogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZGlnIDUKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxNDctMTUxCiAgICAvLyBjb25zdCBtYnJQYXltZW50ID0gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogQXBwbGljYXRpb24oc29jaWFsKS5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IG1ickFtb3VudAogICAgLy8gfSkKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjE2OAogICAgLy8gdGlwLAogICAgaXR4bl9uZXh0CiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBkaWcgMgogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjE1NS0xNjAKICAgIC8vIGNvbnN0IHRpcCA9IGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXNzZXRSZWNlaXZlcjogQXBwbGljYXRpb24oc29jaWFsKS5hZGRyZXNzLAogICAgLy8gICB4ZmVyQXNzZXQ6IGFrdGEsCiAgICAvLyAgIGFzc2V0QW1vdW50OiBwb3N0RmVlCiAgICAvLyB9KQogICAgcHVzaGludCA0IC8vIDQKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTYzLTE3MwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWwucHJvdG90eXBlLmVkaXRQb3N0Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgdGlwLAogICAgLy8gICAgIGNpZCwKICAgIC8vICAgICBhbWVuZG1lbnQKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTcyCiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICB1bmNvdmVyIDQKICAgIHVuY292ZXIgNQogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjE2My0xNzMKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsLnByb3RvdHlwZS5lZGl0UG9zdD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBzb2NpYWwsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJQYXltZW50LAogICAgLy8gICAgIHRpcCwKICAgIC8vICAgICBjaWQsCiAgICAvLyAgICAgYW1lbmRtZW50CiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHhiYTRiZjc5NCAvLyBtZXRob2QgImVkaXRQb3N0KHBheSxheGZlcixieXRlWzM2XSxieXRlWzMyXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjEzNi0xNDEKICAgIC8vIGVkaXRQb3N0KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGNpZDogQ0lELAogICAgLy8gICBhbWVuZG1lbnQ6IGJ5dGVzPDMyPgogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OkFraXRhU29jaWFsUGx1Z2luLmdhdGVkUmVwbHlbcm91dGluZ10oKSAtPiB2b2lkOgpnYXRlZFJlcGx5OgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjE3Ni0xODgKICAgIC8vIGdhdGVkUmVwbHkoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgdGltZXN0YW1wOiB1aW50NjQsCiAgICAvLyAgIG5vbmNlOiBieXRlczwyND4sCiAgICAvLyAgIGNpZDogQ0lELAogICAgLy8gICByZWY6IGJ5dGVzLAogICAgLy8gICB0eXBlOiBSZWZUeXBlLAogICAgLy8gICBnYXRlSUQ6IHVpbnQ2NCwKICAgIC8vICAgYXJnczogR2F0ZUFyZ3MsCiAgICAvLyAgIHVzZVBheVdhbGw6IGJvb2xlYW4sCiAgICAvLyAgIHBheVdhbGxJRDogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHN3YXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgY292ZXIgMgogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGxlbgogICAgcHVzaGludCAyNCAvLyAyNAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMjRdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDM2IC8vIDM2CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszNl0KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDYKICAgIGR1cAogICAgY292ZXIgMwogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3VpbnQ4W10pCiAgICBleHRyYWN0IDIgMAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNwogICAgZHVwCiAgICBjb3ZlciA0CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA4CiAgICBkdXAKICAgIGNvdmVyIDUKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgOQogICAgY292ZXIgNAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMTAKICAgIGR1cAogICAgY292ZXIgNQogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDExCiAgICBkdXAKICAgIGNvdmVyIDUKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTg5CiAgICAvLyBjb25zdCB7IG9yaWdpbiwgc2VuZGVyIH0gPSBnZXRBY2NvdW50cyh3YWxsZXQpCiAgICB1bmNvdmVyIDMKICAgIGNhbGxzdWIgZ2V0QWNjb3VudHMKICAgIGR1cAogICAgZXh0cmFjdCAzMiAzMgogICAgY292ZXIgNAogICAgZXh0cmFjdCA2NCAzMgogICAgZHVwCiAgICBjb3ZlciA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxOTEKICAgIC8vIGNvbnN0IHsgZ2F0ZSB9ID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxOTEKICAgIC8vIGNvbnN0IHsgZ2F0ZSB9ID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgZHVwCiAgICBieXRlYyA3IC8vICJhYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxOTEKICAgIC8vIGNvbnN0IHsgZ2F0ZSB9ID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgY292ZXIgNQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0NQogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YVNvY2lhbEFwcExpc3QpKQogICAgYnl0ZWNfMSAvLyAic2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTkyCiAgICAvLyBjb25zdCB7IHNvY2lhbCB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGNvdmVyIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjE5MwogICAgLy8gY29uc3QgeyBwb3N0cywgdm90ZXMsIHZvdGVsaXN0IH0gPSB0aGlzLm1icihjaWQpCiAgICB1bmNvdmVyIDMKICAgIGNhbGxzdWIgc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjpCYXNlU29jaWFsLm1icgogICAgZHVwCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDEKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIGV4dHJhY3RfdWludDY0CiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxOTQKICAgIC8vIGxldCBtYnJBbW91bnQ6IHVpbnQ2NCA9IHBvc3RzICsgdm90ZXMgKyB2b3RlbGlzdAogICAgY292ZXIgMgogICAgKwogICAgKwogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTk2CiAgICAvLyBjb25zdCB7IHBvc3RFeGlzdHMsIGNyZWF0b3IsIGNyZWF0b3JXYWxsZXQsIGdhdGVJRDogcG9zdEdhdGVJRCB9ID0gdGhpcy5nZXRDcmVhdG9yRGV0YWlscyh0eXBlLCBzZW5kZXIsIHJlZi50b0ZpeGVkKHsgbGVuZ3RoOiAzMiB9KSkKICAgIGRpZyAyCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gTGVuZ3RoIG11c3QgYmUgMzIKICAgIHVuY292ZXIgMgogICAgY2FsbHN1YiBnZXRDcmVhdG9yRGV0YWlscwogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBkaWcgMQogICAgZXh0cmFjdCAxIDMyCiAgICBjb3ZlciAyCiAgICBkaWcgMQogICAgcHVzaGludCAzMyAvLyAzMwogICAgZXh0cmFjdF91aW50NjQKICAgIGNvdmVyIDIKICAgIHN3YXAKICAgIGV4dHJhY3QgNDEgOAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTk4CiAgICAvLyBpZiAoIXBvc3RFeGlzdHMpIHsKICAgIGJueiBnYXRlZFJlcGx5X2FmdGVyX2lmX2Vsc2VAMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTk5CiAgICAvLyBtYnJBbW91bnQgKz0gdGhpcy5tYnIob3AuYnplcm8oMCkpLnBvc3RzCiAgICBpbnRjXzAgLy8gMAogICAgYnplcm8KICAgIGNhbGxzdWIgc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjpCYXNlU29jaWFsLm1icgogICAgcHVzaGludCAxNiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgIGRpZyA0CiAgICArCiAgICBidXJ5IDQKCmdhdGVkUmVwbHlfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MjAyCiAgICAvLyBjb25zdCB0aXBJbmZvID0gdGhpcy5jaGVja1RpcE1iclJlcXVpcmVtZW50cyh0aGlzLmFraXRhREFPLnZhbHVlLCBjcmVhdG9yLCBBcHBsaWNhdGlvbihjcmVhdG9yV2FsbGV0KSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjIwMgogICAgLy8gY29uc3QgdGlwSW5mbyA9IHRoaXMuY2hlY2tUaXBNYnJSZXF1aXJlbWVudHModGhpcy5ha2l0YURBTy52YWx1ZSwgY3JlYXRvciwgQXBwbGljYXRpb24oY3JlYXRvcldhbGxldCkpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZGlnIDMKICAgIGRpZyAzCiAgICBjYWxsc3ViIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czo6QmFzZVNvY2lhbC5jaGVja1RpcE1iclJlcXVpcmVtZW50cwogICAgZHVwCiAgICBidXJ5IDIxCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoyMDQKICAgIC8vIGlmICh0aXBJbmZvLnR5cGUgPT09IFRpcFNlbmRUeXBlQVJDNTgpIHsKICAgIGV4dHJhY3QgMCAxCiAgICBieXRlYyA2IC8vIDB4MTQKICAgID09CiAgICBieiBnYXRlZFJlcGx5X2FmdGVyX2lmX2Vsc2VANQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MjA1CiAgICAvLyBtYnJBbW91bnQgKz0gdGlwSW5mby5hcmM1OAogICAgZGlnIDE5CiAgICBpbnRjXzEgLy8gMQogICAgZXh0cmFjdF91aW50NjQKICAgIGRpZyA0CiAgICArCiAgICBidXJ5IDQKCmdhdGVkUmVwbHlfYWZ0ZXJfaWZfZWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MjEwCiAgICAvLyByZWNlaXZlcjogQXBwbGljYXRpb24oc29jaWFsKS5hZGRyZXNzLAogICAgZGlnIDQKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MjE0CiAgICAvLyBjb25zdCBha3RhID0gQXNzZXQoZ2V0QWtpdGFBc3NldHModGhpcy5ha2l0YURBTy52YWx1ZSkuYWt0YSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjIxNAogICAgLy8gY29uc3QgYWt0YSA9IEFzc2V0KGdldEFraXRhQXNzZXRzKHRoaXMuYWtpdGFEQU8udmFsdWUpLmFrdGEpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo5NAogICAgLy8gY29uc3QgYWtpdGFBc3NldHNCeXRlcyA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXNzZXRzKSlbMF0KICAgIGR1cAogICAgYnl0ZWMgNCAvLyAiYWtpdGFfYXNzZXRzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MjE0CiAgICAvLyBjb25zdCBha3RhID0gQXNzZXQoZ2V0QWtpdGFBc3NldHModGhpcy5ha2l0YURBTy52YWx1ZSkuYWt0YSkKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo2OQogICAgLy8gY29uc3QgW3NvY2lhbEZlZXNCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNTb2NpYWxGZWVzKSkKICAgIHN3YXAKICAgIGJ5dGVjIDUgLy8gInNvY2lhbF9mZWVzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MjE1CiAgICAvLyBjb25zdCB7IHJlYWN0RmVlIH0gPSBnZXRTb2NpYWxGZWVzKHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBpbnRjXzIgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjIxOAogICAgLy8gYXNzZXRSZWNlaXZlcjogQXBwbGljYXRpb24oc29jaWFsKS5hZGRyZXNzLAogICAgZGlnIDMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjIzNi0yNTMKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsLnByb3RvdHlwZS5nYXRlZFJlcGx5Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgdGlwLAogICAgLy8gICAgIGdhdGVUeG4sCiAgICAvLyAgICAgdGltZXN0YW1wLAogICAgLy8gICAgIG5vbmNlLAogICAgLy8gICAgIGNpZCwKICAgIC8vICAgICByZWYsCiAgICAvLyAgICAgdHlwZSwKICAgIC8vICAgICBnYXRlSUQsCiAgICAvLyAgICAgdXNlUGF5V2FsbCwKICAgIC8vICAgICBwYXlXYWxsSUQKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIGRpZyA4CiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgMTAKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjIwOC0yMTIKICAgIC8vIGNvbnN0IG1iclBheW1lbnQgPSBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihzb2NpYWwpLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogbWJyQW1vdW50CiAgICAvLyB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MjQxCiAgICAvLyB0aXAsCiAgICBpdHhuX25leHQKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgc3dhcAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoyMTYtMjIxCiAgICAvLyBjb25zdCB0aXAgPSBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHNvY2lhbCkuYWRkcmVzcywKICAgIC8vICAgeGZlckFzc2V0OiBha3RhLAogICAgLy8gICBhc3NldEFtb3VudDogcmVhY3RGZWUKICAgIC8vIH0pCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoyNDIKICAgIC8vIGdhdGVUeG4sCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjIyOQogICAgLy8gbWV0aG9kU2VsZWN0b3IoR2F0ZU11c3RDaGVja0FiaU1ldGhvZCksCiAgICBieXRlYyA4IC8vIG1ldGhvZCAibXVzdENoZWNrKGFkZHJlc3MsdWludDY0LGJ5dGVbXVtdKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDkKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA3CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjIyNS0yMzQKICAgIC8vIGNvbnN0IGdhdGVUeG4gPSBpdHhuLmFwcGxpY2F0aW9uQ2FsbCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdhdGUsCiAgICAvLyAgIGFwcEFyZ3M6IFsKICAgIC8vICAgICBtZXRob2RTZWxlY3RvcihHYXRlTXVzdENoZWNrQWJpTWV0aG9kKSwKICAgIC8vICAgICBvcmlnaW4sCiAgICAvLyAgICAgcG9zdEdhdGVJRCwKICAgIC8vICAgICBlbmNvZGVBcmM0KGFyZ3MpCiAgICAvLyAgIF0KICAgIC8vIH0pCiAgICBpbnRjXzMgLy8gNgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoyMzYtMjUzCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbC5wcm90b3R5cGUuZ2F0ZWRSZXBseT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBzb2NpYWwsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJQYXltZW50LAogICAgLy8gICAgIHRpcCwKICAgIC8vICAgICBnYXRlVHhuLAogICAgLy8gICAgIHRpbWVzdGFtcCwKICAgIC8vICAgICBub25jZSwKICAgIC8vICAgICBjaWQsCiAgICAvLyAgICAgcmVmLAogICAgLy8gICAgIHR5cGUsCiAgICAvLyAgICAgZ2F0ZUlELAogICAgLy8gICAgIHVzZVBheVdhbGwsCiAgICAvLyAgICAgcGF5V2FsbElECiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjI1MgogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgZGlnIDE5CiAgICBkaWcgMjEKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoyMzYtMjUzCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbC5wcm90b3R5cGUuZ2F0ZWRSZXBseT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBzb2NpYWwsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJQYXltZW50LAogICAgLy8gICAgIHRpcCwKICAgIC8vICAgICBnYXRlVHhuLAogICAgLy8gICAgIHRpbWVzdGFtcCwKICAgIC8vICAgICBub25jZSwKICAgIC8vICAgICBjaWQsCiAgICAvLyAgICAgcmVmLAogICAgLy8gICAgIHR5cGUsCiAgICAvLyAgICAgZ2F0ZUlELAogICAgLy8gICAgIHVzZVBheVdhbGwsCiAgICAvLyAgICAgcGF5V2FsbElECiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHhkNWM4ZTdiOCAvLyBtZXRob2QgImdhdGVkUmVwbHkocGF5LGF4ZmVyLGFwcGwsdWludDY0LGJ5dGVbMjRdLGJ5dGVbMzZdLGJ5dGVbXSx1aW50OCx1aW50NjQsYm9vbCx1aW50NjQpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTkKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTgKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTcKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTYKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxNzYtMTg4CiAgICAvLyBnYXRlZFJlcGx5KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIHRpbWVzdGFtcDogdWludDY0LAogICAgLy8gICBub25jZTogYnl0ZXM8MjQ+LAogICAgLy8gICBjaWQ6IENJRCwKICAgIC8vICAgcmVmOiBieXRlcywKICAgIC8vICAgdHlwZTogUmVmVHlwZSwKICAgIC8vICAgZ2F0ZUlEOiB1aW50NjQsCiAgICAvLyAgIGFyZ3M6IEdhdGVBcmdzLAogICAgLy8gICB1c2VQYXlXYWxsOiBib29sZWFuLAogICAgLy8gICBwYXlXYWxsSUQ6IHVpbnQ2NAogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OkFraXRhU29jaWFsUGx1Z2luLnJlcGx5W3JvdXRpbmddKCkgLT4gdm9pZDoKcmVwbHk6CiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MjU2LTI2NwogICAgLy8gcmVwbHkoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgdGltZXN0YW1wOiB1aW50NjQsCiAgICAvLyAgIG5vbmNlOiBieXRlczwyND4sCiAgICAvLyAgIGNpZDogQ0lELAogICAgLy8gICByZWY6IGJ5dGVzLAogICAgLy8gICB0eXBlOiBSZWZUeXBlLAogICAgLy8gICBnYXRlSUQ6IHVpbnQ2NCwKICAgIC8vICAgdXNlUGF5V2FsbDogYm9vbGVhbiwKICAgIC8vICAgcGF5V2FsbElEOiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgc3dhcAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBjb3ZlciAyCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgY292ZXIgMgogICAgbGVuCiAgICBwdXNoaW50IDI0IC8vIDI0CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFsyNF0KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGR1cAogICAgY292ZXIgMgogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzYgLy8gMzYKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzM2XQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgZHVwCiAgICBjb3ZlciAzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdWludDhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA3CiAgICBkdXAKICAgIGNvdmVyIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDgKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDgKICAgIGR1cAogICAgY292ZXIgNQogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA5CiAgICBkdXAKICAgIGNvdmVyIDUKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxMAogICAgZHVwCiAgICBjb3ZlciA1CiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIHVuY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzIgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBkdXAKICAgIGNvdmVyIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjI3MAogICAgLy8gY29uc3QgeyBzb2NpYWwgfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MjcwCiAgICAvLyBjb25zdCB7IHNvY2lhbCB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0NQogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YVNvY2lhbEFwcExpc3QpKQogICAgYnl0ZWNfMSAvLyAic2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MjcwCiAgICAvLyBjb25zdCB7IHNvY2lhbCB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGNvdmVyIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjI3MQogICAgLy8gY29uc3QgeyBwb3N0cywgdm90ZXMsIHZvdGVsaXN0IH0gPSB0aGlzLm1icihjaWQpCiAgICB1bmNvdmVyIDMKICAgIGNhbGxzdWIgc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjpCYXNlU29jaWFsLm1icgogICAgZHVwCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDEKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIGV4dHJhY3RfdWludDY0CiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoyNzIKICAgIC8vIGxldCBtYnJBbW91bnQ6IHVpbnQ2NCA9IHBvc3RzICsgdm90ZXMgKyB2b3RlbGlzdAogICAgY292ZXIgMgogICAgKwogICAgKwogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6Mjc0CiAgICAvLyBjb25zdCB7IHBvc3RFeGlzdHMsIGNyZWF0b3IsIGNyZWF0b3JXYWxsZXQgfSA9IHRoaXMuZ2V0Q3JlYXRvckRldGFpbHModHlwZSwgc2VuZGVyLCByZWYudG9GaXhlZCh7IGxlbmd0aDogMzIgfSkpCiAgICBkaWcgMgogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIExlbmd0aCBtdXN0IGJlIDMyCiAgICB1bmNvdmVyIDIKICAgIGNhbGxzdWIgZ2V0Q3JlYXRvckRldGFpbHMKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgZGlnIDEKICAgIGV4dHJhY3QgMSAzMgogICAgY292ZXIgMgogICAgc3dhcAogICAgcHVzaGludCAzMyAvLyAzMwogICAgZXh0cmFjdF91aW50NjQKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjI3NgogICAgLy8gaWYgKCFwb3N0RXhpc3RzKSB7CiAgICBibnogcmVwbHlfYWZ0ZXJfaWZfZWxzZUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoyNzcKICAgIC8vIG1ickFtb3VudCArPSB0aGlzLm1icihvcC5iemVybygwKSkucG9zdHMKICAgIGludGNfMCAvLyAwCiAgICBiemVybwogICAgY2FsbHN1YiBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6OkJhc2VTb2NpYWwubWJyCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDMKICAgICsKICAgIGJ1cnkgMwoKcmVwbHlfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MjgwCiAgICAvLyBjb25zdCB0aXBJbmZvID0gdGhpcy5jaGVja1RpcE1iclJlcXVpcmVtZW50cyh0aGlzLmFraXRhREFPLnZhbHVlLCBjcmVhdG9yLCBBcHBsaWNhdGlvbihjcmVhdG9yV2FsbGV0KSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjI4MAogICAgLy8gY29uc3QgdGlwSW5mbyA9IHRoaXMuY2hlY2tUaXBNYnJSZXF1aXJlbWVudHModGhpcy5ha2l0YURBTy52YWx1ZSwgY3JlYXRvciwgQXBwbGljYXRpb24oY3JlYXRvcldhbGxldCkpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZGlnIDIKICAgIGRpZyAyCiAgICBjYWxsc3ViIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czo6QmFzZVNvY2lhbC5jaGVja1RpcE1iclJlcXVpcmVtZW50cwogICAgZHVwCiAgICBidXJ5IDE3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoyODIKICAgIC8vIGlmICh0aXBJbmZvLnR5cGUgPT09IFRpcFNlbmRUeXBlQVJDNTgpIHsKICAgIGV4dHJhY3QgMCAxCiAgICBieXRlYyA2IC8vIDB4MTQKICAgID09CiAgICBieiByZXBseV9hZnRlcl9pZl9lbHNlQDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjI4MwogICAgLy8gbWJyQW1vdW50ICs9IHRpcEluZm8uYXJjNTgKICAgIGRpZyAxNQogICAgaW50Y18xIC8vIDEKICAgIGV4dHJhY3RfdWludDY0CiAgICBkaWcgMwogICAgKwogICAgYnVyeSAzCgpyZXBseV9hZnRlcl9pZl9lbHNlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoyODgKICAgIC8vIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihzb2NpYWwpLmFkZHJlc3MsCiAgICBkaWcgMwogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoyOTIKICAgIC8vIGNvbnN0IGFrdGEgPSBBc3NldChnZXRBa2l0YUFzc2V0cyh0aGlzLmFraXRhREFPLnZhbHVlKS5ha3RhKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MjkyCiAgICAvLyBjb25zdCBha3RhID0gQXNzZXQoZ2V0QWtpdGFBc3NldHModGhpcy5ha2l0YURBTy52YWx1ZSkuYWt0YSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjk0CiAgICAvLyBjb25zdCBha2l0YUFzc2V0c0J5dGVzID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBc3NldHMpKVswXQogICAgZHVwCiAgICBieXRlYyA0IC8vICJha2l0YV9hc3NldHMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoyOTIKICAgIC8vIGNvbnN0IGFrdGEgPSBBc3NldChnZXRBa2l0YUFzc2V0cyh0aGlzLmFraXRhREFPLnZhbHVlKS5ha3RhKQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjY5CiAgICAvLyBjb25zdCBbc29jaWFsRmVlc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1NvY2lhbEZlZXMpKQogICAgc3dhcAogICAgYnl0ZWMgNSAvLyAic29jaWFsX2ZlZXMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoyOTMKICAgIC8vIGNvbnN0IHsgcmVhY3RGZWUgfSA9IGdldFNvY2lhbEZlZXModGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGludGNfMiAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6Mjk2CiAgICAvLyBhc3NldFJlY2VpdmVyOiBBcHBsaWNhdGlvbihzb2NpYWwpLmFkZHJlc3MsCiAgICBkaWcgMwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MzAxLTMxNwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWwucHJvdG90eXBlLnJlcGx5Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgdGlwLAogICAgLy8gICAgIHRpbWVzdGFtcCwKICAgIC8vICAgICBub25jZSwKICAgIC8vICAgICBjaWQsCiAgICAvLyAgICAgcmVmLAogICAgLy8gICAgIHR5cGUsCiAgICAvLyAgICAgZ2F0ZUlELAogICAgLy8gICAgIHVzZVBheVdhbGwsCiAgICAvLyAgICAgcGF5V2FsbElECiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICBkaWcgNwogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIHVuY292ZXIgMwogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZGlnIDgKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjI4Ni0yOTAKICAgIC8vIGNvbnN0IG1iclBheW1lbnQgPSBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihzb2NpYWwpLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogbWJyQW1vdW50CiAgICAvLyB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MzA2CiAgICAvLyB0aXAsCiAgICBpdHhuX25leHQKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgc3dhcAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoyOTQtMjk5CiAgICAvLyBjb25zdCB0aXAgPSBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHNvY2lhbCkuYWRkcmVzcywKICAgIC8vICAgeGZlckFzc2V0OiBha3RhLAogICAgLy8gICBhc3NldEFtb3VudDogcmVhY3RGZWUKICAgIC8vIH0pCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozMDEtMzE3CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbC5wcm90b3R5cGUucmVwbHk+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogc29jaWFsLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICB0aXAsCiAgICAvLyAgICAgdGltZXN0YW1wLAogICAgLy8gICAgIG5vbmNlLAogICAgLy8gICAgIGNpZCwKICAgIC8vICAgICByZWYsCiAgICAvLyAgICAgdHlwZSwKICAgIC8vICAgICBnYXRlSUQsCiAgICAvLyAgICAgdXNlUGF5V2FsbCwKICAgIC8vICAgICBwYXlXYWxsSUQKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MzE2CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICBkaWcgMTUKICAgIGRpZyAxNwogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjMwMS0zMTcKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsLnByb3RvdHlwZS5yZXBseT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBzb2NpYWwsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJQYXltZW50LAogICAgLy8gICAgIHRpcCwKICAgIC8vICAgICB0aW1lc3RhbXAsCiAgICAvLyAgICAgbm9uY2UsCiAgICAvLyAgICAgY2lkLAogICAgLy8gICAgIHJlZiwKICAgIC8vICAgICB0eXBlLAogICAgLy8gICAgIGdhdGVJRCwKICAgIC8vICAgICB1c2VQYXlXYWxsLAogICAgLy8gICAgIHBheVdhbGxJRAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4MmZmYzMxMjMgLy8gbWV0aG9kICJyZXBseShwYXksYXhmZXIsdWludDY0LGJ5dGVbMjRdLGJ5dGVbMzZdLGJ5dGVbXSx1aW50OCx1aW50NjQsYm9vbCx1aW50NjQpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgOQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA4CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MjU2LTI2NwogICAgLy8gcmVwbHkoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgdGltZXN0YW1wOiB1aW50NjQsCiAgICAvLyAgIG5vbmNlOiBieXRlczwyND4sCiAgICAvLyAgIGNpZDogQ0lELAogICAgLy8gICByZWY6IGJ5dGVzLAogICAgLy8gICB0eXBlOiBSZWZUeXBlLAogICAgLy8gICBnYXRlSUQ6IHVpbnQ2NCwKICAgIC8vICAgdXNlUGF5V2FsbDogYm9vbGVhbiwKICAgIC8vICAgcGF5V2FsbElEOiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjpBa2l0YVNvY2lhbFBsdWdpbi5nYXRlZEVkaXRSZXBseVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmdhdGVkRWRpdFJlcGx5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MzIwLTMyNgogICAgLy8gZ2F0ZWRFZGl0UmVwbHkoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgY2lkOiBDSUQsCiAgICAvLyAgIGFtZW5kbWVudDogYnl0ZXM8MzI+LAogICAgLy8gICBhcmdzOiBHYXRlQXJncwogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDM2IC8vIDM2CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszNl0KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgY292ZXIgMwogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MzI3CiAgICAvLyBjb25zdCB7IG9yaWdpbiwgc2VuZGVyIH0gPSBnZXRBY2NvdW50cyh3YWxsZXQpCiAgICB1bmNvdmVyIDIKICAgIGNhbGxzdWIgZ2V0QWNjb3VudHMKICAgIGR1cAogICAgZXh0cmFjdCAzMiAzMgogICAgY292ZXIgMwogICAgZXh0cmFjdCA2NCAzMgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBjb3ZlciAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozMjkKICAgIC8vIGNvbnN0IHsgZ2F0ZSB9ID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozMjkKICAgIC8vIGNvbnN0IHsgZ2F0ZSB9ID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgZHVwCiAgICBieXRlYyA3IC8vICJhYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozMjkKICAgIC8vIGNvbnN0IHsgZ2F0ZSB9ID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgY292ZXIgNAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0NQogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YVNvY2lhbEFwcExpc3QpKQogICAgYnl0ZWNfMSAvLyAic2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MzMwCiAgICAvLyBjb25zdCB7IHNvY2lhbCB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgY292ZXIgNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MzMxCiAgICAvLyBjb25zdCB7IHBvc3RzLCB2b3Rlcywgdm90ZWxpc3QgfSA9IHRoaXMubWJyKGNpZCkKICAgIHVuY292ZXIgMwogICAgY2FsbHN1YiBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6OkJhc2VTb2NpYWwubWJyCiAgICBkdXAKICAgIHB1c2hpbnQgMTYgLy8gMTYKICAgIGV4dHJhY3RfdWludDY0CiAgICBkaWcgMQogICAgcHVzaGludCAyNCAvLyAyNAogICAgZXh0cmFjdF91aW50NjQKICAgIHVuY292ZXIgMgogICAgcHVzaGludCAzMiAvLyAzMgogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjMzMgogICAgLy8gbGV0IG1ickFtb3VudDogdWludDY0ID0gcG9zdHMgKyB2b3RlcyArIHZvdGVsaXN0CiAgICBjb3ZlciAyCiAgICArCiAgICArCiAgICBjb3ZlciAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozMzQtMzM4CiAgICAvLyBjb25zdCBwb3N0QmVpbmdBbWVuZGVkID0gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWwucHJvdG90eXBlLmdldFBvc3Q+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogc29jaWFsLAogICAgLy8gICBhcmdzOiBbYW1lbmRtZW50XQogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIGJ5dGVjIDEwIC8vIG1ldGhvZCAiZ2V0UG9zdChieXRlWzMyXSkoYWRkcmVzcyx1aW50NjQsdWludDY0LGJvb2wsdWludDY0LGJvb2wsdWludDgsYnl0ZVtdKSIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMyAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjM0MAogICAgLy8gY29uc3Qgb3JpZ2luYWxQb3N0UmVmID0gcG9zdEJlaW5nQW1lbmRlZC5yZWYuc2xpY2UoMCwgMzIpLnRvRml4ZWQoeyBsZW5ndGg6IDMyIH0pCiAgICBkdXAKICAgIHB1c2hpbnQgNTkgLy8gNTkKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMQogICAgbGVuCiAgICBzdWJzdHJpbmczCiAgICBleHRyYWN0IDIgMAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMCAvLyAwCiAgICBkaWcgMQogICAgPj0KICAgIGludGNfMCAvLyAwCiAgICBkaWcgMgogICAgdW5jb3ZlciAyCiAgICBzZWxlY3QKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGRpZyAyCiAgICA+PQogICAgcHVzaGludCAzMiAvLyAzMgogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDIKICAgIHNlbGVjdAogICAgc3Vic3RyaW5nMwogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gTGVuZ3RoIG11c3QgYmUgMzIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjM0MgogICAgLy8gY29uc3QgeyBjcmVhdG9yLCBjcmVhdG9yV2FsbGV0LCBnYXRlSUQ6IHBvc3RHYXRlSUQgfSA9IHRoaXMuZ2V0Q3JlYXRvckRldGFpbHMoUmVmVHlwZVBvc3QsIHNlbmRlciwgb3JpZ2luYWxQb3N0UmVmKQogICAgYnl0ZWMgOSAvLyAweDBhCiAgICBjb3ZlciAyCiAgICBjYWxsc3ViIGdldENyZWF0b3JEZXRhaWxzCiAgICBkdXAKICAgIGV4dHJhY3QgMSAzMgogICAgZGlnIDEKICAgIHB1c2hpbnQgMzMgLy8gMzMKICAgIGV4dHJhY3RfdWludDY0CiAgICB1bmNvdmVyIDIKICAgIGV4dHJhY3QgNDEgOAogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MzQzCiAgICAvLyBjb25zdCB0aXBJbmZvID0gdGhpcy5jaGVja1RpcE1iclJlcXVpcmVtZW50cyh0aGlzLmFraXRhREFPLnZhbHVlLCBjcmVhdG9yLCBBcHBsaWNhdGlvbihjcmVhdG9yV2FsbGV0KSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjM0MwogICAgLy8gY29uc3QgdGlwSW5mbyA9IHRoaXMuY2hlY2tUaXBNYnJSZXF1aXJlbWVudHModGhpcy5ha2l0YURBTy52YWx1ZSwgY3JlYXRvciwgQXBwbGljYXRpb24oY3JlYXRvcldhbGxldCkpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgY292ZXIgMgogICAgY2FsbHN1YiBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6OkJhc2VTb2NpYWwuY2hlY2tUaXBNYnJSZXF1aXJlbWVudHMKICAgIGR1cAogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MzQ1CiAgICAvLyBpZiAodGlwSW5mby50eXBlID09PSBUaXBTZW5kVHlwZUFSQzU4KSB7CiAgICBleHRyYWN0IDAgMQogICAgYnl0ZWMgNiAvLyAweDE0CiAgICA9PQogICAgYnogZ2F0ZWRFZGl0UmVwbHlfYWZ0ZXJfaWZfZWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozNDYKICAgIC8vIG1ickFtb3VudCArPSB0aXBJbmZvLmFyYzU4CiAgICBkaWcgMQogICAgaW50Y18xIC8vIDEKICAgIGV4dHJhY3RfdWludDY0CiAgICArCgpnYXRlZEVkaXRSZXBseV9hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozNTEKICAgIC8vIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihzb2NpYWwpLmFkZHJlc3MsCiAgICBkaWcgMwogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozNTUKICAgIC8vIGNvbnN0IGFrdGEgPSBBc3NldChnZXRBa2l0YUFzc2V0cyh0aGlzLmFraXRhREFPLnZhbHVlKS5ha3RhKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MzU1CiAgICAvLyBjb25zdCBha3RhID0gQXNzZXQoZ2V0QWtpdGFBc3NldHModGhpcy5ha2l0YURBTy52YWx1ZSkuYWt0YSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjk0CiAgICAvLyBjb25zdCBha2l0YUFzc2V0c0J5dGVzID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBc3NldHMpKVswXQogICAgZHVwCiAgICBieXRlYyA0IC8vICJha2l0YV9hc3NldHMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozNTUKICAgIC8vIGNvbnN0IGFrdGEgPSBBc3NldChnZXRBa2l0YUFzc2V0cyh0aGlzLmFraXRhREFPLnZhbHVlKS5ha3RhKQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjY5CiAgICAvLyBjb25zdCBbc29jaWFsRmVlc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1NvY2lhbEZlZXMpKQogICAgc3dhcAogICAgYnl0ZWMgNSAvLyAic29jaWFsX2ZlZXMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozNTYKICAgIC8vIGNvbnN0IHsgcmVhY3RGZWUgfSA9IGdldFNvY2lhbEZlZXModGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGludGNfMiAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MzU5CiAgICAvLyBhc3NldFJlY2VpdmVyOiBBcHBsaWNhdGlvbihzb2NpYWwpLmFkZHJlc3MsCiAgICBkaWcgMwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6Mzc2LTM4NwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWwucHJvdG90eXBlLmdhdGVkRWRpdFJlcGx5Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgdGlwLAogICAgLy8gICAgIGdhdGVUeG4sCiAgICAvLyAgICAgY2lkLAogICAgLy8gICAgIGFtZW5kbWVudAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgdW5jb3ZlciA1CiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgOAogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MzQ5LTM1MwogICAgLy8gY29uc3QgbWJyUGF5bWVudCA9IGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHNvY2lhbCkuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBtYnJBbW91bnQKICAgIC8vIH0pCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozODEKICAgIC8vIHRpcCwKICAgIGl0eG5fbmV4dAogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjM1Ny0zNjIKICAgIC8vIGNvbnN0IHRpcCA9IGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXNzZXRSZWNlaXZlcjogQXBwbGljYXRpb24oc29jaWFsKS5hZGRyZXNzLAogICAgLy8gICB4ZmVyQXNzZXQ6IGFrdGEsCiAgICAvLyAgIGFzc2V0QW1vdW50OiByZWFjdEZlZQogICAgLy8gfSkKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjM4MgogICAgLy8gZ2F0ZVR4biwKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MzY4CiAgICAvLyBtZXRob2RTZWxlY3RvcihHYXRlTXVzdENoZWNrQWJpTWV0aG9kKSwKICAgIGJ5dGVjIDggLy8gbWV0aG9kICJtdXN0Q2hlY2soYWRkcmVzcyx1aW50NjQsYnl0ZVtdW10pdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDgKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozNjQtMzczCiAgICAvLyBjb25zdCBnYXRlVHhuID0gaXR4bi5hcHBsaWNhdGlvbkNhbGwoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBnYXRlLAogICAgLy8gICBhcHBBcmdzOiBbCiAgICAvLyAgICAgbWV0aG9kU2VsZWN0b3IoR2F0ZU11c3RDaGVja0FiaU1ldGhvZCksCiAgICAvLyAgICAgb3JpZ2luLAogICAgLy8gICAgIHBvc3RHYXRlSUQsCiAgICAvLyAgICAgZW5jb2RlQXJjNChhcmdzKQogICAgLy8gICBdCiAgICAvLyB9KQogICAgaW50Y18zIC8vIDYKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6Mzc2LTM4NwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWwucHJvdG90eXBlLmdhdGVkRWRpdFJlcGx5Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgdGlwLAogICAgLy8gICAgIGdhdGVUeG4sCiAgICAvLyAgICAgY2lkLAogICAgLy8gICAgIGFtZW5kbWVudAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozODYKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIGRpZyAxMQogICAgZGlnIDEzCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6Mzc2LTM4NwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWwucHJvdG90eXBlLmdhdGVkRWRpdFJlcGx5Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgdGlwLAogICAgLy8gICAgIGdhdGVUeG4sCiAgICAvLyAgICAgY2lkLAogICAgLy8gICAgIGFtZW5kbWVudAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4NzI3MjRmOTYgLy8gbWV0aG9kICJnYXRlZEVkaXRSZXBseShwYXksYXhmZXIsYXBwbCxieXRlWzM2XSxieXRlWzMyXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjMyMC0zMjYKICAgIC8vIGdhdGVkRWRpdFJlcGx5KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGNpZDogQ0lELAogICAgLy8gICBhbWVuZG1lbnQ6IGJ5dGVzPDMyPiwKICAgIC8vICAgYXJnczogR2F0ZUFyZ3MKICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjpBa2l0YVNvY2lhbFBsdWdpbi5lZGl0UmVwbHlbcm91dGluZ10oKSAtPiB2b2lkOgplZGl0UmVwbHk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozOTAtMzk1CiAgICAvLyBlZGl0UmVwbHkoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgY2lkOiBDSUQsCiAgICAvLyAgIGFtZW5kbWVudDogYnl0ZXM8MzI+CiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHN3YXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgY292ZXIgMgogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzYgLy8gMzYKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzM2XQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBjb3ZlciAzCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICB1bmNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18yIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBjb3ZlciAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozOTgKICAgIC8vIGNvbnN0IHsgc29jaWFsIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjM5OAogICAgLy8gY29uc3QgeyBzb2NpYWwgfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDUKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFTb2NpYWxBcHBMaXN0KSkKICAgIGJ5dGVjXzEgLy8gInNhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjM5OAogICAgLy8gY29uc3QgeyBzb2NpYWwgfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGNvdmVyIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjM5OQogICAgLy8gY29uc3QgeyBwb3N0cywgdm90ZXMsIHZvdGVsaXN0IH0gPSB0aGlzLm1icihjaWQpCiAgICB1bmNvdmVyIDMKICAgIGNhbGxzdWIgc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjpCYXNlU29jaWFsLm1icgogICAgZHVwCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDEKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIGV4dHJhY3RfdWludDY0CiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0MDAKICAgIC8vIGxldCBtYnJBbW91bnQ6IHVpbnQ2NCA9IHBvc3RzICsgdm90ZXMgKyB2b3RlbGlzdAogICAgY292ZXIgMgogICAgKwogICAgKwogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NDAyLTQwNgogICAgLy8gY29uc3QgcG9zdEJlaW5nQW1lbmRlZCA9IGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsLnByb3RvdHlwZS5nZXRQb3N0Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogW2FtZW5kbWVudF0KICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICBieXRlYyAxMCAvLyBtZXRob2QgImdldFBvc3QoYnl0ZVszMl0pKGFkZHJlc3MsdWludDY0LHVpbnQ2NCxib29sLHVpbnQ2NCxib29sLHVpbnQ4LGJ5dGVbXSkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzMgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBCeXRlcyBoYXMgdmFsaWQgcHJlZml4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0MDgKICAgIC8vIGNvbnN0IG9yaWdpbmFsUG9zdFJlZiA9IHBvc3RCZWluZ0FtZW5kZWQucmVmLnNsaWNlKDAsIDMyKS50b0ZpeGVkKHsgbGVuZ3RoOiAzMiB9KQogICAgZHVwCiAgICBwdXNoaW50IDU5IC8vIDU5CiAgICBleHRyYWN0X3VpbnQxNgogICAgZGlnIDEKICAgIGxlbgogICAgc3Vic3RyaW5nMwogICAgZXh0cmFjdCAyIDAKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzAgLy8gMAogICAgZGlnIDEKICAgID49CiAgICBpbnRjXzAgLy8gMAogICAgZGlnIDIKICAgIHVuY292ZXIgMgogICAgc2VsZWN0CiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICBkaWcgMgogICAgPj0KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciAyCiAgICBzZWxlY3QKICAgIHN1YnN0cmluZzMKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIExlbmd0aCBtdXN0IGJlIDMyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0MTAKICAgIC8vIGNvbnN0IHsgY3JlYXRvciwgY3JlYXRvcldhbGxldCB9ID0gdGhpcy5nZXRDcmVhdG9yRGV0YWlscyhSZWZUeXBlUG9zdCwgc2VuZGVyLCBvcmlnaW5hbFBvc3RSZWYpCiAgICBieXRlYyA5IC8vIDB4MGEKICAgIGNvdmVyIDIKICAgIGNhbGxzdWIgZ2V0Q3JlYXRvckRldGFpbHMKICAgIGR1cAogICAgZXh0cmFjdCAxIDMyCiAgICBzd2FwCiAgICBwdXNoaW50IDMzIC8vIDMzCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NDExCiAgICAvLyBjb25zdCB0aXBJbmZvID0gdGhpcy5jaGVja1RpcE1iclJlcXVpcmVtZW50cyh0aGlzLmFraXRhREFPLnZhbHVlLCBjcmVhdG9yLCBBcHBsaWNhdGlvbihjcmVhdG9yV2FsbGV0KSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjQxMQogICAgLy8gY29uc3QgdGlwSW5mbyA9IHRoaXMuY2hlY2tUaXBNYnJSZXF1aXJlbWVudHModGhpcy5ha2l0YURBTy52YWx1ZSwgY3JlYXRvciwgQXBwbGljYXRpb24oY3JlYXRvcldhbGxldCkpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgY292ZXIgMgogICAgY2FsbHN1YiBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6OkJhc2VTb2NpYWwuY2hlY2tUaXBNYnJSZXF1aXJlbWVudHMKICAgIGR1cAogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NDEzCiAgICAvLyBpZiAodGlwSW5mby50eXBlID09PSBUaXBTZW5kVHlwZUFSQzU4KSB7CiAgICBleHRyYWN0IDAgMQogICAgYnl0ZWMgNiAvLyAweDE0CiAgICA9PQogICAgYnogZWRpdFJlcGx5X2FmdGVyX2lmX2Vsc2VANAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NDE0CiAgICAvLyBtYnJBbW91bnQgKz0gdGlwSW5mby5hcmM1OAogICAgZGlnIDEKICAgIGludGNfMSAvLyAxCiAgICBleHRyYWN0X3VpbnQ2NAogICAgKwoKZWRpdFJlcGx5X2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjQxOQogICAgLy8gcmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHNvY2lhbCkuYWRkcmVzcywKICAgIGRpZyAyCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjQyMwogICAgLy8gY29uc3QgYWt0YSA9IEFzc2V0KGdldEFraXRhQXNzZXRzKHRoaXMuYWtpdGFEQU8udmFsdWUpLmFrdGEpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0MjMKICAgIC8vIGNvbnN0IGFrdGEgPSBBc3NldChnZXRBa2l0YUFzc2V0cyh0aGlzLmFraXRhREFPLnZhbHVlKS5ha3RhKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OTQKICAgIC8vIGNvbnN0IGFraXRhQXNzZXRzQnl0ZXMgPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFzc2V0cykpWzBdCiAgICBkdXAKICAgIGJ5dGVjIDQgLy8gImFraXRhX2Fzc2V0cyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjQyMwogICAgLy8gY29uc3QgYWt0YSA9IEFzc2V0KGdldEFraXRhQXNzZXRzKHRoaXMuYWtpdGFEQU8udmFsdWUpLmFrdGEpCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NjkKICAgIC8vIGNvbnN0IFtzb2NpYWxGZWVzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzU29jaWFsRmVlcykpCiAgICBzd2FwCiAgICBieXRlYyA1IC8vICJzb2NpYWxfZmVlcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjQyNAogICAgLy8gY29uc3QgeyByZWFjdEZlZSB9ID0gZ2V0U29jaWFsRmVlcyh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18yIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0MjcKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHNvY2lhbCkuYWRkcmVzcywKICAgIGRpZyAzCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0MzMtNDQzCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbC5wcm90b3R5cGUuZWRpdFJlcGx5Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgdGlwLAogICAgLy8gICAgIGNpZCwKICAgIC8vICAgICBhbWVuZG1lbnQKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIHVuY292ZXIgNQogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIHVuY292ZXIgMwogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZGlnIDYKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjQxNy00MjEKICAgIC8vIGNvbnN0IG1iclBheW1lbnQgPSBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihzb2NpYWwpLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogbWJyQW1vdW50CiAgICAvLyB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NDM4CiAgICAvLyB0aXAsCiAgICBpdHhuX25leHQKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgc3dhcAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0MjUtNDMwCiAgICAvLyBjb25zdCB0aXAgPSBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHNvY2lhbCkuYWRkcmVzcywKICAgIC8vICAgeGZlckFzc2V0OiBha3RhLAogICAgLy8gICBhc3NldEFtb3VudDogcmVhY3RGZWUKICAgIC8vIH0pCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0MzMtNDQzCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbC5wcm90b3R5cGUuZWRpdFJlcGx5Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgdGlwLAogICAgLy8gICAgIGNpZCwKICAgIC8vICAgICBhbWVuZG1lbnQKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NDQyCiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICBkaWcgNwogICAgZGlnIDkKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0MzMtNDQzCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbC5wcm90b3R5cGUuZWRpdFJlcGx5Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgdGlwLAogICAgLy8gICAgIGNpZCwKICAgIC8vICAgICBhbWVuZG1lbnQKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDFjOTlmZTllIC8vIG1ldGhvZCAiZWRpdFJlcGx5KHBheSxheGZlcixieXRlWzM2XSxieXRlWzMyXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA3CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDYKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozOTAtMzk1CiAgICAvLyBlZGl0UmVwbHkoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgY2lkOiBDSUQsCiAgICAvLyAgIGFtZW5kbWVudDogYnl0ZXM8MzI+CiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo6QWtpdGFTb2NpYWxQbHVnaW4udm90ZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CnZvdGU6CiAgICBpbnRjXzAgLy8gMAogICAgcHVzaGJ5dGVzICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0NDYtNDUyCiAgICAvLyB2b3RlKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIHJlZjogYnl0ZXMsCiAgICAvLyAgIHR5cGU6IFJlZlR5cGUsCiAgICAvLyAgIGlzVXA6IGJvb2xlYW4KICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgc3dhcAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBjb3ZlciAyCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIGRpZyAxCiAgICBsZW4KICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChsZW4rdWludDhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDgKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGR1cAogICAgY292ZXIgNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMiAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIGR1cAogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NDU1CiAgICAvLyBjb25zdCB7IHNvY2lhbCB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0NTUKICAgIC8vIGNvbnN0IHsgc29jaWFsIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQ1CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhU29jaWFsQXBwTGlzdCkpCiAgICBieXRlY18xIC8vICJzYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0NTUKICAgIC8vIGNvbnN0IHsgc29jaWFsIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NDU2CiAgICAvLyBjb25zdCB7IHZvdGVsaXN0LCBwb3N0cyB9ID0gdGhpcy5tYnIob3AuYnplcm8oMCkpCiAgICBpbnRjXzAgLy8gMAogICAgYnplcm8KICAgIGNhbGxzdWIgc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjpCYXNlU29jaWFsLm1icgogICAgZHVwCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICBleHRyYWN0X3VpbnQ2NAogICAgY292ZXIgNAogICAgcHVzaGludCAxNiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgIGNvdmVyIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjQ1OQogICAgLy8gY29uc3QgeyBwb3N0RXhpc3RzLCBjcmVhdG9yLCBjcmVhdG9yV2FsbGV0IH0gPSB0aGlzLmdldENyZWF0b3JEZXRhaWxzKHR5cGUsIHNlbmRlciwgcmVmLnRvRml4ZWQoeyBsZW5ndGg6IDMyIH0pKQogICAgZGlnIDIKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBMZW5ndGggbXVzdCBiZSAzMgogICAgdW5jb3ZlciAyCiAgICBjYWxsc3ViIGdldENyZWF0b3JEZXRhaWxzCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIGRpZyAxCiAgICBleHRyYWN0IDEgMzIKICAgIGNvdmVyIDMKICAgIHN3YXAKICAgIHB1c2hpbnQgMzMgLy8gMzMKICAgIGV4dHJhY3RfdWludDY0CiAgICBjb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0NjEKICAgIC8vIGlmICghcG9zdEV4aXN0cykgewogICAgYnogdm90ZV9pZl9ib2R5QDIKICAgIGJ1cnkgMTIKCnZvdGVfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NDY1CiAgICAvLyBpZiAoaXNVcCkgewogICAgZGlnIDUKICAgIGJ6IHZvdGVfYWZ0ZXJfaWZfZWxzZUA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0NjYKICAgIC8vIGNvbnN0IHRpcEluZm8gPSB0aGlzLmNoZWNrVGlwTWJyUmVxdWlyZW1lbnRzKHRoaXMuYWtpdGFEQU8udmFsdWUsIGNyZWF0b3IsIEFwcGxpY2F0aW9uKGNyZWF0b3JXYWxsZXQpKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NDY2CiAgICAvLyBjb25zdCB0aXBJbmZvID0gdGhpcy5jaGVja1RpcE1iclJlcXVpcmVtZW50cyh0aGlzLmFraXRhREFPLnZhbHVlLCBjcmVhdG9yLCBBcHBsaWNhdGlvbihjcmVhdG9yV2FsbGV0KSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBkaWcgMgogICAgZGlnIDIKICAgIGNhbGxzdWIgc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjpCYXNlU29jaWFsLmNoZWNrVGlwTWJyUmVxdWlyZW1lbnRzCiAgICBkdXAKICAgIGJ1cnkgMTQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjQ2OAogICAgLy8gaWYgKHRpcEluZm8udHlwZSA9PT0gVGlwU2VuZFR5cGVBUkM1OCkgewogICAgZXh0cmFjdCAwIDEKICAgIGJ5dGVjIDYgLy8gMHgxNAogICAgPT0KICAgIGJ6IHZvdGVfYWZ0ZXJfaWZfZWxzZUA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0NjkKICAgIC8vIG1ickFtb3VudCArPSB0aXBJbmZvLmFyYzU4CiAgICBkaWcgMTIKICAgIGludGNfMSAvLyAxCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDEyCiAgICArCiAgICBidXJ5IDEyCgp2b3RlX2FmdGVyX2lmX2Vsc2VANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjQ3NQogICAgLy8gcmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHNvY2lhbCkuYWRkcmVzcywKICAgIGRpZyAzCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjQ3OQogICAgLy8gY29uc3QgYWt0YSA9IEFzc2V0KGdldEFraXRhQXNzZXRzKHRoaXMuYWtpdGFEQU8udmFsdWUpLmFrdGEpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0NzkKICAgIC8vIGNvbnN0IGFrdGEgPSBBc3NldChnZXRBa2l0YUFzc2V0cyh0aGlzLmFraXRhREFPLnZhbHVlKS5ha3RhKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OTQKICAgIC8vIGNvbnN0IGFraXRhQXNzZXRzQnl0ZXMgPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFzc2V0cykpWzBdCiAgICBkdXAKICAgIGJ5dGVjIDQgLy8gImFraXRhX2Fzc2V0cyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjQ3OQogICAgLy8gY29uc3QgYWt0YSA9IEFzc2V0KGdldEFraXRhQXNzZXRzKHRoaXMuYWtpdGFEQU8udmFsdWUpLmFrdGEpCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NjkKICAgIC8vIGNvbnN0IFtzb2NpYWxGZWVzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzU29jaWFsRmVlcykpCiAgICBzd2FwCiAgICBieXRlYyA1IC8vICJzb2NpYWxfZmVlcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjQ4MAogICAgLy8gY29uc3QgeyByZWFjdEZlZSB9ID0gZ2V0U29jaWFsRmVlcyh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18yIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0ODMKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHNvY2lhbCkuYWRkcmVzcywKICAgIGRpZyAzCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0ODgtNDk5CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbC5wcm90b3R5cGUudm90ZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBzb2NpYWwsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJQYXltZW50LAogICAgLy8gICAgIHRpcCwKICAgIC8vICAgICByZWYsCiAgICAvLyAgICAgdHlwZSwKICAgIC8vICAgICBpc1VwCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICBkaWcgMTYKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGRpZyA4CiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0NzMtNDc3CiAgICAvLyBjb25zdCBtYnJQYXltZW50ID0gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogQXBwbGljYXRpb24oc29jaWFsKS5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IG1ickFtb3VudAogICAgLy8gfSkKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjQ5MwogICAgLy8gdGlwLAogICAgaXR4bl9uZXh0CiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NDgxLTQ4NgogICAgLy8gY29uc3QgdGlwID0gaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhc3NldFJlY2VpdmVyOiBBcHBsaWNhdGlvbihzb2NpYWwpLmFkZHJlc3MsCiAgICAvLyAgIHhmZXJBc3NldDogYWt0YSwKICAgIC8vICAgYXNzZXRBbW91bnQ6IHJlYWN0RmVlCiAgICAvLyB9KQogICAgcHVzaGludCA0IC8vIDQKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NDg4LTQ5OQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWwucHJvdG90eXBlLnZvdGU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogc29jaWFsLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICB0aXAsCiAgICAvLyAgICAgcmVmLAogICAgLy8gICAgIHR5cGUsCiAgICAvLyAgICAgaXNVcAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo0OTgKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIGRpZyAxMQogICAgZGlnIDEzCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NDg4LTQ5OQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWwucHJvdG90eXBlLnZvdGU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogc29jaWFsLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICB0aXAsCiAgICAvLyAgICAgcmVmLAogICAgLy8gICAgIHR5cGUsCiAgICAvLyAgICAgaXNVcAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4MDJlOTI2MzEgLy8gbWV0aG9kICJ2b3RlKHBheSxheGZlcixieXRlW10sdWludDgsYm9vbCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA5CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NDQ2LTQ1MgogICAgLy8gdm90ZSgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICByZWY6IGJ5dGVzLAogICAgLy8gICB0eXBlOiBSZWZUeXBlLAogICAgLy8gICBpc1VwOiBib29sZWFuCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCnZvdGVfaWZfYm9keUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NDYyCiAgICAvLyBtYnJBbW91bnQgKz0gcG9zdHMKICAgIGRpZyAzCiAgICArCiAgICBidXJ5IDEyCiAgICBiIHZvdGVfYWZ0ZXJfaWZfZWxzZUAzCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OkFraXRhU29jaWFsUGx1Z2luLmVkaXRWb3RlW3JvdXRpbmddKCkgLT4gdm9pZDoKZWRpdFZvdGU6CiAgICBpbnRjXzAgLy8gMAogICAgcHVzaGJ5dGVzICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1MDItNTA3CiAgICAvLyBlZGl0Vm90ZSgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICByZWY6IGJ5dGVzPDMyPiwKICAgIC8vICAgZmxpcDogYm9vbGVhbgogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgY292ZXIgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgdW5jb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMiAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIGR1cAogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NTEwCiAgICAvLyBjb25zdCB7IHNvY2lhbCB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1MTAKICAgIC8vIGNvbnN0IHsgc29jaWFsIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQ1CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhU29jaWFsQXBwTGlzdCkpCiAgICBkdXAKICAgIGJ5dGVjXzEgLy8gInNhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjUxMAogICAgLy8gY29uc3QgeyBzb2NpYWwgfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGNvdmVyIDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjUxMi01MTYKICAgIC8vIGNvbnN0IHsgaXNVcDogd2FzVXAgfSA9IGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsLnByb3RvdHlwZS5nZXRWb3RlPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogW3NlbmRlciwgcmVmXSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICBwdXNoYnl0ZXMgMHg5ZTE3NGJiNiAvLyBtZXRob2QgImdldFZvdGUoYWRkcmVzcyxieXRlWzMyXSkodWludDY0LGJvb2wpIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZHVwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18zIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgOSAvLyA5CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAodWludDY0LGJvb2wxKQogICAgcHVzaGludCA2NCAvLyA2NAogICAgZ2V0Yml0CiAgICBjb3ZlciAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1MjAKICAgIC8vIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihzb2NpYWwpLmFkZHJlc3MsCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIHN3YXAKICAgIGNvdmVyIDQKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjUyMQogICAgLy8gYW1vdW50OiAwLAogICAgaW50Y18wIC8vIDAKICAgIGNvdmVyIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OTQKICAgIC8vIGNvbnN0IGFraXRhQXNzZXRzQnl0ZXMgPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFzc2V0cykpWzBdCiAgICBzd2FwCiAgICBieXRlYyA0IC8vICJha2l0YV9hc3NldHMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1MjQKICAgIC8vIGNvbnN0IGFrdGEgPSBBc3NldChnZXRBa2l0YUFzc2V0cyh0aGlzLmFraXRhREFPLnZhbHVlKS5ha3RhKQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBjb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1MjgKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHNvY2lhbCkuYWRkcmVzcywKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIHN3YXAKICAgIGNvdmVyIDIKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjUzMAogICAgLy8gYXNzZXRBbW91bnQ6IDAsCiAgICBpbnRjXzAgLy8gMAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NTMzCiAgICAvLyBpZiAoZmxpcCkgewogICAgYnogZWRpdFZvdGVfYWZ0ZXJfaWZfZWxzZUA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1MzQKICAgIC8vIGNvbnN0IHsgcmVhY3RGZWUgfSA9IGdldFNvY2lhbEZlZXModGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjUzNAogICAgLy8gY29uc3QgeyByZWFjdEZlZSB9ID0gZ2V0U29jaWFsRmVlcyh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NjkKICAgIC8vIGNvbnN0IFtzb2NpYWxGZWVzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzU29jaWFsRmVlcykpCiAgICBieXRlYyA1IC8vICJzb2NpYWxfZmVlcyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjUzNAogICAgLy8gY29uc3QgeyByZWFjdEZlZSB9ID0gZ2V0U29jaWFsRmVlcyh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18yIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICBidXJ5IDEzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1MzkKICAgIC8vIGlmICghd2FzVXApIHsKICAgIGRpZyA1CiAgICBibnogZWRpdFZvdGVfYWZ0ZXJfaWZfZWxzZUA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1NDEKICAgIC8vIGNvbnN0IHsgY3JlYXRvciwgY3JlYXRvcldhbGxldCB9ID0gdGhpcy5nZXRDcmVhdG9yRGV0YWlscyhSZWZUeXBlUG9zdCwgc2VuZGVyLCByZWYudG9GaXhlZCh7IGxlbmd0aDogMzIgfSkpCiAgICBieXRlYyA5IC8vIDB4MGEKICAgIGRpZyA4CiAgICBkaWcgMTEKICAgIGNhbGxzdWIgZ2V0Q3JlYXRvckRldGFpbHMKICAgIGR1cAogICAgZXh0cmFjdCAxIDMyCiAgICBzd2FwCiAgICBwdXNoaW50IDMzIC8vIDMzCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NTQyCiAgICAvLyBjb25zdCB0aXBJbmZvID0gdGhpcy5jaGVja1RpcE1iclJlcXVpcmVtZW50cyh0aGlzLmFraXRhREFPLnZhbHVlLCBjcmVhdG9yLCBBcHBsaWNhdGlvbihjcmVhdG9yV2FsbGV0KSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjU0MgogICAgLy8gY29uc3QgdGlwSW5mbyA9IHRoaXMuY2hlY2tUaXBNYnJSZXF1aXJlbWVudHModGhpcy5ha2l0YURBTy52YWx1ZSwgY3JlYXRvciwgQXBwbGljYXRpb24oY3JlYXRvcldhbGxldCkpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgY292ZXIgMgogICAgY2FsbHN1YiBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6OkJhc2VTb2NpYWwuY2hlY2tUaXBNYnJSZXF1aXJlbWVudHMKICAgIGR1cAogICAgYnVyeSAxNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NTQzCiAgICAvLyBpZiAodGlwSW5mby50eXBlID09PSBUaXBTZW5kVHlwZUFSQzU4KSB7CiAgICBleHRyYWN0IDAgMQogICAgYnl0ZWMgNiAvLyAweDE0CiAgICA9PQogICAgYnogZWRpdFZvdGVfYWZ0ZXJfaWZfZWxzZUA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1NDQKICAgIC8vIG1iclBheW1lbnQuc2V0KHsgYW1vdW50OiB0aXBJbmZvLmFyYzU4IH0pCiAgICBkaWcgMTMKICAgIGludGNfMSAvLyAxCiAgICBleHRyYWN0X3VpbnQ2NAogICAgYnVyeSA0CgplZGl0Vm90ZV9hZnRlcl9pZl9lbHNlQDc6CiAgICBkaWcgMTIKICAgIGJ1cnkgMQoKZWRpdFZvdGVfYWZ0ZXJfaWZfZWxzZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NTQ5LTU1OQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWwucHJvdG90eXBlLmVkaXRWb3RlPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgdGlwLAogICAgLy8gICAgIHJlZiwKICAgIC8vICAgICBmbGlwCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgZGlnIDMKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBkaWcgNAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZGlnIDcKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjUxOC01MjIKICAgIC8vIGNvbnN0IG1iclBheW1lbnQgPSBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihzb2NpYWwpLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogMCwKICAgIC8vIH0pCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1NTQKICAgIC8vIHRpcCwKICAgIGl0eG5fbmV4dAogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGRpZyAzCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgZGlnIDIKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NTI2LTUzMQogICAgLy8gY29uc3QgdGlwID0gaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhc3NldFJlY2VpdmVyOiBBcHBsaWNhdGlvbihzb2NpYWwpLmFkZHJlc3MsCiAgICAvLyAgIHhmZXJBc3NldDogYWt0YSwKICAgIC8vICAgYXNzZXRBbW91bnQ6IDAsCiAgICAvLyB9KQogICAgcHVzaGludCA0IC8vIDQKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NTQ5LTU1OQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWwucHJvdG90eXBlLmVkaXRWb3RlPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgdGlwLAogICAgLy8gICAgIHJlZiwKICAgIC8vICAgICBmbGlwCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1NTgKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICBkaWcgMTEKICAgIGRpZyAxMwogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjU0OS01NTkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsLnByb3RvdHlwZS5lZGl0Vm90ZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBzb2NpYWwsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJQYXltZW50LAogICAgLy8gICAgIHRpcCwKICAgIC8vICAgICByZWYsCiAgICAvLyAgICAgZmxpcAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDg0ZmE0YjVlIC8vIG1ldGhvZCAiZWRpdFZvdGUocGF5LGF4ZmVyLGJ5dGVbMzJdLGJvb2wpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGRpZyA3CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NTAyLTUwNwogICAgLy8gZWRpdFZvdGUoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgcmVmOiBieXRlczwzMj4sCiAgICAvLyAgIGZsaXA6IGJvb2xlYW4KICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjpBa2l0YVNvY2lhbFBsdWdpbi5nYXRlZFJlYWN0W3JvdXRpbmddKCkgLT4gdm9pZDoKZ2F0ZWRSZWFjdDoKICAgIGludGNfMCAvLyAwCiAgICBkdXBuIDIKICAgIHB1c2hieXRlcyAiIgogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1NjItNTY5CiAgICAvLyBnYXRlZFJlYWN0KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIHJlZjogYnl0ZXMsCiAgICAvLyAgIHR5cGU6IFJlZlR5cGUsCiAgICAvLyAgIE5GVDogdWludDY0LAogICAgLy8gICBhcmdzOiBHYXRlQXJncwogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1aW50OFtdKQogICAgZXh0cmFjdCAyIDAKICAgIGR1cAogICAgY292ZXIgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBjb3ZlciAzCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgZHVwCiAgICBjb3ZlciAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NTcwCiAgICAvLyBjb25zdCB7IG9yaWdpbiwgc2VuZGVyIH0gPSBnZXRBY2NvdW50cyh3YWxsZXQpCiAgICB1bmNvdmVyIDIKICAgIGNhbGxzdWIgZ2V0QWNjb3VudHMKICAgIGR1cAogICAgZXh0cmFjdCAzMiAzMgogICAgY292ZXIgMwogICAgZXh0cmFjdCA2NCAzMgogICAgZHVwCiAgICBjb3ZlciAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1NzIKICAgIC8vIGNvbnN0IHsgZ2F0ZSB9ID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1NzIKICAgIC8vIGNvbnN0IHsgZ2F0ZSB9ID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgZHVwCiAgICBieXRlYyA3IC8vICJhYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1NzIKICAgIC8vIGNvbnN0IHsgZ2F0ZSB9ID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgY292ZXIgNAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0NQogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YVNvY2lhbEFwcExpc3QpKQogICAgYnl0ZWNfMSAvLyAic2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NTczCiAgICAvLyBjb25zdCB7IHNvY2lhbCB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgY292ZXIgNAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NTc1LTU3OQogICAgLy8gY29uc3QgcmVhY3Rpb25FeGlzdHMgPSBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25FeGlzdHM+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogc29jaWFsLAogICAgLy8gICBhcmdzOiBbcmVmLnRvRml4ZWQoeyBsZW5ndGg6IDMyIH0pLCBORlRdCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NTc4CiAgICAvLyBhcmdzOiBbcmVmLnRvRml4ZWQoeyBsZW5ndGg6IDMyIH0pLCBORlRdCiAgICBkaWcgMwogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIExlbmd0aCBtdXN0IGJlIDMyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1NzUtNTc5CiAgICAvLyBjb25zdCByZWFjdGlvbkV4aXN0cyA9IGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsLnByb3RvdHlwZS5nZXRSZWFjdGlvbkV4aXN0cz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBzb2NpYWwsCiAgICAvLyAgIGFyZ3M6IFtyZWYudG9GaXhlZCh7IGxlbmd0aDogMzIgfSksIE5GVF0KICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBieXRlYyAxMSAvLyBtZXRob2QgImdldFJlYWN0aW9uRXhpc3RzKGJ5dGVbMzJdLHVpbnQ2NClib29sIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18zIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NTgxCiAgICAvLyBjb25zdCB7IHJlYWN0aW9ucywgcmVhY3Rpb25saXN0LCBwb3N0cyB9ID0gdGhpcy5tYnIob3AuYnplcm8oMCkpCiAgICBpbnRjXzAgLy8gMAogICAgYnplcm8KICAgIGNhbGxzdWIgc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjpCYXNlU29jaWFsLm1icgogICAgZHVwCiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgY292ZXIgMgogICAgZHVwCiAgICBwdXNoaW50IDQ4IC8vIDQ4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgY292ZXIgMgogICAgcHVzaGludCAxNiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjU4My01ODUKICAgIC8vIGxldCBtYnJBbW91bnQ6IHVpbnQ2NCA9IHJlYWN0aW9uRXhpc3RzCiAgICAvLyAgID8gcmVhY3Rpb25saXN0CiAgICAvLyAgIDogcmVhY3Rpb25zICsgcmVhY3Rpb25saXN0CiAgICBieiBnYXRlZFJlYWN0X3Rlcm5hcnlfZmFsc2VANAogICAgYnVyeSAxNAoKZ2F0ZWRSZWFjdF90ZXJuYXJ5X21lcmdlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1ODcKICAgIC8vIGNvbnN0IHsgcG9zdEV4aXN0cywgY3JlYXRvciwgY3JlYXRvcldhbGxldCwgZ2F0ZUlEOiBwb3N0R2F0ZUlEIH0gPSB0aGlzLmdldENyZWF0b3JEZXRhaWxzKHR5cGUsIHNlbmRlciwgcmVmLnRvRml4ZWQoeyBsZW5ndGg6IDMyIH0pKQogICAgZGlnIDgKICAgIGRpZyA1CiAgICBkaWcgMTEKICAgIGNhbGxzdWIgZ2V0Q3JlYXRvckRldGFpbHMKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgZGlnIDEKICAgIGV4dHJhY3QgMSAzMgogICAgYnVyeSAxOQogICAgZGlnIDEKICAgIHB1c2hpbnQgMzMgLy8gMzMKICAgIGV4dHJhY3RfdWludDY0CiAgICBidXJ5IDE3CiAgICBzd2FwCiAgICBleHRyYWN0IDQxIDgKICAgIGJ1cnkgMTkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjU4OQogICAgLy8gaWYgKCFwb3N0RXhpc3RzKSB7CiAgICBibnogZ2F0ZWRSZWFjdF9hZnRlcl9pZl9lbHNlQDcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjU5MAogICAgLy8gbWJyQW1vdW50ICs9IHBvc3RzCiAgICBkaWcgMTMKICAgIGRpZyAxCiAgICArCiAgICBidXJ5IDE0CgpnYXRlZFJlYWN0X2FmdGVyX2lmX2Vsc2VANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjU5MwogICAgLy8gY29uc3QgdGlwSW5mbyA9IHRoaXMuY2hlY2tUaXBNYnJSZXF1aXJlbWVudHModGhpcy5ha2l0YURBTy52YWx1ZSwgY3JlYXRvciwgQXBwbGljYXRpb24oY3JlYXRvcldhbGxldCkpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1OTMKICAgIC8vIGNvbnN0IHRpcEluZm8gPSB0aGlzLmNoZWNrVGlwTWJyUmVxdWlyZW1lbnRzKHRoaXMuYWtpdGFEQU8udmFsdWUsIGNyZWF0b3IsIEFwcGxpY2F0aW9uKGNyZWF0b3JXYWxsZXQpKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGRpZyAxNwogICAgZGlnIDE2CiAgICBjYWxsc3ViIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czo6QmFzZVNvY2lhbC5jaGVja1RpcE1iclJlcXVpcmVtZW50cwogICAgZHVwCiAgICBidXJ5IDE3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1OTQKICAgIC8vIGlmICh0aXBJbmZvLnR5cGUgPT09IFRpcFNlbmRUeXBlQVJDNTgpIHsKICAgIGV4dHJhY3QgMCAxCiAgICBieXRlYyA2IC8vIDB4MTQKICAgID09CiAgICBieiBnYXRlZFJlYWN0X2FmdGVyX2lmX2Vsc2VAOQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NTk1CiAgICAvLyBtYnJBbW91bnQgKz0gdGlwSW5mby5hcmM1OAogICAgZGlnIDE1CiAgICBpbnRjXzEgLy8gMQogICAgZXh0cmFjdF91aW50NjQKICAgIGRpZyAxNAogICAgKwogICAgYnVyeSAxNAoKZ2F0ZWRSZWFjdF9hZnRlcl9pZl9lbHNlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo2MDAKICAgIC8vIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihzb2NpYWwpLmFkZHJlc3MsCiAgICBkaWcgMgogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo2MDQKICAgIC8vIGNvbnN0IGFrdGEgPSBBc3NldChnZXRBa2l0YUFzc2V0cyh0aGlzLmFraXRhREFPLnZhbHVlKS5ha3RhKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NjA0CiAgICAvLyBjb25zdCBha3RhID0gQXNzZXQoZ2V0QWtpdGFBc3NldHModGhpcy5ha2l0YURBTy52YWx1ZSkuYWt0YSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjk0CiAgICAvLyBjb25zdCBha2l0YUFzc2V0c0J5dGVzID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBc3NldHMpKVswXQogICAgZHVwCiAgICBieXRlYyA0IC8vICJha2l0YV9hc3NldHMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo2MDQKICAgIC8vIGNvbnN0IGFrdGEgPSBBc3NldChnZXRBa2l0YUFzc2V0cyh0aGlzLmFraXRhREFPLnZhbHVlKS5ha3RhKQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjY5CiAgICAvLyBjb25zdCBbc29jaWFsRmVlc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1NvY2lhbEZlZXMpKQogICAgc3dhcAogICAgYnl0ZWMgNSAvLyAic29jaWFsX2ZlZXMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo2MDUKICAgIC8vIGNvbnN0IHsgcmVhY3RGZWUgfSA9IGdldFNvY2lhbEZlZXModGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGludGNfMiAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NjA4CiAgICAvLyBhc3NldFJlY2VpdmVyOiBBcHBsaWNhdGlvbihzb2NpYWwpLmFkZHJlc3MsCiAgICBkaWcgMwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NjI0LTYzNgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWwucHJvdG90eXBlLmdhdGVkUmVhY3Q+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogc29jaWFsLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICB0aXAsCiAgICAvLyAgICAgZ2F0ZVR4biwKICAgIC8vICAgICByZWYsCiAgICAvLyAgICAgdHlwZSwKICAgIC8vICAgICBORlQKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIGRpZyAxOAogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIHVuY292ZXIgMwogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZGlnIDgKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjU5OC02MDIKICAgIC8vIGNvbnN0IG1iclBheW1lbnQgPSBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihzb2NpYWwpLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogbWJyQW1vdW50CiAgICAvLyB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NjI5CiAgICAvLyB0aXAsCiAgICBpdHhuX25leHQKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgc3dhcAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo2MDYtNjExCiAgICAvLyBjb25zdCB0aXAgPSBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHNvY2lhbCkuYWRkcmVzcywKICAgIC8vICAgeGZlckFzc2V0OiBha3RhLAogICAgLy8gICBhc3NldEFtb3VudDogcmVhY3RGZWUKICAgIC8vIH0pCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo2MzAKICAgIC8vIGdhdGVUeG4sCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjYxNwogICAgLy8gbWV0aG9kU2VsZWN0b3IoR2F0ZU11c3RDaGVja0FiaU1ldGhvZCksCiAgICBieXRlYyA4IC8vIG1ldGhvZCAibXVzdENoZWNrKGFkZHJlc3MsdWludDY0LGJ5dGVbXVtdKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDcKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTkKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgOAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA1CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjYxMy02MjIKICAgIC8vIGNvbnN0IGdhdGVUeG4gPSBpdHhuLmFwcGxpY2F0aW9uQ2FsbCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdhdGUsCiAgICAvLyAgIGFwcEFyZ3M6IFsKICAgIC8vICAgICBtZXRob2RTZWxlY3RvcihHYXRlTXVzdENoZWNrQWJpTWV0aG9kKSwKICAgIC8vICAgICBvcmlnaW4sCiAgICAvLyAgICAgcG9zdEdhdGVJRCwKICAgIC8vICAgICBlbmNvZGVBcmM0KGFyZ3MpCiAgICAvLyAgIF0KICAgIC8vIH0pCiAgICBpbnRjXzMgLy8gNgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo2MjQtNjM2CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbC5wcm90b3R5cGUuZ2F0ZWRSZWFjdD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBzb2NpYWwsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJQYXltZW50LAogICAgLy8gICAgIHRpcCwKICAgIC8vICAgICBnYXRlVHhuLAogICAgLy8gICAgIHJlZiwKICAgIC8vICAgICB0eXBlLAogICAgLy8gICAgIE5GVAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo2MzUKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIGRpZyAxMwogICAgZGlnIDE1CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NjI0LTYzNgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWwucHJvdG90eXBlLmdhdGVkUmVhY3Q+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogc29jaWFsLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICB0aXAsCiAgICAvLyAgICAgZ2F0ZVR4biwKICAgIC8vICAgICByZWYsCiAgICAvLyAgICAgdHlwZSwKICAgIC8vICAgICBORlQKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDZlN2Q0MmMyIC8vIG1ldGhvZCAiZ2F0ZWRSZWFjdChwYXksYXhmZXIsYXBwbCxieXRlW10sdWludDgsdWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDEzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDExCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDEwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NTYyLTU2OQogICAgLy8gZ2F0ZWRSZWFjdCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICByZWY6IGJ5dGVzLAogICAgLy8gICB0eXBlOiBSZWZUeXBlLAogICAgLy8gICBORlQ6IHVpbnQ2NCwKICAgIC8vICAgYXJnczogR2F0ZUFyZ3MKICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKZ2F0ZWRSZWFjdF90ZXJuYXJ5X2ZhbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1ODUKICAgIC8vIDogcmVhY3Rpb25zICsgcmVhY3Rpb25saXN0CiAgICBkaWcgMgogICAgKwogICAgYnVyeSAxNAogICAgYiBnYXRlZFJlYWN0X3Rlcm5hcnlfbWVyZ2VANQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjpBa2l0YVNvY2lhbFBsdWdpbi5yZWFjdFtyb3V0aW5nXSgpIC0+IHZvaWQ6CnJlYWN0OgogICAgaW50Y18wIC8vIDAKICAgIGR1cAogICAgcHVzaGJ5dGVzICIiCiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjYzOS02NDUKICAgIC8vIHJlYWN0KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIHJlZjogYnl0ZXMsCiAgICAvLyAgIHR5cGU6IFJlZlR5cGUsCiAgICAvLyAgIE5GVDogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHN3YXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgY292ZXIgMgogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3VpbnQ4W10pCiAgICBleHRyYWN0IDIgMAogICAgZHVwCiAgICBjb3ZlciAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICB1bmNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18yIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgZHVwCiAgICBjb3ZlciAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo2NDgKICAgIC8vIGNvbnN0IHsgc29jaWFsIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjY0OAogICAgLy8gY29uc3QgeyBzb2NpYWwgfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDUKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFTb2NpYWxBcHBMaXN0KSkKICAgIGJ5dGVjXzEgLy8gInNhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjY0OAogICAgLy8gY29uc3QgeyBzb2NpYWwgfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGNvdmVyIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjY1MC02NTQKICAgIC8vIGNvbnN0IHJlYWN0aW9uRXhpc3RzID0gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWwucHJvdG90eXBlLmdldFJlYWN0aW9uRXhpc3RzPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogW3JlZi50b0ZpeGVkKHsgbGVuZ3RoOiAzMiB9KSwgTkZUXQogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjY1MwogICAgLy8gYXJnczogW3JlZi50b0ZpeGVkKHsgbGVuZ3RoOiAzMiB9KSwgTkZUXQogICAgZGlnIDMKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBMZW5ndGggbXVzdCBiZSAzMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NjUwLTY1NAogICAgLy8gY29uc3QgcmVhY3Rpb25FeGlzdHMgPSBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbC5wcm90b3R5cGUuZ2V0UmVhY3Rpb25FeGlzdHM+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogc29jaWFsLAogICAgLy8gICBhcmdzOiBbcmVmLnRvRml4ZWQoeyBsZW5ndGg6IDMyIH0pLCBORlRdCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgYnl0ZWMgMTEgLy8gbWV0aG9kICJnZXRSZWFjdGlvbkV4aXN0cyhieXRlWzMyXSx1aW50NjQpYm9vbCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMyAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjY1NgogICAgLy8gY29uc3QgeyByZWFjdGlvbnMsIHJlYWN0aW9ubGlzdCwgcG9zdHMgfSA9IHRoaXMubWJyKG9wLmJ6ZXJvKDApKQogICAgaW50Y18wIC8vIDAKICAgIGJ6ZXJvCiAgICBjYWxsc3ViIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czo6QmFzZVNvY2lhbC5tYnIKICAgIGR1cAogICAgcHVzaGludCA0MCAvLyA0MAogICAgZXh0cmFjdF91aW50NjQKICAgIGNvdmVyIDIKICAgIGR1cAogICAgcHVzaGludCA0OCAvLyA0OAogICAgZXh0cmFjdF91aW50NjQKICAgIGNvdmVyIDIKICAgIHB1c2hpbnQgMTYgLy8gMTYKICAgIGV4dHJhY3RfdWludDY0CiAgICBjb3ZlciAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo2NTgtNjYwCiAgICAvLyBsZXQgbWJyQW1vdW50OiB1aW50NjQgPSByZWFjdGlvbkV4aXN0cwogICAgLy8gICA/IHJlYWN0aW9ubGlzdAogICAgLy8gICA6IHJlYWN0aW9ucyArIHJlYWN0aW9ubGlzdAogICAgYnogcmVhY3RfdGVybmFyeV9mYWxzZUA0CiAgICBidXJ5IDExCgpyZWFjdF90ZXJuYXJ5X21lcmdlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo2NjIKICAgIC8vIGNvbnN0IHsgcG9zdEV4aXN0cywgY3JlYXRvciwgY3JlYXRvcldhbGxldCB9ID0gdGhpcy5nZXRDcmVhdG9yRGV0YWlscyh0eXBlLCBzZW5kZXIsIHJlZi50b0ZpeGVkKHsgbGVuZ3RoOiAzMiB9KSkKICAgIGRpZyA1CiAgICBkaWcgNAogICAgZGlnIDgKICAgIGNhbGxzdWIgZ2V0Q3JlYXRvckRldGFpbHMKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgZGlnIDEKICAgIGV4dHJhY3QgMSAzMgogICAgYnVyeSAxNgogICAgc3dhcAogICAgcHVzaGludCAzMyAvLyAzMwogICAgZXh0cmFjdF91aW50NjQKICAgIGJ1cnkgMTMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjY2NAogICAgLy8gaWYgKCFwb3N0RXhpc3RzKSB7CiAgICBibnogcmVhY3RfYWZ0ZXJfaWZfZWxzZUA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo2NjUKICAgIC8vIG1ickFtb3VudCArPSBwb3N0cwogICAgZGlnIDEwCiAgICBkaWcgMQogICAgKwogICAgYnVyeSAxMQoKcmVhY3RfYWZ0ZXJfaWZfZWxzZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NjY4CiAgICAvLyBjb25zdCB0aXBJbmZvID0gdGhpcy5jaGVja1RpcE1iclJlcXVpcmVtZW50cyh0aGlzLmFraXRhREFPLnZhbHVlLCBjcmVhdG9yLCBBcHBsaWNhdGlvbihjcmVhdG9yV2FsbGV0KSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjY2OAogICAgLy8gY29uc3QgdGlwSW5mbyA9IHRoaXMuY2hlY2tUaXBNYnJSZXF1aXJlbWVudHModGhpcy5ha2l0YURBTy52YWx1ZSwgY3JlYXRvciwgQXBwbGljYXRpb24oY3JlYXRvcldhbGxldCkpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZGlnIDE0CiAgICBkaWcgMTMKICAgIGNhbGxzdWIgc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjpCYXNlU29jaWFsLmNoZWNrVGlwTWJyUmVxdWlyZW1lbnRzCiAgICBkdXAKICAgIGJ1cnkgMTQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjY2OQogICAgLy8gaWYgKHRpcEluZm8udHlwZSA9PT0gVGlwU2VuZFR5cGVBUkM1OCkgewogICAgZXh0cmFjdCAwIDEKICAgIGJ5dGVjIDYgLy8gMHgxNAogICAgPT0KICAgIGJ6IHJlYWN0X2FmdGVyX2lmX2Vsc2VAOQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NjcwCiAgICAvLyBtYnJBbW91bnQgKz0gdGlwSW5mby5hcmM1OAogICAgZGlnIDEyCiAgICBpbnRjXzEgLy8gMQogICAgZXh0cmFjdF91aW50NjQKICAgIGRpZyAxMQogICAgKwogICAgYnVyeSAxMQoKcmVhY3RfYWZ0ZXJfaWZfZWxzZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6Njc1CiAgICAvLyByZWNlaXZlcjogQXBwbGljYXRpb24oc29jaWFsKS5hZGRyZXNzLAogICAgZGlnIDIKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6Njc5CiAgICAvLyBjb25zdCBha3RhID0gQXNzZXQoZ2V0QWtpdGFBc3NldHModGhpcy5ha2l0YURBTy52YWx1ZSkuYWt0YSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjY3OQogICAgLy8gY29uc3QgYWt0YSA9IEFzc2V0KGdldEFraXRhQXNzZXRzKHRoaXMuYWtpdGFEQU8udmFsdWUpLmFrdGEpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo5NAogICAgLy8gY29uc3QgYWtpdGFBc3NldHNCeXRlcyA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXNzZXRzKSlbMF0KICAgIGR1cAogICAgYnl0ZWMgNCAvLyAiYWtpdGFfYXNzZXRzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6Njc5CiAgICAvLyBjb25zdCBha3RhID0gQXNzZXQoZ2V0QWtpdGFBc3NldHModGhpcy5ha2l0YURBTy52YWx1ZSkuYWt0YSkKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo2OQogICAgLy8gY29uc3QgW3NvY2lhbEZlZXNCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNTb2NpYWxGZWVzKSkKICAgIHN3YXAKICAgIGJ5dGVjIDUgLy8gInNvY2lhbF9mZWVzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NjgwCiAgICAvLyBjb25zdCB7IHJlYWN0RmVlIH0gPSBnZXRTb2NpYWxGZWVzKHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBpbnRjXzIgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjY4MwogICAgLy8gYXNzZXRSZWNlaXZlcjogQXBwbGljYXRpb24oc29jaWFsKS5hZGRyZXNzLAogICAgZGlnIDMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjY4OC02OTkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsLnByb3RvdHlwZS5yZWFjdD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBzb2NpYWwsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJQYXltZW50LAogICAgLy8gICAgIHRpcCwKICAgIC8vICAgICByZWYsCiAgICAvLyAgICAgdHlwZSwKICAgIC8vICAgICBORlQKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIGRpZyAxNQogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIHVuY292ZXIgMwogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZGlnIDcKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjY3My02NzcKICAgIC8vIGNvbnN0IG1iclBheW1lbnQgPSBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihzb2NpYWwpLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogbWJyQW1vdW50CiAgICAvLyB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NjkzCiAgICAvLyB0aXAsCiAgICBpdHhuX25leHQKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgc3dhcAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo2ODEtNjg2CiAgICAvLyBjb25zdCB0aXAgPSBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHNvY2lhbCkuYWRkcmVzcywKICAgIC8vICAgeGZlckFzc2V0OiBha3RhLAogICAgLy8gICBhc3NldEFtb3VudDogcmVhY3RGZWUKICAgIC8vIH0pCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo2ODgtNjk5CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbC5wcm90b3R5cGUucmVhY3Q+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogc29jaWFsLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICB0aXAsCiAgICAvLyAgICAgcmVmLAogICAgLy8gICAgIHR5cGUsCiAgICAvLyAgICAgTkZUCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjY5OAogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgZGlnIDEwCiAgICBkaWcgMTIKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo2ODgtNjk5CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbC5wcm90b3R5cGUucmVhY3Q+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogc29jaWFsLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICB0aXAsCiAgICAvLyAgICAgcmVmLAogICAgLy8gICAgIHR5cGUsCiAgICAvLyAgICAgTkZUCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHhkMGU1YjE4ZCAvLyBtZXRob2QgInJlYWN0KHBheSxheGZlcixieXRlW10sdWludDgsdWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDEwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDgKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjYzOS02NDUKICAgIC8vIHJlYWN0KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIHJlZjogYnl0ZXMsCiAgICAvLyAgIHR5cGU6IFJlZlR5cGUsCiAgICAvLyAgIE5GVDogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCnJlYWN0X3Rlcm5hcnlfZmFsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjY2MAogICAgLy8gOiByZWFjdGlvbnMgKyByZWFjdGlvbmxpc3QKICAgIGRpZyAyCiAgICArCiAgICBidXJ5IDExCiAgICBiIHJlYWN0X3Rlcm5hcnlfbWVyZ2VANQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjpBa2l0YVNvY2lhbFBsdWdpbi5kZWxldGVSZWFjdGlvbltyb3V0aW5nXSgpIC0+IHZvaWQ6CmRlbGV0ZVJlYWN0aW9uOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NzAyLTcwNwogICAgLy8gZGVsZXRlUmVhY3Rpb24oCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgcmVmOiBieXRlczwzMj4sCiAgICAvLyAgIE5GVDogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18yIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NzEwCiAgICAvLyBjb25zdCB7IHNvY2lhbCB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo3MTAKICAgIC8vIGNvbnN0IHsgc29jaWFsIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQ1CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhU29jaWFsQXBwTGlzdCkpCiAgICBieXRlY18xIC8vICJzYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo3MTAKICAgIC8vIGNvbnN0IHsgc29jaWFsIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NzEyLTcxNwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWwucHJvdG90eXBlLmRlbGV0ZVJlYWN0aW9uPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogW3JlZiwgTkZUXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjcxNgogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciA0CiAgICB1bmNvdmVyIDUKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo3MTItNzE3CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbC5wcm90b3R5cGUuZGVsZXRlUmVhY3Rpb24+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogc29jaWFsLAogICAgLy8gICBhcmdzOiBbcmVmLCBORlRdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4NmU1Yjc3MDIgLy8gbWV0aG9kICJkZWxldGVSZWFjdGlvbihieXRlWzMyXSx1aW50NjQpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo3MDItNzA3CiAgICAvLyBkZWxldGVSZWFjdGlvbigKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICByZWY6IGJ5dGVzPDMyPiwKICAgIC8vICAgTkZUOiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjpBa2l0YVNvY2lhbFBsdWdpbi5nYXRlZEZvbGxvd1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmdhdGVkRm9sbG93OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NzIwLTcyNQogICAgLy8gZ2F0ZWRGb2xsb3coCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYWRkcmVzczogQWNjb3VudCwKICAgIC8vICAgYXJnczogR2F0ZUFyZ3MKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjcyNgogICAgLy8gY29uc3QgeyBvcmlnaW4sIHNlbmRlciB9ID0gZ2V0QWNjb3VudHMod2FsbGV0KQogICAgZGlnIDMKICAgIGNhbGxzdWIgZ2V0QWNjb3VudHMKICAgIGR1cAogICAgZXh0cmFjdCAzMiAzMgogICAgc3dhcAogICAgZXh0cmFjdCA2NCAzMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NzI4CiAgICAvLyBjb25zdCB7IGdhdGUgfSA9IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NzI4CiAgICAvLyBjb25zdCB7IGdhdGUgfSA9IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDAKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBcHBMaXN0KSkKICAgIGR1cAogICAgYnl0ZWMgNyAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NzI4CiAgICAvLyBjb25zdCB7IGdhdGUgfSA9IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgcHVzaGludCA0MCAvLyA0MAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDUKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFTb2NpYWxBcHBMaXN0KSkKICAgIHN3YXAKICAgIGJ5dGVjXzEgLy8gInNhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjcyOQogICAgLy8gY29uc3QgeyBzb2NpYWwsIGdyYXBoIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBzd2FwCiAgICBpbnRjXzIgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjczMS03MzUKICAgIC8vIGNvbnN0IHsgZm9sbG93R2F0ZUlEIH0gPSBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbC5wcm90b3R5cGUuZ2V0TWV0YT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBzb2NpYWwsCiAgICAvLyAgIGFyZ3M6IFthZGRyZXNzXQogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIGJ5dGVjIDEyIC8vIG1ldGhvZCAiZ2V0TWV0YShhZGRyZXNzKShib29sLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LGJvb2wsdWludDY0LHVpbnQ2NCx1aW50NjQpIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgc3dhcAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBkaWcgMgogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIGRpZyAxCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMyAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGxlbgogICAgcHVzaGludCA3NCAvLyA3NAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGJvb2wxLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LGJvb2wxLHVpbnQ2NCx1aW50NjQsdWludDY0KQogICAgZXh0cmFjdCA1NCA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo3MzkKICAgIC8vIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihncmFwaCkuYWRkcmVzcywKICAgIGRpZyAxCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo3NDAKICAgIC8vIGFtb3VudDogdGhpcy5tYnIob3AuYnplcm8oMCkpLmZvbGxvd3MKICAgIGludGNfMCAvLyAwCiAgICBiemVybwogICAgY2FsbHN1YiBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6OkJhc2VTb2NpYWwubWJyCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjc1NC03NjMKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsR3JhcGgucHJvdG90eXBlLmdhdGVkRm9sbG93Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdyYXBoLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICBnYXRlVHhuLAogICAgLy8gICAgIGFkZHJlc3MKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgMwogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjczNy03NDEKICAgIC8vIGNvbnN0IG1iclBheW1lbnQgPSBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihncmFwaCkuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiB0aGlzLm1icihvcC5iemVybygwKSkuZm9sbG93cwogICAgLy8gfSkKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjc1OQogICAgLy8gZ2F0ZVR4biwKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NzQ3CiAgICAvLyBtZXRob2RTZWxlY3RvcihHYXRlTXVzdENoZWNrQWJpTWV0aG9kKSwKICAgIGJ5dGVjIDggLy8gbWV0aG9kICJtdXN0Q2hlY2soYWRkcmVzcyx1aW50NjQsYnl0ZVtdW10pdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgc3dhcAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjc0My03NTIKICAgIC8vIGNvbnN0IGdhdGVUeG4gPSBpdHhuLmFwcGxpY2F0aW9uQ2FsbCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdhdGUsCiAgICAvLyAgIGFwcEFyZ3M6IFsKICAgIC8vICAgICBtZXRob2RTZWxlY3RvcihHYXRlTXVzdENoZWNrQWJpTWV0aG9kKSwKICAgIC8vICAgICBvcmlnaW4sCiAgICAvLyAgICAgZm9sbG93R2F0ZUlELAogICAgLy8gICAgIGVuY29kZUFyYzQoYXJncykKICAgIC8vICAgXQogICAgLy8gfSkKICAgIGludGNfMyAvLyA2CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjc1NC03NjMKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsR3JhcGgucHJvdG90eXBlLmdhdGVkRm9sbG93Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdyYXBoLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICBnYXRlVHhuLAogICAgLy8gICAgIGFkZHJlc3MKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NzYyCiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgNAogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjc1NC03NjMKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsR3JhcGgucHJvdG90eXBlLmdhdGVkRm9sbG93Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdyYXBoLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICBnYXRlVHhuLAogICAgLy8gICAgIGFkZHJlc3MKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDg2Njc1NDk0IC8vIG1ldGhvZCAiZ2F0ZWRGb2xsb3cocGF5LGFwcGwsYWRkcmVzcyl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjcyMC03MjUKICAgIC8vIGdhdGVkRm9sbG93KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFkZHJlc3M6IEFjY291bnQsCiAgICAvLyAgIGFyZ3M6IEdhdGVBcmdzCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo6QWtpdGFTb2NpYWxQbHVnaW4uZm9sbG93W3JvdXRpbmddKCkgLT4gdm9pZDoKZm9sbG93OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NzY2LTc3MAogICAgLy8gZm9sbG93KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFkZHJlc3M6IEFjY291bnQKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMiAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjc3MwogICAgLy8gY29uc3QgeyBncmFwaCB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo3NzMKICAgIC8vIGNvbnN0IHsgZ3JhcGggfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDUKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFTb2NpYWxBcHBMaXN0KSkKICAgIGJ5dGVjXzEgLy8gInNhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjc3MwogICAgLy8gY29uc3QgeyBncmFwaCB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBpbnRjXzIgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjc3NwogICAgLy8gcmVjZWl2ZXI6IEFwcGxpY2F0aW9uKGdyYXBoKS5hZGRyZXNzLAogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo3NzgKICAgIC8vIGFtb3VudDogdGhpcy5tYnIob3AuYnplcm8oMCkpLmZvbGxvd3MKICAgIGludGNfMCAvLyAwCiAgICBiemVybwogICAgY2FsbHN1YiBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6OkJhc2VTb2NpYWwubWJyCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjc4MS03ODkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsR3JhcGgucHJvdG90eXBlLmZvbGxvdz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBncmFwaCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgYWRkcmVzcwogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGRpZyAxCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6Nzc1LTc3OQogICAgLy8gY29uc3QgbWJyUGF5bWVudCA9IGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IEFwcGxpY2F0aW9uKGdyYXBoKS5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IHRoaXMubWJyKG9wLmJ6ZXJvKDApKS5mb2xsb3dzCiAgICAvLyB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NzgxLTc4OQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWxHcmFwaC5wcm90b3R5cGUuZm9sbG93Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdyYXBoLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICBhZGRyZXNzCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjc4OAogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDQKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo3ODEtNzg5CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbEdyYXBoLnByb3RvdHlwZS5mb2xsb3c+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogZ3JhcGgsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJQYXltZW50LAogICAgLy8gICAgIGFkZHJlc3MKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDRiNmY5MDdmIC8vIG1ldGhvZCAiZm9sbG93KHBheSxhZGRyZXNzKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NzY2LTc3MAogICAgLy8gZm9sbG93KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFkZHJlc3M6IEFjY291bnQKICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjpBa2l0YVNvY2lhbFBsdWdpbi51bmZvbGxvd1tyb3V0aW5nXSgpIC0+IHZvaWQ6CnVuZm9sbG93OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NzkyLTc5NgogICAgLy8gdW5mb2xsb3coCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYWRkcmVzczogQWNjb3VudAogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18yIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6Nzk5CiAgICAvLyBjb25zdCB7IGdyYXBoIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjc5OQogICAgLy8gY29uc3QgeyBncmFwaCB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0NQogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YVNvY2lhbEFwcExpc3QpKQogICAgYnl0ZWNfMSAvLyAic2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6Nzk5CiAgICAvLyBjb25zdCB7IGdyYXBoIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGludGNfMiAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6ODAxLTgwNgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWxHcmFwaC5wcm90b3R5cGUudW5mb2xsb3c+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogZ3JhcGgsCiAgICAvLyAgIGFyZ3M6IFthZGRyZXNzXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjgwNQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDQKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo4MDEtODA2CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbEdyYXBoLnByb3RvdHlwZS51bmZvbGxvdz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBncmFwaCwKICAgIC8vICAgYXJnczogW2FkZHJlc3NdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4MTYxYjNhN2EgLy8gbWV0aG9kICJ1bmZvbGxvdyhhZGRyZXNzKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NzkyLTc5NgogICAgLy8gdW5mb2xsb3coCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYWRkcmVzczogQWNjb3VudAogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OkFraXRhU29jaWFsUGx1Z2luLmJsb2NrW3JvdXRpbmddKCkgLT4gdm9pZDoKYmxvY2s6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo4MTEtODE1CiAgICAvLyBibG9jaygKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhZGRyZXNzOiBBY2NvdW50CiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzIgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo4MTgKICAgIC8vIGNvbnN0IHsgZ3JhcGggfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6ODE4CiAgICAvLyBjb25zdCB7IGdyYXBoIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQ1CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhU29jaWFsQXBwTGlzdCkpCiAgICBieXRlY18xIC8vICJzYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo4MTgKICAgIC8vIGNvbnN0IHsgZ3JhcGggfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18yIC8vIDgKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo4MjIKICAgIC8vIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihncmFwaCkuYWRkcmVzcywKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6ODIzCiAgICAvLyBhbW91bnQ6IHRoaXMubWJyKG9wLmJ6ZXJvKDApKS5ibG9ja3MKICAgIGludGNfMCAvLyAwCiAgICBiemVybwogICAgY2FsbHN1YiBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6OkJhc2VTb2NpYWwubWJyCiAgICBpbnRjXzIgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjgyNi04MzEKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsR3JhcGgucHJvdG90eXBlLmJsb2NrPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdyYXBoLAogICAgLy8gICBhcmdzOiBbbWJyUGF5bWVudCwgYWRkcmVzc10sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo4MjAtODI0CiAgICAvLyBjb25zdCBtYnJQYXltZW50ID0gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogQXBwbGljYXRpb24oZ3JhcGgpLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogdGhpcy5tYnIob3AuYnplcm8oMCkpLmJsb2NrcwogICAgLy8gfSkKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjgyNi04MzEKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsR3JhcGgucHJvdG90eXBlLmJsb2NrPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdyYXBoLAogICAgLy8gICBhcmdzOiBbbWJyUGF5bWVudCwgYWRkcmVzc10sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjgzMAogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDQKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo4MjYtODMxCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbEdyYXBoLnByb3RvdHlwZS5ibG9jaz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBncmFwaCwKICAgIC8vICAgYXJnczogW21iclBheW1lbnQsIGFkZHJlc3NdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4YjU5YzhhNTQgLy8gbWV0aG9kICJibG9jayhwYXksYWRkcmVzcyl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjgxMS04MTUKICAgIC8vIGJsb2NrKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFkZHJlc3M6IEFjY291bnQKICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjpBa2l0YVNvY2lhbFBsdWdpbi51bmJsb2NrW3JvdXRpbmddKCkgLT4gdm9pZDoKdW5ibG9jazoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjgzNC04MzgKICAgIC8vIHVuYmxvY2soCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYWRkcmVzczogQWNjb3VudAogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18yIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6ODQxCiAgICAvLyBjb25zdCB7IGdyYXBoIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjg0MQogICAgLy8gY29uc3QgeyBncmFwaCB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0NQogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YVNvY2lhbEFwcExpc3QpKQogICAgYnl0ZWNfMSAvLyAic2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6ODQxCiAgICAvLyBjb25zdCB7IGdyYXBoIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGludGNfMiAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6ODQzLTg0OAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWxHcmFwaC5wcm90b3R5cGUudW5ibG9jaz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBncmFwaCwKICAgIC8vICAgYXJnczogW2FkZHJlc3NdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6ODQ3CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgNAogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjg0My04NDgKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsR3JhcGgucHJvdG90eXBlLnVuYmxvY2s+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogZ3JhcGgsCiAgICAvLyAgIGFyZ3M6IFthZGRyZXNzXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweGFlZWJiMzc4IC8vIG1ldGhvZCAidW5ibG9jayhhZGRyZXNzKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6ODM0LTgzOAogICAgLy8gdW5ibG9jaygKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhZGRyZXNzOiBBY2NvdW50CiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo6QWtpdGFTb2NpYWxQbHVnaW4uYWRkTW9kZXJhdG9yW3JvdXRpbmddKCkgLT4gdm9pZDoKYWRkTW9kZXJhdG9yOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6ODUxLTg1NQogICAgLy8gYWRkTW9kZXJhdG9yKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFkZHJlc3M6IEFjY291bnQKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMiAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjg1OAogICAgLy8gY29uc3QgeyBtb2RlcmF0aW9uIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjg1OAogICAgLy8gY29uc3QgeyBtb2RlcmF0aW9uIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQ1CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhU29jaWFsQXBwTGlzdCkpCiAgICBieXRlY18xIC8vICJzYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo4NTgKICAgIC8vIGNvbnN0IHsgbW9kZXJhdGlvbiB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBwdXNoaW50IDI0IC8vIDI0CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6ODYyCiAgICAvLyByZWNlaXZlcjogQXBwbGljYXRpb24obW9kZXJhdGlvbikuYWRkcmVzcywKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6ODYzCiAgICAvLyBhbW91bnQ6IHRoaXMubWJyKG9wLmJ6ZXJvKDApKS5tb2RlcmF0b3JzCiAgICBpbnRjXzAgLy8gMAogICAgYnplcm8KICAgIGNhbGxzdWIgc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjpCYXNlU29jaWFsLm1icgogICAgcHVzaGludCA2NCAvLyA2NAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjg2Ni04NzEKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsTW9kZXJhdGlvbi5wcm90b3R5cGUuYWRkTW9kZXJhdG9yPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IG1vZGVyYXRpb24sCiAgICAvLyAgIGFyZ3M6IFttYnJQYXltZW50LCBhZGRyZXNzXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjg2MC04NjQKICAgIC8vIGNvbnN0IG1iclBheW1lbnQgPSBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihtb2RlcmF0aW9uKS5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IHRoaXMubWJyKG9wLmJ6ZXJvKDApKS5tb2RlcmF0b3JzCiAgICAvLyB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6ODY2LTg3MQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWxNb2RlcmF0aW9uLnByb3RvdHlwZS5hZGRNb2RlcmF0b3I+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogbW9kZXJhdGlvbiwKICAgIC8vICAgYXJnczogW21iclBheW1lbnQsIGFkZHJlc3NdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo4NzAKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciA0CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6ODY2LTg3MQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWxNb2RlcmF0aW9uLnByb3RvdHlwZS5hZGRNb2RlcmF0b3I+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogbW9kZXJhdGlvbiwKICAgIC8vICAgYXJnczogW21iclBheW1lbnQsIGFkZHJlc3NdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4Nzc2NjJjOGUgLy8gbWV0aG9kICJhZGRNb2RlcmF0b3IocGF5LGFkZHJlc3Mpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo4NTEtODU1CiAgICAvLyBhZGRNb2RlcmF0b3IoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYWRkcmVzczogQWNjb3VudAogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OkFraXRhU29jaWFsUGx1Z2luLnJlbW92ZU1vZGVyYXRvcltyb3V0aW5nXSgpIC0+IHZvaWQ6CnJlbW92ZU1vZGVyYXRvcjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjg3NS04NzkKICAgIC8vIHJlbW92ZU1vZGVyYXRvcigKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhZGRyZXNzOiBBY2NvdW50CiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzIgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo4ODIKICAgIC8vIGNvbnN0IHsgbW9kZXJhdGlvbiB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo4ODIKICAgIC8vIGNvbnN0IHsgbW9kZXJhdGlvbiB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0NQogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YVNvY2lhbEFwcExpc3QpKQogICAgYnl0ZWNfMSAvLyAic2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6ODgyCiAgICAvLyBjb25zdCB7IG1vZGVyYXRpb24gfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgcHVzaGludCAyNCAvLyAyNAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjg4NC04ODkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsTW9kZXJhdGlvbi5wcm90b3R5cGUucmVtb3ZlTW9kZXJhdG9yPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IG1vZGVyYXRpb24sCiAgICAvLyAgIGFyZ3M6IFthZGRyZXNzXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjg4OAogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDQKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo4ODQtODg5CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbE1vZGVyYXRpb24ucHJvdG90eXBlLnJlbW92ZU1vZGVyYXRvcj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBtb2RlcmF0aW9uLAogICAgLy8gICBhcmdzOiBbYWRkcmVzc10sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHgwM2UzYWIyMiAvLyBtZXRob2QgInJlbW92ZU1vZGVyYXRvcihhZGRyZXNzKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6ODc1LTg3OQogICAgLy8gcmVtb3ZlTW9kZXJhdG9yKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFkZHJlc3M6IEFjY291bnQKICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjpBa2l0YVNvY2lhbFBsdWdpbi5iYW5bcm91dGluZ10oKSAtPiB2b2lkOgpiYW46CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo4OTItODk3CiAgICAvLyBiYW4oCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYWRkcmVzczogQWNjb3VudCwKICAgIC8vICAgZXhwaXJhdGlvbjogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18yIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OTAwCiAgICAvLyBjb25zdCB7IG1vZGVyYXRpb24gfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OTAwCiAgICAvLyBjb25zdCB7IG1vZGVyYXRpb24gfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDUKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFTb2NpYWxBcHBMaXN0KSkKICAgIGJ5dGVjXzEgLy8gInNhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjkwMAogICAgLy8gY29uc3QgeyBtb2RlcmF0aW9uIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo5MDQKICAgIC8vIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihtb2RlcmF0aW9uKS5hZGRyZXNzLAogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo5MDUKICAgIC8vIGFtb3VudDogdGhpcy5tYnIob3AuYnplcm8oMCkpLmJhbm5lZAogICAgaW50Y18wIC8vIDAKICAgIGJ6ZXJvCiAgICBjYWxsc3ViIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czo6QmFzZVNvY2lhbC5tYnIKICAgIHB1c2hpbnQgNzIgLy8gNzIKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo5MDgtOTEzCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbE1vZGVyYXRpb24ucHJvdG90eXBlLmJhbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBtb2RlcmF0aW9uLAogICAgLy8gICBhcmdzOiBbbWJyUGF5bWVudCwgYWRkcmVzcywgZXhwaXJhdGlvbl0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo5MDItOTA2CiAgICAvLyBjb25zdCBtYnJQYXltZW50ID0gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogQXBwbGljYXRpb24obW9kZXJhdGlvbikuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiB0aGlzLm1icihvcC5iemVybygwKSkuYmFubmVkCiAgICAvLyB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OTA4LTkxMwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWxNb2RlcmF0aW9uLnByb3RvdHlwZS5iYW4+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogbW9kZXJhdGlvbiwKICAgIC8vICAgYXJnczogW21iclBheW1lbnQsIGFkZHJlc3MsIGV4cGlyYXRpb25dLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo5MTIKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIHVuY292ZXIgNAogICAgdW5jb3ZlciA1CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OTA4LTkxMwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWxNb2RlcmF0aW9uLnByb3RvdHlwZS5iYW4+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogbW9kZXJhdGlvbiwKICAgIC8vICAgYXJnczogW21iclBheW1lbnQsIGFkZHJlc3MsIGV4cGlyYXRpb25dLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4OGViYzE5YjUgLy8gbWV0aG9kICJiYW4ocGF5LGFkZHJlc3MsdWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6ODkyLTg5NwogICAgLy8gYmFuKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFkZHJlc3M6IEFjY291bnQsCiAgICAvLyAgIGV4cGlyYXRpb246IHVpbnQ2NAogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OkFraXRhU29jaWFsUGx1Z2luLmZsYWdQb3N0W3JvdXRpbmddKCkgLT4gdm9pZDoKZmxhZ1Bvc3Q6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo5MTYtOTIwCiAgICAvLyBmbGFnUG9zdCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICByZWY6IGJ5dGVzPDMyPgogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18yIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OTIzCiAgICAvLyBjb25zdCB7IG1vZGVyYXRpb24gfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OTIzCiAgICAvLyBjb25zdCB7IG1vZGVyYXRpb24gfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDUKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFTb2NpYWxBcHBMaXN0KSkKICAgIGJ5dGVjXzEgLy8gInNhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjkyMwogICAgLy8gY29uc3QgeyBtb2RlcmF0aW9uIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo5MjUtOTMwCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbE1vZGVyYXRpb24ucHJvdG90eXBlLmZsYWdQb3N0Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IG1vZGVyYXRpb24sCiAgICAvLyAgIGFyZ3M6IFtyZWZdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OTI5CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgNAogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjkyNS05MzAKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsTW9kZXJhdGlvbi5wcm90b3R5cGUuZmxhZ1Bvc3Q+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogbW9kZXJhdGlvbiwKICAgIC8vICAgYXJnczogW3JlZl0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHg2MWRjZDJlZiAvLyBtZXRob2QgImZsYWdQb3N0KGJ5dGVbMzJdKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OTE2LTkyMAogICAgLy8gZmxhZ1Bvc3QoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgcmVmOiBieXRlczwzMj4KICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjpBa2l0YVNvY2lhbFBsdWdpbi51bmZsYWdQb3N0W3JvdXRpbmddKCkgLT4gdm9pZDoKdW5mbGFnUG9zdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjkzMy05MzcKICAgIC8vIHVuZmxhZ1Bvc3QoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgcmVmOiBieXRlczwzMj4KICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMiAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjk0MAogICAgLy8gY29uc3QgeyBtb2RlcmF0aW9uIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjk0MAogICAgLy8gY29uc3QgeyBtb2RlcmF0aW9uIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQ1CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhU29jaWFsQXBwTGlzdCkpCiAgICBieXRlY18xIC8vICJzYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo5NDAKICAgIC8vIGNvbnN0IHsgbW9kZXJhdGlvbiB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBwdXNoaW50IDI0IC8vIDI0CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OTQyLTk0NwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWxNb2RlcmF0aW9uLnByb3RvdHlwZS51bmZsYWdQb3N0Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IG1vZGVyYXRpb24sCiAgICAvLyAgIGFyZ3M6IFtyZWZdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OTQ2CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgNAogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjk0Mi05NDcKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsTW9kZXJhdGlvbi5wcm90b3R5cGUudW5mbGFnUG9zdD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBtb2RlcmF0aW9uLAogICAgLy8gICBhcmdzOiBbcmVmXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDc5NjBlYTc2IC8vIG1ldGhvZCAidW5mbGFnUG9zdChieXRlWzMyXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjkzMy05MzcKICAgIC8vIHVuZmxhZ1Bvc3QoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgcmVmOiBieXRlczwzMj4KICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjpBa2l0YVNvY2lhbFBsdWdpbi51bmJhbltyb3V0aW5nXSgpIC0+IHZvaWQ6CnVuYmFuOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OTUwLTk1NAogICAgLy8gdW5iYW4oCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYWRkcmVzczogQWNjb3VudAogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18yIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OTU3CiAgICAvLyBjb25zdCB7IG1vZGVyYXRpb24gfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OTU3CiAgICAvLyBjb25zdCB7IG1vZGVyYXRpb24gfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDUKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFTb2NpYWxBcHBMaXN0KSkKICAgIGJ5dGVjXzEgLy8gInNhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjk1NwogICAgLy8gY29uc3QgeyBtb2RlcmF0aW9uIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo5NTktOTY0CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbE1vZGVyYXRpb24ucHJvdG90eXBlLnVuYmFuPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IG1vZGVyYXRpb24sCiAgICAvLyAgIGFyZ3M6IFthZGRyZXNzXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjk2MwogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDQKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo5NTktOTY0CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbE1vZGVyYXRpb24ucHJvdG90eXBlLnVuYmFuPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IG1vZGVyYXRpb24sCiAgICAvLyAgIGFyZ3M6IFthZGRyZXNzXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweGEwZDIzMjFkIC8vIG1ldGhvZCAidW5iYW4oYWRkcmVzcyl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjk1MC05NTQKICAgIC8vIHVuYmFuKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFkZHJlc3M6IEFjY291bnQKICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjpBa2l0YVNvY2lhbFBsdWdpbi5hZGRBY3Rpb25bcm91dGluZ10oKSAtPiB2b2lkOgphZGRBY3Rpb246CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo5NjctOTcyCiAgICAvLyBhZGRBY3Rpb24oCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYWN0aW9uQXBwSUQ6IHVpbnQ2NCwKICAgIC8vICAgY29udGVudDogQ0lECiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzYgLy8gMzYKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzM2XQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18yIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OTc1CiAgICAvLyBjb25zdCB7IG1vZGVyYXRpb24gfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OTc1CiAgICAvLyBjb25zdCB7IG1vZGVyYXRpb24gfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDUKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFTb2NpYWxBcHBMaXN0KSkKICAgIGJ5dGVjXzEgLy8gInNhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjk3NQogICAgLy8gY29uc3QgeyBtb2RlcmF0aW9uIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo5NzkKICAgIC8vIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihtb2RlcmF0aW9uKS5hZGRyZXNzLAogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo5ODAKICAgIC8vIGFtb3VudDogdGhpcy5tYnIob3AuYnplcm8oMCkpLmFjdGlvbnMKICAgIGludGNfMCAvLyAwCiAgICBiemVybwogICAgY2FsbHN1YiBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6OkJhc2VTb2NpYWwubWJyCiAgICBwdXNoaW50IDgwIC8vIDgwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OTgzLTk5MgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWxNb2RlcmF0aW9uLnByb3RvdHlwZS5hZGRBY3Rpb24+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogbW9kZXJhdGlvbiwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgYWN0aW9uQXBwSUQsCiAgICAvLyAgICAgY29udGVudAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGRpZyAxCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OTc3LTk4MQogICAgLy8gY29uc3QgbWJyUGF5bWVudCA9IGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IEFwcGxpY2F0aW9uKG1vZGVyYXRpb24pLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogdGhpcy5tYnIob3AuYnplcm8oMCkpLmFjdGlvbnMKICAgIC8vIH0pCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo5ODMtOTkyCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbE1vZGVyYXRpb24ucHJvdG90eXBlLmFkZEFjdGlvbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBtb2RlcmF0aW9uLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICBhY3Rpb25BcHBJRCwKICAgIC8vICAgICBjb250ZW50CiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjk5MQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciA0CiAgICB1bmNvdmVyIDUKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo5ODMtOTkyCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbE1vZGVyYXRpb24ucHJvdG90eXBlLmFkZEFjdGlvbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBtb2RlcmF0aW9uLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICBhY3Rpb25BcHBJRCwKICAgIC8vICAgICBjb250ZW50CiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHhkOTA2NzFiNiAvLyBtZXRob2QgImFkZEFjdGlvbihwYXksdWludDY0LGJ5dGVbMzZdKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OTY3LTk3MgogICAgLy8gYWRkQWN0aW9uKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFjdGlvbkFwcElEOiB1aW50NjQsCiAgICAvLyAgIGNvbnRlbnQ6IENJRAogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OkFraXRhU29jaWFsUGx1Z2luLnJlbW92ZUFjdGlvbltyb3V0aW5nXSgpIC0+IHZvaWQ6CnJlbW92ZUFjdGlvbjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjk5NS05OTkKICAgIC8vIHJlbW92ZUFjdGlvbigKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhY3Rpb25BcHBJRDogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18yIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTAwMgogICAgLy8gY29uc3QgeyBtb2RlcmF0aW9uIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjEwMDIKICAgIC8vIGNvbnN0IHsgbW9kZXJhdGlvbiB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0NQogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YVNvY2lhbEFwcExpc3QpKQogICAgYnl0ZWNfMSAvLyAic2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTAwMgogICAgLy8gY29uc3QgeyBtb2RlcmF0aW9uIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxMDA0LTEwMDkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsTW9kZXJhdGlvbi5wcm90b3R5cGUucmVtb3ZlQWN0aW9uPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IG1vZGVyYXRpb24sCiAgICAvLyAgIGFyZ3M6IFthY3Rpb25BcHBJRF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxMDA4CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgNAogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjEwMDQtMTAwOQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWxNb2RlcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVBY3Rpb24+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogbW9kZXJhdGlvbiwKICAgIC8vICAgYXJnczogW2FjdGlvbkFwcElEXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweGYxNDkyYmY0IC8vIG1ldGhvZCAicmVtb3ZlQWN0aW9uKHVpbnQ2NCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjk5NS05OTkKICAgIC8vIHJlbW92ZUFjdGlvbigKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhY3Rpb25BcHBJRDogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo6QWtpdGFTb2NpYWxQbHVnaW4uaW5pdE1ldGFbcm91dGluZ10oKSAtPiB2b2lkOgppbml0TWV0YToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjEwMTItMTAyMAogICAgLy8gaW5pdE1ldGEoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgdXNlcjogQWNjb3VudCwKICAgIC8vICAgYXV0b21hdGVkOiBib29sZWFuLAogICAgLy8gICBzdWJzY3JpcHRpb25JbmRleDogdWludDY0LAogICAgLy8gICBORkQ6IHVpbnQ2NCwKICAgIC8vICAgYWtpdGFORlQ6IHVpbnQ2NAogICAgLy8gKTogdWludDY0IHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDcKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgNgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzIgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxMDIzCiAgICAvLyBjb25zdCB7IHNvY2lhbCB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxMDIzCiAgICAvLyBjb25zdCB7IHNvY2lhbCB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0NQogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YVNvY2lhbEFwcExpc3QpKQogICAgYnl0ZWNfMSAvLyAic2FsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTAyMwogICAgLy8gY29uc3QgeyBzb2NpYWwgfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxMDI1LTEwNDEKICAgIC8vIGNvbnN0IGltcGFjdCA9IGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsLnByb3RvdHlwZS5pbml0TWV0YT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBzb2NpYWwsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHNvY2lhbCkuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogdGhpcy5tYnIob3AuYnplcm8oMCkpLm1ldGEgKyBJbXBhY3RNZXRhTUJSCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgdXNlciwKICAgIC8vICAgICBhdXRvbWF0ZWQsCiAgICAvLyAgICAgc3Vic2NyaXB0aW9uSW5kZXgsCiAgICAvLyAgICAgTkZELAogICAgLy8gICAgIGFraXRhTkZUCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxMDMxCiAgICAvLyByZWNlaXZlcjogQXBwbGljYXRpb24oc29jaWFsKS5hZGRyZXNzLAogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxMDMyCiAgICAvLyBhbW91bnQ6IHRoaXMubWJyKG9wLmJ6ZXJvKDApKS5tZXRhICsgSW1wYWN0TWV0YU1CUgogICAgaW50Y18wIC8vIDAKICAgIGJ6ZXJvCiAgICBjYWxsc3ViIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czo6QmFzZVNvY2lhbC5tYnIKICAgIHB1c2hpbnQgNTYgLy8gNTYKICAgIGV4dHJhY3RfdWludDY0CiAgICBwdXNoaW50IDMxNzAwIC8vIDMxNzAwCiAgICArCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxMDI5LTEwMzMKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IEFwcGxpY2F0aW9uKHNvY2lhbCkuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiB0aGlzLm1icihvcC5iemVybygwKSkubWV0YSArIEltcGFjdE1ldGFNQlIKICAgIC8vIH0pLAogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTAyNS0xMDQxCiAgICAvLyBjb25zdCBpbXBhY3QgPSBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbC5wcm90b3R5cGUuaW5pdE1ldGE+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogc29jaWFsLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihzb2NpYWwpLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IHRoaXMubWJyKG9wLmJ6ZXJvKDApKS5tZXRhICsgSW1wYWN0TWV0YU1CUgogICAgLy8gICAgIH0pLAogICAgLy8gICAgIHVzZXIsCiAgICAvLyAgICAgYXV0b21hdGVkLAogICAgLy8gICAgIHN1YnNjcmlwdGlvbkluZGV4LAogICAgLy8gICAgIE5GRCwKICAgIC8vICAgICBha2l0YU5GVAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxMDQwCiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICB1bmNvdmVyIDcKICAgIHVuY292ZXIgOAogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjEwMjUtMTA0MQogICAgLy8gY29uc3QgaW1wYWN0ID0gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWwucHJvdG90eXBlLmluaXRNZXRhPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogQXBwbGljYXRpb24oc29jaWFsKS5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiB0aGlzLm1icihvcC5iemVybygwKSkubWV0YSArIEltcGFjdE1ldGFNQlIKICAgIC8vICAgICB9KSwKICAgIC8vICAgICB1c2VyLAogICAgLy8gICAgIGF1dG9tYXRlZCwKICAgIC8vICAgICBzdWJzY3JpcHRpb25JbmRleCwKICAgIC8vICAgICBORkQsCiAgICAvLyAgICAgYWtpdGFORlQKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweDg1NjQzM2VhIC8vIG1ldGhvZCAiaW5pdE1ldGEocGF5LGFkZHJlc3MsYm9vbCx1aW50NjQsdWludDY0LHVpbnQ2NCl1aW50NjQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA3CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA1CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgZ2l0eG4gMSBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMyAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxMDEyLTEwMjAKICAgIC8vIGluaXRNZXRhKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIHVzZXI6IEFjY291bnQsCiAgICAvLyAgIGF1dG9tYXRlZDogYm9vbGVhbiwKICAgIC8vICAgc3Vic2NyaXB0aW9uSW5kZXg6IHVpbnQ2NCwKICAgIC8vICAgTkZEOiB1aW50NjQsCiAgICAvLyAgIGFraXRhTkZUOiB1aW50NjQKICAgIC8vICk6IHVpbnQ2NCB7CiAgICBieXRlY18zIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6OkFraXRhU29jaWFsUGx1Z2luLnVwZGF0ZU1ldGFbcm91dGluZ10oKSAtPiB2b2lkOgp1cGRhdGVNZXRhOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTA0Ni0xMDU1CiAgICAvLyB1cGRhdGVNZXRhKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGZvbGxvd0dhdGVJRDogdWludDY0LAogICAgLy8gICBhZGRyZXNzR2F0ZUlEOiB1aW50NjQsCiAgICAvLyAgIHN1YnNjcmlwdGlvbkluZGV4OiB1aW50NjQsCiAgICAvLyAgIE5GRDogdWludDY0LAogICAgLy8gICBha2l0YU5GVDogdWludDY0LAogICAgLy8gICBkZWZhdWx0UGF5V2FsbElEOiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDYKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA3CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgOAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyA3CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMiAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjEwNTkKICAgIC8vIGNvbnN0IHsgc29jaWFsIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjEwNTkKICAgIC8vIGNvbnN0IHsgc29jaWFsIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQ1CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhU29jaWFsQXBwTGlzdCkpCiAgICBieXRlY18xIC8vICJzYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czoxMDU5CiAgICAvLyBjb25zdCB7IHNvY2lhbCB9ID0gZ2V0QWtpdGFTb2NpYWxBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjEwNjEtMTA3MwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgQWtpdGFTb2NpYWwucHJvdG90eXBlLnVwZGF0ZU1ldGE+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogc29jaWFsLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgZm9sbG93R2F0ZUlELAogICAgLy8gICAgIGFkZHJlc3NHYXRlSUQsCiAgICAvLyAgICAgc3Vic2NyaXB0aW9uSW5kZXgsCiAgICAvLyAgICAgTkZELAogICAgLy8gICAgIGFraXRhTkZULAogICAgLy8gICAgIGRlZmF1bHRQYXlXYWxsSUQKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjEwNzIKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIHVuY292ZXIgOAogICAgdW5jb3ZlciA5CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTA2MS0xMDczCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbC5wcm90b3R5cGUudXBkYXRlTWV0YT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBzb2NpYWwsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBmb2xsb3dHYXRlSUQsCiAgICAvLyAgICAgYWRkcmVzc0dhdGVJRCwKICAgIC8vICAgICBzdWJzY3JpcHRpb25JbmRleCwKICAgIC8vICAgICBORkQsCiAgICAvLyAgICAgYWtpdGFORlQsCiAgICAvLyAgICAgZGVmYXVsdFBheVdhbGxJRAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4NjlhNGVmOTcgLy8gbWV0aG9kICJ1cGRhdGVNZXRhKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA4CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA3CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA1CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MTA0Ni0xMDU1CiAgICAvLyB1cGRhdGVNZXRhKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGZvbGxvd0dhdGVJRDogdWludDY0LAogICAgLy8gICBhZGRyZXNzR2F0ZUlEOiB1aW50NjQsCiAgICAvLyAgIHN1YnNjcmlwdGlvbkluZGV4OiB1aW50NjQsCiAgICAvLyAgIE5GRDogdWludDY0LAogICAgLy8gICBha2l0YU5GVDogdWludDY0LAogICAgLy8gICBkZWZhdWx0UGF5V2FsbElEOiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjpBa2l0YUJhc2VDb250cmFjdC51cGRhdGVBa2l0YURBT1tyb3V0aW5nXSgpIC0+IHZvaWQ6CnVwZGF0ZUFraXRhREFPOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzgKICAgIC8vIHVwZGF0ZUFraXRhREFPKGFraXRhREFPOiBBcHBsaWNhdGlvbik6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjM5CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5nZXRBa2l0YURBT1dhbGxldCgpLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzIKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzIKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIHB1c2hieXRlcyAid2FsbGV0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzkKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSB0aGlzLmdldEFraXRhREFPV2FsbGV0KCkuYWRkcmVzcywgRVJSX05PVF9BS0lUQV9EQU8pCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgdGhlIEFraXRhIERBTyBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjQwCiAgICAvLyB0aGlzLmFraXRhREFPLnZhbHVlID0gYWtpdGFEQU8KICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozOAogICAgLy8gdXBkYXRlQWtpdGFEQU8oYWtpdGFEQU86IEFwcGxpY2F0aW9uKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjpCYXNlU29jaWFsLm1icltyb3V0aW5nXSgpIC0+IHZvaWQ6Cm1icjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czoxNAogICAgLy8gbWJyKHJlZjogYnl0ZXMpOiBBa2l0YVNvY2lhbE1CUkRhdGEgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3VpbnQ4W10pCiAgICBleHRyYWN0IDIgMAogICAgY2FsbHN1YiBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6OkJhc2VTb2NpYWwubWJyCiAgICBieXRlY18zIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjpCYXNlU29jaWFsLnBheVdhbGxNYnJbcm91dGluZ10oKSAtPiB2b2lkOgpwYXlXYWxsTWJyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjMwCiAgICAvLyBwYXlXYWxsTWJyKHBheXdhbGw6IFZpZXdQYXlXYWxsVmFsdWUpOiB1aW50NjQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjMzCiAgICAvLyBQYXlXYWxsUGF5T3B0aW9uU2l6ZSAqIChwYXl3YWxsLmFnZW50UGF5SW5mby5sZW5ndGggKyBwYXl3YWxsLnVzZXJQYXlJbmZvLmxlbmd0aCkKICAgIGR1cAogICAgcHVzaGludCAyIC8vIDIKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMQogICAgbGVuCiAgICBkaWcgMgogICAgZGlnIDIKICAgIHVuY292ZXIgMgogICAgc3Vic3RyaW5nMwogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBkaWcgMgogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICB1bmNvdmVyIDMKICAgIHN3YXAKICAgIHVuY292ZXIgMwogICAgc3Vic3RyaW5nMwogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6MzItMzQKICAgIC8vIEJveENvc3RQZXJCeXRlICogKAogICAgLy8gICBQYXlXYWxsUGF5T3B0aW9uU2l6ZSAqIChwYXl3YWxsLmFnZW50UGF5SW5mby5sZW5ndGggKyBwYXl3YWxsLnVzZXJQYXlJbmZvLmxlbmd0aCkKICAgIC8vICkKICAgIHB1c2hpbnQgNjgwMCAvLyA2ODAwCiAgICAqCiAgICAvLyBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6MzEKICAgIC8vIHJldHVybiBNaW5QYXlXYWxsTUJSICsgKAogICAgcHVzaGludCA1MjAwIC8vIDUyMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czozMS0zNQogICAgLy8gcmV0dXJuIE1pblBheVdhbGxNQlIgKyAoCiAgICAvLyAgIEJveENvc3RQZXJCeXRlICogKAogICAgLy8gICAgIFBheVdhbGxQYXlPcHRpb25TaXplICogKHBheXdhbGwuYWdlbnRQYXlJbmZvLmxlbmd0aCArIHBheXdhbGwudXNlclBheUluZm8ubGVuZ3RoKQogICAgLy8gICApCiAgICAvLyApCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6MzAKICAgIC8vIHBheVdhbGxNYnIocGF5d2FsbDogVmlld1BheVdhbGxWYWx1ZSk6IHVpbnQ2NCB7CiAgICBpdG9iCiAgICBieXRlY18zIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjpCYXNlU29jaWFsLmNoZWNrVGlwTWJyUmVxdWlyZW1lbnRzW3JvdXRpbmddKCkgLT4gdm9pZDoKY2hlY2tUaXBNYnJSZXF1aXJlbWVudHM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6NTEKICAgIC8vIGNoZWNrVGlwTWJyUmVxdWlyZW1lbnRzKGFraXRhREFPOiBBcHBsaWNhdGlvbiwgY3JlYXRvcjogQWNjb3VudCwgd2FsbGV0OiBBcHBsaWNhdGlvbik6IHRpcE1CUkluZm8gewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBjYWxsc3ViIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czo6QmFzZVNvY2lhbC5jaGVja1RpcE1iclJlcXVpcmVtZW50cwogICAgYnl0ZWNfMyAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjpBa2l0YVNvY2lhbFBsdWdpbi5nZXRDcmVhdG9yRGV0YWlscyh0eXBlOiBieXRlcywgc2VuZGVyOiBieXRlcywgcmVmOiBieXRlcykgLT4gYnl0ZXM6CmdldENyZWF0b3JEZXRhaWxzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MzEKICAgIC8vIHByaXZhdGUgZ2V0Q3JlYXRvckRldGFpbHModHlwZTogUmVmVHlwZSwgc2VuZGVyOiBBY2NvdW50LCByZWY6IGJ5dGVzPDMyPik6IHsgcG9zdEV4aXN0czogYm9vbGVhbiwgY3JlYXRvcjogQWNjb3VudCwgY3JlYXRvcldhbGxldDogdWludDY0LCBnYXRlSUQ6IHVpbnQ2NCB9IHsKICAgIHByb3RvIDMgMQogICAgcHVzaGJ5dGVzICIiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozMgogICAgLy8gY29uc3QgeyBzb2NpYWwgfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MzIKICAgIC8vIGNvbnN0IHsgc29jaWFsIH0gPSBnZXRBa2l0YVNvY2lhbEFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQ1CiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhU29jaWFsQXBwTGlzdCkpCiAgICBieXRlY18xIC8vICJzYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozMgogICAgLy8gY29uc3QgeyBzb2NpYWwgfSA9IGdldEFraXRhU29jaWFsQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozNAogICAgLy8gbGV0IGNyZWF0b3IgPSBHbG9iYWwuemVyb0FkZHJlc3MKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MzYKICAgIC8vIGxldCBnYXRlSUQ6IHVpbnQ2NCA9IDAKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czozOAogICAgLy8gbGV0IHBvc3RNdXN0RXhpc3QgPSB0eXBlID09PSBSZWZUeXBlUG9zdAogICAgZnJhbWVfZGlnIC0zCiAgICBieXRlYyA5IC8vIDB4MGEKICAgID09CiAgICBkdXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjQyCiAgICAvLyBpZiAoIXBvc3RNdXN0RXhpc3QpIHsKICAgIGJ6IGdldENyZWF0b3JEZXRhaWxzX2lmX2JvZHlAMQogICAgZnJhbWVfZGlnIDQKICAgIGZyYW1lX2J1cnkgMAoKZ2V0Q3JlYXRvckRldGFpbHNfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NTAKICAgIC8vIGlmIChwb3N0RXhpc3RzKSB7CiAgICBmcmFtZV9kaWcgMAogICAgYnogZ2V0Q3JlYXRvckRldGFpbHNfZWxzZV9ib2R5QDYKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjUxLTU1CiAgICAvLyAoeyBjcmVhdG9yLCBnYXRlSUQgfSA9IGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsLnByb3RvdHlwZS5nZXRQb3N0Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogW3JlZl0sCiAgICAvLyB9KS5yZXR1cm5WYWx1ZSk7CiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo1NAogICAgLy8gYXJnczogW3JlZl0sCiAgICBmcmFtZV9kaWcgLTEKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIHNpemUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjUxLTU1CiAgICAvLyAoeyBjcmVhdG9yLCBnYXRlSUQgfSA9IGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsLnByb3RvdHlwZS5nZXRQb3N0Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogW3JlZl0sCiAgICAvLyB9KS5yZXR1cm5WYWx1ZSk7CiAgICBieXRlYyAxMCAvLyBtZXRob2QgImdldFBvc3QoYnl0ZVszMl0pKGFkZHJlc3MsdWludDY0LHVpbnQ2NCxib29sLHVpbnQ2NCxib29sLHVpbnQ4LGJ5dGVbXSkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIDEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgZnJhbWVfZGlnIC0yCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMyAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGR1cAogICAgZXh0cmFjdCA0IDMyCiAgICBmcmFtZV9idXJ5IDIKICAgIHB1c2hpbnQgNDQgLy8gNDQKICAgIGV4dHJhY3RfdWludDY0CiAgICBmcmFtZV9idXJ5IDMKCmdldENyZWF0b3JEZXRhaWxzX2FmdGVyX2lmX2Vsc2VAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo2Ny03MQogICAgLy8gY29uc3QgbWV0YUV4aXN0cyA9IGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsLnByb3RvdHlwZS5nZXRNZXRhRXhpc3RzPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogW2NyZWF0b3JdCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9iZWdpbgogICAgcHVzaGJ5dGVzIDB4ZTZlNjdiZGMgLy8gbWV0aG9kICJnZXRNZXRhRXhpc3RzKGFkZHJlc3MpYm9vbCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBmcmFtZV9kaWcgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAxCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18zIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NzMKICAgIC8vIGlmICghbWV0YUV4aXN0cykgewogICAgYm56IGdldENyZWF0b3JEZXRhaWxzX2FmdGVyX2lmX2Vsc2VAMTgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjc0CiAgICAvLyByZXR1cm4geyBwb3N0RXhpc3RzLCBjcmVhdG9yLCBjcmVhdG9yV2FsbGV0LCBnYXRlSUQgfTsKICAgIHB1c2hieXRlcyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfZGlnIDAKICAgIHNldGJpdAogICAgZnJhbWVfZGlnIDIKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6MzUKICAgIC8vIGxldCBjcmVhdG9yV2FsbGV0OiB1aW50NjQgPSAwCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NzQKICAgIC8vIHJldHVybiB7IHBvc3RFeGlzdHMsIGNyZWF0b3IsIGNyZWF0b3JXYWxsZXQsIGdhdGVJRCB9OwogICAgaXRvYgogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgMwogICAgaXRvYgogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKZ2V0Q3JlYXRvckRldGFpbHNfYWZ0ZXJfaWZfZWxzZUAxODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjc3LTgxCiAgICAvLyAoeyB3YWxsZXQ6IGNyZWF0b3JXYWxsZXQgfSA9IGFiaUNhbGw8dHlwZW9mIEFraXRhU29jaWFsLnByb3RvdHlwZS5nZXRNZXRhPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHNvY2lhbCwKICAgIC8vICAgYXJnczogW2NyZWF0b3JdLAogICAgLy8gfSkucmV0dXJuVmFsdWUpOwogICAgaXR4bl9iZWdpbgogICAgYnl0ZWMgMTIgLy8gbWV0aG9kICJnZXRNZXRhKGFkZHJlc3MpKGJvb2wsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsYm9vbCx1aW50NjQsdWludDY0LHVpbnQ2NCkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIDIKICAgIGR1cAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAxCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIGRpZyAxCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMyAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGxlbgogICAgcHVzaGludCA3NCAvLyA3NAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGJvb2wxLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LGJvb2wxLHVpbnQ2NCx1aW50NjQsdWludDY0KQogICAgZXh0cmFjdCA1IDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjgzCiAgICAvLyByZXR1cm4geyBwb3N0RXhpc3RzLCBjcmVhdG9yLCBjcmVhdG9yV2FsbGV0LCBnYXRlSUQgfTsKICAgIHB1c2hieXRlcyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfZGlnIDAKICAgIHNldGJpdAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIDMKICAgIGl0b2IKICAgIGNvbmNhdAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCmdldENyZWF0b3JEZXRhaWxzX2Vsc2VfYm9keUA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NTgKICAgIC8vIGlmICh0eXBlID09PSBSZWZUeXBlQWRkcmVzcykgewogICAgZnJhbWVfZGlnIC0zCiAgICBwdXNoYnl0ZXMgMHgxZQogICAgPT0KICAgIGJ6IGdldENyZWF0b3JEZXRhaWxzX2Vsc2VfYm9keUA4CiAgICBmcmFtZV9kaWcgLTEKICAgIGZyYW1lX2J1cnkgMgogICAgYiBnZXRDcmVhdG9yRGV0YWlsc19hZnRlcl9pZl9lbHNlQDE1CgpnZXRDcmVhdG9yRGV0YWlsc19lbHNlX2JvZHlAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjYwCiAgICAvLyB9IGVsc2UgaWYgKHR5cGUgPT09IFJlZlR5cGVBc3NldCkgewogICAgZnJhbWVfZGlnIC0zCiAgICBieXRlYyA2IC8vIDB4MTQKICAgID09CiAgICBieiBnZXRDcmVhdG9yRGV0YWlsc19lbHNlX2JvZHlAMTAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3NvY2lhbC9jb250cmFjdC5hbGdvLnRzOjYxCiAgICAvLyBjcmVhdG9yID0gQXNzZXQob3AuYnRvaShyZWYuc2xpY2UoMCwgOCkpKS5jcmVhdG9yCiAgICBmcmFtZV9kaWcgLTEKICAgIGxlbgogICAgaW50Y18wIC8vIDAKICAgIGRpZyAxCiAgICA+PQogICAgaW50Y18wIC8vIDAKICAgIGRpZyAyCiAgICB1bmNvdmVyIDIKICAgIHNlbGVjdAogICAgaW50Y18yIC8vIDgKICAgIGRpZyAyCiAgICA+PQogICAgaW50Y18yIC8vIDgKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciAyCiAgICBzZWxlY3QKICAgIGZyYW1lX2RpZyAtMQogICAgY292ZXIgMgogICAgc3Vic3RyaW5nMwogICAgYnRvaQogICAgYXNzZXRfcGFyYW1zX2dldCBBc3NldENyZWF0b3IKICAgIHN3YXAKICAgIGZyYW1lX2J1cnkgMgogICAgYXNzZXJ0IC8vIGFzc2V0IGV4aXN0cwogICAgYiBnZXRDcmVhdG9yRGV0YWlsc19hZnRlcl9pZl9lbHNlQDE1CgpnZXRDcmVhdG9yRGV0YWlsc19lbHNlX2JvZHlAMTA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zb2NpYWwvY29udHJhY3QuYWxnby50czo2MgogICAgLy8gfSBlbHNlIGlmICh0eXBlID09PSBSZWZUeXBlQXBwKSB7CiAgICBmcmFtZV9kaWcgLTMKICAgIHB1c2hieXRlcyAweDI4CiAgICA9PQogICAgYnogZ2V0Q3JlYXRvckRldGFpbHNfYWZ0ZXJfaWZfZWxzZUAxNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NjMKICAgIC8vIGNyZWF0b3IgPSBBcHBsaWNhdGlvbihvcC5idG9pKHJlZi5zbGljZSgwLCA4KSkpLmNyZWF0b3IKICAgIGZyYW1lX2RpZyAtMQogICAgbGVuCiAgICBpbnRjXzAgLy8gMAogICAgZGlnIDEKICAgID49CiAgICBpbnRjXzAgLy8gMAogICAgZGlnIDIKICAgIHVuY292ZXIgMgogICAgc2VsZWN0CiAgICBpbnRjXzIgLy8gOAogICAgZGlnIDIKICAgID49CiAgICBpbnRjXzIgLy8gOAogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDIKICAgIHNlbGVjdAogICAgZnJhbWVfZGlnIC0xCiAgICBjb3ZlciAyCiAgICBzdWJzdHJpbmczCiAgICBidG9pCiAgICBhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCiAgICBzd2FwCiAgICBmcmFtZV9idXJ5IDIKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGIgZ2V0Q3JlYXRvckRldGFpbHNfYWZ0ZXJfaWZfZWxzZUAxNQoKZ2V0Q3JlYXRvckRldGFpbHNfaWZfYm9keUAxOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NDMtNDcKICAgIC8vIHBvc3RFeGlzdHMgPSBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbC5wcm90b3R5cGUuZ2V0UG9zdEV4aXN0cz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBzb2NpYWwsCiAgICAvLyAgIGFyZ3M6IFtyZWYudG9GaXhlZCh7IGxlbmd0aDogMzIgfSldCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NDYKICAgIC8vIGFyZ3M6IFtyZWYudG9GaXhlZCh7IGxlbmd0aDogMzIgfSldCiAgICBmcmFtZV9kaWcgLTEKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBMZW5ndGggbXVzdCBiZSAzMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc29jaWFsL2NvbnRyYWN0LmFsZ28udHM6NDMtNDcKICAgIC8vIHBvc3RFeGlzdHMgPSBhYmlDYWxsPHR5cGVvZiBBa2l0YVNvY2lhbC5wcm90b3R5cGUuZ2V0UG9zdEV4aXN0cz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBzb2NpYWwsCiAgICAvLyAgIGFyZ3M6IFtyZWYudG9GaXhlZCh7IGxlbmd0aDogMzIgfSldCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgcHVzaGJ5dGVzIDB4YzAyMmJlODkgLy8gbWV0aG9kICJnZXRQb3N0RXhpc3RzKGJ5dGVbMzJdKWJvb2wiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIDEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgZnJhbWVfZGlnIC0yCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzMgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBCeXRlcyBoYXMgdmFsaWQgcHJlZml4CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBmcmFtZV9idXJ5IDAKICAgIGIgZ2V0Q3JlYXRvckRldGFpbHNfYWZ0ZXJfaWZfZWxzZUAzCgoKLy8gc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjpCYXNlU29jaWFsLm1icihyZWY6IGJ5dGVzKSAtPiBieXRlczoKc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjpCYXNlU29jaWFsLm1icjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czoxNAogICAgLy8gbWJyKHJlZjogYnl0ZXMpOiBBa2l0YVNvY2lhbE1CUkRhdGEgewogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6MTgKICAgIC8vIHBvc3RzOiBNaW5Qb3N0c01CUiArIChCb3hDb3N0UGVyQnl0ZSAqIHJlZi5sZW5ndGgpLAogICAgZnJhbWVfZGlnIC0xCiAgICBsZW4KICAgIHB1c2hpbnQgNDAwIC8vIDQwMAogICAgKgogICAgcHVzaGludCA0MDEwMCAvLyA0MDEwMAogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjE1LTI3CiAgICAvLyByZXR1cm4gewogICAgLy8gICBmb2xsb3dzOiBGb2xsb3dzTUJSLAogICAgLy8gICBibG9ja3M6IEJsb2Nrc01CUiwKICAgIC8vICAgcG9zdHM6IE1pblBvc3RzTUJSICsgKEJveENvc3RQZXJCeXRlICogcmVmLmxlbmd0aCksCiAgICAvLyAgIHZvdGVzOiBWb3Rlc01CUiwKICAgIC8vICAgdm90ZWxpc3Q6IFZvdGVsaXN0TUJSLAogICAgLy8gICByZWFjdGlvbnM6IFJlYWN0aW9uc01CUiwKICAgIC8vICAgcmVhY3Rpb25saXN0OiBSZWFjdGlvbmxpc3RNQlIsCiAgICAvLyAgIG1ldGE6IE1ldGFNQlIsCiAgICAvLyAgIG1vZGVyYXRvcnM6IE1vZGVyYXRvcnNNQlIsCiAgICAvLyAgIGJhbm5lZDogQmFubmVkTUJSLAogICAgLy8gICBhY3Rpb25zOiBBY3Rpb25zTUJSCiAgICAvLyB9CiAgICBpdG9iCiAgICBwdXNoYnl0ZXMgMHgwMDAwMDAwMDAwMDA3YmQ0MDAwMDAwMDAwMDAwM2Q1NAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6MTkKICAgIC8vIHZvdGVzOiBWb3Rlc01CUiwKICAgIHB1c2hpbnQgMTkzMDAgLy8gMTkzMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czoxNS0yNwogICAgLy8gcmV0dXJuIHsKICAgIC8vICAgZm9sbG93czogRm9sbG93c01CUiwKICAgIC8vICAgYmxvY2tzOiBCbG9ja3NNQlIsCiAgICAvLyAgIHBvc3RzOiBNaW5Qb3N0c01CUiArIChCb3hDb3N0UGVyQnl0ZSAqIHJlZi5sZW5ndGgpLAogICAgLy8gICB2b3RlczogVm90ZXNNQlIsCiAgICAvLyAgIHZvdGVsaXN0OiBWb3RlbGlzdE1CUiwKICAgIC8vICAgcmVhY3Rpb25zOiBSZWFjdGlvbnNNQlIsCiAgICAvLyAgIHJlYWN0aW9ubGlzdDogUmVhY3Rpb25saXN0TUJSLAogICAgLy8gICBtZXRhOiBNZXRhTUJSLAogICAgLy8gICBtb2RlcmF0b3JzOiBNb2RlcmF0b3JzTUJSLAogICAgLy8gICBiYW5uZWQ6IEJhbm5lZE1CUiwKICAgIC8vICAgYWN0aW9uczogQWN0aW9uc01CUgogICAgLy8gfQogICAgaXRvYgogICAgc3dhcAogICAgZGlnIDEKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6MjEKICAgIC8vIHJlYWN0aW9uczogUmVhY3Rpb25zTUJSLAogICAgcHVzaGludCAyMjEwMCAvLyAyMjEwMAogICAgLy8gc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjE1LTI3CiAgICAvLyByZXR1cm4gewogICAgLy8gICBmb2xsb3dzOiBGb2xsb3dzTUJSLAogICAgLy8gICBibG9ja3M6IEJsb2Nrc01CUiwKICAgIC8vICAgcG9zdHM6IE1pblBvc3RzTUJSICsgKEJveENvc3RQZXJCeXRlICogcmVmLmxlbmd0aCksCiAgICAvLyAgIHZvdGVzOiBWb3Rlc01CUiwKICAgIC8vICAgdm90ZWxpc3Q6IFZvdGVsaXN0TUJSLAogICAgLy8gICByZWFjdGlvbnM6IFJlYWN0aW9uc01CUiwKICAgIC8vICAgcmVhY3Rpb25saXN0OiBSZWFjdGlvbmxpc3RNQlIsCiAgICAvLyAgIG1ldGE6IE1ldGFNQlIsCiAgICAvLyAgIG1vZGVyYXRvcnM6IE1vZGVyYXRvcnNNQlIsCiAgICAvLyAgIGJhbm5lZDogQmFubmVkTUJSLAogICAgLy8gICBhY3Rpb25zOiBBY3Rpb25zTUJSCiAgICAvLyB9CiAgICBpdG9iCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czoyMgogICAgLy8gcmVhY3Rpb25saXN0OiBSZWFjdGlvbmxpc3RNQlIsCiAgICBwdXNoaW50IDE4OTAwIC8vIDE4OTAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6MTUtMjcKICAgIC8vIHJldHVybiB7CiAgICAvLyAgIGZvbGxvd3M6IEZvbGxvd3NNQlIsCiAgICAvLyAgIGJsb2NrczogQmxvY2tzTUJSLAogICAgLy8gICBwb3N0czogTWluUG9zdHNNQlIgKyAoQm94Q29zdFBlckJ5dGUgKiByZWYubGVuZ3RoKSwKICAgIC8vICAgdm90ZXM6IFZvdGVzTUJSLAogICAgLy8gICB2b3RlbGlzdDogVm90ZWxpc3RNQlIsCiAgICAvLyAgIHJlYWN0aW9uczogUmVhY3Rpb25zTUJSLAogICAgLy8gICByZWFjdGlvbmxpc3Q6IFJlYWN0aW9ubGlzdE1CUiwKICAgIC8vICAgbWV0YTogTWV0YU1CUiwKICAgIC8vICAgbW9kZXJhdG9yczogTW9kZXJhdG9yc01CUiwKICAgIC8vICAgYmFubmVkOiBCYW5uZWRNQlIsCiAgICAvLyAgIGFjdGlvbnM6IEFjdGlvbnNNQlIKICAgIC8vIH0KICAgIGl0b2IKICAgIHN3YXAKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czoyMwogICAgLy8gbWV0YTogTWV0YU1CUiwKICAgIHB1c2hpbnQgNDUzMDAgLy8gNDUzMDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czoxNS0yNwogICAgLy8gcmV0dXJuIHsKICAgIC8vICAgZm9sbG93czogRm9sbG93c01CUiwKICAgIC8vICAgYmxvY2tzOiBCbG9ja3NNQlIsCiAgICAvLyAgIHBvc3RzOiBNaW5Qb3N0c01CUiArIChCb3hDb3N0UGVyQnl0ZSAqIHJlZi5sZW5ndGgpLAogICAgLy8gICB2b3RlczogVm90ZXNNQlIsCiAgICAvLyAgIHZvdGVsaXN0OiBWb3RlbGlzdE1CUiwKICAgIC8vICAgcmVhY3Rpb25zOiBSZWFjdGlvbnNNQlIsCiAgICAvLyAgIHJlYWN0aW9ubGlzdDogUmVhY3Rpb25saXN0TUJSLAogICAgLy8gICBtZXRhOiBNZXRhTUJSLAogICAgLy8gICBtb2RlcmF0b3JzOiBNb2RlcmF0b3JzTUJSLAogICAgLy8gICBiYW5uZWQ6IEJhbm5lZE1CUiwKICAgIC8vICAgYWN0aW9uczogQWN0aW9uc01CUgogICAgLy8gfQogICAgaXRvYgogICAgY29uY2F0CiAgICBkaWcgMQogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czoyNgogICAgLy8gYWN0aW9uczogQWN0aW9uc01CUgogICAgcHVzaGludCAyOTcwMCAvLyAyOTcwMAogICAgLy8gc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjE1LTI3CiAgICAvLyByZXR1cm4gewogICAgLy8gICBmb2xsb3dzOiBGb2xsb3dzTUJSLAogICAgLy8gICBibG9ja3M6IEJsb2Nrc01CUiwKICAgIC8vICAgcG9zdHM6IE1pblBvc3RzTUJSICsgKEJveENvc3RQZXJCeXRlICogcmVmLmxlbmd0aCksCiAgICAvLyAgIHZvdGVzOiBWb3Rlc01CUiwKICAgIC8vICAgdm90ZWxpc3Q6IFZvdGVsaXN0TUJSLAogICAgLy8gICByZWFjdGlvbnM6IFJlYWN0aW9uc01CUiwKICAgIC8vICAgcmVhY3Rpb25saXN0OiBSZWFjdGlvbmxpc3RNQlIsCiAgICAvLyAgIG1ldGE6IE1ldGFNQlIsCiAgICAvLyAgIG1vZGVyYXRvcnM6IE1vZGVyYXRvcnNNQlIsCiAgICAvLyAgIGJhbm5lZDogQmFubmVkTUJSLAogICAgLy8gICBhY3Rpb25zOiBBY3Rpb25zTUJSCiAgICAvLyB9CiAgICBpdG9iCiAgICBjb25jYXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czo6QmFzZVNvY2lhbC5jaGVja1RpcE1iclJlcXVpcmVtZW50cyhha2l0YURBTzogdWludDY0LCBjcmVhdG9yOiBieXRlcywgd2FsbGV0OiB1aW50NjQpIC0+IGJ5dGVzOgpzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6OkJhc2VTb2NpYWwuY2hlY2tUaXBNYnJSZXF1aXJlbWVudHM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6NTEKICAgIC8vIGNoZWNrVGlwTWJyUmVxdWlyZW1lbnRzKGFraXRhREFPOiBBcHBsaWNhdGlvbiwgY3JlYXRvcjogQWNjb3VudCwgd2FsbGV0OiBBcHBsaWNhdGlvbik6IHRpcE1CUkluZm8gewogICAgcHJvdG8gMyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjk0CiAgICAvLyBjb25zdCBha2l0YUFzc2V0c0J5dGVzID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBc3NldHMpKVswXQogICAgZnJhbWVfZGlnIC0zCiAgICBieXRlYyA0IC8vICJha2l0YV9hc3NldHMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6NTIKICAgIC8vIGNvbnN0IGFrdGEgPSBBc3NldChnZXRBa2l0YUFzc2V0cyhha2l0YURBTykuYWt0YSkKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjU0CiAgICAvLyBpZiAoIWNyZWF0b3IuaXNPcHRlZEluKGFrdGEpICYmIHdhbGxldC5pZCAhPT0gMCkgewogICAgZnJhbWVfZGlnIC0yCiAgICBzd2FwCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYm56IHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czo6QmFzZVNvY2lhbC5jaGVja1RpcE1iclJlcXVpcmVtZW50c19hZnRlcl9pZl9lbHNlQDUKICAgIGZyYW1lX2RpZyAtMQogICAgYnogc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjpCYXNlU29jaWFsLmNoZWNrVGlwTWJyUmVxdWlyZW1lbnRzX2FmdGVyX2lmX2Vsc2VANQogICAgLy8gc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjM5LTQ4CiAgICAvLyByZXR1cm4gYWJpQ2FsbDx0eXBlb2YgQWJzdHJhY3RlZEFjY291bnQucHJvdG90eXBlLmFyYzU4X2NhbkNhbGw+KHsKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBnZXRQbHVnaW5BcHBMaXN0KGFraXRhREFPKS5vcHRpbiwKICAgIC8vICAgICB0cnVlLAogICAgLy8gICAgIEdsb2JhbC56ZXJvQWRkcmVzcywKICAgIC8vICAgICAnJywKICAgIC8vICAgICBtZXRob2RTZWxlY3Rvcjx0eXBlb2YgT3B0SW5QbHVnaW4ucHJvdG90eXBlLm9wdEluPigpCiAgICAvLyAgIF0KICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjUwCiAgICAvLyBjb25zdCBbcGx1Z2luQXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1BsdWdpbkFwcExpc3QpKQogICAgZnJhbWVfZGlnIC0zCiAgICBwdXNoYnl0ZXMgInBhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czo0MgogICAgLy8gZ2V0UGx1Z2luQXBwTGlzdChha2l0YURBTykub3B0aW4sCiAgICBleHRyYWN0IDAgOAogICAgLy8gc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjQ0CiAgICAvLyBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czozOS00OAogICAgLy8gcmV0dXJuIGFiaUNhbGw8dHlwZW9mIEFic3RyYWN0ZWRBY2NvdW50LnByb3RvdHlwZS5hcmM1OF9jYW5DYWxsPih7CiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgZ2V0UGx1Z2luQXBwTGlzdChha2l0YURBTykub3B0aW4sCiAgICAvLyAgICAgdHJ1ZSwKICAgIC8vICAgICBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICAvLyAgICAgJycsCiAgICAvLyAgICAgbWV0aG9kU2VsZWN0b3I8dHlwZW9mIE9wdEluUGx1Z2luLnByb3RvdHlwZS5vcHRJbj4oKQogICAgLy8gICBdCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgcHVzaGJ5dGVzIDB4NDcyN2FmMjEgLy8gbWV0aG9kICJhcmM1OF9jYW5DYWxsKHVpbnQ2NCxib29sLGFkZHJlc3Msc3RyaW5nLGJ5dGVbNF0pYm9vbCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgLy8gc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjQzCiAgICAvLyB0cnVlLAogICAgcHVzaGJ5dGVzIDB4ODAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgLy8gc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjQ1CiAgICAvLyAnJywKICAgIHB1c2hieXRlcyAweDAwMDAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICAvLyBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6NDYKICAgIC8vIG1ldGhvZFNlbGVjdG9yPHR5cGVvZiBPcHRJblBsdWdpbi5wcm90b3R5cGUub3B0SW4+KCkKICAgIHB1c2hieXRlcyAweDY4MzVlM2JjIC8vIG1ldGhvZCAib3B0SW4odWludDY0LGJvb2wsdWludDY0W10scGF5KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czozOS00OAogICAgLy8gcmV0dXJuIGFiaUNhbGw8dHlwZW9mIEFic3RyYWN0ZWRBY2NvdW50LnByb3RvdHlwZS5hcmM1OF9jYW5DYWxsPih7CiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgZ2V0UGx1Z2luQXBwTGlzdChha2l0YURBTykub3B0aW4sCiAgICAvLyAgICAgdHJ1ZSwKICAgIC8vICAgICBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICAvLyAgICAgJycsCiAgICAvLyAgICAgbWV0aG9kU2VsZWN0b3I8dHlwZW9mIE9wdEluUGx1Z2luLnByb3RvdHlwZS5vcHRJbj4oKQogICAgLy8gICBdCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzMgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBCeXRlcyBoYXMgdmFsaWQgcHJlZml4CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6NTYKICAgIC8vIGlmIChjYW5DYWxsQXJjNThPcHRJbikgewogICAgYnogc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjpCYXNlU29jaWFsLmNoZWNrVGlwTWJyUmVxdWlyZW1lbnRzX2FmdGVyX2lmX2Vsc2VANQogICAgLy8gc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjU5CiAgICAvLyBhcmM1ODogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICBnbG9iYWwgQXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zb2NpYWwvYmFzZS50czo1Ny02MAogICAgLy8gcmV0dXJuIHsKICAgIC8vICAgdHlwZTogVGlwU2VuZFR5cGVBUkM1OCwKICAgIC8vICAgYXJjNTg6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZQogICAgLy8gfQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjU4CiAgICAvLyB0eXBlOiBUaXBTZW5kVHlwZUFSQzU4LAogICAgYnl0ZWMgNiAvLyAweDE0CiAgICAvLyBzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6NTctNjAKICAgIC8vIHJldHVybiB7CiAgICAvLyAgIHR5cGU6IFRpcFNlbmRUeXBlQVJDNTgsCiAgICAvLyAgIGFyYzU4OiBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIC8vIH0KICAgIHN3YXAKICAgIGNvbmNhdAogICAgcmV0c3ViCgpzbWFydF9jb250cmFjdHMvc29jaWFsL2Jhc2UudHM6OkJhc2VTb2NpYWwuY2hlY2tUaXBNYnJSZXF1aXJlbWVudHNfYWZ0ZXJfaWZfZWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3NvY2lhbC9iYXNlLnRzOjY0LTY3CiAgICAvLyByZXR1cm4gewogICAgLy8gICB0eXBlOiBUaXBTZW5kVHlwZURpcmVjdCwKICAgIC8vICAgYXJjNTg6IDAKICAgIC8vIH0KICAgIHB1c2hieXRlcyAweDBhMDAwMDAwMDAwMDAwMDAwMAogICAgcmV0c3ViCg==", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyAEAAEIBiYNCWFraXRhX2RhbwNzYWwQc3BlbmRpbmdfYWRkcmVzcwQVH3x1DGFraXRhX2Fzc2V0cwtzb2NpYWxfZmVlcwEUA2FhbARDkiZVAQoEmEuu9QTxNgDRBHOepwsxGRREMRhBAOOCHwQWWcGnBEp+tU0EyvjnEwTBmEWdBFtF42sEZrcpYgR1rkCkBOxbzrEENcbjlgRfqjqDBH/UyrcEP9hfTQS0ZUn6BJwwrO0EvshsNASfWalwBKp2VgEEkJHcpQRJPpCPBA2LZ3EEGy0I4gRo6Nt4BCVJgikEXPfgpQSqKQSLBHYj7zMEM+kslASFTe3gBJLm3TsEoTSieAQ0QXXwNhoAjh8AkAFzAioD2AVJBsQIAQkqCloL/Q1iDbwOhQ7sDzoPoQ/vEFgQpxEcEWsRuhIJEn4SzBOAFAkAARQsFEYUdQAjQ4AEiMlA+DYaAI4BAE4AigEBi/+AEmNvbnRyb2xsZWRfYWRkcmVzc2VIi/8qZUiL/4AIcmVmZXJyZXJlSIv/cghETwNQTwJQTFCJigIBi/5AAAMyA4mL/3IIRIk2GgFJIlmBAghLARUSRFcCADYaAkkVJBJEFzYaAxUkEkSAB3ZlcnNpb25PAmcoTGcjQzYaAUkVJBJEFzYaAkkVIxJEIlM2GgNJFSQSRDYaBEkVgRgSRDYaBUkVgSQSRDYaBkkVJBJENhoHSRUjEkQ2GghJFSQSREsHKmVITCIoZUQpZUgiW0sFiBU4SYEQW0sBgRhbTwKBIFtOAggISwFyCEQiKGVESScEZUgiW0wnBWVIIltLBHIIRLFPBLIITwOyB0sFsgAjshAisgG2shSyErIRSwKyAIEEshAisgG2TwhPCYj/CYAEcQW7rbIaTwiyGk8HshpPBrIaTwWyGk8EshpPArIasiCyGLIAJbIQIrIBsyNDNhoBSRUkEkQXNhoCSRUjEkQiUzYaA0kVgSQSRDYaBEkVgSASREsDKmVITCIoZUQpZUgiW0sDiBR1SYEQW0sBgRhbTwKBIFtOAggIgZBnCEsBcghEIihlREknBGVIIltMJwVlSCJbSwRyCESxTwSyCE8DsgdLBbIAI7IQIrIBtrIUshKyEUsCsgCBBLIQIrIBtk8ETwWI/kKABLpL95SyGk8EshpPArIasiCyGLIAJbIQIrIBsyNDIjYaAUkVJBJEF0k2GgJJFSMSRCJTTDYaA0lOAhUkEkQ2GgRJTgIVgRgSRDYaBUlOAkkVgSQSRDYaBklOA0kiWYECCEsBFRJEVwIANhoHSU4ESRUjEkQ2GghJTgUVJBJENhoJTgQ2GgpJTgUVIxJENhoLSU4FFSQSRE8DiP1pSVcgIE4EV0AgSU4EIihlREknB2VIgShbTgUpZUgiW04ETwOIE1NJgRBbSwGBGFtPAoEgW04CCAhOA0sCFYEgEkRPAogRq0kiU0sBVwEgTgJLAYEhW04CTFcpCExAAA0ir4gTFYEQW0sECEUEIihlREsDSwOIE1JJRRVXAAEnBhJBAAlLEyNbSwQIRQRLBElyCEQiKGVESScEZUgiW0wnBWVIJFtLA3IIRLFLCLIITwOyB0sKSbIAI7IQIrIBtk8CshJPArIRTLIUSbIAgQSyECKyAbYnCLIaSwmyGksCshpLDLIaSweyGEmyACWyECKyAbZLE0sViPysgATVyOe4shpLE7IaSxKyGksRshpLELIaSw+yGksOshpLDLIaSwuyGrIgsgCyGCWyECKyAbMjQyI2GgFJFSQSRBdJNhoCSRUjEkQiU0w2GgNJTgIVJBJENhoESU4CFYEYEkQ2GgVJTgJJFYEkEkQ2GgZJTgNJIlmBAghLARUSRFcCADYaB0lOBEkVIxJENhoISU4FFSQSRDYaCUlOBRUjEkQ2GgpJTgUVJBJETwMqZUhJTgQiKGVEKWVIIltOBE8DiBG9SYEQW0sBgRhbTwKBIFtOAggITgNLAhWBIBJETwKIEBVJIlNLAVcBIE4CTIEhW0xAAA0ir4gRhoEQW0sDCEUDIihlREsCSwKIEcNJRRFXAAEnBhJBAAlLDyNbSwMIRQNLA0lyCEQiKGVESScEZUgiW0wnBWVIJFtLA3IIRLFLB7IITwOyB0sISbIAI7IQIrIBtk8CshJPArIRTLIUSbIAgQSyECKyAbZLD0sRiPs7gAQv/DEjshpLD7IaSw6yGksNshpLDLIaSwuyGksKshpLCbIaSwiyGrIgsgCyGCWyECKyAbMjQzYaAUkVJBJEF0k2GgJJFSMSRCJTTDYaA0lOAkkVgSQSRDYaBElOA0kVgSASRDYaBU4DTwKI+pFJVyAgTgNXQCBJTgJOAyIoZURJJwdlSIEoW04EKWVIIltJTgRPA4gQeEmBEFtLAYEYW08CgSBbTgIICE4DsScKshqyGLIaSbIAJbIQIrIBs7Q+SVcEAExXAAQrEkRJgTtZSwEVUlcCAEkVIksBDyJLAk8CTYEgSwIPgSBPA08CTVJJFYEgEkQnCU4CiA6LSVcBIEsBgSFbTwJXKQhOAyIoZUROAogQSklOAlcAAScGEkEABUsBI1sISwNJcghEIihlREknBGVIIltMJwVlSCRbSwNyCESxTwWyCE8DsgdLCEmyACOyECKyAbZPArISTwKyEUyyFEmyAIEEshAisgG2JwiyGksHshpLA7IaSwiyGksFshhJsgAlshAisgG2SwtLDYj5qIAEcnJPlrIaSwuyGksKshqyILIAshglshAisgGzI0M2GgFJFSQSRBdJNhoCSRUjEkQiU0w2GgNJTgJJFYEkEkQ2GgRJTgNJFYEgEkRPAiplSElOAk4DIihlRCllSCJbSU4ETwOIDxVJgRBbSwGBGFtPAoEgW04CCAhOA7EnCrIashiyGkmyACWyECKyAbO0PklXBABMVwAEKxJESYE7WUsBFVJXAgBJFSJLAQ8iSwJPAk2BIEsCD4EgTwNPAk1SSRWBIBJEJwlOAogNKElXASBMgSFbIihlRE4CiA7vSU4CVwABJwYSQQAFSwEjWwhLAklyCEQiKGVESScEZUgiW0wnBWVIJFtLA3IIRLFPBbIITwOyB0sGSbIAI7IQIrIBtk8CshJPArIRTLIUSbIAgQSyECKyAbZLB0sJiPhrgAQcmf6eshpLB7IaSwayGrIgsgCyGCWyECKyAbMjQyKAADYaAUkVJBJEF0k2GgJJFSMSRCJTTDYaA0lOAkkiWYECCEsBFRJEVwIANhoESU4DSRUjEkQ2GgVJTgRJFSMSRCJTTgNPAiplSElOAyIoZUQpZUgiW04DIq+IDcJJgSBbTgSBEFtOBEsCFYEgEkRPAogMI0kiU0sBVwEgTgNMgSFbTgJBAJlFDEsFQQAgIihlREsCSwKIDdZJRQ5XAAEnBhJBAAlLDCNbSwwIRQxLA0lyCEQiKGVESScEZUgiW0wnBWVIJFtLA3IIRLFLELIITwOyB0sISbIAI7IQIrIBtk8CshJPArIRTLIUSbIAgQSyECKyAbZLC0sNiPdOgAQC6SYxshpLC7IaSwqyGksJshqyILIAshglshAisgGzI0NLAwhFDEL/YSKAADYaAUkVJBJEF0k2GgJJFSMSRCJTTDYaA0lOAkkVgSASRDYaBElOA0kVIxJEIlNPAiplSElOAyIoZURJKWVIIltJTgWxgASeF0u2shpLArIaTwSyGkmyGE8CsgAlshAisgGztD5JVwQATFcABCsSREkVgQkSRIFAU04DSXIITE4ERCJOA0wnBGVIIltOAnIITE4CRCJMQQBBIihlRCcFZUgkW0UNSwVAACwnCUsISwuICrpJVwEgTIEhWyIoZUROAogMgUlFD1cAAScGEkEABksNI1tFBEsMRQGxSwOyCEsEsgdLB0myACOyECKyAbZLAbISSwOyEUsCshRJsgCBBLIQIrIBtksLSw2I9hSABIT6S16yGksLshpLCrIasiBLB7IYsgAlshAisgGzI0MiRwKAAEk2GgFJFSQSRBdJNhoCSRUjEkQiU0w2GgNJTgJJIlmBAghLARUSRFcCAElOAjYaBElOAxUjEkQ2GgVJTgNJFSQSRDYaBk4DTwKI9WZJVyAgTgNXQCBJTgMiKGVESScHZUiBKFtOBCllSCJbSU4EsUsDFYEgEkQnC7IaTwOyGk8CshqyGLIAJbIQIrIBs7Q+SVcEAExXAAQrEkRJFSMSRCJTIq+ICxxJgShbTgJJgTBbTgKBEFtOAkEA3EUOSwhLBUsLiAl1SSJTSwFXASBFE0sBgSFbRRFMVykIRRNAAAdLDUsBCEUOIihlREsRSxCICyFJRRFXAAEnBhJBAAlLDyNbSw4IRQ5LAklyCEQiKGVESScEZUgiW0wnBWVIJFtLA3IIRLFLErIITwOyB0sISbIAI7IQIrIBtk8CshJPArIRTLIUSbIAgQSyECKyAbYnCLIaSweyGksTshpLCLIaSwWyGEmyACWyECKyAbZLDUsPiPR7gARufULCshpLDbIaSwuyGksKshqyILIAshglshAisgGzI0NLAghFDkL/HiJJgABJNhoBSRUkEkQXSTYaAkkVIxJEIlNMNhoDSU4CSSJZgQIISwEVEkRXAgBJTgI2GgRJTgMVIxJENhoFSU4DSRUkEkRPAiplSElOAyIoZUQpZUgiW0lOBLFLAxWBIBJEJwuyGk8DshpPArIashiyACWyECKyAbO0PklXBABMVwAEKxJESRUjEkQiUyKviAmSSYEoW04CSYEwW04CgRBbTgJBALdFC0sFSwRLCIgH60kiU0sBVwEgRRBMgSFbRQ1AAAdLCksBCEULIihlREsOSw2ICZ5JRQ5XAAEnBhJBAAlLDCNbSwsIRQtLAklyCEQiKGVESScEZUgiW0wnBWVIJFtLA3IIRLFLD7IITwOyB0sHSbIAI7IQIrIBtk8CshJPArIRTLIUSbIAgQSyECKyAbZLCksMiPMWgATQ5bGNshpLCrIaSwiyGksHshqyILIAshglshAisgGzI0NLAghFC0L/QzYaAUkVJBJEFzYaAkkVIxJEIlM2GgNJFYEgEkQ2GgRJFSQSREsDKmVITCIoZUQpZUgiW7FPBE8FiPKwgARuW3cCshpPBLIaTwKyGrIgshiyACWyECKyAbMjQzYaAUkVJBJEFzYaAkkVIxJEIlM2GgNJFYEgEkQ2GgRLA4jyMUlXICBMV0AgIihlREknB2VIgShbTCllSEkiW0wkW7EnDLIaSwayGkyyGEsCsgAlshAisgGztD5JVwQASwFXAAQrEkQVgUoSRFc2CEsBcghEIq+IB+wiW7GyCLIHSwOyACOyECKyAbYnCLIaTwSyGrIaTwOyGkyyGEsBsgAlshAisgG2TwNPBIjx44AEhmdUlLIaTwOyGrIgshiyACWyECKyAbMjQzYaAUkVJBJEFzYaAkkVIxJEIlM2GgNJFYEgEkRLAiplSCIoZUQpZUgkW0lyCEQir4gHaSJbsbIIsgdLAbIAI7IQIrIBtk8DTwSI8XyABEtvkH+yGk8DshqyILIYsgAlshAisgGzI0M2GgFJFSQSRBc2GgJJFSMSRCJTNhoDSRWBIBJESwIqZUhMIihlRCllSCRbsU8DTwSI8S6ABBYbOnqyGk8CshqyILIYsgAlshAisgGzI0M2GgFJFSQSRBc2GgJJFSMSRCJTNhoDSRWBIBJESwIqZUgiKGVEKWVIJFtJcghEIq+IBrQkW7GyCLIHSwGyACOyECKyAbZPA08EiPDHgAS1nIpUshpPA7IasiCyGLIAJbIQIrIBsyNDNhoBSRUkEkQXNhoCSRUjEkQiUzYaA0kVgSASREsCKmVITCIoZUQpZUgkW7FPA08EiPB5gASu67N4shpPArIasiCyGLIAJbIQIrIBsyNDNhoBSRUkEkQXNhoCSRUjEkQiUzYaA0kVgSASREsCKmVIIihlRCllSIEYW0lyCEQir4gF/oFAW7GyCLIHSwGyACOyECKyAbZPA08EiPAQgAR3ZiyOshpPA7IasiCyGLIAJbIQIrIBsyNDNhoBSRUkEkQXNhoCSRUjEkQiUzYaA0kVgSASREsCKmVITCIoZUQpZUiBGFuxTwNPBIjvwYAEA+OrIrIaTwKyGrIgshiyACWyECKyAbMjQzYaAUkVJBJEFzYaAkkVIxJEIlM2GgNJFYEgEkQ2GgRJFSQSREsDKmVIIihlRCllSIEYW0lyCEQir4gFPoFIW7GyCLIHSwGyACOyECKyAbZPBE8FiO9QgASOvBm1shpPBLIaTwOyGrIgshiyACWyECKyAbMjQzYaAUkVJBJEFzYaAkkVIxJEIlM2GgNJFYEgEkRLAiplSEwiKGVEKWVIgRhbsU8DTwSI7v2ABGHc0u+yGk8CshqyILIYsgAlshAisgGzI0M2GgFJFSQSRBc2GgJJFSMSRCJTNhoDSRWBIBJESwIqZUhMIihlRCllSIEYW7FPA08EiO6ugAR5YOp2shpPArIasiCyGLIAJbIQIrIBsyNDNhoBSRUkEkQXNhoCSRUjEkQiUzYaA0kVgSASREsCKmVITCIoZUQpZUiBGFuxTwNPBIjuX4AEoNIyHbIaTwKyGrIgshiyACWyECKyAbMjQzYaAUkVJBJEFzYaAkkVIxJEIlM2GgNJFSQSRDYaBEkVgSQSREsDKmVIIihlRCllSIEYW0lyCEQir4gD3IFQW7GyCLIHSwGyACOyECKyAbZPBE8FiO3ugATZBnG2shpPBLIaTwOyGrIgshiyACWyECKyAbMjQzYaAUkVJBJEFzYaAkkVIxJEIlM2GgNJFSQSREsCKmVITCIoZUQpZUiBGFuxTwNPBIjtnIAE8Ukr9LIaTwKyGrIgshiyACWyECKyAbMjQzYaAUkVJBJEFzYaAkkVIxJEIlM2GgNJFYEgEkQ2GgRJFSMSRDYaBUkVJBJENhoGSRUkEkQ2GgdJFSQSREsGKmVIIihlRCllSCJbsUlyCEQir4gDAYE4W4HU9wEIsgiyB0sBsgAjshAisgG2TwdPCIjtD4AEhWQz6rIaTweyGk8GshpPBbIaTwSyGk8DshqyILIYsgAlshAisgGztwE+SVcEAExXAAQrEkRJFSQSRCtMULAjQzYaAUkVJBJEFzYaAkkVIxJEIlM2GgNJFSQSRDYaBEkVJBJENhoFSRUkEkQ2GgZJFSQSRDYaB0kVJBJENhoISRUkEkRLByplSEwiKGVEKWVIIluxTwhPCYjsc4AEaaTvl7IaTwiyGk8HshpPBrIaTwWyGk8EshpPArIasiCyGLIAJbIQIrIBsyNDNhoBSRUkEkQXMQAiKGVEgAZ3YWxsZXRlSHIIRBJEKExnI0M2GgFJIlmBAghLARUSRFcCAIgB4StMULAjQzYaAUmBAllLARVLAksCTwJSIllLAiJZTwNMTwNSIlkIgZA1C4HQKAgWK0xQsCNDNhoBSRUkEkQXNhoCSRWBIBJENhoDSRUkEkQXiAHeK0xQsCNDigMBgAAiKGVEKWVIIlsyAyKL/ScJEklBATKLBIwAiwBBALyxi/8VgSASRCcKshqL/7IaiwGyGIv+sgAlshAisgGztD5JVwAEKxJESVcEIIwCgSxbjAOxgATm5nvcshqLArIaiwGyGIv+sgAlshAisgGztD5JVwQATFcABCsSREkVIxJEIlNAABSAAQAiiwBUiwJQIhZQiwMWUIwAibEnDLIaiwJJshqLAbIYi/6yACWyECKyAbO0PklXBABLAVcABCsSRBWBShJEVwUIgAEAIosAVE8CUExQiwMWUIwAiYv9gAEeEkEAB4v/jAJC/2eL/ScGEkEAJov/FSJLAQ8iSwJPAk0kSwIPJE8DTwJNi/9OAlIXcQtMjAJEQv85i/2AASgSQf8wi/8VIksBDyJLAk8CTSRLAg8kTwNPAk2L/04CUhdyB0yMAkRC/wqxi/8VgSASRIAEwCK+ibIai/+yGosBshiL/rIAJbIQIrIBs7Q+SVcEAExXAAQrEkRJFSMSRCJTjABC/paKAQGL/xWBkAMLgaS5AggWgBAAAAAAAAB71AAAAAAAAD1UTFCB5JYBFkxLAVBMUIHUrAEWUIHUkwEWTEsBUIH04QIWUEsBUExQgYToARZQiYoDAYv9JwRlSCJbi/5McABFAUAAXov/QQBZsYv9gANwYWxlSFcACDIDgARHJ68hshpMshqAAYCyGrIagAIAALIagARoNeO8shqL/7IYJbIQIrIBs7Q+SVcEAExXAAQrEkRJFSMSRCJTQQAIMhAWJwZMUImACQoAAAAAAAAAAIk=", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var AkitaSocialPluginParamsFactory = class _AkitaSocialPluginParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "create":
          case "create(string,uint64,uint64)void":
            return _AkitaSocialPluginParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs create ABI call params for the AkitaSocialPlugin smart contract using the create(string,uint64,uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params) {
        return {
          ...params,
          method: "create(string,uint64,uint64)void",
          args: Array.isArray(params.args) ? params.args : [params.args.version, params.args.akitaDao, params.args.escrow]
        };
      }
    };
  }
  /**
   * Constructs a no op call for the post(uint64,bool,uint64,byte[24],byte[36],uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static post(params) {
    return {
      ...params,
      method: "post(uint64,bool,uint64,byte[24],byte[36],uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.timestamp, params.args.nonce, params.args.cid, params.args.gateId, params.args.usePayWall, params.args.payWallId]
    };
  }
  /**
   * Constructs a no op call for the editPost(uint64,bool,byte[36],byte[32])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static editPost(params) {
    return {
      ...params,
      method: "editPost(uint64,bool,byte[36],byte[32])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.cid, params.args.amendment]
    };
  }
  /**
   * Constructs a no op call for the gatedReply(uint64,bool,uint64,byte[24],byte[36],byte[],uint8,uint64,byte[][],bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static gatedReply(params) {
    return {
      ...params,
      method: "gatedReply(uint64,bool,uint64,byte[24],byte[36],byte[],uint8,uint64,byte[][],bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.timestamp, params.args.nonce, params.args.cid, params.args.ref, params.args.type, params.args.gateId, params.args.args, params.args.usePayWall, params.args.payWallId]
    };
  }
  /**
   * Constructs a no op call for the reply(uint64,bool,uint64,byte[24],byte[36],byte[],uint8,uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static reply(params) {
    return {
      ...params,
      method: "reply(uint64,bool,uint64,byte[24],byte[36],byte[],uint8,uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.timestamp, params.args.nonce, params.args.cid, params.args.ref, params.args.type, params.args.gateId, params.args.usePayWall, params.args.payWallId]
    };
  }
  /**
   * Constructs a no op call for the gatedEditReply(uint64,bool,byte[36],byte[32],byte[][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static gatedEditReply(params) {
    return {
      ...params,
      method: "gatedEditReply(uint64,bool,byte[36],byte[32],byte[][])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.cid, params.args.amendment, params.args.args]
    };
  }
  /**
   * Constructs a no op call for the editReply(uint64,bool,byte[36],byte[32])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static editReply(params) {
    return {
      ...params,
      method: "editReply(uint64,bool,byte[36],byte[32])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.cid, params.args.amendment]
    };
  }
  /**
   * Constructs a no op call for the vote(uint64,bool,byte[],uint8,bool)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static vote(params) {
    return {
      ...params,
      method: "vote(uint64,bool,byte[],uint8,bool)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.ref, params.args.type, params.args.isUp]
    };
  }
  /**
   * Constructs a no op call for the editVote(uint64,bool,byte[32],bool)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static editVote(params) {
    return {
      ...params,
      method: "editVote(uint64,bool,byte[32],bool)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.ref, params.args.flip]
    };
  }
  /**
   * Constructs a no op call for the gatedReact(uint64,bool,byte[],uint8,uint64,byte[][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static gatedReact(params) {
    return {
      ...params,
      method: "gatedReact(uint64,bool,byte[],uint8,uint64,byte[][])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.ref, params.args.type, params.args.nft, params.args.args]
    };
  }
  /**
   * Constructs a no op call for the react(uint64,bool,byte[],uint8,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static react(params) {
    return {
      ...params,
      method: "react(uint64,bool,byte[],uint8,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.ref, params.args.type, params.args.nft]
    };
  }
  /**
   * Constructs a no op call for the deleteReaction(uint64,bool,byte[32],uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static deleteReaction(params) {
    return {
      ...params,
      method: "deleteReaction(uint64,bool,byte[32],uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.ref, params.args.nft]
    };
  }
  /**
   * Constructs a no op call for the gatedFollow(uint64,bool,address,byte[][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static gatedFollow(params) {
    return {
      ...params,
      method: "gatedFollow(uint64,bool,address,byte[][])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.address, params.args.args]
    };
  }
  /**
   * Constructs a no op call for the follow(uint64,bool,address)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static follow(params) {
    return {
      ...params,
      method: "follow(uint64,bool,address)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.address]
    };
  }
  /**
   * Constructs a no op call for the unfollow(uint64,bool,address)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static unfollow(params) {
    return {
      ...params,
      method: "unfollow(uint64,bool,address)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.address]
    };
  }
  /**
   * Constructs a no op call for the block(uint64,bool,address)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static block(params) {
    return {
      ...params,
      method: "block(uint64,bool,address)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.address]
    };
  }
  /**
   * Constructs a no op call for the unblock(uint64,bool,address)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static unblock(params) {
    return {
      ...params,
      method: "unblock(uint64,bool,address)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.address]
    };
  }
  /**
   * Constructs a no op call for the addModerator(uint64,bool,address)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static addModerator(params) {
    return {
      ...params,
      method: "addModerator(uint64,bool,address)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.address]
    };
  }
  /**
   * Constructs a no op call for the removeModerator(uint64,bool,address)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static removeModerator(params) {
    return {
      ...params,
      method: "removeModerator(uint64,bool,address)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.address]
    };
  }
  /**
   * Constructs a no op call for the ban(uint64,bool,address,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static ban(params) {
    return {
      ...params,
      method: "ban(uint64,bool,address,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.address, params.args.expiration]
    };
  }
  /**
   * Constructs a no op call for the flagPost(uint64,bool,byte[32])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static flagPost(params) {
    return {
      ...params,
      method: "flagPost(uint64,bool,byte[32])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.ref]
    };
  }
  /**
   * Constructs a no op call for the unflagPost(uint64,bool,byte[32])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static unflagPost(params) {
    return {
      ...params,
      method: "unflagPost(uint64,bool,byte[32])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.ref]
    };
  }
  /**
   * Constructs a no op call for the unban(uint64,bool,address)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static unban(params) {
    return {
      ...params,
      method: "unban(uint64,bool,address)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.address]
    };
  }
  /**
   * Constructs a no op call for the addAction(uint64,bool,uint64,byte[36])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static addAction(params) {
    return {
      ...params,
      method: "addAction(uint64,bool,uint64,byte[36])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.actionAppId, params.args.content]
    };
  }
  /**
   * Constructs a no op call for the removeAction(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static removeAction(params) {
    return {
      ...params,
      method: "removeAction(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.actionAppId]
    };
  }
  /**
   * Constructs a no op call for the initMeta(uint64,bool,address,bool,uint64,uint64,uint64)uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static initMeta(params) {
    return {
      ...params,
      method: "initMeta(uint64,bool,address,bool,uint64,uint64,uint64)uint64",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.user, params.args.automated, params.args.subscriptionIndex, params.args.nfd, params.args.akitaNft]
    };
  }
  /**
   * Constructs a no op call for the updateMeta(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateMeta(params) {
    return {
      ...params,
      method: "updateMeta(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.followGateId, params.args.addressGateId, params.args.subscriptionIndex, params.args.nfd, params.args.akitaNft, params.args.defaultPayWallId]
    };
  }
  /**
   * Constructs a no op call for the updateAkitaDAO(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDao(params) {
    return {
      ...params,
      method: "updateAkitaDAO(uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.akitaDao]
    };
  }
  /**
   * Constructs a no op call for the opUp()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static opUp(params) {
    return {
      ...params,
      method: "opUp()void",
      args: Array.isArray(params.args) ? params.args : []
    };
  }
  /**
   * Constructs a no op call for the mbr(byte[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mbr(params) {
    return {
      ...params,
      method: "mbr(byte[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)",
      args: Array.isArray(params.args) ? params.args : [params.args.ref]
    };
  }
  /**
   * Constructs a no op call for the payWallMbr(((uint8,uint64,uint64)[],(uint8,uint64,uint64)[]))uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static payWallMbr(params) {
    return {
      ...params,
      method: "payWallMbr(((uint8,uint64,uint64)[],(uint8,uint64,uint64)[]))uint64",
      args: Array.isArray(params.args) ? params.args : [params.args.paywall]
    };
  }
  /**
   * Constructs a no op call for the checkTipMbrRequirements(uint64,address,uint64)(uint8,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static checkTipMbrRequirements(params) {
    return {
      ...params,
      method: "checkTipMbrRequirements(uint64,address,uint64)(uint8,uint64)",
      args: Array.isArray(params.args) ? params.args : [params.args.akitaDao, params.args.creator, params.args.wallet]
    };
  }
};
var AkitaSocialPluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `AkitaSocialPluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory20({
      ...params,
      appSpec: APP_SPEC20
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC20;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new AkitaSocialPluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new AkitaSocialPluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the AkitaSocialPlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    var _a;
    const result = await this.appFactory.deploy({
      ...params,
      createParams: ((_a = params.createParams) == null ? void 0 : _a.method) ? AkitaSocialPluginParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams : void 0
    });
    return { result: result.result, appClient: new AkitaSocialPluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the AkitaSocialPlugin smart contract using the create(string,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params) => {
        return this.appFactory.params.create(AkitaSocialPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the AkitaSocialPlugin smart contract using the create(string,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params) => {
        return this.appFactory.createTransaction.create(AkitaSocialPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the AkitaSocialPlugin smart contract using an ABI method call using the create(string,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params) => {
        const result = await this.appFactory.send.create(AkitaSocialPluginParamsFactory.create.create(params));
        return { result: { ...result.result, return: result.result.return }, appClient: new AkitaSocialPluginClient(result.appClient) };
      }
    }
  };
};
var AkitaSocialPluginClient = class _AkitaSocialPluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient20 ? appClientOrParams : new _AppClient20({
      ...appClientOrParams,
      appSpec: APP_SPEC20
    });
  }
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue(method, returnValue) {
    return returnValue !== void 0 ? getArc56ReturnValue13(returnValue, this.appClient.getABIMethod(method), APP_SPEC20.structs) : void 0;
  }
  /**
   * Returns a new `AkitaSocialPluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _AkitaSocialPluginClient(await _AppClient20.fromCreatorAndName({ ...params, appSpec: APP_SPEC20 }));
  }
  /**
   * Returns an `AkitaSocialPluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _AkitaSocialPluginClient(await _AppClient20.fromNetwork({ ...params, appSpec: APP_SPEC20 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the AkitaSocialPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `post(uint64,bool,uint64,byte[24],byte[36],uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    post: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.post(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `editPost(uint64,bool,byte[36],byte[32])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    editPost: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.editPost(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `gatedReply(uint64,bool,uint64,byte[24],byte[36],byte[],uint8,uint64,byte[][],bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    gatedReply: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.gatedReply(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `reply(uint64,bool,uint64,byte[24],byte[36],byte[],uint8,uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    reply: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.reply(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `gatedEditReply(uint64,bool,byte[36],byte[32],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    gatedEditReply: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.gatedEditReply(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `editReply(uint64,bool,byte[36],byte[32])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    editReply: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.editReply(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `vote(uint64,bool,byte[],uint8,bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    vote: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.vote(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `editVote(uint64,bool,byte[32],bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    editVote: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.editVote(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `gatedReact(uint64,bool,byte[],uint8,uint64,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    gatedReact: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.gatedReact(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `react(uint64,bool,byte[],uint8,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    react: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.react(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `deleteReaction(uint64,bool,byte[32],uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    deleteReaction: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.deleteReaction(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `gatedFollow(uint64,bool,address,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    gatedFollow: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.gatedFollow(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `follow(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    follow: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.follow(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `unfollow(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    unfollow: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.unfollow(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `block(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    block: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.block(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `unblock(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    unblock: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.unblock(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `addModerator(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    addModerator: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.addModerator(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `removeModerator(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    removeModerator: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.removeModerator(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `ban(uint64,bool,address,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    ban: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.ban(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `flagPost(uint64,bool,byte[32])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    flagPost: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.flagPost(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `unflagPost(uint64,bool,byte[32])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    unflagPost: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.unflagPost(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `unban(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    unban: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.unban(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `addAction(uint64,bool,uint64,byte[36])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    addAction: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.addAction(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `removeAction(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    removeAction: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.removeAction(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `initMeta(uint64,bool,address,bool,uint64,uint64,uint64)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    initMeta: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.initMeta(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `updateMeta(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateMeta: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.updateMeta(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDao: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.opUp(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `mbr(byte[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    mbr: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.mbr(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `payWallMbr(((uint8,uint64,uint64)[],(uint8,uint64,uint64)[]))uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    payWallMbr: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.payWallMbr(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `checkTipMbrRequirements(uint64,address,uint64)(uint8,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    checkTipMbrRequirements: (params) => {
      return this.appClient.params.call(AkitaSocialPluginParamsFactory.checkTipMbrRequirements(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the AkitaSocialPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `post(uint64,bool,uint64,byte[24],byte[36],uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    post: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.post(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `editPost(uint64,bool,byte[36],byte[32])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    editPost: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.editPost(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `gatedReply(uint64,bool,uint64,byte[24],byte[36],byte[],uint8,uint64,byte[][],bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    gatedReply: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.gatedReply(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `reply(uint64,bool,uint64,byte[24],byte[36],byte[],uint8,uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    reply: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.reply(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `gatedEditReply(uint64,bool,byte[36],byte[32],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    gatedEditReply: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.gatedEditReply(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `editReply(uint64,bool,byte[36],byte[32])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    editReply: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.editReply(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `vote(uint64,bool,byte[],uint8,bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    vote: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.vote(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `editVote(uint64,bool,byte[32],bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    editVote: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.editVote(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `gatedReact(uint64,bool,byte[],uint8,uint64,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    gatedReact: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.gatedReact(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `react(uint64,bool,byte[],uint8,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    react: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.react(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `deleteReaction(uint64,bool,byte[32],uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    deleteReaction: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.deleteReaction(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `gatedFollow(uint64,bool,address,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    gatedFollow: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.gatedFollow(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `follow(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    follow: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.follow(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `unfollow(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    unfollow: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.unfollow(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `block(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    block: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.block(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `unblock(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    unblock: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.unblock(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `addModerator(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    addModerator: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.addModerator(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `removeModerator(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    removeModerator: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.removeModerator(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `ban(uint64,bool,address,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    ban: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.ban(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `flagPost(uint64,bool,byte[32])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    flagPost: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.flagPost(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `unflagPost(uint64,bool,byte[32])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    unflagPost: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.unflagPost(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `unban(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    unban: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.unban(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `addAction(uint64,bool,uint64,byte[36])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    addAction: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.addAction(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `removeAction(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    removeAction: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.removeAction(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `initMeta(uint64,bool,address,bool,uint64,uint64,uint64)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    initMeta: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.initMeta(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `updateMeta(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateMeta: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.updateMeta(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDao: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.opUp(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `mbr(byte[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    mbr: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.mbr(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `payWallMbr(((uint8,uint64,uint64)[],(uint8,uint64,uint64)[]))uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    payWallMbr: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.payWallMbr(params));
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `checkTipMbrRequirements(uint64,address,uint64)(uint8,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    checkTipMbrRequirements: (params) => {
      return this.appClient.createTransaction.call(AkitaSocialPluginParamsFactory.checkTipMbrRequirements(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the AkitaSocialPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `post(uint64,bool,uint64,byte[24],byte[36],uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    post: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.post(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `editPost(uint64,bool,byte[36],byte[32])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    editPost: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.editPost(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `gatedReply(uint64,bool,uint64,byte[24],byte[36],byte[],uint8,uint64,byte[][],bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    gatedReply: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.gatedReply(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `reply(uint64,bool,uint64,byte[24],byte[36],byte[],uint8,uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    reply: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.reply(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `gatedEditReply(uint64,bool,byte[36],byte[32],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    gatedEditReply: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.gatedEditReply(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `editReply(uint64,bool,byte[36],byte[32])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    editReply: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.editReply(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `vote(uint64,bool,byte[],uint8,bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    vote: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.vote(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `editVote(uint64,bool,byte[32],bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    editVote: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.editVote(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `gatedReact(uint64,bool,byte[],uint8,uint64,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    gatedReact: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.gatedReact(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `react(uint64,bool,byte[],uint8,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    react: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.react(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `deleteReaction(uint64,bool,byte[32],uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    deleteReaction: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.deleteReaction(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `gatedFollow(uint64,bool,address,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    gatedFollow: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.gatedFollow(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `follow(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    follow: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.follow(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `unfollow(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    unfollow: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.unfollow(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `block(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    block: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.block(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `unblock(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    unblock: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.unblock(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `addModerator(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    addModerator: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.addModerator(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `removeModerator(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    removeModerator: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.removeModerator(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `ban(uint64,bool,address,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    ban: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.ban(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `flagPost(uint64,bool,byte[32])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    flagPost: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.flagPost(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `unflagPost(uint64,bool,byte[32])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    unflagPost: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.unflagPost(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `unban(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    unban: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.unban(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `addAction(uint64,bool,uint64,byte[36])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    addAction: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.addAction(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `removeAction(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    removeAction: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.removeAction(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `initMeta(uint64,bool,address,bool,uint64,uint64,uint64)uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    initMeta: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.initMeta(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `updateMeta(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateMeta: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.updateMeta(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDao: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.updateAkitaDao(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    opUp: async (params = { args: [] }) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.opUp(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `mbr(byte[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mbr: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.mbr(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `payWallMbr(((uint8,uint64,uint64)[],(uint8,uint64,uint64)[]))uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    payWallMbr: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.payWallMbr(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the AkitaSocialPlugin smart contract using the `checkTipMbrRequirements(uint64,address,uint64)(uint8,uint64)` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    checkTipMbrRequirements: async (params) => {
      const result = await this.appClient.send.call(AkitaSocialPluginParamsFactory.checkTipMbrRequirements(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _AkitaSocialPluginClient(this.appClient.clone(params));
  }
  /**
   * Methods to access state for the current AkitaSocialPlugin app
   */
  state = {
    /**
     * Methods to access global state for the current AkitaSocialPlugin app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async () => {
        const result = await this.appClient.state.global.getAll();
        return {
          version: result.version,
          akitaDao: result.akitaDAO
        };
      },
      /**
       * Get the current value of the version key in global state
       */
      version: async () => {
        return await this.appClient.state.global.getValue("version");
      },
      /**
       * Get the current value of the akitaDAO key in global state
       */
      akitaDao: async () => {
        return await this.appClient.state.global.getValue("akitaDAO");
      }
    }
  };
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a post(uint64,bool,uint64,byte[24],byte[36],uint64,bool,uint64)void method call against the AkitaSocialPlugin contract
       */
      post(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.post(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a editPost(uint64,bool,byte[36],byte[32])void method call against the AkitaSocialPlugin contract
       */
      editPost(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.editPost(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a gatedReply(uint64,bool,uint64,byte[24],byte[36],byte[],uint8,uint64,byte[][],bool,uint64)void method call against the AkitaSocialPlugin contract
       */
      gatedReply(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.gatedReply(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a reply(uint64,bool,uint64,byte[24],byte[36],byte[],uint8,uint64,bool,uint64)void method call against the AkitaSocialPlugin contract
       */
      reply(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.reply(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a gatedEditReply(uint64,bool,byte[36],byte[32],byte[][])void method call against the AkitaSocialPlugin contract
       */
      gatedEditReply(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.gatedEditReply(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a editReply(uint64,bool,byte[36],byte[32])void method call against the AkitaSocialPlugin contract
       */
      editReply(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.editReply(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a vote(uint64,bool,byte[],uint8,bool)void method call against the AkitaSocialPlugin contract
       */
      vote(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.vote(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a editVote(uint64,bool,byte[32],bool)void method call against the AkitaSocialPlugin contract
       */
      editVote(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.editVote(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a gatedReact(uint64,bool,byte[],uint8,uint64,byte[][])void method call against the AkitaSocialPlugin contract
       */
      gatedReact(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.gatedReact(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a react(uint64,bool,byte[],uint8,uint64)void method call against the AkitaSocialPlugin contract
       */
      react(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.react(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a deleteReaction(uint64,bool,byte[32],uint64)void method call against the AkitaSocialPlugin contract
       */
      deleteReaction(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.deleteReaction(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a gatedFollow(uint64,bool,address,byte[][])void method call against the AkitaSocialPlugin contract
       */
      gatedFollow(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.gatedFollow(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a follow(uint64,bool,address)void method call against the AkitaSocialPlugin contract
       */
      follow(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.follow(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a unfollow(uint64,bool,address)void method call against the AkitaSocialPlugin contract
       */
      unfollow(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.unfollow(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a block(uint64,bool,address)void method call against the AkitaSocialPlugin contract
       */
      block(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.block(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a unblock(uint64,bool,address)void method call against the AkitaSocialPlugin contract
       */
      unblock(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.unblock(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a addModerator(uint64,bool,address)void method call against the AkitaSocialPlugin contract
       */
      addModerator(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.addModerator(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a removeModerator(uint64,bool,address)void method call against the AkitaSocialPlugin contract
       */
      removeModerator(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.removeModerator(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a ban(uint64,bool,address,uint64)void method call against the AkitaSocialPlugin contract
       */
      ban(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.ban(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a flagPost(uint64,bool,byte[32])void method call against the AkitaSocialPlugin contract
       */
      flagPost(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.flagPost(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a unflagPost(uint64,bool,byte[32])void method call against the AkitaSocialPlugin contract
       */
      unflagPost(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.unflagPost(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a unban(uint64,bool,address)void method call against the AkitaSocialPlugin contract
       */
      unban(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.unban(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a addAction(uint64,bool,uint64,byte[36])void method call against the AkitaSocialPlugin contract
       */
      addAction(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.addAction(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a removeAction(uint64,bool,uint64)void method call against the AkitaSocialPlugin contract
       */
      removeAction(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.removeAction(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a initMeta(uint64,bool,address,bool,uint64,uint64,uint64)uint64 method call against the AkitaSocialPlugin contract
       */
      initMeta(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.initMeta(params)));
        resultMappers.push((v) => client.decodeReturnValue("initMeta(uint64,bool,address,bool,uint64,uint64,uint64)uint64", v));
        return this;
      },
      /**
       * Add a updateMeta(uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64)void method call against the AkitaSocialPlugin contract
       */
      updateMeta(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateMeta(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a updateAkitaDAO(uint64)void method call against the AkitaSocialPlugin contract
       */
      updateAkitaDao(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDao(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a opUp()void method call against the AkitaSocialPlugin contract
       */
      opUp(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.opUp(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a mbr(byte[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64) method call against the AkitaSocialPlugin contract
       */
      mbr(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mbr(params)));
        resultMappers.push((v) => client.decodeReturnValue("mbr(byte[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)", v));
        return this;
      },
      /**
       * Add a payWallMbr(((uint8,uint64,uint64)[],(uint8,uint64,uint64)[]))uint64 method call against the AkitaSocialPlugin contract
       */
      payWallMbr(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.payWallMbr(params)));
        resultMappers.push((v) => client.decodeReturnValue("payWallMbr(((uint8,uint64,uint64)[],(uint8,uint64,uint64)[]))uint64", v));
        return this;
      },
      /**
       * Add a checkTipMbrRequirements(uint64,address,uint64)(uint8,uint64) method call against the AkitaSocialPlugin contract
       */
      checkTipMbrRequirements(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.checkTipMbrRequirements(params)));
        resultMappers.push((v) => client.decodeReturnValue("checkTipMbrRequirements(uint64,address,uint64)(uint8,uint64)", v));
        return this;
      },
      /**
       * Add a clear state call to the AkitaSocialPlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/social.ts
var SocialPluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: AkitaSocialPluginFactory, ...params });
  }
  post(args) {
    const methodName = "post";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.post({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      },
      // Posting needs opUp transactions for resource reference slots
      opUpCount: 2
    });
  }
  editPost(args) {
    const methodName = "editPost";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.editPost({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  reply(args) {
    const methodName = "reply";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.reply({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      },
      // Reply needs opUp transactions for resource reference slots
      opUpCount: 3
    });
  }
  gatedReply(args) {
    const methodName = "gatedReply";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.gatedReply({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      },
      // GatedReply needs opUp transactions for resource reference slots
      opUpCount: 2
    });
  }
  editReply(args) {
    const methodName = "editReply";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.editReply({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  gatedEditReply(args) {
    const methodName = "gatedEditReply";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.gatedEditReply({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  vote(args) {
    const methodName = "vote";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.vote({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      },
      // Voting needs opUp transactions for resource reference slots
      opUpCount: 2
    });
  }
  editVote(args) {
    const methodName = "editVote";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.editVote({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      },
      // editVote needs opUp transactions for resource reference slots
      opUpCount: 2
    });
  }
  react(args) {
    const methodName = "react";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.react({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      },
      // React needs opUp transactions for resource reference slots
      opUpCount: 2
    });
  }
  gatedReact(args) {
    const methodName = "gatedReact";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.gatedReact({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      },
      // Gated react needs opUp transactions for resource reference slots
      opUpCount: 2
    });
  }
  deleteReaction(args) {
    const methodName = "deleteReaction";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.deleteReaction({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      },
      // Delete reaction needs opUp transactions for resource reference slots
      opUpCount: 2
    });
  }
  follow(args) {
    const methodName = "follow";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.follow({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  gatedFollow(args) {
    const methodName = "gatedFollow";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.gatedFollow({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  unfollow(args) {
    const methodName = "unfollow";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.unfollow({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  block(args) {
    const methodName = "block";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.block({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  unblock(args) {
    const methodName = "unblock";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.unblock({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  addModerator(args) {
    const methodName = "addModerator";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.addModerator({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  removeModerator(args) {
    const methodName = "removeModerator";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.removeModerator({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  ban(args) {
    const methodName = "ban";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.ban({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  unban(args) {
    const methodName = "unban";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.unban({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  flagPost(args) {
    const methodName = "flagPost";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.flagPost({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  unflagPost(args) {
    const methodName = "unflagPost";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.unflagPost({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  addAction(args) {
    const methodName = "addAction";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.addAction({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  removeAction(args) {
    const methodName = "removeAction";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.removeAction({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  initMeta(args) {
    const methodName = "initMeta";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.initMeta({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      },
      // initMeta needs opUp transactions for resource reference slots
      opUpCount: 2
    });
  }
  updateMeta(args) {
    const methodName = "updateMeta";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.updateMeta({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
};

// src/generated/StakingPluginClient.ts
import {
  AppClient as _AppClient21
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory21 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC21 = { "name": "StakingPlugin", "structs": {}, "methods": [{ "name": "create", "args": [{ "type": "uint64", "name": "akitaDAO" }, { "type": "string", "name": "version" }], "returns": { "type": "void" }, "actions": { "create": ["NoOp"], "call": [] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "stake", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "assetID" }, { "type": "uint8", "name": "type" }, { "type": "uint64", "name": "amount" }, { "type": "uint64", "name": "expiration" }, { "type": "bool", "name": "isUpdate" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "withdraw", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "asset" }, { "type": "uint8", "name": "type" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "createHeartbeat", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "address", "name": "address" }, { "type": "uint64", "name": "asset" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "softCheck", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "address", "name": "address" }, { "type": "uint64", "name": "asset" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "updateAkitaDAO", "args": [{ "type": "uint64", "name": "akitaDAO" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "opUp", "args": [], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 1, "bytes": 1 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": { "version": { "keyType": "AVMString", "valueType": "AVMString", "key": "dmVyc2lvbg==", "desc": "the current version of the contract" }, "akitaDAO": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "YWtpdGFfZGFv", "desc": "the app ID of the Akita DAO" } }, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": [], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [815], "errorMessage": "Bytes has valid prefix" }, { "pc": [46], "errorMessage": "OnCompletion must be NoOp" }, { "pc": [850], "errorMessage": "Only the Akita DAO can call this function" }, { "pc": [133, 327, 393, 417, 848], "errorMessage": "application exists" }, { "pc": [266, 576, 666, 756, 835], "errorMessage": "check GlobalState exists" }, { "pc": [820], "errorMessage": "invalid number of bytes for (bool1,uint64)" }, { "pc": [157], "errorMessage": "invalid number of bytes for (len+utf8[])" }, { "pc": [197, 253, 547, 636, 726], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [142, 187, 208, 232, 245, 538, 557, 627, 655, 717, 745, 828], "errorMessage": "invalid number of bytes for uint64" }, { "pc": [221, 565], "errorMessage": "invalid number of bytes for uint8" }, { "pc": [647, 737], "errorMessage": "invalid number of bytes for uint8[32]" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDggNiAyODkwMAogICAgYnl0ZWNibG9jayAiYWtpdGFfZGFvIiAic3BlbmRpbmdfYWRkcmVzcyIgImFhbCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxMgogICAgLy8gZXhwb3J0IGNsYXNzIFN0YWtpbmdQbHVnaW4gZXh0ZW5kcyBjbGFzc2VzKEJhc2VTdGFraW5nLCBBa2l0YUJhc2VDb250cmFjdCkgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBieiBtYWluX2NyZWF0ZV9Ob09wQDEyCiAgICBwdXNoYnl0ZXNzIDB4YmI5ZDg3NDkgMHgyYTc4ZTJlZSAweGI2ZmM3NmNmIDB4ZmRiZjg5NjAgMHgzM2U5MmM5NCAweDg1NGRlZGUwIC8vIG1ldGhvZCAic3Rha2UodWludDY0LGJvb2wsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQsYm9vbCl2b2lkIiwgbWV0aG9kICJ3aXRoZHJhdyh1aW50NjQsYm9vbCx1aW50NjQsdWludDgpdm9pZCIsIG1ldGhvZCAiY3JlYXRlSGVhcnRiZWF0KHVpbnQ2NCxib29sLGFkZHJlc3MsdWludDY0KXZvaWQiLCBtZXRob2QgInNvZnRDaGVjayh1aW50NjQsYm9vbCxhZGRyZXNzLHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJ1cGRhdGVBa2l0YURBTyh1aW50NjQpdm9pZCIsIG1ldGhvZCAib3BVcCgpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIHN0YWtlIHdpdGhkcmF3IGNyZWF0ZUhlYXJ0YmVhdCBzb2Z0Q2hlY2sgdXBkYXRlQWtpdGFEQU8gbWFpbl9vcFVwX3JvdXRlQDEwCiAgICBlcnIKCm1haW5fb3BVcF9yb3V0ZUAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjQzCiAgICAvLyBvcFVwKCk6IHZvaWQgeyB9CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2NyZWF0ZV9Ob09wQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEyCiAgICAvLyBleHBvcnQgY2xhc3MgU3Rha2luZ1BsdWdpbiBleHRlbmRzIGNsYXNzZXMoQmFzZVN0YWtpbmcsIEFraXRhQmFzZUNvbnRyYWN0KSB7CiAgICBwdXNoYnl0ZXMgMHg2Zjk4MTdmNiAvLyBtZXRob2QgImNyZWF0ZSh1aW50NjQsc3RyaW5nKXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBjcmVhdGUKICAgIGVycgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OnJla2V5QWRkcmVzcyhyZWtleUJhY2s6IHVpbnQ2NCwgd2FsbGV0OiB1aW50NjQpIC0+IGJ5dGVzOgpyZWtleUFkZHJlc3M6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMQogICAgLy8gZXhwb3J0IGZ1bmN0aW9uIHJla2V5QWRkcmVzcyhyZWtleUJhY2s6IGJvb2xlYW4sIHdhbGxldDogQXBwbGljYXRpb24pOiBBY2NvdW50IHsKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjIKICAgIC8vIGlmICghcmVrZXlCYWNrKSB7CiAgICBmcmFtZV9kaWcgLTIKICAgIGJueiByZWtleUFkZHJlc3NfYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMwogICAgLy8gcmV0dXJuIEdsb2JhbC56ZXJvQWRkcmVzcwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICByZXRzdWIKCnJla2V5QWRkcmVzc19hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyNgogICAgLy8gcmV0dXJuIHdhbGxldC5hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1BsdWdpbi5jcmVhdGVbcm91dGluZ10oKSAtPiB2b2lkOgpjcmVhdGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTYKICAgIC8vIEBhYmltZXRob2QoeyBvbkNyZWF0ZTogJ3JlcXVpcmUnIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyNwogICAgLy8gdmVyc2lvbiA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5VmVyc2lvbiB9KQogICAgcHVzaGJ5dGVzICJ2ZXJzaW9uIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjE4CiAgICAvLyB0aGlzLnZlcnNpb24udmFsdWUgPSB2ZXJzaW9uCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTkKICAgIC8vIHRoaXMuYWtpdGFEQU8udmFsdWUgPSBBcHBsaWNhdGlvbihha2l0YURBTykKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTYKICAgIC8vIEBhYmltZXRob2QoeyBvbkNyZWF0ZTogJ3JlcXVpcmUnIH0pCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUGx1Z2luLnN0YWtlW3JvdXRpbmddKCkgLT4gdm9pZDoKc3Rha2U6CiAgICBwdXNoYnl0ZXMgIiIKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjI0LTMyCiAgICAvLyBzdGFrZSgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhc3NldElEOiB1aW50NjQsCiAgICAvLyAgIHR5cGU6IFN0YWtpbmdUeXBlLAogICAgLy8gICBhbW91bnQ6IHVpbnQ2NCwKICAgIC8vICAgZXhwaXJhdGlvbjogdWludDY0LAogICAgLy8gICBpc1VwZGF0ZTogYm9vbGVhbgogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgc3dhcAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBjb3ZlciAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA2CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzQKICAgIC8vIGNvbnN0IHN0YWtpbmdBcHBJRCA9IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzQKICAgIC8vIGNvbnN0IHN0YWtpbmdBcHBJRCA9IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMiAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjM0CiAgICAvLyBjb25zdCBzdGFraW5nQXBwSUQgPSBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZwogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MzcKICAgIC8vIGNvbnN0IGlzRXNjcm93ID0gdHlwZSA9PT0gU1RBS0lOR19UWVBFX0hBUkQgfHwgdHlwZSA9PT0gU1RBS0lOR19UWVBFX0xPQ0sKICAgIHB1c2hieXRlcyAweDFlCiAgICA9PQogICAgYm56IHN0YWtlX2Jvb2xfdHJ1ZUAzCiAgICBkaWcgNgogICAgcHVzaGJ5dGVzIDB4MjgKICAgID09CiAgICBieiBzdGFrZV9ib29sX2ZhbHNlQDQKCnN0YWtlX2Jvb2xfdHJ1ZUAzOgogICAgaW50Y18xIC8vIDEKICAgIGJ1cnkgMTIKCnN0YWtlX2Jvb2xfbWVyZ2VANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0MgogICAgLy8gbGV0IHNlbmRBbW91bnQ6IHVpbnQ2NCA9IDAKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDExCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDMKICAgIC8vIGlmICghaXNVcGRhdGUpIHsKICAgIGRpZyAyCiAgICBibnogc3Rha2VfZWxzZV9ib2R5QDE0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NDQKICAgIC8vIGlmIChpc0VzY3JvdyAmJiBpc0FsZ28pIHsKICAgIGRpZyAxMQogICAgYnogc3Rha2VfZWxzZV9ib2R5QDkKICAgIGRpZyA3CiAgICBibnogc3Rha2VfZWxzZV9ib2R5QDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0NQogICAgLy8gc2VuZEFtb3VudCA9IGFtb3VudCArIGNvc3RzLnN0YWtlcwogICAgZGlnIDQKICAgIGludGMgNCAvLyAyODkwMAogICAgKwogICAgYnVyeSAxMQoKc3Rha2VfYWZ0ZXJfaWZfZWxzZUAxODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1NQogICAgLy8gaWYgKGlzQWxnbykgewogICAgZGlnIDcKICAgIGJueiBzdGFrZV9lbHNlX2JvZHlAMjIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1Ni03MAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Rha2luZy5wcm90b3R5cGUuc3Rha2U+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogc3Rha2luZ0FwcElELAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiBzdGFraW5nQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IHNlbmRBbW91bnQsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgdHlwZSwKICAgIC8vICAgICBhbW91bnQsCiAgICAvLyAgICAgZXhwaXJhdGlvbiwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjIKICAgIC8vIHJlY2VpdmVyOiBzdGFraW5nQXBwLmFkZHJlc3MsCiAgICBkdXBuIDIKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGRpZyAxMgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGRpZyAyCiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjAtNjQKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IHN0YWtpbmdBcHAuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBzZW5kQW1vdW50LAogICAgLy8gfSksCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NTYtNzAKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN0YWtpbmcucHJvdG90eXBlLnN0YWtlPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHN0YWtpbmdBcHBJRCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogc3Rha2luZ0FwcC5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBzZW5kQW1vdW50LAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIHR5cGUsCiAgICAvLyAgICAgYW1vdW50LAogICAgLy8gICAgIGV4cGlyYXRpb24sCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6NjkKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICBkaWcgMTAKICAgIGRpZyAxMgogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1Ni03MAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Rha2luZy5wcm90b3R5cGUuc3Rha2U+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogc3Rha2luZ0FwcElELAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiBzdGFraW5nQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IHNlbmRBbW91bnQsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgdHlwZSwKICAgIC8vICAgICBhbW91bnQsCiAgICAvLyAgICAgZXhwaXJhdGlvbiwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHg4MjU2Y2YxOSAvLyBtZXRob2QgInN0YWtlKHBheSx1aW50OCx1aW50NjQsdWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDkKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgOAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAoKc3Rha2VfYWZ0ZXJfaWZfZWxzZUAyNjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoyNC0zMgogICAgLy8gc3Rha2UoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXNzZXRJRDogdWludDY0LAogICAgLy8gICB0eXBlOiBTdGFraW5nVHlwZSwKICAgIC8vICAgYW1vdW50OiB1aW50NjQsCiAgICAvLyAgIGV4cGlyYXRpb246IHVpbnQ2NCwKICAgIC8vICAgaXNVcGRhdGU6IGJvb2xlYW4KICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKc3Rha2VfZWxzZV9ib2R5QDIyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjcyLTkyCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdGFraW5nLnByb3RvdHlwZS5zdGFrZUFzYT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBzdGFraW5nQXBwSUQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IHN0YWtpbmdBcHAuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogc2VuZEFtb3VudCwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgYXNzZXRSZWNlaXZlcjogc3Rha2luZ0FwcC5hZGRyZXNzLAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICAgIHhmZXJBc3NldDogYXNzZXRJRCwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICB0eXBlLAogICAgLy8gICAgIGFtb3VudCwKICAgIC8vICAgICBleHBpcmF0aW9uLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo3OAogICAgLy8gcmVjZWl2ZXI6IHN0YWtpbmdBcHAuYWRkcmVzcywKICAgIGR1cG4gMgogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgZGlnIDEyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZGlnIDIKICAgIGR1cAogICAgY292ZXIgMgogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo3Ni04MAogICAgLy8gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogc3Rha2luZ0FwcC5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IHNlbmRBbW91bnQsCiAgICAvLyB9KSwKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo4MS04NgogICAgLy8gaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhc3NldFJlY2VpdmVyOiBzdGFraW5nQXBwLmFkZHJlc3MsCiAgICAvLyAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgIHhmZXJBc3NldDogYXNzZXRJRCwKICAgIC8vIH0pLAogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6ODMKICAgIC8vIGFzc2V0UmVjZWl2ZXI6IHN0YWtpbmdBcHAuYWRkcmVzcywKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgZGlnIDEwCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgZGlnIDcKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6ODEtODYKICAgIC8vIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXNzZXRSZWNlaXZlcjogc3Rha2luZ0FwcC5hZGRyZXNzLAogICAgLy8gICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gICB4ZmVyQXNzZXQ6IGFzc2V0SUQsCiAgICAvLyB9KSwKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo3Mi05MgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Rha2luZy5wcm90b3R5cGUuc3Rha2VBc2E+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogc3Rha2luZ0FwcElELAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiBzdGFraW5nQXBwLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IHNlbmRBbW91bnQsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IHN0YWtpbmdBcHAuYWRkcmVzcywKICAgIC8vICAgICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0SUQsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgdHlwZSwKICAgIC8vICAgICBhbW91bnQsCiAgICAvLyAgICAgZXhwaXJhdGlvbiwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo5MQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIGRpZyAxMAogICAgZGlnIDEyCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjcyLTkyCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdGFraW5nLnByb3RvdHlwZS5zdGFrZUFzYT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBzdGFraW5nQXBwSUQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IHN0YWtpbmdBcHAuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogc2VuZEFtb3VudCwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgYXNzZXRSZWNlaXZlcjogc3Rha2luZ0FwcC5hZGRyZXNzLAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICAgIHhmZXJBc3NldDogYXNzZXRJRCwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICB0eXBlLAogICAgLy8gICAgIGFtb3VudCwKICAgIC8vICAgICBleHBpcmF0aW9uLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDIwNDY3YjkzIC8vIG1ldGhvZCAic3Rha2VBc2EocGF5LGF4ZmVyLHVpbnQ4LHVpbnQ2NCx1aW50NjQpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgOQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA4CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDYKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBiIHN0YWtlX2FmdGVyX2lmX2Vsc2VAMjYKCnN0YWtlX2Vsc2VfYm9keUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ2CiAgICAvLyB9IGVsc2UgaWYgKHR5cGUgPT09IFNUQUtJTkdfVFlQRV9IRUFSVEJFQVQpIHsKICAgIGRpZyA2CiAgICBwdXNoYnl0ZXMgMHgwYQogICAgPT0KICAgIGJ6IHN0YWtlX2Vsc2VfYm9keUAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjQ3CiAgICAvLyBzZW5kQW1vdW50ID0gKGNvc3RzLnN0YWtlcyArIGNvc3RzLmhlYXJ0YmVhdHMpCiAgICBwdXNoaW50IDk5MDAwIC8vIDk5MDAwCiAgICBidXJ5IDExCiAgICBiIHN0YWtlX2FmdGVyX2lmX2Vsc2VAMTgKCnN0YWtlX2Vsc2VfYm9keUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo0OQogICAgLy8gc2VuZEFtb3VudCA9IGNvc3RzLnN0YWtlcwogICAgaW50YyA0IC8vIDI4OTAwCiAgICBidXJ5IDExCiAgICBiIHN0YWtlX2FmdGVyX2lmX2Vsc2VAMTgKCnN0YWtlX2Vsc2VfYm9keUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo1MQogICAgLy8gfSBlbHNlIGlmIChpc0VzY3JvdyAmJiBpc0FsZ28pIHsKICAgIGRpZyAxMQogICAgYnogc3Rha2VfYWZ0ZXJfaWZfZWxzZUAxOAogICAgZGlnIDcKICAgIGJueiBzdGFrZV9hZnRlcl9pZl9lbHNlQDE4CiAgICBkaWcgNAogICAgYnVyeSAxMQogICAgYiBzdGFrZV9hZnRlcl9pZl9lbHNlQDE4CgpzdGFrZV9ib29sX2ZhbHNlQDQ6CiAgICBpbnRjXzAgLy8gMAogICAgYnVyeSAxMgogICAgYiBzdGFrZV9ib29sX21lcmdlQDUKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQbHVnaW4ud2l0aGRyYXdbcm91dGluZ10oKSAtPiB2b2lkOgp3aXRoZHJhdzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo5Ni0xMDEKICAgIC8vIHdpdGhkcmF3KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFzc2V0OiB1aW50NjQsCiAgICAvLyAgIHR5cGU6IFN0YWtpbmdUeXBlCiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEwNC0xMDkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN0YWtpbmcucHJvdG90eXBlLndpdGhkcmF3Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgLy8gICBhcmdzOiBbYXNzZXQsIHR5cGVdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxMDYKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxMDYKICAgIC8vIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQwCiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBieXRlY18yIC8vICJhYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTA2CiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN0YWtpbmcsCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxMDgKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICB1bmNvdmVyIDQKICAgIHVuY292ZXIgNQogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxMDQtMTA5CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdGFraW5nLnByb3RvdHlwZS53aXRoZHJhdz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIC8vICAgYXJnczogW2Fzc2V0LCB0eXBlXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHg4MzA0ODBmMyAvLyBtZXRob2QgIndpdGhkcmF3KHVpbnQ2NCx1aW50OCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czo5Ni0xMDEKICAgIC8vIHdpdGhkcmF3KAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFzc2V0OiB1aW50NjQsCiAgICAvLyAgIHR5cGU6IFN0YWtpbmdUeXBlCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQbHVnaW4uY3JlYXRlSGVhcnRiZWF0W3JvdXRpbmddKCkgLT4gdm9pZDoKY3JlYXRlSGVhcnRiZWF0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjExMi0xMTcKICAgIC8vIGNyZWF0ZUhlYXJ0YmVhdCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhZGRyZXNzOiBBY2NvdW50LAogICAgLy8gICBhc3NldDogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEyMC0xMjUKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN0YWtpbmcucHJvdG90eXBlLmNyZWF0ZUhlYXJ0YmVhdD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIC8vICAgYXJnczogW2FkZHJlc3MsIGFzc2V0XSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTIyCiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN0YWtpbmcsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTIyCiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN0YWtpbmcsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMiAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEyMgogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTI0CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgdW5jb3ZlciA0CiAgICB1bmNvdmVyIDUKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTIwLTEyNQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Rha2luZy5wcm90b3R5cGUuY3JlYXRlSGVhcnRiZWF0Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgLy8gICBhcmdzOiBbYWRkcmVzcywgYXNzZXRdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweGM4MTczY2ExIC8vIG1ldGhvZCAiY3JlYXRlSGVhcnRiZWF0KGFkZHJlc3MsdWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjExMi0xMTcKICAgIC8vIGNyZWF0ZUhlYXJ0YmVhdCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhZGRyZXNzOiBBY2NvdW50LAogICAgLy8gICBhc3NldDogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQbHVnaW4uc29mdENoZWNrW3JvdXRpbmddKCkgLT4gdm9pZDoKc29mdENoZWNrOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEyOC0xMzMKICAgIC8vIHNvZnRDaGVjaygKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhZGRyZXNzOiBBY2NvdW50LAogICAgLy8gICBhc3NldDogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEzNi0xNDEKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN0YWtpbmcucHJvdG90eXBlLnNvZnRDaGVjaz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Rha2luZywKICAgIC8vICAgYXJnczogW2FkZHJlc3MsIGFzc2V0XSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTM4CiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN0YWtpbmcsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTM4CiAgICAvLyBhcHBJZDogZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN0YWtpbmcsCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMiAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy9jb250cmFjdC5hbGdvLnRzOjEzOAogICAgLy8gYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTQwCiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgdW5jb3ZlciA0CiAgICB1bmNvdmVyIDUKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nL2NvbnRyYWN0LmFsZ28udHM6MTM2LTE0MQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Rha2luZy5wcm90b3R5cGUuc29mdENoZWNrPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdGFraW5nLAogICAgLy8gICBhcmdzOiBbYWRkcmVzcywgYXNzZXRdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDQ4NzE2ZjFhIC8vIG1ldGhvZCAic29mdENoZWNrKGFkZHJlc3MsdWludDY0KShib29sLHVpbnQ2NCkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciA0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgaXR4biBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgcHVzaGJ5dGVzIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgbGVuCiAgICBwdXNoaW50IDkgLy8gOQogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmcvY29udHJhY3QuYWxnby50czoxMjgtMTMzCiAgICAvLyBzb2Z0Q2hlY2soCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYWRkcmVzczogQWNjb3VudCwKICAgIC8vICAgYXNzZXQ6IHVpbnQ2NAogICAgLy8gKTogdm9pZCB7CiAgICByZXR1cm4gLy8gb24gZXJyb3I6IGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAoYm9vbDEsdWludDY0KQoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjpBa2l0YUJhc2VDb250cmFjdC51cGRhdGVBa2l0YURBT1tyb3V0aW5nXSgpIC0+IHZvaWQ6CnVwZGF0ZUFraXRhREFPOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzgKICAgIC8vIHVwZGF0ZUFraXRhREFPKGFraXRhREFPOiBBcHBsaWNhdGlvbik6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjM5CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gdGhpcy5nZXRBa2l0YURBT1dhbGxldCgpLmFkZHJlc3MsIEVSUl9OT1RfQUtJVEFfREFPKQogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzIKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzIKICAgIC8vIGNvbnN0IFt3YWxsZXRJRF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQodGhpcy5ha2l0YURBTy52YWx1ZSwgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNXYWxsZXQpKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIHB1c2hieXRlcyAid2FsbGV0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzkKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSB0aGlzLmdldEFraXRhREFPV2FsbGV0KCkuYWRkcmVzcywgRVJSX05PVF9BS0lUQV9EQU8pCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgdGhlIEFraXRhIERBTyBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjQwCiAgICAvLyB0aGlzLmFraXRhREFPLnZhbHVlID0gYWtpdGFEQU8KICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozOAogICAgLy8gdXBkYXRlQWtpdGFEQU8oYWtpdGFEQU86IEFwcGxpY2F0aW9uKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCg==", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyAFAAEIBuThASYDCWFraXRhX2RhbxBzcGVuZGluZ19hZGRyZXNzA2FhbDEZFEQxGEEANIIGBLudh0kEKnji7gS2/HbPBP2/iWAEM+kslASFTe3gNhoAjgYATAGuAgcCYQLQAAEAI0OABG+YF/Y2GgCOAQASAIoCAYv+QAADMgOJi/9yCESJNhoBSRUkEkQXNhoCSSJZgQIISwEVEkRXAgCAB3ZlcnNpb25MZyhMZyNDgABJNhoBSRUkEkQXSTYaAkkVIxJEIlNMNhoDSRUkEkQXTDYaBElOAkkVIxJENhoFSU4DSRUkEkQXTgI2GgZJTgMVJBJENhoHSRUjEkQiU04CTCllSEwiKGVEKmVIIltMgAEeEkAACUsGgAEoEkEA7CNFDCJFC0sCQADQSwtBALJLB0AArUsEIQQIRQtLB0AAQrFHAnIIREsMsgiyB0sCSbIAI7IQIrIBtksKSwyI/xWABIJWzxmyGksJshpLCLIaSwayGrIgsgCyGCWyECKyAbMjQ7FHAnIIREsMsgiyB0sCSU4CsgAjshAisgG2SXIIREsKshFLB7ISshRLAbIAgQSyECKyAbZLCksMiP63gAQgRnuTshpLCbIaSwiyGksGshqyILIYsgAlshAisgGzQv+fSwaAAQoSQQAJgbiFBkULQv9IIQRFC0L/QUsLQf88SwdA/zdLBEULQv8wIkUMQv8RNhoBSRUkEkQXNhoCSRUjEkQiUzYaA0kVJBJENhoESRUjEkRLAyllSEyxIihlRCplSCJbTwRPBYj+KYAEgwSA87IaTwSyGk8CshqyILIYsgAlshAisgGzI0M2GgFJFSQSRBc2GgJJFSMSRCJTNhoDSRWBIBJENhoESRUkEkRLAyllSEyxIihlRCplSCJbTwRPBYj9z4AEyBc8obIaTwSyGk8CshqyILIYsgAlshAisgGzI0M2GgFJFSQSRBc2GgJJFSMSRCJTNhoDSRWBIBJENhoESRUkEkRLAyllSEyxIihlRCplSCJbTwRPBYj9dYAESHFvGrIaTwSyGk8CshqyILIYsgAlshAisgGztD5JVwQATFcABIAEFR98dRJEFYEJEkM2GgFJFSQSRBcxACIoZUSABndhbGxldGVIcghEEkQoTGcjQw==", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var StakingPluginParamsFactory = class _StakingPluginParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "create":
          case "create(uint64,string)void":
            return _StakingPluginParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs create ABI call params for the StakingPlugin smart contract using the create(uint64,string)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params) {
        return {
          ...params,
          method: "create(uint64,string)void",
          args: Array.isArray(params.args) ? params.args : [params.args.akitaDao, params.args.version]
        };
      }
    };
  }
  /**
   * Constructs a no op call for the stake(uint64,bool,uint64,uint8,uint64,uint64,bool)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static stake(params) {
    return {
      ...params,
      method: "stake(uint64,bool,uint64,uint8,uint64,uint64,bool)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.assetId, params.args.type, params.args.amount, params.args.expiration, params.args.isUpdate]
    };
  }
  /**
   * Constructs a no op call for the withdraw(uint64,bool,uint64,uint8)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static withdraw(params) {
    return {
      ...params,
      method: "withdraw(uint64,bool,uint64,uint8)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.asset, params.args.type]
    };
  }
  /**
   * Constructs a no op call for the createHeartbeat(uint64,bool,address,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static createHeartbeat(params) {
    return {
      ...params,
      method: "createHeartbeat(uint64,bool,address,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.address, params.args.asset]
    };
  }
  /**
   * Constructs a no op call for the softCheck(uint64,bool,address,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static softCheck(params) {
    return {
      ...params,
      method: "softCheck(uint64,bool,address,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.address, params.args.asset]
    };
  }
  /**
   * Constructs a no op call for the updateAkitaDAO(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDao(params) {
    return {
      ...params,
      method: "updateAkitaDAO(uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.akitaDao]
    };
  }
  /**
   * Constructs a no op call for the opUp()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static opUp(params) {
    return {
      ...params,
      method: "opUp()void",
      args: Array.isArray(params.args) ? params.args : []
    };
  }
};
var StakingPluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `StakingPluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory21({
      ...params,
      appSpec: APP_SPEC21
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC21;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new StakingPluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new StakingPluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the StakingPlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    var _a;
    const result = await this.appFactory.deploy({
      ...params,
      createParams: ((_a = params.createParams) == null ? void 0 : _a.method) ? StakingPluginParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams : void 0
    });
    return { result: result.result, appClient: new StakingPluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the StakingPlugin smart contract using the create(uint64,string)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params) => {
        return this.appFactory.params.create(StakingPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the StakingPlugin smart contract using the create(uint64,string)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params) => {
        return this.appFactory.createTransaction.create(StakingPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the StakingPlugin smart contract using an ABI method call using the create(uint64,string)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params) => {
        const result = await this.appFactory.send.create(StakingPluginParamsFactory.create.create(params));
        return { result: { ...result.result, return: result.result.return }, appClient: new StakingPluginClient(result.appClient) };
      }
    }
  };
};
var StakingPluginClient = class _StakingPluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient21 ? appClientOrParams : new _AppClient21({
      ...appClientOrParams,
      appSpec: APP_SPEC21
    });
  }
  /**
   * Returns a new `StakingPluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _StakingPluginClient(await _AppClient21.fromCreatorAndName({ ...params, appSpec: APP_SPEC21 }));
  }
  /**
   * Returns an `StakingPluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _StakingPluginClient(await _AppClient21.fromNetwork({ ...params, appSpec: APP_SPEC21 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the StakingPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the StakingPlugin smart contract using the `stake(uint64,bool,uint64,uint8,uint64,uint64,bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    stake: (params) => {
      return this.appClient.params.call(StakingPluginParamsFactory.stake(params));
    },
    /**
     * Makes a call to the StakingPlugin smart contract using the `withdraw(uint64,bool,uint64,uint8)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    withdraw: (params) => {
      return this.appClient.params.call(StakingPluginParamsFactory.withdraw(params));
    },
    /**
     * Makes a call to the StakingPlugin smart contract using the `createHeartbeat(uint64,bool,address,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    createHeartbeat: (params) => {
      return this.appClient.params.call(StakingPluginParamsFactory.createHeartbeat(params));
    },
    /**
     * Makes a call to the StakingPlugin smart contract using the `softCheck(uint64,bool,address,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    softCheck: (params) => {
      return this.appClient.params.call(StakingPluginParamsFactory.softCheck(params));
    },
    /**
     * Makes a call to the StakingPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDao: (params) => {
      return this.appClient.params.call(StakingPluginParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the StakingPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.params.call(StakingPluginParamsFactory.opUp(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the StakingPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the StakingPlugin smart contract using the `stake(uint64,bool,uint64,uint8,uint64,uint64,bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    stake: (params) => {
      return this.appClient.createTransaction.call(StakingPluginParamsFactory.stake(params));
    },
    /**
     * Makes a call to the StakingPlugin smart contract using the `withdraw(uint64,bool,uint64,uint8)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    withdraw: (params) => {
      return this.appClient.createTransaction.call(StakingPluginParamsFactory.withdraw(params));
    },
    /**
     * Makes a call to the StakingPlugin smart contract using the `createHeartbeat(uint64,bool,address,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    createHeartbeat: (params) => {
      return this.appClient.createTransaction.call(StakingPluginParamsFactory.createHeartbeat(params));
    },
    /**
     * Makes a call to the StakingPlugin smart contract using the `softCheck(uint64,bool,address,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    softCheck: (params) => {
      return this.appClient.createTransaction.call(StakingPluginParamsFactory.softCheck(params));
    },
    /**
     * Makes a call to the StakingPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDao: (params) => {
      return this.appClient.createTransaction.call(StakingPluginParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the StakingPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.createTransaction.call(StakingPluginParamsFactory.opUp(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the StakingPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the StakingPlugin smart contract using the `stake(uint64,bool,uint64,uint8,uint64,uint64,bool)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    stake: async (params) => {
      const result = await this.appClient.send.call(StakingPluginParamsFactory.stake(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the StakingPlugin smart contract using the `withdraw(uint64,bool,uint64,uint8)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    withdraw: async (params) => {
      const result = await this.appClient.send.call(StakingPluginParamsFactory.withdraw(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the StakingPlugin smart contract using the `createHeartbeat(uint64,bool,address,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    createHeartbeat: async (params) => {
      const result = await this.appClient.send.call(StakingPluginParamsFactory.createHeartbeat(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the StakingPlugin smart contract using the `softCheck(uint64,bool,address,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    softCheck: async (params) => {
      const result = await this.appClient.send.call(StakingPluginParamsFactory.softCheck(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the StakingPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDao: async (params) => {
      const result = await this.appClient.send.call(StakingPluginParamsFactory.updateAkitaDao(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the StakingPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    opUp: async (params = { args: [] }) => {
      const result = await this.appClient.send.call(StakingPluginParamsFactory.opUp(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _StakingPluginClient(this.appClient.clone(params));
  }
  /**
   * Methods to access state for the current StakingPlugin app
   */
  state = {
    /**
     * Methods to access global state for the current StakingPlugin app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async () => {
        const result = await this.appClient.state.global.getAll();
        return {
          version: result.version,
          akitaDao: result.akitaDAO
        };
      },
      /**
       * Get the current value of the version key in global state
       */
      version: async () => {
        return await this.appClient.state.global.getValue("version");
      },
      /**
       * Get the current value of the akitaDAO key in global state
       */
      akitaDao: async () => {
        return await this.appClient.state.global.getValue("akitaDAO");
      }
    }
  };
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a stake(uint64,bool,uint64,uint8,uint64,uint64,bool)void method call against the StakingPlugin contract
       */
      stake(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.stake(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a withdraw(uint64,bool,uint64,uint8)void method call against the StakingPlugin contract
       */
      withdraw(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.withdraw(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a createHeartbeat(uint64,bool,address,uint64)void method call against the StakingPlugin contract
       */
      createHeartbeat(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.createHeartbeat(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a softCheck(uint64,bool,address,uint64)void method call against the StakingPlugin contract
       */
      softCheck(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.softCheck(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a updateAkitaDAO(uint64)void method call against the StakingPlugin contract
       */
      updateAkitaDao(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDao(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a opUp()void method call against the StakingPlugin contract
       */
      opUp(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.opUp(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a clear state call to the StakingPlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/staking.ts
var StakingPluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: StakingPluginFactory, ...params });
  }
  stake(args) {
    const methodName = "stake";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.stake({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  withdraw(args) {
    const methodName = "withdraw";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.withdraw({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
};

// src/generated/StakingPoolPluginClient.ts
import { getArc56ReturnValue as getArc56ReturnValue14, getABIStructFromABITuple as getABIStructFromABITuple14 } from "@algorandfoundation/algokit-utils/types/app-arc56";
import {
  AppClient as _AppClient22
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory22 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC22 = { "name": "StakingPoolPlugin", "structs": { "RootKey": [{ "name": "address", "type": "address" }, { "name": "name", "type": "string" }], "RaffleCursor": [{ "name": "ticket", "type": "uint64" }, { "name": "stake", "type": "uint64" }, { "name": "disbursed", "type": "uint64" }], "Reward": [{ "name": "asset", "type": "uint64" }, { "name": "distribution", "type": "uint8" }, { "name": "rate", "type": "uint64" }, { "name": "expiration", "type": "uint64" }, { "name": "interval", "type": "uint64" }, { "name": "qualifiedStakers", "type": "uint64" }, { "name": "qualifiedStake", "type": "uint64" }, { "name": "winnerCount", "type": "uint64" }, { "name": "winningTickets", "type": "uint64[]" }, { "name": "raffleCursor", "type": "RaffleCursor" }, { "name": "vrfFailureCount", "type": "uint64" }, { "name": "phase", "type": "uint8" }, { "name": "disbursementCursor", "type": "uint64" }, { "name": "activeDisbursementId", "type": "uint64" }, { "name": "activeDisbursementRoundStart", "type": "uint64" }, { "name": "lastDisbursementTimestamp", "type": "uint64" }], "StakingPoolMBRData": [{ "name": "entries", "type": "uint64" }, { "name": "uniques", "type": "uint64" }, { "name": "entriesByAddress", "type": "uint64" }, { "name": "rewards", "type": "uint64" }, { "name": "disbursements", "type": "uint64" }] }, "methods": [{ "name": "create", "args": [{ "type": "string", "name": "version" }, { "type": "uint64", "name": "factory" }, { "type": "uint64", "name": "akitaDAO" }], "returns": { "type": "void" }, "actions": { "create": ["NoOp"], "call": [] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "newPool", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "string", "name": "title" }, { "type": "uint8", "name": "type" }, { "type": "address", "name": "marketplace" }, { "type": "(address,string)", "struct": "RootKey", "name": "stakeKey" }, { "type": "uint64", "name": "minimumStakeAmount" }, { "type": "bool", "name": "allowLateSignups" }, { "type": "uint64", "name": "gateID" }, { "type": "uint64", "name": "maxEntries" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "initPool", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "poolID" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "deletePool", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "addReward", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64)", "struct": "Reward", "name": "reward" }, { "type": "uint64", "name": "amount" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "finalizePool", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "poolID" }, { "type": "uint64", "name": "signupTimestamp" }, { "type": "uint64", "name": "startTimestamp" }, { "type": "uint64", "name": "endTimestamp" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "enter", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "appId" }, { "type": "(uint64,uint64,byte[32][])[]", "name": "entries" }, { "type": "byte[][]", "name": "args" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "mbr", "args": [{ "type": "uint64", "name": "winningTickets" }], "returns": { "type": "(uint64,uint64,uint64,uint64,uint64)", "struct": "StakingPoolMBRData", "desc": "the mbr created for each boxmap entry" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": true, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 2, "bytes": 1 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": { "version": { "keyType": "AVMString", "valueType": "AVMString", "key": "dmVyc2lvbg==" }, "factory": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "cG9vbF9mYWN0b3J5", "desc": "the factory contract" }, "akitaDAO": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "YWtpdGFfZGFv", "desc": "the Akita DAO" } }, "local": {}, "box": {} }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": [], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [428, 1339], "errorMessage": "Bytes has valid prefix" }, { "pc": [473, 554, 659, 1098, 1205], "errorMessage": "Not a valid pool" }, { "pc": [59], "errorMessage": "OnCompletion must be NoOp" }, { "pc": [151, 336, 464, 471, 542, 550, 650, 657, 682, 792, 828, 851, 902, 937, 1089, 1096, 1196, 1203, 1256, 1366], "errorMessage": "application exists" }, { "pc": [302, 332, 468, 546, 654, 805, 1093, 1200, 1381], "errorMessage": "check GlobalState exists" }, { "pc": [166, 241], "errorMessage": "invalid number of bytes for (len+utf8[])" }, { "pc": [225, 277, 449, 527, 613, 1049, 1164, 1344], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [177, 186, 216, 269, 285, 293, 432, 440, 459, 518, 537, 603, 624, 644, 1040, 1059, 1068, 1076, 1084, 1154, 1175, 1550], "errorMessage": "invalid number of bytes for uint64" }, { "pc": [249], "errorMessage": "invalid number of bytes for uint8" }, { "pc": [258], "errorMessage": "invalid number of bytes for uint8[32]" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDggNiA0MDAKICAgIGJ5dGVjYmxvY2sgInBvb2xfZmFjdG9yeSIgInNwZW5kaW5nX2FkZHJlc3MiICJha2l0YV9kYW8iIDB4MTUxZjdjNzUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIyCiAgICAvLyBleHBvcnQgY2xhc3MgU3Rha2luZ1Bvb2xQbHVnaW4gZXh0ZW5kcyBCYXNlU3Rha2luZ1Bvb2wgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBieiBtYWluX2NyZWF0ZV9Ob09wQDExCiAgICBwdXNoYnl0ZXNzIDB4YWI5M2FjMWEgMHgyNmMwYzMxYyAweDI1NTJkODlhIDB4ZTc0Mzk5MTkgMHgyNjc0N2E3YSAweDg4NzVmNDY3IDB4YTRiM2U3ODkgLy8gbWV0aG9kICJuZXdQb29sKHVpbnQ2NCxib29sLHN0cmluZyx1aW50OCxhZGRyZXNzLChhZGRyZXNzLHN0cmluZyksdWludDY0LGJvb2wsdWludDY0LHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJpbml0UG9vbCh1aW50NjQsYm9vbCx1aW50NjQpdm9pZCIsIG1ldGhvZCAiZGVsZXRlUG9vbCh1aW50NjQsYm9vbCx1aW50NjQpdm9pZCIsIG1ldGhvZCAiYWRkUmV3YXJkKHVpbnQ2NCxib29sLHVpbnQ2NCwodWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NFtdLCh1aW50NjQsdWludDY0LHVpbnQ2NCksdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCksdWludDY0KXZvaWQiLCBtZXRob2QgImZpbmFsaXplUG9vbCh1aW50NjQsYm9vbCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZCIsIG1ldGhvZCAiZW50ZXIodWludDY0LGJvb2wsdWludDY0LCh1aW50NjQsdWludDY0LGJ5dGVbMzJdW10pW10sYnl0ZVtdW10pdm9pZCIsIG1ldGhvZCAibWJyKHVpbnQ2NCkodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBuZXdQb29sIGluaXRQb29sIGRlbGV0ZVBvb2wgYWRkUmV3YXJkIGZpbmFsaXplUG9vbCBlbnRlciBtYnIKICAgIGVycgoKbWFpbl9jcmVhdGVfTm9PcEAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIyCiAgICAvLyBleHBvcnQgY2xhc3MgU3Rha2luZ1Bvb2xQbHVnaW4gZXh0ZW5kcyBCYXNlU3Rha2luZ1Bvb2wgewogICAgcHVzaGJ5dGVzIDB4ODhjOTQwZjggLy8gbWV0aG9kICJjcmVhdGUoc3RyaW5nLHVpbnQ2NCx1aW50NjQpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIGNyZWF0ZQogICAgZXJyCgoKLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6cmVrZXlBZGRyZXNzKHJla2V5QmFjazogdWludDY0LCB3YWxsZXQ6IHVpbnQ2NCkgLT4gYnl0ZXM6CnJla2V5QWRkcmVzczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzIxCiAgICAvLyBleHBvcnQgZnVuY3Rpb24gcmVrZXlBZGRyZXNzKHJla2V5QmFjazogYm9vbGVhbiwgd2FsbGV0OiBBcHBsaWNhdGlvbik6IEFjY291bnQgewogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMgogICAgLy8gaWYgKCFyZWtleUJhY2spIHsKICAgIGZyYW1lX2RpZyAtMgogICAgYm56IHJla2V5QWRkcmVzc19hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzIzCiAgICAvLyByZXR1cm4gR2xvYmFsLnplcm9BZGRyZXNzCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgIHJldHN1YgoKcmVrZXlBZGRyZXNzX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MzI2CiAgICAvLyByZXR1cm4gd2FsbGV0LmFkZHJlc3MKICAgIGZyYW1lX2RpZyAtMQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OlN0YWtpbmdQb29sUGx1Z2luLmNyZWF0ZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmNyZWF0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM0CiAgICAvLyBAYWJpbWV0aG9kKHsgb25DcmVhdGU6ICdyZXF1aXJlJyB9KQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI2CiAgICAvLyB2ZXJzaW9uID0gR2xvYmFsU3RhdGU8c3RyaW5nPih7IGtleTogR2xvYmFsU3RhdGVLZXlWZXJzaW9uIH0pCiAgICBwdXNoYnl0ZXMgInZlcnNpb24iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozNgogICAgLy8gdGhpcy52ZXJzaW9uLnZhbHVlID0gdmVyc2lvbgogICAgdW5jb3ZlciAzCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjgKICAgIC8vIGZhY3RvcnkgPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IFBvb2xQbHVnaW5HbG9iYWxTdGF0ZUtleUZhY3RvcnkgfSkKICAgIGJ5dGVjXzAgLy8gInBvb2xfZmFjdG9yeSIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM3CiAgICAvLyB0aGlzLmZhY3RvcnkudmFsdWUgPSBmYWN0b3J5CiAgICB1bmNvdmVyIDIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMAogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzIgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjM4CiAgICAvLyB0aGlzLmFraXRhREFPLnZhbHVlID0gYWtpdGFEQU8KICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozNAogICAgLy8gQGFiaW1ldGhvZCh7IG9uQ3JlYXRlOiAncmVxdWlyZScgfSkKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2xQbHVnaW4ubmV3UG9vbFtyb3V0aW5nXSgpIC0+IHZvaWQ6Cm5ld1Bvb2w6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo0My01NAogICAgLy8gbmV3UG9vbCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICB0aXRsZTogc3RyaW5nLAogICAgLy8gICB0eXBlOiBTdGFraW5nVHlwZSwKICAgIC8vICAgbWFya2V0cGxhY2U6IEFjY291bnQsCiAgICAvLyAgIHN0YWtlS2V5OiBSb290S2V5LAogICAgLy8gICBtaW5pbXVtU3Rha2VBbW91bnQ6IHVpbnQ2NCwKICAgIC8vICAgYWxsb3dMYXRlU2lnbnVwczogYm9vbGVhbiwKICAgIC8vICAgZ2F0ZUlEOiB1aW50NjQsCiAgICAvLyAgIG1heEVudHJpZXM6IHVpbnQ2NCwKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1dGY4W10pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA2CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA3CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgOAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgOQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEwCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTcKICAgIC8vIGNvbnN0IGZlZXMgPSBnZXRTdGFraW5nRmVlcyh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjMwCiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMiAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NTcKICAgIC8vIGNvbnN0IGZlZXMgPSBnZXRTdGFraW5nRmVlcyh0aGlzLmFraXRhREFPLnZhbHVlKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NzQKICAgIC8vIGNvbnN0IFtzdGFraW5nRmVlc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1N0YWtpbmdGZWVzKSkKICAgIHB1c2hieXRlcyAic3Rha2luZ19mZWVzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NjIKICAgIC8vIGZlZXMuY3JlYXRpb25GZWUgKwogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo2Mi02NQogICAgLy8gZmVlcy5jcmVhdGlvbkZlZSArCiAgICAvLyBNQVhfUFJPR1JBTV9QQUdFUyArCiAgICAvLyAoR0xPQkFMX1NUQVRFX0tFWV9VSU5UX0NPU1QgKiBwb29sLmdsb2JhbFVpbnRzKSArCiAgICAvLyAoR0xPQkFMX1NUQVRFX0tFWV9CWVRFU19DT1NUICogcG9vbC5nbG9iYWxCeXRlcykgKwogICAgcHVzaGludCAxMzA2MDAwIC8vIDEzMDYwMDAKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY2CiAgICAvLyBHbG9iYWwubWluQmFsYW5jZQogICAgZ2xvYmFsIE1pbkJhbGFuY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjYyLTY2CiAgICAvLyBmZWVzLmNyZWF0aW9uRmVlICsKICAgIC8vIE1BWF9QUk9HUkFNX1BBR0VTICsKICAgIC8vIChHTE9CQUxfU1RBVEVfS0VZX1VJTlRfQ09TVCAqIHBvb2wuZ2xvYmFsVWludHMpICsKICAgIC8vIChHTE9CQUxfU1RBVEVfS0VZX0JZVEVTX0NPU1QgKiBwb29sLmdsb2JhbEJ5dGVzKSArCiAgICAvLyBHbG9iYWwubWluQmFsYW5jZQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzEKICAgIC8vIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyOAogICAgLy8gZmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogUG9vbFBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAicG9vbF9mYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzEKICAgIC8vIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjc1LTkwCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdGFraW5nUG9vbEZhY3RvcnkucHJvdG90eXBlLm5ld1Bvb2w+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyVHhuLAogICAgLy8gICAgIHRpdGxlLAogICAgLy8gICAgIHR5cGUsCiAgICAvLyAgICAgbWFya2V0cGxhY2UsCiAgICAvLyAgICAgc3Rha2VLZXksCiAgICAvLyAgICAgbWluaW11bVN0YWtlQW1vdW50LAogICAgLy8gICAgIGFsbG93TGF0ZVNpZ251cHMsCiAgICAvLyAgICAgZ2F0ZUlELAogICAgLy8gICAgIG1heEVudHJpZXMsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjY5LTczCiAgICAvLyBjb25zdCBtYnJUeG4gPSBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBjaGlsZENvbnRyYWN0TUJSCiAgICAvLyB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6NzUtOTAKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN0YWtpbmdQb29sRmFjdG9yeS5wcm90b3R5cGUubmV3UG9vbD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiB0aGlzLmZhY3RvcnkudmFsdWUsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJUeG4sCiAgICAvLyAgICAgdGl0bGUsCiAgICAvLyAgICAgdHlwZSwKICAgIC8vICAgICBtYXJrZXRwbGFjZSwKICAgIC8vICAgICBzdGFrZUtleSwKICAgIC8vICAgICBtaW5pbXVtU3Rha2VBbW91bnQsCiAgICAvLyAgICAgYWxsb3dMYXRlU2lnbnVwcywKICAgIC8vICAgICBnYXRlSUQsCiAgICAvLyAgICAgbWF4RW50cmllcywKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6ODkKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIHVuY292ZXIgMTAKICAgIHVuY292ZXIgMTEKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo3NS05MAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Rha2luZ1Bvb2xGYWN0b3J5LnByb3RvdHlwZS5uZXdQb29sPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZmFjdG9yeS52YWx1ZSwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclR4biwKICAgIC8vICAgICB0aXRsZSwKICAgIC8vICAgICB0eXBlLAogICAgLy8gICAgIG1hcmtldHBsYWNlLAogICAgLy8gICAgIHN0YWtlS2V5LAogICAgLy8gICAgIG1pbmltdW1TdGFrZUFtb3VudCwKICAgIC8vICAgICBhbGxvd0xhdGVTaWdudXBzLAogICAgLy8gICAgIGdhdGVJRCwKICAgIC8vICAgICBtYXhFbnRyaWVzLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4MmIyNWFjODkgLy8gbWV0aG9kICJuZXdQb29sKHBheSxzdHJpbmcsdWludDgsYWRkcmVzcywoYWRkcmVzcyxzdHJpbmcpLHVpbnQ2NCxib29sLHVpbnQ2NCx1aW50NjQpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMTAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDkKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDgKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDcKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDYKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBnaXR4biAxIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18zIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjQzLTU0CiAgICAvLyBuZXdQb29sKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIHRpdGxlOiBzdHJpbmcsCiAgICAvLyAgIHR5cGU6IFN0YWtpbmdUeXBlLAogICAgLy8gICBtYXJrZXRwbGFjZTogQWNjb3VudCwKICAgIC8vICAgc3Rha2VLZXk6IFJvb3RLZXksCiAgICAvLyAgIG1pbmltdW1TdGFrZUFtb3VudDogdWludDY0LAogICAgLy8gICBhbGxvd0xhdGVTaWdudXBzOiBib29sZWFuLAogICAgLy8gICBnYXRlSUQ6IHVpbnQ2NCwKICAgIC8vICAgbWF4RW50cmllczogdWludDY0LAogICAgLy8gKTogdm9pZCB7CiAgICByZXR1cm4gLy8gb24gZXJyb3I6IGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2xQbHVnaW4uaW5pdFBvb2xbcm91dGluZ10oKSAtPiB2b2lkOgppbml0UG9vbDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjkzLTk3CiAgICAvLyBpbml0UG9vbCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBwb29sSUQ6IHVpbnQ2NAogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjk4CiAgICAvLyBhc3NlcnQoQXBwbGljYXRpb24ocG9vbElEKS5jcmVhdG9yID09PSB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywgRVJSX05PVF9BX1ZBTElEX1BPT0wpCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcENyZWF0b3IKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyOAogICAgLy8gZmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogUG9vbFBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAicG9vbF9mYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTgKICAgIC8vIGFzc2VydChBcHBsaWNhdGlvbihwb29sSUQpLmNyZWF0b3IgPT09IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLCBFUlJfTk9UX0FfVkFMSURfUE9PTCkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICA9PQogICAgYXNzZXJ0IC8vIE5vdCBhIHZhbGlkIHBvb2wKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMSAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwMi0xMDYKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN0YWtpbmdQb29sLnByb3RvdHlwZS5pbml0Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHBvb2xJRCwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwNQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciAyCiAgICB1bmNvdmVyIDMKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDItMTA2CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdGFraW5nUG9vbC5wcm90b3R5cGUuaW5pdD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBwb29sSUQsCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHg4M2YxNDc0OCAvLyBtZXRob2QgImluaXQoKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6OTMtOTcKICAgIC8vIGluaXRQb29sKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIHBvb2xJRDogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2xQbHVnaW4uZGVsZXRlUG9vbFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmRlbGV0ZVBvb2w6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMDktMTEzCiAgICAvLyBkZWxldGVQb29sKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbgogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGR1cAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE0CiAgICAvLyBhc3NlcnQoYXBwSWQuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9OT1RfQV9WQUxJRF9QT09MKQogICAgYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI4CiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBQb29sUGx1Z2luR2xvYmFsU3RhdGVLZXlGYWN0b3J5IH0pCiAgICBieXRlY18wIC8vICJwb29sX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTQKICAgIC8vIGFzc2VydChhcHBJZC5jcmVhdG9yID09PSB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywgRVJSX05PVF9BX1ZBTElEX1BPT0wpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICB1bmNvdmVyIDIKICAgID09CiAgICBhc3NlcnQgLy8gTm90IGEgdmFsaWQgcG9vbAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18xIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTE4LTEyMwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Rha2luZ1Bvb2xGYWN0b3J5LnByb3RvdHlwZS5kZWxldGVQb29sPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IHRoaXMuZmFjdG9yeS52YWx1ZSwKICAgIC8vICAgYXJnczogW2FwcElkXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyMgogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciAzCiAgICB1bmNvdmVyIDQKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMTgtMTIzCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdGFraW5nUG9vbEZhY3RvcnkucHJvdG90eXBlLmRlbGV0ZVBvb2w+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogdGhpcy5mYWN0b3J5LnZhbHVlLAogICAgLy8gICBhcmdzOiBbYXBwSWRdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4Yzc0NzhmOWQgLy8gbWV0aG9kICJkZWxldGVQb29sKHVpbnQ2NCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEwOS0xMTMKICAgIC8vIGRlbGV0ZVBvb2woCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czo6U3Rha2luZ1Bvb2xQbHVnaW4uYWRkUmV3YXJkW3JvdXRpbmddKCkgLT4gdm9pZDoKYWRkUmV3YXJkOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTI2LTEzMgogICAgLy8gYWRkUmV3YXJkKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmV3YXJkOiBSZXdhcmQsCiAgICAvLyAgIGFtb3VudDogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHN3YXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgY292ZXIgMgogICAgY292ZXIgMwogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGNvdmVyIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEzMwogICAgLy8gYXNzZXJ0KGFwcElkLmNyZWF0b3IgPT09IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLCBFUlJfTk9UX0FfVkFMSURfUE9PTCkKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcENyZWF0b3IKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyOAogICAgLy8gZmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogUG9vbFBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAicG9vbF9mYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTMzCiAgICAvLyBhc3NlcnQoYXBwSWQuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9OT1RfQV9WQUxJRF9QT09MKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gTm90IGEgdmFsaWQgcG9vbAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMzcKICAgIC8vIGlmIChyZXdhcmQuYXNzZXQgPT09IDApIHsKICAgIGR1cAogICAgZXh0cmFjdCAwIDgKICAgIHN3YXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBibnogYWRkUmV3YXJkX2Vsc2VfYm9keUA1CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMzgtMTUwCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdGFraW5nUG9vbC5wcm90b3R5cGUuYWRkUmV3YXJkPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IGFtb3VudCArIHRoaXMucmV3YXJkc01icihyZXdhcmQud2lubmVyQ291bnQpCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgcmV3YXJkCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNDQKICAgIC8vIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgZGlnIDUKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTQ1CiAgICAvLyBhbW91bnQ6IGFtb3VudCArIHRoaXMucmV3YXJkc01icihyZXdhcmQud2lubmVyQ291bnQpCiAgICBkaWcgNgogICAgZHVwCiAgICBjb3ZlciAyCiAgICBwdXNoaW50IDQ5IC8vIDQ5CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9iYXNlLnRzOjkKICAgIC8vIHJldHVybiBNaW5Qb29sUmV3YXJkc01CUiArIChCb3hDb3N0UGVyQnl0ZSAqIHdpbm5pbmdUaWNrZXRzKQogICAgaW50YyA0IC8vIDQwMAogICAgZGlnIDEKICAgICoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0NQogICAgLy8gYW1vdW50OiBhbW91bnQgKyB0aGlzLnJld2FyZHNNYnIocmV3YXJkLndpbm5lckNvdW50KQogICAgZGlnIDgKICAgICsKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgNQogICAgZHVwCiAgICBjb3ZlciAzCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTQyLTE0NgogICAgLy8gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBhbW91bnQgKyB0aGlzLnJld2FyZHNNYnIocmV3YXJkLndpbm5lckNvdW50KQogICAgLy8gfSksCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxMzgtMTUwCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdGFraW5nUG9vbC5wcm90b3R5cGUuYWRkUmV3YXJkPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IGFtb3VudCArIHRoaXMucmV3YXJkc01icihyZXdhcmQud2lubmVyQ291bnQpCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgcmV3YXJkCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE0OQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgZGlnIDEwCiAgICBkaWcgMTIKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNDcKICAgIC8vIHJld2FyZAogICAgZGlnIDIKICAgIGV4dHJhY3QgOCAxCiAgICBkaWcgMwogICAgZXh0cmFjdCA5IDgKICAgIGRpZyA0CiAgICBleHRyYWN0IDE3IDgKICAgIHVuY292ZXIgNQogICAgZXh0cmFjdCAyNSA4CiAgICBkaWcgOAogICAgaXRvYgogICAgdW5jb3ZlciA0CiAgICBjb25jYXQKICAgIHVuY292ZXIgMwogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICB1bmNvdmVyIDIKICAgIGl0b2IKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTM4LTE1MAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Rha2luZ1Bvb2wucHJvdG90eXBlLmFkZFJld2FyZD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBhbW91bnQgKyB0aGlzLnJld2FyZHNNYnIocmV3YXJkLndpbm5lckNvdW50KQogICAgLy8gICAgIH0pLAogICAgLy8gICAgIHJld2FyZAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4NzFiOTU3YWYgLy8gbWV0aG9kICJhZGRSZXdhcmQocGF5LCh1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CgphZGRSZXdhcmRfYWZ0ZXJfaWZfZWxzZUAxMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjEyNi0xMzIKICAgIC8vIGFkZFJld2FyZCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhcHBJZDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJld2FyZDogUmV3YXJkLAogICAgLy8gICBhbW91bnQ6IHVpbnQ2NAogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgphZGRSZXdhcmRfZWxzZV9ib2R5QDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNTMKICAgIC8vIGlmICghYXBwSWQuYWRkcmVzcy5pc09wdGVkSW4oQXNzZXQocmV3YXJkLmFzc2V0KSkpIHsKICAgIGRpZyA1CiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBkaWcgMQogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBidXJ5IDEKICAgIGJueiBhZGRSZXdhcmRfYWZ0ZXJfaWZfZWxzZUA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNTYKICAgIC8vIGNvbnN0IGVzY3Jvd0J5dGVzID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXModGhpcy5mYWN0b3J5LnZhbHVlLCBCeXRlcyhHbG9iYWxTdGF0ZUtleUFraXRhRXNjcm93KSlbMF0KICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyOAogICAgLy8gZmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogUG9vbFBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAicG9vbF9mYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTU2CiAgICAvLyBjb25zdCBlc2Nyb3dCeXRlcyA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKHRoaXMuZmFjdG9yeS52YWx1ZSwgQnl0ZXMoR2xvYmFsU3RhdGVLZXlBa2l0YUVzY3JvdykpWzBdCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgcHVzaGJ5dGVzICJha2l0YV9lc2Nyb3ciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNTcKICAgIC8vIGNvbnN0IGVzY3JvdyA9IEFwcGxpY2F0aW9uKGJ0b2koZXNjcm93Qnl0ZXMpKTsKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE1OAogICAgLy8gbGV0IG9wdGluTUJSOiB1aW50NjQgPSBHbG9iYWwuYXNzZXRPcHRJbk1pbkJhbGFuY2UgKiAoCiAgICBnbG9iYWwgQXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE1OQogICAgLy8gIWVzY3Jvdy5hZGRyZXNzLmlzT3B0ZWRJbihBc3NldChyZXdhcmQuYXNzZXQpKSA/IDQgOiAxCiAgICBzd2FwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBkaWcgMgogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBidXJ5IDEKICAgICEKICAgIGludGNfMSAvLyAxCiAgICBwdXNoaW50IDQgLy8gNAogICAgdW5jb3ZlciAyCiAgICBzZWxlY3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE1OC0xNjAKICAgIC8vIGxldCBvcHRpbk1CUjogdWludDY0ID0gR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlICogKAogICAgLy8gICAhZXNjcm93LmFkZHJlc3MuaXNPcHRlZEluKEFzc2V0KHJld2FyZC5hc3NldCkpID8gNCA6IDEKICAgIC8vICkKICAgICoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE2NC0xNzUKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN0YWtpbmdQb29sLnByb3RvdHlwZS5vcHRJbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBvcHRpbk1CUiArIHJld2FyZHNNQlIKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBBc3NldChyZXdhcmQuYXNzZXQpLAogICAgLy8gICBdCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTcwCiAgICAvLyByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIGRpZyA2CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE3MQogICAgLy8gYW1vdW50OiBvcHRpbk1CUiArIHJld2FyZHNNQlIKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE2MgogICAgLy8gY29uc3QgcmV3YXJkc01CUjogdWludDY0ID0gdGhpcy5yZXdhcmRzTWJyKFdpbm5lckNvdW50Q2FwKSAqIDIKICAgIHB1c2hpbnQgODAwMCAvLyA4MDAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNzEKICAgIC8vIGFtb3VudDogb3B0aW5NQlIgKyByZXdhcmRzTUJSCiAgICArCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZGlnIDMKICAgIGR1cAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE2OC0xNzIKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogb3B0aW5NQlIgKyByZXdhcmRzTUJSCiAgICAvLyB9KSwKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE2NC0xNzUKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN0YWtpbmdQb29sLnByb3RvdHlwZS5vcHRJbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBvcHRpbk1CUiArIHJld2FyZHNNQlIKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBBc3NldChyZXdhcmQuYXNzZXQpLAogICAgLy8gICBdCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICBwdXNoYnl0ZXMgMHgzOTRlYWViMiAvLyBtZXRob2QgIm9wdEluKHBheSx1aW50NjQpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CgphZGRSZXdhcmRfYWZ0ZXJfaWZfZWxzZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTc4LTE5NgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Rha2luZ1Bvb2wucHJvdG90eXBlLmFkZFJld2FyZEFzYT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiB0aGlzLnJld2FyZHNNYnIocmV3YXJkLndpbm5lckNvdW50KQogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICAgIHhmZXJBc3NldDogcmV3YXJkLmFzc2V0CiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgcmV3YXJkCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxODQKICAgIC8vIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgZGlnIDUKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTg1CiAgICAvLyBhbW91bnQ6IHRoaXMucmV3YXJkc01icihyZXdhcmQud2lubmVyQ291bnQpCiAgICBkaWcgNgogICAgZHVwCiAgICBjb3ZlciAzCiAgICBwdXNoaW50IDQ5IC8vIDQ5CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9iYXNlLnRzOjkKICAgIC8vIHJldHVybiBNaW5Qb29sUmV3YXJkc01CUiArIChCb3hDb3N0UGVyQnl0ZSAqIHdpbm5pbmdUaWNrZXRzKQogICAgaW50YyA0IC8vIDQwMAogICAgZGlnIDEKICAgICoKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgNQogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTgyLTE4NgogICAgLy8gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiB0aGlzLnJld2FyZHNNYnIocmV3YXJkLndpbm5lckNvdW50KQogICAgLy8gfSksCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxODctMTkyCiAgICAvLyBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgIHhmZXJBc3NldDogcmV3YXJkLmFzc2V0CiAgICAvLyB9KSwKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTg5CiAgICAvLyBhc3NldFJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgZGlnIDIKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGRpZyA1CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBkaWcgOQogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxODctMTkyCiAgICAvLyBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgIHhmZXJBc3NldDogcmV3YXJkLmFzc2V0CiAgICAvLyB9KSwKICAgIHB1c2hpbnQgNCAvLyA0CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjE3OC0xOTYKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN0YWtpbmdQb29sLnByb3RvdHlwZS5hZGRSZXdhcmRBc2E+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogdGhpcy5yZXdhcmRzTWJyKHJld2FyZC53aW5uZXJDb3VudCkKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgYXNzZXRSZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgICB4ZmVyQXNzZXQ6IHJld2FyZC5hc3NldAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIHJld2FyZAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxOTUKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIGRpZyAxMQogICAgZGlnIDEzCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MTkzCiAgICAvLyByZXdhcmQKICAgIGRpZyA1CiAgICBleHRyYWN0IDggMQogICAgZGlnIDYKICAgIGV4dHJhY3QgOSA4CiAgICBkaWcgNwogICAgZXh0cmFjdCAxNyA4CiAgICB1bmNvdmVyIDgKICAgIGV4dHJhY3QgMjUgOAogICAgdW5jb3ZlciA2CiAgICBpdG9iCiAgICB1bmNvdmVyIDQKICAgIGNvbmNhdAogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIHVuY292ZXIgMwogICAgaXRvYgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoxNzgtMTk2CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdGFraW5nUG9vbC5wcm90b3R5cGUuYWRkUmV3YXJkQXNhPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IHRoaXMucmV3YXJkc01icihyZXdhcmQud2lubmVyQ291bnQpCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gICAgICAgeGZlckFzc2V0OiByZXdhcmQuYXNzZXQKICAgIC8vICAgICB9KSwKICAgIC8vICAgICByZXdhcmQKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweGEwMGNjZWM2IC8vIG1ldGhvZCAiYWRkUmV3YXJkQXNhKHBheSxheGZlciwodWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgYiBhZGRSZXdhcmRfYWZ0ZXJfaWZfZWxzZUAxMwoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbFBsdWdpbi5maW5hbGl6ZVBvb2xbcm91dGluZ10oKSAtPiB2b2lkOgpmaW5hbGl6ZVBvb2w6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMDAtMjA3CiAgICAvLyBmaW5hbGl6ZVBvb2woCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgcG9vbElEOiB1aW50NjQsCiAgICAvLyAgIHNpZ251cFRpbWVzdGFtcDogdWludDY0LAogICAgLy8gICBzdGFydFRpbWVzdGFtcDogdWludDY0LAogICAgLy8gICBlbmRUaW1lc3RhbXA6IHVpbnQ2NAogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIwOAogICAgLy8gYXNzZXJ0KEFwcGxpY2F0aW9uKHBvb2xJRCkuY3JlYXRvciA9PT0gdGhpcy5mYWN0b3J5LnZhbHVlLmFkZHJlc3MsIEVSUl9OT1RfQV9WQUxJRF9QT09MKQogICAgZGlnIDMKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcENyZWF0b3IKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyOAogICAgLy8gZmFjdG9yeSA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogUG9vbFBsdWdpbkdsb2JhbFN0YXRlS2V5RmFjdG9yeSB9KQogICAgYnl0ZWNfMCAvLyAicG9vbF9mYWN0b3J5IgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjA4CiAgICAvLyBhc3NlcnQoQXBwbGljYXRpb24ocG9vbElEKS5jcmVhdG9yID09PSB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywgRVJSX05PVF9BX1ZBTElEX1BPT0wpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBOb3QgYSB2YWxpZCBwb29sCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgNQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMTItMjIxCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdGFraW5nUG9vbC5wcm90b3R5cGUuZmluYWxpemU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogcG9vbElELAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgc2lnbnVwVGltZXN0YW1wLAogICAgLy8gICAgIHN0YXJ0VGltZXN0YW1wLAogICAgLy8gICAgIGVuZFRpbWVzdGFtcCwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIyMAogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgdW5jb3ZlciA1CiAgICB1bmNvdmVyIDYKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMTItMjIxCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdGFraW5nUG9vbC5wcm90b3R5cGUuZmluYWxpemU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogcG9vbElELAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgc2lnbnVwVGltZXN0YW1wLAogICAgLy8gICAgIHN0YXJ0VGltZXN0YW1wLAogICAgLy8gICAgIGVuZFRpbWVzdGFtcCwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDE4MWU4MjkxIC8vIG1ldGhvZCAiZmluYWxpemUodWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjAwLTIwNwogICAgLy8gZmluYWxpemVQb29sKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIHBvb2xJRDogdWludDY0LAogICAgLy8gICBzaWdudXBUaW1lc3RhbXA6IHVpbnQ2NCwKICAgIC8vICAgc3RhcnRUaW1lc3RhbXA6IHVpbnQ2NCwKICAgIC8vICAgZW5kVGltZXN0YW1wOiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjpTdGFraW5nUG9vbFBsdWdpbi5lbnRlcltyb3V0aW5nXSgpIC0+IHZvaWQ6CmVudGVyOgogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIyNC0yMzAKICAgIC8vIGVudGVyKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFwcElkOiBBcHBsaWNhdGlvbiwKICAgIC8vICAgZW50cmllczogU3Rha2VFbnRyeVtdLAogICAgLy8gICBhcmdzOiBHYXRlQXJncwogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgZHVwCiAgICBjb3ZlciAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGNvdmVyIDMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGNvdmVyIDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIzMQogICAgLy8gYXNzZXJ0KGFwcElkLmNyZWF0b3IgPT09IHRoaXMuZmFjdG9yeS52YWx1ZS5hZGRyZXNzLCBFUlJfTk9UX0FfVkFMSURfUE9PTCkKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI4CiAgICAvLyBmYWN0b3J5ID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBQb29sUGx1Z2luR2xvYmFsU3RhdGVLZXlGYWN0b3J5IH0pCiAgICBieXRlY18wIC8vICJwb29sX2ZhY3RvcnkiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMzEKICAgIC8vIGFzc2VydChhcHBJZC5jcmVhdG9yID09PSB0aGlzLmZhY3RvcnkudmFsdWUuYWRkcmVzcywgRVJSX05PVF9BX1ZBTElEX1BPT0wpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIGFzc2VydCAvLyBOb3QgYSB2YWxpZCBwb29sCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE2MS0xNjQKICAgIC8vIGNvbnN0IFtjb250cm9sbGVkQWNjb3VudEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXRJRCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNjMKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzKQogICAgcHVzaGJ5dGVzICJjb250cm9sbGVkX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE2MS0xNjQKICAgIC8vIGNvbnN0IFtjb250cm9sbGVkQWNjb3VudEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXRJRCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzEgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE2OS0xNzIKICAgIC8vIGNvbnN0IFtyZWZlcnJlckJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXRJRCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzUmVmZXJyZXIpCiAgICAvLyApCiAgICBkaWcgMwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNzEKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1JlZmVycmVyKQogICAgcHVzaGJ5dGVzICJyZWZlcnJlciIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTY5LTE3MgogICAgLy8gY29uc3QgW3JlZmVycmVyQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldElELAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNSZWZlcnJlcikKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjU4CiAgICAvLyB3YWxsZXRBZGRyZXNzOiB3YWxsZXQuYWRkcmVzcywKICAgIHVuY292ZXIgNAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNTctMjYyCiAgICAvLyByZXR1cm4gewogICAgLy8gICB3YWxsZXRBZGRyZXNzOiB3YWxsZXQuYWRkcmVzcywKICAgIC8vICAgb3JpZ2luLAogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlZmVycmVyCiAgICAvLyB9CiAgICB1bmNvdmVyIDQKICAgIGNvbmNhdAogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMzIKICAgIC8vIGNvbnN0IHsgb3JpZ2luLCBzZW5kZXIgfSA9IGdldEFjY291bnRzKHdhbGxldCkKICAgIGR1cAogICAgZXh0cmFjdCAzMiAzMgogICAgY292ZXIgMwogICAgZXh0cmFjdCA2NCAzMgogICAgZHVwCiAgICBjb3ZlciAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyMzUKICAgIC8vIGxldCB0b3RhbDogdWludDY0ID0gZW50cnlNQlIgKiBlbnRyaWVzLmxlbmd0aAogICAgdW5jb3ZlciAyCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgNTA2MDAgLy8gNTA2MDAKICAgICoKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjQzCiAgICAvLyByZXR1cm4gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KGFwcElkLCBCeXRlcyhQb29sR2xvYmFsU3RhdGVLZXlHYXRlSUQpKVswXQogICAgZGlnIDEKICAgIHB1c2hieXRlcyAiZ2F0ZV9pZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjIzOS0yNDMKICAgIC8vIGNvbnN0IGlzRW50ZXJlZCA9IGFiaUNhbGw8dHlwZW9mIFN0YWtpbmdQb29sLnByb3RvdHlwZS5pc0VudGVyZWQ+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW3NlbmRlcl0KICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICBwdXNoYnl0ZXMgMHhlMzM3NzM0MiAvLyBtZXRob2QgImlzRW50ZXJlZChhZGRyZXNzKWJvb2wiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZHVwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzMgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBCeXRlcyBoYXMgdmFsaWQgcHJlZml4CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNDUKICAgIC8vIGlmICghaXNFbnRlcmVkKSB7CiAgICBibnogZW50ZXJfYWZ0ZXJfaWZfZWxzZUA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNDYKICAgIC8vIHRvdGFsICs9IFBvb2xVbmlxdWVzTUJSCiAgICBkaWcgMQogICAgcHVzaGludCAxODkwMCAvLyAxODkwMAogICAgKwogICAgYnVyeSAyCgplbnRlcl9hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNTEKICAgIC8vIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgZGlnIDYKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIHN3YXAKICAgIGJ1cnkgMTEKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI1NQogICAgLy8gaWYgKGdhdGVJRCAhPT0gMCAmJiBhcmdzLmxlbmd0aCA+IDApIHsKICAgIGR1cAogICAgYnogZW50ZXJfZWxzZV9ib2R5QDEwCiAgICBkaWcgNAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBieiBlbnRlcl9lbHNlX2JvZHlAMTAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI1OAogICAgLy8gY29uc3QgeyBnYXRlIH0gPSBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czozMAogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzIgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI1OAogICAgLy8gY29uc3QgeyBnYXRlIH0gPSBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQwCiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBwdXNoYnl0ZXMgImFhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI1OAogICAgLy8gY29uc3QgeyBnYXRlIH0gPSBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkKICAgIHB1c2hpbnQgNDAgLy8gNDAKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNjUKICAgIC8vIGdhdGVJRCwKICAgIGRpZyAxCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNzAtMjc5CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdGFraW5nUG9vbC5wcm90b3R5cGUuZ2F0ZWRFbnRlcj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICBnYXRlVHhuLAogICAgLy8gICAgIGVudHJpZXMsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICBkaWcgMwogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGRpZyAxMQogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZGlnIDQKICAgIGR1cAogICAgY292ZXIgMgogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI0OS0yNTMKICAgIC8vIGNvbnN0IG1iclBheW1lbnQgPSBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IHRvdGFsCiAgICAvLyB9KQogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Mjc1CiAgICAvLyBnYXRlVHhuLAogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNjMKICAgIC8vIG1ldGhvZFNlbGVjdG9yPHR5cGVvZiBHYXRlLnByb3RvdHlwZS5tdXN0Q2hlY2s+KCksCiAgICBwdXNoYnl0ZXMgMHg0MzkyMjY1NSAvLyBtZXRob2QgIm11c3RDaGVjayhhZGRyZXNzLHVpbnQ2NCxieXRlW11bXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgc3dhcAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyNTktMjY4CiAgICAvLyBjb25zdCBnYXRlVHhuID0gaXR4bi5hcHBsaWNhdGlvbkNhbGwoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBnYXRlLAogICAgLy8gICBhcHBBcmdzOiBbCiAgICAvLyAgICAgbWV0aG9kU2VsZWN0b3I8dHlwZW9mIEdhdGUucHJvdG90eXBlLm11c3RDaGVjaz4oKSwKICAgIC8vICAgICBvcmlnaW4sCiAgICAvLyAgICAgZ2F0ZUlELAogICAgLy8gICAgIGVuY29kZUFyYzQoYXJncykKICAgIC8vICAgXQogICAgLy8gfSkKICAgIGludGNfMyAvLyA2CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI3MC0yNzkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN0YWtpbmdQb29sLnByb3RvdHlwZS5nYXRlZEVudGVyPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBtYnJQYXltZW50LAogICAgLy8gICAgIGdhdGVUeG4sCiAgICAvLyAgICAgZW50cmllcywKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KQogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6Mjc4CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICBkaWcgOAogICAgZGlnIDEwCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjcwLTI3OQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Rha2luZ1Bvb2wucHJvdG90eXBlLmdhdGVkRW50ZXI+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgZ2F0ZVR4biwKICAgIC8vICAgICBlbnRyaWVzLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4ZmRjZmRmZjYgLy8gbWV0aG9kICJnYXRlZEVudGVyKHBheSxhcHBsLCh1aW50NjQsdWludDY0LGJ5dGVbMzJdW10pW10pdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgZGlnIDcKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CgplbnRlcl9hZnRlcl9pZl9lbHNlQDEzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjI0LTIzMAogICAgLy8gZW50ZXIoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXBwSWQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICBlbnRyaWVzOiBTdGFrZUVudHJ5W10sCiAgICAvLyAgIGFyZ3M6IEdhdGVBcmdzCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCmVudGVyX2Vsc2VfYm9keUAxMDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N0YWtpbmctcG9vbC9jb250cmFjdC5hbGdvLnRzOjI4MS0yODkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN0YWtpbmdQb29sLnByb3RvdHlwZS5lbnRlcj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgbWJyUGF5bWVudCwKICAgIC8vICAgICBlbnRyaWVzCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGRpZyA5CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgMgogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Rha2luZy1wb29sL2NvbnRyYWN0LmFsZ28udHM6MjQ5LTI1MwogICAgLy8gY29uc3QgbWJyUGF5bWVudCA9IGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogdG90YWwKICAgIC8vIH0pCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyODEtMjg5CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdGFraW5nUG9vbC5wcm90b3R5cGUuZW50ZXI+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgZW50cmllcwogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyODgKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCkKICAgIGRpZyA4CiAgICBkaWcgMTAKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdGFraW5nLXBvb2wvY29udHJhY3QuYWxnby50czoyODEtMjg5CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdGFraW5nUG9vbC5wcm90b3R5cGUuZW50ZXI+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIG1iclBheW1lbnQsCiAgICAvLyAgICAgZW50cmllcwogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4YjgyZWQxYjMgLy8gbWV0aG9kICJlbnRlcihwYXksKHVpbnQ2NCx1aW50NjQsYnl0ZVszMl1bXSlbXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA3CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBkaWcgNwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGIgZW50ZXJfYWZ0ZXJfaWZfZWxzZUAxMwoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvYmFzZS50czo6QmFzZVN0YWtpbmdQb29sLm1icltyb3V0aW5nXSgpIC0+IHZvaWQ6Cm1icjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvYmFzZS50czoxMwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9iYXNlLnRzOjkKICAgIC8vIHJldHVybiBNaW5Qb29sUmV3YXJkc01CUiArIChCb3hDb3N0UGVyQnl0ZSAqIHdpbm5pbmdUaWNrZXRzKQogICAgaW50YyA0IC8vIDQwMAogICAgKgogICAgLy8gc21hcnRfY29udHJhY3RzL3N0YWtpbmctcG9vbC9iYXNlLnRzOjE1LTIxCiAgICAvLyByZXR1cm4gewogICAgLy8gICBlbnRyaWVzOiBQb29sRW50cmllc01CUiwKICAgIC8vICAgdW5pcXVlczogUG9vbFVuaXF1ZXNNQlIsCiAgICAvLyAgIGVudHJpZXNCeUFkZHJlc3M6IFBvb2xFbnRyaWVzQnlBZGRyZXNzTUJSLAogICAgLy8gICByZXdhcmRzOiB0aGlzLnJld2FyZHNNYnIod2lubmluZ1RpY2tldHMpLAogICAgLy8gICBkaXNidXJzZW1lbnRzOiBQb29sRGlzYnVyc2VtZW50U01CUgogICAgLy8gfQogICAgaXRvYgogICAgcHVzaGJ5dGVzIDB4MDAwMDAwMDAwMDAwNjJkNDAwMDAwMDAwMDAwMDQ5ZDQwMDAwMDAwMDAwMDA2MmQ0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvYmFzZS50czoyMAogICAgLy8gZGlzYnVyc2VtZW50czogUG9vbERpc2J1cnNlbWVudFNNQlIKICAgIHB1c2hpbnQgNjEwMCAvLyA2MTAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvc3Rha2luZy1wb29sL2Jhc2UudHM6MTUtMjEKICAgIC8vIHJldHVybiB7CiAgICAvLyAgIGVudHJpZXM6IFBvb2xFbnRyaWVzTUJSLAogICAgLy8gICB1bmlxdWVzOiBQb29sVW5pcXVlc01CUiwKICAgIC8vICAgZW50cmllc0J5QWRkcmVzczogUG9vbEVudHJpZXNCeUFkZHJlc3NNQlIsCiAgICAvLyAgIHJld2FyZHM6IHRoaXMucmV3YXJkc01icih3aW5uaW5nVGlja2V0cyksCiAgICAvLyAgIGRpc2J1cnNlbWVudHM6IFBvb2xEaXNidXJzZW1lbnRTTUJSCiAgICAvLyB9CiAgICBpdG9iCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9zdGFraW5nLXBvb2wvYmFzZS50czoxMwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICBieXRlY18zIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCg==", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyAFAAEIBpADJgQMcG9vbF9mYWN0b3J5EHNwZW5kaW5nX2FkZHJlc3MJYWtpdGFfZGFvBBUffHUxGRREMRhBADmCBwSrk6waBCbAwxwEJVLYmgTnQ5kZBCZ0enoEiHX0ZwSks+eJNhoAjgcAWAE4AYYB2wOQBAEFjgCABIjJQPg2GgCOAQASAIoCAYv+QAADMgOJi/9yCESJNhoBSSJZgQIISwEVEkRXAgA2GgJJFSQSRBc2GgNJFSQSRBeAB3ZlcnNpb25PA2coTwJnKkxnI0M2GgFJFSQSRBc2GgJJFSMSRCJTNhoDSSJZgQIISwEVEkQ2GgRJFSMSRDYaBUkVgSASRDYaBjYaB0kVJBJENhoISRUjEkQ2GglJFSQSRDYaCkkVJBJESwkpZUgiKmVEgAxzdGFraW5nX2ZlZXNlSCJbgZDbTwgyAQgiKGVESXIIRLFPArIIsgdLAbIAI7IQIrIBtk8KTwuI/x6ABCslrImyGk8KshpPCbIaTwiyGk8HshpPBrIaTwWyGk8EshpPA7IasiCyGLIAJbIQIrIBs7cBPklXBABMVwAEKxJEFSQSQzYaAUkVJBJEFzYaAkkVIxJEIlM2GgNJFSQSRBdJcgdEIihlRHIIRBJESwIpZUhMsU8CTwOI/qCABIPxR0iyGrIgshiyACWyECKyAbMjQzYaAUkVJBJEFzYaAkkVIxJEIlM2GgNJFSQSREkXcgdEIihlRElyCERPAhJESwMpZUhMsU8DTwSI/k+ABMdHj52yGk8DshqyILIYsgAlshAisgGzI0M2GgFJFSQSRBdJNhoCSRUjEkQiU0w2GgNJFSQSRBdJTgI2GgRJTgJOAzYaBUkVJBJEF04DcgdEIihlRHIIRBJETCllSExJVwAITCJbSUAAcLFLBUlyCERLBklOAoExWyEESwELSwgIsghMsgdLBUlOA7IAI7IQIrIBtksKSwyI/bNLAlcIAUsDVwkISwRXEQhPBVcZCEsIFk8EUE8DUE8CUExQTwIWUIAEcblXr7IashqyILIAshglshAisgGzI0NLBXIIREsBcABFAUAAXiIoZUSADGFraXRhX2VzY3Jvd2VIFzIQTHIIREsCcABFARQjgQRPAk0LsUsGSU4CcghETIHAPgiyCLIHSwNJsgAjshAisgG2gAQ5Tq6yshpLA7IasgCyGCWyECKyAbOxSwVJcghESwZJTgOBMVshBEsBC7IITLIHSwVJsgAjshAisgG2SwJyCERLBUlOA7IRSwmyErIUSbIAgQSyECKyAbZLC0sNiPy/SwVXCAFLBlcJCEsHVxEITwhXGQhPBhZPBFBPA1BPAlBMUE8DFlCABKAMzsayGrIasiCyALIYJbIQIrIBs0L/CTYaAUkVJBJEFzYaAkkVIxJEIlM2GgNJFSQSRBc2GgRJFSQSRDYaBUkVJBJENhoGSRUkEkRLA3IHRCIoZURyCEQSREsFKWVITLFPBU8GiPwvgAQYHoKRshpPBLIaTwOyGrIgshqyALIYJbIQIrIBsyNDIjYaAUkVJBJEF0k2GgJJFSMSRCJTTDYaA0kVJBJEF0lOAjYaBElOA04DNhoFTgNJcgdEIihlRHIIRBJESwGAEmNvbnRyb2xsZWRfYWRkcmVzc2VITEsCKWVITEsDgAhyZWZlcnJlcmVITE8EcghETwRQTwNQTwJQSVcgIE4DV0AgSU4DTwIiWYGoiwMLTgJLAYAHZ2F0ZV9pZGVITgKxgATjN3NCshpJshqyALIYJbIQIrIBs7Q+SVcEAExXAAQrEkRJFSMSRCJTQAAJSwGB1JMBCEUCSwZyCExFC0RJQQBySwQiWUEAayIqZUSAA2FhbGVIgShbSwEWsUsDsghLC7IHSwRJTgKyACOyECKyAbaABEOSJlWyGksGshqyGksGshpMshhJsgAlshAisgG2SwhLCoj62IAE/c/f9rIaSweyGrIgSweyGLIAJbIQIrIBsyNDsUsBsghLCbIHSwJJsgAjshAisgG2SwhLCoj6n4AEuC7Rs7IaSweyGrIgSweyGLIAJbIQIrIBs0L/xDYaAUkVJBJEFyEECxaAGAAAAAAAAGLUAAAAAAAASdQAAAAAAABi1ExQgdQvFlArTFCwI0M=", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var StakingPoolPluginParamsFactory = class _StakingPoolPluginParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "create":
          case "create(string,uint64,uint64)void":
            return _StakingPoolPluginParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs create ABI call params for the StakingPoolPlugin smart contract using the create(string,uint64,uint64)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params) {
        return {
          ...params,
          method: "create(string,uint64,uint64)void",
          args: Array.isArray(params.args) ? params.args : [params.args.version, params.args.factory, params.args.akitaDao]
        };
      }
    };
  }
  /**
   * Constructs a no op call for the newPool(uint64,bool,string,uint8,address,(address,string),uint64,bool,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static newPool(params) {
    return {
      ...params,
      method: "newPool(uint64,bool,string,uint8,address,(address,string),uint64,bool,uint64,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.title, params.args.type, params.args.marketplace, params.args.stakeKey, params.args.minimumStakeAmount, params.args.allowLateSignups, params.args.gateId, params.args.maxEntries]
    };
  }
  /**
   * Constructs a no op call for the initPool(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static initPool(params) {
    return {
      ...params,
      method: "initPool(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.poolId]
    };
  }
  /**
   * Constructs a no op call for the deletePool(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static deletePool(params) {
    return {
      ...params,
      method: "deletePool(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId]
    };
  }
  /**
   * Constructs a no op call for the addReward(uint64,bool,uint64,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64),uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static addReward(params) {
    return {
      ...params,
      method: "addReward(uint64,bool,uint64,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64),uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.reward, params.args.amount]
    };
  }
  /**
   * Constructs a no op call for the finalizePool(uint64,bool,uint64,uint64,uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static finalizePool(params) {
    return {
      ...params,
      method: "finalizePool(uint64,bool,uint64,uint64,uint64,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.poolId, params.args.signupTimestamp, params.args.startTimestamp, params.args.endTimestamp]
    };
  }
  /**
   * Constructs a no op call for the enter(uint64,bool,uint64,(uint64,uint64,byte[32][])[],byte[][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static enter(params) {
    return {
      ...params,
      method: "enter(uint64,bool,uint64,(uint64,uint64,byte[32][])[],byte[][])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.appId, params.args.entries, params.args.args]
    };
  }
  /**
   * Constructs a no op call for the mbr(uint64)(uint64,uint64,uint64,uint64,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static mbr(params) {
    return {
      ...params,
      method: "mbr(uint64)(uint64,uint64,uint64,uint64,uint64)",
      args: Array.isArray(params.args) ? params.args : [params.args.winningTickets]
    };
  }
};
var StakingPoolPluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `StakingPoolPluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory22({
      ...params,
      appSpec: APP_SPEC22
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC22;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new StakingPoolPluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new StakingPoolPluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the StakingPoolPlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    var _a;
    const result = await this.appFactory.deploy({
      ...params,
      createParams: ((_a = params.createParams) == null ? void 0 : _a.method) ? StakingPoolPluginParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams : void 0
    });
    return { result: result.result, appClient: new StakingPoolPluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the StakingPoolPlugin smart contract using the create(string,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params) => {
        return this.appFactory.params.create(StakingPoolPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the StakingPoolPlugin smart contract using the create(string,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params) => {
        return this.appFactory.createTransaction.create(StakingPoolPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the StakingPoolPlugin smart contract using an ABI method call using the create(string,uint64,uint64)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params) => {
        const result = await this.appFactory.send.create(StakingPoolPluginParamsFactory.create.create(params));
        return { result: { ...result.result, return: result.result.return }, appClient: new StakingPoolPluginClient(result.appClient) };
      }
    }
  };
};
var StakingPoolPluginClient = class _StakingPoolPluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient22 ? appClientOrParams : new _AppClient22({
      ...appClientOrParams,
      appSpec: APP_SPEC22
    });
  }
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue(method, returnValue) {
    return returnValue !== void 0 ? getArc56ReturnValue14(returnValue, this.appClient.getABIMethod(method), APP_SPEC22.structs) : void 0;
  }
  /**
   * Returns a new `StakingPoolPluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _StakingPoolPluginClient(await _AppClient22.fromCreatorAndName({ ...params, appSpec: APP_SPEC22 }));
  }
  /**
   * Returns an `StakingPoolPluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _StakingPoolPluginClient(await _AppClient22.fromNetwork({ ...params, appSpec: APP_SPEC22 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the StakingPoolPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `newPool(uint64,bool,string,uint8,address,(address,string),uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    newPool: (params) => {
      return this.appClient.params.call(StakingPoolPluginParamsFactory.newPool(params));
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `initPool(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    initPool: (params) => {
      return this.appClient.params.call(StakingPoolPluginParamsFactory.initPool(params));
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `deletePool(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    deletePool: (params) => {
      return this.appClient.params.call(StakingPoolPluginParamsFactory.deletePool(params));
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `addReward(uint64,bool,uint64,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64),uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    addReward: (params) => {
      return this.appClient.params.call(StakingPoolPluginParamsFactory.addReward(params));
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `finalizePool(uint64,bool,uint64,uint64,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    finalizePool: (params) => {
      return this.appClient.params.call(StakingPoolPluginParamsFactory.finalizePool(params));
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `enter(uint64,bool,uint64,(uint64,uint64,byte[32][])[],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    enter: (params) => {
      return this.appClient.params.call(StakingPoolPluginParamsFactory.enter(params));
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params: the mbr created for each boxmap entry
     */
    mbr: (params) => {
      return this.appClient.params.call(StakingPoolPluginParamsFactory.mbr(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the StakingPoolPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `newPool(uint64,bool,string,uint8,address,(address,string),uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    newPool: (params) => {
      return this.appClient.createTransaction.call(StakingPoolPluginParamsFactory.newPool(params));
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `initPool(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    initPool: (params) => {
      return this.appClient.createTransaction.call(StakingPoolPluginParamsFactory.initPool(params));
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `deletePool(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    deletePool: (params) => {
      return this.appClient.createTransaction.call(StakingPoolPluginParamsFactory.deletePool(params));
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `addReward(uint64,bool,uint64,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64),uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    addReward: (params) => {
      return this.appClient.createTransaction.call(StakingPoolPluginParamsFactory.addReward(params));
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `finalizePool(uint64,bool,uint64,uint64,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    finalizePool: (params) => {
      return this.appClient.createTransaction.call(StakingPoolPluginParamsFactory.finalizePool(params));
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `enter(uint64,bool,uint64,(uint64,uint64,byte[32][])[],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    enter: (params) => {
      return this.appClient.createTransaction.call(StakingPoolPluginParamsFactory.enter(params));
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: the mbr created for each boxmap entry
     */
    mbr: (params) => {
      return this.appClient.createTransaction.call(StakingPoolPluginParamsFactory.mbr(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the StakingPoolPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `newPool(uint64,bool,string,uint8,address,(address,string),uint64,bool,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    newPool: async (params) => {
      const result = await this.appClient.send.call(StakingPoolPluginParamsFactory.newPool(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `initPool(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    initPool: async (params) => {
      const result = await this.appClient.send.call(StakingPoolPluginParamsFactory.initPool(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `deletePool(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    deletePool: async (params) => {
      const result = await this.appClient.send.call(StakingPoolPluginParamsFactory.deletePool(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `addReward(uint64,bool,uint64,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64),uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    addReward: async (params) => {
      const result = await this.appClient.send.call(StakingPoolPluginParamsFactory.addReward(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `finalizePool(uint64,bool,uint64,uint64,uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    finalizePool: async (params) => {
      const result = await this.appClient.send.call(StakingPoolPluginParamsFactory.finalizePool(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `enter(uint64,bool,uint64,(uint64,uint64,byte[32][])[],byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    enter: async (params) => {
      const result = await this.appClient.send.call(StakingPoolPluginParamsFactory.enter(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the StakingPoolPlugin smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result: the mbr created for each boxmap entry
     */
    mbr: async (params) => {
      const result = await this.appClient.send.call(StakingPoolPluginParamsFactory.mbr(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _StakingPoolPluginClient(this.appClient.clone(params));
  }
  /**
   * Makes a readonly (simulated) call to the StakingPoolPlugin smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result: the mbr created for each boxmap entry
   */
  async mbr(params) {
    const result = await this.appClient.send.call(StakingPoolPluginParamsFactory.mbr(params));
    return result.return;
  }
  /**
   * Methods to access state for the current StakingPoolPlugin app
   */
  state = {
    /**
     * Methods to access global state for the current StakingPoolPlugin app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async () => {
        const result = await this.appClient.state.global.getAll();
        return {
          version: result.version,
          factory: result.factory,
          akitaDao: result.akitaDAO
        };
      },
      /**
       * Get the current value of the version key in global state
       */
      version: async () => {
        return await this.appClient.state.global.getValue("version");
      },
      /**
       * Get the current value of the factory key in global state
       */
      factory: async () => {
        return await this.appClient.state.global.getValue("factory");
      },
      /**
       * Get the current value of the akitaDAO key in global state
       */
      akitaDao: async () => {
        return await this.appClient.state.global.getValue("akitaDAO");
      }
    }
  };
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a newPool(uint64,bool,string,uint8,address,(address,string),uint64,bool,uint64,uint64)void method call against the StakingPoolPlugin contract
       */
      newPool(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.newPool(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a initPool(uint64,bool,uint64)void method call against the StakingPoolPlugin contract
       */
      initPool(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.initPool(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a deletePool(uint64,bool,uint64)void method call against the StakingPoolPlugin contract
       */
      deletePool(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.deletePool(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a addReward(uint64,bool,uint64,(uint64,uint8,uint64,uint64,uint64,uint64,uint64,uint64,uint64[],(uint64,uint64,uint64),uint64,uint8,uint64,uint64,uint64,uint64),uint64)void method call against the StakingPoolPlugin contract
       */
      addReward(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.addReward(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a finalizePool(uint64,bool,uint64,uint64,uint64,uint64)void method call against the StakingPoolPlugin contract
       */
      finalizePool(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.finalizePool(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a enter(uint64,bool,uint64,(uint64,uint64,byte[32][])[],byte[][])void method call against the StakingPoolPlugin contract
       */
      enter(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.enter(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a mbr(uint64)(uint64,uint64,uint64,uint64,uint64) method call against the StakingPoolPlugin contract
       */
      mbr(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.mbr(params)));
        resultMappers.push((v) => client.decodeReturnValue("mbr(uint64)(uint64,uint64,uint64,uint64,uint64)", v));
        return this;
      },
      /**
       * Add a clear state call to the StakingPoolPlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/staking-pool.ts
var StakingPoolPluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: StakingPoolPluginFactory, ...params });
  }
  newPool(args) {
    const methodName = "newPool";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.newPool({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  initPool(args) {
    const methodName = "initPool";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.initPool({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  deletePool(args) {
    const methodName = "deletePool";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.deletePool({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  addReward(args) {
    const methodName = "addReward";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.addReward({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  finalizePool(args) {
    const methodName = "finalizePool";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.finalizePool({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  enter(args) {
    const methodName = "enter";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.enter({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
};

// src/generated/SubscriptionsPluginClient.ts
import { getArc56ReturnValue as getArc56ReturnValue15, getABIStructFromABITuple as getABIStructFromABITuple15 } from "@algorandfoundation/algokit-utils/types/app-arc56";
import {
  AppClient as _AppClient23
} from "@algorandfoundation/algokit-utils/types/app-client";
import { AppFactory as _AppFactory23 } from "@algorandfoundation/algokit-utils/types/app-factory";
var APP_SPEC23 = { "name": "SubscriptionsPlugin", "structs": { "SubscriptionKey": [{ "name": "address", "type": "address" }, { "name": "id", "type": "uint64" }] }, "methods": [{ "name": "create", "args": [{ "type": "uint64", "name": "akitaDAO" }, { "type": "string", "name": "version" }], "returns": { "type": "void" }, "actions": { "create": ["NoOp"], "call": [] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "optIn", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "asset" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "initDescription", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "uint64", "name": "size" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "loadDescription", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "uint64", "name": "offset" }, { "type": "byte[]", "name": "data" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "newService", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "interval" }, { "type": "uint64", "name": "asset" }, { "type": "uint64", "name": "amount" }, { "type": "uint64", "name": "passes" }, { "type": "uint64", "name": "gate" }, { "type": "string", "name": "title" }, { "type": "byte[36]", "name": "bannerImage" }, { "type": "uint8", "name": "highlightMessage" }, { "type": "byte[3]", "name": "highlightColor" }], "returns": { "type": "uint64" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "pauseService", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "id" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "shutdownService", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "index" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "block", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "address", "name": "address" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "unblock", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "address", "name": "address" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "subscribe", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "asset" }, { "type": "address", "name": "recipient" }, { "type": "uint64", "name": "amount" }, { "type": "uint64", "name": "interval" }, { "type": "uint64", "name": "index" }, { "type": "byte[][]", "name": "args" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "triggerPayment", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "address", "name": "address" }, { "type": "uint64", "name": "id" }, { "type": "byte[][]", "name": "args" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "streakCheck", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "(address,uint64)", "struct": "SubscriptionKey", "name": "key" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "setPasses", "args": [{ "type": "uint64", "name": "wallet" }, { "type": "bool", "name": "rekeyBack" }, { "type": "uint64", "name": "id" }, { "type": "address[]", "name": "addresses" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "updateAkitaDAO", "args": [{ "type": "uint64", "name": "akitaDAO" }], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }, { "name": "opUp", "args": [], "returns": { "type": "void" }, "actions": { "create": [], "call": ["NoOp"] }, "readonly": false, "events": [], "recommendations": {} }], "arcs": [22, 28], "networks": {}, "state": { "schema": { "global": { "ints": 1, "bytes": 1 }, "local": { "ints": 0, "bytes": 0 } }, "keys": { "global": { "version": { "keyType": "AVMString", "valueType": "AVMString", "key": "dmVyc2lvbg==", "desc": "the current version of the contract" }, "akitaDAO": { "keyType": "AVMString", "valueType": "AVMUint64", "key": "YWtpdGFfZGFv", "desc": "the app ID of the Akita DAO" } }, "local": {}, "box": { "description": { "keyType": "AVMString", "valueType": "AVMBytes", "key": "ZA==" } } }, "maps": { "global": {}, "local": {}, "box": {} } }, "bareActions": { "create": [], "call": [] }, "sourceInfo": { "approval": { "sourceInfo": [{ "pc": [870], "errorMessage": "Box must have value" }, { "pc": [781, 1037, 1635, 1736, 1887, 2009, 2132, 2225, 2365, 2457], "errorMessage": "Bytes has valid prefix" }, { "pc": [392, 460], "errorMessage": "Description length exceeds maximum" }, { "pc": [529], "errorMessage": "Description not initialized" }, { "pc": [523, 722], "errorMessage": "Invalid call order" }, { "pc": [91], "errorMessage": "OnCompletion must be NoOp" }, { "pc": [2797], "errorMessage": "Only the Akita DAO can call this function" }, { "pc": [229, 319, 793, 1305, 1549, 1663, 1752, 1776, 1900, 2028, 2052, 2146, 2795], "errorMessage": "application exists" }, { "pc": [308, 726, 1138, 1216, 1294, 1395, 1574, 1660, 1689, 2294, 2310, 2627, 2722, 2782], "errorMessage": "check GlobalState exists" }, { "pc": [2462], "errorMessage": "invalid number of bytes for (bool1,uint8[32],uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)" }, { "pc": [2712], "errorMessage": "invalid number of bytes for (len+uint8[32][])" }, { "pc": [445, 2375], "errorMessage": "invalid number of bytes for (len+uint8[])" }, { "pc": [253, 631], "errorMessage": "invalid number of bytes for (len+utf8[])" }, { "pc": [2617], "errorMessage": "invalid number of bytes for (uint8[32],uint64)" }, { "pc": [289, 562, 1118, 1196, 1274, 1374, 1454, 1640, 2255, 2606, 2685], "errorMessage": "invalid number of bytes for bool8" }, { "pc": [238, 280, 299, 377, 385, 421, 429, 552, 575, 585, 595, 605, 615, 786, 1042, 1109, 1128, 1187, 1206, 1265, 1365, 1444, 1467, 1492, 1505, 1515, 1891, 2013, 2136, 2229, 2245, 2277, 2597, 2676, 2695, 2775], "errorMessage": "invalid number of bytes for uint64" }, { "pc": [652], "errorMessage": "invalid number of bytes for uint8" }, { "pc": [1285, 1385, 1481, 2269], "errorMessage": "invalid number of bytes for uint8[32]" }, { "pc": [642], "errorMessage": "invalid number of bytes for uint8[36]" }, { "pc": [663], "errorMessage": "invalid number of bytes for uint8[3]" }], "pcOffsetMethod": "none" }, "clear": { "sourceInfo": [], "pcOffsetMethod": "none" } }, "source": { "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDggNiAyMDM0CiAgICBieXRlY2Jsb2NrICJha2l0YV9kYW8iICJhYWwiIDB4MTUxZjdjNzUgInNwZW5kaW5nX2FkZHJlc3MiICJkIiAweDE3OTVhMGQwIDB4NDM5MjI2NTUgMHhkMTA3OWNhZSAweGNmMTYwMTFkICJjb250cm9sbGVkX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MjAKICAgIC8vIGV4cG9ydCBjbGFzcyBTdWJzY3JpcHRpb25zUGx1Z2luIGV4dGVuZHMgY2xhc3NlcyhCYXNlU3Vic2NyaXB0aW9ucywgQWtpdGFCYXNlQ29udHJhY3QpIHsKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gbXVzdCBiZSBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYnogbWFpbl9jcmVhdGVfTm9PcEAyMAogICAgcHVzaGJ5dGVzIDB4YmE5NzNjZDAgLy8gbWV0aG9kICJvcHRJbih1aW50NjQsYm9vbCx1aW50NjQpdm9pZCIKICAgIGJ5dGVjIDcgLy8gbWV0aG9kICJpbml0RGVzY3JpcHRpb24odWludDY0LHVpbnQ2NCl2b2lkIgogICAgYnl0ZWMgOCAvLyBtZXRob2QgImxvYWREZXNjcmlwdGlvbih1aW50NjQsdWludDY0LGJ5dGVbXSl2b2lkIgogICAgcHVzaGJ5dGVzcyAweGZlYmY4NWYxIDB4MzlhM2FlNDcgMHgxOWIxZmMyYiAweGJlYzg2YzM0IDB4OWY1OWE5NzAgMHhjOWNjYTQ1YyAweDIzZTMzN2JkIDB4ZWEyMTc4YWEgMHgxYzQyNDYxYiAweDMzZTkyYzk0IDB4ODU0ZGVkZTAgLy8gbWV0aG9kICJuZXdTZXJ2aWNlKHVpbnQ2NCxib29sLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsc3RyaW5nLGJ5dGVbMzZdLHVpbnQ4LGJ5dGVbM10pdWludDY0IiwgbWV0aG9kICJwYXVzZVNlcnZpY2UodWludDY0LGJvb2wsdWludDY0KXZvaWQiLCBtZXRob2QgInNodXRkb3duU2VydmljZSh1aW50NjQsYm9vbCx1aW50NjQpdm9pZCIsIG1ldGhvZCAiYmxvY2sodWludDY0LGJvb2wsYWRkcmVzcyl2b2lkIiwgbWV0aG9kICJ1bmJsb2NrKHVpbnQ2NCxib29sLGFkZHJlc3Mpdm9pZCIsIG1ldGhvZCAic3Vic2NyaWJlKHVpbnQ2NCxib29sLHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LGJ5dGVbXVtdKXZvaWQiLCBtZXRob2QgInRyaWdnZXJQYXltZW50KHVpbnQ2NCxib29sLGFkZHJlc3MsdWludDY0LGJ5dGVbXVtdKXZvaWQiLCBtZXRob2QgInN0cmVha0NoZWNrKHVpbnQ2NCxib29sLChhZGRyZXNzLHVpbnQ2NCkpdm9pZCIsIG1ldGhvZCAic2V0UGFzc2VzKHVpbnQ2NCxib29sLHVpbnQ2NCxhZGRyZXNzW10pdm9pZCIsIG1ldGhvZCAidXBkYXRlQWtpdGFEQU8odWludDY0KXZvaWQiLCBtZXRob2QgIm9wVXAoKXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBvcHRJbiBpbml0RGVzY3JpcHRpb24gbG9hZERlc2NyaXB0aW9uIG5ld1NlcnZpY2UgcGF1c2VTZXJ2aWNlIHNodXRkb3duU2VydmljZSBibG9jayB1bmJsb2NrIHN1YnNjcmliZSB0cmlnZ2VyUGF5bWVudCBzdHJlYWtDaGVjayBzZXRQYXNzZXMgdXBkYXRlQWtpdGFEQU8gbWFpbl9vcFVwX3JvdXRlQDE4CiAgICBlcnIKCm1haW5fb3BVcF9yb3V0ZUAxODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjQzCiAgICAvLyBvcFVwKCk6IHZvaWQgeyB9CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2NyZWF0ZV9Ob09wQDIwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjIwCiAgICAvLyBleHBvcnQgY2xhc3MgU3Vic2NyaXB0aW9uc1BsdWdpbiBleHRlbmRzIGNsYXNzZXMoQmFzZVN1YnNjcmlwdGlvbnMsIEFraXRhQmFzZUNvbnRyYWN0KSB7CiAgICBwdXNoYnl0ZXMgMHg2Zjk4MTdmNiAvLyBtZXRob2QgImNyZWF0ZSh1aW50NjQsc3RyaW5nKXZvaWQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBjcmVhdGUKICAgIGVycgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6OnJla2V5QWRkcmVzcyhyZWtleUJhY2s6IHVpbnQ2NCwgd2FsbGV0OiB1aW50NjQpIC0+IGJ5dGVzOgpyZWtleUFkZHJlc3M6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMQogICAgLy8gZXhwb3J0IGZ1bmN0aW9uIHJla2V5QWRkcmVzcyhyZWtleUJhY2s6IGJvb2xlYW4sIHdhbGxldDogQXBwbGljYXRpb24pOiBBY2NvdW50IHsKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czozMjIKICAgIC8vIGlmICghcmVrZXlCYWNrKSB7CiAgICBmcmFtZV9kaWcgLTIKICAgIGJueiByZWtleUFkZHJlc3NfYWZ0ZXJfaWZfZWxzZUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyMwogICAgLy8gcmV0dXJuIEdsb2JhbC56ZXJvQWRkcmVzcwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICByZXRzdWIKCnJla2V5QWRkcmVzc19hZnRlcl9pZl9lbHNlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjMyNgogICAgLy8gcmV0dXJuIHdhbGxldC5hZGRyZXNzCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo6U3Vic2NyaXB0aW9uc1BsdWdpbi5jcmVhdGVbcm91dGluZ10oKSAtPiB2b2lkOgpjcmVhdGU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MjcKICAgIC8vIEBhYmltZXRob2QoeyBvbkNyZWF0ZTogJ3JlcXVpcmUnIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIHB1c2hpbnQgMiAvLyAyCiAgICArCiAgICBkaWcgMQogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3V0ZjhbXSkKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyNwogICAgLy8gdmVyc2lvbiA9IEdsb2JhbFN0YXRlPHN0cmluZz4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5VmVyc2lvbiB9KQogICAgcHVzaGJ5dGVzICJ2ZXJzaW9uIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjI5CiAgICAvLyB0aGlzLnZlcnNpb24udmFsdWUgPSB2ZXJzaW9uCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MzAKICAgIC8vIHRoaXMuYWtpdGFEQU8udmFsdWUgPSBBcHBsaWNhdGlvbihha2l0YURBTykKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MjcKICAgIC8vIEBhYmltZXRob2QoeyBvbkNyZWF0ZTogJ3JlcXVpcmUnIH0pCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjpTdWJzY3JpcHRpb25zUGx1Z2luLm9wdEluW3JvdXRpbmddKCkgLT4gdm9pZDoKb3B0SW46CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MzUtMzkKICAgIC8vIG9wdEluKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFzc2V0OiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgMgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjgKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIGJ5dGVjXzMgLy8gInNwZW5kaW5nX2FkZHJlc3MiCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2Ni0yNjkKICAgIC8vIGNvbnN0IFtzcGVuZGluZ0FkZHJlc3NCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0LAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICAvLyApCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NDIKICAgIC8vIGNvbnN0IGFwcElkID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN1YnNjcmlwdGlvbnMpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NDIKICAgIC8vIGNvbnN0IGFwcElkID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN1YnNjcmlwdGlvbnMpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMSAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjQyCiAgICAvLyBjb25zdCBhcHBJZCA9IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdWJzY3JpcHRpb25zKQogICAgcHVzaGludCAzMiAvLyAzMgogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo0NC01NgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUub3B0SW4+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlLAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIEFzc2V0KGFzc2V0KSwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NTAKICAgIC8vIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NTEKICAgIC8vIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlLAogICAgZ2xvYmFsIEFzc2V0T3B0SW5NaW5CYWxhbmNlCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NDgtNTIKICAgIC8vIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlLAogICAgLy8gfSksCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NDQtNTYKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLm9wdEluPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZSwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBBc3NldChhc3NldCksCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NTUKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgNAogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo0NC01NgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUub3B0SW4+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogR2xvYmFsLmFzc2V0T3B0SW5NaW5CYWxhbmNlLAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIEFzc2V0KGFzc2V0KSwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHgzOTRlYWViMiAvLyBtZXRob2QgIm9wdEluKHBheSx1aW50NjQpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MzUtMzkKICAgIC8vIG9wdEluKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFzc2V0OiB1aW50NjQKICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo6U3Vic2NyaXB0aW9uc1BsdWdpbi5pbml0RGVzY3JpcHRpb25bcm91dGluZ10oKSAtPiB2b2lkOgppbml0RGVzY3JpcHRpb246CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NTkKICAgIC8vIGluaXREZXNjcmlwdGlvbih3YWxsZXQ6IEFwcGxpY2F0aW9uLCBzaXplOiB1aW50NjQpOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjYwCiAgICAvLyBhc3NlcnQoc2l6ZSA8PSBNQVhfREVTQ1JJUFRJT05fTEVOR1RILCBFUlJfQkFEX0RFU0NSSVBUSU9OX0xFTkdUSCkKICAgIHB1c2hpbnQgMzE1MSAvLyAzMTUxCiAgICA8PQogICAgYXNzZXJ0IC8vIERlc2NyaXB0aW9uIGxlbmd0aCBleGNlZWRzIG1heGltdW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoyMwogICAgLy8gZGVzY3JpcHRpb24gPSBCb3g8Ynl0ZXM+KHsga2V5OiBCb3hLZXlTdWJzY3JpcHRpb25zRGVzY3JpcHRpb24gfSkKICAgIGJ5dGVjIDQgLy8gImQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NjEKICAgIC8vIGlmICghdGhpcy5kZXNjcmlwdGlvbi5leGlzdHMpIHsKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYm56IGluaXREZXNjcmlwdGlvbl9lbHNlX2JvZHlAMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjIzCiAgICAvLyBkZXNjcmlwdGlvbiA9IEJveDxieXRlcz4oeyBrZXk6IEJveEtleVN1YnNjcmlwdGlvbnNEZXNjcmlwdGlvbiB9KQogICAgYnl0ZWMgNCAvLyAiZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo2MgogICAgLy8gdGhpcy5kZXNjcmlwdGlvbi5jcmVhdGUoeyBzaXplIH0pCiAgICBzd2FwCiAgICBib3hfY3JlYXRlCiAgICBwb3AKCmluaXREZXNjcmlwdGlvbl9hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NTkKICAgIC8vIGluaXREZXNjcmlwdGlvbih3YWxsZXQ6IEFwcGxpY2F0aW9uLCBzaXplOiB1aW50NjQpOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCmluaXREZXNjcmlwdGlvbl9lbHNlX2JvZHlAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoyMwogICAgLy8gZGVzY3JpcHRpb24gPSBCb3g8Ynl0ZXM+KHsga2V5OiBCb3hLZXlTdWJzY3JpcHRpb25zRGVzY3JpcHRpb24gfSkKICAgIGJ5dGVjIDQgLy8gImQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NjQKICAgIC8vIHRoaXMuZGVzY3JpcHRpb24ucmVzaXplKHNpemUpCiAgICBzd2FwCiAgICBib3hfcmVzaXplCiAgICBiIGluaXREZXNjcmlwdGlvbl9hZnRlcl9pZl9lbHNlQDQKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6OlN1YnNjcmlwdGlvbnNQbHVnaW4ubG9hZERlc2NyaXB0aW9uW3JvdXRpbmddKCkgLT4gdm9pZDoKbG9hZERlc2NyaXB0aW9uOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjY4CiAgICAvLyBsb2FkRGVzY3JpcHRpb24od2FsbGV0OiBBcHBsaWNhdGlvbiwgb2Zmc2V0OiB1aW50NjQsIGRhdGE6IGJ5dGVzKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1aW50OFtdKQogICAgZXh0cmFjdCAyIDAKICAgIGR1cAogICAgY292ZXIgMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjY5CiAgICAvLyBhc3NlcnQob2Zmc2V0ICsgZGF0YS5sZW5ndGggPD0gTUFYX0RFU0NSSVBUSU9OX0xFTkdUSCwgRVJSX0JBRF9ERVNDUklQVElPTl9MRU5HVEgpCiAgICBsZW4KICAgIGRpZyAxCiAgICArCiAgICBwdXNoaW50IDMxNTEgLy8gMzE1MQogICAgPD0KICAgIGFzc2VydCAvLyBEZXNjcmlwdGlvbiBsZW5ndGggZXhjZWVkcyBtYXhpbXVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NzAKICAgIC8vIGNvbnN0IGV4cGVjdGVkUHJldmlvdXNDYWxsczogdWludDY0ID0gb2Zmc2V0IC8gTUFYX0xPQURfREVTQ1JJUFRJT05fQ0hVTktfU0laRQogICAgcHVzaGludCAyMDI2IC8vIDIwMjYKICAgIC8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo3MQogICAgLy8gY29uc3QgdHhuID0gZ3R4bi5UcmFuc2FjdGlvbihUeG4uZ3JvdXBJbmRleCAtIGV4cGVjdGVkUHJldmlvdXNDYWxscyAtIDEpCiAgICB0eG4gR3JvdXBJbmRleAogICAgc3dhcAogICAgLQogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjczCiAgICAvLyB0eG4udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFwcGxpY2F0aW9uQ2FsbAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMyAvLyA2CiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjczLTc0CiAgICAvLyB0eG4udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFwcGxpY2F0aW9uQ2FsbAogICAgLy8gJiYgdHhuLmFwcElkID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQKICAgIGJ6IGxvYWREZXNjcmlwdGlvbl9ib29sX2ZhbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo3NAogICAgLy8gJiYgdHhuLmFwcElkID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQKICAgIGR1cAogICAgZ3R4bnMgQXBwbGljYXRpb25JRAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjczLTc0CiAgICAvLyB0eG4udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFwcGxpY2F0aW9uQ2FsbAogICAgLy8gJiYgdHhuLmFwcElkID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQKICAgIGJ6IGxvYWREZXNjcmlwdGlvbl9ib29sX2ZhbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo3NQogICAgLy8gJiYgdHhuLm51bUFwcEFyZ3MgPT09IDMKICAgIGR1cAogICAgZ3R4bnMgTnVtQXBwQXJncwogICAgcHVzaGludCAzIC8vIDMKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NzMtNzUKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgLy8gJiYgdHhuLm51bUFwcEFyZ3MgPT09IDMKICAgIGJ6IGxvYWREZXNjcmlwdGlvbl9ib29sX2ZhbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo3NgogICAgLy8gJiYgdHhuLm9uQ29tcGxldGlvbiA9PT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wCiAgICBkdXAKICAgIGd0eG5zIE9uQ29tcGxldGlvbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjczLTc2CiAgICAvLyB0eG4udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFwcGxpY2F0aW9uQ2FsbAogICAgLy8gJiYgdHhuLmFwcElkID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQKICAgIC8vICYmIHR4bi5udW1BcHBBcmdzID09PSAzCiAgICAvLyAmJiB0eG4ub25Db21wbGV0aW9uID09PSBPbkNvbXBsZXRlQWN0aW9uLk5vT3AKICAgIGJueiBsb2FkRGVzY3JpcHRpb25fYm9vbF9mYWxzZUA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NzcKICAgIC8vICYmIHR4bi5hcHBBcmdzKDApID09PSBtZXRob2RTZWxlY3Rvcih0aGlzLmluaXREZXNjcmlwdGlvbikKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGd0eG5zYXMgQXBwbGljYXRpb25BcmdzCiAgICBieXRlYyA3IC8vIG1ldGhvZCAiaW5pdERlc2NyaXB0aW9uKHVpbnQ2NCx1aW50NjQpdm9pZCIKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NzMtNzcKICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsCiAgICAvLyAmJiB0eG4uYXBwSWQgPT09IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZAogICAgLy8gJiYgdHhuLm51bUFwcEFyZ3MgPT09IDMKICAgIC8vICYmIHR4bi5vbkNvbXBsZXRpb24gPT09IE9uQ29tcGxldGVBY3Rpb24uTm9PcAogICAgLy8gJiYgdHhuLmFwcEFyZ3MoMCkgPT09IG1ldGhvZFNlbGVjdG9yKHRoaXMuaW5pdERlc2NyaXB0aW9uKQogICAgYnogbG9hZERlc2NyaXB0aW9uX2Jvb2xfZmFsc2VAOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjc4CiAgICAvLyAmJiB0eG4uc2VuZGVyID09PSBUeG4uc2VuZGVyCiAgICBkdXAKICAgIGd0eG5zIFNlbmRlcgogICAgdHhuIFNlbmRlcgogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo3My03OAogICAgLy8gdHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vICYmIHR4bi5hcHBJZCA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkCiAgICAvLyAmJiB0eG4ubnVtQXBwQXJncyA9PT0gMwogICAgLy8gJiYgdHhuLm9uQ29tcGxldGlvbiA9PT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wCiAgICAvLyAmJiB0eG4uYXBwQXJncygwKSA9PT0gbWV0aG9kU2VsZWN0b3IodGhpcy5pbml0RGVzY3JpcHRpb24pCiAgICAvLyAmJiB0eG4uc2VuZGVyID09PSBUeG4uc2VuZGVyCiAgICBieiBsb2FkRGVzY3JpcHRpb25fYm9vbF9mYWxzZUA4CiAgICBpbnRjXzEgLy8gMQoKbG9hZERlc2NyaXB0aW9uX2Jvb2xfbWVyZ2VAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo3Mi03OQogICAgLy8gYXNzZXJ0KCgKICAgIC8vICAgdHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwKICAgIC8vICAgJiYgdHhuLmFwcElkID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQKICAgIC8vICAgJiYgdHhuLm51bUFwcEFyZ3MgPT09IDMKICAgIC8vICAgJiYgdHhuLm9uQ29tcGxldGlvbiA9PT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wCiAgICAvLyAgICYmIHR4bi5hcHBBcmdzKDApID09PSBtZXRob2RTZWxlY3Rvcih0aGlzLmluaXREZXNjcmlwdGlvbikKICAgIC8vICAgJiYgdHhuLnNlbmRlciA9PT0gVHhuLnNlbmRlcgogICAgLy8gKSwgRVJSX0lOVkFMSURfQ0FMTF9PUkRFUikKICAgIGFzc2VydCAvLyBJbnZhbGlkIGNhbGwgb3JkZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoyMwogICAgLy8gZGVzY3JpcHRpb24gPSBCb3g8Ynl0ZXM+KHsga2V5OiBCb3hLZXlTdWJzY3JpcHRpb25zRGVzY3JpcHRpb24gfSkKICAgIGJ5dGVjIDQgLy8gImQiCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6ODAKICAgIC8vIGFzc2VydCh0aGlzLmRlc2NyaXB0aW9uLmV4aXN0cywgRVJSX0RFU0NSSVBUSU9OX05PVF9JTklUSUFMSVpFRCkKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIERlc2NyaXB0aW9uIG5vdCBpbml0aWFsaXplZAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjIzCiAgICAvLyBkZXNjcmlwdGlvbiA9IEJveDxieXRlcz4oeyBrZXk6IEJveEtleVN1YnNjcmlwdGlvbnNEZXNjcmlwdGlvbiB9KQogICAgYnl0ZWMgNCAvLyAiZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo4MgogICAgLy8gdGhpcy5kZXNjcmlwdGlvbi5yZXBsYWNlKG9mZnNldCwgZGF0YSkKICAgIGRpZyAzCiAgICBkaWcgMwogICAgYm94X3JlcGxhY2UKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo2OAogICAgLy8gbG9hZERlc2NyaXB0aW9uKHdhbGxldDogQXBwbGljYXRpb24sIG9mZnNldDogdWludDY0LCBkYXRhOiBieXRlcyk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbG9hZERlc2NyaXB0aW9uX2Jvb2xfZmFsc2VAODoKICAgIGludGNfMCAvLyAwCiAgICBiIGxvYWREZXNjcmlwdGlvbl9ib29sX21lcmdlQDkKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6OlN1YnNjcmlwdGlvbnNQbHVnaW4ubmV3U2VydmljZVtyb3V0aW5nXSgpIC0+IHZvaWQ6Cm5ld1NlcnZpY2U6CiAgICBwdXNoYnl0ZXMgIiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo4NS05NwogICAgLy8gbmV3U2VydmljZSgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBpbnRlcnZhbDogdWludDY0LAogICAgLy8gICBhc3NldDogdWludDY0LAogICAgLy8gICBhbW91bnQ6IHVpbnQ2NCwKICAgIC8vICAgcGFzc2VzOiB1aW50NjQsCiAgICAvLyAgIGdhdGU6IHVpbnQ2NCwKICAgIC8vICAgdGl0bGU6IHN0cmluZywKICAgIC8vICAgYmFubmVySW1hZ2U6IENJRCwKICAgIC8vICAgaGlnaGxpZ2h0TWVzc2FnZTogVWludDgsCiAgICAvLyAgIGhpZ2hsaWdodENvbG9yOiBieXRlczwzPgogICAgLy8gKTogdWludDY0IHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHN3YXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgY292ZXIgMgogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDYKICAgIGR1cAogICAgY292ZXIgMgogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA3CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgOAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgcHVzaGludCAyIC8vIDIKICAgICsKICAgIHN3YXAKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1dGY4W10pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA5CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGxlbgogICAgcHVzaGludCAzNiAvLyAzNgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzZdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxMAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMTEKICAgIGR1cAogICAgY292ZXIgMgogICAgbGVuCiAgICBwdXNoaW50IDMgLy8gMwogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbM10KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18zIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjEwMAogICAgLy8gY29uc3QgdHhuID0gZ3R4bi5UcmFuc2FjdGlvbihUeG4uZ3JvdXBJbmRleCAtIDEpCiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxMDMKICAgIC8vIFR4bi5ncm91cEluZGV4ID4gMiAmJiAvLyBbYXJjNThfcmVrZXlUb1BsdWdpbiwgaW5pdERlc2NyaXB0aW9uLCBsb2FkRGVzY3JpcHRpb25dCiAgICB0eG4gR3JvdXBJbmRleAogICAgcHVzaGludCAyIC8vIDIKICAgID4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxMDMtMTA0CiAgICAvLyBUeG4uZ3JvdXBJbmRleCA+IDIgJiYgLy8gW2FyYzU4X3Jla2V5VG9QbHVnaW4sIGluaXREZXNjcmlwdGlvbiwgbG9hZERlc2NyaXB0aW9uXQogICAgLy8gdHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwgJiYKICAgIGJ6IG5ld1NlcnZpY2VfYm9vbF9mYWxzZUA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MTA0CiAgICAvLyB0eG4udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFwcGxpY2F0aW9uQ2FsbCAmJgogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18zIC8vIDYKICAgID09CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MTAzLTEwNAogICAgLy8gVHhuLmdyb3VwSW5kZXggPiAyICYmIC8vIFthcmM1OF9yZWtleVRvUGx1Z2luLCBpbml0RGVzY3JpcHRpb24sIGxvYWREZXNjcmlwdGlvbl0KICAgIC8vIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsICYmCiAgICBieiBuZXdTZXJ2aWNlX2Jvb2xfZmFsc2VAOAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjEwNQogICAgLy8gdHhuLmFwcElkID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQgJiYKICAgIGR1cAogICAgZ3R4bnMgQXBwbGljYXRpb25JRAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECiAgICA9PQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjEwMy0xMDUKICAgIC8vIFR4bi5ncm91cEluZGV4ID4gMiAmJiAvLyBbYXJjNThfcmVrZXlUb1BsdWdpbiwgaW5pdERlc2NyaXB0aW9uLCBsb2FkRGVzY3JpcHRpb25dCiAgICAvLyB0eG4udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFwcGxpY2F0aW9uQ2FsbCAmJgogICAgLy8gdHhuLmFwcElkID09PSBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uSWQgJiYKICAgIGJ6IG5ld1NlcnZpY2VfYm9vbF9mYWxzZUA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MTA2CiAgICAvLyB0eG4ubnVtQXBwQXJncyA9PT0gNCAmJgogICAgZHVwCiAgICBndHhucyBOdW1BcHBBcmdzCiAgICBwdXNoaW50IDQgLy8gNAogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxMDMtMTA2CiAgICAvLyBUeG4uZ3JvdXBJbmRleCA+IDIgJiYgLy8gW2FyYzU4X3Jla2V5VG9QbHVnaW4sIGluaXREZXNjcmlwdGlvbiwgbG9hZERlc2NyaXB0aW9uXQogICAgLy8gdHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwgJiYKICAgIC8vIHR4bi5hcHBJZCA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkICYmCiAgICAvLyB0eG4ubnVtQXBwQXJncyA9PT0gNCAmJgogICAgYnogbmV3U2VydmljZV9ib29sX2ZhbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxMDcKICAgIC8vIHR4bi5vbkNvbXBsZXRpb24gPT09IE9uQ29tcGxldGVBY3Rpb24uTm9PcCAmJgogICAgZHVwCiAgICBndHhucyBPbkNvbXBsZXRpb24KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxMDMtMTA3CiAgICAvLyBUeG4uZ3JvdXBJbmRleCA+IDIgJiYgLy8gW2FyYzU4X3Jla2V5VG9QbHVnaW4sIGluaXREZXNjcmlwdGlvbiwgbG9hZERlc2NyaXB0aW9uXQogICAgLy8gdHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwgJiYKICAgIC8vIHR4bi5hcHBJZCA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkICYmCiAgICAvLyB0eG4ubnVtQXBwQXJncyA9PT0gNCAmJgogICAgLy8gdHhuLm9uQ29tcGxldGlvbiA9PT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wICYmCiAgICBibnogbmV3U2VydmljZV9ib29sX2ZhbHNlQDgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxMDgKICAgIC8vIHR4bi5hcHBBcmdzKDApID09PSBtZXRob2RTZWxlY3Rvcih0aGlzLmxvYWREZXNjcmlwdGlvbiksCiAgICBkdXAKICAgIGludGNfMCAvLyAwCiAgICBndHhuc2FzIEFwcGxpY2F0aW9uQXJncwogICAgYnl0ZWMgOCAvLyBtZXRob2QgImxvYWREZXNjcmlwdGlvbih1aW50NjQsdWludDY0LGJ5dGVbXSl2b2lkIgogICAgPT0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxMDMtMTA4CiAgICAvLyBUeG4uZ3JvdXBJbmRleCA+IDIgJiYgLy8gW2FyYzU4X3Jla2V5VG9QbHVnaW4sIGluaXREZXNjcmlwdGlvbiwgbG9hZERlc2NyaXB0aW9uXQogICAgLy8gdHhuLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BcHBsaWNhdGlvbkNhbGwgJiYKICAgIC8vIHR4bi5hcHBJZCA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkICYmCiAgICAvLyB0eG4ubnVtQXBwQXJncyA9PT0gNCAmJgogICAgLy8gdHhuLm9uQ29tcGxldGlvbiA9PT0gT25Db21wbGV0ZUFjdGlvbi5Ob09wICYmCiAgICAvLyB0eG4uYXBwQXJncygwKSA9PT0gbWV0aG9kU2VsZWN0b3IodGhpcy5sb2FkRGVzY3JpcHRpb24pLAogICAgYnogbmV3U2VydmljZV9ib29sX2ZhbHNlQDgKICAgIGludGNfMSAvLyAxCgpuZXdTZXJ2aWNlX2Jvb2xfbWVyZ2VAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxMDItMTEwCiAgICAvLyBhc3NlcnQoCiAgICAvLyAgIFR4bi5ncm91cEluZGV4ID4gMiAmJiAvLyBbYXJjNThfcmVrZXlUb1BsdWdpbiwgaW5pdERlc2NyaXB0aW9uLCBsb2FkRGVzY3JpcHRpb25dCiAgICAvLyAgIHR4bi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQXBwbGljYXRpb25DYWxsICYmCiAgICAvLyAgIHR4bi5hcHBJZCA9PT0gR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkICYmCiAgICAvLyAgIHR4bi5udW1BcHBBcmdzID09PSA0ICYmCiAgICAvLyAgIHR4bi5vbkNvbXBsZXRpb24gPT09IE9uQ29tcGxldGVBY3Rpb24uTm9PcCAmJgogICAgLy8gICB0eG4uYXBwQXJncygwKSA9PT0gbWV0aG9kU2VsZWN0b3IodGhpcy5sb2FkRGVzY3JpcHRpb24pLAogICAgLy8gICBFUlJfSU5WQUxJRF9DQUxMX09SREVSCiAgICAvLyApCiAgICBhc3NlcnQgLy8gSW52YWxpZCBjYWxsIG9yZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MTEyCiAgICAvLyBjb25zdCBhcHBJZCA9IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdWJzY3JpcHRpb25zKQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjExMgogICAgLy8gY29uc3QgYXBwSWQgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Vic2NyaXB0aW9ucykKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjQwCiAgICAvLyBjb25zdCBbYXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c0FraXRhQXBwTGlzdCkpCiAgICBieXRlY18xIC8vICJhYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MTEyCiAgICAvLyBjb25zdCBhcHBJZCA9IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdWJzY3JpcHRpb25zKQogICAgcHVzaGludCAzMiAvLyAzMgogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgYnVyeSAxNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjExNC0xMTgKICAgIC8vIGNvbnN0IGNvc3QgPSBhYmlDYWxsPHR5cGVvZiBTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5uZXdTZXJ2aWNlQ29zdD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbYXNzZXRdLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIHB1c2hieXRlcyAweDFkYzc4MzcxIC8vIG1ldGhvZCAibmV3U2VydmljZUNvc3QodWludDY0KXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTAKICAgIGR1cAogICAgY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGR1cAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBkaWcgMwogICAgZHVwCiAgICBjb3ZlciAyCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzIgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBCeXRlcyBoYXMgdmFsaWQgcHJlZml4CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjEyMC0xMzkKICAgIC8vIGl0eG5Db21wb3NlLmJlZ2luPHR5cGVvZiBTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5uZXdTZXJ2aWNlPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IGNvc3QsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgaW50ZXJ2YWwsCiAgICAvLyAgICAgYXNzZXQsCiAgICAvLyAgICAgYW1vdW50LAogICAgLy8gICAgIHBhc3NlcywKICAgIC8vICAgICBnYXRlLAogICAgLy8gICAgIHRpdGxlLAogICAgLy8gICAgIGJhbm5lckltYWdlLAogICAgLy8gICAgIGhpZ2hsaWdodE1lc3NhZ2UsCiAgICAvLyAgICAgaGlnaGxpZ2h0Q29sb3IsCiAgICAvLyAgIF0KICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MTI2CiAgICAvLyByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIGRpZyAxCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MTI0LTEyOAogICAgLy8gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBjb3N0LAogICAgLy8gfSksCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MTIwLTEzOQogICAgLy8gaXR4bkNvbXBvc2UuYmVnaW48dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLm5ld1NlcnZpY2U+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogY29zdCwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBpbnRlcnZhbCwKICAgIC8vICAgICBhc3NldCwKICAgIC8vICAgICBhbW91bnQsCiAgICAvLyAgICAgcGFzc2VzLAogICAgLy8gICAgIGdhdGUsCiAgICAvLyAgICAgdGl0bGUsCiAgICAvLyAgICAgYmFubmVySW1hZ2UsCiAgICAvLyAgICAgaGlnaGxpZ2h0TWVzc2FnZSwKICAgIC8vICAgICBoaWdobGlnaHRDb2xvciwKICAgIC8vICAgXQogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgcHVzaGJ5dGVzIDB4NGJkNjIxZDggLy8gbWV0aG9kICJuZXdTZXJ2aWNlKHBheSx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHN0cmluZyxieXRlWzM2XSx1aW50OCxieXRlWzNdKXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgOQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA4CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDcKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA1CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MjMKICAgIC8vIGRlc2NyaXB0aW9uID0gQm94PGJ5dGVzPih7IGtleTogQm94S2V5U3Vic2NyaXB0aW9uc0Rlc2NyaXB0aW9uIH0pCiAgICBieXRlYyA0IC8vICJkIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjE0MQogICAgLy8gY29uc3Qgc2l6ZSA9IHRoaXMuZGVzY3JpcHRpb24ubGVuZ3RoCiAgICBib3hfbGVuCiAgICBzd2FwCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxNDIKICAgIC8vIGlmIChzaXplID4gTUFYX0RFU0NSSVBUSU9OX0NIVU5LX1NJWkUpIHsKICAgIGludGMgNCAvLyAyMDM0CiAgICA+CiAgICBieiBuZXdTZXJ2aWNlX2Vsc2VfYm9keUAxMgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjIzCiAgICAvLyBkZXNjcmlwdGlvbiA9IEJveDxieXRlcz4oeyBrZXk6IEJveEtleVN1YnNjcmlwdGlvbnNEZXNjcmlwdGlvbiB9KQogICAgYnl0ZWMgNCAvLyAiZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxNDMKICAgIC8vIGNvbnN0IGNodW5rID0gdGhpcy5kZXNjcmlwdGlvbi5leHRyYWN0KDAsIE1BWF9ERVNDUklQVElPTl9DSFVOS19TSVpFKQogICAgaW50Y18wIC8vIDAKICAgIGludGMgNCAvLyAyMDM0CiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjE0NS0xNDkKICAgIC8vIGl0eG5Db21wb3NlLm5leHQ8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnNldFNlcnZpY2VEZXNjcmlwdGlvbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbMCwgY2h1bmtdLAogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjE0OAogICAgLy8gYXJnczogWzAsIGNodW5rXSwKICAgIGludGNfMCAvLyAwCiAgICBpdG9iCiAgICBkaWcgMQogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxNDUtMTQ5CiAgICAvLyBpdHhuQ29tcG9zZS5uZXh0PHR5cGVvZiBTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5zZXRTZXJ2aWNlRGVzY3JpcHRpb24+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWzAsIGNodW5rXSwKICAgIC8vIH0pCiAgICBieXRlYyA1IC8vIG1ldGhvZCAic2V0U2VydmljZURlc2NyaXB0aW9uKHVpbnQ2NCxieXRlW10pdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTUKICAgIGR1cAogICAgY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBkaWcgNAogICAgZHVwCiAgICBjb3ZlciAzCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjE1MS0xNTUKICAgIC8vIGl0eG5Db21wb3NlLm5leHQ8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnNldFNlcnZpY2VEZXNjcmlwdGlvbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbMCwgdGhpcy5kZXNjcmlwdGlvbi5leHRyYWN0KE1BWF9ERVNDUklQVElPTl9DSFVOS19TSVpFLCBzaXplIC0gTUFYX0RFU0NSSVBUSU9OX0NIVU5LX1NJWkUpXSwKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxNTQKICAgIC8vIGFyZ3M6IFswLCB0aGlzLmRlc2NyaXB0aW9uLmV4dHJhY3QoTUFYX0RFU0NSSVBUSU9OX0NIVU5LX1NJWkUsIHNpemUgLSBNQVhfREVTQ1JJUFRJT05fQ0hVTktfU0laRSldLAogICAgdW5jb3ZlciAzCiAgICBpbnRjIDQgLy8gMjAzNAogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjIzCiAgICAvLyBkZXNjcmlwdGlvbiA9IEJveDxieXRlcz4oeyBrZXk6IEJveEtleVN1YnNjcmlwdGlvbnNEZXNjcmlwdGlvbiB9KQogICAgYnl0ZWMgNCAvLyAiZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxNTQKICAgIC8vIGFyZ3M6IFswLCB0aGlzLmRlc2NyaXB0aW9uLmV4dHJhY3QoTUFYX0RFU0NSSVBUSU9OX0NIVU5LX1NJWkUsIHNpemUgLSBNQVhfREVTQ1JJUFRJT05fQ0hVTktfU0laRSldLAogICAgaW50YyA0IC8vIDIwMzQKICAgIHVuY292ZXIgMgogICAgYm94X2V4dHJhY3QKICAgIGR1cAogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MTUxLTE1NQogICAgLy8gaXR4bkNvbXBvc2UubmV4dDx0eXBlb2YgU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUuc2V0U2VydmljZURlc2NyaXB0aW9uPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFswLCB0aGlzLmRlc2NyaXB0aW9uLmV4dHJhY3QoTUFYX0RFU0NSSVBUSU9OX0NIVU5LX1NJWkUsIHNpemUgLSBNQVhfREVTQ1JJUFRJT05fQ0hVTktfU0laRSldLAogICAgLy8gfSkKICAgIGJ5dGVjIDUgLy8gbWV0aG9kICJzZXRTZXJ2aWNlRGVzY3JpcHRpb24odWludDY0LGJ5dGVbXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQoKbmV3U2VydmljZV9hZnRlcl9pZl9lbHNlQDEzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjE2Ny0xNzEKICAgIC8vIGl0eG5Db21wb3NlLm5leHQ8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLmFjdGl2YXRlU2VydmljZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbXSwKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIHB1c2hieXRlcyAweGM4ODM1MTMwIC8vIG1ldGhvZCAiYWN0aXZhdGVTZXJ2aWNlKCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMwogICAgZHVwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGRpZyAyCiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MTczCiAgICAvLyBpdHhuQ29tcG9zZS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxNzUtMTgwCiAgICAvLyBjb25zdCBpZCA9IGFiaUNhbGw8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLmdldFNlcnZpY2VMaXN0Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtzZW5kZXJdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxNzkKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICBkaWcgMTMKICAgIGRpZyAxNQogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxNzUtMTgwCiAgICAvLyBjb25zdCBpZCA9IGFiaUNhbGw8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLmdldFNlcnZpY2VMaXN0Pih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtzZW5kZXJdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweGRmZTYwMmNmIC8vIG1ldGhvZCAiZ2V0U2VydmljZUxpc3QoYWRkcmVzcyl1aW50NjQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18yIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxODUKICAgIC8vIHJldHVybiAoaWQgLSAxKQogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo4NS05NwogICAgLy8gbmV3U2VydmljZSgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBpbnRlcnZhbDogdWludDY0LAogICAgLy8gICBhc3NldDogdWludDY0LAogICAgLy8gICBhbW91bnQ6IHVpbnQ2NCwKICAgIC8vICAgcGFzc2VzOiB1aW50NjQsCiAgICAvLyAgIGdhdGU6IHVpbnQ2NCwKICAgIC8vICAgdGl0bGU6IHN0cmluZywKICAgIC8vICAgYmFubmVySW1hZ2U6IENJRCwKICAgIC8vICAgaGlnaGxpZ2h0TWVzc2FnZTogVWludDgsCiAgICAvLyAgIGhpZ2hsaWdodENvbG9yOiBieXRlczwzPgogICAgLy8gKTogdWludDY0IHsKICAgIGl0b2IKICAgIGJ5dGVjXzIgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm5ld1NlcnZpY2VfZWxzZV9ib2R5QDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjIzCiAgICAvLyBkZXNjcmlwdGlvbiA9IEJveDxieXRlcz4oeyBrZXk6IEJveEtleVN1YnNjcmlwdGlvbnNEZXNjcmlwdGlvbiB9KQogICAgYnl0ZWMgNCAvLyAiZCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxNTgKICAgIC8vIGNvbnN0IGNodW5rID0gdGhpcy5kZXNjcmlwdGlvbi5leHRyYWN0KDAsIHNpemUpCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAyCiAgICBib3hfZXh0cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjE2MC0xNjQKICAgIC8vIGl0eG5Db21wb3NlLm5leHQ8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnNldFNlcnZpY2VEZXNjcmlwdGlvbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbMCwgY2h1bmtdLAogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjE2MwogICAgLy8gYXJnczogWzAsIGNodW5rXSwKICAgIGludGNfMCAvLyAwCiAgICBpdG9iCiAgICBkaWcgMQogICAgbGVuCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxNjAtMTY0CiAgICAvLyBpdHhuQ29tcG9zZS5uZXh0PHR5cGVvZiBTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5zZXRTZXJ2aWNlRGVzY3JpcHRpb24+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWzAsIGNodW5rXSwKICAgIC8vIH0pCiAgICBieXRlYyA1IC8vIG1ldGhvZCAic2V0U2VydmljZURlc2NyaXB0aW9uKHVpbnQ2NCxieXRlW10pdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGIgbmV3U2VydmljZV9hZnRlcl9pZl9lbHNlQDEzCgpuZXdTZXJ2aWNlX2Jvb2xfZmFsc2VAODoKICAgIGludGNfMCAvLyAwCiAgICBiIG5ld1NlcnZpY2VfYm9vbF9tZXJnZUA5CgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjpTdWJzY3JpcHRpb25zUGx1Z2luLnBhdXNlU2VydmljZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CnBhdXNlU2VydmljZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxODgtMTkyCiAgICAvLyBwYXVzZVNlcnZpY2UoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgaWQ6IFN1YnNjcmlwdGlvbklECiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18zIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjE5NQogICAgLy8gY29uc3QgYXBwSWQgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Vic2NyaXB0aW9ucykKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxOTUKICAgIC8vIGNvbnN0IGFwcElkID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN1YnNjcmlwdGlvbnMpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMSAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjE5NQogICAgLy8gY29uc3QgYXBwSWQgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Vic2NyaXB0aW9ucykKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MTk3LTIwMgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUucGF1c2VTZXJ2aWNlPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtpZF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjIwMQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciA0CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjE5Ny0yMDIKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnBhdXNlU2VydmljZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbaWRdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDE3Yzg3MzBiIC8vIG1ldGhvZCAicGF1c2VTZXJ2aWNlKHVpbnQ2NCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoxODgtMTkyCiAgICAvLyBwYXVzZVNlcnZpY2UoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgaWQ6IFN1YnNjcmlwdGlvbklECiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6OlN1YnNjcmlwdGlvbnNQbHVnaW4uc2h1dGRvd25TZXJ2aWNlW3JvdXRpbmddKCkgLT4gdm9pZDoKc2h1dGRvd25TZXJ2aWNlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjIwNS0yMDkKICAgIC8vIHNodXRkb3duU2VydmljZSgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBpbmRleDogdWludDY0CiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18zIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjIxMgogICAgLy8gY29uc3QgYXBwSWQgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Vic2NyaXB0aW9ucykKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoyMTIKICAgIC8vIGNvbnN0IGFwcElkID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN1YnNjcmlwdGlvbnMpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMSAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjIxMgogICAgLy8gY29uc3QgYXBwSWQgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Vic2NyaXB0aW9ucykKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MjE0LTIxOQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUuc2h1dGRvd25TZXJ2aWNlPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtpbmRleF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjIxOAogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciA0CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjIxNC0yMTkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnNodXRkb3duU2VydmljZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbaW5kZXhdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweDg3ZTA1NWM2IC8vIG1ldGhvZCAic2h1dGRvd25TZXJ2aWNlKHVpbnQ2NCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoyMDUtMjA5CiAgICAvLyBzaHV0ZG93blNlcnZpY2UoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgaW5kZXg6IHVpbnQ2NAogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjpTdWJzY3JpcHRpb25zUGx1Z2luLmJsb2NrW3JvdXRpbmddKCkgLT4gdm9pZDoKYmxvY2s6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MjIyLTIyNgogICAgLy8gYmxvY2soCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYWRkcmVzczogQWNjb3VudAogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18zIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjIyOQogICAgLy8gY29uc3QgYXBwSWQgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Vic2NyaXB0aW9ucykKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoyMjkKICAgIC8vIGNvbnN0IGFwcElkID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN1YnNjcmlwdGlvbnMpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMSAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjIyOQogICAgLy8gY29uc3QgYXBwSWQgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Vic2NyaXB0aW9ucykKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MjMxLTI0MwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUuYmxvY2s+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogdGhpcy5tYnIoKS5ibG9ja3MsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgYWRkcmVzcywKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MjM3CiAgICAvLyByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjIzOAogICAgLy8gYW1vdW50OiB0aGlzLm1icigpLmJsb2NrcywKICAgIHB1c2hpbnQgMTU3MDAgLy8gMTU3MDAKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoyMzUtMjM5CiAgICAvLyBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IHRoaXMubWJyKCkuYmxvY2tzLAogICAgLy8gfSksCiAgICBpbnRjXzEgLy8gMQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MjMxLTI0MwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUuYmxvY2s+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogdGhpcy5tYnIoKS5ibG9ja3MsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgYWRkcmVzcywKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoyNDIKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgNAogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoyMzEtMjQzCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5ibG9jaz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiB0aGlzLm1icigpLmJsb2NrcywKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBhZGRyZXNzLAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweGI1OWM4YTU0IC8vIG1ldGhvZCAiYmxvY2socGF5LGFkZHJlc3Mpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDMKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MjIyLTIyNgogICAgLy8gYmxvY2soCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYWRkcmVzczogQWNjb3VudAogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjpTdWJzY3JpcHRpb25zUGx1Z2luLnVuYmxvY2tbcm91dGluZ10oKSAtPiB2b2lkOgp1bmJsb2NrOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjI0Ni0yNTAKICAgIC8vIHVuYmxvY2soCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYWRkcmVzczogQWNjb3VudAogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ4WzMyXQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18zIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjI1MwogICAgLy8gY29uc3QgYXBwSWQgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Vic2NyaXB0aW9ucykKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoyNTMKICAgIC8vIGNvbnN0IGFwcElkID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN1YnNjcmlwdGlvbnMpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMSAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjI1MwogICAgLy8gY29uc3QgYXBwSWQgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Vic2NyaXB0aW9ucykKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MjU1LTI2MAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUudW5ibG9jaz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbYWRkcmVzc10sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjI1OQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciA0CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjI1NS0yNjAKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnVuYmxvY2s+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW2FkZHJlc3NdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweGFlZWJiMzc4IC8vIG1ldGhvZCAidW5ibG9jayhhZGRyZXNzKXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjI0Ni0yNTAKICAgIC8vIHVuYmxvY2soCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYWRkcmVzczogQWNjb3VudAogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjpTdWJzY3JpcHRpb25zUGx1Z2luLnN1YnNjcmliZVtyb3V0aW5nXSgpIC0+IHZvaWQ6CnN1YnNjcmliZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoyNjMtMjcyCiAgICAvLyBzdWJzY3JpYmUoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgYXNzZXQ6IHVpbnQ2NCwKICAgIC8vICAgcmVjaXBpZW50OiBBY2NvdW50LAogICAgLy8gICBhbW91bnQ6IHVpbnQ2NCwKICAgIC8vICAgaW50ZXJ2YWw6IHVpbnQ2NCwKICAgIC8vICAgaW5kZXg6IHVpbnQ2NCwKICAgIC8vICAgYXJnczogR2F0ZUFyZ3MKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIGJ0b2kKICAgIGR1cAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBjb3ZlciAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA0CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGxlbgogICAgcHVzaGludCAzMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDhbMzJdCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBjb3ZlciAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA2CiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNwogICAgZHVwCiAgICBjb3ZlciAzCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDgKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTYxLTE2NAogICAgLy8gY29uc3QgW2NvbnRyb2xsZWRBY2NvdW50Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldElELAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNDb250cm9sbGVkQWRkcmVzcykKICAgIC8vICkKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNjMKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzKQogICAgYnl0ZWMgOSAvLyAiY29udHJvbGxlZF9hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNjEtMTY0CiAgICAvLyBjb25zdCBbY29udHJvbGxlZEFjY291bnRCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0SUQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMyAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTY5LTE3MgogICAgLy8gY29uc3QgW3JlZmVycmVyQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldElELAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNSZWZlcnJlcikKICAgIC8vICkKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNzEKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1JlZmVycmVyKQogICAgcHVzaGJ5dGVzICJyZWZlcnJlciIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTY5LTE3MgogICAgLy8gY29uc3QgW3JlZmVycmVyQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldElELAogICAgLy8gICBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNSZWZlcnJlcikKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjU4CiAgICAvLyB3YWxsZXRBZGRyZXNzOiB3YWxsZXQuYWRkcmVzcywKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNTctMjYyCiAgICAvLyByZXR1cm4gewogICAgLy8gICB3YWxsZXRBZGRyZXNzOiB3YWxsZXQuYWRkcmVzcywKICAgIC8vICAgb3JpZ2luLAogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlZmVycmVyCiAgICAvLyB9CiAgICB1bmNvdmVyIDQKICAgIGNvbmNhdAogICAgdW5jb3ZlciAzCiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MjczCiAgICAvLyBjb25zdCB7IG9yaWdpbiwgc2VuZGVyIH0gPSBnZXRBY2NvdW50cyh3YWxsZXQpCiAgICBkdXAKICAgIGV4dHJhY3QgMzIgMzIKICAgIGNvdmVyIDMKICAgIGV4dHJhY3QgNjQgMzIKICAgIGR1cAogICAgY292ZXIgMwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjI3NQogICAgLy8gY29uc3QgYXBwSWQgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Vic2NyaXB0aW9ucykKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoyNzUKICAgIC8vIGNvbnN0IGFwcElkID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN1YnNjcmlwdGlvbnMpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMSAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjI3NQogICAgLy8gY29uc3QgYXBwSWQgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Vic2NyaXB0aW9ucykKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGNvdmVyIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoyNzgKICAgIC8vIGxldCBtYnJBbW91bnQgPSBjb3N0cy5zdWJzY3JpcHRpb25zCiAgICBwdXNoaW50IDYwNTAwIC8vIDYwNTAwCiAgICBjb3ZlciA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MjgwLTI4NQogICAgLy8gY29uc3QgZmlyc3RTdWJzY3JpcHRpb24gPSBhYmlDYWxsPHR5cGVvZiBTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5pc0ZpcnN0U3Vic2NyaXB0aW9uPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtzZW5kZXJdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoyODQKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICB1bmNvdmVyIDMKICAgIHVuY292ZXIgMwogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoyODAtMjg1CiAgICAvLyBjb25zdCBmaXJzdFN1YnNjcmlwdGlvbiA9IGFiaUNhbGw8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLmlzRmlyc3RTdWJzY3JpcHRpb24+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW3NlbmRlcl0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgcHVzaGJ5dGVzIDB4NjAzZDcyOTcgLy8gbWV0aG9kICJpc0ZpcnN0U3Vic2NyaXB0aW9uKGFkZHJlc3MpYm9vbCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgc3dhcAogICAgZXh0cmFjdCAwIDQKICAgIGJ5dGVjXzIgLy8gMHgxNTFmN2M3NQogICAgPT0KICAgIGFzc2VydCAvLyBCeXRlcyBoYXMgdmFsaWQgcHJlZml4CiAgICBkdXAKICAgIGxlbgogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGJvb2w4CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6Mjg3CiAgICAvLyBpZiAoZmlyc3RTdWJzY3JpcHRpb24pIHsKICAgIGJ6IHN1YnNjcmliZV9hZnRlcl9pZl9lbHNlQDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoyODgKICAgIC8vIG1ickFtb3VudCArPSBjb3N0cy5zdWJzY3JpcHRpb25zbGlzdAogICAgcHVzaGludCA3OTQwMCAvLyA3OTQwMAogICAgYnVyeSAxCgpzdWJzY3JpYmVfYWZ0ZXJfaWZfZWxzZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjI5MwogICAgLy8gaWYgKGlzQXNhICYmICF0aGlzLmFraXRhREFPLnZhbHVlLmFkZHJlc3MuaXNPcHRlZEluKEFzc2V0KGFzc2V0KSkpIHsKICAgIGRpZyAxMAogICAgYnogc3Vic2NyaWJlX2FmdGVyX2lmX2Vsc2VANwogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjI5MwogICAgLy8gaWYgKGlzQXNhICYmICF0aGlzLmFraXRhREFPLnZhbHVlLmFkZHJlc3MuaXNPcHRlZEluKEFzc2V0KGFzc2V0KSkpIHsKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBkaWcgMTEKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBibnogc3Vic2NyaWJlX2FmdGVyX2lmX2Vsc2VANwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjI5NAogICAgLy8gbWJyQW1vdW50ICs9IEdsb2JhbC5hc3NldE9wdEluTWluQmFsYW5jZQogICAgZHVwCiAgICBnbG9iYWwgQXNzZXRPcHRJbk1pbkJhbGFuY2UKICAgICsKICAgIGJ1cnkgMQoKc3Vic2NyaWJlX2FmdGVyX2lmX2Vsc2VANzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoyOTcKICAgIC8vIGlmIChhcmdzLmxlbmd0aCA+IDApIHsKICAgIGRpZyA0CiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGJ6IHN1YnNjcmliZV9lbHNlX2JvZHlAMjAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czoyOTgKICAgIC8vIGNvbnN0IGdhdGUgPSBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuZ2F0ZQogICAgaW50Y18wIC8vIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjI5OAogICAgLy8gY29uc3QgZ2F0ZSA9IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5nYXRlCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMSAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjI5OAogICAgLy8gY29uc3QgZ2F0ZSA9IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5nYXRlCiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjMwMC0zMDQKICAgIC8vIGNvbnN0IHNlcnZpY2UgPSBhYmlDYWxsPHR5cGVvZiBTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5nZXRTZXJ2aWNlPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtyZWNpcGllbnQsIGluZGV4XSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICBwdXNoYnl0ZXMgMHgxYTEzNmY3YyAvLyBtZXRob2QgImdldFNlcnZpY2UoYWRkcmVzcyx1aW50NjQpKHVpbnQ4LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsc3RyaW5nLHN0cmluZyxieXRlWzM2XSx1aW50OCxieXRlWzNdKSIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGRpZyAzCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMiAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czozMTIKICAgIC8vIHNlcnZpY2UuZ2F0ZUlELAogICAgZXh0cmFjdCAzNyA4CiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MzE3CiAgICAvLyBpZiAoaXNBc2EpIHsKICAgIGRpZyAxMgogICAgYnogc3Vic2NyaWJlX2Vsc2VfYm9keUAxNQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjMxOC0zNDAKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLmdhdGVkU3Vic2NyaWJlQXNhPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IG1ickFtb3VudCwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgYXNzZXRSZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgICAgICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGdhdGVUeG4sCiAgICAvLyAgICAgcmVjaXBpZW50LAogICAgLy8gICAgIGFtb3VudCwKICAgIC8vICAgICBpbnRlcnZhbCwKICAgIC8vICAgICBpbmRleCwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MzI0CiAgICAvLyByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIGRpZyAzCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGRpZyA0CiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgZGlnIDUKICAgIGR1cAogICAgY292ZXIgMgogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czozMjItMzI2CiAgICAvLyBpdHhuLnBheW1lbnQoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICBhbW91bnQ6IG1ickFtb3VudCwKICAgIC8vIH0pLAogICAgaW50Y18xIC8vIDEKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjMyNy0zMzIKICAgIC8vIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXNzZXRSZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vIH0pLAogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MzI5CiAgICAvLyBhc3NldFJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBkaWcgMTIKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGRpZyAxNQogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MzI3LTMzMgogICAgLy8gaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhc3NldFJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gfSksCiAgICBwdXNoaW50IDQgLy8gNAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MzMzCiAgICAvLyBnYXRlVHhuLAogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MzEwCiAgICAvLyBtZXRob2RTZWxlY3RvcihHYXRlTXVzdENoZWNrQWJpTWV0aG9kKSwKICAgIGJ5dGVjIDYgLy8gbWV0aG9kICJtdXN0Q2hlY2soYWRkcmVzcyx1aW50NjQsYnl0ZVtdW10pdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgNwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA3CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGRpZyAxCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjMwNi0zMTUKICAgIC8vIGNvbnN0IGdhdGVUeG4gPSBpdHhuLmFwcGxpY2F0aW9uQ2FsbCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdhdGUsCiAgICAvLyAgIGFwcEFyZ3M6IFsKICAgIC8vICAgICBtZXRob2RTZWxlY3RvcihHYXRlTXVzdENoZWNrQWJpTWV0aG9kKSwKICAgIC8vICAgICBvcmlnaW4sCiAgICAvLyAgICAgc2VydmljZS5nYXRlSUQsCiAgICAvLyAgICAgZW5jb2RlQXJjNChhcmdzKQogICAgLy8gICBdCiAgICAvLyB9KQogICAgaW50Y18zIC8vIDYKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjMxOC0zNDAKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLmdhdGVkU3Vic2NyaWJlQXNhPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IG1ickFtb3VudCwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgYXNzZXRSZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgICAgICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGdhdGVUeG4sCiAgICAvLyAgICAgcmVjaXBpZW50LAogICAgLy8gICAgIGFtb3VudCwKICAgIC8vICAgICBpbnRlcnZhbCwKICAgIC8vICAgICBpbmRleCwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czozMzkKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICBkaWcgMTMKICAgIGRpZyAxNQogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czozMTgtMzQwCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5nYXRlZFN1YnNjcmliZUFzYT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5wYXltZW50KHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIHJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgICAgYW1vdW50OiBtYnJBbW91bnQsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgaXR4bi5hc3NldFRyYW5zZmVyKHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIGFzc2V0UmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAogICAgLy8gICAgICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBnYXRlVHhuLAogICAgLy8gICAgIHJlY2lwaWVudCwKICAgIC8vICAgICBhbW91bnQsCiAgICAvLyAgICAgaW50ZXJ2YWwsCiAgICAvLyAgICAgaW5kZXgsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4YTY4ZTY5NjMgLy8gbWV0aG9kICJnYXRlZFN1YnNjcmliZUFzYShwYXksYXhmZXIsYXBwbCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KXVpbnQ2NCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTEKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgOQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA4CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgZ2l0eG4gMyBMYXN0TG9nCiAgICBkdXAKICAgIGV4dHJhY3QgNCAwCiAgICBzd2FwCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMiAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAoKc3Vic2NyaWJlX2FmdGVyX2lmX2Vsc2VAMjk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MjYzLTI3MgogICAgLy8gc3Vic2NyaWJlKAogICAgLy8gICB3YWxsZXQ6IEFwcGxpY2F0aW9uLAogICAgLy8gICByZWtleUJhY2s6IGJvb2xlYW4sCiAgICAvLyAgIGFzc2V0OiB1aW50NjQsCiAgICAvLyAgIHJlY2lwaWVudDogQWNjb3VudCwKICAgIC8vICAgYW1vdW50OiB1aW50NjQsCiAgICAvLyAgIGludGVydmFsOiB1aW50NjQsCiAgICAvLyAgIGluZGV4OiB1aW50NjQsCiAgICAvLyAgIGFyZ3M6IEdhdGVBcmdzCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCnN1YnNjcmliZV9lbHNlX2JvZHlAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MzQyLTM1OAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUuZ2F0ZWRTdWJzY3JpYmU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogYW1vdW50ICsgbWJyQW1vdW50LAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGdhdGVUeG4sCiAgICAvLyAgICAgcmVjaXBpZW50LAogICAgLy8gICAgIGFtb3VudCwKICAgIC8vICAgICBpbnRlcnZhbCwKICAgIC8vICAgICBpbmRleCwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MzQ4CiAgICAvLyByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIGRpZyAzCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czozNDkKICAgIC8vIGFtb3VudDogYW1vdW50ICsgbWJyQW1vdW50LAogICAgZGlnIDExCiAgICBkaWcgNQogICAgKwogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGRpZyA1CiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MzQ2LTM1MAogICAgLy8gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBhbW91bnQgKyBtYnJBbW91bnQsCiAgICAvLyB9KSwKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czozNTEKICAgIC8vIGdhdGVUeG4sCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czozMTAKICAgIC8vIG1ldGhvZFNlbGVjdG9yKEdhdGVNdXN0Q2hlY2tBYmlNZXRob2QpLAogICAgYnl0ZWMgNiAvLyBtZXRob2QgIm11c3RDaGVjayhhZGRyZXNzLHVpbnQ2NCxieXRlW11bXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA3CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDcKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjMwNi0zMTUKICAgIC8vIGNvbnN0IGdhdGVUeG4gPSBpdHhuLmFwcGxpY2F0aW9uQ2FsbCh7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQ6IGdhdGUsCiAgICAvLyAgIGFwcEFyZ3M6IFsKICAgIC8vICAgICBtZXRob2RTZWxlY3RvcihHYXRlTXVzdENoZWNrQWJpTWV0aG9kKSwKICAgIC8vICAgICBvcmlnaW4sCiAgICAvLyAgICAgc2VydmljZS5nYXRlSUQsCiAgICAvLyAgICAgZW5jb2RlQXJjNChhcmdzKQogICAgLy8gICBdCiAgICAvLyB9KQogICAgaW50Y18zIC8vIDYKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjM0Mi0zNTgKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLmdhdGVkU3Vic2NyaWJlPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IGFtb3VudCArIG1ickFtb3VudCwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBnYXRlVHhuLAogICAgLy8gICAgIHJlY2lwaWVudCwKICAgIC8vICAgICBhbW91bnQsCiAgICAvLyAgICAgaW50ZXJ2YWwsCiAgICAvLyAgICAgaW5kZXgsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9uZXh0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MzU3CiAgICAvLyByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgZGlnIDEzCiAgICBkaWcgMTUKICAgIGNhbGxzdWIgcmVrZXlBZGRyZXNzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MzQyLTM1OAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUuZ2F0ZWRTdWJzY3JpYmU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogYW1vdW50ICsgbWJyQW1vdW50LAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGdhdGVUeG4sCiAgICAvLyAgICAgcmVjaXBpZW50LAogICAgLy8gICAgIGFtb3VudCwKICAgIC8vICAgICBpbnRlcnZhbCwKICAgIC8vICAgICBpbmRleCwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHg1MzU1ZGE2ZCAvLyBtZXRob2QgImdhdGVkU3Vic2NyaWJlKHBheSxhcHBsLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA5CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDgKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBnaXR4biAyIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18yIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBiIHN1YnNjcmliZV9hZnRlcl9pZl9lbHNlQDI5CgpzdWJzY3JpYmVfZWxzZV9ib2R5QDIwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjM2MQogICAgLy8gaWYgKGlzQXNhKSB7CiAgICBkaWcgMTAKICAgIGJ6IHN1YnNjcmliZV9lbHNlX2JvZHlAMjUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czozNjItMzgzCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5zdWJzY3JpYmVBc2E+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IG1ickFtb3VudCwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgYXNzZXRSZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgICAgICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIHJlY2lwaWVudCwKICAgIC8vICAgICBhbW91bnQsCiAgICAvLyAgICAgaW50ZXJ2YWwsCiAgICAvLyAgICAgaW5kZXgsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjM2OAogICAgLy8gcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICBkaWcgMQogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBkaWcgMgogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGRpZyAzCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MzY2LTM3MAogICAgLy8gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBtYnJBbW91bnQsCiAgICAvLyB9KSwKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czozNzEtMzc2CiAgICAvLyBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFzc2V0UmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyB9KSwKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjM3MwogICAgLy8gYXNzZXRSZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIGR1cAogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgZGlnIDEwCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBkaWcgMTMKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGRpZyAxCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjM3MS0zNzYKICAgIC8vIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXNzZXRSZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgYXNzZXRBbW91bnQ6IGFtb3VudCwKICAgIC8vIH0pLAogICAgcHVzaGludCA0IC8vIDQKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjM2Mi0zODMKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnN1YnNjcmliZUFzYT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogbWJyQW1vdW50LAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIGl0eG4uYXNzZXRUcmFuc2Zlcih7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICBhc3NldFJlY2VpdmVyOiBhcHBJZC5hZGRyZXNzLAogICAgLy8gICAgICAgeGZlckFzc2V0OiBhc3NldCwKICAgIC8vICAgICAgIGFzc2V0QW1vdW50OiBhbW91bnQsCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgcmVjaXBpZW50LAogICAgLy8gICAgIGFtb3VudCwKICAgIC8vICAgICBpbnRlcnZhbCwKICAgIC8vICAgICBpbmRleCwKICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czozODIKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICBkaWcgMTMKICAgIGRpZyAxNQogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czozNjItMzgzCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5zdWJzY3JpYmVBc2E+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IG1ickFtb3VudCwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICBpdHhuLmFzc2V0VHJhbnNmZXIoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgYXNzZXRSZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIHhmZXJBc3NldDogYXNzZXQsCiAgICAvLyAgICAgICBhc3NldEFtb3VudDogYW1vdW50LAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIHJlY2lwaWVudCwKICAgIC8vICAgICBhbW91bnQsCiAgICAvLyAgICAgaW50ZXJ2YWwsCiAgICAvLyAgICAgaW5kZXgsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4YjEwYTMwNmUgLy8gbWV0aG9kICJzdWJzY3JpYmVBc2EocGF5LGF4ZmVyLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA5CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDgKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBnaXR4biAyIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18yIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBiIHN1YnNjcmliZV9hZnRlcl9pZl9lbHNlQDI5CgpzdWJzY3JpYmVfZWxzZV9ib2R5QDI1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjM4NS00MDAKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnN1YnNjcmliZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogYW1vdW50ICsgbWJyQW1vdW50LAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIHJlY2lwaWVudCwKICAgIC8vICAgICBhbW91bnQsCiAgICAvLyAgICAgaW50ZXJ2YWwsCiAgICAvLyAgICAgaW5kZXgsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjM5MQogICAgLy8gcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICBkaWcgMQogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6MzkyCiAgICAvLyBhbW91bnQ6IGFtb3VudCArIG1ickFtb3VudCwKICAgIGRpZyA5CiAgICBkaWcgMwogICAgKwogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGRpZyAzCiAgICBkdXAKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6Mzg5LTM5MwogICAgLy8gaXR4bi5wYXltZW50KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgYW1vdW50OiBhbW91bnQgKyBtYnJBbW91bnQsCiAgICAvLyB9KSwKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czozODUtNDAwCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5zdWJzY3JpYmU+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFsKICAgIC8vICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgcmVjZWl2ZXI6IGFwcElkLmFkZHJlc3MsCiAgICAvLyAgICAgICBhbW91bnQ6IGFtb3VudCArIG1ickFtb3VudCwKICAgIC8vICAgICB9KSwKICAgIC8vICAgICByZWNpcGllbnQsCiAgICAvLyAgICAgYW1vdW50LAogICAgLy8gICAgIGludGVydmFsLAogICAgLy8gICAgIGluZGV4LAogICAgLy8gICBdLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjM5OQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIGRpZyAxMwogICAgZGlnIDE1CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjM4NS00MDAKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnN1YnNjcmliZT4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkOiBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICBzZW5kZXIsCiAgICAvLyAgICAgICByZWNlaXZlcjogYXBwSWQuYWRkcmVzcywKICAgIC8vICAgICAgIGFtb3VudDogYW1vdW50ICsgbWJyQW1vdW50LAogICAgLy8gICAgIH0pLAogICAgLy8gICAgIHJlY2lwaWVudCwKICAgIC8vICAgICBhbW91bnQsCiAgICAvLyAgICAgaW50ZXJ2YWwsCiAgICAvLyAgICAgaW5kZXgsCiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4MTBmMDBjM2EgLy8gbWV0aG9kICJzdWJzY3JpYmUocGF5LGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpdWludDY0IgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyAxMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA5CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDgKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIFJla2V5VG8KICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBnaXR4biAxIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIHN3YXAKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18yIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBiIHN1YnNjcmliZV9hZnRlcl9pZl9lbHNlQDI5CgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjpTdWJzY3JpcHRpb25zUGx1Z2luLnRyaWdnZXJQYXltZW50W3JvdXRpbmddKCkgLT4gdm9pZDoKdHJpZ2dlclBheW1lbnQ6CiAgICBpbnRjXzAgLy8gMAogICAgcHVzaGJ5dGVzICIiCiAgICBkdXBuIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo0MDUtNDExCiAgICAvLyB0cmlnZ2VyUGF5bWVudCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhZGRyZXNzOiBBY2NvdW50LAogICAgLy8gICBpZDogU3Vic2NyaXB0aW9uSUQsCiAgICAvLyAgIGFyZ3M6IEdhdGVBcmdzCiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzEgLy8gMQogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYm9vbDgKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIHN3YXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGR1cAogICAgY292ZXIgMgogICAgbGVuCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50OFszMl0KICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gOAogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgdWludDY0CiAgICBidG9pCiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyA1CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18zIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjQxNAogICAgLy8gY29uc3QgYXBwSWQgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Vic2NyaXB0aW9ucykKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo0MTQKICAgIC8vIGNvbnN0IGFwcElkID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN1YnNjcmlwdGlvbnMpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMSAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjQxNAogICAgLy8gY29uc3QgYXBwSWQgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Vic2NyaXB0aW9ucykKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGV4dHJhY3RfdWludDY0CiAgICBzd2FwCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NDE2CiAgICAvLyBpZiAoYXJncy5sZW5ndGggPiAwKSB7CiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGJ6IHRyaWdnZXJQYXltZW50X2Vsc2VfYm9keUA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NDE3CiAgICAvLyBjb25zdCBnYXRlID0gZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLmdhdGUKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo0MTcKICAgIC8vIGNvbnN0IGdhdGUgPSBnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuZ2F0ZQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDAKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBcHBMaXN0KSkKICAgIGR1cAogICAgYnl0ZWNfMSAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjQxNwogICAgLy8gY29uc3QgZ2F0ZSA9IGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5nYXRlCiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgYnVyeSAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo1NQogICAgLy8gY29uc3QgW290aGVyQXBwTGlzdEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKGFraXRhREFPLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c090aGVyQXBwTGlzdCkpCiAgICBwdXNoYnl0ZXMgIm9hbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NjAKICAgIC8vIHJldHVybiBnZXRPdGhlckFwcExpc3QoYWtpdGFEQU8pLmVzY3JvdwogICAgcHVzaGludCAyNCAvLyAyNAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MTgyLTE4NQogICAgLy8gY29uc3QgZGF0YSA9IGFiaUNhbGw8dHlwZW9mIEVzY3Jvd0ZhY3RvcnkucHJvdG90eXBlLmdldD4oewogICAgLy8gICBhcHBJZDogZXNjcm93RmFjdG9yeSwKICAgIC8vICAgYXJnczogW2FkZHJlc3NdCiAgICAvLyB9KS5yZXR1cm5WYWx1ZQogICAgaXR4bl9iZWdpbgogICAgcHVzaGJ5dGVzIDB4M2MxYTZmMzMgLy8gbWV0aG9kICJnZXQoYWRkcmVzcylieXRlW10iCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIGludGNfMyAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBpdHhuIExhc3RMb2cKICAgIGR1cAogICAgZXh0cmFjdCA0IDAKICAgIGRpZyAxCiAgICBleHRyYWN0IDAgNAogICAgYnl0ZWNfMiAvLyAweDE1MWY3Yzc1CiAgICA9PQogICAgYXNzZXJ0IC8vIEJ5dGVzIGhhcyB2YWxpZCBwcmVmaXgKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgc3dhcAogICAgbGVuCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciAobGVuK3VpbnQ4W10pCiAgICBleHRyYWN0IDYgMAogICAgZHVwCiAgICBidXJ5IDEyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE4NwogICAgLy8gaWYgKEJ5dGVzKGRhdGEpLmxlbmd0aCA9PT0gMCB8fCBCeXRlcyhkYXRhKS5sZW5ndGggIT09IDgpIHsKICAgIGxlbgogICAgZHVwCiAgICBidXJ5IDkKICAgIGJ6IHRyaWdnZXJQYXltZW50X2lmX2JvZHlAMTEKICAgIGRpZyA3CiAgICBpbnRjXzIgLy8gOAogICAgIT0KICAgIGJ6IHRyaWdnZXJQYXltZW50X2FmdGVyX2lmX2Vsc2VAMTIKCnRyaWdnZXJQYXltZW50X2lmX2JvZHlAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE4OAogICAgLy8gcmV0dXJuIDAKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDkKCnRyaWdnZXJQYXltZW50X2FmdGVyX2lubGluZWRfc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo6Z2V0V2FsbGV0SURAMTM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjEzOQogICAgLy8gaWYgKHdhbGxldElELmlkID09PSAwKSB7CiAgICBkaWcgOAogICAgYm56IHRyaWdnZXJQYXltZW50X2FmdGVyX2lmX2Vsc2VAMTcKICAgIGRpZyA0Cgp0cmlnZ2VyUGF5bWVudF9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6Om9yaWdpbk9yQDE4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjQyMi00MjYKICAgIC8vIGNvbnN0IHN1YiA9IGFiaUNhbGw8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLmdldFN1YnNjcmlwdGlvbj4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbeyBhZGRyZXNzLCBpZCB9XSwKICAgIC8vIH0pLnJldHVyblZhbHVlCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NDI1CiAgICAvLyBhcmdzOiBbeyBhZGRyZXNzLCBpZCB9XSwKICAgIGRpZyA0CiAgICBpdG9iCiAgICBkaWcgNgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NDIyLTQyNgogICAgLy8gY29uc3Qgc3ViID0gYWJpQ2FsbDx0eXBlb2YgU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUuZ2V0U3Vic2NyaXB0aW9uPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFt7IGFkZHJlc3MsIGlkIH1dLAogICAgLy8gfSkucmV0dXJuVmFsdWUKICAgIHB1c2hieXRlcyAweDI1YjgxMmE3IC8vIG1ldGhvZCAiZ2V0U3Vic2NyaXB0aW9uKChhZGRyZXNzLHVpbnQ2NCkpKGJvb2wsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZHVwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDIKICAgIGR1cAogICAgY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBkaWcgNAogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIGl0eG4gTGFzdExvZwogICAgZHVwCiAgICBleHRyYWN0IDQgMAogICAgZGlnIDEKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18yIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgbGVuCiAgICBwdXNoaW50IDEwNSAvLyAxMDUKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIChib29sMSx1aW50OFszMl0sdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NDI4LTQ0NQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUuZ2F0ZWRUcmlnZ2VyUGF5bWVudD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5hcHBsaWNhdGlvbkNhbGwoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgYXBwSWQ6IGdhdGUsCiAgICAvLyAgICAgICBhcHBBcmdzOiBbCiAgICAvLyAgICAgICAgIG1ldGhvZFNlbGVjdG9yKEdhdGVNdXN0Q2hlY2tBYmlNZXRob2QpLAogICAgLy8gICAgICAgICBzdWJPcmlnaW4sCiAgICAvLyAgICAgICAgIHN1Yi5nYXRlSUQsCiAgICAvLyAgICAgICAgIGVuY29kZUFyYzQoYXJncykKICAgIC8vICAgICAgIF0KICAgIC8vICAgICB9KSwKICAgIC8vICAgICB7IGFkZHJlc3MsIGlkIH0KICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NDM4CiAgICAvLyBzdWIuZ2F0ZUlELAogICAgZXh0cmFjdCA3NyA4CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NDM2CiAgICAvLyBtZXRob2RTZWxlY3RvcihHYXRlTXVzdENoZWNrQWJpTWV0aG9kKSwKICAgIGJ5dGVjIDYgLy8gbWV0aG9kICJtdXN0Q2hlY2soYWRkcmVzcyx1aW50NjQsYnl0ZVtdW10pdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMTIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgZHVwCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjQzMi00NDEKICAgIC8vIGl0eG4uYXBwbGljYXRpb25DYWxsKHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZDogZ2F0ZSwKICAgIC8vICAgYXBwQXJnczogWwogICAgLy8gICAgIG1ldGhvZFNlbGVjdG9yKEdhdGVNdXN0Q2hlY2tBYmlNZXRob2QpLAogICAgLy8gICAgIHN1Yk9yaWdpbiwKICAgIC8vICAgICBzdWIuZ2F0ZUlELAogICAgLy8gICAgIGVuY29kZUFyYzQoYXJncykKICAgIC8vICAgXQogICAgLy8gfSksCiAgICBpbnRjXzMgLy8gNgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NDI4LTQ0NQogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUuZ2F0ZWRUcmlnZ2VyUGF5bWVudD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbCiAgICAvLyAgICAgaXR4bi5hcHBsaWNhdGlvbkNhbGwoewogICAgLy8gICAgICAgc2VuZGVyLAogICAgLy8gICAgICAgYXBwSWQ6IGdhdGUsCiAgICAvLyAgICAgICBhcHBBcmdzOiBbCiAgICAvLyAgICAgICAgIG1ldGhvZFNlbGVjdG9yKEdhdGVNdXN0Q2hlY2tBYmlNZXRob2QpLAogICAgLy8gICAgICAgICBzdWJPcmlnaW4sCiAgICAvLyAgICAgICAgIHN1Yi5nYXRlSUQsCiAgICAvLyAgICAgICAgIGVuY29kZUFyYzQoYXJncykKICAgIC8vICAgICAgIF0KICAgIC8vICAgICB9KSwKICAgIC8vICAgICB7IGFkZHJlc3MsIGlkIH0KICAgIC8vICAgXSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBpdHhuX25leHQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo0NDQKICAgIC8vIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICBkaWcgOAogICAgZGlnIDEwCiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjQyOC00NDUKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLmdhdGVkVHJpZ2dlclBheW1lbnQ+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogWwogICAgLy8gICAgIGl0eG4uYXBwbGljYXRpb25DYWxsKHsKICAgIC8vICAgICAgIHNlbmRlciwKICAgIC8vICAgICAgIGFwcElkOiBnYXRlLAogICAgLy8gICAgICAgYXBwQXJnczogWwogICAgLy8gICAgICAgICBtZXRob2RTZWxlY3RvcihHYXRlTXVzdENoZWNrQWJpTWV0aG9kKSwKICAgIC8vICAgICAgICAgc3ViT3JpZ2luLAogICAgLy8gICAgICAgICBzdWIuZ2F0ZUlELAogICAgLy8gICAgICAgICBlbmNvZGVBcmM0KGFyZ3MpCiAgICAvLyAgICAgICBdCiAgICAvLyAgICAgfSksCiAgICAvLyAgICAgeyBhZGRyZXNzLCBpZCB9CiAgICAvLyAgIF0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4MjgxYjg5MWIgLy8gbWV0aG9kICJnYXRlZFRyaWdnZXJQYXltZW50KGFwcGwsKGFkZHJlc3MsdWludDY0KSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBTZW5kZXIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKCnRyaWdnZXJQYXltZW50X2FmdGVyX2lmX2Vsc2VAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo0MDUtNDExCiAgICAvLyB0cmlnZ2VyUGF5bWVudCgKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBhZGRyZXNzOiBBY2NvdW50LAogICAgLy8gICBpZDogU3Vic2NyaXB0aW9uSUQsCiAgICAvLyAgIGFyZ3M6IEdhdGVBcmdzCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCnRyaWdnZXJQYXltZW50X2FmdGVyX2lmX2Vsc2VAMTc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjE2MS0xNjQKICAgIC8vIGNvbnN0IFtjb250cm9sbGVkQWNjb3VudEJ5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXRJRCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzQ29udHJvbGxlZEFkZHJlc3MpCiAgICAvLyApCiAgICBkaWcgOAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNjMKICAgIC8vIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzKQogICAgYnl0ZWMgOSAvLyAiY29udHJvbGxlZF9hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNjEtMTY0CiAgICAvLyBjb25zdCBbY29udHJvbGxlZEFjY291bnRCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcygKICAgIC8vICAgd2FsbGV0SUQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c0NvbnRyb2xsZWRBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjQyMAogICAgLy8gY29uc3Qgc3ViT3JpZ2luID0gb3JpZ2luT3Ioc3ViV2FsbGV0LCBhZGRyZXNzKQogICAgYiB0cmlnZ2VyUGF5bWVudF9hZnRlcl9pbmxpbmVkX3NtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6Om9yaWdpbk9yQDE4Cgp0cmlnZ2VyUGF5bWVudF9hZnRlcl9pZl9lbHNlQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxOTEKICAgIC8vIHJldHVybiBidG9pKGRhdGEpCiAgICBkaWcgMTAKICAgIGJ0b2kKICAgIGJ1cnkgOQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoxNzgKICAgIC8vIHJldHVybiBBcHBsaWNhdGlvbihnZXRXYWxsZXRJRChlc2Nyb3dGYWN0b3J5LCBhZGRyZXNzKSkKICAgIGIgdHJpZ2dlclBheW1lbnRfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjpnZXRXYWxsZXRJREAxMwoKdHJpZ2dlclBheW1lbnRfZWxzZV9ib2R5QDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NDQ3LTQ1MgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUudHJpZ2dlclBheW1lbnQ+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW3sgYWRkcmVzcywgaWQgfV0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjQ1MQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIGRpZyA1CiAgICBkaWcgNwogICAgY2FsbHN1YiByZWtleUFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo0NTAKICAgIC8vIGFyZ3M6IFt7IGFkZHJlc3MsIGlkIH1dLAogICAgZGlnIDQKICAgIGl0b2IKICAgIGRpZyA2CiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo0NDctNDUyCiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdWJzY3JpcHRpb25zLnByb3RvdHlwZS50cmlnZ2VyUGF5bWVudD4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbeyBhZGRyZXNzLCBpZCB9XSwKICAgIC8vICAgcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIC8vIH0pCiAgICBwdXNoYnl0ZXMgMHhjM2Q5ZjFkYyAvLyBtZXRob2QgInRyaWdnZXJQYXltZW50KChhZGRyZXNzLHVpbnQ2NCkpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgaXR4bl9maWVsZCBSZWtleVRvCiAgICBkdXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgZGlnIDEKICAgIGl0eG5fZmllbGQgU2VuZGVyCiAgICBpbnRjXzMgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgYiB0cmlnZ2VyUGF5bWVudF9hZnRlcl9pZl9lbHNlQDgKCgovLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6OlN1YnNjcmlwdGlvbnNQbHVnaW4uc3RyZWFrQ2hlY2tbcm91dGluZ10oKSAtPiB2b2lkOgpzdHJlYWtDaGVjazoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo0NTYtNDYwCiAgICAvLyBzdHJlYWtDaGVjaygKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBrZXk6IFN1YnNjcmlwdGlvbktleQogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgNDAgLy8gNDAKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yICh1aW50OFszMl0sdWludDY0KQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgZGlnIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY4CiAgICAvLyBCeXRlcyhBYnN0cmFjdEFjY291bnRHbG9iYWxTdGF0ZUtleXNTcGVuZGluZ0FkZHJlc3MpCiAgICBieXRlY18zIC8vICJzcGVuZGluZ19hZGRyZXNzIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czoyNjYtMjY5CiAgICAvLyBjb25zdCBbc3BlbmRpbmdBZGRyZXNzQnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoCiAgICAvLyAgIHdhbGxldCwKICAgIC8vICAgQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgLy8gKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjQ2MwogICAgLy8gY29uc3QgYXBwSWQgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Vic2NyaXB0aW9ucykKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czoyOQogICAgLy8gYWtpdGFEQU8gPSBHbG9iYWxTdGF0ZTxBcHBsaWNhdGlvbj4oeyBrZXk6IEdsb2JhbFN0YXRlS2V5QWtpdGFEQU8gfSkKICAgIGJ5dGVjXzAgLy8gImFraXRhX2RhbyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo0NjMKICAgIC8vIGNvbnN0IGFwcElkID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN1YnNjcmlwdGlvbnMpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Z1bmN0aW9ucy50czo0MAogICAgLy8gY29uc3QgW2FwcExpc3RCeXRlc10gPSBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhha2l0YURBTywgQnl0ZXMoQWtpdGFEQU9HbG9iYWxTdGF0ZUtleXNBa2l0YUFwcExpc3QpKQogICAgYnl0ZWNfMSAvLyAiYWFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjQ2MwogICAgLy8gY29uc3QgYXBwSWQgPSBBcHBsaWNhdGlvbihnZXRBa2l0YUFwcExpc3QodGhpcy5ha2l0YURBTy52YWx1ZSkuc3Vic2NyaXB0aW9ucykKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NDY1LTQ3MAogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUuc3RyZWFrQ2hlY2s+KHsKICAgIC8vICAgc2VuZGVyLAogICAgLy8gICBhcHBJZCwKICAgIC8vICAgYXJnczogW2tleV0sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjQ2OQogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciA0CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjQ2NS00NzAKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnN0cmVha0NoZWNrPih7CiAgICAvLyAgIHNlbmRlciwKICAgIC8vICAgYXBwSWQsCiAgICAvLyAgIGFyZ3M6IFtrZXldLAogICAgLy8gICByZWtleVRvOiByZWtleUFkZHJlc3MocmVrZXlCYWNrLCB3YWxsZXQpLAogICAgLy8gfSkKICAgIHB1c2hieXRlcyAweGMwZmYyNzMwIC8vIG1ldGhvZCAic3RyZWFrQ2hlY2soKGFkZHJlc3MsdWludDY0KSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo0NTYtNDYwCiAgICAvLyBzdHJlYWtDaGVjaygKICAgIC8vICAgd2FsbGV0OiBBcHBsaWNhdGlvbiwKICAgIC8vICAgcmVrZXlCYWNrOiBib29sZWFuLAogICAgLy8gICBrZXk6IFN1YnNjcmlwdGlvbktleQogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjpTdWJzY3JpcHRpb25zUGx1Z2luLnNldFBhc3Nlc1tyb3V0aW5nXSgpIC0+IHZvaWQ6CnNldFBhc3NlczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo0NzMtNDc4CiAgICAvLyBzZXRQYXNzZXMoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgaWQ6IFN1YnNjcmlwdGlvbklELAogICAgLy8gICBhZGRyZXNzZXM6IEFjY291bnRbXQogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwCiAgICBsZW4KICAgIGludGNfMSAvLyAxCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBib29sOAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciB1aW50NjQKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICAqCiAgICBwdXNoaW50IDIgLy8gMgogICAgKwogICAgZGlnIDEKICAgIGxlbgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgKGxlbit1aW50OFszMl1bXSkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGRpZyAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvZnVuY3Rpb25zLnRzOjI2OAogICAgLy8gQnl0ZXMoQWJzdHJhY3RBY2NvdW50R2xvYmFsU3RhdGVLZXlzU3BlbmRpbmdBZGRyZXNzKQogICAgYnl0ZWNfMyAvLyAic3BlbmRpbmdfYWRkcmVzcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6MjY2LTI2OQogICAgLy8gY29uc3QgW3NwZW5kaW5nQWRkcmVzc0J5dGVzXSA9IG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKAogICAgLy8gICB3YWxsZXQsCiAgICAvLyAgIEJ5dGVzKEFic3RyYWN0QWNjb3VudEdsb2JhbFN0YXRlS2V5c1NwZW5kaW5nQWRkcmVzcykKICAgIC8vICkKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo0ODEKICAgIC8vIGNvbnN0IGFwcElkID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN1YnNjcmlwdGlvbnMpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb25zL2NvbnRyYWN0LmFsZ28udHM6NDgxCiAgICAvLyBjb25zdCBhcHBJZCA9IEFwcGxpY2F0aW9uKGdldEFraXRhQXBwTGlzdCh0aGlzLmFraXRhREFPLnZhbHVlKS5zdWJzY3JpcHRpb25zKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9mdW5jdGlvbnMudHM6NDAKICAgIC8vIGNvbnN0IFthcHBMaXN0Qnl0ZXNdID0gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoYWtpdGFEQU8sIEJ5dGVzKEFraXRhREFPR2xvYmFsU3RhdGVLZXlzQWtpdGFBcHBMaXN0KSkKICAgIGJ5dGVjXzEgLy8gImFhbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo0ODEKICAgIC8vIGNvbnN0IGFwcElkID0gQXBwbGljYXRpb24oZ2V0QWtpdGFBcHBMaXN0KHRoaXMuYWtpdGFEQU8udmFsdWUpLnN1YnNjcmlwdGlvbnMpCiAgICBwdXNoaW50IDMyIC8vIDMyCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjQ4Mi00ODcKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnNldFBhc3Nlcz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbaWQsIGFkZHJlc3Nlc10sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjQ4NgogICAgLy8gcmVrZXlUbzogcmVrZXlBZGRyZXNzKHJla2V5QmFjaywgd2FsbGV0KSwKICAgIHVuY292ZXIgNAogICAgdW5jb3ZlciA1CiAgICBjYWxsc3ViIHJla2V5QWRkcmVzcwogICAgLy8gc21hcnRfY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9ucy9jb250cmFjdC5hbGdvLnRzOjQ4Mi00ODcKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnNldFBhc3Nlcz4oewogICAgLy8gICBzZW5kZXIsCiAgICAvLyAgIGFwcElkLAogICAgLy8gICBhcmdzOiBbaWQsIGFkZHJlc3Nlc10sCiAgICAvLyAgIHJla2V5VG86IHJla2V5QWRkcmVzcyhyZWtleUJhY2ssIHdhbGxldCksCiAgICAvLyB9KQogICAgcHVzaGJ5dGVzIDB4Mjc1MjAzYWYgLy8gbWV0aG9kICJzZXRQYXNzZXModWludDY0LGFkZHJlc3NbXSl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgNAogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIHVuY292ZXIgMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgUmVrZXlUbwogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaW50Y18zIC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbnMvY29udHJhY3QuYWxnby50czo0NzMtNDc4CiAgICAvLyBzZXRQYXNzZXMoCiAgICAvLyAgIHdhbGxldDogQXBwbGljYXRpb24sCiAgICAvLyAgIHJla2V5QmFjazogYm9vbGVhbiwKICAgIC8vICAgaWQ6IFN1YnNjcmlwdGlvbklELAogICAgLy8gICBhZGRyZXNzZXM6IEFjY291bnRbXQogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6OkFraXRhQmFzZUNvbnRyYWN0LnVwZGF0ZUFraXRhREFPW3JvdXRpbmddKCkgLT4gdm9pZDoKdXBkYXRlQWtpdGFEQU86CiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozOAogICAgLy8gdXBkYXRlQWtpdGFEQU8oYWtpdGFEQU86IEFwcGxpY2F0aW9uKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MzkKICAgIC8vIGFzc2VydChUeG4uc2VuZGVyID09PSB0aGlzLmdldEFraXRhREFPV2FsbGV0KCkuYWRkcmVzcywgRVJSX05PVF9BS0lUQV9EQU8pCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozMgogICAgLy8gY29uc3QgW3dhbGxldElEXSA9IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NCh0aGlzLmFraXRhREFPLnZhbHVlLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1dhbGxldCkpCiAgICBpbnRjXzAgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6MjkKICAgIC8vIGFraXRhREFPID0gR2xvYmFsU3RhdGU8QXBwbGljYXRpb24+KHsga2V5OiBHbG9iYWxTdGF0ZUtleUFraXRhREFPIH0pCiAgICBieXRlY18wIC8vICJha2l0YV9kYW8iCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozMgogICAgLy8gY29uc3QgW3dhbGxldElEXSA9IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NCh0aGlzLmFraXRhREFPLnZhbHVlLCBCeXRlcyhBa2l0YURBT0dsb2JhbFN0YXRlS2V5c1dhbGxldCkpCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgcHVzaGJ5dGVzICJ3YWxsZXQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdXRpbHMvYmFzZS1jb250cmFjdHMvYmFzZS50czozOQogICAgLy8gYXNzZXJ0KFR4bi5zZW5kZXIgPT09IHRoaXMuZ2V0QWtpdGFEQU9XYWxsZXQoKS5hZGRyZXNzLCBFUlJfTk9UX0FLSVRBX0RBTykKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gT25seSB0aGUgQWtpdGEgREFPIGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjI5CiAgICAvLyBha2l0YURBTyA9IEdsb2JhbFN0YXRlPEFwcGxpY2F0aW9uPih7IGtleTogR2xvYmFsU3RhdGVLZXlBa2l0YURBTyB9KQogICAgYnl0ZWNfMCAvLyAiYWtpdGFfZGFvIgogICAgLy8gc21hcnRfY29udHJhY3RzL3V0aWxzL2Jhc2UtY29udHJhY3RzL2Jhc2UudHM6NDAKICAgIC8vIHRoaXMuYWtpdGFEQU8udmFsdWUgPSBha2l0YURBTwogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy91dGlscy9iYXNlLWNvbnRyYWN0cy9iYXNlLnRzOjM4CiAgICAvLyB1cGRhdGVBa2l0YURBTyhha2l0YURBTzogQXBwbGljYXRpb24pOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4K", "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg==" }, "byteCode": { "approval": "CyAFAAEIBvIPJgoJYWtpdGFfZGFvA2FhbAQVH3x1EHNwZW5kaW5nX2FkZHJlc3MBZAQXlaDQBEOSJlUE0QecrgTPFgEdEmNvbnRyb2xsZWRfYWRkcmVzczEZFEQxGEEAZ4AEupc80CcHJwiCCwT+v4XxBDmjrkcEGbH8KwS+yGw0BJ9ZqXAEycykXAQj4ze9BOoheKoEHEJGGwQz6SyUBIVN7eA2GgCODgBMAK4A2gFaA4kD1wQlBIkE2Af0CVkJqAoLAAEAI0OABG+YF/Y2GgCOAQASAIoCAYv+QAADMgOJi/9yCESJNhoBSRUkEkQXNhoCSSJZgQIISwEVEkRXAgCAB3ZlcnNpb25MZyhMZyNDNhoBSRUkEkQXNhoCSRUjEkQiUzYaA0kVJBJESwIrZUgiKGVEKWVIgSBbsUlyCEQyELIIsgdLAbIAI7IQIrIBtk8DTwSI/36ABDlOrrKyGk8DshqyILIYsgAlshAisgGzI0M2GgEVJBJENhoCSRUkEkQXSYHPGA5EJwS9RQFAAAcnBEy5SCNDJwRM00L/9zYaARUkEkQ2GgJJFSQSRBdJNhoDSSJZgQIISwEVEkRXAgBJTgIVSwEIgc8YDkSB6g8KMRZMCSMJSTgQJRJBADxJOBgyCBJBADNJOBuBAxJBACpJOBlAACRJIsIaJwcSQQAaSTgAMQASQQARI0QnBL1FAUQnBEsDSwO7I0MiQv/sgAA2GgFJFSQSRBdJNhoCSRUjEkQiU0w2GgNJTgIVJBJENhoESU4CFSQSRDYaBUlOAhUkEkQ2GgZJTgIVJBJENhoHSU4CFSQSRDYaCElOAkkiWYECCEwVEkQ2GglJTgIVgSQSRDYaCklOAhUjEkQ2GgtJTgIVgQMSRCtlSDEWIwkxFoECDUEBo0k4ECUSQQGbSTgYMggSQQGSSTgbgQQSQQGJSTgZQAGDSSLCGicIEkEBeSNEIihlRCllSIEgW0lFD7GABB3Hg3GyGksKSU4CshpJshhLA0lOArIAJbIQIrIBs7Q+SVcEAExXAAQqEkRJFSQSRBexSwFyCESyB7IISwGyACOyECKyAbaABEvWIdiyGksNshpPArIaSwqyGksJshpLCLIaSweyGksGshpLBbIaSwSyGrIYsgAlshAisgEnBL1MSU8CRCEEDUEAsCcEIiEEurYiFksBFRZXBgJPAlAnBbIaSwGyGrIaSw9JTgKyGEsESU4DsgAlshAisgG2TwMhBAknBCEETwK6SRUWVwYCTFAnBbIaTLIashqyGLIAJbIQIrIBtoAEyINRMLIaSw1JshhLAkmyACWyECKyAbOxSw1LD4j87oAE3+YCz7IaSwGyGrIgsgCyGCWyECKyAbO0PklXBABMVwAEKhJESRUkEkQXIwkWKkxQsCNDJwQiTwK6tiIWSwEVFlcGAk8CUCcFshpMshqyGksNshhLAbIAJbIQIrIBQv98IkL+hDYaAUkVJBJEFzYaAkkVIxJEIlM2GgNJFSQSREsCK2VITCIoZUQpZUiBIFuxTwNPBIj8VYAEF8hzC7IaTwKyGrIgshiyACWyECKyAbMjQzYaAUkVJBJEFzYaAkkVIxJEIlM2GgNJFSQSREsCK2VITCIoZUQpZUiBIFuxTwNPBIj8B4AEh+BVxrIaTwKyGrIgshiyACWyECKyAbMjQzYaAUkVJBJEFzYaAkkVIxJEIlM2GgNJFYEgEkRLAitlSCIoZUQpZUiBIFuxSXIIRIHUerIIsgdLAbIAI7IQIrIBtk8DTwSI+6OABLWcilSyGk8DshqyILIYsgAlshAisgGzI0M2GgFJFSQSRBc2GgJJFSMSRCJTNhoDSRWBIBJESwIrZUhMIihlRCllSIEgW7FPA08EiPtUgASu67N4shpPArIasiCyGLIAJbIQIrIBsyNDNhoBSRUkEkQXSTYaAkkVIxJEIlNJTwI2GgNJFSQSRBdOAjYaBElOAxWBIBJENhoFSU4DSRUkEkQXTgI2GgZJTgMVJBJENhoHSU4DFSQSRDYaCE4CSScJZUhMSStlSExJgAhyZWZlcnJlcmVITElyCERPBFBPA1BPAlBJVyAgTgNXQCBJTgMiKGVEKWVIgSBbSU4EgdTYA04EsU8DTwOI+piABGA9cpeyGksCshqyILIYsgAlshAisgGztD5JVwQATFcABCoSREkVIxJEIlNBAAaBqOwERQFLCkEAFiIoZURyCERLC3AARQFAAAZJMhAIRQFLBCJZQQFLIihlRCllSIEoW7GABBoTb3yyGksKshpLBrIaSwKyGEsDsgAlshAisgGztD5JVwAEKhJEVyUITEsMQQCUsUsDSXIIREsEsgiyB0sFSU4CsgAjshAisgG2SXIIREsMshJLD7IRshRLAbIAgQSyECKyAbYnBrIaSweyGk8DshpLB7IaTwKyGEsBsgAlshAisgG2Sw1LD4j5qYAEpo5pY7IaSwyyGksLshpLCbIaSwiyGrIgshiyACWyECKyAbO3Az5JVwQATFcABCoSRBUkEkQjQ7FLA0lyCERLC0sFCLIIsgdLBUmyACOyECKyAbYnBrIaSweyGk8DshpLB7IaTwKyGEmyACWyECKyAbZLDUsPiPkvgARTVdptshpLDLIaSwuyGksJshpLCLIasiCyALIYJbIQIrIBs7cCPklXBABMVwAEKhJEFSQSREL/g0sKQQB2sUsBSXIIREsCsgiyB0sDSU4CsgAjshAisgG2SXIIREsKshJLDbIRshRLAbIAgQSyECKyAbZLDUsPiPi0gASxCjBushpLDLIaSwuyGksJshpLCLIasiCyGLIAJbIQIrIBs7cCPklXBABMVwAEKhJEFSQSREL/CLFLAUlyCERLCUsDCLIIsgdLA0myACOyECKyAbZLDUsPiPhXgAQQ8Aw6shpLDLIaSwuyGksJshpLCLIasiCyALIYJbIQIrIBs7cBPklXBABMVwAEKhJEFSQSREL+qyKAAEcCNhoBSRUkEkQXSTYaAkkVIxJEIlNMNhoDSU4CFYEgEkQ2GgRJFSQSRBdMNhoFSU4CTCtlSEwiKGVEKWVIgSBbTCJZQQDvIihlREkpZUiBKFtFC4ADb2FsZUiBGFuxgAQ8Gm8zshpLBbIashglshAisgGztD5JVwQASwFXAAQqEkRJIlmBAghMFRJEVwYASUUMFUlFCUEAB0sHJBNBAI4iRQlLCEAAfUsEsUsEFksGTFCABCW4EqeyGkmyGksCSU4CshhLBEmyACWyECKyAbO0PklXBABLAVcABCoSRBWBaRJEsVdNCCcGshpPBLIashpLBbIaSwyyGEmyACWyECKyAbZLCEsKiPcQgAQoG4kbshpPArIasiCyALIYJbIQIrIBsyNDSwgnCWVIQv98SwoXRQlC/22xSwVLB4j23EsEFksGTFCABMPZ8dyyGrIasiBJshhLAbIAJbIQIrIBs0L/wTYaAUkVJBJEFzYaAkkVIxJEIlM2GgNJFYEoEkRLAitlSEwiKGVEKWVIgSBbsU8DTwSI9oSABMD/JzCyGk8CshqyILIYsgAlshAisgGzI0M2GgFJFSQSRBc2GgJJFSMSRCJTNhoDSRUkEkQ2GgRJIlmBIAuBAghLARUSREsDK2VITCIoZUQpZUiBIFuxTwRPBYj2JYAEJ1IDr7IaTwSyGk8CshqyILIYsgAlshAisgGzI0M2GgFJFSQSRBcxACIoZUSABndhbGxldGVIcghEEkQoTGcjQw==", "clear": "C4EBQw==" }, "events": [], "templateVariables": {} };
var BinaryStateValue3 = class {
  constructor(value) {
    this.value = value;
  }
  asByteArray() {
    return this.value;
  }
  asString() {
    return this.value !== void 0 ? Buffer.from(this.value).toString("utf-8") : void 0;
  }
};
var SubscriptionsPluginParamsFactory = class _SubscriptionsPluginParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod(params) {
        switch (params.method) {
          case "create":
          case "create(uint64,string)void":
            return _SubscriptionsPluginParamsFactory.create.create(params);
        }
        throw new Error(`Unknown ' + verb + ' method`);
      },
      /**
       * Constructs create ABI call params for the SubscriptionsPlugin smart contract using the create(uint64,string)void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      create(params) {
        return {
          ...params,
          method: "create(uint64,string)void",
          args: Array.isArray(params.args) ? params.args : [params.args.akitaDao, params.args.version]
        };
      }
    };
  }
  /**
   * Constructs a no op call for the optIn(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static optIn(params) {
    return {
      ...params,
      method: "optIn(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.asset]
    };
  }
  /**
   * Constructs a no op call for the initDescription(uint64,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static initDescription(params) {
    return {
      ...params,
      method: "initDescription(uint64,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.size]
    };
  }
  /**
   * Constructs a no op call for the loadDescription(uint64,uint64,byte[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static loadDescription(params) {
    return {
      ...params,
      method: "loadDescription(uint64,uint64,byte[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.offset, params.args.data]
    };
  }
  /**
   * Constructs a no op call for the newService(uint64,bool,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static newService(params) {
    return {
      ...params,
      method: "newService(uint64,bool,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.interval, params.args.asset, params.args.amount, params.args.passes, params.args.gate, params.args.title, params.args.bannerImage, params.args.highlightMessage, params.args.highlightColor]
    };
  }
  /**
   * Constructs a no op call for the pauseService(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static pauseService(params) {
    return {
      ...params,
      method: "pauseService(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.id]
    };
  }
  /**
   * Constructs a no op call for the shutdownService(uint64,bool,uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static shutdownService(params) {
    return {
      ...params,
      method: "shutdownService(uint64,bool,uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.index]
    };
  }
  /**
   * Constructs a no op call for the block(uint64,bool,address)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static block(params) {
    return {
      ...params,
      method: "block(uint64,bool,address)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.address]
    };
  }
  /**
   * Constructs a no op call for the unblock(uint64,bool,address)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static unblock(params) {
    return {
      ...params,
      method: "unblock(uint64,bool,address)void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.address]
    };
  }
  /**
   * Constructs a no op call for the subscribe(uint64,bool,uint64,address,uint64,uint64,uint64,byte[][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static subscribe(params) {
    return {
      ...params,
      method: "subscribe(uint64,bool,uint64,address,uint64,uint64,uint64,byte[][])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.asset, params.args.recipient, params.args.amount, params.args.interval, params.args.index, params.args.args]
    };
  }
  /**
   * Constructs a no op call for the triggerPayment(uint64,bool,address,uint64,byte[][])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static triggerPayment(params) {
    return {
      ...params,
      method: "triggerPayment(uint64,bool,address,uint64,byte[][])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.address, params.args.id, params.args.args]
    };
  }
  /**
   * Constructs a no op call for the streakCheck(uint64,bool,(address,uint64))void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static streakCheck(params) {
    return {
      ...params,
      method: "streakCheck(uint64,bool,(address,uint64))void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.key]
    };
  }
  /**
   * Constructs a no op call for the setPasses(uint64,bool,uint64,address[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setPasses(params) {
    return {
      ...params,
      method: "setPasses(uint64,bool,uint64,address[])void",
      args: Array.isArray(params.args) ? params.args : [params.args.wallet, params.args.rekeyBack, params.args.id, params.args.addresses]
    };
  }
  /**
   * Constructs a no op call for the updateAkitaDAO(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateAkitaDao(params) {
    return {
      ...params,
      method: "updateAkitaDAO(uint64)void",
      args: Array.isArray(params.args) ? params.args : [params.args.akitaDao]
    };
  }
  /**
   * Constructs a no op call for the opUp()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static opUp(params) {
    return {
      ...params,
      method: "opUp()void",
      args: Array.isArray(params.args) ? params.args : []
    };
  }
};
var SubscriptionsPluginFactory = class {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  appFactory;
  /**
   * Creates a new instance of `SubscriptionsPluginFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params) {
    this.appFactory = new _AppFactory23({
      ...params,
      appSpec: APP_SPEC23
    });
  }
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  get appName() {
    return this.appFactory.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC23;
  }
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  get algorand() {
    return this.appFactory.algorand;
  }
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  getAppClientById(params) {
    return new SubscriptionsPluginClient(this.appFactory.getAppClientById(params));
  }
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  async getAppClientByCreatorAndName(params) {
    return new SubscriptionsPluginClient(await this.appFactory.getAppClientByCreatorAndName(params));
  }
  /**
   * Idempotently deploys the SubscriptionsPlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  async deploy(params = {}) {
    var _a;
    const result = await this.appFactory.deploy({
      ...params,
      createParams: ((_a = params.createParams) == null ? void 0 : _a.method) ? SubscriptionsPluginParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams : void 0
    });
    return { result: result.result, appClient: new SubscriptionsPluginClient(result.appClient) };
  }
  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the SubscriptionsPlugin smart contract using the create(uint64,string)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      create: (params) => {
        return this.appFactory.params.create(SubscriptionsPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the SubscriptionsPlugin smart contract using the create(uint64,string)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      create: (params) => {
        return this.appFactory.createTransaction.create(SubscriptionsPluginParamsFactory.create.create(params));
      }
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the SubscriptionsPlugin smart contract using an ABI method call using the create(uint64,string)void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      create: async (params) => {
        const result = await this.appFactory.send.create(SubscriptionsPluginParamsFactory.create.create(params));
        return { result: { ...result.result, return: result.result.return }, appClient: new SubscriptionsPluginClient(result.appClient) };
      }
    }
  };
};
var SubscriptionsPluginClient = class _SubscriptionsPluginClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  appClient;
  constructor(appClientOrParams) {
    this.appClient = appClientOrParams instanceof _AppClient23 ? appClientOrParams : new _AppClient23({
      ...appClientOrParams,
      appSpec: APP_SPEC23
    });
  }
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue(method, returnValue) {
    return returnValue !== void 0 ? getArc56ReturnValue15(returnValue, this.appClient.getABIMethod(method), APP_SPEC23.structs) : void 0;
  }
  /**
   * Returns a new `SubscriptionsPluginClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  static async fromCreatorAndName(params) {
    return new _SubscriptionsPluginClient(await _AppClient23.fromCreatorAndName({ ...params, appSpec: APP_SPEC23 }));
  }
  /**
   * Returns an `SubscriptionsPluginClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(params) {
    return new _SubscriptionsPluginClient(await _AppClient23.fromNetwork({ ...params, appSpec: APP_SPEC23 }));
  }
  /** The ID of the app instance this client is linked to. */
  get appId() {
    return this.appClient.appId;
  }
  /** The app address of the app instance this client is linked to. */
  get appAddress() {
    return this.appClient.appAddress;
  }
  /** The name of the app. */
  get appName() {
    return this.appClient.appName;
  }
  /** The ARC-56 app spec being used */
  get appSpec() {
    return this.appClient.appSpec;
  }
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  get algorand() {
    return this.appClient.algorand;
  }
  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  params = {
    /**
     * Makes a clear_state call to an existing instance of the SubscriptionsPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.params.bare.clearState(params);
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `optIn(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    optIn: (params) => {
      return this.appClient.params.call(SubscriptionsPluginParamsFactory.optIn(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `initDescription(uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    initDescription: (params) => {
      return this.appClient.params.call(SubscriptionsPluginParamsFactory.initDescription(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `loadDescription(uint64,uint64,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    loadDescription: (params) => {
      return this.appClient.params.call(SubscriptionsPluginParamsFactory.loadDescription(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `newService(uint64,bool,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    newService: (params) => {
      return this.appClient.params.call(SubscriptionsPluginParamsFactory.newService(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `pauseService(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    pauseService: (params) => {
      return this.appClient.params.call(SubscriptionsPluginParamsFactory.pauseService(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `shutdownService(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    shutdownService: (params) => {
      return this.appClient.params.call(SubscriptionsPluginParamsFactory.shutdownService(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `block(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    block: (params) => {
      return this.appClient.params.call(SubscriptionsPluginParamsFactory.block(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `unblock(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    unblock: (params) => {
      return this.appClient.params.call(SubscriptionsPluginParamsFactory.unblock(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `subscribe(uint64,bool,uint64,address,uint64,uint64,uint64,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    subscribe: (params) => {
      return this.appClient.params.call(SubscriptionsPluginParamsFactory.subscribe(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `triggerPayment(uint64,bool,address,uint64,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    triggerPayment: (params) => {
      return this.appClient.params.call(SubscriptionsPluginParamsFactory.triggerPayment(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `streakCheck(uint64,bool,(address,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    streakCheck: (params) => {
      return this.appClient.params.call(SubscriptionsPluginParamsFactory.streakCheck(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `setPasses(uint64,bool,uint64,address[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setPasses: (params) => {
      return this.appClient.params.call(SubscriptionsPluginParamsFactory.setPasses(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateAkitaDao: (params) => {
      return this.appClient.params.call(SubscriptionsPluginParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.params.call(SubscriptionsPluginParamsFactory.opUp(params));
    }
  };
  /**
   * Create transactions for the current app
   */
  createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the SubscriptionsPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.createTransaction.bare.clearState(params);
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `optIn(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    optIn: (params) => {
      return this.appClient.createTransaction.call(SubscriptionsPluginParamsFactory.optIn(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `initDescription(uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    initDescription: (params) => {
      return this.appClient.createTransaction.call(SubscriptionsPluginParamsFactory.initDescription(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `loadDescription(uint64,uint64,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    loadDescription: (params) => {
      return this.appClient.createTransaction.call(SubscriptionsPluginParamsFactory.loadDescription(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `newService(uint64,bool,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    newService: (params) => {
      return this.appClient.createTransaction.call(SubscriptionsPluginParamsFactory.newService(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `pauseService(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    pauseService: (params) => {
      return this.appClient.createTransaction.call(SubscriptionsPluginParamsFactory.pauseService(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `shutdownService(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    shutdownService: (params) => {
      return this.appClient.createTransaction.call(SubscriptionsPluginParamsFactory.shutdownService(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `block(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    block: (params) => {
      return this.appClient.createTransaction.call(SubscriptionsPluginParamsFactory.block(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `unblock(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    unblock: (params) => {
      return this.appClient.createTransaction.call(SubscriptionsPluginParamsFactory.unblock(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `subscribe(uint64,bool,uint64,address,uint64,uint64,uint64,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    subscribe: (params) => {
      return this.appClient.createTransaction.call(SubscriptionsPluginParamsFactory.subscribe(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `triggerPayment(uint64,bool,address,uint64,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    triggerPayment: (params) => {
      return this.appClient.createTransaction.call(SubscriptionsPluginParamsFactory.triggerPayment(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `streakCheck(uint64,bool,(address,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    streakCheck: (params) => {
      return this.appClient.createTransaction.call(SubscriptionsPluginParamsFactory.streakCheck(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `setPasses(uint64,bool,uint64,address[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setPasses: (params) => {
      return this.appClient.createTransaction.call(SubscriptionsPluginParamsFactory.setPasses(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateAkitaDao: (params) => {
      return this.appClient.createTransaction.call(SubscriptionsPluginParamsFactory.updateAkitaDao(params));
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    opUp: (params = { args: [] }) => {
      return this.appClient.createTransaction.call(SubscriptionsPluginParamsFactory.opUp(params));
    }
  };
  /**
   * Send calls to the current app
   */
  send = {
    /**
     * Makes a clear_state call to an existing instance of the SubscriptionsPlugin smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params) => {
      return this.appClient.send.bare.clearState(params);
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `optIn(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    optIn: async (params) => {
      const result = await this.appClient.send.call(SubscriptionsPluginParamsFactory.optIn(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `initDescription(uint64,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    initDescription: async (params) => {
      const result = await this.appClient.send.call(SubscriptionsPluginParamsFactory.initDescription(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `loadDescription(uint64,uint64,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    loadDescription: async (params) => {
      const result = await this.appClient.send.call(SubscriptionsPluginParamsFactory.loadDescription(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `newService(uint64,bool,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    newService: async (params) => {
      const result = await this.appClient.send.call(SubscriptionsPluginParamsFactory.newService(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `pauseService(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    pauseService: async (params) => {
      const result = await this.appClient.send.call(SubscriptionsPluginParamsFactory.pauseService(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `shutdownService(uint64,bool,uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    shutdownService: async (params) => {
      const result = await this.appClient.send.call(SubscriptionsPluginParamsFactory.shutdownService(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `block(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    block: async (params) => {
      const result = await this.appClient.send.call(SubscriptionsPluginParamsFactory.block(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `unblock(uint64,bool,address)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    unblock: async (params) => {
      const result = await this.appClient.send.call(SubscriptionsPluginParamsFactory.unblock(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `subscribe(uint64,bool,uint64,address,uint64,uint64,uint64,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    subscribe: async (params) => {
      const result = await this.appClient.send.call(SubscriptionsPluginParamsFactory.subscribe(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `triggerPayment(uint64,bool,address,uint64,byte[][])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    triggerPayment: async (params) => {
      const result = await this.appClient.send.call(SubscriptionsPluginParamsFactory.triggerPayment(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `streakCheck(uint64,bool,(address,uint64))void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    streakCheck: async (params) => {
      const result = await this.appClient.send.call(SubscriptionsPluginParamsFactory.streakCheck(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `setPasses(uint64,bool,uint64,address[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setPasses: async (params) => {
      const result = await this.appClient.send.call(SubscriptionsPluginParamsFactory.setPasses(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateAkitaDao: async (params) => {
      const result = await this.appClient.send.call(SubscriptionsPluginParamsFactory.updateAkitaDao(params));
      return { ...result, return: result.return };
    },
    /**
     * Makes a call to the SubscriptionsPlugin smart contract using the `opUp()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    opUp: async (params = { args: [] }) => {
      const result = await this.appClient.send.call(SubscriptionsPluginParamsFactory.opUp(params));
      return { ...result, return: result.return };
    }
  };
  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  clone(params) {
    return new _SubscriptionsPluginClient(this.appClient.clone(params));
  }
  /**
   * Methods to access state for the current SubscriptionsPlugin app
   */
  state = {
    /**
     * Methods to access global state for the current SubscriptionsPlugin app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async () => {
        const result = await this.appClient.state.global.getAll();
        return {
          version: result.version,
          akitaDao: result.akitaDAO
        };
      },
      /**
       * Get the current value of the version key in global state
       */
      version: async () => {
        return await this.appClient.state.global.getValue("version");
      },
      /**
       * Get the current value of the akitaDAO key in global state
       */
      akitaDao: async () => {
        return await this.appClient.state.global.getValue("akitaDAO");
      }
    },
    /**
     * Methods to access box state for the current SubscriptionsPlugin app
     */
    box: {
      /**
       * Get all current keyed values from box state
       */
      getAll: async () => {
        const result = await this.appClient.state.box.getAll();
        return {
          description: new BinaryStateValue3(result.description)
        };
      },
      /**
       * Get the current value of the description key in box state
       */
      description: async () => {
        return new BinaryStateValue3(await this.appClient.state.box.getValue("description"));
      }
    }
  };
  newGroup() {
    const client = this;
    const composer = this.algorand.newGroup();
    let promiseChain = Promise.resolve();
    const resultMappers = [];
    return {
      /**
       * Add a optIn(uint64,bool,uint64)void method call against the SubscriptionsPlugin contract
       */
      optIn(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.optIn(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a initDescription(uint64,uint64)void method call against the SubscriptionsPlugin contract
       */
      initDescription(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.initDescription(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a loadDescription(uint64,uint64,byte[])void method call against the SubscriptionsPlugin contract
       */
      loadDescription(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.loadDescription(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a newService(uint64,bool,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64 method call against the SubscriptionsPlugin contract
       */
      newService(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.newService(params)));
        resultMappers.push((v) => client.decodeReturnValue("newService(uint64,bool,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64", v));
        return this;
      },
      /**
       * Add a pauseService(uint64,bool,uint64)void method call against the SubscriptionsPlugin contract
       */
      pauseService(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.pauseService(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a shutdownService(uint64,bool,uint64)void method call against the SubscriptionsPlugin contract
       */
      shutdownService(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.shutdownService(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a block(uint64,bool,address)void method call against the SubscriptionsPlugin contract
       */
      block(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.block(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a unblock(uint64,bool,address)void method call against the SubscriptionsPlugin contract
       */
      unblock(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.unblock(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a subscribe(uint64,bool,uint64,address,uint64,uint64,uint64,byte[][])void method call against the SubscriptionsPlugin contract
       */
      subscribe(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.subscribe(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a triggerPayment(uint64,bool,address,uint64,byte[][])void method call against the SubscriptionsPlugin contract
       */
      triggerPayment(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.triggerPayment(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a streakCheck(uint64,bool,(address,uint64))void method call against the SubscriptionsPlugin contract
       */
      streakCheck(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.streakCheck(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a setPasses(uint64,bool,uint64,address[])void method call against the SubscriptionsPlugin contract
       */
      setPasses(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.setPasses(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a updateAkitaDAO(uint64)void method call against the SubscriptionsPlugin contract
       */
      updateAkitaDao(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateAkitaDao(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a opUp()void method call against the SubscriptionsPlugin contract
       */
      opUp(params) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.opUp(params)));
        resultMappers.push(void 0);
        return this;
      },
      /**
       * Add a clear state call to the SubscriptionsPlugin contract
       */
      clearState(params) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)));
        return this;
      },
      addTransaction(txn, signer) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer));
        return this;
      },
      async composer() {
        await promiseChain;
        return composer;
      },
      async simulate(options) {
        var _a;
        await promiseChain;
        const result = await (!options ? composer.simulate() : composer.simulate(options));
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      },
      async send(params) {
        var _a;
        await promiseChain;
        const result = await composer.send(params);
        return {
          ...result,
          returns: (_a = result.returns) == null ? void 0 : _a.map((val, i) => resultMappers[i] !== void 0 ? resultMappers[i](val) : val.returnValue)
        };
      }
    };
  }
};

// src/wallet/plugins/subscriptions.ts
var SubscriptionsPluginSDK = class extends BaseSDK {
  constructor(params) {
    super({ factory: SubscriptionsPluginFactory, ...params });
  }
  optIn(args) {
    const methodName = "optIn";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.optIn({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  initDescription(args) {
    const methodName = "initDescription";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const params = await this.client.params.initDescription({
          ...sendParams,
          args: { wallet, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  loadDescription(args) {
    const methodName = "loadDescription";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const params = await this.client.params.loadDescription({
          ...sendParams,
          args: { wallet, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  newService(args) {
    const methodName = "newService";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer, rekeyBack: rekeyBackArg, ...rest } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = rekeyBackArg ?? true;
        const params = await this.client.params.newService({
          ...sendParams,
          args: { wallet, rekeyBack, ...rest }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  pauseService(args) {
    const methodName = "pauseService";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.pauseService({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  shutdownService(args) {
    const methodName = "shutdownService";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.shutdownService({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  block(args) {
    const methodName = "block";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.block({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  unblock(args) {
    const methodName = "unblock";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.unblock({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  subscribe(args) {
    const methodName = "subscribe";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer, asset = 0n, index = 0n, args: gateArgs = [], ...rest } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.subscribe({
          ...sendParams,
          args: { wallet, rekeyBack, asset, index, args: gateArgs, ...rest }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  triggerPayment(args) {
    const methodName = "triggerPayment";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer, args: gateArgs = [], ...rest } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.triggerPayment({
          ...sendParams,
          args: { wallet, rekeyBack, args: gateArgs, ...rest }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  streakCheck(args) {
    const methodName = "streakCheck";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.streakCheck({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
  setPasses(args) {
    const methodName = "setPasses";
    if (args === void 0) {
      return (spendingAddress) => ({
        appId: this.client.appId,
        selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
        getTxns
      });
    }
    const { sender, signer } = args;
    const sendParams = this.getRequiredSendParams({ sender, signer });
    return (spendingAddress) => ({
      appId: this.client.appId,
      selectors: [this.client.appClient.getABIMethod(methodName).getSelector()],
      getTxns: async ({ wallet }) => {
        const rekeyBack = args.rekeyBack ?? true;
        const params = await this.client.params.setPasses({
          ...sendParams,
          args: { wallet, rekeyBack, ...args }
        });
        return [{
          type: "methodCall",
          ...params
        }];
      }
    });
  }
};

// src/wallet/types.ts
var AddPluginDefaults = {
  escrow: "",
  name: "",
  useExecutionKey: false,
  useRounds: false,
  admin: false,
  delegationType: 0n,
  coverFees: false,
  canReclaim: true
};
function isFlatAllowance(info) {
  return info.type === "flat";
}
function isWindowAllowance(info) {
  return info.type === "window";
}
function isDripAllowance(info) {
  return info.type === "drip";
}
function isValidPluginSDK(sdk) {
  return sdk && typeof sdk === "object" && typeof sdk.appId === "bigint" && sdk.client && typeof sdk.client.appId === "bigint" && typeof sdk.client.appAddress === "string" && sdk.algorand;
}
function getPluginAppId(plugin) {
  return plugin.appId;
}

// src/wallet/index.ts
var WalletSDK = class extends BaseSDK {
  pluginMapKeyGenerator = ({ plugin, caller = ALGORAND_ZERO_ADDRESS_STRING3, escrow = "" }) => `${plugin}${caller}${escrow}`;
  plugins = new ValueMap(this.pluginMapKeyGenerator);
  namedPlugins = /* @__PURE__ */ new Map();
  escrows = /* @__PURE__ */ new Map();
  allowanceMapKeyGenerator = ({ asset, escrow }) => `${asset}${escrow}`;
  allowances = new ValueMap(this.allowanceMapKeyGenerator);
  executions = /* @__PURE__ */ new Map();
  constructor(params) {
    super({ factory: AbstractedAccountFactory, ...params }, ENV_VAR_NAMES.WALLET_APP_ID);
  }
  group() {
    return new WalletGroupComposer(this);
  }
  async updateCache(key, allowances) {
    const { escrow } = key;
    const requestList = [this.getPluginByKey(key)];
    if (escrow !== "" && !this.escrows.has(escrow)) {
      requestList.push(this.getEscrow(escrow));
    } else {
      requestList.push(Promise.resolve());
    }
    const fetchAllFloor = 5;
    if (allowances && allowances.length > 0) {
      if (allowances.length > fetchAllFloor) {
        requestList.push(this.getAllowances());
      } else {
        for (const allowance of allowances) {
          requestList.push(this.getAllowance({ asset: allowance, escrow }));
        }
      }
    }
    const settled = await Promise.allSettled(requestList);
    if (settled[0].status === "fulfilled") {
      this.plugins.set(key, settled[0].value);
    }
    if (escrow !== "" && !this.escrows.has(escrow) && settled[1].status === "fulfilled") {
      this.escrows.set(escrow, settled[1].value);
    }
    if (allowances && allowances.length > 0 && !(allowances.length > fetchAllFloor)) {
      for (let i = 0; i < allowances.length; i++) {
        const req = settled[i + 2];
        if (req.status === "fulfilled") {
          this.allowances.set(
            { asset: allowances[i], escrow },
            req.value
          );
        }
      }
    }
  }
  async prepareUsePlugin({
    sender,
    signer,
    name = "",
    global = false,
    escrow = "",
    fundsRequest = [],
    calls,
    lease = ""
  }) {
    const sendParams = this.getSendParams({ sender, signer });
    let spendingAddress = await this.client.state.global.controlledAddress();
    if (escrow !== "") {
      let id = 0n;
      if (this.escrows.has(escrow)) {
        id = this.escrows.get(escrow).id;
      } else {
        try {
          id = (await this.getEscrow(escrow)).id;
        } catch (error) {
          throw new Error(`Escrow with name ${escrow} does not exist`);
        }
      }
      spendingAddress = algosdk6.getApplicationAddress(id).toString();
    }
    const segments = [];
    for (const call of calls) {
      const { appId, getTxns: getTxns2, opUpCount = 0 } = call(spendingAddress);
      const callTxns = await getTxns2({ wallet: this.client.appId });
      const last = segments[segments.length - 1];
      if (last && last.appId === appId) {
        last.txns.push(...callTxns);
        last.opUpCount += opUpCount;
      } else {
        segments.push({ appId, txns: callTxns, opUpCount });
      }
    }
    let caller = "";
    if (global) {
      caller = ALGORAND_ZERO_ADDRESS_STRING3;
    } else if (sendParams.sender !== void 0) {
      caller = sendParams.sender instanceof Address5 ? sendParams.sender.toString() : sendParams.sender;
    } else {
      throw new Error("Sender must be provided for non-global plugin calls");
    }
    const group = this.client.newGroup();
    let totalOpUpCount = 0;
    let lastUseRounds = false;
    let lastPluginAppId = 0n;
    for (let segIdx = 0; segIdx < segments.length; segIdx++) {
      const segment = segments[segIdx];
      const isFirstSegment = segIdx === 0;
      lastPluginAppId = segment.appId;
      totalOpUpCount += segment.opUpCount;
      const key = { plugin: segment.appId, caller, escrow };
      let methods = [];
      let useRounds = false;
      let useExecutionKey = false;
      if (this.plugins.has(key)) {
        ({ methods, useRounds, useExecutionKey } = this.plugins.get(key));
      } else {
        ({ methods, useRounds, useExecutionKey } = await this.getPluginByKey(key));
      }
      lastUseRounds = useRounds;
      const methodOffsets = [];
      const methodSignatures = [];
      if (methods.length > 0) {
        for (let i = 0; i < methods.length; i++) {
          methodSignatures.push(methods[i].name.toString());
        }
        for (const txn of segment.txns) {
          if (txn.type === "methodCall" && "appId" in txn && txn.appId === segment.appId) {
            const selector = txn.method.getSelector();
            if (!methodSignatures.includes(selector.toString())) {
              throw new Error(`Transaction selector does not match any allowed method signatures`);
            }
            methodOffsets.push(methodSignatures.indexOf(selector.toString()));
          }
        }
      }
      const rekeyArgs = {
        global,
        escrow,
        methodOffsets,
        // fundsRequest only on the first segment's rekey
        fundsRequest: isFirstSegment ? fundsRequest == null ? void 0 : fundsRequest.map(({ asset, amount }) => [asset, amount]) : []
      };
      let boxReferences = [];
      if (isFirstSegment) {
        if (lease !== "") {
          boxReferences.push(executionBoxKey(lease));
        }
        if (useExecutionKey) {
          if (!hasSenderSigner(sendParams)) {
            throw new Error("Sender and signer must be provided");
          }
          boxReferences.push(domainBoxKey(sendParams.sender));
        }
      }
      if (name && segments.length === 1) {
        group.arc58RekeyToNamedPlugin({
          ...sendParams,
          args: {
            name,
            ...rekeyArgs
          },
          extraFee: isFirstSegment ? microAlgo6(1000n + BigInt(fundsRequest.length * 1e3)) : microAlgo6(1000n),
          boxReferences: boxReferences.length > 0 ? boxReferences : void 0
        });
      } else {
        group.arc58RekeyToPlugin({
          ...sendParams,
          args: {
            plugin: segment.appId,
            ...rekeyArgs
          },
          extraFee: isFirstSegment ? microAlgo6(1000n + BigInt(fundsRequest.length * 1e3)) : microAlgo6(1000n),
          boxReferences: boxReferences.length > 0 ? boxReferences : void 0
        });
      }
      const composer = await group.composer();
      for (const txn of segment.txns) {
        switch (txn.type) {
          case "pay": {
            composer.addPayment(txn);
            break;
          }
          case "assetCreate": {
            composer.addAssetCreate(txn);
            break;
          }
          case "assetConfig": {
            composer.addAssetConfig(txn);
            break;
          }
          case "assetFreeze": {
            composer.addAssetFreeze(txn);
            break;
          }
          case "assetDestroy": {
            composer.addAssetDestroy(txn);
            break;
          }
          case "assetTransfer": {
            composer.addAssetTransfer(txn);
            break;
          }
          case "assetOptIn": {
            composer.addAssetOptIn(txn);
            break;
          }
          case "assetOptOut": {
            composer.addAssetOptOut(txn);
            break;
          }
          case "appCall": {
            if ("appId" in txn && "approvalProgram" in txn) {
              composer.addAppUpdate(txn);
            } else if ("appId" in txn) {
              composer.addAppCall(txn);
            } else {
              composer.addAppCreate(txn);
            }
            break;
          }
          case "keyReg": {
            if ("voteKey" in txn) {
              composer.addOnlineKeyRegistration(txn);
            } else {
              composer.addOfflineKeyRegistration(txn);
            }
            break;
          }
          case "txnWithSigner": {
            composer.addTransaction(txn.txn, txn.signer);
            break;
          }
          case "atc": {
            composer.addAtc(txn.atc);
            break;
          }
          case "methodCall": {
            if ("appId" in txn && "approvalProgram" in txn) {
              composer.addAppUpdateMethodCall(txn);
            } else if ("appId" in txn) {
              composer.addAppCallMethodCall(txn);
            } else {
              composer.addAppCreateMethodCall(txn);
            }
            break;
          }
          default: {
            throw new Error(`Unknown transaction type`);
          }
        }
      }
      group.arc58VerifyAuthAddress({
        ...sendParams,
        args: {},
        ...segments.length > 1 ? { note: new TextEncoder().encode(`v${segIdx}`) } : {}
      });
    }
    const ABI_TXN_TYPES = ["txn", "pay", "keyreg", "acfg", "axfer", "afrz", "appl"];
    let actualTxnCount = 0;
    for (const segment of segments) {
      actualTxnCount += 2;
      for (const txn of segment.txns) {
        actualTxnCount += 1;
        if (txn.type === "methodCall") {
          for (const arg of txn.method.args) {
            if (typeof arg.type === "string" && ABI_TXN_TYPES.includes(arg.type)) {
              actualTxnCount += 1;
            }
          }
        }
      }
    }
    const hasSigner = hasSenderSigner(sendParams);
    const opUpLimit = Math.min(totalOpUpCount, 16 - actualTxnCount);
    if (totalOpUpCount > 0 && hasSigner && opUpLimit > 0) {
      const opUpComposer = await group.composer();
      for (let i = 0; i < opUpLimit; i++) {
        opUpComposer.addAppCallMethodCall({
          sender: sendParams.sender,
          signer: sendParams.signer,
          appId: lastPluginAppId,
          method: algosdk6.ABIMethod.fromSignature("opUp()void"),
          args: [],
          maxFee: microAlgo6(1e3),
          note: new TextEncoder().encode(String(i))
        });
      }
    }
    const length = await (await group.composer()).count();
    const plugins = [...new Set(segments.map((s) => s.appId))];
    return { plugins, caller, useRounds: lastUseRounds, length, group, sendParams };
  }
  async register({ sender, signer, escrow }) {
    const sendParams = this.getSendParams({ sender, signer });
    await this.client.send.register({
      ...sendParams,
      args: {
        escrow
      }
    });
  }
  async changeRevocationApp({ sender, signer, app }) {
    const sendParams = this.getSendParams({ sender, signer });
    await this.client.send.setRevocationApp({
      ...sendParams,
      args: { app }
    });
  }
  async setNickname({ sender, signer, nickname }) {
    const sendParams = this.getSendParams({ sender, signer });
    await this.client.send.setNickname({
      ...sendParams,
      args: { nickname }
    });
  }
  async setAvatar({ sender, signer, avatar }) {
    const sendParams = this.getSendParams({ sender, signer });
    await this.client.send.setAvatar({
      ...sendParams,
      args: { avatar }
    });
  }
  async setBanner({ sender, signer, banner }) {
    const sendParams = this.getSendParams({ sender, signer });
    await this.client.send.setBanner({
      ...sendParams,
      args: { banner }
    });
  }
  async setBio({ sender, signer, bio }) {
    const sendParams = this.getSendParams({ sender, signer });
    await this.client.send.setBio({
      ...sendParams,
      args: { bio }
    });
  }
  async changeAdmin({ sender, signer, newAdmin }) {
    const sendParams = this.getSendParams({ sender, signer });
    await this.client.send.arc58ChangeAdmin({
      ...sendParams,
      args: { newAdmin }
    });
  }
  async verifyAuthAddress(params) {
    const sendParams = this.getSendParams(params);
    await this.client.send.arc58VerifyAuthAddress({
      ...sendParams,
      args: {}
    });
  }
  async rekeyTo({ sender, signer, ...args }) {
    const sendParams = this.getSendParams({ sender, signer });
    await this.client.send.arc58RekeyTo({ ...sendParams, args });
  }
  async canCall({ sender, signer, ...args }) {
    const sendParams = this.getSendParams({ sender, signer });
    const methods = isPluginSDKReturn(args.methods) ? args.methods().selectors : args.methods;
    const result = await Promise.allSettled(methods.flatMap((method) => {
      return this.client.send.arc58CanCall({ ...sendParams, args: { ...args, method } });
    }));
    return result.map((x) => x.status === "fulfilled" ? x.value : false);
  }
  async usePlugin(params) {
    const sendParams = this.getSendParams(params);
    const { escrow = "", fundsRequest = [], consolidateFees = false } = params;
    const hasAlgoFundsRequest = fundsRequest.length > 0 && fundsRequest.some((fr) => fr.asset === 0n);
    const suggestedParams = await this.client.algorand.getSuggestedParams();
    const MAX_SIM_FEE = BigInt(suggestedParams.minFee) * 272n;
    const buildFundsRequest = hasAlgoFundsRequest ? fundsRequest.map((fr) => fr.asset === 0n ? { ...fr, amount: fr.amount + MAX_SIM_FEE } : fr) : fundsRequest;
    const { plugins, caller, length, group, sendParams: preparedSendParams } = await this.prepareUsePlugin({ ...params, fundsRequest: buildFundsRequest });
    let result;
    if (consolidateFees || hasAlgoFundsRequest) {
      const atc = (await (await group.composer()).build()).atc;
      const appliedAtc = forceProperties(atc, {
        sender: preparedSendParams.sender,
        signer: preparedSendParams.signer
      });
      const maxFees = new Map(
        Array.from({ length }, (_, i) => [i, microAlgo6(MAX_SIM_FEE)])
      );
      const { atc: populatedAtc } = await prepareGroupWithCost(
        appliedAtc,
        this.client.algorand.client.algod,
        {
          coverAppCallInnerTransactionFees: true,
          populateAppCallResources: true
        },
        {
          maxFees,
          suggestedParams
        }
      );
      const feeGroup = populatedAtc.clone().buildGroup();
      const totalFees = feeGroup.reduce((acc, txn) => acc + txn.txn.fee, 0n);
      let finalAtc = populatedAtc;
      if (hasAlgoFundsRequest) {
        const modifiedGroup = populatedAtc.clone().buildGroup();
        const rekeyTxn = modifiedGroup[0];
        const appArgs = rekeyTxn.txn.applicationCall.appArgs;
        const fundsRequestArgIndex = appArgs.length - 1;
        appArgs[fundsRequestArgIndex] = this.adjustFundsRequestAmounts(
          appArgs[fundsRequestArgIndex],
          fundsRequest,
          totalFees
        );
        const rebuiltAtc = new algosdk6.AtomicTransactionComposer();
        modifiedGroup.forEach((t) => {
          t.txn["group"] = void 0;
          rebuiltAtc.addTransaction(t);
        });
        rebuiltAtc["methodCalls"] = populatedAtc["methodCalls"];
        finalAtc = rebuiltAtc;
      }
      const consolidatedAtc = forceProperties(finalAtc, {
        fees: new Map([
          [0, microAlgo6(totalFees)],
          ...Array.from({ length: length - 1 }, (_, i) => [i + 1, microAlgo6(0n)])
        ])
      });
      result = await this.client.algorand.newGroup().addAtc(consolidatedAtc).send();
    } else {
      result = await group.send({ ...sendParams });
    }
    for (const plugin of plugins) {
      await this.updateCache(
        { plugin, caller, escrow },
        fundsRequest == null ? void 0 : fundsRequest.map(({ asset }) => asset)
      ).catch((error) => {
        console.warn("Failed to update plugin cache:", error);
      });
    }
    return result;
  }
  /**
   * Modify the ABI-encoded fundsRequest argument in a rekey transaction.
   * Replaces the inflated simulation amounts with the correct amounts (original + realFee).
   *
   * The fundsRequest arg is encoded as `(uint64,uint64)[]`:
   *   2 bytes: element count (big-endian uint16)
   *   Per element: 8 bytes asset (big-endian uint64) + 8 bytes amount (big-endian uint64)
   */
  adjustFundsRequestAmounts(encoded, originalFR, realFee) {
    const result = new Uint8Array(encoded);
    const view = new DataView(result.buffer, result.byteOffset, result.byteLength);
    const count = view.getUint16(0);
    for (let i = 0; i < count; i++) {
      const offset = 2 + i * 16;
      const asset = view.getBigUint64(offset);
      const original = originalFR.find((fr) => fr.asset === asset);
      if (original && asset === 0n) {
        view.setBigUint64(offset + 8, original.amount + realFee);
      }
    }
    return result;
  }
  async addPlugin({
    sender,
    signer,
    name = "",
    client,
    caller,
    global = false,
    methods = [],
    escrow = "",
    admin = false,
    delegationType = 0n,
    lastValid = MAX_UINT64,
    cooldown = 0n,
    useRounds = false,
    useExecutionKey = false,
    coverFees = false,
    canReclaim = true,
    defaultToEscrow = false,
    allowances = []
  }) {
    const sendParams = this.getSendParams({ sender, signer });
    const plugin = client.appId;
    if (global) {
      caller = ALGORAND_ZERO_ADDRESS_STRING3;
    }
    let transformedMethods = [];
    if (methods.length > 0) {
      transformedMethods = methods.reduce(
        (acc, method) => {
          if (isPluginSDKReturn(method.name)) {
            const selectors = method.name().selectors ?? [];
            selectors.forEach((selector) => acc.push([selector, method.cooldown]));
          } else {
            method.name.forEach((x) => acc.push([x, method.cooldown]));
          }
          return acc;
        },
        []
      );
    }
    const newEscrow = escrow !== "" && !this.escrows.get(escrow);
    const controlledAddress = await this.client.state.global.controlledAddress();
    const hasExternalControlledAddress = controlledAddress !== this.client.appAddress.toString();
    const extraFee = microAlgo6((newEscrow ? NewEscrowFeeAmount : 0n) + (hasExternalControlledAddress ? 1000n : 0n));
    const args = {
      plugin,
      caller,
      escrow,
      admin,
      delegationType,
      lastValid,
      cooldown,
      methods: transformedMethods,
      useRounds,
      useExecutionKey,
      coverFees,
      canReclaim,
      defaultToEscrow
    };
    const group = this.client.newGroup();
    if (name !== "") {
      group.arc58AddNamedPlugin({
        ...sendParams,
        args: { name, ...args },
        extraFee
      });
    } else {
      group.arc58AddPlugin({
        ...sendParams,
        args,
        extraFee
      });
    }
    if (allowances.length > 0) {
      if (escrow === "") {
        throw new Error("Allowances can only be added to plugins with an escrow");
      }
      group.arc58AddAllowances({
        ...sendParams,
        args: {
          escrow,
          allowances: AllowancesToTuple(allowances)
        }
      });
    }
    const result = await group.send();
    const postProcess = [];
    if (newEscrow) {
      postProcess.push(this.register({ escrow }));
    }
    postProcess.push(this.updateCache(
      { plugin, caller, escrow },
      allowances.map((allowance) => allowance.asset)
    ).catch((error) => {
      console.warn("Failed to update plugin cache:", error);
    }));
    await Promise.all(postProcess);
    return result;
  }
  async removePlugin({ sender, signer, ...args }) {
    const sendParams = this.getSendParams({ sender, signer });
    return await this.client.send.arc58RemovePlugin({
      ...sendParams,
      args
    });
  }
  async newEscrow({ sender, signer, ...args }) {
    const sendParams = this.getSendParams({ sender, signer });
    return await this.client.send.arc58NewEscrow({
      ...sendParams,
      args
    });
  }
  async toggleEscrowLock({ sender, signer, ...args }) {
    const sendParams = this.getSendParams({ sender, signer });
    return await this.client.send.arc58ToggleEscrowLock({
      ...sendParams,
      args
    });
  }
  async reclaimFunds({ sender, signer, ...args }) {
    const sendParams = this.getSendParams({ sender, signer });
    return await this.client.send.arc58Reclaim({
      ...sendParams,
      args
    });
  }
  async optInEscrow({ sender, signer, ...args }) {
    const sendParams = this.getSendParams({ sender, signer });
    return await this.client.send.arc58OptInEscrow({ ...sendParams, args });
  }
  async addAllowances({ sender, signer, escrow, allowances }) {
    const sendParams = this.getSendParams({ sender, signer });
    return await this.client.send.arc58AddAllowances({
      ...sendParams,
      args: {
        escrow,
        allowances: AllowancesToTuple(allowances)
      }
    });
  }
  async removeAllowances({ sender, signer, ...args }) {
    const sendParams = this.getSendParams({ sender, signer });
    return await this.client.send.arc58RemoveAllowances({
      ...sendParams,
      args
    });
  }
  async addExecutionKey({ sender, signer, lease, groups, firstValid, lastValid }) {
    const sendParams = this.getSendParams({ sender, signer });
    return await this.client.send.arc58AddExecutionKey({
      ...sendParams,
      args: { lease, groups, firstValid, lastValid }
    });
  }
  async removeExecutionKey({ sender, signer, ...args }) {
    const sendParams = this.getSendParams({ sender, signer });
    return await this.client.send.arc58RemoveExecutionKey({
      ...sendParams,
      args
    });
  }
  build = {
    usePlugin: async ({ firstValid = 0n, windowSize = 0n, consolidateFees = true, skipSignatures = false, ...args }) => {
      const { lease } = args;
      const [
        suggestedParams,
        { plugins: _plugins, useRounds, length, group, sendParams },
        admin
      ] = await Promise.all([
        this.client.algorand.getSuggestedParams(),
        this.prepareUsePlugin(args),
        this.client.state.global.admin()
      ]);
      const validityPeriod = 1000n;
      const start = firstValid !== 0n ? firstValid : BigInt(suggestedParams.firstValid);
      if (windowSize === 0n) {
        windowSize = BigInt(suggestedParams.lastValid) - BigInt(suggestedParams.firstValid);
      }
      const f = (await (await group.composer()).build()).atc;
      const f1 = forceProperties(f, { sender: admin, signer: makeEmptyTransactionSigner() });
      let numGroupsToBuild;
      let endTarget;
      if (useRounds) {
        endTarget = start + windowSize;
        numGroupsToBuild = Math.ceil(Number(windowSize) / Number(validityPeriod));
      } else {
        const roundsNeeded = BigInt(Math.ceil(Number(windowSize) / 2.7));
        endTarget = start + roundsNeeded;
        numGroupsToBuild = Math.ceil(Number(roundsNeeded) / Number(validityPeriod));
      }
      const maxFees = new Map([
        ...Array.from({ length }, (_, i) => [i, microAlgo6(BigInt(suggestedParams.minFee) * 272n)])
      ]);
      const { atc: populatedGroup, expectedCost } = await prepareGroupWithCost(
        f1,
        this.client.algorand.client.algod,
        {
          coverAppCallInnerTransactionFees: true,
          populateAppCallResources: true
        },
        {
          maxFees,
          suggestedParams
        },
        admin
        // simulateAccount for account deltas
      );
      const signerToUse = skipSignatures ? makeEmptyTransactionSigner() : sendParams.signer;
      const groups = {
        lease: encodeLease(lease),
        firstValid: start,
        lastValid: endTarget,
        useRounds,
        ids: [],
        atcs: [],
        expectedCost,
        send: async (options) => {
          const status = await this.client.algorand.client.algod.status().do();
          const currentRound = BigInt(status.lastRound);
          let selectedIndex = -1;
          for (let i = 0; i < groups.atcs.length; i++) {
            const groupStart = groups.firstValid + BigInt(i) * validityPeriod;
            const groupEnd = i === groups.atcs.length - 1 ? groups.lastValid : groupStart + validityPeriod - 1n;
            if (currentRound >= groupStart && currentRound <= groupEnd) {
              selectedIndex = i;
              break;
            }
          }
          if (selectedIndex === -1) {
            throw new Error(
              `No valid group for current round ${currentRound}. Window: ${groups.firstValid}-${groups.lastValid}`
            );
          }
          const atc = groups.atcs[selectedIndex];
          if (skipSignatures) {
            if (!(options == null ? void 0 : options.signer)) {
              throw new Error("signer is required when skipSignatures is true");
            }
            const signedAtc = forceProperties(atc, { signer: options.signer });
            return await this.client.algorand.newGroup().addAtc(signedAtc).send();
          } else {
            const finalAtc = (options == null ? void 0 : options.signer) ? forceProperties(atc, { signer: options.signer }) : atc;
            return await this.client.algorand.newGroup().addAtc(finalAtc).send();
          }
        }
      };
      for (let i = 0; i < numGroupsToBuild; i++) {
        const groupStartRound = start + BigInt(i) * validityPeriod;
        let groupEndRound;
        if (i === numGroupsToBuild - 1) {
          groupEndRound = endTarget - 1n;
        } else {
          groupEndRound = groupStartRound + validityPeriod - 1n;
        }
        console.log(`Building group ${i + 1}/${numGroupsToBuild} with start: ${groupStartRound}, end: ${groupEndRound}`);
        let overwrite = {
          sender: sendParams.sender,
          signer: signerToUse,
          firstValid: groupStartRound,
          lastValid: groupEndRound,
          lease: groups.lease
        };
        if (consolidateFees) {
          const feeConsolidation = populatedGroup.clone().buildGroup();
          const totalFees = feeConsolidation.reduce((acc, txn) => acc + txn.txn.fee, 0n);
          overwrite.fees = new Map([
            [0, microAlgo6(totalFees)],
            ...Array.from({ length: length - 1 }, (_, i2) => [i2 + 1, microAlgo6(0)])
          ]);
        }
        const finalGroup = forceProperties(populatedGroup, overwrite);
        const groupID = finalGroup.buildGroup()[0].txn.group;
        groups.ids.push(groupID);
        groups.atcs.push(finalGroup);
      }
      return groups;
    }
  };
  async getGlobalState() {
    return await this.client.state.global.getAll();
  }
  async getAdmin() {
    return (await this.client.send.arc58GetAdmin()).return;
  }
  async getPlugins() {
    this.plugins = new ValueMap(
      this.pluginMapKeyGenerator,
      Array.from(
        await this.client.state.box.plugins.getMap(),
        ([key, info]) => {
          return [
            key,
            {
              ...info,
              methods: info.methods.map((method) => ({
                name: method[0],
                cooldown: method[1],
                lastCalled: method[2]
              }))
            }
          ];
        }
      )
    );
    return this.plugins;
  }
  async getPluginByKey(key) {
    const info = await this.client.state.box.plugins.value(key);
    const methods = info.methods.map((method) => ({
      name: method[0],
      cooldown: method[1],
      lastCalled: method[2]
    }));
    return { ...info, methods };
  }
  async getNamedPlugins() {
    this.namedPlugins = await this.client.state.box.namedPlugins.getMap();
    return this.namedPlugins;
  }
  async getPluginByName(name) {
    const infos = (await this.client.send.arc58GetNamedPlugins({ args: { names: [name] } })).return;
    const info = PluginInfoFromTuple(infos[0]);
    const methods = info.methods.map((method) => ({
      name: method[0],
      cooldown: method[1],
      lastCalled: method[2]
    }));
    return { ...info, methods };
  }
  async getEscrows() {
    this.escrows = await this.client.state.box.escrows.getMap();
    return this.escrows;
  }
  async getEscrow(escrow) {
    return EscrowInfoFromTuple((await this.client.send.arc58GetEscrows({ args: { escrows: [escrow] } })).return[0]);
  }
  async getAllowances() {
    this.allowances = new ValueMap(
      this.allowanceMapKeyGenerator,
      Array.from(
        await this.client.state.box.allowances.getMap(),
        ([key, info]) => {
          return [
            key,
            AllowanceInfoTranslate(info)
          ];
        }
      )
    );
    return this.allowances;
  }
  async getAllowance(key) {
    return AllowanceInfoTranslate(await this.client.state.box.allowances.value(key));
  }
  async getExecutions() {
    this.executions = await this.client.state.box.executions.getMap();
    return this.executions;
  }
  async getExecution(lease) {
    return await this.client.state.box.executions.value(lease);
  }
  async getMbr(args) {
    return (await this.client.send.mbr({ args })).return;
  }
  async balance(assets) {
    return (await this.client.send.balance({ args: { assets }, extraFee: microAlgo6(1e3 * assets.length) })).return;
  }
};

export {
  NewEscrowFeeAmount,
  WalletGroupComposer,
  WalletFactorySDK,
  newWallet,
  OptInPluginSDK,
  PayPluginSDK,
  AsaMintPluginSDK,
  UpdateAkitaDAOPluginSDK,
  RevenueManagerPluginSDK,
  AuctionPluginSDK,
  DAOPluginSDK,
  DualStakePluginSDK,
  GatePluginSDK,
  HyperSwapPluginSDK,
  MarketplacePluginSDK,
  NFDPluginSDK,
  PaySiloPluginSDK,
  PaySiloFactoryPluginSDK,
  PollPluginSDK,
  RafflePluginSDK,
  RewardsPluginSDK,
  SocialPluginSDK,
  StakingPluginSDK,
  StakingPoolPluginSDK,
  SubscriptionsPluginSDK,
  AddPluginDefaults,
  isFlatAllowance,
  isWindowAllowance,
  isDripAllowance,
  isValidPluginSDK,
  getPluginAppId,
  WalletSDK
};
//# sourceMappingURL=chunk-Y34KL4UO.mjs.map