/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client';
import { ABIReturn } from '@algorandfoundation/algokit-utils/types/app';
import { Arc56Contract } from '@algorandfoundation/algokit-utils/types/app-arc56';
import { AppClient as _AppClient, AppClientMethodCallParams, AppClientParams, AppClientBareCallParams, CallOnComplete, AppClientCompilationParams, ResolveAppClientByCreatorAndName, ResolveAppClientByNetwork, CloneAppClientParams } from '@algorandfoundation/algokit-utils/types/app-client';
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory';
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer';
import { SendParams, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction';
import { Address, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk';
export declare const APP_SPEC: Arc56Contract;
/**
 * A state record containing binary data
 */
export interface BinaryState {
    /**
     * Gets the state value as a Uint8Array
     */
    asByteArray(): Uint8Array | undefined;
    /**
     * Gets the state value as a string
     */
    asString(): string | undefined;
}
/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R ? (...args: Expand<A>) => Expand<R> : T extends infer O ? {
    [K in keyof O]: O[K];
} : never;
export type ObjectC3416591 = {
    valid: boolean;
    balance: bigint;
};
/**
 * Converts the ABI tuple representation of a ObjectC3416591 to the struct representation
 */
export declare function ObjectC3416591FromTuple(abiTuple: [boolean, bigint]): ObjectC3416591;
export type RootKey = {
    address: string;
    name: string;
};
/**
 * Converts the ABI tuple representation of a RootKey to the struct representation
 */
export declare function RootKeyFromTuple(abiTuple: [string, string]): RootKey;
export type AddRewardParams = {
    asset: bigint;
    distribution: number;
    rate: bigint;
    expiration: bigint;
    interval: bigint;
    winnerCount: bigint;
};
/**
 * Converts the ABI tuple representation of a AddRewardParams to the struct representation
 */
export declare function AddRewardParamsFromTuple(abiTuple: [bigint, number, bigint, bigint, bigint, bigint]): AddRewardParams;
export type EntryData = {
    address: string;
    asset: bigint;
    quantity: bigint;
    gateArgs: Uint8Array[];
    disqualified: boolean;
};
/**
 * Converts the ABI tuple representation of a EntryData to the struct representation
 */
export declare function EntryDataFromTuple(abiTuple: [string, bigint, bigint, Uint8Array[], boolean]): EntryData;
export type EntryKey = {
    address: string;
    asset: bigint;
};
/**
 * Converts the ABI tuple representation of a EntryKey to the struct representation
 */
export declare function EntryKeyFromTuple(abiTuple: [string, bigint]): EntryKey;
export type RaffleCursor = {
    ticket: bigint;
    stake: bigint;
    disbursed: bigint;
};
/**
 * Converts the ABI tuple representation of a RaffleCursor to the struct representation
 */
export declare function RaffleCursorFromTuple(abiTuple: [bigint, bigint, bigint]): RaffleCursor;
export type Reward = {
    asset: bigint;
    distribution: number;
    rate: bigint;
    expiration: bigint;
    interval: bigint;
    qualifiedStakers: bigint;
    qualifiedStake: bigint;
    winnerCount: bigint;
    winningTickets: bigint[];
    raffleCursor: RaffleCursor;
    vrfFailureCount: bigint;
    phase: number;
    disbursementCursor: bigint;
    activeDisbursementId: bigint;
    activeDisbursementRoundStart: bigint;
    lastDisbursementTimestamp: bigint;
};
/**
 * Converts the ABI tuple representation of a Reward to the struct representation
 */
export declare function RewardFromTuple(abiTuple: [bigint, number, bigint, bigint, bigint, bigint, bigint, bigint, bigint[], [bigint, bigint, bigint], bigint, number, bigint, bigint, bigint, bigint]): Reward;
export type StakingPoolMbrData = {
    entries: bigint;
    uniques: bigint;
    entriesByAddress: bigint;
    rewards: bigint;
    disbursements: bigint;
};
/**
 * Converts the ABI tuple representation of a StakingPoolMBRData to the struct representation
 */
export declare function StakingPoolMbrDataFromTuple(abiTuple: [bigint, bigint, bigint, bigint, bigint]): StakingPoolMbrData;
export type StakingPoolState = {
    status: number;
    title: string;
    type: number;
    signupTimestamp: bigint;
    startTimestamp: bigint;
    allowLateSignups: boolean;
    endTimestamp: bigint;
    maxEntries: bigint;
    entryCount: bigint;
    rewardCount: bigint;
    totalStaked: bigint;
    stakeKey: RootKey;
    minimumStakeAmount: bigint;
    gateId: bigint;
    creator: string;
};
/**
 * Converts the ABI tuple representation of a StakingPoolState to the struct representation
 */
export declare function StakingPoolStateFromTuple(abiTuple: [number, string, number, bigint, bigint, boolean, bigint, bigint, bigint, bigint, bigint, [string, string], bigint, bigint, string]): StakingPoolState;
export type FunderInfo = {
    account: string;
    amount: bigint;
};
/**
 * Converts the ABI tuple representation of a FunderInfo to the struct representation
 */
export declare function FunderInfoFromTuple(abiTuple: [string, bigint]): FunderInfo;
/**
 * The argument types for the StakingPool contract
 */
export type StakingPoolArgs = {
    /**
     * The object representation of the arguments for each method
     */
    obj: {
        'create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void': {
            title: string;
            type: bigint | number;
            creator: string;
            funder: FunderInfo;
            marketplace: string;
            stakeKey: RootKey;
            minimumStakeAmount: bigint | number;
            allowLateSignups: boolean;
            gateId: bigint | number;
            maxEntries: bigint | number;
            akitaDao: bigint | number;
            akitaDaoEscrow: bigint | number;
        };
        'init()void': Record<string, never>;
        'delete(address)void': {
            caller: string;
        };
        'optIn(pay,uint64)void': {
            /**
             * The payment transaction
             */
            payment: AppMethodCallTransactionArgument;
            /**
             * The asset to be opted into
             */
            asset: bigint | number;
        };
        'addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void': {
            payment: AppMethodCallTransactionArgument;
            reward: AddRewardParams;
        };
        'addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void': {
            payment: AppMethodCallTransactionArgument;
            assetXfer: AppMethodCallTransactionArgument;
            reward: AddRewardParams;
        };
        'finalize(uint64,uint64,uint64)void': {
            signupTimestamp: bigint | number;
            startTimestamp: bigint | number;
            endTimestamp: bigint | number;
        };
        'gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void': {
            payment?: AppMethodCallTransactionArgument;
            gateTxn: AppMethodCallTransactionArgument;
            entries: [bigint | number, bigint | number, Uint8Array[]][];
        };
        'enter(pay,(uint64,uint64,byte[32][])[])void': {
            payment: AppMethodCallTransactionArgument;
            entries: [bigint | number, bigint | number, Uint8Array[]][];
        };
        'startDisbursement(uint64)void': {
            rewardId: bigint | number;
        };
        'raffle(uint64)void': {
            rewardId: bigint | number;
        };
        'disburseRewards(uint64,uint64)void': {
            rewardId: bigint | number;
            iterationAmount: bigint | number;
        };
        'finalizeDistribution(uint64)void': {
            rewardId: bigint | number;
        };
        'check(address,uint64)(bool,uint64)': {
            address: string;
            asset: bigint | number;
        };
        'gateCheck(appl,address,uint64)void': {
            gateTxn: AppMethodCallTransactionArgument;
            address: string;
            asset: bigint | number;
        };
        'enterCost(address,uint64)uint64': {
            /**
             * The address that will be entering
             */
            address: string;
            /**
             * The number of entries being added
             */
            entryCount: bigint | number;
        };
        'optInCost(uint64)uint64': {
            asset: bigint | number;
        };
        'signUpsOpen()bool': Record<string, never>;
        'isLive()bool': Record<string, never>;
        'isEntered(address)bool': {
            address: string;
        };
        'getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)': Record<string, never>;
        'updateAkitaDAOEscrow(uint64)void': {
            app: bigint | number;
        };
        'update(string)void': {
            newVersion: string;
        };
        'updateAkitaDAO(uint64)void': {
            akitaDao: bigint | number;
        };
        'opUp()void': Record<string, never>;
        'mbr(uint64)(uint64,uint64,uint64,uint64,uint64)': {
            winningTickets: bigint | number;
        };
    };
    /**
     * The tuple representation of the arguments for each method
     */
    tuple: {
        'create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void': [title: string, type: bigint | number, creator: string, funder: FunderInfo, marketplace: string, stakeKey: RootKey, minimumStakeAmount: bigint | number, allowLateSignups: boolean, gateId: bigint | number, maxEntries: bigint | number, akitaDao: bigint | number, akitaDaoEscrow: bigint | number];
        'init()void': [];
        'delete(address)void': [caller: string];
        'optIn(pay,uint64)void': [payment: AppMethodCallTransactionArgument, asset: bigint | number];
        'addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void': [payment: AppMethodCallTransactionArgument, reward: AddRewardParams];
        'addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void': [payment: AppMethodCallTransactionArgument, assetXfer: AppMethodCallTransactionArgument, reward: AddRewardParams];
        'finalize(uint64,uint64,uint64)void': [signupTimestamp: bigint | number, startTimestamp: bigint | number, endTimestamp: bigint | number];
        'gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void': [payment: AppMethodCallTransactionArgument | undefined, gateTxn: AppMethodCallTransactionArgument, entries: [bigint | number, bigint | number, Uint8Array[]][]];
        'enter(pay,(uint64,uint64,byte[32][])[])void': [payment: AppMethodCallTransactionArgument, entries: [bigint | number, bigint | number, Uint8Array[]][]];
        'startDisbursement(uint64)void': [rewardId: bigint | number];
        'raffle(uint64)void': [rewardId: bigint | number];
        'disburseRewards(uint64,uint64)void': [rewardId: bigint | number, iterationAmount: bigint | number];
        'finalizeDistribution(uint64)void': [rewardId: bigint | number];
        'check(address,uint64)(bool,uint64)': [address: string, asset: bigint | number];
        'gateCheck(appl,address,uint64)void': [gateTxn: AppMethodCallTransactionArgument, address: string, asset: bigint | number];
        'enterCost(address,uint64)uint64': [address: string, entryCount: bigint | number];
        'optInCost(uint64)uint64': [asset: bigint | number];
        'signUpsOpen()bool': [];
        'isLive()bool': [];
        'isEntered(address)bool': [address: string];
        'getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)': [];
        'updateAkitaDAOEscrow(uint64)void': [app: bigint | number];
        'update(string)void': [newVersion: string];
        'updateAkitaDAO(uint64)void': [akitaDao: bigint | number];
        'opUp()void': [];
        'mbr(uint64)(uint64,uint64,uint64,uint64,uint64)': [winningTickets: bigint | number];
    };
};
/**
 * The return type for each method
 */
export type StakingPoolReturns = {
    'create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void': void;
    'init()void': void;
    'delete(address)void': void;
    'optIn(pay,uint64)void': void;
    'addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void': void;
    'addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void': void;
    'finalize(uint64,uint64,uint64)void': void;
    'gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void': void;
    'enter(pay,(uint64,uint64,byte[32][])[])void': void;
    'startDisbursement(uint64)void': void;
    'raffle(uint64)void': void;
    'disburseRewards(uint64,uint64)void': void;
    'finalizeDistribution(uint64)void': void;
    'check(address,uint64)(bool,uint64)': ObjectC3416591;
    'gateCheck(appl,address,uint64)void': void;
    'enterCost(address,uint64)uint64': bigint;
    'optInCost(uint64)uint64': bigint;
    'signUpsOpen()bool': boolean;
    'isLive()bool': boolean;
    'isEntered(address)bool': boolean;
    'getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)': StakingPoolState;
    'updateAkitaDAOEscrow(uint64)void': void;
    'update(string)void': void;
    'updateAkitaDAO(uint64)void': void;
    'opUp()void': void;
    'mbr(uint64)(uint64,uint64,uint64,uint64,uint64)': StakingPoolMbrData;
};
/**
 * Defines the types of available calls and state of the StakingPool smart contract.
 */
export type StakingPoolTypes = {
    /**
     * Maps method signatures / names to their argument and return types.
     */
    methods: Record<'create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void' | 'create', {
        argsObj: StakingPoolArgs['obj']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void'];
        argsTuple: StakingPoolArgs['tuple']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void'];
        returns: StakingPoolReturns['create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void'];
    }> & Record<'init()void' | 'init', {
        argsObj: StakingPoolArgs['obj']['init()void'];
        argsTuple: StakingPoolArgs['tuple']['init()void'];
        returns: StakingPoolReturns['init()void'];
    }> & Record<'delete(address)void' | 'delete', {
        argsObj: StakingPoolArgs['obj']['delete(address)void'];
        argsTuple: StakingPoolArgs['tuple']['delete(address)void'];
        returns: StakingPoolReturns['delete(address)void'];
    }> & Record<'optIn(pay,uint64)void' | 'optIn', {
        argsObj: StakingPoolArgs['obj']['optIn(pay,uint64)void'];
        argsTuple: StakingPoolArgs['tuple']['optIn(pay,uint64)void'];
        returns: StakingPoolReturns['optIn(pay,uint64)void'];
    }> & Record<'addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void' | 'addReward', {
        argsObj: StakingPoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void'];
        argsTuple: StakingPoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void'];
        returns: StakingPoolReturns['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void'];
    }> & Record<'addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void' | 'addRewardAsa', {
        argsObj: StakingPoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void'];
        argsTuple: StakingPoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void'];
        returns: StakingPoolReturns['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void'];
    }> & Record<'finalize(uint64,uint64,uint64)void' | 'finalize', {
        argsObj: StakingPoolArgs['obj']['finalize(uint64,uint64,uint64)void'];
        argsTuple: StakingPoolArgs['tuple']['finalize(uint64,uint64,uint64)void'];
        returns: StakingPoolReturns['finalize(uint64,uint64,uint64)void'];
    }> & Record<'gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void' | 'gatedEnter', {
        argsObj: StakingPoolArgs['obj']['gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void'];
        argsTuple: StakingPoolArgs['tuple']['gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void'];
        returns: StakingPoolReturns['gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void'];
    }> & Record<'enter(pay,(uint64,uint64,byte[32][])[])void' | 'enter', {
        argsObj: StakingPoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[])void'];
        argsTuple: StakingPoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[])void'];
        returns: StakingPoolReturns['enter(pay,(uint64,uint64,byte[32][])[])void'];
    }> & Record<'startDisbursement(uint64)void' | 'startDisbursement', {
        argsObj: StakingPoolArgs['obj']['startDisbursement(uint64)void'];
        argsTuple: StakingPoolArgs['tuple']['startDisbursement(uint64)void'];
        returns: StakingPoolReturns['startDisbursement(uint64)void'];
    }> & Record<'raffle(uint64)void' | 'raffle', {
        argsObj: StakingPoolArgs['obj']['raffle(uint64)void'];
        argsTuple: StakingPoolArgs['tuple']['raffle(uint64)void'];
        returns: StakingPoolReturns['raffle(uint64)void'];
    }> & Record<'disburseRewards(uint64,uint64)void' | 'disburseRewards', {
        argsObj: StakingPoolArgs['obj']['disburseRewards(uint64,uint64)void'];
        argsTuple: StakingPoolArgs['tuple']['disburseRewards(uint64,uint64)void'];
        returns: StakingPoolReturns['disburseRewards(uint64,uint64)void'];
    }> & Record<'finalizeDistribution(uint64)void' | 'finalizeDistribution', {
        argsObj: StakingPoolArgs['obj']['finalizeDistribution(uint64)void'];
        argsTuple: StakingPoolArgs['tuple']['finalizeDistribution(uint64)void'];
        returns: StakingPoolReturns['finalizeDistribution(uint64)void'];
    }> & Record<'check(address,uint64)(bool,uint64)' | 'check', {
        argsObj: StakingPoolArgs['obj']['check(address,uint64)(bool,uint64)'];
        argsTuple: StakingPoolArgs['tuple']['check(address,uint64)(bool,uint64)'];
        returns: StakingPoolReturns['check(address,uint64)(bool,uint64)'];
    }> & Record<'gateCheck(appl,address,uint64)void' | 'gateCheck', {
        argsObj: StakingPoolArgs['obj']['gateCheck(appl,address,uint64)void'];
        argsTuple: StakingPoolArgs['tuple']['gateCheck(appl,address,uint64)void'];
        returns: StakingPoolReturns['gateCheck(appl,address,uint64)void'];
    }> & Record<'enterCost(address,uint64)uint64' | 'enterCost', {
        argsObj: StakingPoolArgs['obj']['enterCost(address,uint64)uint64'];
        argsTuple: StakingPoolArgs['tuple']['enterCost(address,uint64)uint64'];
        /**
         * The total payment amount needed (includes box MBR + any shortfall to meet min balance)
         */
        returns: StakingPoolReturns['enterCost(address,uint64)uint64'];
    }> & Record<'optInCost(uint64)uint64' | 'optInCost', {
        argsObj: StakingPoolArgs['obj']['optInCost(uint64)uint64'];
        argsTuple: StakingPoolArgs['tuple']['optInCost(uint64)uint64'];
        returns: StakingPoolReturns['optInCost(uint64)uint64'];
    }> & Record<'signUpsOpen()bool' | 'signUpsOpen', {
        argsObj: StakingPoolArgs['obj']['signUpsOpen()bool'];
        argsTuple: StakingPoolArgs['tuple']['signUpsOpen()bool'];
        /**
         * a boolean of whether sign ups are open
         */
        returns: StakingPoolReturns['signUpsOpen()bool'];
    }> & Record<'isLive()bool' | 'isLive', {
        argsObj: StakingPoolArgs['obj']['isLive()bool'];
        argsTuple: StakingPoolArgs['tuple']['isLive()bool'];
        /**
         * a boolean of whether the pool is live
         */
        returns: StakingPoolReturns['isLive()bool'];
    }> & Record<'isEntered(address)bool' | 'isEntered', {
        argsObj: StakingPoolArgs['obj']['isEntered(address)bool'];
        argsTuple: StakingPoolArgs['tuple']['isEntered(address)bool'];
        /**
         * a boolean indicating if the address has entered the staking pool
         */
        returns: StakingPoolReturns['isEntered(address)bool'];
    }> & Record<'getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)' | 'getState', {
        argsObj: StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'];
        argsTuple: StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'];
        returns: StakingPoolReturns['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'];
    }> & Record<'updateAkitaDAOEscrow(uint64)void' | 'updateAkitaDAOEscrow', {
        argsObj: StakingPoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'];
        argsTuple: StakingPoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void'];
        returns: StakingPoolReturns['updateAkitaDAOEscrow(uint64)void'];
    }> & Record<'update(string)void' | 'update', {
        argsObj: StakingPoolArgs['obj']['update(string)void'];
        argsTuple: StakingPoolArgs['tuple']['update(string)void'];
        returns: StakingPoolReturns['update(string)void'];
    }> & Record<'updateAkitaDAO(uint64)void' | 'updateAkitaDAO', {
        argsObj: StakingPoolArgs['obj']['updateAkitaDAO(uint64)void'];
        argsTuple: StakingPoolArgs['tuple']['updateAkitaDAO(uint64)void'];
        returns: StakingPoolReturns['updateAkitaDAO(uint64)void'];
    }> & Record<'opUp()void' | 'opUp', {
        argsObj: StakingPoolArgs['obj']['opUp()void'];
        argsTuple: StakingPoolArgs['tuple']['opUp()void'];
        returns: StakingPoolReturns['opUp()void'];
    }> & Record<'mbr(uint64)(uint64,uint64,uint64,uint64,uint64)' | 'mbr', {
        argsObj: StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'];
        argsTuple: StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'];
        /**
         * the mbr created for each boxmap entry
         */
        returns: StakingPoolReturns['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'];
    }>;
    /**
     * Defines the shape of the state of the application.
     */
    state: {
        global: {
            keys: {
                /**
                 * the status the pool is in
                 */
                status: number;
                /**
                 * title of the staking pool
                 */
                title: string;
                /**
                 * the method of staking to be used for the pool
                 */
                type: number;
                /**
                 * the timestamp when sign ups for the pool are allowed
                 */
                signupTimestamp: bigint;
                /**
                 * whether signups are allowed after the staking pool begins
                 */
                allowLateSignups: bigint;
                /**
                 * the timestamp when the pool starts
                 */
                startTimestamp: bigint;
                /**
                 * the timestamp when the pool ends
                 */
                endTimestamp: bigint;
                /**
                 * the maximum entries allowed for the pool
                 */
                maxEntries: bigint;
                /**
                 * the number of entries in a pool
                 */
                entryId: bigint;
                /**
                 * the number of rewards for the pool
                 */
                rewardId: bigint;
                /**
                 * the total amount staked in the pool
                 */
                totalStaked: bigint;
                /**
                * the name for the meta merkle asset group to validate staking
                stake key can be empty if distribution !== DistributionTypePercentage
        
                 */
                stakeKey: RootKey;
                /**
                 * minimum stake amount
                 */
                minimumStakeAmount: bigint;
                /**
                 * the gate id of the pool
                 */
                gateId: bigint;
                /**
                 * the size of the gate were using
                 */
                gateSize: bigint;
                /**
                 * the address of the creator of the staking pool
                 */
                creator: string;
                /**
                 * marketplace is pool creation side marketplace
                 */
                marketplace: string;
                /**
                 * the amount the marketplaces will get for the sale
                 */
                marketplaceRoyalties: bigint;
                /**
                 * the akita royalty for the pool
                 */
                akitaRoyalty: bigint;
                /**
                 * the amount of royalties that were paid in a disbursement
                 */
                akitaRoyaltyAmount: bigint;
                /**
                 * salt for randomness
                 */
                salt: BinaryState;
                /**
                 * the app ID for the akita DAO escrow to use
                 */
                akitaDaoEscrow: bigint;
                /**
                 * the current version of the contract
                 */
                version: string;
                /**
                 * the app ID of the Akita DAO
                 */
                akitaDao: bigint;
                funder: FunderInfo;
            };
            maps: {};
        };
        box: {
            keys: {};
            maps: {
                /**
                 * indexed entries for efficient iteration
                 */
                entries: Map<bigint | number, EntryData>;
                /**
                 * the number of unique asset entries by address
                 */
                uniques: Map<string, bigint>;
                /**
                 * the entries in the pool
                 */
                entriesByAddress: Map<EntryKey, bigint>;
                /**
                 * the rewards for this staking pool
                 */
                rewards: Map<bigint | number, Reward>;
                /**
                 * the disbursements this pool as created & finalized
                 */
                disbursements: Map<bigint | number, Uint8Array>;
            };
        };
    };
};
/**
 * Defines the possible abi call signatures.
 */
export type StakingPoolSignatures = keyof StakingPoolTypes['methods'];
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type StakingPoolNonVoidMethodSignatures = keyof StakingPoolTypes['methods'] extends infer T ? T extends keyof StakingPoolTypes['methods'] ? MethodReturn<T> extends void ? never : T : never : never;
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> & {
    /** The args for the ABI method call, either as an ordered array or an object */
    args: Expand<TArgs>;
}>;
/**
 * Maps a method signature from the StakingPool smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends StakingPoolSignatures> = StakingPoolTypes['methods'][TSignature]['argsObj' | 'argsTuple'];
/**
 * Maps a method signature from the StakingPool smart contract to the method's return type
 */
export type MethodReturn<TSignature extends StakingPoolSignatures> = StakingPoolTypes['methods'][TSignature]['returns'];
/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = StakingPoolTypes['state']['global']['keys'];
/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = StakingPoolTypes['state']['box']['keys'];
/**
 * Defines supported create method params for this smart contract
 */
export type StakingPoolCreateCallParams = Expand<CallParams<StakingPoolArgs['obj']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void']> & {
    method: 'create';
} & {
    onComplete?: OnApplicationComplete.NoOpOC;
} & CreateSchema> | Expand<CallParams<StakingPoolArgs['obj']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void']> & {
    method: 'create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void';
} & {
    onComplete?: OnApplicationComplete.NoOpOC;
} & CreateSchema>;
/**
 * Defines supported update method params for this smart contract
 */
export type StakingPoolUpdateCallParams = Expand<CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']> & {
    method: 'update';
}> | Expand<CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']> & {
    method: 'update(string)void';
}>;
/**
 * Defines supported delete method params for this smart contract
 */
export type StakingPoolDeleteCallParams = Expand<CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']> & {
    method: 'delete';
}> | Expand<CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']> & {
    method: 'delete(address)void';
}>;
/**
 * Defines arguments required for the deploy method.
 */
export type StakingPoolDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
    /**
     * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
     */
    createParams?: StakingPoolCreateCallParams;
    /**
     * Update transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
     */
    updateParams?: StakingPoolUpdateCallParams;
    /**
     * Delete transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
     */
    deleteParams?: StakingPoolDeleteCallParams;
}>;
/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the StakingPool smart contract
 */
export declare abstract class StakingPoolParamsFactory {
    /**
     * Gets available create ABI call param factories
     */
    static get create(): {
        _resolveByMethod<TParams extends StakingPoolCreateCallParams & {
            method: string;
        }>(params: TParams): {
            maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            signer?: (TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount) | undefined;
            rekeyTo?: (string | Address) | undefined;
            note?: (Uint8Array | string) | undefined;
            lease?: (Uint8Array | string) | undefined;
            staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            validityWindow?: number | bigint | undefined;
            firstValidRound?: bigint | undefined;
            lastValidRound?: bigint | undefined;
            onComplete?: OnApplicationComplete | undefined;
            accountReferences?: (string | Address)[] | undefined;
            appReferences?: bigint[] | undefined;
            assetReferences?: bigint[] | undefined;
            boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference | import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier)[] | undefined;
            sender?: (Address | string) | undefined;
            method: string;
            args?: (import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | AppMethodCallTransactionArgument | undefined)[] | undefined;
        } & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        };
        /**
         * Constructs create ABI call params for the StakingPool smart contract using the create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void ABI method
         *
         * @param params Parameters for the call
         * @returns An `AppClientMethodCallParams` object for the call
         */
        create(params: CallParams<StakingPoolArgs["obj"]["create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void"] | StakingPoolArgs["tuple"]["create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void"]> & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }): AppClientMethodCallParams & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        };
    };
    /**
     * Gets available update ABI call param factories
     */
    static get update(): {
        _resolveByMethod<TParams extends StakingPoolUpdateCallParams & {
            method: string;
        }>(params: TParams): {
            maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            signer?: (TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount) | undefined;
            rekeyTo?: (string | Address) | undefined;
            note?: (Uint8Array | string) | undefined;
            lease?: (Uint8Array | string) | undefined;
            staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            validityWindow?: number | bigint | undefined;
            firstValidRound?: bigint | undefined;
            lastValidRound?: bigint | undefined;
            onComplete?: OnApplicationComplete | undefined;
            accountReferences?: (string | Address)[] | undefined;
            appReferences?: bigint[] | undefined;
            assetReferences?: bigint[] | undefined;
            boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference | import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier)[] | undefined;
            sender?: (Address | string) | undefined;
            method: string;
            args?: (import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | AppMethodCallTransactionArgument | undefined)[] | undefined;
        } & AppClientCompilationParams;
        /**
         * Constructs update ABI call params for the StakingPool smart contract using the update(string)void ABI method
         *
         * @param params Parameters for the call
         * @returns An `AppClientMethodCallParams` object for the call
         */
        update(params: CallParams<StakingPoolArgs["obj"]["update(string)void"] | StakingPoolArgs["tuple"]["update(string)void"]> & AppClientCompilationParams): AppClientMethodCallParams & AppClientCompilationParams;
    };
    /**
     * Gets available delete ABI call param factories
     */
    static get delete(): {
        _resolveByMethod<TParams extends StakingPoolDeleteCallParams & {
            method: string;
        }>(params: TParams): {
            maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            signer?: (TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount) | undefined;
            rekeyTo?: (string | Address) | undefined;
            note?: (Uint8Array | string) | undefined;
            lease?: (Uint8Array | string) | undefined;
            staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            validityWindow?: number | bigint | undefined;
            firstValidRound?: bigint | undefined;
            lastValidRound?: bigint | undefined;
            onComplete?: OnApplicationComplete | undefined;
            accountReferences?: (string | Address)[] | undefined;
            appReferences?: bigint[] | undefined;
            assetReferences?: bigint[] | undefined;
            boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference | import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier)[] | undefined;
            sender?: (Address | string) | undefined;
            method: string;
            args?: (import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | AppMethodCallTransactionArgument | undefined)[] | undefined;
        };
        /**
         * Constructs delete ABI call params for the StakingPool smart contract using the delete(address)void ABI method
         *
         * @param params Parameters for the call
         * @returns An `AppClientMethodCallParams` object for the call
         */
        delete(params: CallParams<StakingPoolArgs["obj"]["delete(address)void"] | StakingPoolArgs["tuple"]["delete(address)void"]>): AppClientMethodCallParams;
    };
    /**
     * Constructs a no op call for the init()void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static init(params: CallParams<StakingPoolArgs['obj']['init()void'] | StakingPoolArgs['tuple']['init()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the optIn(pay,uint64)void ABI method
     *
     * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static optIn(params: CallParams<StakingPoolArgs['obj']['optIn(pay,uint64)void'] | StakingPoolArgs['tuple']['optIn(pay,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static addReward(params: CallParams<StakingPoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static addRewardAsa(params: CallParams<StakingPoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the finalize(uint64,uint64,uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static finalize(params: CallParams<StakingPoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['finalize(uint64,uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static gatedEnter(params: CallParams<StakingPoolArgs['obj']['gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void'] | StakingPoolArgs['tuple']['gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the enter(pay,(uint64,uint64,byte[32][])[])void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static enter(params: CallParams<StakingPoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[])void'] | StakingPoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the startDisbursement(uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static startDisbursement(params: CallParams<StakingPoolArgs['obj']['startDisbursement(uint64)void'] | StakingPoolArgs['tuple']['startDisbursement(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the raffle(uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static raffle(params: CallParams<StakingPoolArgs['obj']['raffle(uint64)void'] | StakingPoolArgs['tuple']['raffle(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the disburseRewards(uint64,uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static disburseRewards(params: CallParams<StakingPoolArgs['obj']['disburseRewards(uint64,uint64)void'] | StakingPoolArgs['tuple']['disburseRewards(uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the finalizeDistribution(uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static finalizeDistribution(params: CallParams<StakingPoolArgs['obj']['finalizeDistribution(uint64)void'] | StakingPoolArgs['tuple']['finalizeDistribution(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the check(address,uint64)(bool,uint64) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static check(params: CallParams<StakingPoolArgs['obj']['check(address,uint64)(bool,uint64)'] | StakingPoolArgs['tuple']['check(address,uint64)(bool,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the gateCheck(appl,address,uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static gateCheck(params: CallParams<StakingPoolArgs['obj']['gateCheck(appl,address,uint64)void'] | StakingPoolArgs['tuple']['gateCheck(appl,address,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the enterCost(address,uint64)uint64 ABI method
     *
     * Calculates the total cost required to enter the pool
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static enterCost(params: CallParams<StakingPoolArgs['obj']['enterCost(address,uint64)uint64'] | StakingPoolArgs['tuple']['enterCost(address,uint64)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the optInCost(uint64)uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static optInCost(params: CallParams<StakingPoolArgs['obj']['optInCost(uint64)uint64'] | StakingPoolArgs['tuple']['optInCost(uint64)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the signUpsOpen()bool ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static signUpsOpen(params: CallParams<StakingPoolArgs['obj']['signUpsOpen()bool'] | StakingPoolArgs['tuple']['signUpsOpen()bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the isLive()bool ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static isLive(params: CallParams<StakingPoolArgs['obj']['isLive()bool'] | StakingPoolArgs['tuple']['isLive()bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the isEntered(address)bool ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static isEntered(params: CallParams<StakingPoolArgs['obj']['isEntered(address)bool'] | StakingPoolArgs['tuple']['isEntered(address)bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static getState(params: CallParams<StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the updateAkitaDAOEscrow(uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static updateAkitaDaoEscrow(params: CallParams<StakingPoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the updateAkitaDAO(uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static updateAkitaDao(params: CallParams<StakingPoolArgs['obj']['updateAkitaDAO(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAO(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the opUp()void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static opUp(params: CallParams<StakingPoolArgs['obj']['opUp()void'] | StakingPoolArgs['tuple']['opUp()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the mbr(uint64)(uint64,uint64,uint64,uint64,uint64) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static mbr(params: CallParams<StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
}
/**
 * A factory to create and deploy one or more instance of the StakingPool smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export declare class StakingPoolFactory {
    /**
     * The underlying `AppFactory` for when you want to have more flexibility
     */
    readonly appFactory: _AppFactory;
    /**
     * Creates a new instance of `StakingPoolFactory`
     *
     * @param params The parameters to initialise the app factory with
     */
    constructor(params: Omit<AppFactoryParams, 'appSpec'>);
    /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
    get appName(): string;
    /** The ARC-56 app spec being used */
    get appSpec(): Arc56Contract;
    /** A reference to the underlying `AlgorandClient` this app factory is using. */
    get algorand(): AlgorandClient;
    /**
     * Returns a new `AppClient` client for an app instance of the given ID.
     *
     * Automatically populates appName, defaultSender and source maps from the factory
     * if not specified in the params.
     * @param params The parameters to create the app client
     * @returns The `AppClient`
     */
    getAppClientById(params: AppFactoryAppClientParams): StakingPoolClient;
    /**
     * Returns a new `AppClient` client, resolving the app by creator address and name
     * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
     *
     * Automatically populates appName, defaultSender and source maps from the factory
     * if not specified in the params.
     * @param params The parameters to create the app client
     * @returns The `AppClient`
     */
    getAppClientByCreatorAndName(params: AppFactoryResolveAppClientByCreatorAndNameParams): Promise<StakingPoolClient>;
    /**
     * Idempotently deploys the StakingPool smart contract.
     *
     * @param params The arguments for the contract calls and any additional parameters for the call
     * @returns The deployment result
     */
    deploy(params?: StakingPoolDeployParams): Promise<{
        result: {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "create";
            version: string;
            name: string;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            appId: bigint;
            appAddress: Address;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "update";
            appId: bigint;
            appAddress: Address;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            name: string;
            version: string;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "replace";
            version: string;
            name: string;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            appId: bigint;
            appAddress: Address;
            deleteResult: import("@algorandfoundation/algokit-utils/types/transaction").ConfirmedTransactionResult;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "nothing";
            appId: bigint;
            appAddress: Address;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            name: string;
            version: string;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
        };
        appClient: StakingPoolClient;
    }>;
    /**
     * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
     */
    readonly params: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the StakingPool smart contract using the create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The create params
             */
            create: (params: CallParams<StakingPoolArgs["obj"]["create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void"] | StakingPoolArgs["tuple"]["create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void"]> & AppClientCompilationParams & CreateSchema & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                deployTimeParams: import("@algorandfoundation/algokit-utils/types/app").TealTemplateParams | undefined;
                schema: {
                    globalInts: number;
                    globalByteSlices: number;
                    localInts: number;
                    localByteSlices: number;
                };
                approvalProgram: Uint8Array;
                clearStateProgram: Uint8Array;
                maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                note?: string | Uint8Array | undefined;
                signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                lease?: string | Uint8Array | undefined;
                rekeyTo?: string | Address | undefined;
                staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                validityWindow?: number | bigint | undefined;
                firstValidRound?: bigint | undefined;
                lastValidRound?: bigint | undefined;
                accountReferences?: (string | Address)[] | undefined;
                appReferences?: bigint[] | undefined;
                assetReferences?: bigint[] | undefined;
                boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                sender?: string | Address | undefined;
                method: string;
                args?: (import("algosdk").ABIValue | AppMethodCallTransactionArgument | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined)[] | undefined;
                updatable?: boolean | undefined;
                deletable?: boolean | undefined;
                extraProgramPages?: number | undefined;
            } & {
                sender: Address;
                signer: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                method: import("@algorandfoundation/algokit-utils/types/app-arc56").Arc56Method;
                args: (Transaction | import("algosdk").ABIValue | import("algosdk").TransactionWithSigner | Promise<Transaction> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    note?: string | Uint8Array | undefined;
                    args?: Uint8Array[] | undefined;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                    lease?: string | Uint8Array | undefined;
                    rekeyTo?: string | Address | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                    schema?: {
                        globalInts: number;
                        globalByteSlices: number;
                        localInts: number;
                        localByteSlices: number;
                    } | undefined;
                    extraProgramPages?: number | undefined;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    rekeyTo?: string | Address | undefined;
                    note?: string | Uint8Array | undefined;
                    lease?: string | Uint8Array | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    appId: bigint;
                    onComplete?: OnApplicationComplete.UpdateApplicationOC | undefined;
                    args?: Uint8Array[] | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<import("@algorandfoundation/algokit-utils/types/composer").AppMethodCallParams> | undefined)[] | undefined;
                onComplete: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC;
            }>;
        };
        /**
         * Gets available deployUpdate methods
         */
        deployUpdate: {
            /**
             * Updates an existing instance of the StakingPool smart contract using the update(string)void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The deployUpdate params
             */
            update: (params: CallParams<StakingPoolArgs["obj"]["update(string)void"] | StakingPoolArgs["tuple"]["update(string)void"]> & AppClientCompilationParams) => {
                maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                note?: string | Uint8Array | undefined;
                signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                onComplete?: OnApplicationComplete | undefined;
                lease?: string | Uint8Array | undefined;
                rekeyTo?: string | Address | undefined;
                staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                validityWindow?: number | bigint | undefined;
                firstValidRound?: bigint | undefined;
                lastValidRound?: bigint | undefined;
                accountReferences?: (string | Address)[] | undefined;
                appReferences?: bigint[] | undefined;
                assetReferences?: bigint[] | undefined;
                boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                sender?: string | Address | undefined;
                method: string;
                args?: (import("algosdk").ABIValue | AppMethodCallTransactionArgument | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined)[] | undefined;
            } & {
                sender: Address;
                signer: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                method: import("@algorandfoundation/algokit-utils/types/app-arc56").Arc56Method;
                args: (Transaction | import("algosdk").ABIValue | import("algosdk").TransactionWithSigner | Promise<Transaction> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    note?: string | Uint8Array | undefined;
                    args?: Uint8Array[] | undefined;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                    lease?: string | Uint8Array | undefined;
                    rekeyTo?: string | Address | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                    schema?: {
                        globalInts: number;
                        globalByteSlices: number;
                        localInts: number;
                        localByteSlices: number;
                    } | undefined;
                    extraProgramPages?: number | undefined;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    rekeyTo?: string | Address | undefined;
                    note?: string | Uint8Array | undefined;
                    lease?: string | Uint8Array | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    appId: bigint;
                    onComplete?: OnApplicationComplete.UpdateApplicationOC | undefined;
                    args?: Uint8Array[] | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<import("@algorandfoundation/algokit-utils/types/composer").AppMethodCallParams> | undefined)[] | undefined;
                onComplete: OnApplicationComplete.UpdateApplicationOC;
            };
        };
        /**
         * Gets available deployDelete methods
         */
        deployDelete: {
            /**
             * Deletes an existing instance of the StakingPool smart contract using the delete(address)void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The deployDelete params
             */
            delete: (params: CallParams<StakingPoolArgs["obj"]["delete(address)void"] | StakingPoolArgs["tuple"]["delete(address)void"]>) => {
                maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                note?: string | Uint8Array | undefined;
                signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                onComplete?: OnApplicationComplete | undefined;
                lease?: string | Uint8Array | undefined;
                rekeyTo?: string | Address | undefined;
                staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                validityWindow?: number | bigint | undefined;
                firstValidRound?: bigint | undefined;
                lastValidRound?: bigint | undefined;
                accountReferences?: (string | Address)[] | undefined;
                appReferences?: bigint[] | undefined;
                assetReferences?: bigint[] | undefined;
                boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                sender?: string | Address | undefined;
                method: string;
                args?: (import("algosdk").ABIValue | AppMethodCallTransactionArgument | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined)[] | undefined;
            } & {
                sender: Address;
                signer: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                method: import("@algorandfoundation/algokit-utils/types/app-arc56").Arc56Method;
                args: (Transaction | import("algosdk").ABIValue | import("algosdk").TransactionWithSigner | Promise<Transaction> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    note?: string | Uint8Array | undefined;
                    args?: Uint8Array[] | undefined;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                    lease?: string | Uint8Array | undefined;
                    rekeyTo?: string | Address | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                    schema?: {
                        globalInts: number;
                        globalByteSlices: number;
                        localInts: number;
                        localByteSlices: number;
                    } | undefined;
                    extraProgramPages?: number | undefined;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    rekeyTo?: string | Address | undefined;
                    note?: string | Uint8Array | undefined;
                    lease?: string | Uint8Array | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    appId: bigint;
                    onComplete?: OnApplicationComplete.UpdateApplicationOC | undefined;
                    args?: Uint8Array[] | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<import("@algorandfoundation/algokit-utils/types/composer").AppMethodCallParams> | undefined)[] | undefined;
                onComplete: OnApplicationComplete.DeleteApplicationOC;
            };
        };
    };
    /**
     * Create transactions for the current app
     */
    readonly createTransaction: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the StakingPool smart contract using the create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The create transaction
             */
            create: (params: CallParams<StakingPoolArgs["obj"]["create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void"] | StakingPoolArgs["tuple"]["create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void"]> & AppClientCompilationParams & CreateSchema & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                transactions: Transaction[];
                methodCalls: Map<number, import("algosdk").ABIMethod>;
                signers: Map<number, TransactionSigner>;
            }>;
        };
    };
    /**
     * Send calls to the current app
     */
    readonly send: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the StakingPool smart contract using an ABI method call using the create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The create result
             */
            create: (params: CallParams<StakingPoolArgs["obj"]["create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void"] | StakingPoolArgs["tuple"]["create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void"]> & AppClientCompilationParams & CreateSchema & SendParams & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                result: {
                    return: (undefined | StakingPoolReturns["create(string,uint8,address,(address,uint64),address,(address,string),uint64,bool,uint64,uint64,uint64,uint64)void"]);
                    compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                    compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                    appId: bigint;
                    groupId: string;
                    txIds: string[];
                    returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
                    confirmations: modelsv2.PendingTransactionResponse[];
                    transactions: Transaction[];
                    confirmation: modelsv2.PendingTransactionResponse;
                    transaction: Transaction;
                    appAddress: Address;
                };
                appClient: StakingPoolClient;
            }>;
        };
    };
}
/**
 * A client to make calls to the StakingPool smart contract
 */
export declare class StakingPoolClient {
    /**
     * The underlying `AppClient` for when you want to have more flexibility
     */
    readonly appClient: _AppClient;
    /**
     * Creates a new instance of `StakingPoolClient`
     *
     * @param appClient An `AppClient` instance which has been created with the StakingPool app spec
     */
    constructor(appClient: _AppClient);
    /**
     * Creates a new instance of `StakingPoolClient`
     *
     * @param params The parameters to initialise the app client with
     */
    constructor(params: Omit<AppClientParams, 'appSpec'>);
    /**
     * Checks for decode errors on the given return value and maps the return value to the return type for the given method
     * @returns The typed return value or undefined if there was no value
     */
    decodeReturnValue<TSignature extends StakingPoolNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined): MethodReturn<TSignature> | undefined;
    /**
     * Returns a new `StakingPoolClient` client, resolving the app by creator address and name
     * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
     * @param params The parameters to create the app client
     */
    static fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<StakingPoolClient>;
    /**
     * Returns an `StakingPoolClient` instance for the current network based on
     * pre-determined network-specific app IDs specified in the ARC-56 app spec.
     *
     * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
     * @param params The parameters to create the app client
     */
    static fromNetwork(params: Omit<ResolveAppClientByNetwork, 'appSpec'>): Promise<StakingPoolClient>;
    /** The ID of the app instance this client is linked to. */
    get appId(): bigint;
    /** The app address of the app instance this client is linked to. */
    get appAddress(): Address;
    /** The name of the app. */
    get appName(): string;
    /** The ARC-56 app spec being used */
    get appSpec(): Arc56Contract;
    /** A reference to the underlying `AlgorandClient` this app client is using. */
    get algorand(): AlgorandClient;
    /**
     * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
     */
    readonly params: {
        /**
         * Gets available update methods
         */
        update: {
            /**
             * Updates an existing instance of the StakingPool smart contract using the `update(string)void` ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The update params
             */
            update: (params: CallParams<StakingPoolArgs["obj"]["update(string)void"] | StakingPoolArgs["tuple"]["update(string)void"]> & AppClientCompilationParams) => Promise<{
                approvalProgram: Uint8Array;
                clearStateProgram: Uint8Array;
                compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                note?: string | Uint8Array | undefined;
                signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                onComplete?: OnApplicationComplete | undefined;
                lease?: string | Uint8Array | undefined;
                rekeyTo?: string | Address | undefined;
                staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                validityWindow?: number | bigint | undefined;
                firstValidRound?: bigint | undefined;
                lastValidRound?: bigint | undefined;
                accountReferences?: (string | Address)[] | undefined;
                appReferences?: bigint[] | undefined;
                assetReferences?: bigint[] | undefined;
                boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                sender?: string | Address | undefined;
                method: string;
                args?: (import("algosdk").ABIValue | AppMethodCallTransactionArgument | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined)[] | undefined;
                deployTimeParams?: import("@algorandfoundation/algokit-utils/types/app").TealTemplateParams | undefined;
                updatable?: boolean | undefined;
                deletable?: boolean | undefined;
            } & {
                appId: bigint;
                sender: Address;
                signer: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                method: import("@algorandfoundation/algokit-utils/types/app-arc56").Arc56Method;
                onComplete: OnApplicationComplete.UpdateApplicationOC;
                args: (Transaction | import("algosdk").ABIValue | import("algosdk").TransactionWithSigner | Promise<Transaction> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    note?: string | Uint8Array | undefined;
                    args?: Uint8Array[] | undefined;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                    lease?: string | Uint8Array | undefined;
                    rekeyTo?: string | Address | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                    schema?: {
                        globalInts: number;
                        globalByteSlices: number;
                        localInts: number;
                        localByteSlices: number;
                    } | undefined;
                    extraProgramPages?: number | undefined;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    rekeyTo?: string | Address | undefined;
                    note?: string | Uint8Array | undefined;
                    lease?: string | Uint8Array | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    appId: bigint;
                    onComplete?: OnApplicationComplete.UpdateApplicationOC | undefined;
                    args?: Uint8Array[] | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<import("@algorandfoundation/algokit-utils/types/composer").AppMethodCallParams> | undefined)[] | undefined;
            }>;
        };
        /**
         * Gets available delete methods
         */
        delete: {
            /**
             * Deletes an existing instance of the StakingPool smart contract using the `delete(address)void` ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The delete params
             */
            delete: (params: CallParams<StakingPoolArgs["obj"]["delete(address)void"] | StakingPoolArgs["tuple"]["delete(address)void"]>) => Promise<import("@algorandfoundation/algokit-utils/types/composer").AppDeleteMethodCall>;
        };
        /**
         * Makes a clear_state call to an existing instance of the StakingPool smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams>) => import("@algorandfoundation/algokit-utils/types/composer").AppCallParams;
        /**
         * Makes a call to the StakingPool smart contract using the `init()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        init: (params?: CallParams<StakingPoolArgs["obj"]["init()void"] | StakingPoolArgs["tuple"]["init()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `optIn(pay,uint64)void` ABI method.
         *
         * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        optIn: (params: CallParams<StakingPoolArgs["obj"]["optIn(pay,uint64)void"] | StakingPoolArgs["tuple"]["optIn(pay,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        addReward: (params: CallParams<StakingPoolArgs["obj"]["addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void"] | StakingPoolArgs["tuple"]["addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        addRewardAsa: (params: CallParams<StakingPoolArgs["obj"]["addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void"] | StakingPoolArgs["tuple"]["addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `finalize(uint64,uint64,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        finalize: (params: CallParams<StakingPoolArgs["obj"]["finalize(uint64,uint64,uint64)void"] | StakingPoolArgs["tuple"]["finalize(uint64,uint64,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        gatedEnter: (params: CallParams<StakingPoolArgs["obj"]["gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void"] | StakingPoolArgs["tuple"]["gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `enter(pay,(uint64,uint64,byte[32][])[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        enter: (params: CallParams<StakingPoolArgs["obj"]["enter(pay,(uint64,uint64,byte[32][])[])void"] | StakingPoolArgs["tuple"]["enter(pay,(uint64,uint64,byte[32][])[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `startDisbursement(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        startDisbursement: (params: CallParams<StakingPoolArgs["obj"]["startDisbursement(uint64)void"] | StakingPoolArgs["tuple"]["startDisbursement(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `raffle(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        raffle: (params: CallParams<StakingPoolArgs["obj"]["raffle(uint64)void"] | StakingPoolArgs["tuple"]["raffle(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `disburseRewards(uint64,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        disburseRewards: (params: CallParams<StakingPoolArgs["obj"]["disburseRewards(uint64,uint64)void"] | StakingPoolArgs["tuple"]["disburseRewards(uint64,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `finalizeDistribution(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        finalizeDistribution: (params: CallParams<StakingPoolArgs["obj"]["finalizeDistribution(uint64)void"] | StakingPoolArgs["tuple"]["finalizeDistribution(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `check(address,uint64)(bool,uint64)` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        check: (params: CallParams<StakingPoolArgs["obj"]["check(address,uint64)(bool,uint64)"] | StakingPoolArgs["tuple"]["check(address,uint64)(bool,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `gateCheck(appl,address,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        gateCheck: (params: CallParams<StakingPoolArgs["obj"]["gateCheck(appl,address,uint64)void"] | StakingPoolArgs["tuple"]["gateCheck(appl,address,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `enterCost(address,uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * Calculates the total cost required to enter the pool
         *
         * @param params The params for the smart contract call
         * @returns The call params: The total payment amount needed (includes box MBR + any shortfall to meet min balance)
         */
        enterCost: (params: CallParams<StakingPoolArgs["obj"]["enterCost(address,uint64)uint64"] | StakingPoolArgs["tuple"]["enterCost(address,uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `optInCost(uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        optInCost: (params: CallParams<StakingPoolArgs["obj"]["optInCost(uint64)uint64"] | StakingPoolArgs["tuple"]["optInCost(uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `signUpsOpen()bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params: a boolean of whether sign ups are open
         */
        signUpsOpen: (params?: CallParams<StakingPoolArgs["obj"]["signUpsOpen()bool"] | StakingPoolArgs["tuple"]["signUpsOpen()bool"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `isLive()bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params: a boolean of whether the pool is live
         */
        isLive: (params?: CallParams<StakingPoolArgs["obj"]["isLive()bool"] | StakingPoolArgs["tuple"]["isLive()bool"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `isEntered(address)bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params: a boolean indicating if the address has entered the staking pool
         */
        isEntered: (params: CallParams<StakingPoolArgs["obj"]["isEntered(address)bool"] | StakingPoolArgs["tuple"]["isEntered(address)bool"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        getState: (params?: CallParams<StakingPoolArgs["obj"]["getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)"] | StakingPoolArgs["tuple"]["getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `updateAkitaDAOEscrow(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        updateAkitaDaoEscrow: (params: CallParams<StakingPoolArgs["obj"]["updateAkitaDAOEscrow(uint64)void"] | StakingPoolArgs["tuple"]["updateAkitaDAOEscrow(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `updateAkitaDAO(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        updateAkitaDao: (params: CallParams<StakingPoolArgs["obj"]["updateAkitaDAO(uint64)void"] | StakingPoolArgs["tuple"]["updateAkitaDAO(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `opUp()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        opUp: (params?: CallParams<StakingPoolArgs["obj"]["opUp()void"] | StakingPoolArgs["tuple"]["opUp()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the StakingPool smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params: the mbr created for each boxmap entry
         */
        mbr: (params: CallParams<StakingPoolArgs["obj"]["mbr(uint64)(uint64,uint64,uint64,uint64,uint64)"] | StakingPoolArgs["tuple"]["mbr(uint64)(uint64,uint64,uint64,uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
    };
    /**
     * Create transactions for the current app
     */
    readonly createTransaction: {
        /**
         * Gets available update methods
         */
        update: {
            /**
             * Updates an existing instance of the StakingPool smart contract using the `update(string)void` ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The update transaction
             */
            update: (params: CallParams<StakingPoolArgs["obj"]["update(string)void"] | StakingPoolArgs["tuple"]["update(string)void"]> & AppClientCompilationParams) => Promise<{
                transactions: Transaction[];
                methodCalls: Map<number, import("algosdk").ABIMethod>;
                signers: Map<number, TransactionSigner>;
            }>;
        };
        /**
         * Gets available delete methods
         */
        delete: {
            /**
             * Deletes an existing instance of the StakingPool smart contract using the `delete(address)void` ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The delete transaction
             */
            delete: (params: CallParams<StakingPoolArgs["obj"]["delete(address)void"] | StakingPoolArgs["tuple"]["delete(address)void"]>) => Promise<{
                transactions: Transaction[];
                methodCalls: Map<number, import("algosdk").ABIMethod>;
                signers: Map<number, TransactionSigner>;
            }>;
        };
        /**
         * Makes a clear_state call to an existing instance of the StakingPool smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams>) => Promise<Transaction>;
        /**
         * Makes a call to the StakingPool smart contract using the `init()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        init: (params?: CallParams<StakingPoolArgs["obj"]["init()void"] | StakingPoolArgs["tuple"]["init()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `optIn(pay,uint64)void` ABI method.
         *
         * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        optIn: (params: CallParams<StakingPoolArgs["obj"]["optIn(pay,uint64)void"] | StakingPoolArgs["tuple"]["optIn(pay,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        addReward: (params: CallParams<StakingPoolArgs["obj"]["addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void"] | StakingPoolArgs["tuple"]["addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        addRewardAsa: (params: CallParams<StakingPoolArgs["obj"]["addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void"] | StakingPoolArgs["tuple"]["addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `finalize(uint64,uint64,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        finalize: (params: CallParams<StakingPoolArgs["obj"]["finalize(uint64,uint64,uint64)void"] | StakingPoolArgs["tuple"]["finalize(uint64,uint64,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        gatedEnter: (params: CallParams<StakingPoolArgs["obj"]["gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void"] | StakingPoolArgs["tuple"]["gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `enter(pay,(uint64,uint64,byte[32][])[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        enter: (params: CallParams<StakingPoolArgs["obj"]["enter(pay,(uint64,uint64,byte[32][])[])void"] | StakingPoolArgs["tuple"]["enter(pay,(uint64,uint64,byte[32][])[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `startDisbursement(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        startDisbursement: (params: CallParams<StakingPoolArgs["obj"]["startDisbursement(uint64)void"] | StakingPoolArgs["tuple"]["startDisbursement(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `raffle(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        raffle: (params: CallParams<StakingPoolArgs["obj"]["raffle(uint64)void"] | StakingPoolArgs["tuple"]["raffle(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `disburseRewards(uint64,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        disburseRewards: (params: CallParams<StakingPoolArgs["obj"]["disburseRewards(uint64,uint64)void"] | StakingPoolArgs["tuple"]["disburseRewards(uint64,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `finalizeDistribution(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        finalizeDistribution: (params: CallParams<StakingPoolArgs["obj"]["finalizeDistribution(uint64)void"] | StakingPoolArgs["tuple"]["finalizeDistribution(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `check(address,uint64)(bool,uint64)` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        check: (params: CallParams<StakingPoolArgs["obj"]["check(address,uint64)(bool,uint64)"] | StakingPoolArgs["tuple"]["check(address,uint64)(bool,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `gateCheck(appl,address,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        gateCheck: (params: CallParams<StakingPoolArgs["obj"]["gateCheck(appl,address,uint64)void"] | StakingPoolArgs["tuple"]["gateCheck(appl,address,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `enterCost(address,uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * Calculates the total cost required to enter the pool
         *
         * @param params The params for the smart contract call
         * @returns The call transaction: The total payment amount needed (includes box MBR + any shortfall to meet min balance)
         */
        enterCost: (params: CallParams<StakingPoolArgs["obj"]["enterCost(address,uint64)uint64"] | StakingPoolArgs["tuple"]["enterCost(address,uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `optInCost(uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        optInCost: (params: CallParams<StakingPoolArgs["obj"]["optInCost(uint64)uint64"] | StakingPoolArgs["tuple"]["optInCost(uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `signUpsOpen()bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction: a boolean of whether sign ups are open
         */
        signUpsOpen: (params?: CallParams<StakingPoolArgs["obj"]["signUpsOpen()bool"] | StakingPoolArgs["tuple"]["signUpsOpen()bool"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `isLive()bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction: a boolean of whether the pool is live
         */
        isLive: (params?: CallParams<StakingPoolArgs["obj"]["isLive()bool"] | StakingPoolArgs["tuple"]["isLive()bool"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `isEntered(address)bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction: a boolean indicating if the address has entered the staking pool
         */
        isEntered: (params: CallParams<StakingPoolArgs["obj"]["isEntered(address)bool"] | StakingPoolArgs["tuple"]["isEntered(address)bool"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        getState: (params?: CallParams<StakingPoolArgs["obj"]["getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)"] | StakingPoolArgs["tuple"]["getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `updateAkitaDAOEscrow(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        updateAkitaDaoEscrow: (params: CallParams<StakingPoolArgs["obj"]["updateAkitaDAOEscrow(uint64)void"] | StakingPoolArgs["tuple"]["updateAkitaDAOEscrow(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `updateAkitaDAO(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        updateAkitaDao: (params: CallParams<StakingPoolArgs["obj"]["updateAkitaDAO(uint64)void"] | StakingPoolArgs["tuple"]["updateAkitaDAO(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `opUp()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        opUp: (params?: CallParams<StakingPoolArgs["obj"]["opUp()void"] | StakingPoolArgs["tuple"]["opUp()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction: the mbr created for each boxmap entry
         */
        mbr: (params: CallParams<StakingPoolArgs["obj"]["mbr(uint64)(uint64,uint64,uint64,uint64,uint64)"] | StakingPoolArgs["tuple"]["mbr(uint64)(uint64,uint64,uint64,uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
    };
    /**
     * Send calls to the current app
     */
    readonly send: {
        /**
         * Gets available update methods
         */
        update: {
            /**
             * Updates an existing instance of the StakingPool smart contract using the `update(string)void` ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The update result
             */
            update: (params: CallParams<StakingPoolArgs["obj"]["update(string)void"] | StakingPoolArgs["tuple"]["update(string)void"]> & AppClientCompilationParams & SendParams) => Promise<{
                return: (undefined | StakingPoolReturns["update(string)void"]);
                compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                groupId: string;
                txIds: string[];
                returns?: ABIReturn[] | undefined;
                confirmations: modelsv2.PendingTransactionResponse[];
                transactions: Transaction[];
                confirmation: modelsv2.PendingTransactionResponse;
                transaction: Transaction;
            }>;
        };
        /**
         * Gets available delete methods
         */
        delete: {
            /**
             * Deletes an existing instance of the StakingPool smart contract using the `delete(address)void` ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The delete result
             */
            delete: (params: CallParams<StakingPoolArgs["obj"]["delete(address)void"] | StakingPoolArgs["tuple"]["delete(address)void"]> & SendParams) => Promise<{
                return: (undefined | StakingPoolReturns["delete(address)void"]);
                groupId: string;
                txIds: string[];
                returns?: ABIReturn[] | undefined | undefined;
                confirmations: modelsv2.PendingTransactionResponse[];
                transactions: Transaction[];
                confirmation: modelsv2.PendingTransactionResponse;
                transaction: Transaction;
            }>;
        };
        /**
         * Makes a clear_state call to an existing instance of the StakingPool smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => Promise<{
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            return?: ABIReturn | undefined;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `init()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        init: (params?: CallParams<StakingPoolArgs["obj"]["init()void"] | StakingPoolArgs["tuple"]["init()void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["init()void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `optIn(pay,uint64)void` ABI method.
         *
         * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        optIn: (params: CallParams<StakingPoolArgs["obj"]["optIn(pay,uint64)void"] | StakingPoolArgs["tuple"]["optIn(pay,uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["optIn(pay,uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        addReward: (params: CallParams<StakingPoolArgs["obj"]["addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void"] | StakingPoolArgs["tuple"]["addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        addRewardAsa: (params: CallParams<StakingPoolArgs["obj"]["addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void"] | StakingPoolArgs["tuple"]["addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `finalize(uint64,uint64,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        finalize: (params: CallParams<StakingPoolArgs["obj"]["finalize(uint64,uint64,uint64)void"] | StakingPoolArgs["tuple"]["finalize(uint64,uint64,uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["finalize(uint64,uint64,uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        gatedEnter: (params: CallParams<StakingPoolArgs["obj"]["gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void"] | StakingPoolArgs["tuple"]["gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `enter(pay,(uint64,uint64,byte[32][])[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        enter: (params: CallParams<StakingPoolArgs["obj"]["enter(pay,(uint64,uint64,byte[32][])[])void"] | StakingPoolArgs["tuple"]["enter(pay,(uint64,uint64,byte[32][])[])void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["enter(pay,(uint64,uint64,byte[32][])[])void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `startDisbursement(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        startDisbursement: (params: CallParams<StakingPoolArgs["obj"]["startDisbursement(uint64)void"] | StakingPoolArgs["tuple"]["startDisbursement(uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["startDisbursement(uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `raffle(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        raffle: (params: CallParams<StakingPoolArgs["obj"]["raffle(uint64)void"] | StakingPoolArgs["tuple"]["raffle(uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["raffle(uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `disburseRewards(uint64,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        disburseRewards: (params: CallParams<StakingPoolArgs["obj"]["disburseRewards(uint64,uint64)void"] | StakingPoolArgs["tuple"]["disburseRewards(uint64,uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["disburseRewards(uint64,uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `finalizeDistribution(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        finalizeDistribution: (params: CallParams<StakingPoolArgs["obj"]["finalizeDistribution(uint64)void"] | StakingPoolArgs["tuple"]["finalizeDistribution(uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["finalizeDistribution(uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `check(address,uint64)(bool,uint64)` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        check: (params: CallParams<StakingPoolArgs["obj"]["check(address,uint64)(bool,uint64)"] | StakingPoolArgs["tuple"]["check(address,uint64)(bool,uint64)"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["check(address,uint64)(bool,uint64)"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `gateCheck(appl,address,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        gateCheck: (params: CallParams<StakingPoolArgs["obj"]["gateCheck(appl,address,uint64)void"] | StakingPoolArgs["tuple"]["gateCheck(appl,address,uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["gateCheck(appl,address,uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `enterCost(address,uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * Calculates the total cost required to enter the pool
         *
         * @param params The params for the smart contract call
         * @returns The call result: The total payment amount needed (includes box MBR + any shortfall to meet min balance)
         */
        enterCost: (params: CallParams<StakingPoolArgs["obj"]["enterCost(address,uint64)uint64"] | StakingPoolArgs["tuple"]["enterCost(address,uint64)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["enterCost(address,uint64)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `optInCost(uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        optInCost: (params: CallParams<StakingPoolArgs["obj"]["optInCost(uint64)uint64"] | StakingPoolArgs["tuple"]["optInCost(uint64)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["optInCost(uint64)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `signUpsOpen()bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result: a boolean of whether sign ups are open
         */
        signUpsOpen: (params?: CallParams<StakingPoolArgs["obj"]["signUpsOpen()bool"] | StakingPoolArgs["tuple"]["signUpsOpen()bool"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["signUpsOpen()bool"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `isLive()bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result: a boolean of whether the pool is live
         */
        isLive: (params?: CallParams<StakingPoolArgs["obj"]["isLive()bool"] | StakingPoolArgs["tuple"]["isLive()bool"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["isLive()bool"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `isEntered(address)bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result: a boolean indicating if the address has entered the staking pool
         */
        isEntered: (params: CallParams<StakingPoolArgs["obj"]["isEntered(address)bool"] | StakingPoolArgs["tuple"]["isEntered(address)bool"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["isEntered(address)bool"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        getState: (params?: CallParams<StakingPoolArgs["obj"]["getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)"] | StakingPoolArgs["tuple"]["getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `updateAkitaDAOEscrow(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        updateAkitaDaoEscrow: (params: CallParams<StakingPoolArgs["obj"]["updateAkitaDAOEscrow(uint64)void"] | StakingPoolArgs["tuple"]["updateAkitaDAOEscrow(uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["updateAkitaDAOEscrow(uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `updateAkitaDAO(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        updateAkitaDao: (params: CallParams<StakingPoolArgs["obj"]["updateAkitaDAO(uint64)void"] | StakingPoolArgs["tuple"]["updateAkitaDAO(uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["updateAkitaDAO(uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `opUp()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        opUp: (params?: CallParams<StakingPoolArgs["obj"]["opUp()void"] | StakingPoolArgs["tuple"]["opUp()void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["opUp()void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the StakingPool smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result: the mbr created for each boxmap entry
         */
        mbr: (params: CallParams<StakingPoolArgs["obj"]["mbr(uint64)(uint64,uint64,uint64,uint64,uint64)"] | StakingPoolArgs["tuple"]["mbr(uint64)(uint64,uint64,uint64,uint64,uint64)"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingPoolReturns["mbr(uint64)(uint64,uint64,uint64,uint64,uint64)"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
    };
    /**
     * Clone this app client with different params
     *
     * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
     * @returns A new app client with the altered params
     */
    clone(params: CloneAppClientParams): StakingPoolClient;
    /**
     * Makes a readonly (simulated) call to the StakingPool smart contract using the `enterCost(address,uint64)uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Calculates the total cost required to enter the pool
     *
     * @param params The params for the smart contract call
     * @returns The call result: The total payment amount needed (includes box MBR + any shortfall to meet min balance)
     */
    enterCost(params: CallParams<StakingPoolArgs['obj']['enterCost(address,uint64)uint64'] | StakingPoolArgs['tuple']['enterCost(address,uint64)uint64']>): Promise<bigint>;
    /**
     * Makes a readonly (simulated) call to the StakingPool smart contract using the `optInCost(uint64)uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    optInCost(params: CallParams<StakingPoolArgs['obj']['optInCost(uint64)uint64'] | StakingPoolArgs['tuple']['optInCost(uint64)uint64']>): Promise<bigint>;
    /**
     * Makes a readonly (simulated) call to the StakingPool smart contract using the `signUpsOpen()bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result: a boolean of whether sign ups are open
     */
    signUpsOpen(params?: CallParams<StakingPoolArgs['obj']['signUpsOpen()bool'] | StakingPoolArgs['tuple']['signUpsOpen()bool']>): Promise<boolean>;
    /**
     * Makes a readonly (simulated) call to the StakingPool smart contract using the `isLive()bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result: a boolean of whether the pool is live
     */
    isLive(params?: CallParams<StakingPoolArgs['obj']['isLive()bool'] | StakingPoolArgs['tuple']['isLive()bool']>): Promise<boolean>;
    /**
     * Makes a readonly (simulated) call to the StakingPool smart contract using the `isEntered(address)bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result: a boolean indicating if the address has entered the staking pool
     */
    isEntered(params: CallParams<StakingPoolArgs['obj']['isEntered(address)bool'] | StakingPoolArgs['tuple']['isEntered(address)bool']>): Promise<boolean>;
    /**
     * Makes a readonly (simulated) call to the StakingPool smart contract using the `getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getState(params?: CallParams<StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']>): Promise<StakingPoolState>;
    /**
     * Makes a readonly (simulated) call to the StakingPool smart contract using the `mbr(uint64)(uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result: the mbr created for each boxmap entry
     */
    mbr(params: CallParams<StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']>): Promise<StakingPoolMbrData>;
    /**
     * Methods to access state for the current StakingPool app
     */
    state: {
        /**
         * Methods to access global state for the current StakingPool app
         */
        global: {
            /**
             * Get all current keyed values from global state
             */
            getAll: () => Promise<Partial<Expand<GlobalKeysState>>>;
            /**
             * Get the current value of the status key in global state
             */
            status: () => Promise<number | undefined>;
            /**
             * Get the current value of the title key in global state
             */
            title: () => Promise<string | undefined>;
            /**
             * Get the current value of the type key in global state
             */
            type: () => Promise<number | undefined>;
            /**
             * Get the current value of the signupTimestamp key in global state
             */
            signupTimestamp: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the allowLateSignups key in global state
             */
            allowLateSignups: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the startTimestamp key in global state
             */
            startTimestamp: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the endTimestamp key in global state
             */
            endTimestamp: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the maxEntries key in global state
             */
            maxEntries: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the entryID key in global state
             */
            entryId: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the rewardID key in global state
             */
            rewardId: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the totalStaked key in global state
             */
            totalStaked: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the stakeKey key in global state
             */
            stakeKey: () => Promise<RootKey | undefined>;
            /**
             * Get the current value of the minimumStakeAmount key in global state
             */
            minimumStakeAmount: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the gateID key in global state
             */
            gateId: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the gateSize key in global state
             */
            gateSize: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the creator key in global state
             */
            creator: () => Promise<string | undefined>;
            /**
             * Get the current value of the marketplace key in global state
             */
            marketplace: () => Promise<string | undefined>;
            /**
             * Get the current value of the marketplaceRoyalties key in global state
             */
            marketplaceRoyalties: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the akitaRoyalty key in global state
             */
            akitaRoyalty: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the akitaRoyaltyAmount key in global state
             */
            akitaRoyaltyAmount: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the salt key in global state
             */
            salt: () => Promise<BinaryState>;
            /**
             * Get the current value of the akitaDAOEscrow key in global state
             */
            akitaDaoEscrow: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the version key in global state
             */
            version: () => Promise<string | undefined>;
            /**
             * Get the current value of the akitaDAO key in global state
             */
            akitaDao: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the funder key in global state
             */
            funder: () => Promise<FunderInfo | undefined>;
        };
        /**
         * Methods to access box state for the current StakingPool app
         */
        box: {
            /**
             * Get all current keyed values from box state
             */
            getAll: () => Promise<Partial<Expand<BoxKeysState>>>;
            /**
             * Get values from the entries map in box state
             */
            entries: {
                /**
                 * Get all current values of the entries map in box state
                 */
                getMap: () => Promise<Map<bigint, EntryData>>;
                /**
                 * Get a current value of the entries map by key from box state
                 */
                value: (key: bigint | number) => Promise<EntryData | undefined>;
            };
            /**
             * Get values from the uniques map in box state
             */
            uniques: {
                /**
                 * Get all current values of the uniques map in box state
                 */
                getMap: () => Promise<Map<string, bigint>>;
                /**
                 * Get a current value of the uniques map by key from box state
                 */
                value: (key: string) => Promise<bigint | undefined>;
            };
            /**
             * Get values from the entriesByAddress map in box state
             */
            entriesByAddress: {
                /**
                 * Get all current values of the entriesByAddress map in box state
                 */
                getMap: () => Promise<Map<EntryKey, bigint>>;
                /**
                 * Get a current value of the entriesByAddress map by key from box state
                 */
                value: (key: EntryKey) => Promise<bigint | undefined>;
            };
            /**
             * Get values from the rewards map in box state
             */
            rewards: {
                /**
                 * Get all current values of the rewards map in box state
                 */
                getMap: () => Promise<Map<bigint, Reward>>;
                /**
                 * Get a current value of the rewards map by key from box state
                 */
                value: (key: bigint | number) => Promise<Reward | undefined>;
            };
            /**
             * Get values from the disbursements map in box state
             */
            disbursements: {
                /**
                 * Get all current values of the disbursements map in box state
                 */
                getMap: () => Promise<Map<bigint, Uint8Array>>;
                /**
                 * Get a current value of the disbursements map by key from box state
                 */
                value: (key: bigint | number) => Promise<Uint8Array | undefined>;
            };
        };
    };
    newGroup(): StakingPoolComposer;
}
export type StakingPoolComposer<TReturns extends [...any[]] = []> = {
    /**
     * Calls the init()void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    init(params?: CallParams<StakingPoolArgs['obj']['init()void'] | StakingPoolArgs['tuple']['init()void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['init()void'] | undefined]>;
    /**
     * Calls the optIn(pay,uint64)void ABI method.
     *
     * optin tells the contract to opt into an asa, it may also require the akita dao escrow to opt in
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    optIn(params?: CallParams<StakingPoolArgs['obj']['optIn(pay,uint64)void'] | StakingPoolArgs['tuple']['optIn(pay,uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['optIn(pay,uint64)void'] | undefined]>;
    /**
     * Calls the addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    addReward(params?: CallParams<StakingPoolArgs['obj']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['addReward(pay,(uint64,uint8,uint64,uint64,uint64,uint64))void'] | undefined]>;
    /**
     * Calls the addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    addRewardAsa(params?: CallParams<StakingPoolArgs['obj']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void'] | StakingPoolArgs['tuple']['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['addRewardAsa(pay,axfer,(uint64,uint8,uint64,uint64,uint64,uint64))void'] | undefined]>;
    /**
     * Calls the finalize(uint64,uint64,uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    finalize(params?: CallParams<StakingPoolArgs['obj']['finalize(uint64,uint64,uint64)void'] | StakingPoolArgs['tuple']['finalize(uint64,uint64,uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['finalize(uint64,uint64,uint64)void'] | undefined]>;
    /**
     * Calls the gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    gatedEnter(params?: CallParams<StakingPoolArgs['obj']['gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void'] | StakingPoolArgs['tuple']['gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['gatedEnter(pay,appl,(uint64,uint64,byte[32][])[])void'] | undefined]>;
    /**
     * Calls the enter(pay,(uint64,uint64,byte[32][])[])void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    enter(params?: CallParams<StakingPoolArgs['obj']['enter(pay,(uint64,uint64,byte[32][])[])void'] | StakingPoolArgs['tuple']['enter(pay,(uint64,uint64,byte[32][])[])void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['enter(pay,(uint64,uint64,byte[32][])[])void'] | undefined]>;
    /**
     * Calls the startDisbursement(uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    startDisbursement(params?: CallParams<StakingPoolArgs['obj']['startDisbursement(uint64)void'] | StakingPoolArgs['tuple']['startDisbursement(uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['startDisbursement(uint64)void'] | undefined]>;
    /**
     * Calls the raffle(uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    raffle(params?: CallParams<StakingPoolArgs['obj']['raffle(uint64)void'] | StakingPoolArgs['tuple']['raffle(uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['raffle(uint64)void'] | undefined]>;
    /**
     * Calls the disburseRewards(uint64,uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    disburseRewards(params?: CallParams<StakingPoolArgs['obj']['disburseRewards(uint64,uint64)void'] | StakingPoolArgs['tuple']['disburseRewards(uint64,uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['disburseRewards(uint64,uint64)void'] | undefined]>;
    /**
     * Calls the finalizeDistribution(uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    finalizeDistribution(params?: CallParams<StakingPoolArgs['obj']['finalizeDistribution(uint64)void'] | StakingPoolArgs['tuple']['finalizeDistribution(uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['finalizeDistribution(uint64)void'] | undefined]>;
    /**
     * Calls the check(address,uint64)(bool,uint64) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    check(params?: CallParams<StakingPoolArgs['obj']['check(address,uint64)(bool,uint64)'] | StakingPoolArgs['tuple']['check(address,uint64)(bool,uint64)']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['check(address,uint64)(bool,uint64)'] | undefined]>;
    /**
     * Calls the gateCheck(appl,address,uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    gateCheck(params?: CallParams<StakingPoolArgs['obj']['gateCheck(appl,address,uint64)void'] | StakingPoolArgs['tuple']['gateCheck(appl,address,uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['gateCheck(appl,address,uint64)void'] | undefined]>;
    /**
     * Calls the enterCost(address,uint64)uint64 ABI method.
     *
     * Calculates the total cost required to enter the pool
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    enterCost(params?: CallParams<StakingPoolArgs['obj']['enterCost(address,uint64)uint64'] | StakingPoolArgs['tuple']['enterCost(address,uint64)uint64']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['enterCost(address,uint64)uint64'] | undefined]>;
    /**
     * Calls the optInCost(uint64)uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    optInCost(params?: CallParams<StakingPoolArgs['obj']['optInCost(uint64)uint64'] | StakingPoolArgs['tuple']['optInCost(uint64)uint64']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['optInCost(uint64)uint64'] | undefined]>;
    /**
     * Calls the signUpsOpen()bool ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    signUpsOpen(params?: CallParams<StakingPoolArgs['obj']['signUpsOpen()bool'] | StakingPoolArgs['tuple']['signUpsOpen()bool']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['signUpsOpen()bool'] | undefined]>;
    /**
     * Calls the isLive()bool ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    isLive(params?: CallParams<StakingPoolArgs['obj']['isLive()bool'] | StakingPoolArgs['tuple']['isLive()bool']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['isLive()bool'] | undefined]>;
    /**
     * Calls the isEntered(address)bool ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    isEntered(params?: CallParams<StakingPoolArgs['obj']['isEntered(address)bool'] | StakingPoolArgs['tuple']['isEntered(address)bool']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['isEntered(address)bool'] | undefined]>;
    /**
     * Calls the getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    getState(params?: CallParams<StakingPoolArgs['obj']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | StakingPoolArgs['tuple']['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['getState()(uint8,string,uint8,uint64,uint64,bool,uint64,uint64,uint64,uint64,uint64,(address,string),uint64,uint64,address)'] | undefined]>;
    /**
     * Calls the updateAkitaDAOEscrow(uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    updateAkitaDaoEscrow(params?: CallParams<StakingPoolArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAOEscrow(uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['updateAkitaDAOEscrow(uint64)void'] | undefined]>;
    /**
     * Calls the updateAkitaDAO(uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    updateAkitaDao(params?: CallParams<StakingPoolArgs['obj']['updateAkitaDAO(uint64)void'] | StakingPoolArgs['tuple']['updateAkitaDAO(uint64)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['updateAkitaDAO(uint64)void'] | undefined]>;
    /**
     * Calls the opUp()void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    opUp(params?: CallParams<StakingPoolArgs['obj']['opUp()void'] | StakingPoolArgs['tuple']['opUp()void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['opUp()void'] | undefined]>;
    /**
     * Calls the mbr(uint64)(uint64,uint64,uint64,uint64,uint64) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    mbr(params?: CallParams<StakingPoolArgs['obj']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | StakingPoolArgs['tuple']['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['mbr(uint64)(uint64,uint64,uint64,uint64,uint64)'] | undefined]>;
    /**
     * Gets available update methods
     */
    readonly update: {
        /**
         * Updates an existing instance of the StakingPool smart contract using the update(string)void ABI method.
         *
         * @param args The arguments for the smart contract call
         * @param params Any additional parameters for the call
         * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
         */
        update(params?: CallParams<StakingPoolArgs['obj']['update(string)void'] | StakingPoolArgs['tuple']['update(string)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['update(string)void'] | undefined]>;
    };
    /**
     * Gets available delete methods
     */
    readonly delete: {
        /**
         * Deletes an existing instance of the StakingPool smart contract using the delete(address)void ABI method.
         *
         * @param args The arguments for the smart contract call
         * @param params Any additional parameters for the call
         * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
         */
        delete(params?: CallParams<StakingPoolArgs['obj']['delete(address)void'] | StakingPoolArgs['tuple']['delete(address)void']>): StakingPoolComposer<[...TReturns, StakingPoolReturns['delete(address)void'] | undefined]>;
    };
    /**
     * Makes a clear_state call to an existing instance of the StakingPool smart contract.
     *
     * @param args The arguments for the bare call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    clearState(params?: AppClientBareCallParams): StakingPoolComposer<[...TReturns, undefined]>;
    /**
     * Adds a transaction to the composer
     *
     * @param txn A transaction to add to the transaction group
     * @param signer The optional signer to use when signing this transaction.
     */
    addTransaction(txn: Transaction, signer?: TransactionSigner): StakingPoolComposer<TReturns>;
    /**
     * Returns the underlying AtomicTransactionComposer instance
     */
    composer(): Promise<TransactionComposer>;
    /**
     * Simulates the transaction group and returns the result
     */
    simulate(): Promise<StakingPoolComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    simulate(options: SkipSignaturesSimulateOptions): Promise<StakingPoolComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    simulate(options: RawSimulateOptions): Promise<StakingPoolComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    /**
     * Sends the transaction group to the network and returns the results
     */
    send(params?: SendParams): Promise<StakingPoolComposerResults<TReturns>>;
};
export type StakingPoolComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
    returns: TReturns;
}>;
