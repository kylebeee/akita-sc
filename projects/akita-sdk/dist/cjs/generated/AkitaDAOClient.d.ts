/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client';
import { ABIReturn } from '@algorandfoundation/algokit-utils/types/app';
import { Arc56Contract } from '@algorandfoundation/algokit-utils/types/app-arc56';
import { AppClient as _AppClient, AppClientMethodCallParams, AppClientParams, AppClientBareCallParams, CallOnComplete, AppClientCompilationParams, ResolveAppClientByCreatorAndName, ResolveAppClientByNetwork, CloneAppClientParams } from '@algorandfoundation/algokit-utils/types/app-client';
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory';
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer';
import { SendParams, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction';
import { Address, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk';
export declare const APP_SPEC: Arc56Contract;
/**
 * A state record containing binary data
 */
export interface BinaryState {
    /**
     * Gets the state value as a Uint8Array
     */
    asByteArray(): Uint8Array | undefined;
    /**
     * Gets the state value as a string
     */
    asString(): string | undefined;
}
/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R ? (...args: Expand<A>) => Expand<R> : T extends infer O ? {
    [K in keyof O]: O[K];
} : never;
export type Object752A5B25 = {
    upgradeApp: ProposalSettings;
    addPlugin: ProposalSettings;
    removeExecutePlugin: ProposalSettings;
    removePlugin: ProposalSettings;
    addAllowance: ProposalSettings;
    removeAllowance: ProposalSettings;
    newEscrow: ProposalSettings;
    toggleEscrowLock: ProposalSettings;
    updateFields: ProposalSettings;
};
/**
 * Converts the ABI tuple representation of a Object752A5B25 to the struct representation
 */
export declare function Object752A5B25FromTuple(abiTuple: [[bigint, bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint, bigint]]): Object752A5B25;
export type AkitaAppList = {
    staking: bigint;
    rewards: bigint;
    pool: bigint;
    prizeBox: bigint;
    subscriptions: bigint;
    gate: bigint;
    auction: bigint;
    hyperSwap: bigint;
    raffle: bigint;
    metaMerkles: bigint;
    marketplace: bigint;
    wallet: bigint;
};
/**
 * Converts the ABI tuple representation of a AkitaAppList to the struct representation
 */
export declare function AkitaAppListFromTuple(abiTuple: [bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint]): AkitaAppList;
export type AkitaAssets = {
    akta: bigint;
    bones: bigint;
};
/**
 * Converts the ABI tuple representation of a AkitaAssets to the struct representation
 */
export declare function AkitaAssetsFromTuple(abiTuple: [bigint, bigint]): AkitaAssets;
export type AkitaDaoApps = {
    staking: bigint;
    rewards: bigint;
    pool: bigint;
    prizeBox: bigint;
    subscriptions: bigint;
    gate: bigint;
    auction: bigint;
    hyperSwap: bigint;
    raffle: bigint;
    metaMerkles: bigint;
    marketplace: bigint;
    akitaNfd: bigint;
    optin: bigint;
    revenueManager: bigint;
    update: bigint;
    social: bigint;
    graph: bigint;
    impact: bigint;
    moderation: bigint;
    vrfBeacon: bigint;
    nfdRegistry: bigint;
    assetInbox: bigint;
    wallet: bigint;
    escrow: bigint;
    poll: bigint;
};
/**
 * Converts the ABI tuple representation of a AkitaDAOApps to the struct representation
 */
export declare function AkitaDaoAppsFromTuple(abiTuple: [bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint]): AkitaDaoApps;
export type AkitaDaoFees = {
    walletCreateFee: bigint;
    walletReferrerPercentage: bigint;
    postFee: bigint;
    reactFee: bigint;
    impactTaxMin: bigint;
    impactTaxMax: bigint;
    poolCreationFee: bigint;
    poolImpactTaxMin: bigint;
    poolImpactTaxMax: bigint;
    subscriptionServiceCreationFee: bigint;
    subscriptionPaymentPercentage: bigint;
    subscriptionTriggerPercentage: bigint;
    marketplaceSalePercentageMin: bigint;
    marketplaceSalePercentageMax: bigint;
    marketplaceComposablePercentage: bigint;
    marketplaceRoyaltyDefaultPercentage: bigint;
    shuffleSalePercentage: bigint;
    omnigemSaleFee: bigint;
    auctionCreationFee: bigint;
    auctionSaleImpactTaxMin: bigint;
    auctionSaleImpactTaxMax: bigint;
    auctionComposablePercentage: bigint;
    auctionRafflePercentage: bigint;
    raffleCreationFee: bigint;
    raffleSaleImpactTaxMin: bigint;
    raffleSaleImpactTaxMax: bigint;
    raffleComposablePercentage: bigint;
    swapFeeImpactTaxMin: bigint;
    swapFeeImpactTaxMax: bigint;
    swapComposablePercentage: bigint;
    swapLiquidityPercentage: bigint;
    krbyPercentage: bigint;
    moderatorPercentage: bigint;
};
/**
 * Converts the ABI tuple representation of a AkitaDAOFees to the struct representation
 */
export declare function AkitaDaoFeesFromTuple(abiTuple: [bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint]): AkitaDaoFees;
export type AkitaSocialAppList = {
    social: bigint;
    graph: bigint;
    impact: bigint;
    moderation: bigint;
};
/**
 * Converts the ABI tuple representation of a AkitaSocialAppList to the struct representation
 */
export declare function AkitaSocialAppListFromTuple(abiTuple: [bigint, bigint, bigint, bigint]): AkitaSocialAppList;
export type DaoPluginKey = {
    plugin: bigint;
    escrow: string;
};
/**
 * Converts the ABI tuple representation of a DAOPluginKey to the struct representation
 */
export declare function DaoPluginKeyFromTuple(abiTuple: [bigint, string]): DaoPluginKey;
export type ExecutionMetadata = {
    proposalId: bigint;
    index: bigint;
};
/**
 * Converts the ABI tuple representation of a ExecutionMetadata to the struct representation
 */
export declare function ExecutionMetadataFromTuple(abiTuple: [bigint, bigint]): ExecutionMetadata;
export type NftFees = {
    marketplaceSalePercentageMin: bigint;
    marketplaceSalePercentageMax: bigint;
    marketplaceComposablePercentage: bigint;
    marketplaceRoyaltyDefaultPercentage: bigint;
    shuffleSalePercentage: bigint;
    omnigemSaleFee: bigint;
    auctionCreationFee: bigint;
    auctionSaleImpactTaxMin: bigint;
    auctionSaleImpactTaxMax: bigint;
    auctionComposablePercentage: bigint;
    auctionRafflePercentage: bigint;
    raffleCreationFee: bigint;
    raffleSaleImpactTaxMin: bigint;
    raffleSaleImpactTaxMax: bigint;
    raffleComposablePercentage: bigint;
};
/**
 * Converts the ABI tuple representation of a NFTFees to the struct representation
 */
export declare function NftFeesFromTuple(abiTuple: [bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint]): NftFees;
export type OtherAppList = {
    vrfBeacon: bigint;
    nfdRegistry: bigint;
    assetInbox: bigint;
    escrow: bigint;
    poll: bigint;
    akitaNfd: bigint;
};
/**
 * Converts the ABI tuple representation of a OtherAppList to the struct representation
 */
export declare function OtherAppListFromTuple(abiTuple: [bigint, bigint, bigint, bigint, bigint, bigint]): OtherAppList;
export type PluginAppList = {
    optin: bigint;
    revenueManager: bigint;
    update: bigint;
};
/**
 * Converts the ABI tuple representation of a PluginAppList to the struct representation
 */
export declare function PluginAppListFromTuple(abiTuple: [bigint, bigint, bigint]): PluginAppList;
export type ProposalCostInfo = {
    total: bigint;
    mbr: bigint;
    fee: bigint;
    power: bigint;
    duration: bigint;
    participation: bigint;
    approval: bigint;
};
/**
 * Converts the ABI tuple representation of a ProposalCostInfo to the struct representation
 */
export declare function ProposalCostInfoFromTuple(abiTuple: [bigint, bigint, bigint, bigint, bigint, bigint, bigint]): ProposalCostInfo;
export type ProposalDetails = {
    status: number;
    cid: Uint8Array;
    votes: ProposalVoteTotals;
    creator: string;
    votingTs: bigint;
    created: bigint;
    feesPaid: bigint;
    actions: [number, Uint8Array][];
};
/**
 * Converts the ABI tuple representation of a ProposalDetails to the struct representation
 */
export declare function ProposalDetailsFromTuple(abiTuple: [number, Uint8Array, [bigint, bigint, bigint], string, bigint, bigint, bigint, [number, Uint8Array][]]): ProposalDetails;
export type ProposalSettings = {
    fee: bigint;
    power: bigint;
    duration: bigint;
    participation: bigint;
    approval: bigint;
};
/**
 * Converts the ABI tuple representation of a ProposalSettings to the struct representation
 */
export declare function ProposalSettingsFromTuple(abiTuple: [bigint, bigint, bigint, bigint, bigint]): ProposalSettings;
export type ProposalVoteInfo = {
    type: number;
    power: bigint;
};
/**
 * Converts the ABI tuple representation of a ProposalVoteInfo to the struct representation
 */
export declare function ProposalVoteInfoFromTuple(abiTuple: [number, bigint]): ProposalVoteInfo;
export type ProposalVoteKey = {
    proposalId: bigint;
    voter: string;
};
/**
 * Converts the ABI tuple representation of a ProposalVoteKey to the struct representation
 */
export declare function ProposalVoteKeyFromTuple(abiTuple: [bigint, string]): ProposalVoteKey;
export type ProposalVoteTotals = {
    approvals: bigint;
    rejections: bigint;
    abstains: bigint;
};
/**
 * Converts the ABI tuple representation of a ProposalVoteTotals to the struct representation
 */
export declare function ProposalVoteTotalsFromTuple(abiTuple: [bigint, bigint, bigint]): ProposalVoteTotals;
export type SocialFees = {
    postFee: bigint;
    reactFee: bigint;
    impactTaxMin: bigint;
    impactTaxMax: bigint;
};
/**
 * Converts the ABI tuple representation of a SocialFees to the struct representation
 */
export declare function SocialFeesFromTuple(abiTuple: [bigint, bigint, bigint, bigint]): SocialFees;
export type StakingFees = {
    creationFee: bigint;
    impactTaxMin: bigint;
    impactTaxMax: bigint;
};
/**
 * Converts the ABI tuple representation of a StakingFees to the struct representation
 */
export declare function StakingFeesFromTuple(abiTuple: [bigint, bigint, bigint]): StakingFees;
export type SubscriptionFees = {
    serviceCreationFee: bigint;
    paymentPercentage: bigint;
    triggerPercentage: bigint;
};
/**
 * Converts the ABI tuple representation of a SubscriptionFees to the struct representation
 */
export declare function SubscriptionFeesFromTuple(abiTuple: [bigint, bigint, bigint]): SubscriptionFees;
export type SwapFees = {
    impactTaxMin: bigint;
    impactTaxMax: bigint;
};
/**
 * Converts the ABI tuple representation of a SwapFees to the struct representation
 */
export declare function SwapFeesFromTuple(abiTuple: [bigint, bigint]): SwapFees;
export type WalletFees = {
    createFee: bigint;
    referrerPercentage: bigint;
};
/**
 * Converts the ABI tuple representation of a WalletFees to the struct representation
 */
export declare function WalletFeesFromTuple(abiTuple: [bigint, bigint]): WalletFees;
/**
 * The argument types for the AkitaDao contract
 */
export type AkitaDaoArgs = {
    /**
     * The object representation of the arguments for each method
     */
    obj: {
        'create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void': {
            version: string;
            akta: bigint | number;
            contentPolicy: Uint8Array;
            minRewardsImpact: bigint | number;
            apps: AkitaDaoApps;
            fees: AkitaDaoFees;
            proposalSettings: Object752A5B25;
            revenueSplits: [[bigint | number, string], bigint | number, bigint | number][];
        };
        'update(string)void': {
            newVersion: string;
        };
        'setup(string)uint64': {
            nickname: string;
        };
        'partiallyInitialize()void': Record<string, never>;
        'initialize()void': Record<string, never>;
        'newProposal(pay,byte[36],(uint8,byte[])[])uint64': {
            payment: AppMethodCallTransactionArgument;
            cid: Uint8Array;
            actions: [bigint | number, Uint8Array][];
        };
        'editProposal(uint64,byte[36],(uint8,byte[])[])void': {
            id: bigint | number;
            cid: Uint8Array;
            actions: [bigint | number, Uint8Array][];
        };
        'editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void': {
            payment: AppMethodCallTransactionArgument;
            id: bigint | number;
            cid: Uint8Array;
            actions: [bigint | number, Uint8Array][];
        };
        'deleteProposal(uint64)void': {
            proposalId: bigint | number;
        };
        'submitProposal(uint64)void': {
            proposalId: bigint | number;
        };
        'voteProposal(pay,uint64,uint8)void': {
            mbrPayment: AppMethodCallTransactionArgument;
            proposalId: bigint | number;
            vote: bigint | number;
        };
        'finalizeProposal(uint64)void': {
            proposalId: bigint | number;
        };
        'executeProposal(uint64)void': {
            proposalId: bigint | number;
        };
        'deleteProposalVotes(uint64,address[])void': {
            proposalId: bigint | number;
            voters: string[];
        };
        'setupCost()uint64': Record<string, never>;
        'proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)': {
            actions: [bigint | number, Uint8Array][];
        };
        'getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])': {
            proposalId: bigint | number;
        };
        'mustGetExecution(byte[32])(uint64,uint64)': {
            lease: Uint8Array;
        };
        'opUp()void': Record<string, never>;
    };
    /**
     * The tuple representation of the arguments for each method
     */
    tuple: {
        'create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void': [version: string, akta: bigint | number, contentPolicy: Uint8Array, minRewardsImpact: bigint | number, apps: AkitaDaoApps, fees: AkitaDaoFees, proposalSettings: Object752A5B25, revenueSplits: [[bigint | number, string], bigint | number, bigint | number][]];
        'update(string)void': [newVersion: string];
        'setup(string)uint64': [nickname: string];
        'partiallyInitialize()void': [];
        'initialize()void': [];
        'newProposal(pay,byte[36],(uint8,byte[])[])uint64': [payment: AppMethodCallTransactionArgument, cid: Uint8Array, actions: [bigint | number, Uint8Array][]];
        'editProposal(uint64,byte[36],(uint8,byte[])[])void': [id: bigint | number, cid: Uint8Array, actions: [bigint | number, Uint8Array][]];
        'editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void': [payment: AppMethodCallTransactionArgument, id: bigint | number, cid: Uint8Array, actions: [bigint | number, Uint8Array][]];
        'deleteProposal(uint64)void': [proposalId: bigint | number];
        'submitProposal(uint64)void': [proposalId: bigint | number];
        'voteProposal(pay,uint64,uint8)void': [mbrPayment: AppMethodCallTransactionArgument, proposalId: bigint | number, vote: bigint | number];
        'finalizeProposal(uint64)void': [proposalId: bigint | number];
        'executeProposal(uint64)void': [proposalId: bigint | number];
        'deleteProposalVotes(uint64,address[])void': [proposalId: bigint | number, voters: string[]];
        'setupCost()uint64': [];
        'proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)': [actions: [bigint | number, Uint8Array][]];
        'getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])': [proposalId: bigint | number];
        'mustGetExecution(byte[32])(uint64,uint64)': [lease: Uint8Array];
        'opUp()void': [];
    };
};
/**
 * The return type for each method
 */
export type AkitaDaoReturns = {
    'create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void': void;
    'update(string)void': void;
    'setup(string)uint64': bigint;
    'partiallyInitialize()void': void;
    'initialize()void': void;
    'newProposal(pay,byte[36],(uint8,byte[])[])uint64': bigint;
    'editProposal(uint64,byte[36],(uint8,byte[])[])void': void;
    'editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void': void;
    'deleteProposal(uint64)void': void;
    'submitProposal(uint64)void': void;
    'voteProposal(pay,uint64,uint8)void': void;
    'finalizeProposal(uint64)void': void;
    'executeProposal(uint64)void': void;
    'deleteProposalVotes(uint64,address[])void': void;
    'setupCost()uint64': bigint;
    'proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)': ProposalCostInfo;
    'getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])': ProposalDetails;
    'mustGetExecution(byte[32])(uint64,uint64)': ExecutionMetadata;
    'opUp()void': void;
};
/**
 * Defines the types of available calls and state of the AkitaDao smart contract.
 */
export type AkitaDaoTypes = {
    /**
     * Maps method signatures / names to their argument and return types.
     */
    methods: Record<'create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void' | 'create', {
        argsObj: AkitaDaoArgs['obj']['create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void'];
        argsTuple: AkitaDaoArgs['tuple']['create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void'];
        returns: AkitaDaoReturns['create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void'];
    }> & Record<'update(string)void' | 'update', {
        argsObj: AkitaDaoArgs['obj']['update(string)void'];
        argsTuple: AkitaDaoArgs['tuple']['update(string)void'];
        returns: AkitaDaoReturns['update(string)void'];
    }> & Record<'setup(string)uint64' | 'setup', {
        argsObj: AkitaDaoArgs['obj']['setup(string)uint64'];
        argsTuple: AkitaDaoArgs['tuple']['setup(string)uint64'];
        returns: AkitaDaoReturns['setup(string)uint64'];
    }> & Record<'partiallyInitialize()void' | 'partiallyInitialize', {
        argsObj: AkitaDaoArgs['obj']['partiallyInitialize()void'];
        argsTuple: AkitaDaoArgs['tuple']['partiallyInitialize()void'];
        returns: AkitaDaoReturns['partiallyInitialize()void'];
    }> & Record<'initialize()void' | 'initialize', {
        argsObj: AkitaDaoArgs['obj']['initialize()void'];
        argsTuple: AkitaDaoArgs['tuple']['initialize()void'];
        returns: AkitaDaoReturns['initialize()void'];
    }> & Record<'newProposal(pay,byte[36],(uint8,byte[])[])uint64' | 'newProposal', {
        argsObj: AkitaDaoArgs['obj']['newProposal(pay,byte[36],(uint8,byte[])[])uint64'];
        argsTuple: AkitaDaoArgs['tuple']['newProposal(pay,byte[36],(uint8,byte[])[])uint64'];
        returns: AkitaDaoReturns['newProposal(pay,byte[36],(uint8,byte[])[])uint64'];
    }> & Record<'editProposal(uint64,byte[36],(uint8,byte[])[])void' | 'editProposal', {
        argsObj: AkitaDaoArgs['obj']['editProposal(uint64,byte[36],(uint8,byte[])[])void'];
        argsTuple: AkitaDaoArgs['tuple']['editProposal(uint64,byte[36],(uint8,byte[])[])void'];
        returns: AkitaDaoReturns['editProposal(uint64,byte[36],(uint8,byte[])[])void'];
    }> & Record<'editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void' | 'editProposalWithPayment', {
        argsObj: AkitaDaoArgs['obj']['editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void'];
        argsTuple: AkitaDaoArgs['tuple']['editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void'];
        returns: AkitaDaoReturns['editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void'];
    }> & Record<'deleteProposal(uint64)void' | 'deleteProposal', {
        argsObj: AkitaDaoArgs['obj']['deleteProposal(uint64)void'];
        argsTuple: AkitaDaoArgs['tuple']['deleteProposal(uint64)void'];
        returns: AkitaDaoReturns['deleteProposal(uint64)void'];
    }> & Record<'submitProposal(uint64)void' | 'submitProposal', {
        argsObj: AkitaDaoArgs['obj']['submitProposal(uint64)void'];
        argsTuple: AkitaDaoArgs['tuple']['submitProposal(uint64)void'];
        returns: AkitaDaoReturns['submitProposal(uint64)void'];
    }> & Record<'voteProposal(pay,uint64,uint8)void' | 'voteProposal', {
        argsObj: AkitaDaoArgs['obj']['voteProposal(pay,uint64,uint8)void'];
        argsTuple: AkitaDaoArgs['tuple']['voteProposal(pay,uint64,uint8)void'];
        returns: AkitaDaoReturns['voteProposal(pay,uint64,uint8)void'];
    }> & Record<'finalizeProposal(uint64)void' | 'finalizeProposal', {
        argsObj: AkitaDaoArgs['obj']['finalizeProposal(uint64)void'];
        argsTuple: AkitaDaoArgs['tuple']['finalizeProposal(uint64)void'];
        returns: AkitaDaoReturns['finalizeProposal(uint64)void'];
    }> & Record<'executeProposal(uint64)void' | 'executeProposal', {
        argsObj: AkitaDaoArgs['obj']['executeProposal(uint64)void'];
        argsTuple: AkitaDaoArgs['tuple']['executeProposal(uint64)void'];
        returns: AkitaDaoReturns['executeProposal(uint64)void'];
    }> & Record<'deleteProposalVotes(uint64,address[])void' | 'deleteProposalVotes', {
        argsObj: AkitaDaoArgs['obj']['deleteProposalVotes(uint64,address[])void'];
        argsTuple: AkitaDaoArgs['tuple']['deleteProposalVotes(uint64,address[])void'];
        returns: AkitaDaoReturns['deleteProposalVotes(uint64,address[])void'];
    }> & Record<'setupCost()uint64' | 'setupCost', {
        argsObj: AkitaDaoArgs['obj']['setupCost()uint64'];
        argsTuple: AkitaDaoArgs['tuple']['setupCost()uint64'];
        returns: AkitaDaoReturns['setupCost()uint64'];
    }> & Record<'proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)' | 'proposalCost', {
        argsObj: AkitaDaoArgs['obj']['proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)'];
        argsTuple: AkitaDaoArgs['tuple']['proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)'];
        returns: AkitaDaoReturns['proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)'];
    }> & Record<'getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])' | 'getProposal', {
        argsObj: AkitaDaoArgs['obj']['getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])'];
        argsTuple: AkitaDaoArgs['tuple']['getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])'];
        returns: AkitaDaoReturns['getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])'];
    }> & Record<'mustGetExecution(byte[32])(uint64,uint64)' | 'mustGetExecution', {
        argsObj: AkitaDaoArgs['obj']['mustGetExecution(byte[32])(uint64,uint64)'];
        argsTuple: AkitaDaoArgs['tuple']['mustGetExecution(byte[32])(uint64,uint64)'];
        returns: AkitaDaoReturns['mustGetExecution(byte[32])(uint64,uint64)'];
    }> & Record<'opUp()void' | 'opUp', {
        argsObj: AkitaDaoArgs['obj']['opUp()void'];
        argsTuple: AkitaDaoArgs['tuple']['opUp()void'];
        returns: AkitaDaoReturns['opUp()void'];
    }>;
    /**
     * Defines the shape of the state of the application.
     */
    state: {
        global: {
            keys: {
                /**
                 * state of the DAO
                 */
                state: number;
                /**
                 * the version number of the DAO
                 */
                version: string;
                /**
                 * the arc58 wallet the DAO controls
                 */
                wallet: bigint;
                /**
                 * the number of actions allowed in a proposal
                 */
                proposalActionLimit: bigint;
                /**
                 * the raw 36 byte content policy of the protocol
                 */
                contentPolicy: BinaryState;
                /**
                 * the minimum impact score to qualify for daily disbursement
                 */
                minRewardsImpact: bigint;
                /**
                 * the list of akita contract ids
                 */
                akitaAppList: AkitaAppList;
                /**
                 * the list of akita social contract ids
                 */
                akitaSocialAppList: AkitaSocialAppList;
                /**
                 * the list of plugin contract ids
                 */
                pluginAppList: PluginAppList;
                /**
                 * the list of other contract ids we use
                 */
                otherAppList: OtherAppList;
                /**
                 * the fees for akita wallet operations
                 */
                walletFees: WalletFees;
                /**
                 * fees associated with akita social
                 */
                socialFees: SocialFees;
                /**
                 * fees associated with staking assets
                 */
                stakingFees: StakingFees;
                /**
                 * fees associated with subscriptions
                 */
                subscriptionFees: SubscriptionFees;
                /**
                 * fees associated with NFT sales
                 */
                nftFees: NftFees;
                /**
                 * fees associated with swaps
                 */
                swapFees: SwapFees;
                /**
                 * the akita assets
                 */
                akitaAssets: AkitaAssets;
                /**
                 * the revenue manager contract id
                 */
                revenueSplits: [[bigint, string], number, bigint][];
                /**
                 * proposal settings for upgrading applications
                 */
                upgradeAppProposalSettings: ProposalSettings;
                /**
                 * proposal settings for adding a plugin
                 */
                addPluginProposalSettings: ProposalSettings;
                /**
                 * proposal settings for removing a plugin
                 */
                removePluginProposalSettings: ProposalSettings;
                /**
                 * proposal settings for removing a plugin execution
                 */
                removeExecutePluginProposalSettings: ProposalSettings;
                /**
                 * proposal settings for adding an allowance
                 */
                addAllowancesProposalSettings: ProposalSettings;
                /**
                 * proposal settings for removing an allowance
                 */
                removeAllowancesProposalSettings: ProposalSettings;
                /**
                 * proposal settings for creating a new escrow
                 */
                newEscrowProposalSettings: ProposalSettings;
                /**
                 * proposal settings for toggling an escrow lock
                 */
                toggleEscrowLockProposalSettings: ProposalSettings;
                /**
                 * proposal settings for updating fields
                 */
                updateFieldsProposalSettings: ProposalSettings;
                /**
                 * the next proposal id
                 */
                proposalId: bigint;
            };
            maps: {};
        };
        box: {
            keys: {};
            maps: {
                /**
                 * Plugins that add functionality to the controlledAddress and the account that has permission to use it.
                 */
                plugins: Map<DaoPluginKey, ProposalSettings>;
                /**
                 * voting state of a proposal
                 */
                proposals: Map<bigint | number, ProposalDetails>;
                /**
                 * votes by proposal id & address
                 */
                proposalVotes: Map<ProposalVoteKey, ProposalVoteInfo>;
                /**
                 * extra execution information for the DAO
                 */
                executions: Map<Uint8Array | string, ExecutionMetadata>;
            };
        };
    };
};
/**
 * Defines the possible abi call signatures.
 */
export type AkitaDaoSignatures = keyof AkitaDaoTypes['methods'];
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type AkitaDaoNonVoidMethodSignatures = keyof AkitaDaoTypes['methods'] extends infer T ? T extends keyof AkitaDaoTypes['methods'] ? MethodReturn<T> extends void ? never : T : never : never;
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> & {
    /** The args for the ABI method call, either as an ordered array or an object */
    args: Expand<TArgs>;
}>;
/**
 * Maps a method signature from the AkitaDao smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends AkitaDaoSignatures> = AkitaDaoTypes['methods'][TSignature]['argsObj' | 'argsTuple'];
/**
 * Maps a method signature from the AkitaDao smart contract to the method's return type
 */
export type MethodReturn<TSignature extends AkitaDaoSignatures> = AkitaDaoTypes['methods'][TSignature]['returns'];
/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = AkitaDaoTypes['state']['global']['keys'];
/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = AkitaDaoTypes['state']['box']['keys'];
/**
 * Defines supported create method params for this smart contract
 */
export type AkitaDaoCreateCallParams = Expand<CallParams<AkitaDaoArgs['obj']['create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void'] | AkitaDaoArgs['tuple']['create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void']> & {
    method: 'create';
} & {
    onComplete?: OnApplicationComplete.NoOpOC;
} & CreateSchema> | Expand<CallParams<AkitaDaoArgs['obj']['create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void'] | AkitaDaoArgs['tuple']['create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void']> & {
    method: 'create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void';
} & {
    onComplete?: OnApplicationComplete.NoOpOC;
} & CreateSchema>;
/**
 * Defines supported update method params for this smart contract
 */
export type AkitaDaoUpdateCallParams = Expand<CallParams<AkitaDaoArgs['obj']['update(string)void'] | AkitaDaoArgs['tuple']['update(string)void']> & {
    method: 'update';
}> | Expand<CallParams<AkitaDaoArgs['obj']['update(string)void'] | AkitaDaoArgs['tuple']['update(string)void']> & {
    method: 'update(string)void';
}>;
/**
 * Defines arguments required for the deploy method.
 */
export type AkitaDaoDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
    /**
     * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
     */
    createParams?: AkitaDaoCreateCallParams;
    /**
     * Update transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
     */
    updateParams?: AkitaDaoUpdateCallParams;
}>;
/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the AkitaDao smart contract
 */
export declare abstract class AkitaDaoParamsFactory {
    /**
     * Gets available create ABI call param factories
     */
    static get create(): {
        _resolveByMethod<TParams extends AkitaDaoCreateCallParams & {
            method: string;
        }>(params: TParams): {
            maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            signer?: (TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount) | undefined;
            rekeyTo?: (string | Address) | undefined;
            note?: (Uint8Array | string) | undefined;
            lease?: (Uint8Array | string) | undefined;
            staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            validityWindow?: number | bigint | undefined;
            firstValidRound?: bigint | undefined;
            lastValidRound?: bigint | undefined;
            onComplete?: OnApplicationComplete | undefined;
            accountReferences?: (string | Address)[] | undefined;
            appReferences?: bigint[] | undefined;
            assetReferences?: bigint[] | undefined;
            boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference | import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier)[] | undefined;
            sender?: (Address | string) | undefined;
            method: string;
            args?: (import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | AppMethodCallTransactionArgument | undefined)[] | undefined;
        } & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        };
        /**
         * Constructs create ABI call params for the AkitaDAO smart contract using the create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void ABI method
         *
         * @param params Parameters for the call
         * @returns An `AppClientMethodCallParams` object for the call
         */
        create(params: CallParams<AkitaDaoArgs["obj"]["create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void"] | AkitaDaoArgs["tuple"]["create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void"]> & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }): AppClientMethodCallParams & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        };
    };
    /**
     * Gets available update ABI call param factories
     */
    static get update(): {
        _resolveByMethod<TParams extends AkitaDaoUpdateCallParams & {
            method: string;
        }>(params: TParams): {
            maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            signer?: (TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount) | undefined;
            rekeyTo?: (string | Address) | undefined;
            note?: (Uint8Array | string) | undefined;
            lease?: (Uint8Array | string) | undefined;
            staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            validityWindow?: number | bigint | undefined;
            firstValidRound?: bigint | undefined;
            lastValidRound?: bigint | undefined;
            onComplete?: OnApplicationComplete | undefined;
            accountReferences?: (string | Address)[] | undefined;
            appReferences?: bigint[] | undefined;
            assetReferences?: bigint[] | undefined;
            boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference | import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier)[] | undefined;
            sender?: (Address | string) | undefined;
            method: string;
            args?: (import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | AppMethodCallTransactionArgument | undefined)[] | undefined;
        } & AppClientCompilationParams;
        /**
         * Constructs update ABI call params for the AkitaDAO smart contract using the update(string)void ABI method
         *
         * @param params Parameters for the call
         * @returns An `AppClientMethodCallParams` object for the call
         */
        update(params: CallParams<AkitaDaoArgs["obj"]["update(string)void"] | AkitaDaoArgs["tuple"]["update(string)void"]> & AppClientCompilationParams): AppClientMethodCallParams & AppClientCompilationParams;
    };
    /**
     * Constructs a no op call for the setup(string)uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static setup(params: CallParams<AkitaDaoArgs['obj']['setup(string)uint64'] | AkitaDaoArgs['tuple']['setup(string)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the partiallyInitialize()void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static partiallyInitialize(params: CallParams<AkitaDaoArgs['obj']['partiallyInitialize()void'] | AkitaDaoArgs['tuple']['partiallyInitialize()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the initialize()void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static initialize(params: CallParams<AkitaDaoArgs['obj']['initialize()void'] | AkitaDaoArgs['tuple']['initialize()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the newProposal(pay,byte[36],(uint8,byte[])[])uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static newProposal(params: CallParams<AkitaDaoArgs['obj']['newProposal(pay,byte[36],(uint8,byte[])[])uint64'] | AkitaDaoArgs['tuple']['newProposal(pay,byte[36],(uint8,byte[])[])uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the editProposal(uint64,byte[36],(uint8,byte[])[])void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static editProposal(params: CallParams<AkitaDaoArgs['obj']['editProposal(uint64,byte[36],(uint8,byte[])[])void'] | AkitaDaoArgs['tuple']['editProposal(uint64,byte[36],(uint8,byte[])[])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static editProposalWithPayment(params: CallParams<AkitaDaoArgs['obj']['editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void'] | AkitaDaoArgs['tuple']['editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the deleteProposal(uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static deleteProposal(params: CallParams<AkitaDaoArgs['obj']['deleteProposal(uint64)void'] | AkitaDaoArgs['tuple']['deleteProposal(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the submitProposal(uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static submitProposal(params: CallParams<AkitaDaoArgs['obj']['submitProposal(uint64)void'] | AkitaDaoArgs['tuple']['submitProposal(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the voteProposal(pay,uint64,uint8)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static voteProposal(params: CallParams<AkitaDaoArgs['obj']['voteProposal(pay,uint64,uint8)void'] | AkitaDaoArgs['tuple']['voteProposal(pay,uint64,uint8)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the finalizeProposal(uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static finalizeProposal(params: CallParams<AkitaDaoArgs['obj']['finalizeProposal(uint64)void'] | AkitaDaoArgs['tuple']['finalizeProposal(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the executeProposal(uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static executeProposal(params: CallParams<AkitaDaoArgs['obj']['executeProposal(uint64)void'] | AkitaDaoArgs['tuple']['executeProposal(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the deleteProposalVotes(uint64,address[])void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static deleteProposalVotes(params: CallParams<AkitaDaoArgs['obj']['deleteProposalVotes(uint64,address[])void'] | AkitaDaoArgs['tuple']['deleteProposalVotes(uint64,address[])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the setupCost()uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static setupCost(params: CallParams<AkitaDaoArgs['obj']['setupCost()uint64'] | AkitaDaoArgs['tuple']['setupCost()uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static proposalCost(params: CallParams<AkitaDaoArgs['obj']['proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | AkitaDaoArgs['tuple']['proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[]) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static getProposal(params: CallParams<AkitaDaoArgs['obj']['getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])'] | AkitaDaoArgs['tuple']['getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the mustGetExecution(byte[32])(uint64,uint64) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static mustGetExecution(params: CallParams<AkitaDaoArgs['obj']['mustGetExecution(byte[32])(uint64,uint64)'] | AkitaDaoArgs['tuple']['mustGetExecution(byte[32])(uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the opUp()void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static opUp(params: CallParams<AkitaDaoArgs['obj']['opUp()void'] | AkitaDaoArgs['tuple']['opUp()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
}
/**
 * A factory to create and deploy one or more instance of the AkitaDAO smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export declare class AkitaDaoFactory {
    /**
     * The underlying `AppFactory` for when you want to have more flexibility
     */
    readonly appFactory: _AppFactory;
    /**
     * Creates a new instance of `AkitaDaoFactory`
     *
     * @param params The parameters to initialise the app factory with
     */
    constructor(params: Omit<AppFactoryParams, 'appSpec'>);
    /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
    get appName(): string;
    /** The ARC-56 app spec being used */
    get appSpec(): Arc56Contract;
    /** A reference to the underlying `AlgorandClient` this app factory is using. */
    get algorand(): AlgorandClient;
    /**
     * Returns a new `AppClient` client for an app instance of the given ID.
     *
     * Automatically populates appName, defaultSender and source maps from the factory
     * if not specified in the params.
     * @param params The parameters to create the app client
     * @returns The `AppClient`
     */
    getAppClientById(params: AppFactoryAppClientParams): AkitaDaoClient;
    /**
     * Returns a new `AppClient` client, resolving the app by creator address and name
     * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
     *
     * Automatically populates appName, defaultSender and source maps from the factory
     * if not specified in the params.
     * @param params The parameters to create the app client
     * @returns The `AppClient`
     */
    getAppClientByCreatorAndName(params: AppFactoryResolveAppClientByCreatorAndNameParams): Promise<AkitaDaoClient>;
    /**
     * Idempotently deploys the AkitaDAO smart contract.
     *
     * @param params The arguments for the contract calls and any additional parameters for the call
     * @returns The deployment result
     */
    deploy(params?: AkitaDaoDeployParams): Promise<{
        result: {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "create";
            version: string;
            name: string;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            appId: bigint;
            appAddress: Address;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "update";
            appId: bigint;
            appAddress: Address;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            name: string;
            version: string;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "replace";
            version: string;
            name: string;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            appId: bigint;
            appAddress: Address;
            deleteResult: import("@algorandfoundation/algokit-utils/types/transaction").ConfirmedTransactionResult;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "nothing";
            appId: bigint;
            appAddress: Address;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            name: string;
            version: string;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
        };
        appClient: AkitaDaoClient;
    }>;
    /**
     * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
     */
    readonly params: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the AkitaDAO smart contract using the create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The create params
             */
            create: (params: CallParams<AkitaDaoArgs["obj"]["create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void"] | AkitaDaoArgs["tuple"]["create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void"]> & AppClientCompilationParams & CreateSchema & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                deployTimeParams: import("@algorandfoundation/algokit-utils/types/app").TealTemplateParams | undefined;
                schema: {
                    globalInts: number;
                    globalByteSlices: number;
                    localInts: number;
                    localByteSlices: number;
                };
                approvalProgram: Uint8Array;
                clearStateProgram: Uint8Array;
                maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                note?: string | Uint8Array | undefined;
                signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                lease?: string | Uint8Array | undefined;
                rekeyTo?: string | Address | undefined;
                staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                validityWindow?: number | bigint | undefined;
                firstValidRound?: bigint | undefined;
                lastValidRound?: bigint | undefined;
                accountReferences?: (string | Address)[] | undefined;
                appReferences?: bigint[] | undefined;
                assetReferences?: bigint[] | undefined;
                boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                sender?: string | Address | undefined;
                method: string;
                args?: (import("algosdk").ABIValue | AppMethodCallTransactionArgument | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined)[] | undefined;
                updatable?: boolean | undefined;
                deletable?: boolean | undefined;
                extraProgramPages?: number | undefined;
            } & {
                sender: Address;
                signer: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                method: import("@algorandfoundation/algokit-utils/types/app-arc56").Arc56Method;
                args: (Transaction | import("algosdk").ABIValue | import("algosdk").TransactionWithSigner | Promise<Transaction> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    note?: string | Uint8Array | undefined;
                    args?: Uint8Array[] | undefined;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                    lease?: string | Uint8Array | undefined;
                    rekeyTo?: string | Address | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                    schema?: {
                        globalInts: number;
                        globalByteSlices: number;
                        localInts: number;
                        localByteSlices: number;
                    } | undefined;
                    extraProgramPages?: number | undefined;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    rekeyTo?: string | Address | undefined;
                    note?: string | Uint8Array | undefined;
                    lease?: string | Uint8Array | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    appId: bigint;
                    onComplete?: OnApplicationComplete.UpdateApplicationOC | undefined;
                    args?: Uint8Array[] | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<import("@algorandfoundation/algokit-utils/types/composer").AppMethodCallParams> | undefined)[] | undefined;
                onComplete: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC;
            }>;
        };
        /**
         * Gets available deployUpdate methods
         */
        deployUpdate: {
            /**
             * Updates an existing instance of the AkitaDAO smart contract using the update(string)void ABI method.
             *
            *
            The Akita DAO contract supports its own upgrade via a secure, auditable process. Here's a step-by-step trace of how a self-upgrade is executed:
            
            1. Proposal Creation:
              - A member submits a proposal to upgrade the DAO by including a ProposalAction of type `UpgradeApp`.
              - This proposal references the ARC58 contract and specifies the required upgrade parameters, such as the new application code and any associated execution keys.
            
            2. Proposal Approval:
              - The DAO community votes on the proposal. If it receives sufficient approvals as defined in the proposals settings, its status changes to `Approved`.
            
            3. Execution Initiation:
              - Upon approval, the DAO creates an execution entry in the ARC58 contract using the parameters from the upgrade proposal.
              - This sets up the conditions under which an upgrade may be performed, such as locking execution to a valid round interval and binding it to a unique execution key (via the transaction lease).
            
            4. Upgrade Execution:
              - A transaction group is submitted where the ARC58 account (or an authorized delegate) triggers the actual `update` method on the DAO contract.
              - The `update` method receives the `proposalID` and index of the upgrade action.
              - The DAO contract performs the following validation checks before actually permitting the upgrade:
                  a. Confirms the referenced proposal exists and has status `Approved`.
                  b. Ensures the action type matches `UpgradeApp`.
                  c. Verifies the current app ID matches the proposals intended target.
                  d. Ensures the transaction lease matches the authorized execution key from the proposal.
                  e. Validates that the group context (via groupId and round) satisfies execution constraintse.g., only the specified group may proceed and only within a permitted round window.
              - Only if all conditions are satisfied is the application update allowed to continue.
            
            This architecture ensures upgrades are strictly governed, requiring DAO consensus, group-based transaction atomicity, and explicit validation checks at execution time.
      
             *
             * @param params The params for the smart contract call
             * @returns The deployUpdate params
             */
            update: (params: CallParams<AkitaDaoArgs["obj"]["update(string)void"] | AkitaDaoArgs["tuple"]["update(string)void"]> & AppClientCompilationParams) => {
                maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                note?: string | Uint8Array | undefined;
                signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                onComplete?: OnApplicationComplete | undefined;
                lease?: string | Uint8Array | undefined;
                rekeyTo?: string | Address | undefined;
                staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                validityWindow?: number | bigint | undefined;
                firstValidRound?: bigint | undefined;
                lastValidRound?: bigint | undefined;
                accountReferences?: (string | Address)[] | undefined;
                appReferences?: bigint[] | undefined;
                assetReferences?: bigint[] | undefined;
                boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                sender?: string | Address | undefined;
                method: string;
                args?: (import("algosdk").ABIValue | AppMethodCallTransactionArgument | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined)[] | undefined;
            } & {
                sender: Address;
                signer: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                method: import("@algorandfoundation/algokit-utils/types/app-arc56").Arc56Method;
                args: (Transaction | import("algosdk").ABIValue | import("algosdk").TransactionWithSigner | Promise<Transaction> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    note?: string | Uint8Array | undefined;
                    args?: Uint8Array[] | undefined;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                    lease?: string | Uint8Array | undefined;
                    rekeyTo?: string | Address | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                    schema?: {
                        globalInts: number;
                        globalByteSlices: number;
                        localInts: number;
                        localByteSlices: number;
                    } | undefined;
                    extraProgramPages?: number | undefined;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    rekeyTo?: string | Address | undefined;
                    note?: string | Uint8Array | undefined;
                    lease?: string | Uint8Array | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    appId: bigint;
                    onComplete?: OnApplicationComplete.UpdateApplicationOC | undefined;
                    args?: Uint8Array[] | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<import("@algorandfoundation/algokit-utils/types/composer").AppMethodCallParams> | undefined)[] | undefined;
                onComplete: OnApplicationComplete.UpdateApplicationOC;
            };
        };
    };
    /**
     * Create transactions for the current app
     */
    readonly createTransaction: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the AkitaDAO smart contract using the create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The create transaction
             */
            create: (params: CallParams<AkitaDaoArgs["obj"]["create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void"] | AkitaDaoArgs["tuple"]["create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void"]> & AppClientCompilationParams & CreateSchema & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                transactions: Transaction[];
                methodCalls: Map<number, import("algosdk").ABIMethod>;
                signers: Map<number, TransactionSigner>;
            }>;
        };
    };
    /**
     * Send calls to the current app
     */
    readonly send: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the AkitaDAO smart contract using an ABI method call using the create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The create result
             */
            create: (params: CallParams<AkitaDaoArgs["obj"]["create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void"] | AkitaDaoArgs["tuple"]["create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void"]> & AppClientCompilationParams & CreateSchema & SendParams & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                result: {
                    return: (undefined | AkitaDaoReturns["create(string,uint64,byte[36],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),((uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,uint64,uint64)),((uint64,string),uint8,uint64)[])void"]);
                    compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                    compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                    appId: bigint;
                    groupId: string;
                    txIds: string[];
                    returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
                    confirmations: modelsv2.PendingTransactionResponse[];
                    transactions: Transaction[];
                    confirmation: modelsv2.PendingTransactionResponse;
                    transaction: Transaction;
                    appAddress: Address;
                };
                appClient: AkitaDaoClient;
            }>;
        };
    };
}
/**
 * A client to make calls to the AkitaDAO smart contract
 */
export declare class AkitaDaoClient {
    /**
     * The underlying `AppClient` for when you want to have more flexibility
     */
    readonly appClient: _AppClient;
    /**
     * Creates a new instance of `AkitaDaoClient`
     *
     * @param appClient An `AppClient` instance which has been created with the AkitaDao app spec
     */
    constructor(appClient: _AppClient);
    /**
     * Creates a new instance of `AkitaDaoClient`
     *
     * @param params The parameters to initialise the app client with
     */
    constructor(params: Omit<AppClientParams, 'appSpec'>);
    /**
     * Checks for decode errors on the given return value and maps the return value to the return type for the given method
     * @returns The typed return value or undefined if there was no value
     */
    decodeReturnValue<TSignature extends AkitaDaoNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined): MethodReturn<TSignature> | undefined;
    /**
     * Returns a new `AkitaDaoClient` client, resolving the app by creator address and name
     * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
     * @param params The parameters to create the app client
     */
    static fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<AkitaDaoClient>;
    /**
     * Returns an `AkitaDaoClient` instance for the current network based on
     * pre-determined network-specific app IDs specified in the ARC-56 app spec.
     *
     * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
     * @param params The parameters to create the app client
     */
    static fromNetwork(params: Omit<ResolveAppClientByNetwork, 'appSpec'>): Promise<AkitaDaoClient>;
    /** The ID of the app instance this client is linked to. */
    get appId(): bigint;
    /** The app address of the app instance this client is linked to. */
    get appAddress(): Address;
    /** The name of the app. */
    get appName(): string;
    /** The ARC-56 app spec being used */
    get appSpec(): Arc56Contract;
    /** A reference to the underlying `AlgorandClient` this app client is using. */
    get algorand(): AlgorandClient;
    /**
     * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
     */
    readonly params: {
        /**
         * Gets available update methods
         */
        update: {
            /**
             * Updates an existing instance of the AkitaDAO smart contract using the `update(string)void` ABI method.
             *
            *
            The Akita DAO contract supports its own upgrade via a secure, auditable process. Here's a step-by-step trace of how a self-upgrade is executed:
            
            1. Proposal Creation:
              - A member submits a proposal to upgrade the DAO by including a ProposalAction of type `UpgradeApp`.
              - This proposal references the ARC58 contract and specifies the required upgrade parameters, such as the new application code and any associated execution keys.
            
            2. Proposal Approval:
              - The DAO community votes on the proposal. If it receives sufficient approvals as defined in the proposals settings, its status changes to `Approved`.
            
            3. Execution Initiation:
              - Upon approval, the DAO creates an execution entry in the ARC58 contract using the parameters from the upgrade proposal.
              - This sets up the conditions under which an upgrade may be performed, such as locking execution to a valid round interval and binding it to a unique execution key (via the transaction lease).
            
            4. Upgrade Execution:
              - A transaction group is submitted where the ARC58 account (or an authorized delegate) triggers the actual `update` method on the DAO contract.
              - The `update` method receives the `proposalID` and index of the upgrade action.
              - The DAO contract performs the following validation checks before actually permitting the upgrade:
                  a. Confirms the referenced proposal exists and has status `Approved`.
                  b. Ensures the action type matches `UpgradeApp`.
                  c. Verifies the current app ID matches the proposals intended target.
                  d. Ensures the transaction lease matches the authorized execution key from the proposal.
                  e. Validates that the group context (via groupId and round) satisfies execution constraintse.g., only the specified group may proceed and only within a permitted round window.
              - Only if all conditions are satisfied is the application update allowed to continue.
            
            This architecture ensures upgrades are strictly governed, requiring DAO consensus, group-based transaction atomicity, and explicit validation checks at execution time.
      
             *
             * @param params The params for the smart contract call
             * @returns The update params
             */
            update: (params: CallParams<AkitaDaoArgs["obj"]["update(string)void"] | AkitaDaoArgs["tuple"]["update(string)void"]> & AppClientCompilationParams) => Promise<{
                approvalProgram: Uint8Array;
                clearStateProgram: Uint8Array;
                compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                note?: string | Uint8Array | undefined;
                signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                onComplete?: OnApplicationComplete | undefined;
                lease?: string | Uint8Array | undefined;
                rekeyTo?: string | Address | undefined;
                staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                validityWindow?: number | bigint | undefined;
                firstValidRound?: bigint | undefined;
                lastValidRound?: bigint | undefined;
                accountReferences?: (string | Address)[] | undefined;
                appReferences?: bigint[] | undefined;
                assetReferences?: bigint[] | undefined;
                boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                sender?: string | Address | undefined;
                method: string;
                args?: (import("algosdk").ABIValue | AppMethodCallTransactionArgument | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined)[] | undefined;
                deployTimeParams?: import("@algorandfoundation/algokit-utils/types/app").TealTemplateParams | undefined;
                updatable?: boolean | undefined;
                deletable?: boolean | undefined;
            } & {
                appId: bigint;
                sender: Address;
                signer: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                method: import("@algorandfoundation/algokit-utils/types/app-arc56").Arc56Method;
                onComplete: OnApplicationComplete.UpdateApplicationOC;
                args: (Transaction | import("algosdk").ABIValue | import("algosdk").TransactionWithSigner | Promise<Transaction> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    note?: string | Uint8Array | undefined;
                    args?: Uint8Array[] | undefined;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                    lease?: string | Uint8Array | undefined;
                    rekeyTo?: string | Address | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                    schema?: {
                        globalInts: number;
                        globalByteSlices: number;
                        localInts: number;
                        localByteSlices: number;
                    } | undefined;
                    extraProgramPages?: number | undefined;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    rekeyTo?: string | Address | undefined;
                    note?: string | Uint8Array | undefined;
                    lease?: string | Uint8Array | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    appId: bigint;
                    onComplete?: OnApplicationComplete.UpdateApplicationOC | undefined;
                    args?: Uint8Array[] | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<import("@algorandfoundation/algokit-utils/types/composer").AppMethodCallParams> | undefined)[] | undefined;
            }>;
        };
        /**
         * Makes a clear_state call to an existing instance of the AkitaDAO smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams>) => import("@algorandfoundation/algokit-utils/types/composer").AppCallParams;
        /**
         * Makes a call to the AkitaDAO smart contract using the `setup(string)uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        setup: (params: CallParams<AkitaDaoArgs["obj"]["setup(string)uint64"] | AkitaDaoArgs["tuple"]["setup(string)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `partiallyInitialize()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        partiallyInitialize: (params?: CallParams<AkitaDaoArgs["obj"]["partiallyInitialize()void"] | AkitaDaoArgs["tuple"]["partiallyInitialize()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `initialize()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        initialize: (params?: CallParams<AkitaDaoArgs["obj"]["initialize()void"] | AkitaDaoArgs["tuple"]["initialize()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `newProposal(pay,byte[36],(uint8,byte[])[])uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        newProposal: (params: CallParams<AkitaDaoArgs["obj"]["newProposal(pay,byte[36],(uint8,byte[])[])uint64"] | AkitaDaoArgs["tuple"]["newProposal(pay,byte[36],(uint8,byte[])[])uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `editProposal(uint64,byte[36],(uint8,byte[])[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        editProposal: (params: CallParams<AkitaDaoArgs["obj"]["editProposal(uint64,byte[36],(uint8,byte[])[])void"] | AkitaDaoArgs["tuple"]["editProposal(uint64,byte[36],(uint8,byte[])[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        editProposalWithPayment: (params: CallParams<AkitaDaoArgs["obj"]["editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void"] | AkitaDaoArgs["tuple"]["editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `deleteProposal(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        deleteProposal: (params: CallParams<AkitaDaoArgs["obj"]["deleteProposal(uint64)void"] | AkitaDaoArgs["tuple"]["deleteProposal(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `submitProposal(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        submitProposal: (params: CallParams<AkitaDaoArgs["obj"]["submitProposal(uint64)void"] | AkitaDaoArgs["tuple"]["submitProposal(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `voteProposal(pay,uint64,uint8)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        voteProposal: (params: CallParams<AkitaDaoArgs["obj"]["voteProposal(pay,uint64,uint8)void"] | AkitaDaoArgs["tuple"]["voteProposal(pay,uint64,uint8)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `finalizeProposal(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        finalizeProposal: (params: CallParams<AkitaDaoArgs["obj"]["finalizeProposal(uint64)void"] | AkitaDaoArgs["tuple"]["finalizeProposal(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `executeProposal(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        executeProposal: (params: CallParams<AkitaDaoArgs["obj"]["executeProposal(uint64)void"] | AkitaDaoArgs["tuple"]["executeProposal(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `deleteProposalVotes(uint64,address[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        deleteProposalVotes: (params: CallParams<AkitaDaoArgs["obj"]["deleteProposalVotes(uint64,address[])void"] | AkitaDaoArgs["tuple"]["deleteProposalVotes(uint64,address[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `setupCost()uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        setupCost: (params?: CallParams<AkitaDaoArgs["obj"]["setupCost()uint64"] | AkitaDaoArgs["tuple"]["setupCost()uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        proposalCost: (params: CallParams<AkitaDaoArgs["obj"]["proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)"] | AkitaDaoArgs["tuple"]["proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        getProposal: (params: CallParams<AkitaDaoArgs["obj"]["getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])"] | AkitaDaoArgs["tuple"]["getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `mustGetExecution(byte[32])(uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        mustGetExecution: (params: CallParams<AkitaDaoArgs["obj"]["mustGetExecution(byte[32])(uint64,uint64)"] | AkitaDaoArgs["tuple"]["mustGetExecution(byte[32])(uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `opUp()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        opUp: (params?: CallParams<AkitaDaoArgs["obj"]["opUp()void"] | AkitaDaoArgs["tuple"]["opUp()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
    };
    /**
     * Create transactions for the current app
     */
    readonly createTransaction: {
        /**
         * Gets available update methods
         */
        update: {
            /**
             * Updates an existing instance of the AkitaDAO smart contract using the `update(string)void` ABI method.
             *
            *
            The Akita DAO contract supports its own upgrade via a secure, auditable process. Here's a step-by-step trace of how a self-upgrade is executed:
            
            1. Proposal Creation:
              - A member submits a proposal to upgrade the DAO by including a ProposalAction of type `UpgradeApp`.
              - This proposal references the ARC58 contract and specifies the required upgrade parameters, such as the new application code and any associated execution keys.
            
            2. Proposal Approval:
              - The DAO community votes on the proposal. If it receives sufficient approvals as defined in the proposals settings, its status changes to `Approved`.
            
            3. Execution Initiation:
              - Upon approval, the DAO creates an execution entry in the ARC58 contract using the parameters from the upgrade proposal.
              - This sets up the conditions under which an upgrade may be performed, such as locking execution to a valid round interval and binding it to a unique execution key (via the transaction lease).
            
            4. Upgrade Execution:
              - A transaction group is submitted where the ARC58 account (or an authorized delegate) triggers the actual `update` method on the DAO contract.
              - The `update` method receives the `proposalID` and index of the upgrade action.
              - The DAO contract performs the following validation checks before actually permitting the upgrade:
                  a. Confirms the referenced proposal exists and has status `Approved`.
                  b. Ensures the action type matches `UpgradeApp`.
                  c. Verifies the current app ID matches the proposals intended target.
                  d. Ensures the transaction lease matches the authorized execution key from the proposal.
                  e. Validates that the group context (via groupId and round) satisfies execution constraintse.g., only the specified group may proceed and only within a permitted round window.
              - Only if all conditions are satisfied is the application update allowed to continue.
            
            This architecture ensures upgrades are strictly governed, requiring DAO consensus, group-based transaction atomicity, and explicit validation checks at execution time.
      
             *
             * @param params The params for the smart contract call
             * @returns The update transaction
             */
            update: (params: CallParams<AkitaDaoArgs["obj"]["update(string)void"] | AkitaDaoArgs["tuple"]["update(string)void"]> & AppClientCompilationParams) => Promise<{
                transactions: Transaction[];
                methodCalls: Map<number, import("algosdk").ABIMethod>;
                signers: Map<number, TransactionSigner>;
            }>;
        };
        /**
         * Makes a clear_state call to an existing instance of the AkitaDAO smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams>) => Promise<Transaction>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `setup(string)uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        setup: (params: CallParams<AkitaDaoArgs["obj"]["setup(string)uint64"] | AkitaDaoArgs["tuple"]["setup(string)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `partiallyInitialize()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        partiallyInitialize: (params?: CallParams<AkitaDaoArgs["obj"]["partiallyInitialize()void"] | AkitaDaoArgs["tuple"]["partiallyInitialize()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `initialize()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        initialize: (params?: CallParams<AkitaDaoArgs["obj"]["initialize()void"] | AkitaDaoArgs["tuple"]["initialize()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `newProposal(pay,byte[36],(uint8,byte[])[])uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        newProposal: (params: CallParams<AkitaDaoArgs["obj"]["newProposal(pay,byte[36],(uint8,byte[])[])uint64"] | AkitaDaoArgs["tuple"]["newProposal(pay,byte[36],(uint8,byte[])[])uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `editProposal(uint64,byte[36],(uint8,byte[])[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        editProposal: (params: CallParams<AkitaDaoArgs["obj"]["editProposal(uint64,byte[36],(uint8,byte[])[])void"] | AkitaDaoArgs["tuple"]["editProposal(uint64,byte[36],(uint8,byte[])[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        editProposalWithPayment: (params: CallParams<AkitaDaoArgs["obj"]["editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void"] | AkitaDaoArgs["tuple"]["editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `deleteProposal(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        deleteProposal: (params: CallParams<AkitaDaoArgs["obj"]["deleteProposal(uint64)void"] | AkitaDaoArgs["tuple"]["deleteProposal(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `submitProposal(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        submitProposal: (params: CallParams<AkitaDaoArgs["obj"]["submitProposal(uint64)void"] | AkitaDaoArgs["tuple"]["submitProposal(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `voteProposal(pay,uint64,uint8)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        voteProposal: (params: CallParams<AkitaDaoArgs["obj"]["voteProposal(pay,uint64,uint8)void"] | AkitaDaoArgs["tuple"]["voteProposal(pay,uint64,uint8)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `finalizeProposal(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        finalizeProposal: (params: CallParams<AkitaDaoArgs["obj"]["finalizeProposal(uint64)void"] | AkitaDaoArgs["tuple"]["finalizeProposal(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `executeProposal(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        executeProposal: (params: CallParams<AkitaDaoArgs["obj"]["executeProposal(uint64)void"] | AkitaDaoArgs["tuple"]["executeProposal(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `deleteProposalVotes(uint64,address[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        deleteProposalVotes: (params: CallParams<AkitaDaoArgs["obj"]["deleteProposalVotes(uint64,address[])void"] | AkitaDaoArgs["tuple"]["deleteProposalVotes(uint64,address[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `setupCost()uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        setupCost: (params?: CallParams<AkitaDaoArgs["obj"]["setupCost()uint64"] | AkitaDaoArgs["tuple"]["setupCost()uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        proposalCost: (params: CallParams<AkitaDaoArgs["obj"]["proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)"] | AkitaDaoArgs["tuple"]["proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        getProposal: (params: CallParams<AkitaDaoArgs["obj"]["getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])"] | AkitaDaoArgs["tuple"]["getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `mustGetExecution(byte[32])(uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        mustGetExecution: (params: CallParams<AkitaDaoArgs["obj"]["mustGetExecution(byte[32])(uint64,uint64)"] | AkitaDaoArgs["tuple"]["mustGetExecution(byte[32])(uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `opUp()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        opUp: (params?: CallParams<AkitaDaoArgs["obj"]["opUp()void"] | AkitaDaoArgs["tuple"]["opUp()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
    };
    /**
     * Send calls to the current app
     */
    readonly send: {
        /**
         * Gets available update methods
         */
        update: {
            /**
             * Updates an existing instance of the AkitaDAO smart contract using the `update(string)void` ABI method.
             *
            *
            The Akita DAO contract supports its own upgrade via a secure, auditable process. Here's a step-by-step trace of how a self-upgrade is executed:
            
            1. Proposal Creation:
              - A member submits a proposal to upgrade the DAO by including a ProposalAction of type `UpgradeApp`.
              - This proposal references the ARC58 contract and specifies the required upgrade parameters, such as the new application code and any associated execution keys.
            
            2. Proposal Approval:
              - The DAO community votes on the proposal. If it receives sufficient approvals as defined in the proposals settings, its status changes to `Approved`.
            
            3. Execution Initiation:
              - Upon approval, the DAO creates an execution entry in the ARC58 contract using the parameters from the upgrade proposal.
              - This sets up the conditions under which an upgrade may be performed, such as locking execution to a valid round interval and binding it to a unique execution key (via the transaction lease).
            
            4. Upgrade Execution:
              - A transaction group is submitted where the ARC58 account (or an authorized delegate) triggers the actual `update` method on the DAO contract.
              - The `update` method receives the `proposalID` and index of the upgrade action.
              - The DAO contract performs the following validation checks before actually permitting the upgrade:
                  a. Confirms the referenced proposal exists and has status `Approved`.
                  b. Ensures the action type matches `UpgradeApp`.
                  c. Verifies the current app ID matches the proposals intended target.
                  d. Ensures the transaction lease matches the authorized execution key from the proposal.
                  e. Validates that the group context (via groupId and round) satisfies execution constraintse.g., only the specified group may proceed and only within a permitted round window.
              - Only if all conditions are satisfied is the application update allowed to continue.
            
            This architecture ensures upgrades are strictly governed, requiring DAO consensus, group-based transaction atomicity, and explicit validation checks at execution time.
      
             *
             * @param params The params for the smart contract call
             * @returns The update result
             */
            update: (params: CallParams<AkitaDaoArgs["obj"]["update(string)void"] | AkitaDaoArgs["tuple"]["update(string)void"]> & AppClientCompilationParams & SendParams) => Promise<{
                return: (undefined | AkitaDaoReturns["update(string)void"]);
                compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                groupId: string;
                txIds: string[];
                returns?: ABIReturn[] | undefined;
                confirmations: modelsv2.PendingTransactionResponse[];
                transactions: Transaction[];
                confirmation: modelsv2.PendingTransactionResponse;
                transaction: Transaction;
            }>;
        };
        /**
         * Makes a clear_state call to an existing instance of the AkitaDAO smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => Promise<{
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            return?: ABIReturn | undefined;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `setup(string)uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        setup: (params: CallParams<AkitaDaoArgs["obj"]["setup(string)uint64"] | AkitaDaoArgs["tuple"]["setup(string)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoReturns["setup(string)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `partiallyInitialize()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        partiallyInitialize: (params?: CallParams<AkitaDaoArgs["obj"]["partiallyInitialize()void"] | AkitaDaoArgs["tuple"]["partiallyInitialize()void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoReturns["partiallyInitialize()void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `initialize()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        initialize: (params?: CallParams<AkitaDaoArgs["obj"]["initialize()void"] | AkitaDaoArgs["tuple"]["initialize()void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoReturns["initialize()void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `newProposal(pay,byte[36],(uint8,byte[])[])uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        newProposal: (params: CallParams<AkitaDaoArgs["obj"]["newProposal(pay,byte[36],(uint8,byte[])[])uint64"] | AkitaDaoArgs["tuple"]["newProposal(pay,byte[36],(uint8,byte[])[])uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoReturns["newProposal(pay,byte[36],(uint8,byte[])[])uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `editProposal(uint64,byte[36],(uint8,byte[])[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        editProposal: (params: CallParams<AkitaDaoArgs["obj"]["editProposal(uint64,byte[36],(uint8,byte[])[])void"] | AkitaDaoArgs["tuple"]["editProposal(uint64,byte[36],(uint8,byte[])[])void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoReturns["editProposal(uint64,byte[36],(uint8,byte[])[])void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        editProposalWithPayment: (params: CallParams<AkitaDaoArgs["obj"]["editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void"] | AkitaDaoArgs["tuple"]["editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoReturns["editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `deleteProposal(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        deleteProposal: (params: CallParams<AkitaDaoArgs["obj"]["deleteProposal(uint64)void"] | AkitaDaoArgs["tuple"]["deleteProposal(uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoReturns["deleteProposal(uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `submitProposal(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        submitProposal: (params: CallParams<AkitaDaoArgs["obj"]["submitProposal(uint64)void"] | AkitaDaoArgs["tuple"]["submitProposal(uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoReturns["submitProposal(uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `voteProposal(pay,uint64,uint8)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        voteProposal: (params: CallParams<AkitaDaoArgs["obj"]["voteProposal(pay,uint64,uint8)void"] | AkitaDaoArgs["tuple"]["voteProposal(pay,uint64,uint8)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoReturns["voteProposal(pay,uint64,uint8)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `finalizeProposal(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        finalizeProposal: (params: CallParams<AkitaDaoArgs["obj"]["finalizeProposal(uint64)void"] | AkitaDaoArgs["tuple"]["finalizeProposal(uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoReturns["finalizeProposal(uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `executeProposal(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        executeProposal: (params: CallParams<AkitaDaoArgs["obj"]["executeProposal(uint64)void"] | AkitaDaoArgs["tuple"]["executeProposal(uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoReturns["executeProposal(uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `deleteProposalVotes(uint64,address[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        deleteProposalVotes: (params: CallParams<AkitaDaoArgs["obj"]["deleteProposalVotes(uint64,address[])void"] | AkitaDaoArgs["tuple"]["deleteProposalVotes(uint64,address[])void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoReturns["deleteProposalVotes(uint64,address[])void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `setupCost()uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        setupCost: (params?: CallParams<AkitaDaoArgs["obj"]["setupCost()uint64"] | AkitaDaoArgs["tuple"]["setupCost()uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoReturns["setupCost()uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        proposalCost: (params: CallParams<AkitaDaoArgs["obj"]["proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)"] | AkitaDaoArgs["tuple"]["proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoReturns["proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        getProposal: (params: CallParams<AkitaDaoArgs["obj"]["getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])"] | AkitaDaoArgs["tuple"]["getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoReturns["getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `mustGetExecution(byte[32])(uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        mustGetExecution: (params: CallParams<AkitaDaoArgs["obj"]["mustGetExecution(byte[32])(uint64,uint64)"] | AkitaDaoArgs["tuple"]["mustGetExecution(byte[32])(uint64,uint64)"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoReturns["mustGetExecution(byte[32])(uint64,uint64)"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAO smart contract using the `opUp()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        opUp: (params?: CallParams<AkitaDaoArgs["obj"]["opUp()void"] | AkitaDaoArgs["tuple"]["opUp()void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoReturns["opUp()void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
    };
    /**
     * Clone this app client with different params
     *
     * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
     * @returns A new app client with the altered params
     */
    clone(params: CloneAppClientParams): AkitaDaoClient;
    /**
     * Makes a readonly (simulated) call to the AkitaDAO smart contract using the `setupCost()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setupCost(params?: CallParams<AkitaDaoArgs['obj']['setupCost()uint64'] | AkitaDaoArgs['tuple']['setupCost()uint64']>): Promise<bigint>;
    /**
     * Makes a readonly (simulated) call to the AkitaDAO smart contract using the `proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    proposalCost(params: CallParams<AkitaDaoArgs['obj']['proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | AkitaDaoArgs['tuple']['proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)']>): Promise<ProposalCostInfo>;
    /**
     * Makes a readonly (simulated) call to the AkitaDAO smart contract using the `getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getProposal(params: CallParams<AkitaDaoArgs['obj']['getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])'] | AkitaDaoArgs['tuple']['getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])']>): Promise<ProposalDetails>;
    /**
     * Makes a readonly (simulated) call to the AkitaDAO smart contract using the `mustGetExecution(byte[32])(uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mustGetExecution(params: CallParams<AkitaDaoArgs['obj']['mustGetExecution(byte[32])(uint64,uint64)'] | AkitaDaoArgs['tuple']['mustGetExecution(byte[32])(uint64,uint64)']>): Promise<ExecutionMetadata>;
    /**
     * Methods to access state for the current AkitaDAO app
     */
    state: {
        /**
         * Methods to access global state for the current AkitaDAO app
         */
        global: {
            /**
             * Get all current keyed values from global state
             */
            getAll: () => Promise<Partial<Expand<GlobalKeysState>>>;
            /**
             * Get the current value of the state key in global state
             */
            state: () => Promise<number | undefined>;
            /**
             * Get the current value of the version key in global state
             */
            version: () => Promise<string | undefined>;
            /**
             * Get the current value of the wallet key in global state
             */
            wallet: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the proposalActionLimit key in global state
             */
            proposalActionLimit: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the contentPolicy key in global state
             */
            contentPolicy: () => Promise<BinaryState>;
            /**
             * Get the current value of the minRewardsImpact key in global state
             */
            minRewardsImpact: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the akitaAppList key in global state
             */
            akitaAppList: () => Promise<AkitaAppList | undefined>;
            /**
             * Get the current value of the akitaSocialAppList key in global state
             */
            akitaSocialAppList: () => Promise<AkitaSocialAppList | undefined>;
            /**
             * Get the current value of the pluginAppList key in global state
             */
            pluginAppList: () => Promise<PluginAppList | undefined>;
            /**
             * Get the current value of the otherAppList key in global state
             */
            otherAppList: () => Promise<OtherAppList | undefined>;
            /**
             * Get the current value of the walletFees key in global state
             */
            walletFees: () => Promise<WalletFees | undefined>;
            /**
             * Get the current value of the socialFees key in global state
             */
            socialFees: () => Promise<SocialFees | undefined>;
            /**
             * Get the current value of the stakingFees key in global state
             */
            stakingFees: () => Promise<StakingFees | undefined>;
            /**
             * Get the current value of the subscriptionFees key in global state
             */
            subscriptionFees: () => Promise<SubscriptionFees | undefined>;
            /**
             * Get the current value of the nftFees key in global state
             */
            nftFees: () => Promise<NftFees | undefined>;
            /**
             * Get the current value of the swapFees key in global state
             */
            swapFees: () => Promise<SwapFees | undefined>;
            /**
             * Get the current value of the akitaAssets key in global state
             */
            akitaAssets: () => Promise<AkitaAssets | undefined>;
            /**
             * Get the current value of the revenueSplits key in global state
             */
            revenueSplits: () => Promise<[[bigint, string], number, bigint][] | undefined>;
            /**
             * Get the current value of the upgradeAppProposalSettings key in global state
             */
            upgradeAppProposalSettings: () => Promise<ProposalSettings | undefined>;
            /**
             * Get the current value of the addPluginProposalSettings key in global state
             */
            addPluginProposalSettings: () => Promise<ProposalSettings | undefined>;
            /**
             * Get the current value of the removePluginProposalSettings key in global state
             */
            removePluginProposalSettings: () => Promise<ProposalSettings | undefined>;
            /**
             * Get the current value of the removeExecutePluginProposalSettings key in global state
             */
            removeExecutePluginProposalSettings: () => Promise<ProposalSettings | undefined>;
            /**
             * Get the current value of the addAllowancesProposalSettings key in global state
             */
            addAllowancesProposalSettings: () => Promise<ProposalSettings | undefined>;
            /**
             * Get the current value of the removeAllowancesProposalSettings key in global state
             */
            removeAllowancesProposalSettings: () => Promise<ProposalSettings | undefined>;
            /**
             * Get the current value of the newEscrowProposalSettings key in global state
             */
            newEscrowProposalSettings: () => Promise<ProposalSettings | undefined>;
            /**
             * Get the current value of the toggleEscrowLockProposalSettings key in global state
             */
            toggleEscrowLockProposalSettings: () => Promise<ProposalSettings | undefined>;
            /**
             * Get the current value of the updateFieldsProposalSettings key in global state
             */
            updateFieldsProposalSettings: () => Promise<ProposalSettings | undefined>;
            /**
             * Get the current value of the proposalID key in global state
             */
            proposalId: () => Promise<bigint | undefined>;
        };
        /**
         * Methods to access box state for the current AkitaDAO app
         */
        box: {
            /**
             * Get all current keyed values from box state
             */
            getAll: () => Promise<Partial<Expand<BoxKeysState>>>;
            /**
             * Get values from the plugins map in box state
             */
            plugins: {
                /**
                 * Get all current values of the plugins map in box state
                 */
                getMap: () => Promise<Map<DaoPluginKey, ProposalSettings>>;
                /**
                 * Get a current value of the plugins map by key from box state
                 */
                value: (key: DaoPluginKey) => Promise<ProposalSettings | undefined>;
            };
            /**
             * Get values from the proposals map in box state
             */
            proposals: {
                /**
                 * Get all current values of the proposals map in box state
                 */
                getMap: () => Promise<Map<bigint, ProposalDetails>>;
                /**
                 * Get a current value of the proposals map by key from box state
                 */
                value: (key: bigint | number) => Promise<ProposalDetails | undefined>;
            };
            /**
             * Get values from the proposalVotes map in box state
             */
            proposalVotes: {
                /**
                 * Get all current values of the proposalVotes map in box state
                 */
                getMap: () => Promise<Map<ProposalVoteKey, ProposalVoteInfo>>;
                /**
                 * Get a current value of the proposalVotes map by key from box state
                 */
                value: (key: ProposalVoteKey) => Promise<ProposalVoteInfo | undefined>;
            };
            /**
             * Get values from the executions map in box state
             */
            executions: {
                /**
                 * Get all current values of the executions map in box state
                 */
                getMap: () => Promise<Map<Uint8Array, ExecutionMetadata>>;
                /**
                 * Get a current value of the executions map by key from box state
                 */
                value: (key: Uint8Array | string) => Promise<ExecutionMetadata | undefined>;
            };
        };
    };
    newGroup(): AkitaDaoComposer;
}
export type AkitaDaoComposer<TReturns extends [...any[]] = []> = {
    /**
     * Calls the setup(string)uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    setup(params?: CallParams<AkitaDaoArgs['obj']['setup(string)uint64'] | AkitaDaoArgs['tuple']['setup(string)uint64']>): AkitaDaoComposer<[...TReturns, AkitaDaoReturns['setup(string)uint64'] | undefined]>;
    /**
     * Calls the partiallyInitialize()void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    partiallyInitialize(params?: CallParams<AkitaDaoArgs['obj']['partiallyInitialize()void'] | AkitaDaoArgs['tuple']['partiallyInitialize()void']>): AkitaDaoComposer<[...TReturns, AkitaDaoReturns['partiallyInitialize()void'] | undefined]>;
    /**
     * Calls the initialize()void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    initialize(params?: CallParams<AkitaDaoArgs['obj']['initialize()void'] | AkitaDaoArgs['tuple']['initialize()void']>): AkitaDaoComposer<[...TReturns, AkitaDaoReturns['initialize()void'] | undefined]>;
    /**
     * Calls the newProposal(pay,byte[36],(uint8,byte[])[])uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    newProposal(params?: CallParams<AkitaDaoArgs['obj']['newProposal(pay,byte[36],(uint8,byte[])[])uint64'] | AkitaDaoArgs['tuple']['newProposal(pay,byte[36],(uint8,byte[])[])uint64']>): AkitaDaoComposer<[...TReturns, AkitaDaoReturns['newProposal(pay,byte[36],(uint8,byte[])[])uint64'] | undefined]>;
    /**
     * Calls the editProposal(uint64,byte[36],(uint8,byte[])[])void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    editProposal(params?: CallParams<AkitaDaoArgs['obj']['editProposal(uint64,byte[36],(uint8,byte[])[])void'] | AkitaDaoArgs['tuple']['editProposal(uint64,byte[36],(uint8,byte[])[])void']>): AkitaDaoComposer<[...TReturns, AkitaDaoReturns['editProposal(uint64,byte[36],(uint8,byte[])[])void'] | undefined]>;
    /**
     * Calls the editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    editProposalWithPayment(params?: CallParams<AkitaDaoArgs['obj']['editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void'] | AkitaDaoArgs['tuple']['editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void']>): AkitaDaoComposer<[...TReturns, AkitaDaoReturns['editProposalWithPayment(pay,uint64,byte[36],(uint8,byte[])[])void'] | undefined]>;
    /**
     * Calls the deleteProposal(uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    deleteProposal(params?: CallParams<AkitaDaoArgs['obj']['deleteProposal(uint64)void'] | AkitaDaoArgs['tuple']['deleteProposal(uint64)void']>): AkitaDaoComposer<[...TReturns, AkitaDaoReturns['deleteProposal(uint64)void'] | undefined]>;
    /**
     * Calls the submitProposal(uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    submitProposal(params?: CallParams<AkitaDaoArgs['obj']['submitProposal(uint64)void'] | AkitaDaoArgs['tuple']['submitProposal(uint64)void']>): AkitaDaoComposer<[...TReturns, AkitaDaoReturns['submitProposal(uint64)void'] | undefined]>;
    /**
     * Calls the voteProposal(pay,uint64,uint8)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    voteProposal(params?: CallParams<AkitaDaoArgs['obj']['voteProposal(pay,uint64,uint8)void'] | AkitaDaoArgs['tuple']['voteProposal(pay,uint64,uint8)void']>): AkitaDaoComposer<[...TReturns, AkitaDaoReturns['voteProposal(pay,uint64,uint8)void'] | undefined]>;
    /**
     * Calls the finalizeProposal(uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    finalizeProposal(params?: CallParams<AkitaDaoArgs['obj']['finalizeProposal(uint64)void'] | AkitaDaoArgs['tuple']['finalizeProposal(uint64)void']>): AkitaDaoComposer<[...TReturns, AkitaDaoReturns['finalizeProposal(uint64)void'] | undefined]>;
    /**
     * Calls the executeProposal(uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    executeProposal(params?: CallParams<AkitaDaoArgs['obj']['executeProposal(uint64)void'] | AkitaDaoArgs['tuple']['executeProposal(uint64)void']>): AkitaDaoComposer<[...TReturns, AkitaDaoReturns['executeProposal(uint64)void'] | undefined]>;
    /**
     * Calls the deleteProposalVotes(uint64,address[])void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    deleteProposalVotes(params?: CallParams<AkitaDaoArgs['obj']['deleteProposalVotes(uint64,address[])void'] | AkitaDaoArgs['tuple']['deleteProposalVotes(uint64,address[])void']>): AkitaDaoComposer<[...TReturns, AkitaDaoReturns['deleteProposalVotes(uint64,address[])void'] | undefined]>;
    /**
     * Calls the setupCost()uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    setupCost(params?: CallParams<AkitaDaoArgs['obj']['setupCost()uint64'] | AkitaDaoArgs['tuple']['setupCost()uint64']>): AkitaDaoComposer<[...TReturns, AkitaDaoReturns['setupCost()uint64'] | undefined]>;
    /**
     * Calls the proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    proposalCost(params?: CallParams<AkitaDaoArgs['obj']['proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | AkitaDaoArgs['tuple']['proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)']>): AkitaDaoComposer<[...TReturns, AkitaDaoReturns['proposalCost((uint8,byte[])[])(uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | undefined]>;
    /**
     * Calls the getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[]) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    getProposal(params?: CallParams<AkitaDaoArgs['obj']['getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])'] | AkitaDaoArgs['tuple']['getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])']>): AkitaDaoComposer<[...TReturns, AkitaDaoReturns['getProposal(uint64)(uint8,byte[36],(uint64,uint64,uint64),address,uint64,uint64,uint64,(uint8,byte[])[])'] | undefined]>;
    /**
     * Calls the mustGetExecution(byte[32])(uint64,uint64) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    mustGetExecution(params?: CallParams<AkitaDaoArgs['obj']['mustGetExecution(byte[32])(uint64,uint64)'] | AkitaDaoArgs['tuple']['mustGetExecution(byte[32])(uint64,uint64)']>): AkitaDaoComposer<[...TReturns, AkitaDaoReturns['mustGetExecution(byte[32])(uint64,uint64)'] | undefined]>;
    /**
     * Calls the opUp()void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    opUp(params?: CallParams<AkitaDaoArgs['obj']['opUp()void'] | AkitaDaoArgs['tuple']['opUp()void']>): AkitaDaoComposer<[...TReturns, AkitaDaoReturns['opUp()void'] | undefined]>;
    /**
     * Gets available update methods
     */
    readonly update: {
        /**
         * Updates an existing instance of the AkitaDAO smart contract using the update(string)void ABI method.
         *
         * @param args The arguments for the smart contract call
         * @param params Any additional parameters for the call
         * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
         */
        update(params?: CallParams<AkitaDaoArgs['obj']['update(string)void'] | AkitaDaoArgs['tuple']['update(string)void']>): AkitaDaoComposer<[...TReturns, AkitaDaoReturns['update(string)void'] | undefined]>;
    };
    /**
     * Makes a clear_state call to an existing instance of the AkitaDAO smart contract.
     *
     * @param args The arguments for the bare call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    clearState(params?: AppClientBareCallParams): AkitaDaoComposer<[...TReturns, undefined]>;
    /**
     * Adds a transaction to the composer
     *
     * @param txn A transaction to add to the transaction group
     * @param signer The optional signer to use when signing this transaction.
     */
    addTransaction(txn: Transaction, signer?: TransactionSigner): AkitaDaoComposer<TReturns>;
    /**
     * Returns the underlying AtomicTransactionComposer instance
     */
    composer(): Promise<TransactionComposer>;
    /**
     * Simulates the transaction group and returns the result
     */
    simulate(): Promise<AkitaDaoComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    simulate(options: SkipSignaturesSimulateOptions): Promise<AkitaDaoComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    simulate(options: RawSimulateOptions): Promise<AkitaDaoComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    /**
     * Sends the transaction group to the network and returns the results
     */
    send(params?: SendParams): Promise<AkitaDaoComposerResults<TReturns>>;
};
export type AkitaDaoComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
    returns: TReturns;
}>;
