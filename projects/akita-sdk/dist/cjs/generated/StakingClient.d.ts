/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client';
import { ABIReturn } from '@algorandfoundation/algokit-utils/types/app';
import { Arc56Contract } from '@algorandfoundation/algokit-utils/types/app-arc56';
import { AppClient as _AppClient, AppClientMethodCallParams, AppClientParams, AppClientBareCallParams, CallOnComplete, AppClientCompilationParams, ResolveAppClientByCreatorAndName, ResolveAppClientByNetwork, CloneAppClientParams } from '@algorandfoundation/algokit-utils/types/app-client';
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory';
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer';
import { SendParams, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction';
import { Address, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk';
export declare const APP_SPEC: Arc56Contract;
/**
 * A state record containing binary data
 */
export interface BinaryState {
    /**
     * Gets the state value as a Uint8Array
     */
    asByteArray(): Uint8Array | undefined;
    /**
     * Gets the state value as a string
     */
    asString(): string | undefined;
}
/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R ? (...args: Expand<A>) => Expand<R> : T extends infer O ? {
    [K in keyof O]: O[K];
} : never;
export type Escrow = {
    hard: bigint;
    lock: bigint;
};
/**
 * Converts the ABI tuple representation of a Escrow to the struct representation
 */
export declare function EscrowFromTuple(abiTuple: [bigint, bigint]): Escrow;
export type HeartbeatKey = {
    address: string;
    asset: bigint;
};
/**
 * Converts the ABI tuple representation of a HeartbeatKey to the struct representation
 */
export declare function HeartbeatKeyFromTuple(abiTuple: [string, bigint]): HeartbeatKey;
export type Stake = {
    amount: bigint;
    lastUpdate: bigint;
    expiration: bigint;
};
/**
 * Converts the ABI tuple representation of a Stake to the struct representation
 */
export declare function StakeFromTuple(abiTuple: [bigint, bigint, bigint]): Stake;
export type StakeCheck = {
    valid: boolean;
    balance: bigint;
};
/**
 * Converts the ABI tuple representation of a StakeCheck to the struct representation
 */
export declare function StakeCheckFromTuple(abiTuple: [boolean, bigint]): StakeCheck;
export type StakeInfo = {
    asset: bigint;
    type: number;
};
/**
 * Converts the ABI tuple representation of a StakeInfo to the struct representation
 */
export declare function StakeInfoFromTuple(abiTuple: [bigint, number]): StakeInfo;
export type StakeKey = {
    address: string;
    asset: bigint;
    type: number;
};
/**
 * Converts the ABI tuple representation of a StakeKey to the struct representation
 */
export declare function StakeKeyFromTuple(abiTuple: [string, bigint, number]): StakeKey;
export type TotalsInfo = {
    locked: bigint;
    escrowed: bigint;
};
/**
 * Converts the ABI tuple representation of a TotalsInfo to the struct representation
 */
export declare function TotalsInfoFromTuple(abiTuple: [bigint, bigint]): TotalsInfo;
/**
 * The argument types for the Staking contract
 */
export type StakingArgs = {
    /**
     * The object representation of the arguments for each method
     */
    obj: {
        'create(string,uint64)void': {
            version: string;
            akitaDao: bigint | number;
        };
        'init()void': Record<string, never>;
        'optIn(pay,uint64)void': {
            /**
             * The payment transaction
             */
            payment: AppMethodCallTransactionArgument;
            /**
             * The asset to be opted into
             */
            asset: bigint | number;
        };
        'stake(pay,uint8,uint64,uint64)void': {
            payment: AppMethodCallTransactionArgument;
            type: bigint | number;
            amount: bigint | number;
            expiration: bigint | number;
        };
        'stakeAsa(pay,axfer,uint8,uint64,uint64)void': {
            payment: AppMethodCallTransactionArgument;
            assetXfer: AppMethodCallTransactionArgument;
            type: bigint | number;
            amount: bigint | number;
            expiration: bigint | number;
        };
        'withdraw(uint64,uint8)void': {
            asset: bigint | number;
            type: bigint | number;
        };
        'createHeartbeat(address,uint64)void': {
            address: string;
            asset: bigint | number;
        };
        'softCheck(address,uint64)(bool,uint64)': {
            address: string;
            asset: bigint | number;
        };
        'updateSettings(pay,uint64,uint64)void': {
            payment: AppMethodCallTransactionArgument;
            asset: bigint | number;
            value: bigint | number;
        };
        'optInCost()uint64': Record<string, never>;
        'stakeCost(uint64,uint8)uint64': {
            asset: bigint | number;
            type: bigint | number;
        };
        'getTimeLeft(address,uint64)uint64': {
            address: string;
            asset: bigint | number;
        };
        'mustGetTimeLeft(address,uint64)uint64': {
            address: string;
            asset: bigint | number;
        };
        'getInfo(address,(uint64,uint8))(uint64,uint64,uint64)': {
            address: string;
            stake: StakeInfo;
        };
        'mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)': {
            address: string;
            stake: StakeInfo;
        };
        'getEscrowInfo(address,uint64)(uint64,uint64)': {
            address: string;
            asset: bigint | number;
        };
        'getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]': {
            address: string;
            asset: bigint | number;
        };
        'mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]': {
            address: string;
            asset: bigint | number;
        };
        'getHeartbeatAverage(address,uint64,bool)uint64': {
            address: string;
            asset: bigint | number;
            includeEscrowed: boolean;
        };
        'mustGetHeartbeatAverage(address,uint64,bool)uint64': {
            address: string;
            asset: bigint | number;
            includeEscrowed: boolean;
        };
        'getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]': {
            address: string;
            type: bigint | number;
            assets: bigint[] | number[];
        };
        'mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]': {
            address: string;
            type: bigint | number;
            assets: bigint[] | number[];
        };
        'stakeCheck(address,(uint64,uint64)[],uint8,bool)bool': {
            address: string;
            checks: [bigint | number, bigint | number][];
            type: bigint | number;
            includeEscrowed: boolean;
        };
        'getTotals(uint64[])(uint64,uint64)[]': {
            assets: bigint[] | number[];
        };
        'updateAkitaDAO(uint64)void': {
            akitaDao: bigint | number;
        };
        'opUp()void': Record<string, never>;
    };
    /**
     * The tuple representation of the arguments for each method
     */
    tuple: {
        'create(string,uint64)void': [version: string, akitaDao: bigint | number];
        'init()void': [];
        'optIn(pay,uint64)void': [payment: AppMethodCallTransactionArgument, asset: bigint | number];
        'stake(pay,uint8,uint64,uint64)void': [payment: AppMethodCallTransactionArgument, type: bigint | number, amount: bigint | number, expiration: bigint | number];
        'stakeAsa(pay,axfer,uint8,uint64,uint64)void': [payment: AppMethodCallTransactionArgument, assetXfer: AppMethodCallTransactionArgument, type: bigint | number, amount: bigint | number, expiration: bigint | number];
        'withdraw(uint64,uint8)void': [asset: bigint | number, type: bigint | number];
        'createHeartbeat(address,uint64)void': [address: string, asset: bigint | number];
        'softCheck(address,uint64)(bool,uint64)': [address: string, asset: bigint | number];
        'updateSettings(pay,uint64,uint64)void': [payment: AppMethodCallTransactionArgument, asset: bigint | number, value: bigint | number];
        'optInCost()uint64': [];
        'stakeCost(uint64,uint8)uint64': [asset: bigint | number, type: bigint | number];
        'getTimeLeft(address,uint64)uint64': [address: string, asset: bigint | number];
        'mustGetTimeLeft(address,uint64)uint64': [address: string, asset: bigint | number];
        'getInfo(address,(uint64,uint8))(uint64,uint64,uint64)': [address: string, stake: StakeInfo];
        'mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)': [address: string, stake: StakeInfo];
        'getEscrowInfo(address,uint64)(uint64,uint64)': [address: string, asset: bigint | number];
        'getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]': [address: string, asset: bigint | number];
        'mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]': [address: string, asset: bigint | number];
        'getHeartbeatAverage(address,uint64,bool)uint64': [address: string, asset: bigint | number, includeEscrowed: boolean];
        'mustGetHeartbeatAverage(address,uint64,bool)uint64': [address: string, asset: bigint | number, includeEscrowed: boolean];
        'getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]': [address: string, type: bigint | number, assets: bigint[] | number[]];
        'mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]': [address: string, type: bigint | number, assets: bigint[] | number[]];
        'stakeCheck(address,(uint64,uint64)[],uint8,bool)bool': [address: string, checks: [bigint | number, bigint | number][], type: bigint | number, includeEscrowed: boolean];
        'getTotals(uint64[])(uint64,uint64)[]': [assets: bigint[] | number[]];
        'updateAkitaDAO(uint64)void': [akitaDao: bigint | number];
        'opUp()void': [];
    };
};
/**
 * The return type for each method
 */
export type StakingReturns = {
    'create(string,uint64)void': void;
    'init()void': void;
    'optIn(pay,uint64)void': void;
    'stake(pay,uint8,uint64,uint64)void': void;
    'stakeAsa(pay,axfer,uint8,uint64,uint64)void': void;
    'withdraw(uint64,uint8)void': void;
    'createHeartbeat(address,uint64)void': void;
    'softCheck(address,uint64)(bool,uint64)': StakeCheck;
    'updateSettings(pay,uint64,uint64)void': void;
    'optInCost()uint64': bigint;
    'stakeCost(uint64,uint8)uint64': bigint;
    'getTimeLeft(address,uint64)uint64': bigint;
    'mustGetTimeLeft(address,uint64)uint64': bigint;
    'getInfo(address,(uint64,uint8))(uint64,uint64,uint64)': Stake;
    'mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)': Stake;
    'getEscrowInfo(address,uint64)(uint64,uint64)': Escrow;
    'getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]': [[bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint]];
    'mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]': [[bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint]];
    'getHeartbeatAverage(address,uint64,bool)uint64': bigint;
    'mustGetHeartbeatAverage(address,uint64,bool)uint64': bigint;
    'getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]': [bigint, bigint, bigint][];
    'mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]': [bigint, bigint, bigint][];
    'stakeCheck(address,(uint64,uint64)[],uint8,bool)bool': boolean;
    'getTotals(uint64[])(uint64,uint64)[]': [bigint, bigint][];
    'updateAkitaDAO(uint64)void': void;
    'opUp()void': void;
};
/**
 * Defines the types of available calls and state of the Staking smart contract.
 */
export type StakingTypes = {
    /**
     * Maps method signatures / names to their argument and return types.
     */
    methods: Record<'create(string,uint64)void' | 'create', {
        argsObj: StakingArgs['obj']['create(string,uint64)void'];
        argsTuple: StakingArgs['tuple']['create(string,uint64)void'];
        returns: StakingReturns['create(string,uint64)void'];
    }> & Record<'init()void' | 'init', {
        argsObj: StakingArgs['obj']['init()void'];
        argsTuple: StakingArgs['tuple']['init()void'];
        returns: StakingReturns['init()void'];
    }> & Record<'optIn(pay,uint64)void' | 'optIn', {
        argsObj: StakingArgs['obj']['optIn(pay,uint64)void'];
        argsTuple: StakingArgs['tuple']['optIn(pay,uint64)void'];
        returns: StakingReturns['optIn(pay,uint64)void'];
    }> & Record<'stake(pay,uint8,uint64,uint64)void' | 'stake', {
        argsObj: StakingArgs['obj']['stake(pay,uint8,uint64,uint64)void'];
        argsTuple: StakingArgs['tuple']['stake(pay,uint8,uint64,uint64)void'];
        returns: StakingReturns['stake(pay,uint8,uint64,uint64)void'];
    }> & Record<'stakeAsa(pay,axfer,uint8,uint64,uint64)void' | 'stakeAsa', {
        argsObj: StakingArgs['obj']['stakeAsa(pay,axfer,uint8,uint64,uint64)void'];
        argsTuple: StakingArgs['tuple']['stakeAsa(pay,axfer,uint8,uint64,uint64)void'];
        returns: StakingReturns['stakeAsa(pay,axfer,uint8,uint64,uint64)void'];
    }> & Record<'withdraw(uint64,uint8)void' | 'withdraw', {
        argsObj: StakingArgs['obj']['withdraw(uint64,uint8)void'];
        argsTuple: StakingArgs['tuple']['withdraw(uint64,uint8)void'];
        returns: StakingReturns['withdraw(uint64,uint8)void'];
    }> & Record<'createHeartbeat(address,uint64)void' | 'createHeartbeat', {
        argsObj: StakingArgs['obj']['createHeartbeat(address,uint64)void'];
        argsTuple: StakingArgs['tuple']['createHeartbeat(address,uint64)void'];
        returns: StakingReturns['createHeartbeat(address,uint64)void'];
    }> & Record<'softCheck(address,uint64)(bool,uint64)' | 'softCheck', {
        argsObj: StakingArgs['obj']['softCheck(address,uint64)(bool,uint64)'];
        argsTuple: StakingArgs['tuple']['softCheck(address,uint64)(bool,uint64)'];
        returns: StakingReturns['softCheck(address,uint64)(bool,uint64)'];
    }> & Record<'updateSettings(pay,uint64,uint64)void' | 'updateSettings', {
        argsObj: StakingArgs['obj']['updateSettings(pay,uint64,uint64)void'];
        argsTuple: StakingArgs['tuple']['updateSettings(pay,uint64,uint64)void'];
        returns: StakingReturns['updateSettings(pay,uint64,uint64)void'];
    }> & Record<'optInCost()uint64' | 'optInCost', {
        argsObj: StakingArgs['obj']['optInCost()uint64'];
        argsTuple: StakingArgs['tuple']['optInCost()uint64'];
        returns: StakingReturns['optInCost()uint64'];
    }> & Record<'stakeCost(uint64,uint8)uint64' | 'stakeCost', {
        argsObj: StakingArgs['obj']['stakeCost(uint64,uint8)uint64'];
        argsTuple: StakingArgs['tuple']['stakeCost(uint64,uint8)uint64'];
        returns: StakingReturns['stakeCost(uint64,uint8)uint64'];
    }> & Record<'getTimeLeft(address,uint64)uint64' | 'getTimeLeft', {
        argsObj: StakingArgs['obj']['getTimeLeft(address,uint64)uint64'];
        argsTuple: StakingArgs['tuple']['getTimeLeft(address,uint64)uint64'];
        returns: StakingReturns['getTimeLeft(address,uint64)uint64'];
    }> & Record<'mustGetTimeLeft(address,uint64)uint64' | 'mustGetTimeLeft', {
        argsObj: StakingArgs['obj']['mustGetTimeLeft(address,uint64)uint64'];
        argsTuple: StakingArgs['tuple']['mustGetTimeLeft(address,uint64)uint64'];
        returns: StakingReturns['mustGetTimeLeft(address,uint64)uint64'];
    }> & Record<'getInfo(address,(uint64,uint8))(uint64,uint64,uint64)' | 'getInfo', {
        argsObj: StakingArgs['obj']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)'];
        argsTuple: StakingArgs['tuple']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)'];
        returns: StakingReturns['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)'];
    }> & Record<'mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)' | 'mustGetInfo', {
        argsObj: StakingArgs['obj']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)'];
        argsTuple: StakingArgs['tuple']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)'];
        returns: StakingReturns['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)'];
    }> & Record<'getEscrowInfo(address,uint64)(uint64,uint64)' | 'getEscrowInfo', {
        argsObj: StakingArgs['obj']['getEscrowInfo(address,uint64)(uint64,uint64)'];
        argsTuple: StakingArgs['tuple']['getEscrowInfo(address,uint64)(uint64,uint64)'];
        returns: StakingReturns['getEscrowInfo(address,uint64)(uint64,uint64)'];
    }> & Record<'getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]' | 'getHeartbeat', {
        argsObj: StakingArgs['obj']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]'];
        argsTuple: StakingArgs['tuple']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]'];
        returns: StakingReturns['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]'];
    }> & Record<'mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]' | 'mustGetHeartbeat', {
        argsObj: StakingArgs['obj']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]'];
        argsTuple: StakingArgs['tuple']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]'];
        returns: StakingReturns['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]'];
    }> & Record<'getHeartbeatAverage(address,uint64,bool)uint64' | 'getHeartbeatAverage', {
        argsObj: StakingArgs['obj']['getHeartbeatAverage(address,uint64,bool)uint64'];
        argsTuple: StakingArgs['tuple']['getHeartbeatAverage(address,uint64,bool)uint64'];
        returns: StakingReturns['getHeartbeatAverage(address,uint64,bool)uint64'];
    }> & Record<'mustGetHeartbeatAverage(address,uint64,bool)uint64' | 'mustGetHeartbeatAverage', {
        argsObj: StakingArgs['obj']['mustGetHeartbeatAverage(address,uint64,bool)uint64'];
        argsTuple: StakingArgs['tuple']['mustGetHeartbeatAverage(address,uint64,bool)uint64'];
        returns: StakingReturns['mustGetHeartbeatAverage(address,uint64,bool)uint64'];
    }> & Record<'getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]' | 'getInfoList', {
        argsObj: StakingArgs['obj']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'];
        argsTuple: StakingArgs['tuple']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'];
        returns: StakingReturns['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'];
    }> & Record<'mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]' | 'mustGetInfoList', {
        argsObj: StakingArgs['obj']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'];
        argsTuple: StakingArgs['tuple']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'];
        returns: StakingReturns['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'];
    }> & Record<'stakeCheck(address,(uint64,uint64)[],uint8,bool)bool' | 'stakeCheck', {
        argsObj: StakingArgs['obj']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool'];
        argsTuple: StakingArgs['tuple']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool'];
        returns: StakingReturns['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool'];
    }> & Record<'getTotals(uint64[])(uint64,uint64)[]' | 'getTotals', {
        argsObj: StakingArgs['obj']['getTotals(uint64[])(uint64,uint64)[]'];
        argsTuple: StakingArgs['tuple']['getTotals(uint64[])(uint64,uint64)[]'];
        returns: StakingReturns['getTotals(uint64[])(uint64,uint64)[]'];
    }> & Record<'updateAkitaDAO(uint64)void' | 'updateAkitaDAO', {
        argsObj: StakingArgs['obj']['updateAkitaDAO(uint64)void'];
        argsTuple: StakingArgs['tuple']['updateAkitaDAO(uint64)void'];
        returns: StakingReturns['updateAkitaDAO(uint64)void'];
    }> & Record<'opUp()void' | 'opUp', {
        argsObj: StakingArgs['obj']['opUp()void'];
        argsTuple: StakingArgs['tuple']['opUp()void'];
        returns: StakingReturns['opUp()void'];
    }>;
    /**
     * Defines the shape of the state of the application.
     */
    state: {
        global: {
            keys: {
                /**
                 * The address that is allowed to call the 'beat' method to create heartbeat records
                 */
                heartbeatManagerAddress: string;
                /**
                 * the current version of the contract
                 */
                version: string;
                /**
                 * the app ID of the Akita DAO
                 */
                akitaDao: bigint;
            };
            maps: {};
        };
        box: {
            keys: {};
            maps: {
                stakes: Map<StakeKey, Stake>;
                heartbeats: Map<HeartbeatKey, [[bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint]]>;
                totals: Map<bigint | number, TotalsInfo>;
                settings: Map<bigint | number, bigint>;
            };
        };
    };
};
/**
 * Defines the possible abi call signatures.
 */
export type StakingSignatures = keyof StakingTypes['methods'];
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type StakingNonVoidMethodSignatures = keyof StakingTypes['methods'] extends infer T ? T extends keyof StakingTypes['methods'] ? MethodReturn<T> extends void ? never : T : never : never;
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> & {
    /** The args for the ABI method call, either as an ordered array or an object */
    args: Expand<TArgs>;
}>;
/**
 * Maps a method signature from the Staking smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends StakingSignatures> = StakingTypes['methods'][TSignature]['argsObj' | 'argsTuple'];
/**
 * Maps a method signature from the Staking smart contract to the method's return type
 */
export type MethodReturn<TSignature extends StakingSignatures> = StakingTypes['methods'][TSignature]['returns'];
/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = StakingTypes['state']['global']['keys'];
/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = StakingTypes['state']['box']['keys'];
/**
 * Defines supported create method params for this smart contract
 */
export type StakingCreateCallParams = Expand<CallParams<StakingArgs['obj']['create(string,uint64)void'] | StakingArgs['tuple']['create(string,uint64)void']> & {
    method: 'create';
} & {
    onComplete?: OnApplicationComplete.NoOpOC;
} & CreateSchema> | Expand<CallParams<StakingArgs['obj']['create(string,uint64)void'] | StakingArgs['tuple']['create(string,uint64)void']> & {
    method: 'create(string,uint64)void';
} & {
    onComplete?: OnApplicationComplete.NoOpOC;
} & CreateSchema>;
/**
 * Defines arguments required for the deploy method.
 */
export type StakingDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
    /**
     * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
     */
    createParams?: StakingCreateCallParams;
}>;
/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the Staking smart contract
 */
export declare abstract class StakingParamsFactory {
    /**
     * Gets available create ABI call param factories
     */
    static get create(): {
        _resolveByMethod<TParams extends StakingCreateCallParams & {
            method: string;
        }>(params: TParams): {
            maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            signer?: (TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount) | undefined;
            rekeyTo?: (string | Address) | undefined;
            note?: (Uint8Array | string) | undefined;
            lease?: (Uint8Array | string) | undefined;
            staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            validityWindow?: number | bigint | undefined;
            firstValidRound?: bigint | undefined;
            lastValidRound?: bigint | undefined;
            onComplete?: OnApplicationComplete | undefined;
            accountReferences?: (string | Address)[] | undefined;
            appReferences?: bigint[] | undefined;
            assetReferences?: bigint[] | undefined;
            boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference | import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier)[] | undefined;
            sender?: (Address | string) | undefined;
            method: string;
            args?: (import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | AppMethodCallTransactionArgument | undefined)[] | undefined;
        } & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        };
        /**
         * Constructs create ABI call params for the Staking smart contract using the create(string,uint64)void ABI method
         *
         * @param params Parameters for the call
         * @returns An `AppClientMethodCallParams` object for the call
         */
        create(params: CallParams<StakingArgs["obj"]["create(string,uint64)void"] | StakingArgs["tuple"]["create(string,uint64)void"]> & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }): AppClientMethodCallParams & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        };
    };
    /**
     * Constructs a no op call for the init()void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static init(params: CallParams<StakingArgs['obj']['init()void'] | StakingArgs['tuple']['init()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the optIn(pay,uint64)void ABI method
     *
     * optin tells the contract to opt into an asa
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static optIn(params: CallParams<StakingArgs['obj']['optIn(pay,uint64)void'] | StakingArgs['tuple']['optIn(pay,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the stake(pay,uint8,uint64,uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static stake(params: CallParams<StakingArgs['obj']['stake(pay,uint8,uint64,uint64)void'] | StakingArgs['tuple']['stake(pay,uint8,uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the stakeAsa(pay,axfer,uint8,uint64,uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static stakeAsa(params: CallParams<StakingArgs['obj']['stakeAsa(pay,axfer,uint8,uint64,uint64)void'] | StakingArgs['tuple']['stakeAsa(pay,axfer,uint8,uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the withdraw(uint64,uint8)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static withdraw(params: CallParams<StakingArgs['obj']['withdraw(uint64,uint8)void'] | StakingArgs['tuple']['withdraw(uint64,uint8)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the createHeartbeat(address,uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static createHeartbeat(params: CallParams<StakingArgs['obj']['createHeartbeat(address,uint64)void'] | StakingArgs['tuple']['createHeartbeat(address,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the softCheck(address,uint64)(bool,uint64) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static softCheck(params: CallParams<StakingArgs['obj']['softCheck(address,uint64)(bool,uint64)'] | StakingArgs['tuple']['softCheck(address,uint64)(bool,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the updateSettings(pay,uint64,uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static updateSettings(params: CallParams<StakingArgs['obj']['updateSettings(pay,uint64,uint64)void'] | StakingArgs['tuple']['updateSettings(pay,uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the optInCost()uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static optInCost(params: CallParams<StakingArgs['obj']['optInCost()uint64'] | StakingArgs['tuple']['optInCost()uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the stakeCost(uint64,uint8)uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static stakeCost(params: CallParams<StakingArgs['obj']['stakeCost(uint64,uint8)uint64'] | StakingArgs['tuple']['stakeCost(uint64,uint8)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the getTimeLeft(address,uint64)uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static getTimeLeft(params: CallParams<StakingArgs['obj']['getTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['getTimeLeft(address,uint64)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the mustGetTimeLeft(address,uint64)uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static mustGetTimeLeft(params: CallParams<StakingArgs['obj']['mustGetTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['mustGetTimeLeft(address,uint64)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the getInfo(address,(uint64,uint8))(uint64,uint64,uint64) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static getInfo(params: CallParams<StakingArgs['obj']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static mustGetInfo(params: CallParams<StakingArgs['obj']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the getEscrowInfo(address,uint64)(uint64,uint64) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static getEscrowInfo(params: CallParams<StakingArgs['obj']['getEscrowInfo(address,uint64)(uint64,uint64)'] | StakingArgs['tuple']['getEscrowInfo(address,uint64)(uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4] ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static getHeartbeat(params: CallParams<StakingArgs['obj']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]'] | StakingArgs['tuple']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4] ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static mustGetHeartbeat(params: CallParams<StakingArgs['obj']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]'] | StakingArgs['tuple']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the getHeartbeatAverage(address,uint64,bool)uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static getHeartbeatAverage(params: CallParams<StakingArgs['obj']['getHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['getHeartbeatAverage(address,uint64,bool)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the mustGetHeartbeatAverage(address,uint64,bool)uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static mustGetHeartbeatAverage(params: CallParams<StakingArgs['obj']['mustGetHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['mustGetHeartbeatAverage(address,uint64,bool)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[] ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static getInfoList(params: CallParams<StakingArgs['obj']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[] ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static mustGetInfoList(params: CallParams<StakingArgs['obj']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the stakeCheck(address,(uint64,uint64)[],uint8,bool)bool ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static stakeCheck(params: CallParams<StakingArgs['obj']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool'] | StakingArgs['tuple']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the getTotals(uint64[])(uint64,uint64)[] ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static getTotals(params: CallParams<StakingArgs['obj']['getTotals(uint64[])(uint64,uint64)[]'] | StakingArgs['tuple']['getTotals(uint64[])(uint64,uint64)[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the updateAkitaDAO(uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static updateAkitaDao(params: CallParams<StakingArgs['obj']['updateAkitaDAO(uint64)void'] | StakingArgs['tuple']['updateAkitaDAO(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the opUp()void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static opUp(params: CallParams<StakingArgs['obj']['opUp()void'] | StakingArgs['tuple']['opUp()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
}
/**
 * A factory to create and deploy one or more instance of the Staking smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export declare class StakingFactory {
    /**
     * The underlying `AppFactory` for when you want to have more flexibility
     */
    readonly appFactory: _AppFactory;
    /**
     * Creates a new instance of `StakingFactory`
     *
     * @param params The parameters to initialise the app factory with
     */
    constructor(params: Omit<AppFactoryParams, 'appSpec'>);
    /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
    get appName(): string;
    /** The ARC-56 app spec being used */
    get appSpec(): Arc56Contract;
    /** A reference to the underlying `AlgorandClient` this app factory is using. */
    get algorand(): AlgorandClient;
    /**
     * Returns a new `AppClient` client for an app instance of the given ID.
     *
     * Automatically populates appName, defaultSender and source maps from the factory
     * if not specified in the params.
     * @param params The parameters to create the app client
     * @returns The `AppClient`
     */
    getAppClientById(params: AppFactoryAppClientParams): StakingClient;
    /**
     * Returns a new `AppClient` client, resolving the app by creator address and name
     * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
     *
     * Automatically populates appName, defaultSender and source maps from the factory
     * if not specified in the params.
     * @param params The parameters to create the app client
     * @returns The `AppClient`
     */
    getAppClientByCreatorAndName(params: AppFactoryResolveAppClientByCreatorAndNameParams): Promise<StakingClient>;
    /**
     * Idempotently deploys the Staking smart contract.
     *
     * @param params The arguments for the contract calls and any additional parameters for the call
     * @returns The deployment result
     */
    deploy(params?: StakingDeployParams): Promise<{
        result: {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "create";
            version: string;
            name: string;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            appId: bigint;
            appAddress: Address;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "update";
            appId: bigint;
            appAddress: Address;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            name: string;
            version: string;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "replace";
            version: string;
            name: string;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            appId: bigint;
            appAddress: Address;
            deleteResult: import("@algorandfoundation/algokit-utils/types/transaction").ConfirmedTransactionResult;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "nothing";
            appId: bigint;
            appAddress: Address;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            name: string;
            version: string;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
        };
        appClient: StakingClient;
    }>;
    /**
     * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
     */
    readonly params: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the Staking smart contract using the create(string,uint64)void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The create params
             */
            create: (params: CallParams<StakingArgs["obj"]["create(string,uint64)void"] | StakingArgs["tuple"]["create(string,uint64)void"]> & AppClientCompilationParams & CreateSchema & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                deployTimeParams: import("@algorandfoundation/algokit-utils/types/app").TealTemplateParams | undefined;
                schema: {
                    globalInts: number;
                    globalByteSlices: number;
                    localInts: number;
                    localByteSlices: number;
                };
                approvalProgram: Uint8Array;
                clearStateProgram: Uint8Array;
                maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                note?: string | Uint8Array | undefined;
                signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                lease?: string | Uint8Array | undefined;
                rekeyTo?: string | Address | undefined;
                staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                validityWindow?: number | bigint | undefined;
                firstValidRound?: bigint | undefined;
                lastValidRound?: bigint | undefined;
                accountReferences?: (string | Address)[] | undefined;
                appReferences?: bigint[] | undefined;
                assetReferences?: bigint[] | undefined;
                boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                sender?: string | Address | undefined;
                method: string;
                args?: (import("algosdk").ABIValue | AppMethodCallTransactionArgument | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined)[] | undefined;
                updatable?: boolean | undefined;
                deletable?: boolean | undefined;
                extraProgramPages?: number | undefined;
            } & {
                sender: Address;
                signer: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                method: import("@algorandfoundation/algokit-utils/types/app-arc56").Arc56Method;
                args: (Transaction | import("algosdk").ABIValue | import("algosdk").TransactionWithSigner | Promise<Transaction> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    note?: string | Uint8Array | undefined;
                    args?: Uint8Array[] | undefined;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                    lease?: string | Uint8Array | undefined;
                    rekeyTo?: string | Address | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                    schema?: {
                        globalInts: number;
                        globalByteSlices: number;
                        localInts: number;
                        localByteSlices: number;
                    } | undefined;
                    extraProgramPages?: number | undefined;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    rekeyTo?: string | Address | undefined;
                    note?: string | Uint8Array | undefined;
                    lease?: string | Uint8Array | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    appId: bigint;
                    onComplete?: OnApplicationComplete.UpdateApplicationOC | undefined;
                    args?: Uint8Array[] | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<import("@algorandfoundation/algokit-utils/types/composer").AppMethodCallParams> | undefined)[] | undefined;
                onComplete: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC;
            }>;
        };
    };
    /**
     * Create transactions for the current app
     */
    readonly createTransaction: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the Staking smart contract using the create(string,uint64)void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The create transaction
             */
            create: (params: CallParams<StakingArgs["obj"]["create(string,uint64)void"] | StakingArgs["tuple"]["create(string,uint64)void"]> & AppClientCompilationParams & CreateSchema & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                transactions: Transaction[];
                methodCalls: Map<number, import("algosdk").ABIMethod>;
                signers: Map<number, TransactionSigner>;
            }>;
        };
    };
    /**
     * Send calls to the current app
     */
    readonly send: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the Staking smart contract using an ABI method call using the create(string,uint64)void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The create result
             */
            create: (params: CallParams<StakingArgs["obj"]["create(string,uint64)void"] | StakingArgs["tuple"]["create(string,uint64)void"]> & AppClientCompilationParams & CreateSchema & SendParams & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                result: {
                    return: (undefined | StakingReturns["create(string,uint64)void"]);
                    compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                    compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                    appId: bigint;
                    groupId: string;
                    txIds: string[];
                    returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
                    confirmations: modelsv2.PendingTransactionResponse[];
                    transactions: Transaction[];
                    confirmation: modelsv2.PendingTransactionResponse;
                    transaction: Transaction;
                    appAddress: Address;
                };
                appClient: StakingClient;
            }>;
        };
    };
}
/**
 * A client to make calls to the Staking smart contract
 */
export declare class StakingClient {
    /**
     * The underlying `AppClient` for when you want to have more flexibility
     */
    readonly appClient: _AppClient;
    /**
     * Creates a new instance of `StakingClient`
     *
     * @param appClient An `AppClient` instance which has been created with the Staking app spec
     */
    constructor(appClient: _AppClient);
    /**
     * Creates a new instance of `StakingClient`
     *
     * @param params The parameters to initialise the app client with
     */
    constructor(params: Omit<AppClientParams, 'appSpec'>);
    /**
     * Checks for decode errors on the given return value and maps the return value to the return type for the given method
     * @returns The typed return value or undefined if there was no value
     */
    decodeReturnValue<TSignature extends StakingNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined): MethodReturn<TSignature> | undefined;
    /**
     * Returns a new `StakingClient` client, resolving the app by creator address and name
     * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
     * @param params The parameters to create the app client
     */
    static fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<StakingClient>;
    /**
     * Returns an `StakingClient` instance for the current network based on
     * pre-determined network-specific app IDs specified in the ARC-56 app spec.
     *
     * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
     * @param params The parameters to create the app client
     */
    static fromNetwork(params: Omit<ResolveAppClientByNetwork, 'appSpec'>): Promise<StakingClient>;
    /** The ID of the app instance this client is linked to. */
    get appId(): bigint;
    /** The app address of the app instance this client is linked to. */
    get appAddress(): Address;
    /** The name of the app. */
    get appName(): string;
    /** The ARC-56 app spec being used */
    get appSpec(): Arc56Contract;
    /** A reference to the underlying `AlgorandClient` this app client is using. */
    get algorand(): AlgorandClient;
    /**
     * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
     */
    readonly params: {
        /**
         * Makes a clear_state call to an existing instance of the Staking smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams>) => import("@algorandfoundation/algokit-utils/types/composer").AppCallParams;
        /**
         * Makes a call to the Staking smart contract using the `init()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        init: (params?: CallParams<StakingArgs["obj"]["init()void"] | StakingArgs["tuple"]["init()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `optIn(pay,uint64)void` ABI method.
         *
         * optin tells the contract to opt into an asa
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        optIn: (params: CallParams<StakingArgs["obj"]["optIn(pay,uint64)void"] | StakingArgs["tuple"]["optIn(pay,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `stake(pay,uint8,uint64,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        stake: (params: CallParams<StakingArgs["obj"]["stake(pay,uint8,uint64,uint64)void"] | StakingArgs["tuple"]["stake(pay,uint8,uint64,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `stakeAsa(pay,axfer,uint8,uint64,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        stakeAsa: (params: CallParams<StakingArgs["obj"]["stakeAsa(pay,axfer,uint8,uint64,uint64)void"] | StakingArgs["tuple"]["stakeAsa(pay,axfer,uint8,uint64,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `withdraw(uint64,uint8)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        withdraw: (params: CallParams<StakingArgs["obj"]["withdraw(uint64,uint8)void"] | StakingArgs["tuple"]["withdraw(uint64,uint8)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `createHeartbeat(address,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        createHeartbeat: (params: CallParams<StakingArgs["obj"]["createHeartbeat(address,uint64)void"] | StakingArgs["tuple"]["createHeartbeat(address,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `softCheck(address,uint64)(bool,uint64)` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        softCheck: (params: CallParams<StakingArgs["obj"]["softCheck(address,uint64)(bool,uint64)"] | StakingArgs["tuple"]["softCheck(address,uint64)(bool,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `updateSettings(pay,uint64,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        updateSettings: (params: CallParams<StakingArgs["obj"]["updateSettings(pay,uint64,uint64)void"] | StakingArgs["tuple"]["updateSettings(pay,uint64,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `optInCost()uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        optInCost: (params?: CallParams<StakingArgs["obj"]["optInCost()uint64"] | StakingArgs["tuple"]["optInCost()uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `stakeCost(uint64,uint8)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        stakeCost: (params: CallParams<StakingArgs["obj"]["stakeCost(uint64,uint8)uint64"] | StakingArgs["tuple"]["stakeCost(uint64,uint8)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `getTimeLeft(address,uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        getTimeLeft: (params: CallParams<StakingArgs["obj"]["getTimeLeft(address,uint64)uint64"] | StakingArgs["tuple"]["getTimeLeft(address,uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `mustGetTimeLeft(address,uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        mustGetTimeLeft: (params: CallParams<StakingArgs["obj"]["mustGetTimeLeft(address,uint64)uint64"] | StakingArgs["tuple"]["mustGetTimeLeft(address,uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `getInfo(address,(uint64,uint8))(uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        getInfo: (params: CallParams<StakingArgs["obj"]["getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"] | StakingArgs["tuple"]["getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        mustGetInfo: (params: CallParams<StakingArgs["obj"]["mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)"] | StakingArgs["tuple"]["mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `getEscrowInfo(address,uint64)(uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        getEscrowInfo: (params: CallParams<StakingArgs["obj"]["getEscrowInfo(address,uint64)(uint64,uint64)"] | StakingArgs["tuple"]["getEscrowInfo(address,uint64)(uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        getHeartbeat: (params: CallParams<StakingArgs["obj"]["getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]"] | StakingArgs["tuple"]["getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        mustGetHeartbeat: (params: CallParams<StakingArgs["obj"]["mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]"] | StakingArgs["tuple"]["mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `getHeartbeatAverage(address,uint64,bool)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        getHeartbeatAverage: (params: CallParams<StakingArgs["obj"]["getHeartbeatAverage(address,uint64,bool)uint64"] | StakingArgs["tuple"]["getHeartbeatAverage(address,uint64,bool)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `mustGetHeartbeatAverage(address,uint64,bool)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        mustGetHeartbeatAverage: (params: CallParams<StakingArgs["obj"]["mustGetHeartbeatAverage(address,uint64,bool)uint64"] | StakingArgs["tuple"]["mustGetHeartbeatAverage(address,uint64,bool)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        getInfoList: (params: CallParams<StakingArgs["obj"]["getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]"] | StakingArgs["tuple"]["getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        mustGetInfoList: (params: CallParams<StakingArgs["obj"]["mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]"] | StakingArgs["tuple"]["mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `stakeCheck(address,(uint64,uint64)[],uint8,bool)bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        stakeCheck: (params: CallParams<StakingArgs["obj"]["stakeCheck(address,(uint64,uint64)[],uint8,bool)bool"] | StakingArgs["tuple"]["stakeCheck(address,(uint64,uint64)[],uint8,bool)bool"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `getTotals(uint64[])(uint64,uint64)[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        getTotals: (params: CallParams<StakingArgs["obj"]["getTotals(uint64[])(uint64,uint64)[]"] | StakingArgs["tuple"]["getTotals(uint64[])(uint64,uint64)[]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `updateAkitaDAO(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        updateAkitaDao: (params: CallParams<StakingArgs["obj"]["updateAkitaDAO(uint64)void"] | StakingArgs["tuple"]["updateAkitaDAO(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Staking smart contract using the `opUp()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        opUp: (params?: CallParams<StakingArgs["obj"]["opUp()void"] | StakingArgs["tuple"]["opUp()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
    };
    /**
     * Create transactions for the current app
     */
    readonly createTransaction: {
        /**
         * Makes a clear_state call to an existing instance of the Staking smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams>) => Promise<Transaction>;
        /**
         * Makes a call to the Staking smart contract using the `init()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        init: (params?: CallParams<StakingArgs["obj"]["init()void"] | StakingArgs["tuple"]["init()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `optIn(pay,uint64)void` ABI method.
         *
         * optin tells the contract to opt into an asa
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        optIn: (params: CallParams<StakingArgs["obj"]["optIn(pay,uint64)void"] | StakingArgs["tuple"]["optIn(pay,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `stake(pay,uint8,uint64,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        stake: (params: CallParams<StakingArgs["obj"]["stake(pay,uint8,uint64,uint64)void"] | StakingArgs["tuple"]["stake(pay,uint8,uint64,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `stakeAsa(pay,axfer,uint8,uint64,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        stakeAsa: (params: CallParams<StakingArgs["obj"]["stakeAsa(pay,axfer,uint8,uint64,uint64)void"] | StakingArgs["tuple"]["stakeAsa(pay,axfer,uint8,uint64,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `withdraw(uint64,uint8)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        withdraw: (params: CallParams<StakingArgs["obj"]["withdraw(uint64,uint8)void"] | StakingArgs["tuple"]["withdraw(uint64,uint8)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `createHeartbeat(address,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        createHeartbeat: (params: CallParams<StakingArgs["obj"]["createHeartbeat(address,uint64)void"] | StakingArgs["tuple"]["createHeartbeat(address,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `softCheck(address,uint64)(bool,uint64)` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        softCheck: (params: CallParams<StakingArgs["obj"]["softCheck(address,uint64)(bool,uint64)"] | StakingArgs["tuple"]["softCheck(address,uint64)(bool,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `updateSettings(pay,uint64,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        updateSettings: (params: CallParams<StakingArgs["obj"]["updateSettings(pay,uint64,uint64)void"] | StakingArgs["tuple"]["updateSettings(pay,uint64,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `optInCost()uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        optInCost: (params?: CallParams<StakingArgs["obj"]["optInCost()uint64"] | StakingArgs["tuple"]["optInCost()uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `stakeCost(uint64,uint8)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        stakeCost: (params: CallParams<StakingArgs["obj"]["stakeCost(uint64,uint8)uint64"] | StakingArgs["tuple"]["stakeCost(uint64,uint8)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `getTimeLeft(address,uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        getTimeLeft: (params: CallParams<StakingArgs["obj"]["getTimeLeft(address,uint64)uint64"] | StakingArgs["tuple"]["getTimeLeft(address,uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `mustGetTimeLeft(address,uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        mustGetTimeLeft: (params: CallParams<StakingArgs["obj"]["mustGetTimeLeft(address,uint64)uint64"] | StakingArgs["tuple"]["mustGetTimeLeft(address,uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `getInfo(address,(uint64,uint8))(uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        getInfo: (params: CallParams<StakingArgs["obj"]["getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"] | StakingArgs["tuple"]["getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        mustGetInfo: (params: CallParams<StakingArgs["obj"]["mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)"] | StakingArgs["tuple"]["mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `getEscrowInfo(address,uint64)(uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        getEscrowInfo: (params: CallParams<StakingArgs["obj"]["getEscrowInfo(address,uint64)(uint64,uint64)"] | StakingArgs["tuple"]["getEscrowInfo(address,uint64)(uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        getHeartbeat: (params: CallParams<StakingArgs["obj"]["getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]"] | StakingArgs["tuple"]["getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        mustGetHeartbeat: (params: CallParams<StakingArgs["obj"]["mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]"] | StakingArgs["tuple"]["mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `getHeartbeatAverage(address,uint64,bool)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        getHeartbeatAverage: (params: CallParams<StakingArgs["obj"]["getHeartbeatAverage(address,uint64,bool)uint64"] | StakingArgs["tuple"]["getHeartbeatAverage(address,uint64,bool)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `mustGetHeartbeatAverage(address,uint64,bool)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        mustGetHeartbeatAverage: (params: CallParams<StakingArgs["obj"]["mustGetHeartbeatAverage(address,uint64,bool)uint64"] | StakingArgs["tuple"]["mustGetHeartbeatAverage(address,uint64,bool)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        getInfoList: (params: CallParams<StakingArgs["obj"]["getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]"] | StakingArgs["tuple"]["getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        mustGetInfoList: (params: CallParams<StakingArgs["obj"]["mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]"] | StakingArgs["tuple"]["mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `stakeCheck(address,(uint64,uint64)[],uint8,bool)bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        stakeCheck: (params: CallParams<StakingArgs["obj"]["stakeCheck(address,(uint64,uint64)[],uint8,bool)bool"] | StakingArgs["tuple"]["stakeCheck(address,(uint64,uint64)[],uint8,bool)bool"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `getTotals(uint64[])(uint64,uint64)[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        getTotals: (params: CallParams<StakingArgs["obj"]["getTotals(uint64[])(uint64,uint64)[]"] | StakingArgs["tuple"]["getTotals(uint64[])(uint64,uint64)[]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `updateAkitaDAO(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        updateAkitaDao: (params: CallParams<StakingArgs["obj"]["updateAkitaDAO(uint64)void"] | StakingArgs["tuple"]["updateAkitaDAO(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `opUp()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        opUp: (params?: CallParams<StakingArgs["obj"]["opUp()void"] | StakingArgs["tuple"]["opUp()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
    };
    /**
     * Send calls to the current app
     */
    readonly send: {
        /**
         * Makes a clear_state call to an existing instance of the Staking smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => Promise<{
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            return?: ABIReturn | undefined;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `init()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        init: (params?: CallParams<StakingArgs["obj"]["init()void"] | StakingArgs["tuple"]["init()void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["init()void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `optIn(pay,uint64)void` ABI method.
         *
         * optin tells the contract to opt into an asa
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        optIn: (params: CallParams<StakingArgs["obj"]["optIn(pay,uint64)void"] | StakingArgs["tuple"]["optIn(pay,uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["optIn(pay,uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `stake(pay,uint8,uint64,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        stake: (params: CallParams<StakingArgs["obj"]["stake(pay,uint8,uint64,uint64)void"] | StakingArgs["tuple"]["stake(pay,uint8,uint64,uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["stake(pay,uint8,uint64,uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `stakeAsa(pay,axfer,uint8,uint64,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        stakeAsa: (params: CallParams<StakingArgs["obj"]["stakeAsa(pay,axfer,uint8,uint64,uint64)void"] | StakingArgs["tuple"]["stakeAsa(pay,axfer,uint8,uint64,uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["stakeAsa(pay,axfer,uint8,uint64,uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `withdraw(uint64,uint8)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        withdraw: (params: CallParams<StakingArgs["obj"]["withdraw(uint64,uint8)void"] | StakingArgs["tuple"]["withdraw(uint64,uint8)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["withdraw(uint64,uint8)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `createHeartbeat(address,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        createHeartbeat: (params: CallParams<StakingArgs["obj"]["createHeartbeat(address,uint64)void"] | StakingArgs["tuple"]["createHeartbeat(address,uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["createHeartbeat(address,uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `softCheck(address,uint64)(bool,uint64)` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        softCheck: (params: CallParams<StakingArgs["obj"]["softCheck(address,uint64)(bool,uint64)"] | StakingArgs["tuple"]["softCheck(address,uint64)(bool,uint64)"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["softCheck(address,uint64)(bool,uint64)"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `updateSettings(pay,uint64,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        updateSettings: (params: CallParams<StakingArgs["obj"]["updateSettings(pay,uint64,uint64)void"] | StakingArgs["tuple"]["updateSettings(pay,uint64,uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["updateSettings(pay,uint64,uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `optInCost()uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        optInCost: (params?: CallParams<StakingArgs["obj"]["optInCost()uint64"] | StakingArgs["tuple"]["optInCost()uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["optInCost()uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `stakeCost(uint64,uint8)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        stakeCost: (params: CallParams<StakingArgs["obj"]["stakeCost(uint64,uint8)uint64"] | StakingArgs["tuple"]["stakeCost(uint64,uint8)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["stakeCost(uint64,uint8)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `getTimeLeft(address,uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        getTimeLeft: (params: CallParams<StakingArgs["obj"]["getTimeLeft(address,uint64)uint64"] | StakingArgs["tuple"]["getTimeLeft(address,uint64)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["getTimeLeft(address,uint64)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `mustGetTimeLeft(address,uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        mustGetTimeLeft: (params: CallParams<StakingArgs["obj"]["mustGetTimeLeft(address,uint64)uint64"] | StakingArgs["tuple"]["mustGetTimeLeft(address,uint64)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["mustGetTimeLeft(address,uint64)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `getInfo(address,(uint64,uint8))(uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        getInfo: (params: CallParams<StakingArgs["obj"]["getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"] | StakingArgs["tuple"]["getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["getInfo(address,(uint64,uint8))(uint64,uint64,uint64)"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        mustGetInfo: (params: CallParams<StakingArgs["obj"]["mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)"] | StakingArgs["tuple"]["mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `getEscrowInfo(address,uint64)(uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        getEscrowInfo: (params: CallParams<StakingArgs["obj"]["getEscrowInfo(address,uint64)(uint64,uint64)"] | StakingArgs["tuple"]["getEscrowInfo(address,uint64)(uint64,uint64)"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["getEscrowInfo(address,uint64)(uint64,uint64)"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        getHeartbeat: (params: CallParams<StakingArgs["obj"]["getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]"] | StakingArgs["tuple"]["getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        mustGetHeartbeat: (params: CallParams<StakingArgs["obj"]["mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]"] | StakingArgs["tuple"]["mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `getHeartbeatAverage(address,uint64,bool)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        getHeartbeatAverage: (params: CallParams<StakingArgs["obj"]["getHeartbeatAverage(address,uint64,bool)uint64"] | StakingArgs["tuple"]["getHeartbeatAverage(address,uint64,bool)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["getHeartbeatAverage(address,uint64,bool)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `mustGetHeartbeatAverage(address,uint64,bool)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        mustGetHeartbeatAverage: (params: CallParams<StakingArgs["obj"]["mustGetHeartbeatAverage(address,uint64,bool)uint64"] | StakingArgs["tuple"]["mustGetHeartbeatAverage(address,uint64,bool)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["mustGetHeartbeatAverage(address,uint64,bool)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        getInfoList: (params: CallParams<StakingArgs["obj"]["getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]"] | StakingArgs["tuple"]["getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        mustGetInfoList: (params: CallParams<StakingArgs["obj"]["mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]"] | StakingArgs["tuple"]["mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `stakeCheck(address,(uint64,uint64)[],uint8,bool)bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        stakeCheck: (params: CallParams<StakingArgs["obj"]["stakeCheck(address,(uint64,uint64)[],uint8,bool)bool"] | StakingArgs["tuple"]["stakeCheck(address,(uint64,uint64)[],uint8,bool)bool"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["stakeCheck(address,(uint64,uint64)[],uint8,bool)bool"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `getTotals(uint64[])(uint64,uint64)[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        getTotals: (params: CallParams<StakingArgs["obj"]["getTotals(uint64[])(uint64,uint64)[]"] | StakingArgs["tuple"]["getTotals(uint64[])(uint64,uint64)[]"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["getTotals(uint64[])(uint64,uint64)[]"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `updateAkitaDAO(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        updateAkitaDao: (params: CallParams<StakingArgs["obj"]["updateAkitaDAO(uint64)void"] | StakingArgs["tuple"]["updateAkitaDAO(uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["updateAkitaDAO(uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Staking smart contract using the `opUp()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        opUp: (params?: CallParams<StakingArgs["obj"]["opUp()void"] | StakingArgs["tuple"]["opUp()void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | StakingReturns["opUp()void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
    };
    /**
     * Clone this app client with different params
     *
     * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
     * @returns A new app client with the altered params
     */
    clone(params: CloneAppClientParams): StakingClient;
    /**
     * Makes a readonly (simulated) call to the Staking smart contract using the `optInCost()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    optInCost(params?: CallParams<StakingArgs['obj']['optInCost()uint64'] | StakingArgs['tuple']['optInCost()uint64']>): Promise<bigint>;
    /**
     * Makes a readonly (simulated) call to the Staking smart contract using the `stakeCost(uint64,uint8)uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    stakeCost(params: CallParams<StakingArgs['obj']['stakeCost(uint64,uint8)uint64'] | StakingArgs['tuple']['stakeCost(uint64,uint8)uint64']>): Promise<bigint>;
    /**
     * Makes a readonly (simulated) call to the Staking smart contract using the `getTimeLeft(address,uint64)uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getTimeLeft(params: CallParams<StakingArgs['obj']['getTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['getTimeLeft(address,uint64)uint64']>): Promise<bigint>;
    /**
     * Makes a readonly (simulated) call to the Staking smart contract using the `mustGetTimeLeft(address,uint64)uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mustGetTimeLeft(params: CallParams<StakingArgs['obj']['mustGetTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['mustGetTimeLeft(address,uint64)uint64']>): Promise<bigint>;
    /**
     * Makes a readonly (simulated) call to the Staking smart contract using the `getInfo(address,(uint64,uint8))(uint64,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getInfo(params: CallParams<StakingArgs['obj']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)']>): Promise<Stake>;
    /**
     * Makes a readonly (simulated) call to the Staking smart contract using the `mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mustGetInfo(params: CallParams<StakingArgs['obj']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)']>): Promise<Stake>;
    /**
     * Makes a readonly (simulated) call to the Staking smart contract using the `getEscrowInfo(address,uint64)(uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getEscrowInfo(params: CallParams<StakingArgs['obj']['getEscrowInfo(address,uint64)(uint64,uint64)'] | StakingArgs['tuple']['getEscrowInfo(address,uint64)(uint64,uint64)']>): Promise<Escrow>;
    /**
     * Makes a readonly (simulated) call to the Staking smart contract using the `getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getHeartbeat(params: CallParams<StakingArgs['obj']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]'] | StakingArgs['tuple']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]']>): Promise<[[bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint]]>;
    /**
     * Makes a readonly (simulated) call to the Staking smart contract using the `mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mustGetHeartbeat(params: CallParams<StakingArgs['obj']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]'] | StakingArgs['tuple']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]']>): Promise<[[bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint]]>;
    /**
     * Makes a readonly (simulated) call to the Staking smart contract using the `getHeartbeatAverage(address,uint64,bool)uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getHeartbeatAverage(params: CallParams<StakingArgs['obj']['getHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['getHeartbeatAverage(address,uint64,bool)uint64']>): Promise<bigint>;
    /**
     * Makes a readonly (simulated) call to the Staking smart contract using the `mustGetHeartbeatAverage(address,uint64,bool)uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mustGetHeartbeatAverage(params: CallParams<StakingArgs['obj']['mustGetHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['mustGetHeartbeatAverage(address,uint64,bool)uint64']>): Promise<bigint>;
    /**
     * Makes a readonly (simulated) call to the Staking smart contract using the `getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getInfoList(params: CallParams<StakingArgs['obj']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']>): Promise<[bigint, bigint, bigint][]>;
    /**
     * Makes a readonly (simulated) call to the Staking smart contract using the `mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mustGetInfoList(params: CallParams<StakingArgs['obj']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']>): Promise<[bigint, bigint, bigint][]>;
    /**
     * Makes a readonly (simulated) call to the Staking smart contract using the `stakeCheck(address,(uint64,uint64)[],uint8,bool)bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    stakeCheck(params: CallParams<StakingArgs['obj']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool'] | StakingArgs['tuple']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool']>): Promise<boolean>;
    /**
     * Makes a readonly (simulated) call to the Staking smart contract using the `getTotals(uint64[])(uint64,uint64)[]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getTotals(params: CallParams<StakingArgs['obj']['getTotals(uint64[])(uint64,uint64)[]'] | StakingArgs['tuple']['getTotals(uint64[])(uint64,uint64)[]']>): Promise<[bigint, bigint][]>;
    /**
     * Methods to access state for the current Staking app
     */
    state: {
        /**
         * Methods to access global state for the current Staking app
         */
        global: {
            /**
             * Get all current keyed values from global state
             */
            getAll: () => Promise<Partial<Expand<GlobalKeysState>>>;
            /**
             * Get the current value of the heartbeatManagerAddress key in global state
             */
            heartbeatManagerAddress: () => Promise<string | undefined>;
            /**
             * Get the current value of the version key in global state
             */
            version: () => Promise<string | undefined>;
            /**
             * Get the current value of the akitaDAO key in global state
             */
            akitaDao: () => Promise<bigint | undefined>;
        };
        /**
         * Methods to access box state for the current Staking app
         */
        box: {
            /**
             * Get all current keyed values from box state
             */
            getAll: () => Promise<Partial<Expand<BoxKeysState>>>;
            /**
             * Get values from the stakes map in box state
             */
            stakes: {
                /**
                 * Get all current values of the stakes map in box state
                 */
                getMap: () => Promise<Map<StakeKey, Stake>>;
                /**
                 * Get a current value of the stakes map by key from box state
                 */
                value: (key: StakeKey) => Promise<Stake | undefined>;
            };
            /**
             * Get values from the heartbeats map in box state
             */
            heartbeats: {
                /**
                 * Get all current values of the heartbeats map in box state
                 */
                getMap: () => Promise<Map<HeartbeatKey, [[bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint]]>>;
                /**
                 * Get a current value of the heartbeats map by key from box state
                 */
                value: (key: HeartbeatKey) => Promise<[[bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint], [bigint, bigint, bigint, bigint]] | undefined>;
            };
            /**
             * Get values from the totals map in box state
             */
            totals: {
                /**
                 * Get all current values of the totals map in box state
                 */
                getMap: () => Promise<Map<bigint, TotalsInfo>>;
                /**
                 * Get a current value of the totals map by key from box state
                 */
                value: (key: bigint | number) => Promise<TotalsInfo | undefined>;
            };
            /**
             * Get values from the settings map in box state
             */
            settings: {
                /**
                 * Get all current values of the settings map in box state
                 */
                getMap: () => Promise<Map<bigint, bigint>>;
                /**
                 * Get a current value of the settings map by key from box state
                 */
                value: (key: bigint | number) => Promise<bigint | undefined>;
            };
        };
    };
    newGroup(): StakingComposer;
}
export type StakingComposer<TReturns extends [...any[]] = []> = {
    /**
     * Calls the init()void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    init(params?: CallParams<StakingArgs['obj']['init()void'] | StakingArgs['tuple']['init()void']>): StakingComposer<[...TReturns, StakingReturns['init()void'] | undefined]>;
    /**
     * Calls the optIn(pay,uint64)void ABI method.
     *
     * optin tells the contract to opt into an asa
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    optIn(params?: CallParams<StakingArgs['obj']['optIn(pay,uint64)void'] | StakingArgs['tuple']['optIn(pay,uint64)void']>): StakingComposer<[...TReturns, StakingReturns['optIn(pay,uint64)void'] | undefined]>;
    /**
     * Calls the stake(pay,uint8,uint64,uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    stake(params?: CallParams<StakingArgs['obj']['stake(pay,uint8,uint64,uint64)void'] | StakingArgs['tuple']['stake(pay,uint8,uint64,uint64)void']>): StakingComposer<[...TReturns, StakingReturns['stake(pay,uint8,uint64,uint64)void'] | undefined]>;
    /**
     * Calls the stakeAsa(pay,axfer,uint8,uint64,uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    stakeAsa(params?: CallParams<StakingArgs['obj']['stakeAsa(pay,axfer,uint8,uint64,uint64)void'] | StakingArgs['tuple']['stakeAsa(pay,axfer,uint8,uint64,uint64)void']>): StakingComposer<[...TReturns, StakingReturns['stakeAsa(pay,axfer,uint8,uint64,uint64)void'] | undefined]>;
    /**
     * Calls the withdraw(uint64,uint8)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    withdraw(params?: CallParams<StakingArgs['obj']['withdraw(uint64,uint8)void'] | StakingArgs['tuple']['withdraw(uint64,uint8)void']>): StakingComposer<[...TReturns, StakingReturns['withdraw(uint64,uint8)void'] | undefined]>;
    /**
     * Calls the createHeartbeat(address,uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    createHeartbeat(params?: CallParams<StakingArgs['obj']['createHeartbeat(address,uint64)void'] | StakingArgs['tuple']['createHeartbeat(address,uint64)void']>): StakingComposer<[...TReturns, StakingReturns['createHeartbeat(address,uint64)void'] | undefined]>;
    /**
     * Calls the softCheck(address,uint64)(bool,uint64) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    softCheck(params?: CallParams<StakingArgs['obj']['softCheck(address,uint64)(bool,uint64)'] | StakingArgs['tuple']['softCheck(address,uint64)(bool,uint64)']>): StakingComposer<[...TReturns, StakingReturns['softCheck(address,uint64)(bool,uint64)'] | undefined]>;
    /**
     * Calls the updateSettings(pay,uint64,uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    updateSettings(params?: CallParams<StakingArgs['obj']['updateSettings(pay,uint64,uint64)void'] | StakingArgs['tuple']['updateSettings(pay,uint64,uint64)void']>): StakingComposer<[...TReturns, StakingReturns['updateSettings(pay,uint64,uint64)void'] | undefined]>;
    /**
     * Calls the optInCost()uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    optInCost(params?: CallParams<StakingArgs['obj']['optInCost()uint64'] | StakingArgs['tuple']['optInCost()uint64']>): StakingComposer<[...TReturns, StakingReturns['optInCost()uint64'] | undefined]>;
    /**
     * Calls the stakeCost(uint64,uint8)uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    stakeCost(params?: CallParams<StakingArgs['obj']['stakeCost(uint64,uint8)uint64'] | StakingArgs['tuple']['stakeCost(uint64,uint8)uint64']>): StakingComposer<[...TReturns, StakingReturns['stakeCost(uint64,uint8)uint64'] | undefined]>;
    /**
     * Calls the getTimeLeft(address,uint64)uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    getTimeLeft(params?: CallParams<StakingArgs['obj']['getTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['getTimeLeft(address,uint64)uint64']>): StakingComposer<[...TReturns, StakingReturns['getTimeLeft(address,uint64)uint64'] | undefined]>;
    /**
     * Calls the mustGetTimeLeft(address,uint64)uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    mustGetTimeLeft(params?: CallParams<StakingArgs['obj']['mustGetTimeLeft(address,uint64)uint64'] | StakingArgs['tuple']['mustGetTimeLeft(address,uint64)uint64']>): StakingComposer<[...TReturns, StakingReturns['mustGetTimeLeft(address,uint64)uint64'] | undefined]>;
    /**
     * Calls the getInfo(address,(uint64,uint8))(uint64,uint64,uint64) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    getInfo(params?: CallParams<StakingArgs['obj']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)']>): StakingComposer<[...TReturns, StakingReturns['getInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | undefined]>;
    /**
     * Calls the mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    mustGetInfo(params?: CallParams<StakingArgs['obj']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | StakingArgs['tuple']['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)']>): StakingComposer<[...TReturns, StakingReturns['mustGetInfo(address,(uint64,uint8))(uint64,uint64,uint64)'] | undefined]>;
    /**
     * Calls the getEscrowInfo(address,uint64)(uint64,uint64) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    getEscrowInfo(params?: CallParams<StakingArgs['obj']['getEscrowInfo(address,uint64)(uint64,uint64)'] | StakingArgs['tuple']['getEscrowInfo(address,uint64)(uint64,uint64)']>): StakingComposer<[...TReturns, StakingReturns['getEscrowInfo(address,uint64)(uint64,uint64)'] | undefined]>;
    /**
     * Calls the getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4] ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    getHeartbeat(params?: CallParams<StakingArgs['obj']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]'] | StakingArgs['tuple']['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]']>): StakingComposer<[...TReturns, StakingReturns['getHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]'] | undefined]>;
    /**
     * Calls the mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4] ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    mustGetHeartbeat(params?: CallParams<StakingArgs['obj']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]'] | StakingArgs['tuple']['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]']>): StakingComposer<[...TReturns, StakingReturns['mustGetHeartbeat(address,uint64)(uint64,uint64,uint64,uint64)[4]'] | undefined]>;
    /**
     * Calls the getHeartbeatAverage(address,uint64,bool)uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    getHeartbeatAverage(params?: CallParams<StakingArgs['obj']['getHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['getHeartbeatAverage(address,uint64,bool)uint64']>): StakingComposer<[...TReturns, StakingReturns['getHeartbeatAverage(address,uint64,bool)uint64'] | undefined]>;
    /**
     * Calls the mustGetHeartbeatAverage(address,uint64,bool)uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    mustGetHeartbeatAverage(params?: CallParams<StakingArgs['obj']['mustGetHeartbeatAverage(address,uint64,bool)uint64'] | StakingArgs['tuple']['mustGetHeartbeatAverage(address,uint64,bool)uint64']>): StakingComposer<[...TReturns, StakingReturns['mustGetHeartbeatAverage(address,uint64,bool)uint64'] | undefined]>;
    /**
     * Calls the getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[] ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    getInfoList(params?: CallParams<StakingArgs['obj']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']>): StakingComposer<[...TReturns, StakingReturns['getInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | undefined]>;
    /**
     * Calls the mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[] ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    mustGetInfoList(params?: CallParams<StakingArgs['obj']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | StakingArgs['tuple']['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]']>): StakingComposer<[...TReturns, StakingReturns['mustGetInfoList(address,uint8,uint64[])(uint64,uint64,uint64)[]'] | undefined]>;
    /**
     * Calls the stakeCheck(address,(uint64,uint64)[],uint8,bool)bool ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    stakeCheck(params?: CallParams<StakingArgs['obj']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool'] | StakingArgs['tuple']['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool']>): StakingComposer<[...TReturns, StakingReturns['stakeCheck(address,(uint64,uint64)[],uint8,bool)bool'] | undefined]>;
    /**
     * Calls the getTotals(uint64[])(uint64,uint64)[] ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    getTotals(params?: CallParams<StakingArgs['obj']['getTotals(uint64[])(uint64,uint64)[]'] | StakingArgs['tuple']['getTotals(uint64[])(uint64,uint64)[]']>): StakingComposer<[...TReturns, StakingReturns['getTotals(uint64[])(uint64,uint64)[]'] | undefined]>;
    /**
     * Calls the updateAkitaDAO(uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    updateAkitaDao(params?: CallParams<StakingArgs['obj']['updateAkitaDAO(uint64)void'] | StakingArgs['tuple']['updateAkitaDAO(uint64)void']>): StakingComposer<[...TReturns, StakingReturns['updateAkitaDAO(uint64)void'] | undefined]>;
    /**
     * Calls the opUp()void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    opUp(params?: CallParams<StakingArgs['obj']['opUp()void'] | StakingArgs['tuple']['opUp()void']>): StakingComposer<[...TReturns, StakingReturns['opUp()void'] | undefined]>;
    /**
     * Makes a clear_state call to an existing instance of the Staking smart contract.
     *
     * @param args The arguments for the bare call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    clearState(params?: AppClientBareCallParams): StakingComposer<[...TReturns, undefined]>;
    /**
     * Adds a transaction to the composer
     *
     * @param txn A transaction to add to the transaction group
     * @param signer The optional signer to use when signing this transaction.
     */
    addTransaction(txn: Transaction, signer?: TransactionSigner): StakingComposer<TReturns>;
    /**
     * Returns the underlying AtomicTransactionComposer instance
     */
    composer(): Promise<TransactionComposer>;
    /**
     * Simulates the transaction group and returns the result
     */
    simulate(): Promise<StakingComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    simulate(options: SkipSignaturesSimulateOptions): Promise<StakingComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    simulate(options: RawSimulateOptions): Promise<StakingComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    /**
     * Sends the transaction group to the network and returns the results
     */
    send(params?: SendParams): Promise<StakingComposerResults<TReturns>>;
};
export type StakingComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
    returns: TReturns;
}>;
