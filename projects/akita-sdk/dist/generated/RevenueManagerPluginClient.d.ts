/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client';
import { ABIReturn } from '@algorandfoundation/algokit-utils/types/app';
import { Arc56Contract } from '@algorandfoundation/algokit-utils/types/app-arc56';
import { AppClient as _AppClient, AppClientMethodCallParams, AppClientParams, AppClientBareCallParams, CallOnComplete, AppClientCompilationParams, ResolveAppClientByCreatorAndName, ResolveAppClientByNetwork, CloneAppClientParams } from '@algorandfoundation/algokit-utils/types/app-client';
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory';
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer';
import { SendParams, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction';
import { Address, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk';
export declare const APP_SPEC: Arc56Contract;
/**
 * A state record containing binary data
 */
export interface BinaryState {
    /**
     * Gets the state value as a Uint8Array
     */
    asByteArray(): Uint8Array | undefined;
    /**
     * Gets the state value as a string
     */
    asString(): string | undefined;
}
/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R ? (...args: Expand<A>) => Expand<R> : T extends infer O ? {
    [K in keyof O]: O[K];
} : never;
export type EscrowAssetKey = {
    escrow: bigint;
    asset: bigint;
};
/**
 * Converts the ABI tuple representation of a EscrowAssetKey to the struct representation
 */
export declare function EscrowAssetKeyFromTuple(abiTuple: [bigint, bigint]): EscrowAssetKey;
export type ReceiveEscrow = {
    source: string;
    allocatable: boolean;
    optinAllowed: boolean;
    optinCount: bigint;
    phase: number;
    allocationCounter: bigint;
    lastDisbursement: bigint;
    creationDate: bigint;
};
/**
 * Converts the ABI tuple representation of a ReceiveEscrow to the struct representation
 */
export declare function ReceiveEscrowFromTuple(abiTuple: [string, boolean, boolean, bigint, number, bigint, bigint, bigint]): ReceiveEscrow;
export type SplitRef = {
    app: bigint;
    key: Uint8Array;
};
/**
 * Converts the ABI tuple representation of a SplitRef to the struct representation
 */
export declare function SplitRefFromTuple(abiTuple: [bigint, Uint8Array]): SplitRef;
export type WalletEscrowKey = {
    wallet: bigint;
    escrow: string;
};
/**
 * Converts the ABI tuple representation of a WalletEscrowKey to the struct representation
 */
export declare function WalletEscrowKeyFromTuple(abiTuple: [bigint, string]): WalletEscrowKey;
/**
 * The argument types for the RevenueManagerPlugin contract
 */
export type RevenueManagerPluginArgs = {
    /**
     * The object representation of the arguments for each method
     */
    obj: {
        'create(string,uint64)void': {
            version: string;
            akitaDao: bigint | number;
        };
        'optIn(uint64,bool,uint64[],pay)void': {
            wallet: bigint | number;
            rekeyBack: boolean;
            assets: bigint[] | number[];
            mbrPayment: AppMethodCallTransactionArgument;
        };
        'newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void': {
            wallet: bigint | number;
            rekeyBack: boolean;
            escrow: string;
            source: string;
            allocatable: boolean;
            optinAllowed: boolean;
            splits: [[bigint | number, string], bigint | number, bigint | number][];
        };
        'newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void': {
            wallet: bigint | number;
            rekeyBack: boolean;
            escrow: string;
            source: string;
            allocatable: boolean;
            optinAllowed: boolean;
            splitRef: SplitRef;
        };
        'startEscrowDisbursement(uint64,bool)void': {
            wallet: bigint | number;
            rekeyBack: boolean;
        };
        'processEscrowAllocation(uint64,bool,uint64[])void': {
            wallet: bigint | number;
            rekeyBack: boolean;
            ids: bigint[] | number[];
        };
        'finalizeEscrowDisbursement(uint64,bool,uint64[])void': {
            wallet: bigint | number;
            rekeyBack: boolean;
            ids: bigint[] | number[];
        };
        'updateAkitaDAO(uint64)void': {
            akitaDao: bigint | number;
        };
        'opUp()void': Record<string, never>;
    };
    /**
     * The tuple representation of the arguments for each method
     */
    tuple: {
        'create(string,uint64)void': [version: string, akitaDao: bigint | number];
        'optIn(uint64,bool,uint64[],pay)void': [wallet: bigint | number, rekeyBack: boolean, assets: bigint[] | number[], mbrPayment: AppMethodCallTransactionArgument];
        'newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void': [wallet: bigint | number, rekeyBack: boolean, escrow: string, source: string, allocatable: boolean, optinAllowed: boolean, splits: [[bigint | number, string], bigint | number, bigint | number][]];
        'newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void': [wallet: bigint | number, rekeyBack: boolean, escrow: string, source: string, allocatable: boolean, optinAllowed: boolean, splitRef: SplitRef];
        'startEscrowDisbursement(uint64,bool)void': [wallet: bigint | number, rekeyBack: boolean];
        'processEscrowAllocation(uint64,bool,uint64[])void': [wallet: bigint | number, rekeyBack: boolean, ids: bigint[] | number[]];
        'finalizeEscrowDisbursement(uint64,bool,uint64[])void': [wallet: bigint | number, rekeyBack: boolean, ids: bigint[] | number[]];
        'updateAkitaDAO(uint64)void': [akitaDao: bigint | number];
        'opUp()void': [];
    };
};
/**
 * The return type for each method
 */
export type RevenueManagerPluginReturns = {
    'create(string,uint64)void': void;
    'optIn(uint64,bool,uint64[],pay)void': void;
    'newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void': void;
    'newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void': void;
    'startEscrowDisbursement(uint64,bool)void': void;
    'processEscrowAllocation(uint64,bool,uint64[])void': void;
    'finalizeEscrowDisbursement(uint64,bool,uint64[])void': void;
    'updateAkitaDAO(uint64)void': void;
    'opUp()void': void;
};
/**
 * Defines the types of available calls and state of the RevenueManagerPlugin smart contract.
 */
export type RevenueManagerPluginTypes = {
    /**
     * Maps method signatures / names to their argument and return types.
     */
    methods: Record<'create(string,uint64)void' | 'create', {
        argsObj: RevenueManagerPluginArgs['obj']['create(string,uint64)void'];
        argsTuple: RevenueManagerPluginArgs['tuple']['create(string,uint64)void'];
        returns: RevenueManagerPluginReturns['create(string,uint64)void'];
    }> & Record<'optIn(uint64,bool,uint64[],pay)void' | 'optIn', {
        argsObj: RevenueManagerPluginArgs['obj']['optIn(uint64,bool,uint64[],pay)void'];
        argsTuple: RevenueManagerPluginArgs['tuple']['optIn(uint64,bool,uint64[],pay)void'];
        returns: RevenueManagerPluginReturns['optIn(uint64,bool,uint64[],pay)void'];
    }> & Record<'newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void' | 'newReceiveEscrow', {
        argsObj: RevenueManagerPluginArgs['obj']['newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void'];
        argsTuple: RevenueManagerPluginArgs['tuple']['newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void'];
        returns: RevenueManagerPluginReturns['newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void'];
    }> & Record<'newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void' | 'newReceiveEscrowWithRef', {
        argsObj: RevenueManagerPluginArgs['obj']['newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void'];
        argsTuple: RevenueManagerPluginArgs['tuple']['newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void'];
        returns: RevenueManagerPluginReturns['newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void'];
    }> & Record<'startEscrowDisbursement(uint64,bool)void' | 'startEscrowDisbursement', {
        argsObj: RevenueManagerPluginArgs['obj']['startEscrowDisbursement(uint64,bool)void'];
        argsTuple: RevenueManagerPluginArgs['tuple']['startEscrowDisbursement(uint64,bool)void'];
        returns: RevenueManagerPluginReturns['startEscrowDisbursement(uint64,bool)void'];
    }> & Record<'processEscrowAllocation(uint64,bool,uint64[])void' | 'processEscrowAllocation', {
        argsObj: RevenueManagerPluginArgs['obj']['processEscrowAllocation(uint64,bool,uint64[])void'];
        argsTuple: RevenueManagerPluginArgs['tuple']['processEscrowAllocation(uint64,bool,uint64[])void'];
        returns: RevenueManagerPluginReturns['processEscrowAllocation(uint64,bool,uint64[])void'];
    }> & Record<'finalizeEscrowDisbursement(uint64,bool,uint64[])void' | 'finalizeEscrowDisbursement', {
        argsObj: RevenueManagerPluginArgs['obj']['finalizeEscrowDisbursement(uint64,bool,uint64[])void'];
        argsTuple: RevenueManagerPluginArgs['tuple']['finalizeEscrowDisbursement(uint64,bool,uint64[])void'];
        returns: RevenueManagerPluginReturns['finalizeEscrowDisbursement(uint64,bool,uint64[])void'];
    }> & Record<'updateAkitaDAO(uint64)void' | 'updateAkitaDAO', {
        argsObj: RevenueManagerPluginArgs['obj']['updateAkitaDAO(uint64)void'];
        argsTuple: RevenueManagerPluginArgs['tuple']['updateAkitaDAO(uint64)void'];
        returns: RevenueManagerPluginReturns['updateAkitaDAO(uint64)void'];
    }> & Record<'opUp()void' | 'opUp', {
        argsObj: RevenueManagerPluginArgs['obj']['opUp()void'];
        argsTuple: RevenueManagerPluginArgs['tuple']['opUp()void'];
        returns: RevenueManagerPluginReturns['opUp()void'];
    }>;
    /**
     * Defines the shape of the state of the application.
     */
    state: {
        global: {
            keys: {
                /**
                 * the current version of the contract
                 */
                version: string;
                /**
                 * the app ID of the Akita DAO
                 */
                akitaDao: bigint;
            };
            maps: {};
        };
        box: {
            keys: {};
            maps: {
                /**
                 * box map of all the escrows
                 */
                escrows: Map<WalletEscrowKey, ReceiveEscrow>;
                /**
                 * box map of escrow assets that have already been processed during this allocation
                 */
                receiveAssets: Map<EscrowAssetKey, Uint8Array>;
                /**
                 * how to split revenue & where to send it
                 */
                splits: Map<WalletEscrowKey, [[bigint, string], number, bigint][]>;
                /**
                 * references to splits stored in other contracts (alternative to direct splits)
                 */
                splitRefs: Map<WalletEscrowKey, SplitRef>;
            };
        };
    };
};
/**
 * Defines the possible abi call signatures.
 */
export type RevenueManagerPluginSignatures = keyof RevenueManagerPluginTypes['methods'];
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> & {
    /** The args for the ABI method call, either as an ordered array or an object */
    args: Expand<TArgs>;
}>;
/**
 * Maps a method signature from the RevenueManagerPlugin smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends RevenueManagerPluginSignatures> = RevenueManagerPluginTypes['methods'][TSignature]['argsObj' | 'argsTuple'];
/**
 * Maps a method signature from the RevenueManagerPlugin smart contract to the method's return type
 */
export type MethodReturn<TSignature extends RevenueManagerPluginSignatures> = RevenueManagerPluginTypes['methods'][TSignature]['returns'];
/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = RevenueManagerPluginTypes['state']['global']['keys'];
/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = RevenueManagerPluginTypes['state']['box']['keys'];
/**
 * Defines supported create method params for this smart contract
 */
export type RevenueManagerPluginCreateCallParams = Expand<CallParams<RevenueManagerPluginArgs['obj']['create(string,uint64)void'] | RevenueManagerPluginArgs['tuple']['create(string,uint64)void']> & {
    method: 'create';
} & {
    onComplete?: OnApplicationComplete.NoOpOC;
} & CreateSchema> | Expand<CallParams<RevenueManagerPluginArgs['obj']['create(string,uint64)void'] | RevenueManagerPluginArgs['tuple']['create(string,uint64)void']> & {
    method: 'create(string,uint64)void';
} & {
    onComplete?: OnApplicationComplete.NoOpOC;
} & CreateSchema>;
/**
 * Defines arguments required for the deploy method.
 */
export type RevenueManagerPluginDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
    /**
     * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
     */
    createParams?: RevenueManagerPluginCreateCallParams;
}>;
/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the RevenueManagerPlugin smart contract
 */
export declare abstract class RevenueManagerPluginParamsFactory {
    /**
     * Gets available create ABI call param factories
     */
    static get create(): {
        _resolveByMethod<TParams extends RevenueManagerPluginCreateCallParams & {
            method: string;
        }>(params: TParams): {
            maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            signer?: (TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount) | undefined;
            rekeyTo?: (string | Address) | undefined;
            note?: (Uint8Array | string) | undefined;
            lease?: (Uint8Array | string) | undefined;
            staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            validityWindow?: number | bigint | undefined;
            firstValidRound?: bigint | undefined;
            lastValidRound?: bigint | undefined;
            onComplete?: OnApplicationComplete | undefined;
            accountReferences?: (string | Address)[] | undefined;
            appReferences?: bigint[] | undefined;
            assetReferences?: bigint[] | undefined;
            boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference | import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier)[] | undefined;
            sender?: (Address | string) | undefined;
            method: string;
            args?: (import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | AppMethodCallTransactionArgument | undefined)[] | undefined;
        } & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        };
        /**
         * Constructs create ABI call params for the RevenueManagerPlugin smart contract using the create(string,uint64)void ABI method
         *
         * @param params Parameters for the call
         * @returns An `AppClientMethodCallParams` object for the call
         */
        create(params: CallParams<RevenueManagerPluginArgs["obj"]["create(string,uint64)void"] | RevenueManagerPluginArgs["tuple"]["create(string,uint64)void"]> & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }): AppClientMethodCallParams & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        };
    };
    /**
     * Constructs a no op call for the optIn(uint64,bool,uint64[],pay)void ABI method
     *
    * optin exists because revenue manager uses additional metadata to track optin counts for processing payments
    revenue escrows must be locked to avoid mistracking optins to ensure all opted in assets get processed
  
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static optIn(params: CallParams<RevenueManagerPluginArgs['obj']['optIn(uint64,bool,uint64[],pay)void'] | RevenueManagerPluginArgs['tuple']['optIn(uint64,bool,uint64[],pay)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void ABI method
     *
    * Creates a new receive escrow with direct splits
    Use this when you want to store splits directly in this contract
  
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static newReceiveEscrow(params: CallParams<RevenueManagerPluginArgs['obj']['newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void'] | RevenueManagerPluginArgs['tuple']['newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void ABI method
     *
    * Creates a new receive escrow with a reference to splits stored in another contract
    Use this when you want splits to be dynamically read from another contract's global state
  
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static newReceiveEscrowWithRef(params: CallParams<RevenueManagerPluginArgs['obj']['newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void'] | RevenueManagerPluginArgs['tuple']['newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the startEscrowDisbursement(uint64,bool)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static startEscrowDisbursement(params: CallParams<RevenueManagerPluginArgs['obj']['startEscrowDisbursement(uint64,bool)void'] | RevenueManagerPluginArgs['tuple']['startEscrowDisbursement(uint64,bool)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the processEscrowAllocation(uint64,bool,uint64[])void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static processEscrowAllocation(params: CallParams<RevenueManagerPluginArgs['obj']['processEscrowAllocation(uint64,bool,uint64[])void'] | RevenueManagerPluginArgs['tuple']['processEscrowAllocation(uint64,bool,uint64[])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the finalizeEscrowDisbursement(uint64,bool,uint64[])void ABI method
     *
    * Cleans up processed asset boxes and resets escrow back to idle state
    Must be called after all assets have been processed (escrow in Finalization phase)
    Can be called in batches - pass the asset IDs that were processed to delete their tracking boxes
  
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static finalizeEscrowDisbursement(params: CallParams<RevenueManagerPluginArgs['obj']['finalizeEscrowDisbursement(uint64,bool,uint64[])void'] | RevenueManagerPluginArgs['tuple']['finalizeEscrowDisbursement(uint64,bool,uint64[])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the updateAkitaDAO(uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static updateAkitaDao(params: CallParams<RevenueManagerPluginArgs['obj']['updateAkitaDAO(uint64)void'] | RevenueManagerPluginArgs['tuple']['updateAkitaDAO(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the opUp()void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static opUp(params: CallParams<RevenueManagerPluginArgs['obj']['opUp()void'] | RevenueManagerPluginArgs['tuple']['opUp()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
}
/**
 * A factory to create and deploy one or more instance of the RevenueManagerPlugin smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export declare class RevenueManagerPluginFactory {
    /**
     * The underlying `AppFactory` for when you want to have more flexibility
     */
    readonly appFactory: _AppFactory;
    /**
     * Creates a new instance of `RevenueManagerPluginFactory`
     *
     * @param params The parameters to initialise the app factory with
     */
    constructor(params: Omit<AppFactoryParams, 'appSpec'>);
    /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
    get appName(): string;
    /** The ARC-56 app spec being used */
    get appSpec(): Arc56Contract;
    /** A reference to the underlying `AlgorandClient` this app factory is using. */
    get algorand(): AlgorandClient;
    /**
     * Returns a new `AppClient` client for an app instance of the given ID.
     *
     * Automatically populates appName, defaultSender and source maps from the factory
     * if not specified in the params.
     * @param params The parameters to create the app client
     * @returns The `AppClient`
     */
    getAppClientById(params: AppFactoryAppClientParams): RevenueManagerPluginClient;
    /**
     * Returns a new `AppClient` client, resolving the app by creator address and name
     * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
     *
     * Automatically populates appName, defaultSender and source maps from the factory
     * if not specified in the params.
     * @param params The parameters to create the app client
     * @returns The `AppClient`
     */
    getAppClientByCreatorAndName(params: AppFactoryResolveAppClientByCreatorAndNameParams): Promise<RevenueManagerPluginClient>;
    /**
     * Idempotently deploys the RevenueManagerPlugin smart contract.
     *
     * @param params The arguments for the contract calls and any additional parameters for the call
     * @returns The deployment result
     */
    deploy(params?: RevenueManagerPluginDeployParams): Promise<{
        result: {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "create";
            version: string;
            name: string;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            appId: bigint;
            appAddress: Address;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "update";
            appId: bigint;
            appAddress: Address;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            name: string;
            version: string;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "replace";
            version: string;
            name: string;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            appId: bigint;
            appAddress: Address;
            deleteResult: import("@algorandfoundation/algokit-utils/types/transaction").ConfirmedTransactionResult;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "nothing";
            appId: bigint;
            appAddress: Address;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            name: string;
            version: string;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
        };
        appClient: RevenueManagerPluginClient;
    }>;
    /**
     * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
     */
    readonly params: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the RevenueManagerPlugin smart contract using the create(string,uint64)void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The create params
             */
            create: (params: CallParams<RevenueManagerPluginArgs["obj"]["create(string,uint64)void"] | RevenueManagerPluginArgs["tuple"]["create(string,uint64)void"]> & AppClientCompilationParams & CreateSchema & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                deployTimeParams: import("@algorandfoundation/algokit-utils/types/app").TealTemplateParams | undefined;
                schema: {
                    globalInts: number;
                    globalByteSlices: number;
                    localInts: number;
                    localByteSlices: number;
                };
                approvalProgram: Uint8Array;
                clearStateProgram: Uint8Array;
                maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                note?: string | Uint8Array | undefined;
                signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                lease?: string | Uint8Array | undefined;
                rekeyTo?: string | Address | undefined;
                staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                validityWindow?: number | bigint | undefined;
                firstValidRound?: bigint | undefined;
                lastValidRound?: bigint | undefined;
                accountReferences?: (string | Address)[] | undefined;
                appReferences?: bigint[] | undefined;
                assetReferences?: bigint[] | undefined;
                boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                sender?: string | Address | undefined;
                method: string;
                args?: (import("algosdk").ABIValue | AppMethodCallTransactionArgument | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined)[] | undefined;
                updatable?: boolean | undefined;
                deletable?: boolean | undefined;
                extraProgramPages?: number | undefined;
            } & {
                sender: Address;
                signer: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                method: import("@algorandfoundation/algokit-utils/types/app-arc56").Arc56Method;
                args: (Transaction | import("algosdk").ABIValue | import("algosdk").TransactionWithSigner | Promise<Transaction> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    note?: string | Uint8Array | undefined;
                    args?: Uint8Array[] | undefined;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                    lease?: string | Uint8Array | undefined;
                    rekeyTo?: string | Address | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                    schema?: {
                        globalInts: number;
                        globalByteSlices: number;
                        localInts: number;
                        localByteSlices: number;
                    } | undefined;
                    extraProgramPages?: number | undefined;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    rekeyTo?: string | Address | undefined;
                    note?: string | Uint8Array | undefined;
                    lease?: string | Uint8Array | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    appId: bigint;
                    onComplete?: OnApplicationComplete.UpdateApplicationOC | undefined;
                    args?: Uint8Array[] | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<import("@algorandfoundation/algokit-utils/types/composer").AppMethodCallParams> | undefined)[] | undefined;
                onComplete: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC;
            }>;
        };
    };
    /**
     * Create transactions for the current app
     */
    readonly createTransaction: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the RevenueManagerPlugin smart contract using the create(string,uint64)void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The create transaction
             */
            create: (params: CallParams<RevenueManagerPluginArgs["obj"]["create(string,uint64)void"] | RevenueManagerPluginArgs["tuple"]["create(string,uint64)void"]> & AppClientCompilationParams & CreateSchema & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                transactions: Transaction[];
                methodCalls: Map<number, import("algosdk").ABIMethod>;
                signers: Map<number, TransactionSigner>;
            }>;
        };
    };
    /**
     * Send calls to the current app
     */
    readonly send: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the RevenueManagerPlugin smart contract using an ABI method call using the create(string,uint64)void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The create result
             */
            create: (params: CallParams<RevenueManagerPluginArgs["obj"]["create(string,uint64)void"] | RevenueManagerPluginArgs["tuple"]["create(string,uint64)void"]> & AppClientCompilationParams & CreateSchema & SendParams & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                result: {
                    return: (undefined | RevenueManagerPluginReturns["create(string,uint64)void"]);
                    compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                    compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                    appId: bigint;
                    groupId: string;
                    txIds: string[];
                    returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
                    confirmations: modelsv2.PendingTransactionResponse[];
                    transactions: Transaction[];
                    confirmation: modelsv2.PendingTransactionResponse;
                    transaction: Transaction;
                    appAddress: Address;
                };
                appClient: RevenueManagerPluginClient;
            }>;
        };
    };
}
/**
 * A client to make calls to the RevenueManagerPlugin smart contract
 */
export declare class RevenueManagerPluginClient {
    /**
     * The underlying `AppClient` for when you want to have more flexibility
     */
    readonly appClient: _AppClient;
    /**
     * Creates a new instance of `RevenueManagerPluginClient`
     *
     * @param appClient An `AppClient` instance which has been created with the RevenueManagerPlugin app spec
     */
    constructor(appClient: _AppClient);
    /**
     * Creates a new instance of `RevenueManagerPluginClient`
     *
     * @param params The parameters to initialise the app client with
     */
    constructor(params: Omit<AppClientParams, 'appSpec'>);
    /**
     * Returns a new `RevenueManagerPluginClient` client, resolving the app by creator address and name
     * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
     * @param params The parameters to create the app client
     */
    static fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<RevenueManagerPluginClient>;
    /**
     * Returns an `RevenueManagerPluginClient` instance for the current network based on
     * pre-determined network-specific app IDs specified in the ARC-56 app spec.
     *
     * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
     * @param params The parameters to create the app client
     */
    static fromNetwork(params: Omit<ResolveAppClientByNetwork, 'appSpec'>): Promise<RevenueManagerPluginClient>;
    /** The ID of the app instance this client is linked to. */
    get appId(): bigint;
    /** The app address of the app instance this client is linked to. */
    get appAddress(): Address;
    /** The name of the app. */
    get appName(): string;
    /** The ARC-56 app spec being used */
    get appSpec(): Arc56Contract;
    /** A reference to the underlying `AlgorandClient` this app client is using. */
    get algorand(): AlgorandClient;
    /**
     * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
     */
    readonly params: {
        /**
         * Makes a clear_state call to an existing instance of the RevenueManagerPlugin smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams>) => import("@algorandfoundation/algokit-utils/types/composer").AppCallParams;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `optIn(uint64,bool,uint64[],pay)void` ABI method.
         *
        * optin exists because revenue manager uses additional metadata to track optin counts for processing payments
        revenue escrows must be locked to avoid mistracking optins to ensure all opted in assets get processed
    
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        optIn: (params: CallParams<RevenueManagerPluginArgs["obj"]["optIn(uint64,bool,uint64[],pay)void"] | RevenueManagerPluginArgs["tuple"]["optIn(uint64,bool,uint64[],pay)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void` ABI method.
         *
        * Creates a new receive escrow with direct splits
        Use this when you want to store splits directly in this contract
    
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        newReceiveEscrow: (params: CallParams<RevenueManagerPluginArgs["obj"]["newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void"] | RevenueManagerPluginArgs["tuple"]["newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void` ABI method.
         *
        * Creates a new receive escrow with a reference to splits stored in another contract
        Use this when you want splits to be dynamically read from another contract's global state
    
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        newReceiveEscrowWithRef: (params: CallParams<RevenueManagerPluginArgs["obj"]["newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void"] | RevenueManagerPluginArgs["tuple"]["newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `startEscrowDisbursement(uint64,bool)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        startEscrowDisbursement: (params: CallParams<RevenueManagerPluginArgs["obj"]["startEscrowDisbursement(uint64,bool)void"] | RevenueManagerPluginArgs["tuple"]["startEscrowDisbursement(uint64,bool)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `processEscrowAllocation(uint64,bool,uint64[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        processEscrowAllocation: (params: CallParams<RevenueManagerPluginArgs["obj"]["processEscrowAllocation(uint64,bool,uint64[])void"] | RevenueManagerPluginArgs["tuple"]["processEscrowAllocation(uint64,bool,uint64[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `finalizeEscrowDisbursement(uint64,bool,uint64[])void` ABI method.
         *
        * Cleans up processed asset boxes and resets escrow back to idle state
        Must be called after all assets have been processed (escrow in Finalization phase)
        Can be called in batches - pass the asset IDs that were processed to delete their tracking boxes
    
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        finalizeEscrowDisbursement: (params: CallParams<RevenueManagerPluginArgs["obj"]["finalizeEscrowDisbursement(uint64,bool,uint64[])void"] | RevenueManagerPluginArgs["tuple"]["finalizeEscrowDisbursement(uint64,bool,uint64[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        updateAkitaDao: (params: CallParams<RevenueManagerPluginArgs["obj"]["updateAkitaDAO(uint64)void"] | RevenueManagerPluginArgs["tuple"]["updateAkitaDAO(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `opUp()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        opUp: (params?: CallParams<RevenueManagerPluginArgs["obj"]["opUp()void"] | RevenueManagerPluginArgs["tuple"]["opUp()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
    };
    /**
     * Create transactions for the current app
     */
    readonly createTransaction: {
        /**
         * Makes a clear_state call to an existing instance of the RevenueManagerPlugin smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams>) => Promise<Transaction>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `optIn(uint64,bool,uint64[],pay)void` ABI method.
         *
        * optin exists because revenue manager uses additional metadata to track optin counts for processing payments
        revenue escrows must be locked to avoid mistracking optins to ensure all opted in assets get processed
    
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        optIn: (params: CallParams<RevenueManagerPluginArgs["obj"]["optIn(uint64,bool,uint64[],pay)void"] | RevenueManagerPluginArgs["tuple"]["optIn(uint64,bool,uint64[],pay)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void` ABI method.
         *
        * Creates a new receive escrow with direct splits
        Use this when you want to store splits directly in this contract
    
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        newReceiveEscrow: (params: CallParams<RevenueManagerPluginArgs["obj"]["newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void"] | RevenueManagerPluginArgs["tuple"]["newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void` ABI method.
         *
        * Creates a new receive escrow with a reference to splits stored in another contract
        Use this when you want splits to be dynamically read from another contract's global state
    
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        newReceiveEscrowWithRef: (params: CallParams<RevenueManagerPluginArgs["obj"]["newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void"] | RevenueManagerPluginArgs["tuple"]["newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `startEscrowDisbursement(uint64,bool)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        startEscrowDisbursement: (params: CallParams<RevenueManagerPluginArgs["obj"]["startEscrowDisbursement(uint64,bool)void"] | RevenueManagerPluginArgs["tuple"]["startEscrowDisbursement(uint64,bool)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `processEscrowAllocation(uint64,bool,uint64[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        processEscrowAllocation: (params: CallParams<RevenueManagerPluginArgs["obj"]["processEscrowAllocation(uint64,bool,uint64[])void"] | RevenueManagerPluginArgs["tuple"]["processEscrowAllocation(uint64,bool,uint64[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `finalizeEscrowDisbursement(uint64,bool,uint64[])void` ABI method.
         *
        * Cleans up processed asset boxes and resets escrow back to idle state
        Must be called after all assets have been processed (escrow in Finalization phase)
        Can be called in batches - pass the asset IDs that were processed to delete their tracking boxes
    
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        finalizeEscrowDisbursement: (params: CallParams<RevenueManagerPluginArgs["obj"]["finalizeEscrowDisbursement(uint64,bool,uint64[])void"] | RevenueManagerPluginArgs["tuple"]["finalizeEscrowDisbursement(uint64,bool,uint64[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        updateAkitaDao: (params: CallParams<RevenueManagerPluginArgs["obj"]["updateAkitaDAO(uint64)void"] | RevenueManagerPluginArgs["tuple"]["updateAkitaDAO(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `opUp()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        opUp: (params?: CallParams<RevenueManagerPluginArgs["obj"]["opUp()void"] | RevenueManagerPluginArgs["tuple"]["opUp()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
    };
    /**
     * Send calls to the current app
     */
    readonly send: {
        /**
         * Makes a clear_state call to an existing instance of the RevenueManagerPlugin smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => Promise<{
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            return?: ABIReturn | undefined;
        }>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `optIn(uint64,bool,uint64[],pay)void` ABI method.
         *
        * optin exists because revenue manager uses additional metadata to track optin counts for processing payments
        revenue escrows must be locked to avoid mistracking optins to ensure all opted in assets get processed
    
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        optIn: (params: CallParams<RevenueManagerPluginArgs["obj"]["optIn(uint64,bool,uint64[],pay)void"] | RevenueManagerPluginArgs["tuple"]["optIn(uint64,bool,uint64[],pay)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | RevenueManagerPluginReturns["optIn(uint64,bool,uint64[],pay)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void` ABI method.
         *
        * Creates a new receive escrow with direct splits
        Use this when you want to store splits directly in this contract
    
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        newReceiveEscrow: (params: CallParams<RevenueManagerPluginArgs["obj"]["newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void"] | RevenueManagerPluginArgs["tuple"]["newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | RevenueManagerPluginReturns["newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void` ABI method.
         *
        * Creates a new receive escrow with a reference to splits stored in another contract
        Use this when you want splits to be dynamically read from another contract's global state
    
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        newReceiveEscrowWithRef: (params: CallParams<RevenueManagerPluginArgs["obj"]["newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void"] | RevenueManagerPluginArgs["tuple"]["newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | RevenueManagerPluginReturns["newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `startEscrowDisbursement(uint64,bool)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        startEscrowDisbursement: (params: CallParams<RevenueManagerPluginArgs["obj"]["startEscrowDisbursement(uint64,bool)void"] | RevenueManagerPluginArgs["tuple"]["startEscrowDisbursement(uint64,bool)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | RevenueManagerPluginReturns["startEscrowDisbursement(uint64,bool)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `processEscrowAllocation(uint64,bool,uint64[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        processEscrowAllocation: (params: CallParams<RevenueManagerPluginArgs["obj"]["processEscrowAllocation(uint64,bool,uint64[])void"] | RevenueManagerPluginArgs["tuple"]["processEscrowAllocation(uint64,bool,uint64[])void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | RevenueManagerPluginReturns["processEscrowAllocation(uint64,bool,uint64[])void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `finalizeEscrowDisbursement(uint64,bool,uint64[])void` ABI method.
         *
        * Cleans up processed asset boxes and resets escrow back to idle state
        Must be called after all assets have been processed (escrow in Finalization phase)
        Can be called in batches - pass the asset IDs that were processed to delete their tracking boxes
    
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        finalizeEscrowDisbursement: (params: CallParams<RevenueManagerPluginArgs["obj"]["finalizeEscrowDisbursement(uint64,bool,uint64[])void"] | RevenueManagerPluginArgs["tuple"]["finalizeEscrowDisbursement(uint64,bool,uint64[])void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | RevenueManagerPluginReturns["finalizeEscrowDisbursement(uint64,bool,uint64[])void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `updateAkitaDAO(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        updateAkitaDao: (params: CallParams<RevenueManagerPluginArgs["obj"]["updateAkitaDAO(uint64)void"] | RevenueManagerPluginArgs["tuple"]["updateAkitaDAO(uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | RevenueManagerPluginReturns["updateAkitaDAO(uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the RevenueManagerPlugin smart contract using the `opUp()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        opUp: (params?: CallParams<RevenueManagerPluginArgs["obj"]["opUp()void"] | RevenueManagerPluginArgs["tuple"]["opUp()void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | RevenueManagerPluginReturns["opUp()void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
    };
    /**
     * Clone this app client with different params
     *
     * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
     * @returns A new app client with the altered params
     */
    clone(params: CloneAppClientParams): RevenueManagerPluginClient;
    /**
     * Methods to access state for the current RevenueManagerPlugin app
     */
    state: {
        /**
         * Methods to access global state for the current RevenueManagerPlugin app
         */
        global: {
            /**
             * Get all current keyed values from global state
             */
            getAll: () => Promise<Partial<Expand<GlobalKeysState>>>;
            /**
             * Get the current value of the version key in global state
             */
            version: () => Promise<string | undefined>;
            /**
             * Get the current value of the akitaDAO key in global state
             */
            akitaDao: () => Promise<bigint | undefined>;
        };
        /**
         * Methods to access box state for the current RevenueManagerPlugin app
         */
        box: {
            /**
             * Get all current keyed values from box state
             */
            getAll: () => Promise<Partial<Expand<BoxKeysState>>>;
            /**
             * Get values from the escrows map in box state
             */
            escrows: {
                /**
                 * Get all current values of the escrows map in box state
                 */
                getMap: () => Promise<Map<WalletEscrowKey, ReceiveEscrow>>;
                /**
                 * Get a current value of the escrows map by key from box state
                 */
                value: (key: WalletEscrowKey) => Promise<ReceiveEscrow | undefined>;
            };
            /**
             * Get values from the receiveAssets map in box state
             */
            receiveAssets: {
                /**
                 * Get all current values of the receiveAssets map in box state
                 */
                getMap: () => Promise<Map<EscrowAssetKey, Uint8Array>>;
                /**
                 * Get a current value of the receiveAssets map by key from box state
                 */
                value: (key: EscrowAssetKey) => Promise<Uint8Array | undefined>;
            };
            /**
             * Get values from the splits map in box state
             */
            splits: {
                /**
                 * Get all current values of the splits map in box state
                 */
                getMap: () => Promise<Map<WalletEscrowKey, [[bigint, string], number, bigint][]>>;
                /**
                 * Get a current value of the splits map by key from box state
                 */
                value: (key: WalletEscrowKey) => Promise<[[bigint, string], number, bigint][] | undefined>;
            };
            /**
             * Get values from the splitRefs map in box state
             */
            splitRefs: {
                /**
                 * Get all current values of the splitRefs map in box state
                 */
                getMap: () => Promise<Map<WalletEscrowKey, SplitRef>>;
                /**
                 * Get a current value of the splitRefs map by key from box state
                 */
                value: (key: WalletEscrowKey) => Promise<SplitRef | undefined>;
            };
        };
    };
    newGroup(): RevenueManagerPluginComposer;
}
export type RevenueManagerPluginComposer<TReturns extends [...any[]] = []> = {
    /**
     * Calls the optIn(uint64,bool,uint64[],pay)void ABI method.
     *
    * optin exists because revenue manager uses additional metadata to track optin counts for processing payments
    revenue escrows must be locked to avoid mistracking optins to ensure all opted in assets get processed
  
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    optIn(params?: CallParams<RevenueManagerPluginArgs['obj']['optIn(uint64,bool,uint64[],pay)void'] | RevenueManagerPluginArgs['tuple']['optIn(uint64,bool,uint64[],pay)void']>): RevenueManagerPluginComposer<[...TReturns, RevenueManagerPluginReturns['optIn(uint64,bool,uint64[],pay)void'] | undefined]>;
    /**
     * Calls the newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void ABI method.
     *
    * Creates a new receive escrow with direct splits
    Use this when you want to store splits directly in this contract
  
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    newReceiveEscrow(params?: CallParams<RevenueManagerPluginArgs['obj']['newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void'] | RevenueManagerPluginArgs['tuple']['newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void']>): RevenueManagerPluginComposer<[...TReturns, RevenueManagerPluginReturns['newReceiveEscrow(uint64,bool,string,address,bool,bool,((uint64,string),uint8,uint64)[])void'] | undefined]>;
    /**
     * Calls the newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void ABI method.
     *
    * Creates a new receive escrow with a reference to splits stored in another contract
    Use this when you want splits to be dynamically read from another contract's global state
  
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    newReceiveEscrowWithRef(params?: CallParams<RevenueManagerPluginArgs['obj']['newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void'] | RevenueManagerPluginArgs['tuple']['newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void']>): RevenueManagerPluginComposer<[...TReturns, RevenueManagerPluginReturns['newReceiveEscrowWithRef(uint64,bool,string,address,bool,bool,(uint64,byte[]))void'] | undefined]>;
    /**
     * Calls the startEscrowDisbursement(uint64,bool)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    startEscrowDisbursement(params?: CallParams<RevenueManagerPluginArgs['obj']['startEscrowDisbursement(uint64,bool)void'] | RevenueManagerPluginArgs['tuple']['startEscrowDisbursement(uint64,bool)void']>): RevenueManagerPluginComposer<[...TReturns, RevenueManagerPluginReturns['startEscrowDisbursement(uint64,bool)void'] | undefined]>;
    /**
     * Calls the processEscrowAllocation(uint64,bool,uint64[])void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    processEscrowAllocation(params?: CallParams<RevenueManagerPluginArgs['obj']['processEscrowAllocation(uint64,bool,uint64[])void'] | RevenueManagerPluginArgs['tuple']['processEscrowAllocation(uint64,bool,uint64[])void']>): RevenueManagerPluginComposer<[...TReturns, RevenueManagerPluginReturns['processEscrowAllocation(uint64,bool,uint64[])void'] | undefined]>;
    /**
     * Calls the finalizeEscrowDisbursement(uint64,bool,uint64[])void ABI method.
     *
    * Cleans up processed asset boxes and resets escrow back to idle state
    Must be called after all assets have been processed (escrow in Finalization phase)
    Can be called in batches - pass the asset IDs that were processed to delete their tracking boxes
  
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    finalizeEscrowDisbursement(params?: CallParams<RevenueManagerPluginArgs['obj']['finalizeEscrowDisbursement(uint64,bool,uint64[])void'] | RevenueManagerPluginArgs['tuple']['finalizeEscrowDisbursement(uint64,bool,uint64[])void']>): RevenueManagerPluginComposer<[...TReturns, RevenueManagerPluginReturns['finalizeEscrowDisbursement(uint64,bool,uint64[])void'] | undefined]>;
    /**
     * Calls the updateAkitaDAO(uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    updateAkitaDao(params?: CallParams<RevenueManagerPluginArgs['obj']['updateAkitaDAO(uint64)void'] | RevenueManagerPluginArgs['tuple']['updateAkitaDAO(uint64)void']>): RevenueManagerPluginComposer<[...TReturns, RevenueManagerPluginReturns['updateAkitaDAO(uint64)void'] | undefined]>;
    /**
     * Calls the opUp()void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    opUp(params?: CallParams<RevenueManagerPluginArgs['obj']['opUp()void'] | RevenueManagerPluginArgs['tuple']['opUp()void']>): RevenueManagerPluginComposer<[...TReturns, RevenueManagerPluginReturns['opUp()void'] | undefined]>;
    /**
     * Makes a clear_state call to an existing instance of the RevenueManagerPlugin smart contract.
     *
     * @param args The arguments for the bare call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    clearState(params?: AppClientBareCallParams): RevenueManagerPluginComposer<[...TReturns, undefined]>;
    /**
     * Adds a transaction to the composer
     *
     * @param txn A transaction to add to the transaction group
     * @param signer The optional signer to use when signing this transaction.
     */
    addTransaction(txn: Transaction, signer?: TransactionSigner): RevenueManagerPluginComposer<TReturns>;
    /**
     * Returns the underlying AtomicTransactionComposer instance
     */
    composer(): Promise<TransactionComposer>;
    /**
     * Simulates the transaction group and returns the result
     */
    simulate(): Promise<RevenueManagerPluginComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    simulate(options: SkipSignaturesSimulateOptions): Promise<RevenueManagerPluginComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    simulate(options: RawSimulateOptions): Promise<RevenueManagerPluginComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    /**
     * Sends the transaction group to the network and returns the results
     */
    send(params?: SendParams): Promise<RevenueManagerPluginComposerResults<TReturns>>;
};
export type RevenueManagerPluginComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
    returns: TReturns;
}>;
