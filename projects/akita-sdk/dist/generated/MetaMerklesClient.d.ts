/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client';
import { ABIReturn } from '@algorandfoundation/algokit-utils/types/app';
import { Arc56Contract } from '@algorandfoundation/algokit-utils/types/app-arc56';
import { AppClient as _AppClient, AppClientMethodCallParams, AppClientParams, AppClientBareCallParams, CallOnComplete, AppClientCompilationParams, ResolveAppClientByCreatorAndName, ResolveAppClientByNetwork, CloneAppClientParams } from '@algorandfoundation/algokit-utils/types/app-client';
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory';
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer';
import { SendParams, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction';
import { Address, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk';
export declare const APP_SPEC: Arc56Contract;
/**
 * A state record containing binary data
 */
export interface BinaryState {
    /**
     * Gets the state value as a Uint8Array
     */
    asByteArray(): Uint8Array | undefined;
    /**
     * Gets the state value as a string
     */
    asString(): string | undefined;
}
/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R ? (...args: Expand<A>) => Expand<R> : T extends infer O ? {
    [K in keyof O]: O[K];
} : never;
export type DataKey = {
    address: Uint8Array;
    name: string;
    key: string;
};
/**
 * Converts the ABI tuple representation of a DataKey to the struct representation
 */
export declare function DataKeyFromTuple(abiTuple: [Uint8Array, string, string]): DataKey;
export type RootKey = {
    address: string;
    name: string;
};
/**
 * Converts the ABI tuple representation of a RootKey to the struct representation
 */
export declare function RootKeyFromTuple(abiTuple: [string, string]): RootKey;
export type TypesValue = {
    schema: string;
    description: string;
};
/**
 * Converts the ABI tuple representation of a TypesValue to the struct representation
 */
export declare function TypesValueFromTuple(abiTuple: [string, string]): TypesValue;
/**
 * The argument types for the MetaMerkles contract
 */
export type MetaMerklesArgs = {
    /**
     * The object representation of the arguments for each method
     */
    obj: {
        'create()void': Record<string, never>;
        'addRoot(pay,string,byte[32],uint64)void': {
            payment: AppMethodCallTransactionArgument;
            /**
             * the name alias of the root being added
             */
            name: string;
            /**
             * a merkle tree root
             */
            root: Uint8Array;
            /**
             * an index of the tree type enum from box storage
             */
            type: bigint | number;
        };
        'deleteRoot(string)void': {
            /**
             * the name of the merkle tree root
             */
            name: string;
        };
        'updateRoot(string,byte[32])void': {
            /**
             * the name of the merkle group data
             */
            name: string;
            /**
             * the new 32 byte merkle tree root
             */
            newRoot: Uint8Array;
        };
        'addData(pay,string,string,string)void': {
            payment: AppMethodCallTransactionArgument;
            /**
             * the name of the merkle tree root
             */
            name: string;
            /**
             * the metadata key eg. `Royalty`
             */
            key: string;
            /**
             * the metadata value eg. `5` encoded as a bytestring for 5%
             */
            value: string;
        };
        'deleteData(string,string)void': {
            /**
             * the name of the merkle tree root
             */
            name: string;
            /**
             * the metadata key you want to remove
             */
            key: string;
        };
        'verify(address,string,byte[32],byte[32][],uint64)bool': {
            /**
             * the address of the merkle tree root creator
             */
            address: string;
            /**
             * The name alias of the root
             */
            name: string;
            /**
             * The hashed leaf to verify
             */
            leaf: Uint8Array;
            /**
             * The merkle proof
             */
            proof: Uint8Array[];
            /**
             * The type check for the lists purpose
             */
            type: bigint | number;
        };
        'read(address,string,string)string': {
            /**
             * the address of the merkle tree root creator
             */
            address: string;
            /**
             * the name of the merkle tree root
             */
            name: string;
            /**
             * the metadata key eg. `Royalty`
             */
            key: string;
        };
        'verifiedRead(address,string,byte[32],byte[32][],uint64,string)string': {
            /**
             * the address of the merkle tree root creator
             */
            address: string;
            /**
             * the name of the root
             */
            name: string;
            /**
             * the leaf node to be verified
             */
            leaf: Uint8Array;
            /**
             * the proof the hash is included
             */
            proof: Uint8Array[];
            /**
            * the list type that helps contracts ensure
            the lists purpose isn't being misused ( 0 if the caller doesnt care )
      
             */
            type: bigint | number;
            /**
             * the metadata key eg. `Royalty`
             */
            key: string;
        };
        'verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string': {
            /**
             * the address of the merkle tree root creator
             */
            address: string;
            /**
             * the name of the root
             */
            name: string;
            /**
             * the leaf node to be verified
             */
            leaf: Uint8Array;
            /**
             * the proof the hash is included
             */
            proof: Uint8Array[];
            /**
            * the list type that helps contracts ensure
            the lists purpose isn't being misused ( 0 if the caller doesnt care )
      
             */
            type: bigint | number;
            /**
             * the metadata key eg. `Royalty`
             */
            key: string;
        };
        'addType(pay,string,uint8[])void': {
            payment: AppMethodCallTransactionArgument;
            description: string;
            schemaList: bigint[] | number[];
        };
        'rootCosts(string)uint64': {
            name: string;
        };
        'dataCosts(string,string,string)uint64': {
            name: string;
            key: string;
            value: string;
        };
    };
    /**
     * The tuple representation of the arguments for each method
     */
    tuple: {
        'create()void': [];
        'addRoot(pay,string,byte[32],uint64)void': [payment: AppMethodCallTransactionArgument, name: string, root: Uint8Array, type: bigint | number];
        'deleteRoot(string)void': [name: string];
        'updateRoot(string,byte[32])void': [name: string, newRoot: Uint8Array];
        'addData(pay,string,string,string)void': [payment: AppMethodCallTransactionArgument, name: string, key: string, value: string];
        'deleteData(string,string)void': [name: string, key: string];
        'verify(address,string,byte[32],byte[32][],uint64)bool': [address: string, name: string, leaf: Uint8Array, proof: Uint8Array[], type: bigint | number];
        'read(address,string,string)string': [address: string, name: string, key: string];
        'verifiedRead(address,string,byte[32],byte[32][],uint64,string)string': [address: string, name: string, leaf: Uint8Array, proof: Uint8Array[], type: bigint | number, key: string];
        'verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string': [address: string, name: string, leaf: Uint8Array, proof: Uint8Array[], type: bigint | number, key: string];
        'addType(pay,string,uint8[])void': [payment: AppMethodCallTransactionArgument, description: string, schemaList: bigint[] | number[]];
        'rootCosts(string)uint64': [name: string];
        'dataCosts(string,string,string)uint64': [name: string, key: string, value: string];
    };
};
/**
 * The return type for each method
 */
export type MetaMerklesReturns = {
    'create()void': void;
    'addRoot(pay,string,byte[32],uint64)void': void;
    'deleteRoot(string)void': void;
    'updateRoot(string,byte[32])void': void;
    'addData(pay,string,string,string)void': void;
    'deleteData(string,string)void': void;
    'verify(address,string,byte[32],byte[32][],uint64)bool': boolean;
    'read(address,string,string)string': string;
    'verifiedRead(address,string,byte[32],byte[32][],uint64,string)string': string;
    'verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string': string;
    'addType(pay,string,uint8[])void': void;
    'rootCosts(string)uint64': bigint;
    'dataCosts(string,string,string)uint64': bigint;
};
/**
 * Defines the types of available calls and state of the MetaMerkles smart contract.
 */
export type MetaMerklesTypes = {
    /**
     * Maps method signatures / names to their argument and return types.
     */
    methods: Record<'create()void' | 'create', {
        argsObj: MetaMerklesArgs['obj']['create()void'];
        argsTuple: MetaMerklesArgs['tuple']['create()void'];
        returns: MetaMerklesReturns['create()void'];
    }> & Record<'addRoot(pay,string,byte[32],uint64)void' | 'addRoot', {
        argsObj: MetaMerklesArgs['obj']['addRoot(pay,string,byte[32],uint64)void'];
        argsTuple: MetaMerklesArgs['tuple']['addRoot(pay,string,byte[32],uint64)void'];
        returns: MetaMerklesReturns['addRoot(pay,string,byte[32],uint64)void'];
    }> & Record<'deleteRoot(string)void' | 'deleteRoot', {
        argsObj: MetaMerklesArgs['obj']['deleteRoot(string)void'];
        argsTuple: MetaMerklesArgs['tuple']['deleteRoot(string)void'];
        returns: MetaMerklesReturns['deleteRoot(string)void'];
    }> & Record<'updateRoot(string,byte[32])void' | 'updateRoot', {
        argsObj: MetaMerklesArgs['obj']['updateRoot(string,byte[32])void'];
        argsTuple: MetaMerklesArgs['tuple']['updateRoot(string,byte[32])void'];
        returns: MetaMerklesReturns['updateRoot(string,byte[32])void'];
    }> & Record<'addData(pay,string,string,string)void' | 'addData', {
        argsObj: MetaMerklesArgs['obj']['addData(pay,string,string,string)void'];
        argsTuple: MetaMerklesArgs['tuple']['addData(pay,string,string,string)void'];
        returns: MetaMerklesReturns['addData(pay,string,string,string)void'];
    }> & Record<'deleteData(string,string)void' | 'deleteData', {
        argsObj: MetaMerklesArgs['obj']['deleteData(string,string)void'];
        argsTuple: MetaMerklesArgs['tuple']['deleteData(string,string)void'];
        returns: MetaMerklesReturns['deleteData(string,string)void'];
    }> & Record<'verify(address,string,byte[32],byte[32][],uint64)bool' | 'verify', {
        argsObj: MetaMerklesArgs['obj']['verify(address,string,byte[32],byte[32][],uint64)bool'];
        argsTuple: MetaMerklesArgs['tuple']['verify(address,string,byte[32],byte[32][],uint64)bool'];
        /**
         * a boolean indicating whether the proof is valid
         */
        returns: MetaMerklesReturns['verify(address,string,byte[32],byte[32][],uint64)bool'];
    }> & Record<'read(address,string,string)string' | 'read', {
        argsObj: MetaMerklesArgs['obj']['read(address,string,string)string'];
        argsTuple: MetaMerklesArgs['tuple']['read(address,string,string)string'];
        /**
         * the value set eg. `5` encoded as a bytestring for 5%
         */
        returns: MetaMerklesReturns['read(address,string,string)string'];
    }> & Record<'verifiedRead(address,string,byte[32],byte[32][],uint64,string)string' | 'verifiedRead', {
        argsObj: MetaMerklesArgs['obj']['verifiedRead(address,string,byte[32],byte[32][],uint64,string)string'];
        argsTuple: MetaMerklesArgs['tuple']['verifiedRead(address,string,byte[32],byte[32][],uint64,string)string'];
        /**
         * a string of metadata
         */
        returns: MetaMerklesReturns['verifiedRead(address,string,byte[32],byte[32][],uint64,string)string'];
    }> & Record<'verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string' | 'verifiedMustRead', {
        argsObj: MetaMerklesArgs['obj']['verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string'];
        argsTuple: MetaMerklesArgs['tuple']['verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string'];
        /**
         * a string of metadata
         */
        returns: MetaMerklesReturns['verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string'];
    }> & Record<'addType(pay,string,uint8[])void' | 'addType', {
        argsObj: MetaMerklesArgs['obj']['addType(pay,string,uint8[])void'];
        argsTuple: MetaMerklesArgs['tuple']['addType(pay,string,uint8[])void'];
        returns: MetaMerklesReturns['addType(pay,string,uint8[])void'];
    }> & Record<'rootCosts(string)uint64' | 'rootCosts', {
        argsObj: MetaMerklesArgs['obj']['rootCosts(string)uint64'];
        argsTuple: MetaMerklesArgs['tuple']['rootCosts(string)uint64'];
        returns: MetaMerklesReturns['rootCosts(string)uint64'];
    }> & Record<'dataCosts(string,string,string)uint64' | 'dataCosts', {
        argsObj: MetaMerklesArgs['obj']['dataCosts(string,string,string)uint64'];
        argsTuple: MetaMerklesArgs['tuple']['dataCosts(string,string,string)uint64'];
        returns: MetaMerklesReturns['dataCosts(string,string,string)uint64'];
    }>;
    /**
     * Defines the shape of the state of the application.
     */
    state: {
        global: {
            keys: {
                typesId: bigint;
            };
            maps: {};
        };
        box: {
            keys: {};
            maps: {
                /**
                 * the types (intents) of merkle trees that exist
                 */
                types: Map<bigint | number, TypesValue>;
                /**
                 * the merkle roots we want to attach data to
                 */
                roots: Map<RootKey, Uint8Array>;
                /**
                 * rootData is the box map for managing the data associated with a group
                 */
                data: Map<DataKey, string>;
            };
        };
    };
};
/**
 * Defines the possible abi call signatures.
 */
export type MetaMerklesSignatures = keyof MetaMerklesTypes['methods'];
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type MetaMerklesNonVoidMethodSignatures = keyof MetaMerklesTypes['methods'] extends infer T ? T extends keyof MetaMerklesTypes['methods'] ? MethodReturn<T> extends void ? never : T : never : never;
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> & {
    /** The args for the ABI method call, either as an ordered array or an object */
    args: Expand<TArgs>;
}>;
/**
 * Maps a method signature from the MetaMerkles smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends MetaMerklesSignatures> = MetaMerklesTypes['methods'][TSignature]['argsObj' | 'argsTuple'];
/**
 * Maps a method signature from the MetaMerkles smart contract to the method's return type
 */
export type MethodReturn<TSignature extends MetaMerklesSignatures> = MetaMerklesTypes['methods'][TSignature]['returns'];
/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = MetaMerklesTypes['state']['global']['keys'];
/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = MetaMerklesTypes['state']['box']['keys'];
/**
 * Defines supported create method params for this smart contract
 */
export type MetaMerklesCreateCallParams = Expand<CallParams<MetaMerklesArgs['obj']['create()void'] | MetaMerklesArgs['tuple']['create()void']> & {
    method: 'create';
} & {
    onComplete?: OnApplicationComplete.NoOpOC;
} & CreateSchema> | Expand<CallParams<MetaMerklesArgs['obj']['create()void'] | MetaMerklesArgs['tuple']['create()void']> & {
    method: 'create()void';
} & {
    onComplete?: OnApplicationComplete.NoOpOC;
} & CreateSchema>;
/**
 * Defines arguments required for the deploy method.
 */
export type MetaMerklesDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
    /**
     * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
     */
    createParams?: MetaMerklesCreateCallParams;
}>;
/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the MetaMerkles smart contract
 */
export declare abstract class MetaMerklesParamsFactory {
    /**
     * Gets available create ABI call param factories
     */
    static get create(): {
        _resolveByMethod<TParams extends MetaMerklesCreateCallParams & {
            method: string;
        }>(params: TParams): {
            maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            signer?: (TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount) | undefined;
            rekeyTo?: (string | Address) | undefined;
            note?: (Uint8Array | string) | undefined;
            lease?: (Uint8Array | string) | undefined;
            staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            validityWindow?: number | bigint | undefined;
            firstValidRound?: bigint | undefined;
            lastValidRound?: bigint | undefined;
            onComplete?: OnApplicationComplete | undefined;
            accountReferences?: (string | Address)[] | undefined;
            appReferences?: bigint[] | undefined;
            assetReferences?: bigint[] | undefined;
            boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference | import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier)[] | undefined;
            sender?: (Address | string) | undefined;
            method: string;
            args?: (import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | AppMethodCallTransactionArgument | undefined)[] | undefined;
        } & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        };
        /**
         * Constructs create ABI call params for the MetaMerkles smart contract using the create()void ABI method
         *
         * @param params Parameters for the call
         * @returns An `AppClientMethodCallParams` object for the call
         */
        create(params: CallParams<MetaMerklesArgs["obj"]["create()void"] | MetaMerklesArgs["tuple"]["create()void"]> & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }): AppClientMethodCallParams & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        };
    };
    /**
     * Constructs a no op call for the addRoot(pay,string,byte[32],uint64)void ABI method
     *
    * Creates two boxes and adds a merkle root
    using a `RootKey` to the root box map and also a list type to the
    metadata attached to the root in the data box map
  
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static addRoot(params: CallParams<MetaMerklesArgs['obj']['addRoot(pay,string,byte[32],uint64)void'] | MetaMerklesArgs['tuple']['addRoot(pay,string,byte[32],uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the deleteRoot(string)void ABI method
     *
     * Deletes the merkle root from the root box map
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static deleteRoot(params: CallParams<MetaMerklesArgs['obj']['deleteRoot(string)void'] | MetaMerklesArgs['tuple']['deleteRoot(string)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the updateRoot(string,byte[32])void ABI method
     *
     * Replaces the merkle root with another
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static updateRoot(params: CallParams<MetaMerklesArgs['obj']['updateRoot(string,byte[32])void'] | MetaMerklesArgs['tuple']['updateRoot(string,byte[32])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the addData(pay,string,string,string)void ABI method
     *
    * Registers a key & value in the data box map that
    corresponds to a merkle root in the root box map
  
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static addData(params: CallParams<MetaMerklesArgs['obj']['addData(pay,string,string,string)void'] | MetaMerklesArgs['tuple']['addData(pay,string,string,string)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the deleteData(string,string)void ABI method
     *
     * Deletes a metadata key & value pair from the data box map
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static deleteData(params: CallParams<MetaMerklesArgs['obj']['deleteData(string,string)void'] | MetaMerklesArgs['tuple']['deleteData(string,string)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the verify(address,string,byte[32],byte[32][],uint64)bool ABI method
     *
     * verify an inclusion in a double sha256 based merkle tree
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static verify(params: CallParams<MetaMerklesArgs['obj']['verify(address,string,byte[32],byte[32][],uint64)bool'] | MetaMerklesArgs['tuple']['verify(address,string,byte[32],byte[32][],uint64)bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the read(address,string,string)string ABI method
     *
     * Fetch a metadata properties
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static read(params: CallParams<MetaMerklesArgs['obj']['read(address,string,string)string'] | MetaMerklesArgs['tuple']['read(address,string,string)string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the verifiedRead(address,string,byte[32],byte[32][],uint64,string)string ABI method
     *
    * Read metadata from box storage and verify the data provided is included
    in the merkle tree given a sha256'd 32 byte merkle tree root & a proof
    thats pre-computed off chain.
    
    verify an inclusion in a merkle tree
    & read an associated key value pair
    & check against the underlying data's schema
    & check against the underlying data's list type or purpose
  
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static verifiedRead(params: CallParams<MetaMerklesArgs['obj']['verifiedRead(address,string,byte[32],byte[32][],uint64,string)string'] | MetaMerklesArgs['tuple']['verifiedRead(address,string,byte[32],byte[32][],uint64,string)string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string ABI method
     *
    * Read metadata from box storage and verify the data provided is included
    in the merkle tree given a sha256'd 32 byte merkle tree root & a proof
    thats pre-computed off chain.
    
    verify an inclusion in a merkle tree
    & read an associated key value pair
    & check against the underlying data's schema
    & check against the underlying data's list type or purpose
  
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static verifiedMustRead(params: CallParams<MetaMerklesArgs['obj']['verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string'] | MetaMerklesArgs['tuple']['verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the addType(pay,string,uint8[])void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static addType(params: CallParams<MetaMerklesArgs['obj']['addType(pay,string,uint8[])void'] | MetaMerklesArgs['tuple']['addType(pay,string,uint8[])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the rootCosts(string)uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static rootCosts(params: CallParams<MetaMerklesArgs['obj']['rootCosts(string)uint64'] | MetaMerklesArgs['tuple']['rootCosts(string)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the dataCosts(string,string,string)uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static dataCosts(params: CallParams<MetaMerklesArgs['obj']['dataCosts(string,string,string)uint64'] | MetaMerklesArgs['tuple']['dataCosts(string,string,string)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
}
/**
 * A factory to create and deploy one or more instance of the MetaMerkles smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export declare class MetaMerklesFactory {
    /**
     * The underlying `AppFactory` for when you want to have more flexibility
     */
    readonly appFactory: _AppFactory;
    /**
     * Creates a new instance of `MetaMerklesFactory`
     *
     * @param params The parameters to initialise the app factory with
     */
    constructor(params: Omit<AppFactoryParams, 'appSpec'>);
    /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
    get appName(): string;
    /** The ARC-56 app spec being used */
    get appSpec(): Arc56Contract;
    /** A reference to the underlying `AlgorandClient` this app factory is using. */
    get algorand(): AlgorandClient;
    /**
     * Returns a new `AppClient` client for an app instance of the given ID.
     *
     * Automatically populates appName, defaultSender and source maps from the factory
     * if not specified in the params.
     * @param params The parameters to create the app client
     * @returns The `AppClient`
     */
    getAppClientById(params: AppFactoryAppClientParams): MetaMerklesClient;
    /**
     * Returns a new `AppClient` client, resolving the app by creator address and name
     * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
     *
     * Automatically populates appName, defaultSender and source maps from the factory
     * if not specified in the params.
     * @param params The parameters to create the app client
     * @returns The `AppClient`
     */
    getAppClientByCreatorAndName(params: AppFactoryResolveAppClientByCreatorAndNameParams): Promise<MetaMerklesClient>;
    /**
     * Idempotently deploys the MetaMerkles smart contract.
     *
     * @param params The arguments for the contract calls and any additional parameters for the call
     * @returns The deployment result
     */
    deploy(params?: MetaMerklesDeployParams): Promise<{
        result: {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "create";
            version: string;
            name: string;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            appId: bigint;
            appAddress: Address;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "update";
            appId: bigint;
            appAddress: Address;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            name: string;
            version: string;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "replace";
            version: string;
            name: string;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            appId: bigint;
            appAddress: Address;
            deleteResult: import("@algorandfoundation/algokit-utils/types/transaction").ConfirmedTransactionResult;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "nothing";
            appId: bigint;
            appAddress: Address;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            name: string;
            version: string;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
        };
        appClient: MetaMerklesClient;
    }>;
    /**
     * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
     */
    readonly params: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the MetaMerkles smart contract using the create()void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The create params
             */
            create: (params?: CallParams<MetaMerklesArgs["obj"]["create()void"] | MetaMerklesArgs["tuple"]["create()void"]> & AppClientCompilationParams & CreateSchema & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                deployTimeParams: import("@algorandfoundation/algokit-utils/types/app").TealTemplateParams | undefined;
                schema: {
                    globalInts: number;
                    globalByteSlices: number;
                    localInts: number;
                    localByteSlices: number;
                };
                approvalProgram: Uint8Array;
                clearStateProgram: Uint8Array;
                maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                note?: string | Uint8Array | undefined;
                signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                lease?: string | Uint8Array | undefined;
                rekeyTo?: string | Address | undefined;
                staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                validityWindow?: number | bigint | undefined;
                firstValidRound?: bigint | undefined;
                lastValidRound?: bigint | undefined;
                accountReferences?: (string | Address)[] | undefined;
                appReferences?: bigint[] | undefined;
                assetReferences?: bigint[] | undefined;
                boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                sender?: string | Address | undefined;
                method: string;
                args?: (import("algosdk").ABIValue | AppMethodCallTransactionArgument | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined)[] | undefined;
                updatable?: boolean | undefined;
                deletable?: boolean | undefined;
                extraProgramPages?: number | undefined;
            } & {
                sender: Address;
                signer: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                method: import("@algorandfoundation/algokit-utils/types/app-arc56").Arc56Method;
                args: (Transaction | import("algosdk").ABIValue | import("algosdk").TransactionWithSigner | Promise<Transaction> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    note?: string | Uint8Array | undefined;
                    args?: Uint8Array[] | undefined;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                    lease?: string | Uint8Array | undefined;
                    rekeyTo?: string | Address | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                    schema?: {
                        globalInts: number;
                        globalByteSlices: number;
                        localInts: number;
                        localByteSlices: number;
                    } | undefined;
                    extraProgramPages?: number | undefined;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    rekeyTo?: string | Address | undefined;
                    note?: string | Uint8Array | undefined;
                    lease?: string | Uint8Array | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    appId: bigint;
                    onComplete?: OnApplicationComplete.UpdateApplicationOC | undefined;
                    args?: Uint8Array[] | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<import("@algorandfoundation/algokit-utils/types/composer").AppMethodCallParams> | undefined)[] | undefined;
                onComplete: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC;
            }>;
        };
    };
    /**
     * Create transactions for the current app
     */
    readonly createTransaction: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the MetaMerkles smart contract using the create()void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The create transaction
             */
            create: (params?: CallParams<MetaMerklesArgs["obj"]["create()void"] | MetaMerklesArgs["tuple"]["create()void"]> & AppClientCompilationParams & CreateSchema & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                transactions: Transaction[];
                methodCalls: Map<number, import("algosdk").ABIMethod>;
                signers: Map<number, TransactionSigner>;
            }>;
        };
    };
    /**
     * Send calls to the current app
     */
    readonly send: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the MetaMerkles smart contract using an ABI method call using the create()void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The create result
             */
            create: (params?: CallParams<MetaMerklesArgs["obj"]["create()void"] | MetaMerklesArgs["tuple"]["create()void"]> & AppClientCompilationParams & CreateSchema & SendParams & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                result: {
                    return: (undefined | MetaMerklesReturns["create()void"]);
                    compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                    compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                    appId: bigint;
                    groupId: string;
                    txIds: string[];
                    returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
                    confirmations: modelsv2.PendingTransactionResponse[];
                    transactions: Transaction[];
                    confirmation: modelsv2.PendingTransactionResponse;
                    transaction: Transaction;
                    appAddress: Address;
                };
                appClient: MetaMerklesClient;
            }>;
        };
    };
}
/**
 * A client to make calls to the MetaMerkles smart contract
 */
export declare class MetaMerklesClient {
    /**
     * The underlying `AppClient` for when you want to have more flexibility
     */
    readonly appClient: _AppClient;
    /**
     * Creates a new instance of `MetaMerklesClient`
     *
     * @param appClient An `AppClient` instance which has been created with the MetaMerkles app spec
     */
    constructor(appClient: _AppClient);
    /**
     * Creates a new instance of `MetaMerklesClient`
     *
     * @param params The parameters to initialise the app client with
     */
    constructor(params: Omit<AppClientParams, 'appSpec'>);
    /**
     * Checks for decode errors on the given return value and maps the return value to the return type for the given method
     * @returns The typed return value or undefined if there was no value
     */
    decodeReturnValue<TSignature extends MetaMerklesNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined): MethodReturn<TSignature> | undefined;
    /**
     * Returns a new `MetaMerklesClient` client, resolving the app by creator address and name
     * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
     * @param params The parameters to create the app client
     */
    static fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<MetaMerklesClient>;
    /**
     * Returns an `MetaMerklesClient` instance for the current network based on
     * pre-determined network-specific app IDs specified in the ARC-56 app spec.
     *
     * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
     * @param params The parameters to create the app client
     */
    static fromNetwork(params: Omit<ResolveAppClientByNetwork, 'appSpec'>): Promise<MetaMerklesClient>;
    /** The ID of the app instance this client is linked to. */
    get appId(): bigint;
    /** The app address of the app instance this client is linked to. */
    get appAddress(): Address;
    /** The name of the app. */
    get appName(): string;
    /** The ARC-56 app spec being used */
    get appSpec(): Arc56Contract;
    /** A reference to the underlying `AlgorandClient` this app client is using. */
    get algorand(): AlgorandClient;
    /**
     * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
     */
    readonly params: {
        /**
         * Makes a clear_state call to an existing instance of the MetaMerkles smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams>) => import("@algorandfoundation/algokit-utils/types/composer").AppCallParams;
        /**
         * Makes a call to the MetaMerkles smart contract using the `addRoot(pay,string,byte[32],uint64)void` ABI method.
         *
        * Creates two boxes and adds a merkle root
        using a `RootKey` to the root box map and also a list type to the
        metadata attached to the root in the data box map
    
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        addRoot: (params: CallParams<MetaMerklesArgs["obj"]["addRoot(pay,string,byte[32],uint64)void"] | MetaMerklesArgs["tuple"]["addRoot(pay,string,byte[32],uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `deleteRoot(string)void` ABI method.
         *
         * Deletes the merkle root from the root box map
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        deleteRoot: (params: CallParams<MetaMerklesArgs["obj"]["deleteRoot(string)void"] | MetaMerklesArgs["tuple"]["deleteRoot(string)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `updateRoot(string,byte[32])void` ABI method.
         *
         * Replaces the merkle root with another
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        updateRoot: (params: CallParams<MetaMerklesArgs["obj"]["updateRoot(string,byte[32])void"] | MetaMerklesArgs["tuple"]["updateRoot(string,byte[32])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `addData(pay,string,string,string)void` ABI method.
         *
        * Registers a key & value in the data box map that
        corresponds to a merkle root in the root box map
    
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        addData: (params: CallParams<MetaMerklesArgs["obj"]["addData(pay,string,string,string)void"] | MetaMerklesArgs["tuple"]["addData(pay,string,string,string)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `deleteData(string,string)void` ABI method.
         *
         * Deletes a metadata key & value pair from the data box map
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        deleteData: (params: CallParams<MetaMerklesArgs["obj"]["deleteData(string,string)void"] | MetaMerklesArgs["tuple"]["deleteData(string,string)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `verify(address,string,byte[32],byte[32][],uint64)bool` ABI method.
         *
         * verify an inclusion in a double sha256 based merkle tree
         *
         * @param params The params for the smart contract call
         * @returns The call params: a boolean indicating whether the proof is valid
         */
        verify: (params: CallParams<MetaMerklesArgs["obj"]["verify(address,string,byte[32],byte[32][],uint64)bool"] | MetaMerklesArgs["tuple"]["verify(address,string,byte[32],byte[32][],uint64)bool"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `read(address,string,string)string` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * Fetch a metadata properties
         *
         * @param params The params for the smart contract call
         * @returns The call params: the value set eg. `5` encoded as a bytestring for 5%
         */
        read: (params: CallParams<MetaMerklesArgs["obj"]["read(address,string,string)string"] | MetaMerklesArgs["tuple"]["read(address,string,string)string"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `verifiedRead(address,string,byte[32],byte[32][],uint64,string)string` ABI method.
         *
        * Read metadata from box storage and verify the data provided is included
        in the merkle tree given a sha256'd 32 byte merkle tree root & a proof
        thats pre-computed off chain.
        
        verify an inclusion in a merkle tree
        & read an associated key value pair
        & check against the underlying data's schema
        & check against the underlying data's list type or purpose
    
         *
         * @param params The params for the smart contract call
         * @returns The call params: a string of metadata
         */
        verifiedRead: (params: CallParams<MetaMerklesArgs["obj"]["verifiedRead(address,string,byte[32],byte[32][],uint64,string)string"] | MetaMerklesArgs["tuple"]["verifiedRead(address,string,byte[32],byte[32][],uint64,string)string"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string` ABI method.
         *
        * Read metadata from box storage and verify the data provided is included
        in the merkle tree given a sha256'd 32 byte merkle tree root & a proof
        thats pre-computed off chain.
        
        verify an inclusion in a merkle tree
        & read an associated key value pair
        & check against the underlying data's schema
        & check against the underlying data's list type or purpose
    
         *
         * @param params The params for the smart contract call
         * @returns The call params: a string of metadata
         */
        verifiedMustRead: (params: CallParams<MetaMerklesArgs["obj"]["verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string"] | MetaMerklesArgs["tuple"]["verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `addType(pay,string,uint8[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        addType: (params: CallParams<MetaMerklesArgs["obj"]["addType(pay,string,uint8[])void"] | MetaMerklesArgs["tuple"]["addType(pay,string,uint8[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `rootCosts(string)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        rootCosts: (params: CallParams<MetaMerklesArgs["obj"]["rootCosts(string)uint64"] | MetaMerklesArgs["tuple"]["rootCosts(string)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `dataCosts(string,string,string)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        dataCosts: (params: CallParams<MetaMerklesArgs["obj"]["dataCosts(string,string,string)uint64"] | MetaMerklesArgs["tuple"]["dataCosts(string,string,string)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
    };
    /**
     * Create transactions for the current app
     */
    readonly createTransaction: {
        /**
         * Makes a clear_state call to an existing instance of the MetaMerkles smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams>) => Promise<Transaction>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `addRoot(pay,string,byte[32],uint64)void` ABI method.
         *
        * Creates two boxes and adds a merkle root
        using a `RootKey` to the root box map and also a list type to the
        metadata attached to the root in the data box map
    
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        addRoot: (params: CallParams<MetaMerklesArgs["obj"]["addRoot(pay,string,byte[32],uint64)void"] | MetaMerklesArgs["tuple"]["addRoot(pay,string,byte[32],uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `deleteRoot(string)void` ABI method.
         *
         * Deletes the merkle root from the root box map
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        deleteRoot: (params: CallParams<MetaMerklesArgs["obj"]["deleteRoot(string)void"] | MetaMerklesArgs["tuple"]["deleteRoot(string)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `updateRoot(string,byte[32])void` ABI method.
         *
         * Replaces the merkle root with another
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        updateRoot: (params: CallParams<MetaMerklesArgs["obj"]["updateRoot(string,byte[32])void"] | MetaMerklesArgs["tuple"]["updateRoot(string,byte[32])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `addData(pay,string,string,string)void` ABI method.
         *
        * Registers a key & value in the data box map that
        corresponds to a merkle root in the root box map
    
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        addData: (params: CallParams<MetaMerklesArgs["obj"]["addData(pay,string,string,string)void"] | MetaMerklesArgs["tuple"]["addData(pay,string,string,string)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `deleteData(string,string)void` ABI method.
         *
         * Deletes a metadata key & value pair from the data box map
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        deleteData: (params: CallParams<MetaMerklesArgs["obj"]["deleteData(string,string)void"] | MetaMerklesArgs["tuple"]["deleteData(string,string)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `verify(address,string,byte[32],byte[32][],uint64)bool` ABI method.
         *
         * verify an inclusion in a double sha256 based merkle tree
         *
         * @param params The params for the smart contract call
         * @returns The call transaction: a boolean indicating whether the proof is valid
         */
        verify: (params: CallParams<MetaMerklesArgs["obj"]["verify(address,string,byte[32],byte[32][],uint64)bool"] | MetaMerklesArgs["tuple"]["verify(address,string,byte[32],byte[32][],uint64)bool"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `read(address,string,string)string` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * Fetch a metadata properties
         *
         * @param params The params for the smart contract call
         * @returns The call transaction: the value set eg. `5` encoded as a bytestring for 5%
         */
        read: (params: CallParams<MetaMerklesArgs["obj"]["read(address,string,string)string"] | MetaMerklesArgs["tuple"]["read(address,string,string)string"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `verifiedRead(address,string,byte[32],byte[32][],uint64,string)string` ABI method.
         *
        * Read metadata from box storage and verify the data provided is included
        in the merkle tree given a sha256'd 32 byte merkle tree root & a proof
        thats pre-computed off chain.
        
        verify an inclusion in a merkle tree
        & read an associated key value pair
        & check against the underlying data's schema
        & check against the underlying data's list type or purpose
    
         *
         * @param params The params for the smart contract call
         * @returns The call transaction: a string of metadata
         */
        verifiedRead: (params: CallParams<MetaMerklesArgs["obj"]["verifiedRead(address,string,byte[32],byte[32][],uint64,string)string"] | MetaMerklesArgs["tuple"]["verifiedRead(address,string,byte[32],byte[32][],uint64,string)string"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string` ABI method.
         *
        * Read metadata from box storage and verify the data provided is included
        in the merkle tree given a sha256'd 32 byte merkle tree root & a proof
        thats pre-computed off chain.
        
        verify an inclusion in a merkle tree
        & read an associated key value pair
        & check against the underlying data's schema
        & check against the underlying data's list type or purpose
    
         *
         * @param params The params for the smart contract call
         * @returns The call transaction: a string of metadata
         */
        verifiedMustRead: (params: CallParams<MetaMerklesArgs["obj"]["verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string"] | MetaMerklesArgs["tuple"]["verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `addType(pay,string,uint8[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        addType: (params: CallParams<MetaMerklesArgs["obj"]["addType(pay,string,uint8[])void"] | MetaMerklesArgs["tuple"]["addType(pay,string,uint8[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `rootCosts(string)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        rootCosts: (params: CallParams<MetaMerklesArgs["obj"]["rootCosts(string)uint64"] | MetaMerklesArgs["tuple"]["rootCosts(string)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `dataCosts(string,string,string)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        dataCosts: (params: CallParams<MetaMerklesArgs["obj"]["dataCosts(string,string,string)uint64"] | MetaMerklesArgs["tuple"]["dataCosts(string,string,string)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
    };
    /**
     * Send calls to the current app
     */
    readonly send: {
        /**
         * Makes a clear_state call to an existing instance of the MetaMerkles smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => Promise<{
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            return?: ABIReturn | undefined;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `addRoot(pay,string,byte[32],uint64)void` ABI method.
         *
        * Creates two boxes and adds a merkle root
        using a `RootKey` to the root box map and also a list type to the
        metadata attached to the root in the data box map
    
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        addRoot: (params: CallParams<MetaMerklesArgs["obj"]["addRoot(pay,string,byte[32],uint64)void"] | MetaMerklesArgs["tuple"]["addRoot(pay,string,byte[32],uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | MetaMerklesReturns["addRoot(pay,string,byte[32],uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `deleteRoot(string)void` ABI method.
         *
         * Deletes the merkle root from the root box map
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        deleteRoot: (params: CallParams<MetaMerklesArgs["obj"]["deleteRoot(string)void"] | MetaMerklesArgs["tuple"]["deleteRoot(string)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | MetaMerklesReturns["deleteRoot(string)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `updateRoot(string,byte[32])void` ABI method.
         *
         * Replaces the merkle root with another
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        updateRoot: (params: CallParams<MetaMerklesArgs["obj"]["updateRoot(string,byte[32])void"] | MetaMerklesArgs["tuple"]["updateRoot(string,byte[32])void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | MetaMerklesReturns["updateRoot(string,byte[32])void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `addData(pay,string,string,string)void` ABI method.
         *
        * Registers a key & value in the data box map that
        corresponds to a merkle root in the root box map
    
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        addData: (params: CallParams<MetaMerklesArgs["obj"]["addData(pay,string,string,string)void"] | MetaMerklesArgs["tuple"]["addData(pay,string,string,string)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | MetaMerklesReturns["addData(pay,string,string,string)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `deleteData(string,string)void` ABI method.
         *
         * Deletes a metadata key & value pair from the data box map
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        deleteData: (params: CallParams<MetaMerklesArgs["obj"]["deleteData(string,string)void"] | MetaMerklesArgs["tuple"]["deleteData(string,string)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | MetaMerklesReturns["deleteData(string,string)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `verify(address,string,byte[32],byte[32][],uint64)bool` ABI method.
         *
         * verify an inclusion in a double sha256 based merkle tree
         *
         * @param params The params for the smart contract call
         * @returns The call result: a boolean indicating whether the proof is valid
         */
        verify: (params: CallParams<MetaMerklesArgs["obj"]["verify(address,string,byte[32],byte[32][],uint64)bool"] | MetaMerklesArgs["tuple"]["verify(address,string,byte[32],byte[32][],uint64)bool"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | MetaMerklesReturns["verify(address,string,byte[32],byte[32][],uint64)bool"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `read(address,string,string)string` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * Fetch a metadata properties
         *
         * @param params The params for the smart contract call
         * @returns The call result: the value set eg. `5` encoded as a bytestring for 5%
         */
        read: (params: CallParams<MetaMerklesArgs["obj"]["read(address,string,string)string"] | MetaMerklesArgs["tuple"]["read(address,string,string)string"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | MetaMerklesReturns["read(address,string,string)string"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `verifiedRead(address,string,byte[32],byte[32][],uint64,string)string` ABI method.
         *
        * Read metadata from box storage and verify the data provided is included
        in the merkle tree given a sha256'd 32 byte merkle tree root & a proof
        thats pre-computed off chain.
        
        verify an inclusion in a merkle tree
        & read an associated key value pair
        & check against the underlying data's schema
        & check against the underlying data's list type or purpose
    
         *
         * @param params The params for the smart contract call
         * @returns The call result: a string of metadata
         */
        verifiedRead: (params: CallParams<MetaMerklesArgs["obj"]["verifiedRead(address,string,byte[32],byte[32][],uint64,string)string"] | MetaMerklesArgs["tuple"]["verifiedRead(address,string,byte[32],byte[32][],uint64,string)string"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | MetaMerklesReturns["verifiedRead(address,string,byte[32],byte[32][],uint64,string)string"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string` ABI method.
         *
        * Read metadata from box storage and verify the data provided is included
        in the merkle tree given a sha256'd 32 byte merkle tree root & a proof
        thats pre-computed off chain.
        
        verify an inclusion in a merkle tree
        & read an associated key value pair
        & check against the underlying data's schema
        & check against the underlying data's list type or purpose
    
         *
         * @param params The params for the smart contract call
         * @returns The call result: a string of metadata
         */
        verifiedMustRead: (params: CallParams<MetaMerklesArgs["obj"]["verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string"] | MetaMerklesArgs["tuple"]["verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | MetaMerklesReturns["verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `addType(pay,string,uint8[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        addType: (params: CallParams<MetaMerklesArgs["obj"]["addType(pay,string,uint8[])void"] | MetaMerklesArgs["tuple"]["addType(pay,string,uint8[])void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | MetaMerklesReturns["addType(pay,string,uint8[])void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `rootCosts(string)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        rootCosts: (params: CallParams<MetaMerklesArgs["obj"]["rootCosts(string)uint64"] | MetaMerklesArgs["tuple"]["rootCosts(string)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | MetaMerklesReturns["rootCosts(string)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the MetaMerkles smart contract using the `dataCosts(string,string,string)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        dataCosts: (params: CallParams<MetaMerklesArgs["obj"]["dataCosts(string,string,string)uint64"] | MetaMerklesArgs["tuple"]["dataCosts(string,string,string)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | MetaMerklesReturns["dataCosts(string,string,string)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
    };
    /**
     * Clone this app client with different params
     *
     * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
     * @returns A new app client with the altered params
     */
    clone(params: CloneAppClientParams): MetaMerklesClient;
    /**
     * Makes a readonly (simulated) call to the MetaMerkles smart contract using the `read(address,string,string)string` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Fetch a metadata properties
     *
     * @param params The params for the smart contract call
     * @returns The call result: the value set eg. `5` encoded as a bytestring for 5%
     */
    read(params: CallParams<MetaMerklesArgs['obj']['read(address,string,string)string'] | MetaMerklesArgs['tuple']['read(address,string,string)string']>): Promise<string>;
    /**
     * Makes a readonly (simulated) call to the MetaMerkles smart contract using the `rootCosts(string)uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    rootCosts(params: CallParams<MetaMerklesArgs['obj']['rootCosts(string)uint64'] | MetaMerklesArgs['tuple']['rootCosts(string)uint64']>): Promise<bigint>;
    /**
     * Makes a readonly (simulated) call to the MetaMerkles smart contract using the `dataCosts(string,string,string)uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    dataCosts(params: CallParams<MetaMerklesArgs['obj']['dataCosts(string,string,string)uint64'] | MetaMerklesArgs['tuple']['dataCosts(string,string,string)uint64']>): Promise<bigint>;
    /**
     * Methods to access state for the current MetaMerkles app
     */
    state: {
        /**
         * Methods to access global state for the current MetaMerkles app
         */
        global: {
            /**
             * Get all current keyed values from global state
             */
            getAll: () => Promise<Partial<Expand<GlobalKeysState>>>;
            /**
             * Get the current value of the typesID key in global state
             */
            typesId: () => Promise<bigint | undefined>;
        };
        /**
         * Methods to access box state for the current MetaMerkles app
         */
        box: {
            /**
             * Get all current keyed values from box state
             */
            getAll: () => Promise<Partial<Expand<BoxKeysState>>>;
            /**
             * Get values from the types map in box state
             */
            types: {
                /**
                 * Get all current values of the types map in box state
                 */
                getMap: () => Promise<Map<bigint, TypesValue>>;
                /**
                 * Get a current value of the types map by key from box state
                 */
                value: (key: bigint | number) => Promise<TypesValue | undefined>;
            };
            /**
             * Get values from the roots map in box state
             */
            roots: {
                /**
                 * Get all current values of the roots map in box state
                 */
                getMap: () => Promise<Map<RootKey, Uint8Array>>;
                /**
                 * Get a current value of the roots map by key from box state
                 */
                value: (key: RootKey) => Promise<Uint8Array | undefined>;
            };
            /**
             * Get values from the data map in box state
             */
            data: {
                /**
                 * Get all current values of the data map in box state
                 */
                getMap: () => Promise<Map<DataKey, string>>;
                /**
                 * Get a current value of the data map by key from box state
                 */
                value: (key: DataKey) => Promise<string | undefined>;
            };
        };
    };
    newGroup(): MetaMerklesComposer;
}
export type MetaMerklesComposer<TReturns extends [...any[]] = []> = {
    /**
     * Calls the addRoot(pay,string,byte[32],uint64)void ABI method.
     *
    * Creates two boxes and adds a merkle root
    using a `RootKey` to the root box map and also a list type to the
    metadata attached to the root in the data box map
  
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    addRoot(params?: CallParams<MetaMerklesArgs['obj']['addRoot(pay,string,byte[32],uint64)void'] | MetaMerklesArgs['tuple']['addRoot(pay,string,byte[32],uint64)void']>): MetaMerklesComposer<[...TReturns, MetaMerklesReturns['addRoot(pay,string,byte[32],uint64)void'] | undefined]>;
    /**
     * Calls the deleteRoot(string)void ABI method.
     *
     * Deletes the merkle root from the root box map
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    deleteRoot(params?: CallParams<MetaMerklesArgs['obj']['deleteRoot(string)void'] | MetaMerklesArgs['tuple']['deleteRoot(string)void']>): MetaMerklesComposer<[...TReturns, MetaMerklesReturns['deleteRoot(string)void'] | undefined]>;
    /**
     * Calls the updateRoot(string,byte[32])void ABI method.
     *
     * Replaces the merkle root with another
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    updateRoot(params?: CallParams<MetaMerklesArgs['obj']['updateRoot(string,byte[32])void'] | MetaMerklesArgs['tuple']['updateRoot(string,byte[32])void']>): MetaMerklesComposer<[...TReturns, MetaMerklesReturns['updateRoot(string,byte[32])void'] | undefined]>;
    /**
     * Calls the addData(pay,string,string,string)void ABI method.
     *
    * Registers a key & value in the data box map that
    corresponds to a merkle root in the root box map
  
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    addData(params?: CallParams<MetaMerklesArgs['obj']['addData(pay,string,string,string)void'] | MetaMerklesArgs['tuple']['addData(pay,string,string,string)void']>): MetaMerklesComposer<[...TReturns, MetaMerklesReturns['addData(pay,string,string,string)void'] | undefined]>;
    /**
     * Calls the deleteData(string,string)void ABI method.
     *
     * Deletes a metadata key & value pair from the data box map
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    deleteData(params?: CallParams<MetaMerklesArgs['obj']['deleteData(string,string)void'] | MetaMerklesArgs['tuple']['deleteData(string,string)void']>): MetaMerklesComposer<[...TReturns, MetaMerklesReturns['deleteData(string,string)void'] | undefined]>;
    /**
     * Calls the verify(address,string,byte[32],byte[32][],uint64)bool ABI method.
     *
     * verify an inclusion in a double sha256 based merkle tree
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    verify(params?: CallParams<MetaMerklesArgs['obj']['verify(address,string,byte[32],byte[32][],uint64)bool'] | MetaMerklesArgs['tuple']['verify(address,string,byte[32],byte[32][],uint64)bool']>): MetaMerklesComposer<[...TReturns, MetaMerklesReturns['verify(address,string,byte[32],byte[32][],uint64)bool'] | undefined]>;
    /**
     * Calls the read(address,string,string)string ABI method.
     *
     * Fetch a metadata properties
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    read(params?: CallParams<MetaMerklesArgs['obj']['read(address,string,string)string'] | MetaMerklesArgs['tuple']['read(address,string,string)string']>): MetaMerklesComposer<[...TReturns, MetaMerklesReturns['read(address,string,string)string'] | undefined]>;
    /**
     * Calls the verifiedRead(address,string,byte[32],byte[32][],uint64,string)string ABI method.
     *
    * Read metadata from box storage and verify the data provided is included
    in the merkle tree given a sha256'd 32 byte merkle tree root & a proof
    thats pre-computed off chain.
    
    verify an inclusion in a merkle tree
    & read an associated key value pair
    & check against the underlying data's schema
    & check against the underlying data's list type or purpose
  
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    verifiedRead(params?: CallParams<MetaMerklesArgs['obj']['verifiedRead(address,string,byte[32],byte[32][],uint64,string)string'] | MetaMerklesArgs['tuple']['verifiedRead(address,string,byte[32],byte[32][],uint64,string)string']>): MetaMerklesComposer<[...TReturns, MetaMerklesReturns['verifiedRead(address,string,byte[32],byte[32][],uint64,string)string'] | undefined]>;
    /**
     * Calls the verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string ABI method.
     *
    * Read metadata from box storage and verify the data provided is included
    in the merkle tree given a sha256'd 32 byte merkle tree root & a proof
    thats pre-computed off chain.
    
    verify an inclusion in a merkle tree
    & read an associated key value pair
    & check against the underlying data's schema
    & check against the underlying data's list type or purpose
  
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    verifiedMustRead(params?: CallParams<MetaMerklesArgs['obj']['verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string'] | MetaMerklesArgs['tuple']['verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string']>): MetaMerklesComposer<[...TReturns, MetaMerklesReturns['verifiedMustRead(address,string,byte[32],byte[32][],uint64,string)string'] | undefined]>;
    /**
     * Calls the addType(pay,string,uint8[])void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    addType(params?: CallParams<MetaMerklesArgs['obj']['addType(pay,string,uint8[])void'] | MetaMerklesArgs['tuple']['addType(pay,string,uint8[])void']>): MetaMerklesComposer<[...TReturns, MetaMerklesReturns['addType(pay,string,uint8[])void'] | undefined]>;
    /**
     * Calls the rootCosts(string)uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    rootCosts(params?: CallParams<MetaMerklesArgs['obj']['rootCosts(string)uint64'] | MetaMerklesArgs['tuple']['rootCosts(string)uint64']>): MetaMerklesComposer<[...TReturns, MetaMerklesReturns['rootCosts(string)uint64'] | undefined]>;
    /**
     * Calls the dataCosts(string,string,string)uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    dataCosts(params?: CallParams<MetaMerklesArgs['obj']['dataCosts(string,string,string)uint64'] | MetaMerklesArgs['tuple']['dataCosts(string,string,string)uint64']>): MetaMerklesComposer<[...TReturns, MetaMerklesReturns['dataCosts(string,string,string)uint64'] | undefined]>;
    /**
     * Makes a clear_state call to an existing instance of the MetaMerkles smart contract.
     *
     * @param args The arguments for the bare call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    clearState(params?: AppClientBareCallParams): MetaMerklesComposer<[...TReturns, undefined]>;
    /**
     * Adds a transaction to the composer
     *
     * @param txn A transaction to add to the transaction group
     * @param signer The optional signer to use when signing this transaction.
     */
    addTransaction(txn: Transaction, signer?: TransactionSigner): MetaMerklesComposer<TReturns>;
    /**
     * Returns the underlying AtomicTransactionComposer instance
     */
    composer(): Promise<TransactionComposer>;
    /**
     * Simulates the transaction group and returns the result
     */
    simulate(): Promise<MetaMerklesComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    simulate(options: SkipSignaturesSimulateOptions): Promise<MetaMerklesComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    simulate(options: RawSimulateOptions): Promise<MetaMerklesComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    /**
     * Sends the transaction group to the network and returns the results
     */
    send(params?: SendParams): Promise<MetaMerklesComposerResults<TReturns>>;
};
export type MetaMerklesComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
    returns: TReturns;
}>;
