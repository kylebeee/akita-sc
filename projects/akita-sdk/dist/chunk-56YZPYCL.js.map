{"version":3,"sources":["/Users/kylebreeding/akita/akita-sc/projects/akita-sdk/dist/chunk-56YZPYCL.js","../src/wallet/utils.ts"],"names":["options"],"mappings":"AAAA;ACAA,oFAA2E;AAG3E,iEAA4B;AAarB,SAAS,4BAAA,CAA6B,IAAA,EAAsB;AACjE,EAAA,OAAA,CAAQ,IAAA,EAAM;AAAA,IACZ,KAAK,MAAA,EAAQ;AAAE,MAAA,OAAO,EAAA;AAAA,IAAG;AAAA,IACzB,KAAK,QAAA,EAAU;AAAE,MAAA,OAAO,EAAA;AAAA,IAAG;AAAA,IAC3B,KAAK,MAAA,EAAQ;AAAE,MAAA,OAAO,EAAA;AAAA,IAAG;AAAA,IACzB,OAAA,EAAS;AACP,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,wBAAA,EAA2B,IAAI,CAAA,CAAA;AACjD,IAAA;AACF,EAAA;AACF;AAEoK;AAChH,EAAA;AACT,IAAA;AACI,IAAA;AACK,IAAA;AACA,IAAA;AACjD,EAAA;AACH;AAE8E;AAEvD,EAAA;AACR,IAAA;AACC,IAAA;AACI,IAAA;AAClB,EAAA;AAEmB,EAAA;AACZ,IAAA;AACI,MAAA;AACC,QAAA;AACO,QAAA;AACD,QAAA;AACT,QAAA;AACL,MAAA;AACG,IAAA;AACI,MAAA;AACC,QAAA;AACO,QAAA;AACD,QAAA;AACG,QAAA;AACZ,QAAA;AACL,MAAA;AACG,IAAA;AACI,MAAA;AACC,QAAA;AACa,QAAA;AACT,QAAA;AACC,QAAA;AACI,QAAA;AACZ,QAAA;AACL,MAAA;AACF,IAAA;AACiD,MAAA;AACnD,EAAA;AACF;AAE2D;AAEX,EAAA;AACR,EAAA;AAEQ,EAAA;AAC1B,EAAA;AACkB,EAAA;AAE/B,EAAA;AACT;AAEoE;AACvD,EAAA;AACK,IAAA;AACG,MAAA;AAC6B,MAAA;AAC7C,IAAA;AACH,EAAA;AACF;AAc6B;AACU,EAAA;AACV,EAAA;AAE2BA,EAAAA;AA/GxD,IAAA;AAgHuB,IAAA;AAEgC,IAAA;AAO/CA,IAAAA;AAIC,IAAA;AAK0C,IAAA;AAIF,IAAA;AAIEA,IAAAA;AAGjD,EAAA;AAEwB,EAAA;AACW,IAAA;AACV,IAAA;AACxB,EAAA;AAGwC,EAAA;AAElC,EAAA;AACT;AAE2C;AACR,iBAAA;AACzB,EAAA;AAEkG,EAAA;AACpF,IAAA;AACN,IAAA;AACyB,MAAA;AAChB,QAAA;AACrB,MAAA;AACF,IAAA;AACF,EAAA;AAE0D,EAAA;AAC3B,IAAA;AACpB,MAAA;AACT,IAAA;AAEiC,IAAA;AACnC,EAAA;AAEkD,EAAA;AACV,IAAA;AACT,IAAA;AACtB,IAAA;AACT,EAAA;AAEiD,EAAA;AACT,IAAA;AACT,IAAA;AAC/B,EAAA;AAE2C,EAAA;AACH,IAAA;AACT,IAAA;AAC/B,EAAA;AAE8C,EAAA;AACN,IAAA;AACN,IAAA;AAClC,EAAA;AAEc,EAAA;AACG,IAAA;AACjB,EAAA;AAEmB,EAAA;AACD,IAAA;AAClB,EAAA;AAEiC,EAAA;AACV,IAAA;AACvB,EAAA;AAE8B,EAAA;AACL,IAAA;AACzB,EAAA;AAEyC,EAAA;AACf,IAAA;AAC1B,EAAA;AAEgF,EAAA;AACnD,IAAA;AAC7B,EAAA;AAEmD,EAAA;AAChB,IAAA;AACnC,EAAA;AACF;AAEwD;AAAY,EAAA;AAAW;ADpEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/Users/kylebreeding/akita/akita-sc/projects/akita-sdk/dist/chunk-56YZPYCL.js","sourcesContent":[null,"import algosdk, { Address, AtomicTransactionComposer, decodeAddress } from \"algosdk\";\nimport { AllowanceInfo as SubAllowanceInfo } from \"../generated/AbstractedAccountClient\";\nimport { AddAllowanceArgs, AllowanceInfo } from \"./types\";\nimport { encodeLease } from \"@algorandfoundation/algokit-utils\";\nimport { PluginHookParams } from \"../types\";\nimport { Txn } from \"@algorandfoundation/algokit-utils/types/composer\";\nimport { AlgoAmount } from \"@algorandfoundation/algokit-utils/types/amount\";\n// import { AppCallParams, AppUpdateParams, Txn } from \"@algorandfoundation/algokit-utils/types/composer\";\n\n\n// AppCallParams | AppCreateParams | AppUpdateParams\n\n// export function isAppCall(params: Txn): params is AppCallParams {\n//   return params.type === 'appCall' && 'appId' in params;\n// }\n\nexport function SpendAllowanceTypeFromString(type: string): bigint {\n  switch (type) {\n    case 'flat': { return 1n }\n    case 'window': { return 2n }\n    case 'drip': { return 3n }\n    default: {\n      throw new Error(`Invalid allowance type: ${type}`);\n    }\n  }\n}\n\nexport function AllowancesToTuple(allowances: AddAllowanceArgs[]): [number | bigint, number | bigint, number | bigint, number | bigint, number | bigint, boolean][] {\n  return allowances.map(({ asset, type, useRounds = false, ...rest }) => {\n    const max = 'max' in rest ? rest.max : 0n;\n    const interval = 'interval' in rest ? rest.interval : 0n;\n    const amount = 'amount' in rest ? rest.amount : 'rate' in rest ? rest.rate : 0n;\n    return [asset, SpendAllowanceTypeFromString(type), amount, max, interval, useRounds];\n  }) as [number | bigint, number | bigint, number | bigint, number | bigint, number | bigint, boolean][];\n}\n\nexport function AllowanceInfoTranslate(info: SubAllowanceInfo): AllowanceInfo {\n\n  const commonFields = {\n    last: info.last,\n    start: info.start,\n    useRounds: info.useRounds\n  }\n\n  switch (info.type) {\n    case 1:\n      return {\n        type: 'flat',\n        amount: info.amount,\n        spent: info.spent,\n        ...commonFields\n      };\n    case 2:\n      return {\n        type: 'window',\n        amount: info.amount,\n        spent: info.spent,\n        interval: info.interval,\n        ...commonFields\n      };\n    case 3:\n      return {\n        type: 'drip',\n        lastLeftover: info.spent,\n        max: info.max,\n        rate: info.amount,\n        interval: info.interval,\n        ...commonFields\n      };\n    default:\n      throw new Error(`Unknown allowance type ${info.type}`);\n  }\n}\n\nexport function executionBoxKey(lease: string): Uint8Array {\n\n  const prefix = new Uint8Array(Buffer.from('x'));\n  const encodedLease = encodeLease(lease)!;\n\n  const result = new Uint8Array(prefix.length + encodedLease.length);\n  result.set(prefix, 0);\n  result.set(encodedLease, prefix.length);\n\n  return result;\n}\n\nexport function domainBoxKey(address: string | Address): Uint8Array {\n  return new Uint8Array(\n    Buffer.concat([\n      Buffer.from('d'),\n      typeof address === 'string' ? decodeAddress(address).publicKey : address.publicKey\n    ])\n  );\n}\n\nexport type OverWriteProperties = {\n  sender?: string | algosdk.Address;\n  signer?: algosdk.TransactionSigner;\n  firstValid?: bigint;\n  lastValid?: bigint;\n  lease?: Uint8Array | string;\n  fees?: Map<number, AlgoAmount>;\n};\n\nexport function forceProperties(\n  atc: AtomicTransactionComposer,\n  options: OverWriteProperties\n): AtomicTransactionComposer {\n  const group = atc.clone().buildGroup();\n  const newAtc = new algosdk.AtomicTransactionComposer();\n\n  const overWriteProperties = (txn: any, index: number, options: OverWriteProperties) => {\n    txn.txn['group'] = undefined;\n\n    txn.txn['lease'] = (options.lease !== undefined && index === 0)\n      ? (typeof options.lease === 'string'\n        ? encodeLease(options.lease)\n        : options.lease)\n      : txn.txn['lease'];\n\n    txn['signer'] = options.signer !== undefined\n      ? options.signer\n      : txn['signer'];\n\n    txn.txn['sender'] = options.sender !== undefined\n      ? (typeof options.sender === 'string'\n        ? decodeAddress(options.sender)\n        : options.sender)\n      : txn.txn['sender'];\n\n    txn.txn['firstValid'] = options.firstValid !== undefined\n      ? options.firstValid\n      : txn.txn['firstValid'];\n\n    txn.txn['lastValid'] = options.lastValid !== undefined\n      ? options.lastValid\n      : txn.txn['lastValid'];\n\n    txn.txn['fee'] = options.fees !== undefined && options.fees.has(index) && options.fees.get(index)?.microAlgo !== undefined\n      ? options.fees.get(index)?.microAlgo\n      : txn.txn['fee']\n  }\n\n  group.forEach((t, i) => {\n    overWriteProperties(t, i, options);\n    newAtc.addTransaction(t);\n  });\n\n  // Preserve method calls\n  newAtc['methodCalls'] = atc['methodCalls'];\n\n  return newAtc;\n}\n\nexport class ValueMap<K extends object, V> {\n  private map = new Map<string, V>();\n  private keyGenerator: (obj: K) => string;\n\n  constructor(keyGenerator: (obj: K) => string, iterable?: Iterable<readonly [K | Partial<K> | string, V]>) {\n    this.keyGenerator = keyGenerator;\n    if (iterable) {\n      for (const [key, value] of iterable) {\n        this.set(key, value);\n      }\n    }\n  }\n\n  private generateKey(key: K | Partial<K> | string): string {\n    if (typeof key === 'string') {\n      return key;\n    }\n    // If it's a partial key, we need to call the key generator which should handle defaults\n    return this.keyGenerator(key as K);\n  }\n\n  set(key: K | Partial<K> | string, value: V): this {\n    const stringKey = this.generateKey(key);\n    this.map.set(stringKey, value);\n    return this;\n  }\n\n  get(key: K | Partial<K> | string): V | undefined {\n    const stringKey = this.generateKey(key);\n    return this.map.get(stringKey);\n  }\n\n  has(key: K | Partial<K> | string): boolean {\n    const stringKey = this.generateKey(key);\n    return this.map.has(stringKey);\n  }\n\n  delete(key: K | Partial<K> | string): boolean {\n    const stringKey = this.generateKey(key);\n    return this.map.delete(stringKey);\n  }\n\n  clear(): void {\n    this.map.clear();\n  }\n\n  get size(): number {\n    return this.map.size;\n  }\n\n  keys(): IterableIterator<string> {\n    return this.map.keys();\n  }\n\n  values(): IterableIterator<V> {\n    return this.map.values();\n  }\n\n  entries(): IterableIterator<[string, V]> {\n    return this.map.entries();\n  }\n\n  forEach(callbackfn: (value: V, key: string, map: Map<string, V>) => void): void {\n    this.map.forEach(callbackfn);\n  }\n\n  [Symbol.iterator](): IterableIterator<[string, V]> {\n    return this.map[Symbol.iterator]();\n  }\n}\n\nexport const getTxns = async ({ }: PluginHookParams) => { return [{}] as Txn[] }"]}