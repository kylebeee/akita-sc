{"version":3,"sources":["/Users/kylebreeding/akita/akita-sc/projects/akita-sdk/dist/chunk-2WS6GQO5.js","../src/types.ts"],"names":[],"mappings":"AAAA;ACkCO,SAAS,eAAA,CAAgB,MAAA,EAAoE;AAClG,EAAA,OAAO,MAAA,CAAO,OAAA,IAAW,KAAA,EAAA,GAAa,MAAA,CAAO,OAAA,IAAW,KAAA,CAAA;AAC1D;AA4DO,SAAS,iBAAA,CAAkB,KAAA,EAA0C;AAC1E,EAAA,OAAO,OAAO,MAAA,IAAU,UAAA;AAC1B;AD3FA;AACA;AACE;AACA;AACF,yFAAC","file":"/Users/kylebreeding/akita/akita-sc/projects/akita-sdk/dist/chunk-2WS6GQO5.js","sourcesContent":[null,"import { AlgorandClient } from \"@algorandfoundation/algokit-utils/types/algorand-client\";\nimport { AlgoAmount } from '@algorandfoundation/algokit-utils/types/amount';\nimport { SendParams } from \"@algorandfoundation/algokit-utils/types/transaction\";\nimport { Address, modelsv2, Transaction, TransactionSigner } from \"algosdk\";\nimport { AppFactoryAppClientParams } from \"@algorandfoundation/algokit-utils/types/app-factory\";\nimport { Txn } from \"@algorandfoundation/algokit-utils/types/composer\";\nimport { ABIReturn, AppReturn } from \"@algorandfoundation/algokit-utils/types/app\";\n\nexport type MaybeSigner = {\n  sender?: Address | string;\n  signer?: TransactionSigner;\n};\n\nexport type ClientFactory<T> = new (params: { algorand: AlgorandClient }) => {\n  getAppClientById(params: AppFactoryAppClientParams): T;\n};\n\nexport interface SDKClient {\n  appId: bigint;\n  algorand: AlgorandClient;\n}\n\nexport type ExpandedSendParams = SendParams & {\n  maxFee?: AlgoAmount;\n  sender?: Address | string;\n  signer?: TransactionSigner;\n};\n\nexport type ExpandedSendParamsWithSigner = ExpandedSendParams & {\n  sender: Address | string;\n  signer: TransactionSigner;\n};\n\n// Type guard function\nexport function hasSenderSigner(params: ExpandedSendParams): params is ExpandedSendParamsWithSigner {\n  return params.sender !== undefined && params.signer !== undefined;\n}\n\n// Generic type for SDK instances that extend BaseSDK\nexport interface AkitaSDK<TClient extends SDKClient = SDKClient> {\n  appId: bigint;\n  client: TClient;\n  algorand: AlgorandClient;\n  readerAccount: string;\n  sendParams: SendParams;\n  setReaderAccount(readerAccount: string): void;\n  setSendParams(sendParams: SendParams): void;\n}\n\n// Helper type to extract the client type from an SDK\nexport type ExtractClientType<T> = T extends AkitaSDK<infer C> ? C : never;\n\n// Helper type to extract the SDK type from a client\nexport type SDKFromClient<TClient extends SDKClient> = AkitaSDK<TClient>;\n\nexport interface NewBaseContractSDKParams<T> extends NewContractSDKParams {\n  factory: ClientFactory<T>;\n}\n\n// Utility types for working with SDK instances\n\n// Type guard to check if an object is an AkitaSDK instance\nexport type IsAkitaSDK<T> = T extends AkitaSDK<any> ? true : false;\n\n// Union type helper for multiple SDK types\nexport type AnyAkitaSDK = AkitaSDK<any>;\n\n// Type to constrain function parameters to only accept AkitaSDK instances\nexport type RequireAkitaSDK<T extends AkitaSDK<any>> = T;\n\n// Type to extract method signatures from a client (for direct method usage)\nexport type ClientMethodSignatures<TClient> = {\n  [K in keyof TClient]: TClient[K] extends (...args: any[]) => any ? TClient[K] : never;\n}[keyof TClient];\n\n// Type to extract method names from a client (useful for dynamic method calling)\nexport type ClientMethods<TClient> = {\n  [K in keyof TClient]: TClient[K] extends (...args: any[]) => any ? K : never;\n}[keyof TClient];\n\nexport type PluginHookParams = {\n  wallet: bigint;\n}\n\nexport type PluginSDKReturn = (spendingAddress?: Address | string) => {\n  appId: bigint;\n  selectors: Uint8Array[];\n  getTxns: (params: PluginHookParams) => Promise<Txn[]>;\n  /**\n   * Number of opUp transactions to add after verifyAuthAddr.\n   * Complex operations like voting need additional opUp calls\n   * to provide extra resource reference slots for inner transactions.\n   */\n  opUpCount?: number;\n}\n\nexport function isPluginSDKReturn(value: unknown): value is PluginSDKReturn {\n  return typeof value === 'function';\n}\n\n// Helper type for plugin method specifications that allows both string names and method references\nexport type PluginMethodSpecifier = PluginSDKReturn | Uint8Array[];\n\n// Type for SDK constructor parameters with proper client factory typing\nexport type SDKConstructorParams<TClient extends SDKClient> = NewContractSDKParams & {\n  factory: ClientFactory<TClient>;\n};\n\n/**\n * Factory params with optional appId - can be resolved from environment\n */\nexport type OptionalAppIdFactoryParams = Omit<AppFactoryAppClientParams, 'appId'> & {\n  appId?: bigint;\n};\n\n/**\n * Parameters for constructing SDK instances\n * appId is optional - if not provided, will be resolved from environment variables\n */\nexport interface NewContractSDKParams {\n  factoryParams: OptionalAppIdFactoryParams;\n  algorand: AlgorandClient;\n  readerAccount?: string;\n  sendParams?: SendParams;\n}\n\nexport interface PluginCallParams {\n  appId: bigint;\n  method: string;\n  args?: any[];\n  sendParams?: ExpandedSendParams;\n  readerAccount?: string;\n}\n\nexport type TxnReturn<T> = Omit<{\n  groupId: string;\n  txIds: string[];\n  returns?: ABIReturn[] | undefined;\n  confirmations: modelsv2.PendingTransactionResponse[];\n  transactions: Transaction[];\n  confirmation: modelsv2.PendingTransactionResponse;\n  transaction: Transaction;\n  return?: ABIReturn | undefined;\n}, \"return\"> & AppReturn<T>\n\nexport type GroupReturn = {\n  groupId: string;\n  txIds: string[];\n  returns: ABIReturn[] & [];\n  confirmations: modelsv2.PendingTransactionResponse[];\n  transactions: Transaction[];\n}"]}