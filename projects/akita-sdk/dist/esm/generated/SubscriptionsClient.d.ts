/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client';
import { ABIReturn } from '@algorandfoundation/algokit-utils/types/app';
import { Arc56Contract } from '@algorandfoundation/algokit-utils/types/app-arc56';
import { AppClient as _AppClient, AppClientMethodCallParams, AppClientParams, AppClientBareCallParams, CallOnComplete, AppClientCompilationParams, ResolveAppClientByCreatorAndName, ResolveAppClientByNetwork, CloneAppClientParams } from '@algorandfoundation/algokit-utils/types/app-client';
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory';
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer';
import { SendParams, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction';
import { Address, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk';
export declare const APP_SPEC: Arc56Contract;
/**
 * A state record containing binary data
 */
export interface BinaryState {
    /**
     * Gets the state value as a Uint8Array
     */
    asByteArray(): Uint8Array | undefined;
    /**
     * Gets the state value as a string
     */
    asString(): string | undefined;
}
/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R ? (...args: Expand<A>) => Expand<R> : T extends infer O ? {
    [K in keyof O]: O[K];
} : never;
export type BlockListKey = {
    address: Uint8Array;
    blocked: Uint8Array;
};
/**
 * Converts the ABI tuple representation of a BlockListKey to the struct representation
 */
export declare function BlockListKeyFromTuple(abiTuple: [Uint8Array, Uint8Array]): BlockListKey;
export type Service = {
    status: number;
    interval: bigint;
    asset: bigint;
    amount: bigint;
    passes: bigint;
    gateId: bigint;
    title: string;
    description: string;
    bannerImage: Uint8Array;
    highlightMessage: number;
    highlightColor: Uint8Array;
};
/**
 * Converts the ABI tuple representation of a Service to the struct representation
 */
export declare function ServiceFromTuple(abiTuple: [number, bigint, bigint, bigint, bigint, bigint, string, string, Uint8Array, number, Uint8Array]): Service;
export type ServicesKey = {
    address: string;
    id: bigint;
};
/**
 * Converts the ABI tuple representation of a ServicesKey to the struct representation
 */
export declare function ServicesKeyFromTuple(abiTuple: [string, bigint]): ServicesKey;
export type SubscriptionInfo = {
    recipient: string;
    serviceId: bigint;
    startDate: bigint;
    amount: bigint;
    interval: bigint;
    asset: bigint;
    gateId: bigint;
    lastPayment: bigint;
    streak: bigint;
    escrowed: bigint;
};
/**
 * Converts the ABI tuple representation of a SubscriptionInfo to the struct representation
 */
export declare function SubscriptionInfoFromTuple(abiTuple: [string, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint]): SubscriptionInfo;
export type SubscriptionInfoWithDetails = {
    recipient: string;
    startDate: bigint;
    amount: bigint;
    interval: bigint;
    asset: bigint;
    gateId: bigint;
    serviceId: bigint;
    status: number;
    title: string;
    description: string;
    bannerImage: Uint8Array;
    highlightMessage: number;
    highlightColor: Uint8Array;
    lastPayment: bigint;
    streak: bigint;
    escrowed: bigint;
    passes: string[];
};
/**
 * Converts the ABI tuple representation of a SubscriptionInfoWithDetails to the struct representation
 */
export declare function SubscriptionInfoWithDetailsFromTuple(abiTuple: [string, bigint, bigint, bigint, bigint, bigint, bigint, number, string, string, Uint8Array, number, Uint8Array, bigint, bigint, bigint, string[]]): SubscriptionInfoWithDetails;
export type SubscriptionInfoWithExistence = {
    exists: boolean;
    recipient: string;
    serviceId: bigint;
    startDate: bigint;
    amount: bigint;
    interval: bigint;
    asset: bigint;
    gateId: bigint;
    lastPayment: bigint;
    streak: bigint;
    escrowed: bigint;
};
/**
 * Converts the ABI tuple representation of a SubscriptionInfoWithExistence to the struct representation
 */
export declare function SubscriptionInfoWithExistenceFromTuple(abiTuple: [boolean, string, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint]): SubscriptionInfoWithExistence;
export type SubscriptionKey = {
    address: string;
    id: bigint;
};
/**
 * Converts the ABI tuple representation of a SubscriptionKey to the struct representation
 */
export declare function SubscriptionKeyFromTuple(abiTuple: [string, bigint]): SubscriptionKey;
/**
 * The argument types for the Subscriptions contract
 */
export type SubscriptionsArgs = {
    /**
     * The object representation of the arguments for each method
     */
    obj: {
        'create(string,uint64,uint64)void': {
            version: string;
            akitaDao: bigint | number;
            akitaDaoEscrow: bigint | number;
        };
        'newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64': {
            /**
             * The payment for the service creation
             */
            payment: AppMethodCallTransactionArgument;
            /**
             * The interval in seconds
             */
            interval: bigint | number;
            /**
             * The asa to be used for the subscription
             */
            asset: bigint | number;
            /**
             * The amount of the asa to be used for the subscription
             */
            amount: bigint | number;
            /**
             * The number of accounts the subscription can be shared with
             */
            passes: bigint | number;
            gateId: bigint | number;
            title: string;
            bannerImage: Uint8Array;
            highlightMessage: bigint | number;
            highlightColor: Uint8Array;
        };
        'setServiceDescription(uint64,byte[])void': {
            offset: bigint | number;
            data: Uint8Array;
        };
        'activateService()void': Record<string, never>;
        'pauseService(uint64)void': {
            id: bigint | number;
        };
        'unpauseService(uint64)void': {
            id: bigint | number;
        };
        'shutdownService(uint64)void': {
            id: bigint | number;
        };
        'block(pay,address)void': {
            /**
             * The payment to cover mbr for blocking
             */
            payment: AppMethodCallTransactionArgument;
            /**
             * The address to be blocked
             */
            blocked: string;
        };
        'unblock(address)void': {
            /**
             * The address to be unblocked
             */
            blocked: string;
        };
        'gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64': {
            payment?: AppMethodCallTransactionArgument;
            gateTxn: AppMethodCallTransactionArgument;
            recipient: string;
            amount: bigint | number;
            interval: bigint | number;
            serviceId: bigint | number;
        };
        'subscribe(pay,address,uint64,uint64,uint64)uint64': {
            payment: AppMethodCallTransactionArgument;
            recipient: string;
            amount: bigint | number;
            interval: bigint | number;
            serviceId: bigint | number;
        };
        'gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64': {
            payment?: AppMethodCallTransactionArgument;
            assetXfer?: AppMethodCallTransactionArgument;
            gateTxn: AppMethodCallTransactionArgument;
            recipient: string;
            amount: bigint | number;
            interval: bigint | number;
            serviceId: bigint | number;
        };
        'subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64': {
            payment: AppMethodCallTransactionArgument;
            assetXfer: AppMethodCallTransactionArgument;
            recipient: string;
            amount: bigint | number;
            interval: bigint | number;
            serviceId: bigint | number;
        };
        'deposit(pay,uint64)void': {
            payment: AppMethodCallTransactionArgument;
            id: bigint | number;
        };
        'depositAsa(axfer,uint64)void': {
            assetXfer: AppMethodCallTransactionArgument;
            id: bigint | number;
        };
        'withdraw(uint64,uint64)void': {
            id: bigint | number;
            amount: bigint | number;
        };
        'unsubscribe(uint64)void': {
            id: bigint | number;
        };
        'gatedTriggerPayment(appl,(address,uint64))void': {
            gateTxn: AppMethodCallTransactionArgument;
            key: SubscriptionKey;
        };
        'triggerPayment((address,uint64))void': {
            key: SubscriptionKey;
        };
        'streakCheck((address,uint64))void': {
            key: SubscriptionKey;
        };
        'setPasses(uint64,address[])void': {
            id: bigint | number;
            addresses: string[];
        };
        'triggerList((address,uint64[])[])bool[]': {
            req: [string, bigint[] | number[]][];
        };
        'isBlocked(address,address)bool': {
            /**
             * The address to be checked
             */
            address: string;
            blocked: string;
        };
        'isShutdown(address,uint64)bool': {
            address: string;
            id: bigint | number;
        };
        'newServiceCost(uint64)uint64': {
            asset: bigint | number;
        };
        'newSubscriptionCost(address,uint64,uint64)uint64': {
            recipient: string;
            asset: bigint | number;
            serviceId: bigint | number;
        };
        'blockCost()uint64': Record<string, never>;
        'getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])': {
            address: string;
            id: bigint | number;
        };
        'getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]': {
            address: string;
            start: bigint | number;
            windowSize: bigint | number;
        };
        'getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)': {
            key: SubscriptionKey;
        };
        'mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)': {
            key: SubscriptionKey;
        };
        'getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])': {
            key: SubscriptionKey;
        };
        'isFirstSubscription(address)bool': {
            address: string;
        };
        'getServiceList(address)uint64': {
            address: string;
        };
        'getSubscriptionList(address)uint64': {
            address: string;
        };
        'optIn(pay,uint64)void': {
            /**
             * The payment transaction
             */
            payment: AppMethodCallTransactionArgument;
            /**
             * The asset to be opted into
             */
            asset: bigint | number;
        };
        'optInCost(uint64)uint64': {
            asset: bigint | number;
        };
        'updateAkitaDAOEscrow(uint64)void': {
            app: bigint | number;
        };
        'update(string)void': {
            newVersion: string;
        };
        'updateAkitaDAO(uint64)void': {
            akitaDao: bigint | number;
        };
        'opUp()void': Record<string, never>;
    };
    /**
     * The tuple representation of the arguments for each method
     */
    tuple: {
        'create(string,uint64,uint64)void': [version: string, akitaDao: bigint | number, akitaDaoEscrow: bigint | number];
        'newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64': [payment: AppMethodCallTransactionArgument, interval: bigint | number, asset: bigint | number, amount: bigint | number, passes: bigint | number, gateId: bigint | number, title: string, bannerImage: Uint8Array, highlightMessage: bigint | number, highlightColor: Uint8Array];
        'setServiceDescription(uint64,byte[])void': [offset: bigint | number, data: Uint8Array];
        'activateService()void': [];
        'pauseService(uint64)void': [id: bigint | number];
        'unpauseService(uint64)void': [id: bigint | number];
        'shutdownService(uint64)void': [id: bigint | number];
        'block(pay,address)void': [payment: AppMethodCallTransactionArgument, blocked: string];
        'unblock(address)void': [blocked: string];
        'gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64': [payment: AppMethodCallTransactionArgument | undefined, gateTxn: AppMethodCallTransactionArgument, recipient: string, amount: bigint | number, interval: bigint | number, serviceId: bigint | number];
        'subscribe(pay,address,uint64,uint64,uint64)uint64': [payment: AppMethodCallTransactionArgument, recipient: string, amount: bigint | number, interval: bigint | number, serviceId: bigint | number];
        'gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64': [payment: AppMethodCallTransactionArgument | undefined, assetXfer: AppMethodCallTransactionArgument | undefined, gateTxn: AppMethodCallTransactionArgument, recipient: string, amount: bigint | number, interval: bigint | number, serviceId: bigint | number];
        'subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64': [payment: AppMethodCallTransactionArgument, assetXfer: AppMethodCallTransactionArgument, recipient: string, amount: bigint | number, interval: bigint | number, serviceId: bigint | number];
        'deposit(pay,uint64)void': [payment: AppMethodCallTransactionArgument, id: bigint | number];
        'depositAsa(axfer,uint64)void': [assetXfer: AppMethodCallTransactionArgument, id: bigint | number];
        'withdraw(uint64,uint64)void': [id: bigint | number, amount: bigint | number];
        'unsubscribe(uint64)void': [id: bigint | number];
        'gatedTriggerPayment(appl,(address,uint64))void': [gateTxn: AppMethodCallTransactionArgument, key: SubscriptionKey];
        'triggerPayment((address,uint64))void': [key: SubscriptionKey];
        'streakCheck((address,uint64))void': [key: SubscriptionKey];
        'setPasses(uint64,address[])void': [id: bigint | number, addresses: string[]];
        'triggerList((address,uint64[])[])bool[]': [req: [string, bigint[] | number[]][]];
        'isBlocked(address,address)bool': [address: string, blocked: string];
        'isShutdown(address,uint64)bool': [address: string, id: bigint | number];
        'newServiceCost(uint64)uint64': [asset: bigint | number];
        'newSubscriptionCost(address,uint64,uint64)uint64': [recipient: string, asset: bigint | number, serviceId: bigint | number];
        'blockCost()uint64': [];
        'getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])': [address: string, id: bigint | number];
        'getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]': [address: string, start: bigint | number, windowSize: bigint | number];
        'getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)': [key: SubscriptionKey];
        'mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)': [key: SubscriptionKey];
        'getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])': [key: SubscriptionKey];
        'isFirstSubscription(address)bool': [address: string];
        'getServiceList(address)uint64': [address: string];
        'getSubscriptionList(address)uint64': [address: string];
        'optIn(pay,uint64)void': [payment: AppMethodCallTransactionArgument, asset: bigint | number];
        'optInCost(uint64)uint64': [asset: bigint | number];
        'updateAkitaDAOEscrow(uint64)void': [app: bigint | number];
        'update(string)void': [newVersion: string];
        'updateAkitaDAO(uint64)void': [akitaDao: bigint | number];
        'opUp()void': [];
    };
};
/**
 * The return type for each method
 */
export type SubscriptionsReturns = {
    'create(string,uint64,uint64)void': void;
    'newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64': bigint;
    'setServiceDescription(uint64,byte[])void': void;
    'activateService()void': void;
    'pauseService(uint64)void': void;
    'unpauseService(uint64)void': void;
    'shutdownService(uint64)void': void;
    'block(pay,address)void': void;
    'unblock(address)void': void;
    'gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64': bigint;
    'subscribe(pay,address,uint64,uint64,uint64)uint64': bigint;
    'gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64': bigint;
    'subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64': bigint;
    'deposit(pay,uint64)void': void;
    'depositAsa(axfer,uint64)void': void;
    'withdraw(uint64,uint64)void': void;
    'unsubscribe(uint64)void': void;
    'gatedTriggerPayment(appl,(address,uint64))void': void;
    'triggerPayment((address,uint64))void': void;
    'streakCheck((address,uint64))void': void;
    'setPasses(uint64,address[])void': void;
    'triggerList((address,uint64[])[])bool[]': boolean[];
    'isBlocked(address,address)bool': boolean;
    'isShutdown(address,uint64)bool': boolean;
    'newServiceCost(uint64)uint64': bigint;
    'newSubscriptionCost(address,uint64,uint64)uint64': bigint;
    'blockCost()uint64': bigint;
    'getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])': Service;
    'getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]': [number, bigint, bigint, bigint, bigint, bigint, string, string, Uint8Array, number, Uint8Array][];
    'getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)': SubscriptionInfoWithExistence;
    'mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)': SubscriptionInfo;
    'getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])': SubscriptionInfoWithDetails;
    'isFirstSubscription(address)bool': boolean;
    'getServiceList(address)uint64': bigint;
    'getSubscriptionList(address)uint64': bigint;
    'optIn(pay,uint64)void': void;
    'optInCost(uint64)uint64': bigint;
    'updateAkitaDAOEscrow(uint64)void': void;
    'update(string)void': void;
    'updateAkitaDAO(uint64)void': void;
    'opUp()void': void;
};
/**
 * Defines the types of available calls and state of the Subscriptions smart contract.
 */
export type SubscriptionsTypes = {
    /**
     * Maps method signatures / names to their argument and return types.
     */
    methods: Record<'create(string,uint64,uint64)void' | 'create', {
        argsObj: SubscriptionsArgs['obj']['create(string,uint64,uint64)void'];
        argsTuple: SubscriptionsArgs['tuple']['create(string,uint64,uint64)void'];
        returns: SubscriptionsReturns['create(string,uint64,uint64)void'];
    }> & Record<'newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64' | 'newService', {
        argsObj: SubscriptionsArgs['obj']['newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64'];
        argsTuple: SubscriptionsArgs['tuple']['newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64'];
        returns: SubscriptionsReturns['newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64'];
    }> & Record<'setServiceDescription(uint64,byte[])void' | 'setServiceDescription', {
        argsObj: SubscriptionsArgs['obj']['setServiceDescription(uint64,byte[])void'];
        argsTuple: SubscriptionsArgs['tuple']['setServiceDescription(uint64,byte[])void'];
        returns: SubscriptionsReturns['setServiceDescription(uint64,byte[])void'];
    }> & Record<'activateService()void' | 'activateService', {
        argsObj: SubscriptionsArgs['obj']['activateService()void'];
        argsTuple: SubscriptionsArgs['tuple']['activateService()void'];
        returns: SubscriptionsReturns['activateService()void'];
    }> & Record<'pauseService(uint64)void' | 'pauseService', {
        argsObj: SubscriptionsArgs['obj']['pauseService(uint64)void'];
        argsTuple: SubscriptionsArgs['tuple']['pauseService(uint64)void'];
        returns: SubscriptionsReturns['pauseService(uint64)void'];
    }> & Record<'unpauseService(uint64)void' | 'unpauseService', {
        argsObj: SubscriptionsArgs['obj']['unpauseService(uint64)void'];
        argsTuple: SubscriptionsArgs['tuple']['unpauseService(uint64)void'];
        returns: SubscriptionsReturns['unpauseService(uint64)void'];
    }> & Record<'shutdownService(uint64)void' | 'shutdownService', {
        argsObj: SubscriptionsArgs['obj']['shutdownService(uint64)void'];
        argsTuple: SubscriptionsArgs['tuple']['shutdownService(uint64)void'];
        returns: SubscriptionsReturns['shutdownService(uint64)void'];
    }> & Record<'block(pay,address)void' | 'block', {
        argsObj: SubscriptionsArgs['obj']['block(pay,address)void'];
        argsTuple: SubscriptionsArgs['tuple']['block(pay,address)void'];
        returns: SubscriptionsReturns['block(pay,address)void'];
    }> & Record<'unblock(address)void' | 'unblock', {
        argsObj: SubscriptionsArgs['obj']['unblock(address)void'];
        argsTuple: SubscriptionsArgs['tuple']['unblock(address)void'];
        returns: SubscriptionsReturns['unblock(address)void'];
    }> & Record<'gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64' | 'gatedSubscribe', {
        argsObj: SubscriptionsArgs['obj']['gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64'];
        argsTuple: SubscriptionsArgs['tuple']['gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64'];
        returns: SubscriptionsReturns['gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64'];
    }> & Record<'subscribe(pay,address,uint64,uint64,uint64)uint64' | 'subscribe', {
        argsObj: SubscriptionsArgs['obj']['subscribe(pay,address,uint64,uint64,uint64)uint64'];
        argsTuple: SubscriptionsArgs['tuple']['subscribe(pay,address,uint64,uint64,uint64)uint64'];
        returns: SubscriptionsReturns['subscribe(pay,address,uint64,uint64,uint64)uint64'];
    }> & Record<'gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64' | 'gatedSubscribeAsa', {
        argsObj: SubscriptionsArgs['obj']['gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64'];
        argsTuple: SubscriptionsArgs['tuple']['gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64'];
        returns: SubscriptionsReturns['gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64'];
    }> & Record<'subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64' | 'subscribeAsa', {
        argsObj: SubscriptionsArgs['obj']['subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64'];
        argsTuple: SubscriptionsArgs['tuple']['subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64'];
        returns: SubscriptionsReturns['subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64'];
    }> & Record<'deposit(pay,uint64)void' | 'deposit', {
        argsObj: SubscriptionsArgs['obj']['deposit(pay,uint64)void'];
        argsTuple: SubscriptionsArgs['tuple']['deposit(pay,uint64)void'];
        returns: SubscriptionsReturns['deposit(pay,uint64)void'];
    }> & Record<'depositAsa(axfer,uint64)void' | 'depositAsa', {
        argsObj: SubscriptionsArgs['obj']['depositAsa(axfer,uint64)void'];
        argsTuple: SubscriptionsArgs['tuple']['depositAsa(axfer,uint64)void'];
        returns: SubscriptionsReturns['depositAsa(axfer,uint64)void'];
    }> & Record<'withdraw(uint64,uint64)void' | 'withdraw', {
        argsObj: SubscriptionsArgs['obj']['withdraw(uint64,uint64)void'];
        argsTuple: SubscriptionsArgs['tuple']['withdraw(uint64,uint64)void'];
        returns: SubscriptionsReturns['withdraw(uint64,uint64)void'];
    }> & Record<'unsubscribe(uint64)void' | 'unsubscribe', {
        argsObj: SubscriptionsArgs['obj']['unsubscribe(uint64)void'];
        argsTuple: SubscriptionsArgs['tuple']['unsubscribe(uint64)void'];
        returns: SubscriptionsReturns['unsubscribe(uint64)void'];
    }> & Record<'gatedTriggerPayment(appl,(address,uint64))void' | 'gatedTriggerPayment', {
        argsObj: SubscriptionsArgs['obj']['gatedTriggerPayment(appl,(address,uint64))void'];
        argsTuple: SubscriptionsArgs['tuple']['gatedTriggerPayment(appl,(address,uint64))void'];
        returns: SubscriptionsReturns['gatedTriggerPayment(appl,(address,uint64))void'];
    }> & Record<'triggerPayment((address,uint64))void' | 'triggerPayment', {
        argsObj: SubscriptionsArgs['obj']['triggerPayment((address,uint64))void'];
        argsTuple: SubscriptionsArgs['tuple']['triggerPayment((address,uint64))void'];
        returns: SubscriptionsReturns['triggerPayment((address,uint64))void'];
    }> & Record<'streakCheck((address,uint64))void' | 'streakCheck', {
        argsObj: SubscriptionsArgs['obj']['streakCheck((address,uint64))void'];
        argsTuple: SubscriptionsArgs['tuple']['streakCheck((address,uint64))void'];
        returns: SubscriptionsReturns['streakCheck((address,uint64))void'];
    }> & Record<'setPasses(uint64,address[])void' | 'setPasses', {
        argsObj: SubscriptionsArgs['obj']['setPasses(uint64,address[])void'];
        argsTuple: SubscriptionsArgs['tuple']['setPasses(uint64,address[])void'];
        returns: SubscriptionsReturns['setPasses(uint64,address[])void'];
    }> & Record<'triggerList((address,uint64[])[])bool[]' | 'triggerList', {
        argsObj: SubscriptionsArgs['obj']['triggerList((address,uint64[])[])bool[]'];
        argsTuple: SubscriptionsArgs['tuple']['triggerList((address,uint64[])[])bool[]'];
        returns: SubscriptionsReturns['triggerList((address,uint64[])[])bool[]'];
    }> & Record<'isBlocked(address,address)bool' | 'isBlocked', {
        argsObj: SubscriptionsArgs['obj']['isBlocked(address,address)bool'];
        argsTuple: SubscriptionsArgs['tuple']['isBlocked(address,address)bool'];
        returns: SubscriptionsReturns['isBlocked(address,address)bool'];
    }> & Record<'isShutdown(address,uint64)bool' | 'isShutdown', {
        argsObj: SubscriptionsArgs['obj']['isShutdown(address,uint64)bool'];
        argsTuple: SubscriptionsArgs['tuple']['isShutdown(address,uint64)bool'];
        returns: SubscriptionsReturns['isShutdown(address,uint64)bool'];
    }> & Record<'newServiceCost(uint64)uint64' | 'newServiceCost', {
        argsObj: SubscriptionsArgs['obj']['newServiceCost(uint64)uint64'];
        argsTuple: SubscriptionsArgs['tuple']['newServiceCost(uint64)uint64'];
        returns: SubscriptionsReturns['newServiceCost(uint64)uint64'];
    }> & Record<'newSubscriptionCost(address,uint64,uint64)uint64' | 'newSubscriptionCost', {
        argsObj: SubscriptionsArgs['obj']['newSubscriptionCost(address,uint64,uint64)uint64'];
        argsTuple: SubscriptionsArgs['tuple']['newSubscriptionCost(address,uint64,uint64)uint64'];
        returns: SubscriptionsReturns['newSubscriptionCost(address,uint64,uint64)uint64'];
    }> & Record<'blockCost()uint64' | 'blockCost', {
        argsObj: SubscriptionsArgs['obj']['blockCost()uint64'];
        argsTuple: SubscriptionsArgs['tuple']['blockCost()uint64'];
        returns: SubscriptionsReturns['blockCost()uint64'];
    }> & Record<'getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])' | 'getService', {
        argsObj: SubscriptionsArgs['obj']['getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])'];
        argsTuple: SubscriptionsArgs['tuple']['getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])'];
        returns: SubscriptionsReturns['getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])'];
    }> & Record<'getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]' | 'getServicesByAddress', {
        argsObj: SubscriptionsArgs['obj']['getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]'];
        argsTuple: SubscriptionsArgs['tuple']['getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]'];
        returns: SubscriptionsReturns['getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]'];
    }> & Record<'getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)' | 'getSubscription', {
        argsObj: SubscriptionsArgs['obj']['getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'];
        argsTuple: SubscriptionsArgs['tuple']['getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'];
        returns: SubscriptionsReturns['getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'];
    }> & Record<'mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)' | 'mustGetSubscription', {
        argsObj: SubscriptionsArgs['obj']['mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'];
        argsTuple: SubscriptionsArgs['tuple']['mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'];
        returns: SubscriptionsReturns['mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'];
    }> & Record<'getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])' | 'getSubscriptionWithDetails', {
        argsObj: SubscriptionsArgs['obj']['getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])'];
        argsTuple: SubscriptionsArgs['tuple']['getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])'];
        returns: SubscriptionsReturns['getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])'];
    }> & Record<'isFirstSubscription(address)bool' | 'isFirstSubscription', {
        argsObj: SubscriptionsArgs['obj']['isFirstSubscription(address)bool'];
        argsTuple: SubscriptionsArgs['tuple']['isFirstSubscription(address)bool'];
        returns: SubscriptionsReturns['isFirstSubscription(address)bool'];
    }> & Record<'getServiceList(address)uint64' | 'getServiceList', {
        argsObj: SubscriptionsArgs['obj']['getServiceList(address)uint64'];
        argsTuple: SubscriptionsArgs['tuple']['getServiceList(address)uint64'];
        returns: SubscriptionsReturns['getServiceList(address)uint64'];
    }> & Record<'getSubscriptionList(address)uint64' | 'getSubscriptionList', {
        argsObj: SubscriptionsArgs['obj']['getSubscriptionList(address)uint64'];
        argsTuple: SubscriptionsArgs['tuple']['getSubscriptionList(address)uint64'];
        returns: SubscriptionsReturns['getSubscriptionList(address)uint64'];
    }> & Record<'optIn(pay,uint64)void' | 'optIn', {
        argsObj: SubscriptionsArgs['obj']['optIn(pay,uint64)void'];
        argsTuple: SubscriptionsArgs['tuple']['optIn(pay,uint64)void'];
        returns: SubscriptionsReturns['optIn(pay,uint64)void'];
    }> & Record<'optInCost(uint64)uint64' | 'optInCost', {
        argsObj: SubscriptionsArgs['obj']['optInCost(uint64)uint64'];
        argsTuple: SubscriptionsArgs['tuple']['optInCost(uint64)uint64'];
        returns: SubscriptionsReturns['optInCost(uint64)uint64'];
    }> & Record<'updateAkitaDAOEscrow(uint64)void' | 'updateAkitaDAOEscrow', {
        argsObj: SubscriptionsArgs['obj']['updateAkitaDAOEscrow(uint64)void'];
        argsTuple: SubscriptionsArgs['tuple']['updateAkitaDAOEscrow(uint64)void'];
        returns: SubscriptionsReturns['updateAkitaDAOEscrow(uint64)void'];
    }> & Record<'update(string)void' | 'update', {
        argsObj: SubscriptionsArgs['obj']['update(string)void'];
        argsTuple: SubscriptionsArgs['tuple']['update(string)void'];
        returns: SubscriptionsReturns['update(string)void'];
    }> & Record<'updateAkitaDAO(uint64)void' | 'updateAkitaDAO', {
        argsObj: SubscriptionsArgs['obj']['updateAkitaDAO(uint64)void'];
        argsTuple: SubscriptionsArgs['tuple']['updateAkitaDAO(uint64)void'];
        returns: SubscriptionsReturns['updateAkitaDAO(uint64)void'];
    }> & Record<'opUp()void' | 'opUp', {
        argsObj: SubscriptionsArgs['obj']['opUp()void'];
        argsTuple: SubscriptionsArgs['tuple']['opUp()void'];
        returns: SubscriptionsReturns['opUp()void'];
    }>;
    /**
     * Defines the shape of the state of the application.
     */
    state: {
        global: {
            keys: {
                /**
                 * the app ID for the akita DAO escrow to use
                 */
                akitaDaoEscrow: bigint;
                /**
                 * the current version of the contract
                 */
                version: string;
                /**
                 * the app ID of the Akita DAO
                 */
                akitaDao: bigint;
            };
            maps: {};
        };
        box: {
            keys: {};
            maps: {
                subscriptions: Map<SubscriptionKey, SubscriptionInfo>;
                /**
                 * A counter for each addresses subscription id
                 */
                subscriptionslist: Map<string, bigint>;
                /**
                * services is a map of services a specific merchant has
                denoted by the merchant address + index of the offer as a key
                32 + 8 = 40 bytes
                120 bytes total -> (2500 + (400 * 121)) = 0.050500
        
                 */
                services: Map<ServicesKey, Service>;
                serviceslist: Map<string, bigint>;
                /**
                * blocks allow merchants to specify which addresses cannot subscribe
                key will be merchant address + blocked address
                32 + 32 = 64 bytes
                65 bytes total -> (2500 + (400 * 64)) = 0.028500
        
                 */
                blocks: Map<BlockListKey, Uint8Array>;
                passes: Map<SubscriptionKey, string[]>;
            };
        };
    };
};
/**
 * Defines the possible abi call signatures.
 */
export type SubscriptionsSignatures = keyof SubscriptionsTypes['methods'];
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type SubscriptionsNonVoidMethodSignatures = keyof SubscriptionsTypes['methods'] extends infer T ? T extends keyof SubscriptionsTypes['methods'] ? MethodReturn<T> extends void ? never : T : never : never;
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> & {
    /** The args for the ABI method call, either as an ordered array or an object */
    args: Expand<TArgs>;
}>;
/**
 * Maps a method signature from the Subscriptions smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends SubscriptionsSignatures> = SubscriptionsTypes['methods'][TSignature]['argsObj' | 'argsTuple'];
/**
 * Maps a method signature from the Subscriptions smart contract to the method's return type
 */
export type MethodReturn<TSignature extends SubscriptionsSignatures> = SubscriptionsTypes['methods'][TSignature]['returns'];
/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = SubscriptionsTypes['state']['global']['keys'];
/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = SubscriptionsTypes['state']['box']['keys'];
/**
 * Defines supported create method params for this smart contract
 */
export type SubscriptionsCreateCallParams = Expand<CallParams<SubscriptionsArgs['obj']['create(string,uint64,uint64)void'] | SubscriptionsArgs['tuple']['create(string,uint64,uint64)void']> & {
    method: 'create';
} & {
    onComplete?: OnApplicationComplete.NoOpOC;
} & CreateSchema> | Expand<CallParams<SubscriptionsArgs['obj']['create(string,uint64,uint64)void'] | SubscriptionsArgs['tuple']['create(string,uint64,uint64)void']> & {
    method: 'create(string,uint64,uint64)void';
} & {
    onComplete?: OnApplicationComplete.NoOpOC;
} & CreateSchema>;
/**
 * Defines supported update method params for this smart contract
 */
export type SubscriptionsUpdateCallParams = Expand<CallParams<SubscriptionsArgs['obj']['update(string)void'] | SubscriptionsArgs['tuple']['update(string)void']> & {
    method: 'update';
}> | Expand<CallParams<SubscriptionsArgs['obj']['update(string)void'] | SubscriptionsArgs['tuple']['update(string)void']> & {
    method: 'update(string)void';
}>;
/**
 * Defines arguments required for the deploy method.
 */
export type SubscriptionsDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
    /**
     * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
     */
    createParams?: SubscriptionsCreateCallParams;
    /**
     * Update transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
     */
    updateParams?: SubscriptionsUpdateCallParams;
}>;
/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the Subscriptions smart contract
 */
export declare abstract class SubscriptionsParamsFactory {
    /**
     * Gets available create ABI call param factories
     */
    static get create(): {
        _resolveByMethod<TParams extends SubscriptionsCreateCallParams & {
            method: string;
        }>(params: TParams): {
            maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            signer?: (TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount) | undefined;
            rekeyTo?: (string | Address) | undefined;
            note?: (Uint8Array | string) | undefined;
            lease?: (Uint8Array | string) | undefined;
            staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            validityWindow?: number | bigint | undefined;
            firstValidRound?: bigint | undefined;
            lastValidRound?: bigint | undefined;
            onComplete?: OnApplicationComplete | undefined;
            accountReferences?: (string | Address)[] | undefined;
            appReferences?: bigint[] | undefined;
            assetReferences?: bigint[] | undefined;
            boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference | import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier)[] | undefined;
            sender?: (Address | string) | undefined;
            method: string;
            args?: (import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | AppMethodCallTransactionArgument | undefined)[] | undefined;
        } & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        };
        /**
         * Constructs create ABI call params for the Subscriptions smart contract using the create(string,uint64,uint64)void ABI method
         *
         * @param params Parameters for the call
         * @returns An `AppClientMethodCallParams` object for the call
         */
        create(params: CallParams<SubscriptionsArgs["obj"]["create(string,uint64,uint64)void"] | SubscriptionsArgs["tuple"]["create(string,uint64,uint64)void"]> & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }): AppClientMethodCallParams & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        };
    };
    /**
     * Gets available update ABI call param factories
     */
    static get update(): {
        _resolveByMethod<TParams extends SubscriptionsUpdateCallParams & {
            method: string;
        }>(params: TParams): {
            maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            signer?: (TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount) | undefined;
            rekeyTo?: (string | Address) | undefined;
            note?: (Uint8Array | string) | undefined;
            lease?: (Uint8Array | string) | undefined;
            staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            validityWindow?: number | bigint | undefined;
            firstValidRound?: bigint | undefined;
            lastValidRound?: bigint | undefined;
            onComplete?: OnApplicationComplete | undefined;
            accountReferences?: (string | Address)[] | undefined;
            appReferences?: bigint[] | undefined;
            assetReferences?: bigint[] | undefined;
            boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference | import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier)[] | undefined;
            sender?: (Address | string) | undefined;
            method: string;
            args?: (import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | AppMethodCallTransactionArgument | undefined)[] | undefined;
        } & AppClientCompilationParams;
        /**
         * Constructs update ABI call params for the Subscriptions smart contract using the update(string)void ABI method
         *
         * @param params Parameters for the call
         * @returns An `AppClientMethodCallParams` object for the call
         */
        update(params: CallParams<SubscriptionsArgs["obj"]["update(string)void"] | SubscriptionsArgs["tuple"]["update(string)void"]> & AppClientCompilationParams): AppClientMethodCallParams & AppClientCompilationParams;
    };
    /**
     * Constructs a no op call for the newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64 ABI method
     *
     * newService creates a new service for a merchant
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static newService(params: CallParams<SubscriptionsArgs['obj']['newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64'] | SubscriptionsArgs['tuple']['newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the setServiceDescription(uint64,byte[])void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static setServiceDescription(params: CallParams<SubscriptionsArgs['obj']['setServiceDescription(uint64,byte[])void'] | SubscriptionsArgs['tuple']['setServiceDescription(uint64,byte[])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the activateService()void ABI method
     *
     * activateService activates an service for a merchant
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static activateService(params: CallParams<SubscriptionsArgs['obj']['activateService()void'] | SubscriptionsArgs['tuple']['activateService()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the pauseService(uint64)void ABI method
     *
    * pauseService pauses a service for a merchant
    it does not shutdown pre-existing subscriptions
    it simply prevents new subscriptions from being created
    for a specific service
  
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static pauseService(params: CallParams<SubscriptionsArgs['obj']['pauseService(uint64)void'] | SubscriptionsArgs['tuple']['pauseService(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the unpauseService(uint64)void ABI method
     *
     * unpauseService activates an service for a merchant
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static unpauseService(params: CallParams<SubscriptionsArgs['obj']['unpauseService(uint64)void'] | SubscriptionsArgs['tuple']['unpauseService(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the shutdownService(uint64)void ABI method
     *
    * shutdownService permanently shuts down an service for a merchant
    it also shutsdown pre-existing subscriptions
  
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static shutdownService(params: CallParams<SubscriptionsArgs['obj']['shutdownService(uint64)void'] | SubscriptionsArgs['tuple']['shutdownService(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the block(pay,address)void ABI method
     *
     * block blacklists an address for a merchant
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static block(params: CallParams<SubscriptionsArgs['obj']['block(pay,address)void'] | SubscriptionsArgs['tuple']['block(pay,address)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the unblock(address)void ABI method
     *
     * unblock removes an address from a merchants blocks
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static unblock(params: CallParams<SubscriptionsArgs['obj']['unblock(address)void'] | SubscriptionsArgs['tuple']['unblock(address)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static gatedSubscribe(params: CallParams<SubscriptionsArgs['obj']['gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64'] | SubscriptionsArgs['tuple']['gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the subscribe(pay,address,uint64,uint64,uint64)uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static subscribe(params: CallParams<SubscriptionsArgs['obj']['subscribe(pay,address,uint64,uint64,uint64)uint64'] | SubscriptionsArgs['tuple']['subscribe(pay,address,uint64,uint64,uint64)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static gatedSubscribeAsa(params: CallParams<SubscriptionsArgs['obj']['gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64'] | SubscriptionsArgs['tuple']['gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static subscribeAsa(params: CallParams<SubscriptionsArgs['obj']['subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64'] | SubscriptionsArgs['tuple']['subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the deposit(pay,uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static deposit(params: CallParams<SubscriptionsArgs['obj']['deposit(pay,uint64)void'] | SubscriptionsArgs['tuple']['deposit(pay,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the depositAsa(axfer,uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static depositAsa(params: CallParams<SubscriptionsArgs['obj']['depositAsa(axfer,uint64)void'] | SubscriptionsArgs['tuple']['depositAsa(axfer,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the withdraw(uint64,uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static withdraw(params: CallParams<SubscriptionsArgs['obj']['withdraw(uint64,uint64)void'] | SubscriptionsArgs['tuple']['withdraw(uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the unsubscribe(uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static unsubscribe(params: CallParams<SubscriptionsArgs['obj']['unsubscribe(uint64)void'] | SubscriptionsArgs['tuple']['unsubscribe(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the gatedTriggerPayment(appl,(address,uint64))void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static gatedTriggerPayment(params: CallParams<SubscriptionsArgs['obj']['gatedTriggerPayment(appl,(address,uint64))void'] | SubscriptionsArgs['tuple']['gatedTriggerPayment(appl,(address,uint64))void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the triggerPayment((address,uint64))void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static triggerPayment(params: CallParams<SubscriptionsArgs['obj']['triggerPayment((address,uint64))void'] | SubscriptionsArgs['tuple']['triggerPayment((address,uint64))void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the streakCheck((address,uint64))void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static streakCheck(params: CallParams<SubscriptionsArgs['obj']['streakCheck((address,uint64))void'] | SubscriptionsArgs['tuple']['streakCheck((address,uint64))void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the setPasses(uint64,address[])void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static setPasses(params: CallParams<SubscriptionsArgs['obj']['setPasses(uint64,address[])void'] | SubscriptionsArgs['tuple']['setPasses(uint64,address[])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the triggerList((address,uint64[])[])bool[] ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static triggerList(params: CallParams<SubscriptionsArgs['obj']['triggerList((address,uint64[])[])bool[]'] | SubscriptionsArgs['tuple']['triggerList((address,uint64[])[])bool[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the isBlocked(address,address)bool ABI method
     *
     * isBlocked checks if an address is blocked for a merchant
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static isBlocked(params: CallParams<SubscriptionsArgs['obj']['isBlocked(address,address)bool'] | SubscriptionsArgs['tuple']['isBlocked(address,address)bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the isShutdown(address,uint64)bool ABI method
     *
     * serviceIsActive checks if an service is shutdown
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static isShutdown(params: CallParams<SubscriptionsArgs['obj']['isShutdown(address,uint64)bool'] | SubscriptionsArgs['tuple']['isShutdown(address,uint64)bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the newServiceCost(uint64)uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static newServiceCost(params: CallParams<SubscriptionsArgs['obj']['newServiceCost(uint64)uint64'] | SubscriptionsArgs['tuple']['newServiceCost(uint64)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the newSubscriptionCost(address,uint64,uint64)uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static newSubscriptionCost(params: CallParams<SubscriptionsArgs['obj']['newSubscriptionCost(address,uint64,uint64)uint64'] | SubscriptionsArgs['tuple']['newSubscriptionCost(address,uint64,uint64)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the blockCost()uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static blockCost(params: CallParams<SubscriptionsArgs['obj']['blockCost()uint64'] | SubscriptionsArgs['tuple']['blockCost()uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3]) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static getService(params: CallParams<SubscriptionsArgs['obj']['getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])'] | SubscriptionsArgs['tuple']['getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[] ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static getServicesByAddress(params: CallParams<SubscriptionsArgs['obj']['getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]'] | SubscriptionsArgs['tuple']['getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static getSubscription(params: CallParams<SubscriptionsArgs['obj']['getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | SubscriptionsArgs['tuple']['getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static mustGetSubscription(params: CallParams<SubscriptionsArgs['obj']['mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | SubscriptionsArgs['tuple']['mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[]) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static getSubscriptionWithDetails(params: CallParams<SubscriptionsArgs['obj']['getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])'] | SubscriptionsArgs['tuple']['getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the isFirstSubscription(address)bool ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static isFirstSubscription(params: CallParams<SubscriptionsArgs['obj']['isFirstSubscription(address)bool'] | SubscriptionsArgs['tuple']['isFirstSubscription(address)bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the getServiceList(address)uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static getServiceList(params: CallParams<SubscriptionsArgs['obj']['getServiceList(address)uint64'] | SubscriptionsArgs['tuple']['getServiceList(address)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the getSubscriptionList(address)uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static getSubscriptionList(params: CallParams<SubscriptionsArgs['obj']['getSubscriptionList(address)uint64'] | SubscriptionsArgs['tuple']['getSubscriptionList(address)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the optIn(pay,uint64)void ABI method
     *
     * optin tells the contract to opt into an asa
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static optIn(params: CallParams<SubscriptionsArgs['obj']['optIn(pay,uint64)void'] | SubscriptionsArgs['tuple']['optIn(pay,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the optInCost(uint64)uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static optInCost(params: CallParams<SubscriptionsArgs['obj']['optInCost(uint64)uint64'] | SubscriptionsArgs['tuple']['optInCost(uint64)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the updateAkitaDAOEscrow(uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static updateAkitaDaoEscrow(params: CallParams<SubscriptionsArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | SubscriptionsArgs['tuple']['updateAkitaDAOEscrow(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the updateAkitaDAO(uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static updateAkitaDao(params: CallParams<SubscriptionsArgs['obj']['updateAkitaDAO(uint64)void'] | SubscriptionsArgs['tuple']['updateAkitaDAO(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the opUp()void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static opUp(params: CallParams<SubscriptionsArgs['obj']['opUp()void'] | SubscriptionsArgs['tuple']['opUp()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
}
/**
 * A factory to create and deploy one or more instance of the Subscriptions smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export declare class SubscriptionsFactory {
    /**
     * The underlying `AppFactory` for when you want to have more flexibility
     */
    readonly appFactory: _AppFactory;
    /**
     * Creates a new instance of `SubscriptionsFactory`
     *
     * @param params The parameters to initialise the app factory with
     */
    constructor(params: Omit<AppFactoryParams, 'appSpec'>);
    /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
    get appName(): string;
    /** The ARC-56 app spec being used */
    get appSpec(): Arc56Contract;
    /** A reference to the underlying `AlgorandClient` this app factory is using. */
    get algorand(): AlgorandClient;
    /**
     * Returns a new `AppClient` client for an app instance of the given ID.
     *
     * Automatically populates appName, defaultSender and source maps from the factory
     * if not specified in the params.
     * @param params The parameters to create the app client
     * @returns The `AppClient`
     */
    getAppClientById(params: AppFactoryAppClientParams): SubscriptionsClient;
    /**
     * Returns a new `AppClient` client, resolving the app by creator address and name
     * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
     *
     * Automatically populates appName, defaultSender and source maps from the factory
     * if not specified in the params.
     * @param params The parameters to create the app client
     * @returns The `AppClient`
     */
    getAppClientByCreatorAndName(params: AppFactoryResolveAppClientByCreatorAndNameParams): Promise<SubscriptionsClient>;
    /**
     * Idempotently deploys the Subscriptions smart contract.
     *
     * @param params The arguments for the contract calls and any additional parameters for the call
     * @returns The deployment result
     */
    deploy(params?: SubscriptionsDeployParams): Promise<{
        result: {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "create";
            version: string;
            name: string;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            appId: bigint;
            appAddress: Address;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "update";
            appId: bigint;
            appAddress: Address;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            name: string;
            version: string;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "replace";
            version: string;
            name: string;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            appId: bigint;
            appAddress: Address;
            deleteResult: import("@algorandfoundation/algokit-utils/types/transaction").ConfirmedTransactionResult;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "nothing";
            appId: bigint;
            appAddress: Address;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            name: string;
            version: string;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
        };
        appClient: SubscriptionsClient;
    }>;
    /**
     * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
     */
    readonly params: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the Subscriptions smart contract using the create(string,uint64,uint64)void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The create params
             */
            create: (params: CallParams<SubscriptionsArgs["obj"]["create(string,uint64,uint64)void"] | SubscriptionsArgs["tuple"]["create(string,uint64,uint64)void"]> & AppClientCompilationParams & CreateSchema & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                deployTimeParams: import("@algorandfoundation/algokit-utils/types/app").TealTemplateParams | undefined;
                schema: {
                    globalInts: number;
                    globalByteSlices: number;
                    localInts: number;
                    localByteSlices: number;
                };
                approvalProgram: Uint8Array;
                clearStateProgram: Uint8Array;
                maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                note?: string | Uint8Array | undefined;
                signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                lease?: string | Uint8Array | undefined;
                rekeyTo?: string | Address | undefined;
                staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                validityWindow?: number | bigint | undefined;
                firstValidRound?: bigint | undefined;
                lastValidRound?: bigint | undefined;
                accountReferences?: (string | Address)[] | undefined;
                appReferences?: bigint[] | undefined;
                assetReferences?: bigint[] | undefined;
                boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                sender?: string | Address | undefined;
                method: string;
                args?: (import("algosdk").ABIValue | AppMethodCallTransactionArgument | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined)[] | undefined;
                updatable?: boolean | undefined;
                deletable?: boolean | undefined;
                extraProgramPages?: number | undefined;
            } & {
                sender: Address;
                signer: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                method: import("@algorandfoundation/algokit-utils/types/app-arc56").Arc56Method;
                args: (Transaction | import("algosdk").ABIValue | import("algosdk").TransactionWithSigner | Promise<Transaction> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    note?: string | Uint8Array | undefined;
                    args?: Uint8Array[] | undefined;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                    lease?: string | Uint8Array | undefined;
                    rekeyTo?: string | Address | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                    schema?: {
                        globalInts: number;
                        globalByteSlices: number;
                        localInts: number;
                        localByteSlices: number;
                    } | undefined;
                    extraProgramPages?: number | undefined;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    rekeyTo?: string | Address | undefined;
                    note?: string | Uint8Array | undefined;
                    lease?: string | Uint8Array | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    appId: bigint;
                    onComplete?: OnApplicationComplete.UpdateApplicationOC | undefined;
                    args?: Uint8Array[] | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<import("@algorandfoundation/algokit-utils/types/composer").AppMethodCallParams> | undefined)[] | undefined;
                onComplete: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC;
            }>;
        };
        /**
         * Gets available deployUpdate methods
         */
        deployUpdate: {
            /**
             * Updates an existing instance of the Subscriptions smart contract using the update(string)void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The deployUpdate params
             */
            update: (params: CallParams<SubscriptionsArgs["obj"]["update(string)void"] | SubscriptionsArgs["tuple"]["update(string)void"]> & AppClientCompilationParams) => {
                maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                note?: string | Uint8Array | undefined;
                signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                onComplete?: OnApplicationComplete | undefined;
                lease?: string | Uint8Array | undefined;
                rekeyTo?: string | Address | undefined;
                staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                validityWindow?: number | bigint | undefined;
                firstValidRound?: bigint | undefined;
                lastValidRound?: bigint | undefined;
                accountReferences?: (string | Address)[] | undefined;
                appReferences?: bigint[] | undefined;
                assetReferences?: bigint[] | undefined;
                boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                sender?: string | Address | undefined;
                method: string;
                args?: (import("algosdk").ABIValue | AppMethodCallTransactionArgument | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined)[] | undefined;
            } & {
                sender: Address;
                signer: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                method: import("@algorandfoundation/algokit-utils/types/app-arc56").Arc56Method;
                args: (Transaction | import("algosdk").ABIValue | import("algosdk").TransactionWithSigner | Promise<Transaction> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    note?: string | Uint8Array | undefined;
                    args?: Uint8Array[] | undefined;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                    lease?: string | Uint8Array | undefined;
                    rekeyTo?: string | Address | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                    schema?: {
                        globalInts: number;
                        globalByteSlices: number;
                        localInts: number;
                        localByteSlices: number;
                    } | undefined;
                    extraProgramPages?: number | undefined;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    rekeyTo?: string | Address | undefined;
                    note?: string | Uint8Array | undefined;
                    lease?: string | Uint8Array | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    appId: bigint;
                    onComplete?: OnApplicationComplete.UpdateApplicationOC | undefined;
                    args?: Uint8Array[] | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<import("@algorandfoundation/algokit-utils/types/composer").AppMethodCallParams> | undefined)[] | undefined;
                onComplete: OnApplicationComplete.UpdateApplicationOC;
            };
        };
    };
    /**
     * Create transactions for the current app
     */
    readonly createTransaction: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the Subscriptions smart contract using the create(string,uint64,uint64)void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The create transaction
             */
            create: (params: CallParams<SubscriptionsArgs["obj"]["create(string,uint64,uint64)void"] | SubscriptionsArgs["tuple"]["create(string,uint64,uint64)void"]> & AppClientCompilationParams & CreateSchema & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                transactions: Transaction[];
                methodCalls: Map<number, import("algosdk").ABIMethod>;
                signers: Map<number, TransactionSigner>;
            }>;
        };
    };
    /**
     * Send calls to the current app
     */
    readonly send: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the Subscriptions smart contract using an ABI method call using the create(string,uint64,uint64)void ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The create result
             */
            create: (params: CallParams<SubscriptionsArgs["obj"]["create(string,uint64,uint64)void"] | SubscriptionsArgs["tuple"]["create(string,uint64,uint64)void"]> & AppClientCompilationParams & CreateSchema & SendParams & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                result: {
                    return: (undefined | SubscriptionsReturns["create(string,uint64,uint64)void"]);
                    compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                    compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                    appId: bigint;
                    groupId: string;
                    txIds: string[];
                    returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
                    confirmations: modelsv2.PendingTransactionResponse[];
                    transactions: Transaction[];
                    confirmation: modelsv2.PendingTransactionResponse;
                    transaction: Transaction;
                    appAddress: Address;
                };
                appClient: SubscriptionsClient;
            }>;
        };
    };
}
/**
 * A client to make calls to the Subscriptions smart contract
 */
export declare class SubscriptionsClient {
    /**
     * The underlying `AppClient` for when you want to have more flexibility
     */
    readonly appClient: _AppClient;
    /**
     * Creates a new instance of `SubscriptionsClient`
     *
     * @param appClient An `AppClient` instance which has been created with the Subscriptions app spec
     */
    constructor(appClient: _AppClient);
    /**
     * Creates a new instance of `SubscriptionsClient`
     *
     * @param params The parameters to initialise the app client with
     */
    constructor(params: Omit<AppClientParams, 'appSpec'>);
    /**
     * Checks for decode errors on the given return value and maps the return value to the return type for the given method
     * @returns The typed return value or undefined if there was no value
     */
    decodeReturnValue<TSignature extends SubscriptionsNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined): MethodReturn<TSignature> | undefined;
    /**
     * Returns a new `SubscriptionsClient` client, resolving the app by creator address and name
     * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
     * @param params The parameters to create the app client
     */
    static fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<SubscriptionsClient>;
    /**
     * Returns an `SubscriptionsClient` instance for the current network based on
     * pre-determined network-specific app IDs specified in the ARC-56 app spec.
     *
     * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
     * @param params The parameters to create the app client
     */
    static fromNetwork(params: Omit<ResolveAppClientByNetwork, 'appSpec'>): Promise<SubscriptionsClient>;
    /** The ID of the app instance this client is linked to. */
    get appId(): bigint;
    /** The app address of the app instance this client is linked to. */
    get appAddress(): Address;
    /** The name of the app. */
    get appName(): string;
    /** The ARC-56 app spec being used */
    get appSpec(): Arc56Contract;
    /** A reference to the underlying `AlgorandClient` this app client is using. */
    get algorand(): AlgorandClient;
    /**
     * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
     */
    readonly params: {
        /**
         * Gets available update methods
         */
        update: {
            /**
             * Updates an existing instance of the Subscriptions smart contract using the `update(string)void` ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The update params
             */
            update: (params: CallParams<SubscriptionsArgs["obj"]["update(string)void"] | SubscriptionsArgs["tuple"]["update(string)void"]> & AppClientCompilationParams) => Promise<{
                approvalProgram: Uint8Array;
                clearStateProgram: Uint8Array;
                compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                note?: string | Uint8Array | undefined;
                signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                onComplete?: OnApplicationComplete | undefined;
                lease?: string | Uint8Array | undefined;
                rekeyTo?: string | Address | undefined;
                staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                validityWindow?: number | bigint | undefined;
                firstValidRound?: bigint | undefined;
                lastValidRound?: bigint | undefined;
                accountReferences?: (string | Address)[] | undefined;
                appReferences?: bigint[] | undefined;
                assetReferences?: bigint[] | undefined;
                boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                sender?: string | Address | undefined;
                method: string;
                args?: (import("algosdk").ABIValue | AppMethodCallTransactionArgument | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined)[] | undefined;
                deployTimeParams?: import("@algorandfoundation/algokit-utils/types/app").TealTemplateParams | undefined;
                updatable?: boolean | undefined;
                deletable?: boolean | undefined;
            } & {
                appId: bigint;
                sender: Address;
                signer: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                method: import("@algorandfoundation/algokit-utils/types/app-arc56").Arc56Method;
                onComplete: OnApplicationComplete.UpdateApplicationOC;
                args: (Transaction | import("algosdk").ABIValue | import("algosdk").TransactionWithSigner | Promise<Transaction> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    note?: string | Uint8Array | undefined;
                    args?: Uint8Array[] | undefined;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                    lease?: string | Uint8Array | undefined;
                    rekeyTo?: string | Address | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                    schema?: {
                        globalInts: number;
                        globalByteSlices: number;
                        localInts: number;
                        localByteSlices: number;
                    } | undefined;
                    extraProgramPages?: number | undefined;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string | Address;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    rekeyTo?: string | Address | undefined;
                    note?: string | Uint8Array | undefined;
                    lease?: string | Uint8Array | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | bigint | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    appId: bigint;
                    onComplete?: OnApplicationComplete.UpdateApplicationOC | undefined;
                    args?: Uint8Array[] | undefined;
                    accountReferences?: (string | Address)[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<import("@algorandfoundation/algokit-utils/types/composer").AppMethodCallParams> | undefined)[] | undefined;
            }>;
        };
        /**
         * Makes a clear_state call to an existing instance of the Subscriptions smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams>) => import("@algorandfoundation/algokit-utils/types/composer").AppCallParams;
        /**
         * Makes a call to the Subscriptions smart contract using the `newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64` ABI method.
         *
         * newService creates a new service for a merchant
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        newService: (params: CallParams<SubscriptionsArgs["obj"]["newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64"] | SubscriptionsArgs["tuple"]["newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `setServiceDescription(uint64,byte[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        setServiceDescription: (params: CallParams<SubscriptionsArgs["obj"]["setServiceDescription(uint64,byte[])void"] | SubscriptionsArgs["tuple"]["setServiceDescription(uint64,byte[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `activateService()void` ABI method.
         *
         * activateService activates an service for a merchant
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        activateService: (params?: CallParams<SubscriptionsArgs["obj"]["activateService()void"] | SubscriptionsArgs["tuple"]["activateService()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `pauseService(uint64)void` ABI method.
         *
        * pauseService pauses a service for a merchant
        it does not shutdown pre-existing subscriptions
        it simply prevents new subscriptions from being created
        for a specific service
    
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        pauseService: (params: CallParams<SubscriptionsArgs["obj"]["pauseService(uint64)void"] | SubscriptionsArgs["tuple"]["pauseService(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `unpauseService(uint64)void` ABI method.
         *
         * unpauseService activates an service for a merchant
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        unpauseService: (params: CallParams<SubscriptionsArgs["obj"]["unpauseService(uint64)void"] | SubscriptionsArgs["tuple"]["unpauseService(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `shutdownService(uint64)void` ABI method.
         *
        * shutdownService permanently shuts down an service for a merchant
        it also shutsdown pre-existing subscriptions
    
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        shutdownService: (params: CallParams<SubscriptionsArgs["obj"]["shutdownService(uint64)void"] | SubscriptionsArgs["tuple"]["shutdownService(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `block(pay,address)void` ABI method.
         *
         * block blacklists an address for a merchant
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        block: (params: CallParams<SubscriptionsArgs["obj"]["block(pay,address)void"] | SubscriptionsArgs["tuple"]["block(pay,address)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `unblock(address)void` ABI method.
         *
         * unblock removes an address from a merchants blocks
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        unblock: (params: CallParams<SubscriptionsArgs["obj"]["unblock(address)void"] | SubscriptionsArgs["tuple"]["unblock(address)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        gatedSubscribe: (params: CallParams<SubscriptionsArgs["obj"]["gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64"] | SubscriptionsArgs["tuple"]["gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `subscribe(pay,address,uint64,uint64,uint64)uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        subscribe: (params: CallParams<SubscriptionsArgs["obj"]["subscribe(pay,address,uint64,uint64,uint64)uint64"] | SubscriptionsArgs["tuple"]["subscribe(pay,address,uint64,uint64,uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        gatedSubscribeAsa: (params: CallParams<SubscriptionsArgs["obj"]["gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64"] | SubscriptionsArgs["tuple"]["gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        subscribeAsa: (params: CallParams<SubscriptionsArgs["obj"]["subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64"] | SubscriptionsArgs["tuple"]["subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `deposit(pay,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        deposit: (params: CallParams<SubscriptionsArgs["obj"]["deposit(pay,uint64)void"] | SubscriptionsArgs["tuple"]["deposit(pay,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `depositAsa(axfer,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        depositAsa: (params: CallParams<SubscriptionsArgs["obj"]["depositAsa(axfer,uint64)void"] | SubscriptionsArgs["tuple"]["depositAsa(axfer,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `withdraw(uint64,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        withdraw: (params: CallParams<SubscriptionsArgs["obj"]["withdraw(uint64,uint64)void"] | SubscriptionsArgs["tuple"]["withdraw(uint64,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `unsubscribe(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        unsubscribe: (params: CallParams<SubscriptionsArgs["obj"]["unsubscribe(uint64)void"] | SubscriptionsArgs["tuple"]["unsubscribe(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `gatedTriggerPayment(appl,(address,uint64))void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        gatedTriggerPayment: (params: CallParams<SubscriptionsArgs["obj"]["gatedTriggerPayment(appl,(address,uint64))void"] | SubscriptionsArgs["tuple"]["gatedTriggerPayment(appl,(address,uint64))void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `triggerPayment((address,uint64))void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        triggerPayment: (params: CallParams<SubscriptionsArgs["obj"]["triggerPayment((address,uint64))void"] | SubscriptionsArgs["tuple"]["triggerPayment((address,uint64))void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `streakCheck((address,uint64))void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        streakCheck: (params: CallParams<SubscriptionsArgs["obj"]["streakCheck((address,uint64))void"] | SubscriptionsArgs["tuple"]["streakCheck((address,uint64))void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `setPasses(uint64,address[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        setPasses: (params: CallParams<SubscriptionsArgs["obj"]["setPasses(uint64,address[])void"] | SubscriptionsArgs["tuple"]["setPasses(uint64,address[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `triggerList((address,uint64[])[])bool[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        triggerList: (params: CallParams<SubscriptionsArgs["obj"]["triggerList((address,uint64[])[])bool[]"] | SubscriptionsArgs["tuple"]["triggerList((address,uint64[])[])bool[]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `isBlocked(address,address)bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * isBlocked checks if an address is blocked for a merchant
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        isBlocked: (params: CallParams<SubscriptionsArgs["obj"]["isBlocked(address,address)bool"] | SubscriptionsArgs["tuple"]["isBlocked(address,address)bool"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `isShutdown(address,uint64)bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * serviceIsActive checks if an service is shutdown
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        isShutdown: (params: CallParams<SubscriptionsArgs["obj"]["isShutdown(address,uint64)bool"] | SubscriptionsArgs["tuple"]["isShutdown(address,uint64)bool"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `newServiceCost(uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        newServiceCost: (params: CallParams<SubscriptionsArgs["obj"]["newServiceCost(uint64)uint64"] | SubscriptionsArgs["tuple"]["newServiceCost(uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `newSubscriptionCost(address,uint64,uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        newSubscriptionCost: (params: CallParams<SubscriptionsArgs["obj"]["newSubscriptionCost(address,uint64,uint64)uint64"] | SubscriptionsArgs["tuple"]["newSubscriptionCost(address,uint64,uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `blockCost()uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        blockCost: (params?: CallParams<SubscriptionsArgs["obj"]["blockCost()uint64"] | SubscriptionsArgs["tuple"]["blockCost()uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        getService: (params: CallParams<SubscriptionsArgs["obj"]["getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])"] | SubscriptionsArgs["tuple"]["getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        getServicesByAddress: (params: CallParams<SubscriptionsArgs["obj"]["getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]"] | SubscriptionsArgs["tuple"]["getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        getSubscription: (params: CallParams<SubscriptionsArgs["obj"]["getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"] | SubscriptionsArgs["tuple"]["getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        mustGetSubscription: (params: CallParams<SubscriptionsArgs["obj"]["mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"] | SubscriptionsArgs["tuple"]["mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        getSubscriptionWithDetails: (params: CallParams<SubscriptionsArgs["obj"]["getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])"] | SubscriptionsArgs["tuple"]["getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `isFirstSubscription(address)bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        isFirstSubscription: (params: CallParams<SubscriptionsArgs["obj"]["isFirstSubscription(address)bool"] | SubscriptionsArgs["tuple"]["isFirstSubscription(address)bool"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `getServiceList(address)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        getServiceList: (params: CallParams<SubscriptionsArgs["obj"]["getServiceList(address)uint64"] | SubscriptionsArgs["tuple"]["getServiceList(address)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `getSubscriptionList(address)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        getSubscriptionList: (params: CallParams<SubscriptionsArgs["obj"]["getSubscriptionList(address)uint64"] | SubscriptionsArgs["tuple"]["getSubscriptionList(address)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `optIn(pay,uint64)void` ABI method.
         *
         * optin tells the contract to opt into an asa
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        optIn: (params: CallParams<SubscriptionsArgs["obj"]["optIn(pay,uint64)void"] | SubscriptionsArgs["tuple"]["optIn(pay,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `optInCost(uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        optInCost: (params: CallParams<SubscriptionsArgs["obj"]["optInCost(uint64)uint64"] | SubscriptionsArgs["tuple"]["optInCost(uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `updateAkitaDAOEscrow(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        updateAkitaDaoEscrow: (params: CallParams<SubscriptionsArgs["obj"]["updateAkitaDAOEscrow(uint64)void"] | SubscriptionsArgs["tuple"]["updateAkitaDAOEscrow(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `updateAkitaDAO(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        updateAkitaDao: (params: CallParams<SubscriptionsArgs["obj"]["updateAkitaDAO(uint64)void"] | SubscriptionsArgs["tuple"]["updateAkitaDAO(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Subscriptions smart contract using the `opUp()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        opUp: (params?: CallParams<SubscriptionsArgs["obj"]["opUp()void"] | SubscriptionsArgs["tuple"]["opUp()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
    };
    /**
     * Create transactions for the current app
     */
    readonly createTransaction: {
        /**
         * Gets available update methods
         */
        update: {
            /**
             * Updates an existing instance of the Subscriptions smart contract using the `update(string)void` ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The update transaction
             */
            update: (params: CallParams<SubscriptionsArgs["obj"]["update(string)void"] | SubscriptionsArgs["tuple"]["update(string)void"]> & AppClientCompilationParams) => Promise<{
                transactions: Transaction[];
                methodCalls: Map<number, import("algosdk").ABIMethod>;
                signers: Map<number, TransactionSigner>;
            }>;
        };
        /**
         * Makes a clear_state call to an existing instance of the Subscriptions smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams>) => Promise<Transaction>;
        /**
         * Makes a call to the Subscriptions smart contract using the `newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64` ABI method.
         *
         * newService creates a new service for a merchant
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        newService: (params: CallParams<SubscriptionsArgs["obj"]["newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64"] | SubscriptionsArgs["tuple"]["newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `setServiceDescription(uint64,byte[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        setServiceDescription: (params: CallParams<SubscriptionsArgs["obj"]["setServiceDescription(uint64,byte[])void"] | SubscriptionsArgs["tuple"]["setServiceDescription(uint64,byte[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `activateService()void` ABI method.
         *
         * activateService activates an service for a merchant
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        activateService: (params?: CallParams<SubscriptionsArgs["obj"]["activateService()void"] | SubscriptionsArgs["tuple"]["activateService()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `pauseService(uint64)void` ABI method.
         *
        * pauseService pauses a service for a merchant
        it does not shutdown pre-existing subscriptions
        it simply prevents new subscriptions from being created
        for a specific service
    
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        pauseService: (params: CallParams<SubscriptionsArgs["obj"]["pauseService(uint64)void"] | SubscriptionsArgs["tuple"]["pauseService(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `unpauseService(uint64)void` ABI method.
         *
         * unpauseService activates an service for a merchant
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        unpauseService: (params: CallParams<SubscriptionsArgs["obj"]["unpauseService(uint64)void"] | SubscriptionsArgs["tuple"]["unpauseService(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `shutdownService(uint64)void` ABI method.
         *
        * shutdownService permanently shuts down an service for a merchant
        it also shutsdown pre-existing subscriptions
    
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        shutdownService: (params: CallParams<SubscriptionsArgs["obj"]["shutdownService(uint64)void"] | SubscriptionsArgs["tuple"]["shutdownService(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `block(pay,address)void` ABI method.
         *
         * block blacklists an address for a merchant
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        block: (params: CallParams<SubscriptionsArgs["obj"]["block(pay,address)void"] | SubscriptionsArgs["tuple"]["block(pay,address)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `unblock(address)void` ABI method.
         *
         * unblock removes an address from a merchants blocks
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        unblock: (params: CallParams<SubscriptionsArgs["obj"]["unblock(address)void"] | SubscriptionsArgs["tuple"]["unblock(address)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        gatedSubscribe: (params: CallParams<SubscriptionsArgs["obj"]["gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64"] | SubscriptionsArgs["tuple"]["gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `subscribe(pay,address,uint64,uint64,uint64)uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        subscribe: (params: CallParams<SubscriptionsArgs["obj"]["subscribe(pay,address,uint64,uint64,uint64)uint64"] | SubscriptionsArgs["tuple"]["subscribe(pay,address,uint64,uint64,uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        gatedSubscribeAsa: (params: CallParams<SubscriptionsArgs["obj"]["gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64"] | SubscriptionsArgs["tuple"]["gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        subscribeAsa: (params: CallParams<SubscriptionsArgs["obj"]["subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64"] | SubscriptionsArgs["tuple"]["subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `deposit(pay,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        deposit: (params: CallParams<SubscriptionsArgs["obj"]["deposit(pay,uint64)void"] | SubscriptionsArgs["tuple"]["deposit(pay,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `depositAsa(axfer,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        depositAsa: (params: CallParams<SubscriptionsArgs["obj"]["depositAsa(axfer,uint64)void"] | SubscriptionsArgs["tuple"]["depositAsa(axfer,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `withdraw(uint64,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        withdraw: (params: CallParams<SubscriptionsArgs["obj"]["withdraw(uint64,uint64)void"] | SubscriptionsArgs["tuple"]["withdraw(uint64,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `unsubscribe(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        unsubscribe: (params: CallParams<SubscriptionsArgs["obj"]["unsubscribe(uint64)void"] | SubscriptionsArgs["tuple"]["unsubscribe(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `gatedTriggerPayment(appl,(address,uint64))void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        gatedTriggerPayment: (params: CallParams<SubscriptionsArgs["obj"]["gatedTriggerPayment(appl,(address,uint64))void"] | SubscriptionsArgs["tuple"]["gatedTriggerPayment(appl,(address,uint64))void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `triggerPayment((address,uint64))void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        triggerPayment: (params: CallParams<SubscriptionsArgs["obj"]["triggerPayment((address,uint64))void"] | SubscriptionsArgs["tuple"]["triggerPayment((address,uint64))void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `streakCheck((address,uint64))void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        streakCheck: (params: CallParams<SubscriptionsArgs["obj"]["streakCheck((address,uint64))void"] | SubscriptionsArgs["tuple"]["streakCheck((address,uint64))void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `setPasses(uint64,address[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        setPasses: (params: CallParams<SubscriptionsArgs["obj"]["setPasses(uint64,address[])void"] | SubscriptionsArgs["tuple"]["setPasses(uint64,address[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `triggerList((address,uint64[])[])bool[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        triggerList: (params: CallParams<SubscriptionsArgs["obj"]["triggerList((address,uint64[])[])bool[]"] | SubscriptionsArgs["tuple"]["triggerList((address,uint64[])[])bool[]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `isBlocked(address,address)bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * isBlocked checks if an address is blocked for a merchant
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        isBlocked: (params: CallParams<SubscriptionsArgs["obj"]["isBlocked(address,address)bool"] | SubscriptionsArgs["tuple"]["isBlocked(address,address)bool"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `isShutdown(address,uint64)bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * serviceIsActive checks if an service is shutdown
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        isShutdown: (params: CallParams<SubscriptionsArgs["obj"]["isShutdown(address,uint64)bool"] | SubscriptionsArgs["tuple"]["isShutdown(address,uint64)bool"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `newServiceCost(uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        newServiceCost: (params: CallParams<SubscriptionsArgs["obj"]["newServiceCost(uint64)uint64"] | SubscriptionsArgs["tuple"]["newServiceCost(uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `newSubscriptionCost(address,uint64,uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        newSubscriptionCost: (params: CallParams<SubscriptionsArgs["obj"]["newSubscriptionCost(address,uint64,uint64)uint64"] | SubscriptionsArgs["tuple"]["newSubscriptionCost(address,uint64,uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `blockCost()uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        blockCost: (params?: CallParams<SubscriptionsArgs["obj"]["blockCost()uint64"] | SubscriptionsArgs["tuple"]["blockCost()uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        getService: (params: CallParams<SubscriptionsArgs["obj"]["getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])"] | SubscriptionsArgs["tuple"]["getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        getServicesByAddress: (params: CallParams<SubscriptionsArgs["obj"]["getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]"] | SubscriptionsArgs["tuple"]["getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        getSubscription: (params: CallParams<SubscriptionsArgs["obj"]["getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"] | SubscriptionsArgs["tuple"]["getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        mustGetSubscription: (params: CallParams<SubscriptionsArgs["obj"]["mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"] | SubscriptionsArgs["tuple"]["mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        getSubscriptionWithDetails: (params: CallParams<SubscriptionsArgs["obj"]["getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])"] | SubscriptionsArgs["tuple"]["getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `isFirstSubscription(address)bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        isFirstSubscription: (params: CallParams<SubscriptionsArgs["obj"]["isFirstSubscription(address)bool"] | SubscriptionsArgs["tuple"]["isFirstSubscription(address)bool"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `getServiceList(address)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        getServiceList: (params: CallParams<SubscriptionsArgs["obj"]["getServiceList(address)uint64"] | SubscriptionsArgs["tuple"]["getServiceList(address)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `getSubscriptionList(address)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        getSubscriptionList: (params: CallParams<SubscriptionsArgs["obj"]["getSubscriptionList(address)uint64"] | SubscriptionsArgs["tuple"]["getSubscriptionList(address)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `optIn(pay,uint64)void` ABI method.
         *
         * optin tells the contract to opt into an asa
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        optIn: (params: CallParams<SubscriptionsArgs["obj"]["optIn(pay,uint64)void"] | SubscriptionsArgs["tuple"]["optIn(pay,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `optInCost(uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        optInCost: (params: CallParams<SubscriptionsArgs["obj"]["optInCost(uint64)uint64"] | SubscriptionsArgs["tuple"]["optInCost(uint64)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `updateAkitaDAOEscrow(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        updateAkitaDaoEscrow: (params: CallParams<SubscriptionsArgs["obj"]["updateAkitaDAOEscrow(uint64)void"] | SubscriptionsArgs["tuple"]["updateAkitaDAOEscrow(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `updateAkitaDAO(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        updateAkitaDao: (params: CallParams<SubscriptionsArgs["obj"]["updateAkitaDAO(uint64)void"] | SubscriptionsArgs["tuple"]["updateAkitaDAO(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `opUp()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        opUp: (params?: CallParams<SubscriptionsArgs["obj"]["opUp()void"] | SubscriptionsArgs["tuple"]["opUp()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
    };
    /**
     * Send calls to the current app
     */
    readonly send: {
        /**
         * Gets available update methods
         */
        update: {
            /**
             * Updates an existing instance of the Subscriptions smart contract using the `update(string)void` ABI method.
             *
             * @param params The params for the smart contract call
             * @returns The update result
             */
            update: (params: CallParams<SubscriptionsArgs["obj"]["update(string)void"] | SubscriptionsArgs["tuple"]["update(string)void"]> & AppClientCompilationParams & SendParams) => Promise<{
                return: (undefined | SubscriptionsReturns["update(string)void"]);
                compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                groupId: string;
                txIds: string[];
                returns?: ABIReturn[] | undefined;
                confirmations: modelsv2.PendingTransactionResponse[];
                transactions: Transaction[];
                confirmation: modelsv2.PendingTransactionResponse;
                transaction: Transaction;
            }>;
        };
        /**
         * Makes a clear_state call to an existing instance of the Subscriptions smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => Promise<{
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            return?: ABIReturn | undefined;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64` ABI method.
         *
         * newService creates a new service for a merchant
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        newService: (params: CallParams<SubscriptionsArgs["obj"]["newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64"] | SubscriptionsArgs["tuple"]["newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `setServiceDescription(uint64,byte[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        setServiceDescription: (params: CallParams<SubscriptionsArgs["obj"]["setServiceDescription(uint64,byte[])void"] | SubscriptionsArgs["tuple"]["setServiceDescription(uint64,byte[])void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["setServiceDescription(uint64,byte[])void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `activateService()void` ABI method.
         *
         * activateService activates an service for a merchant
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        activateService: (params?: CallParams<SubscriptionsArgs["obj"]["activateService()void"] | SubscriptionsArgs["tuple"]["activateService()void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["activateService()void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `pauseService(uint64)void` ABI method.
         *
        * pauseService pauses a service for a merchant
        it does not shutdown pre-existing subscriptions
        it simply prevents new subscriptions from being created
        for a specific service
    
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        pauseService: (params: CallParams<SubscriptionsArgs["obj"]["pauseService(uint64)void"] | SubscriptionsArgs["tuple"]["pauseService(uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["pauseService(uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `unpauseService(uint64)void` ABI method.
         *
         * unpauseService activates an service for a merchant
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        unpauseService: (params: CallParams<SubscriptionsArgs["obj"]["unpauseService(uint64)void"] | SubscriptionsArgs["tuple"]["unpauseService(uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["unpauseService(uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `shutdownService(uint64)void` ABI method.
         *
        * shutdownService permanently shuts down an service for a merchant
        it also shutsdown pre-existing subscriptions
    
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        shutdownService: (params: CallParams<SubscriptionsArgs["obj"]["shutdownService(uint64)void"] | SubscriptionsArgs["tuple"]["shutdownService(uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["shutdownService(uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `block(pay,address)void` ABI method.
         *
         * block blacklists an address for a merchant
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        block: (params: CallParams<SubscriptionsArgs["obj"]["block(pay,address)void"] | SubscriptionsArgs["tuple"]["block(pay,address)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["block(pay,address)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `unblock(address)void` ABI method.
         *
         * unblock removes an address from a merchants blocks
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        unblock: (params: CallParams<SubscriptionsArgs["obj"]["unblock(address)void"] | SubscriptionsArgs["tuple"]["unblock(address)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["unblock(address)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        gatedSubscribe: (params: CallParams<SubscriptionsArgs["obj"]["gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64"] | SubscriptionsArgs["tuple"]["gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `subscribe(pay,address,uint64,uint64,uint64)uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        subscribe: (params: CallParams<SubscriptionsArgs["obj"]["subscribe(pay,address,uint64,uint64,uint64)uint64"] | SubscriptionsArgs["tuple"]["subscribe(pay,address,uint64,uint64,uint64)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["subscribe(pay,address,uint64,uint64,uint64)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        gatedSubscribeAsa: (params: CallParams<SubscriptionsArgs["obj"]["gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64"] | SubscriptionsArgs["tuple"]["gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        subscribeAsa: (params: CallParams<SubscriptionsArgs["obj"]["subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64"] | SubscriptionsArgs["tuple"]["subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `deposit(pay,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        deposit: (params: CallParams<SubscriptionsArgs["obj"]["deposit(pay,uint64)void"] | SubscriptionsArgs["tuple"]["deposit(pay,uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["deposit(pay,uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `depositAsa(axfer,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        depositAsa: (params: CallParams<SubscriptionsArgs["obj"]["depositAsa(axfer,uint64)void"] | SubscriptionsArgs["tuple"]["depositAsa(axfer,uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["depositAsa(axfer,uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `withdraw(uint64,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        withdraw: (params: CallParams<SubscriptionsArgs["obj"]["withdraw(uint64,uint64)void"] | SubscriptionsArgs["tuple"]["withdraw(uint64,uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["withdraw(uint64,uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `unsubscribe(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        unsubscribe: (params: CallParams<SubscriptionsArgs["obj"]["unsubscribe(uint64)void"] | SubscriptionsArgs["tuple"]["unsubscribe(uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["unsubscribe(uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `gatedTriggerPayment(appl,(address,uint64))void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        gatedTriggerPayment: (params: CallParams<SubscriptionsArgs["obj"]["gatedTriggerPayment(appl,(address,uint64))void"] | SubscriptionsArgs["tuple"]["gatedTriggerPayment(appl,(address,uint64))void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["gatedTriggerPayment(appl,(address,uint64))void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `triggerPayment((address,uint64))void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        triggerPayment: (params: CallParams<SubscriptionsArgs["obj"]["triggerPayment((address,uint64))void"] | SubscriptionsArgs["tuple"]["triggerPayment((address,uint64))void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["triggerPayment((address,uint64))void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `streakCheck((address,uint64))void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        streakCheck: (params: CallParams<SubscriptionsArgs["obj"]["streakCheck((address,uint64))void"] | SubscriptionsArgs["tuple"]["streakCheck((address,uint64))void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["streakCheck((address,uint64))void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `setPasses(uint64,address[])void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        setPasses: (params: CallParams<SubscriptionsArgs["obj"]["setPasses(uint64,address[])void"] | SubscriptionsArgs["tuple"]["setPasses(uint64,address[])void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["setPasses(uint64,address[])void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `triggerList((address,uint64[])[])bool[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        triggerList: (params: CallParams<SubscriptionsArgs["obj"]["triggerList((address,uint64[])[])bool[]"] | SubscriptionsArgs["tuple"]["triggerList((address,uint64[])[])bool[]"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["triggerList((address,uint64[])[])bool[]"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `isBlocked(address,address)bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * isBlocked checks if an address is blocked for a merchant
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        isBlocked: (params: CallParams<SubscriptionsArgs["obj"]["isBlocked(address,address)bool"] | SubscriptionsArgs["tuple"]["isBlocked(address,address)bool"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["isBlocked(address,address)bool"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `isShutdown(address,uint64)bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * serviceIsActive checks if an service is shutdown
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        isShutdown: (params: CallParams<SubscriptionsArgs["obj"]["isShutdown(address,uint64)bool"] | SubscriptionsArgs["tuple"]["isShutdown(address,uint64)bool"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["isShutdown(address,uint64)bool"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `newServiceCost(uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        newServiceCost: (params: CallParams<SubscriptionsArgs["obj"]["newServiceCost(uint64)uint64"] | SubscriptionsArgs["tuple"]["newServiceCost(uint64)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["newServiceCost(uint64)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `newSubscriptionCost(address,uint64,uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        newSubscriptionCost: (params: CallParams<SubscriptionsArgs["obj"]["newSubscriptionCost(address,uint64,uint64)uint64"] | SubscriptionsArgs["tuple"]["newSubscriptionCost(address,uint64,uint64)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["newSubscriptionCost(address,uint64,uint64)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `blockCost()uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        blockCost: (params?: CallParams<SubscriptionsArgs["obj"]["blockCost()uint64"] | SubscriptionsArgs["tuple"]["blockCost()uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["blockCost()uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        getService: (params: CallParams<SubscriptionsArgs["obj"]["getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])"] | SubscriptionsArgs["tuple"]["getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        getServicesByAddress: (params: CallParams<SubscriptionsArgs["obj"]["getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]"] | SubscriptionsArgs["tuple"]["getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        getSubscription: (params: CallParams<SubscriptionsArgs["obj"]["getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"] | SubscriptionsArgs["tuple"]["getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        mustGetSubscription: (params: CallParams<SubscriptionsArgs["obj"]["mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"] | SubscriptionsArgs["tuple"]["mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        getSubscriptionWithDetails: (params: CallParams<SubscriptionsArgs["obj"]["getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])"] | SubscriptionsArgs["tuple"]["getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `isFirstSubscription(address)bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        isFirstSubscription: (params: CallParams<SubscriptionsArgs["obj"]["isFirstSubscription(address)bool"] | SubscriptionsArgs["tuple"]["isFirstSubscription(address)bool"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["isFirstSubscription(address)bool"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `getServiceList(address)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        getServiceList: (params: CallParams<SubscriptionsArgs["obj"]["getServiceList(address)uint64"] | SubscriptionsArgs["tuple"]["getServiceList(address)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["getServiceList(address)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `getSubscriptionList(address)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        getSubscriptionList: (params: CallParams<SubscriptionsArgs["obj"]["getSubscriptionList(address)uint64"] | SubscriptionsArgs["tuple"]["getSubscriptionList(address)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["getSubscriptionList(address)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `optIn(pay,uint64)void` ABI method.
         *
         * optin tells the contract to opt into an asa
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        optIn: (params: CallParams<SubscriptionsArgs["obj"]["optIn(pay,uint64)void"] | SubscriptionsArgs["tuple"]["optIn(pay,uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["optIn(pay,uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `optInCost(uint64)uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        optInCost: (params: CallParams<SubscriptionsArgs["obj"]["optInCost(uint64)uint64"] | SubscriptionsArgs["tuple"]["optInCost(uint64)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["optInCost(uint64)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `updateAkitaDAOEscrow(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        updateAkitaDaoEscrow: (params: CallParams<SubscriptionsArgs["obj"]["updateAkitaDAOEscrow(uint64)void"] | SubscriptionsArgs["tuple"]["updateAkitaDAOEscrow(uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["updateAkitaDAOEscrow(uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `updateAkitaDAO(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        updateAkitaDao: (params: CallParams<SubscriptionsArgs["obj"]["updateAkitaDAO(uint64)void"] | SubscriptionsArgs["tuple"]["updateAkitaDAO(uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["updateAkitaDAO(uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Subscriptions smart contract using the `opUp()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        opUp: (params?: CallParams<SubscriptionsArgs["obj"]["opUp()void"] | SubscriptionsArgs["tuple"]["opUp()void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | SubscriptionsReturns["opUp()void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
    };
    /**
     * Clone this app client with different params
     *
     * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
     * @returns A new app client with the altered params
     */
    clone(params: CloneAppClientParams): SubscriptionsClient;
    /**
     * Makes a readonly (simulated) call to the Subscriptions smart contract using the `triggerList((address,uint64[])[])bool[]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    triggerList(params: CallParams<SubscriptionsArgs['obj']['triggerList((address,uint64[])[])bool[]'] | SubscriptionsArgs['tuple']['triggerList((address,uint64[])[])bool[]']>): Promise<boolean[]>;
    /**
     * Makes a readonly (simulated) call to the Subscriptions smart contract using the `isBlocked(address,address)bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * isBlocked checks if an address is blocked for a merchant
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    isBlocked(params: CallParams<SubscriptionsArgs['obj']['isBlocked(address,address)bool'] | SubscriptionsArgs['tuple']['isBlocked(address,address)bool']>): Promise<boolean>;
    /**
     * Makes a readonly (simulated) call to the Subscriptions smart contract using the `isShutdown(address,uint64)bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * serviceIsActive checks if an service is shutdown
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    isShutdown(params: CallParams<SubscriptionsArgs['obj']['isShutdown(address,uint64)bool'] | SubscriptionsArgs['tuple']['isShutdown(address,uint64)bool']>): Promise<boolean>;
    /**
     * Makes a readonly (simulated) call to the Subscriptions smart contract using the `newServiceCost(uint64)uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    newServiceCost(params: CallParams<SubscriptionsArgs['obj']['newServiceCost(uint64)uint64'] | SubscriptionsArgs['tuple']['newServiceCost(uint64)uint64']>): Promise<bigint>;
    /**
     * Makes a readonly (simulated) call to the Subscriptions smart contract using the `newSubscriptionCost(address,uint64,uint64)uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    newSubscriptionCost(params: CallParams<SubscriptionsArgs['obj']['newSubscriptionCost(address,uint64,uint64)uint64'] | SubscriptionsArgs['tuple']['newSubscriptionCost(address,uint64,uint64)uint64']>): Promise<bigint>;
    /**
     * Makes a readonly (simulated) call to the Subscriptions smart contract using the `blockCost()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    blockCost(params?: CallParams<SubscriptionsArgs['obj']['blockCost()uint64'] | SubscriptionsArgs['tuple']['blockCost()uint64']>): Promise<bigint>;
    /**
     * Makes a readonly (simulated) call to the Subscriptions smart contract using the `getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getService(params: CallParams<SubscriptionsArgs['obj']['getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])'] | SubscriptionsArgs['tuple']['getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])']>): Promise<Service>;
    /**
     * Makes a readonly (simulated) call to the Subscriptions smart contract using the `getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getServicesByAddress(params: CallParams<SubscriptionsArgs['obj']['getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]'] | SubscriptionsArgs['tuple']['getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]']>): Promise<[number, bigint, bigint, bigint, bigint, bigint, string, string, Uint8Array<ArrayBufferLike>, number, Uint8Array<ArrayBufferLike>][]>;
    /**
     * Makes a readonly (simulated) call to the Subscriptions smart contract using the `getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getSubscription(params: CallParams<SubscriptionsArgs['obj']['getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | SubscriptionsArgs['tuple']['getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']>): Promise<SubscriptionInfoWithExistence>;
    /**
     * Makes a readonly (simulated) call to the Subscriptions smart contract using the `mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mustGetSubscription(params: CallParams<SubscriptionsArgs['obj']['mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | SubscriptionsArgs['tuple']['mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']>): Promise<SubscriptionInfo>;
    /**
     * Makes a readonly (simulated) call to the Subscriptions smart contract using the `getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getSubscriptionWithDetails(params: CallParams<SubscriptionsArgs['obj']['getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])'] | SubscriptionsArgs['tuple']['getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])']>): Promise<SubscriptionInfoWithDetails>;
    /**
     * Makes a readonly (simulated) call to the Subscriptions smart contract using the `isFirstSubscription(address)bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    isFirstSubscription(params: CallParams<SubscriptionsArgs['obj']['isFirstSubscription(address)bool'] | SubscriptionsArgs['tuple']['isFirstSubscription(address)bool']>): Promise<boolean>;
    /**
     * Makes a readonly (simulated) call to the Subscriptions smart contract using the `getServiceList(address)uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getServiceList(params: CallParams<SubscriptionsArgs['obj']['getServiceList(address)uint64'] | SubscriptionsArgs['tuple']['getServiceList(address)uint64']>): Promise<bigint>;
    /**
     * Makes a readonly (simulated) call to the Subscriptions smart contract using the `getSubscriptionList(address)uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getSubscriptionList(params: CallParams<SubscriptionsArgs['obj']['getSubscriptionList(address)uint64'] | SubscriptionsArgs['tuple']['getSubscriptionList(address)uint64']>): Promise<bigint>;
    /**
     * Makes a readonly (simulated) call to the Subscriptions smart contract using the `optInCost(uint64)uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    optInCost(params: CallParams<SubscriptionsArgs['obj']['optInCost(uint64)uint64'] | SubscriptionsArgs['tuple']['optInCost(uint64)uint64']>): Promise<bigint>;
    /**
     * Methods to access state for the current Subscriptions app
     */
    state: {
        /**
         * Methods to access global state for the current Subscriptions app
         */
        global: {
            /**
             * Get all current keyed values from global state
             */
            getAll: () => Promise<Partial<Expand<GlobalKeysState>>>;
            /**
             * Get the current value of the akitaDAOEscrow key in global state
             */
            akitaDaoEscrow: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the version key in global state
             */
            version: () => Promise<string | undefined>;
            /**
             * Get the current value of the akitaDAO key in global state
             */
            akitaDao: () => Promise<bigint | undefined>;
        };
        /**
         * Methods to access box state for the current Subscriptions app
         */
        box: {
            /**
             * Get all current keyed values from box state
             */
            getAll: () => Promise<Partial<Expand<BoxKeysState>>>;
            /**
             * Get values from the subscriptions map in box state
             */
            subscriptions: {
                /**
                 * Get all current values of the subscriptions map in box state
                 */
                getMap: () => Promise<Map<SubscriptionKey, SubscriptionInfo>>;
                /**
                 * Get a current value of the subscriptions map by key from box state
                 */
                value: (key: SubscriptionKey) => Promise<SubscriptionInfo | undefined>;
            };
            /**
             * Get values from the subscriptionslist map in box state
             */
            subscriptionslist: {
                /**
                 * Get all current values of the subscriptionslist map in box state
                 */
                getMap: () => Promise<Map<string, bigint>>;
                /**
                 * Get a current value of the subscriptionslist map by key from box state
                 */
                value: (key: string) => Promise<bigint | undefined>;
            };
            /**
             * Get values from the services map in box state
             */
            services: {
                /**
                 * Get all current values of the services map in box state
                 */
                getMap: () => Promise<Map<ServicesKey, Service>>;
                /**
                 * Get a current value of the services map by key from box state
                 */
                value: (key: ServicesKey) => Promise<Service | undefined>;
            };
            /**
             * Get values from the serviceslist map in box state
             */
            serviceslist: {
                /**
                 * Get all current values of the serviceslist map in box state
                 */
                getMap: () => Promise<Map<string, bigint>>;
                /**
                 * Get a current value of the serviceslist map by key from box state
                 */
                value: (key: string) => Promise<bigint | undefined>;
            };
            /**
             * Get values from the blocks map in box state
             */
            blocks: {
                /**
                 * Get all current values of the blocks map in box state
                 */
                getMap: () => Promise<Map<BlockListKey, Uint8Array>>;
                /**
                 * Get a current value of the blocks map by key from box state
                 */
                value: (key: BlockListKey) => Promise<Uint8Array | undefined>;
            };
            /**
             * Get values from the passes map in box state
             */
            passes: {
                /**
                 * Get all current values of the passes map in box state
                 */
                getMap: () => Promise<Map<SubscriptionKey, string[]>>;
                /**
                 * Get a current value of the passes map by key from box state
                 */
                value: (key: SubscriptionKey) => Promise<string[] | undefined>;
            };
        };
    };
    newGroup(): SubscriptionsComposer;
}
export type SubscriptionsComposer<TReturns extends [...any[]] = []> = {
    /**
     * Calls the newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64 ABI method.
     *
     * newService creates a new service for a merchant
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    newService(params?: CallParams<SubscriptionsArgs['obj']['newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64'] | SubscriptionsArgs['tuple']['newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['newService(pay,uint64,uint64,uint64,uint64,uint64,string,byte[36],uint8,byte[3])uint64'] | undefined]>;
    /**
     * Calls the setServiceDescription(uint64,byte[])void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    setServiceDescription(params?: CallParams<SubscriptionsArgs['obj']['setServiceDescription(uint64,byte[])void'] | SubscriptionsArgs['tuple']['setServiceDescription(uint64,byte[])void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['setServiceDescription(uint64,byte[])void'] | undefined]>;
    /**
     * Calls the activateService()void ABI method.
     *
     * activateService activates an service for a merchant
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    activateService(params?: CallParams<SubscriptionsArgs['obj']['activateService()void'] | SubscriptionsArgs['tuple']['activateService()void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['activateService()void'] | undefined]>;
    /**
     * Calls the pauseService(uint64)void ABI method.
     *
    * pauseService pauses a service for a merchant
    it does not shutdown pre-existing subscriptions
    it simply prevents new subscriptions from being created
    for a specific service
  
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    pauseService(params?: CallParams<SubscriptionsArgs['obj']['pauseService(uint64)void'] | SubscriptionsArgs['tuple']['pauseService(uint64)void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['pauseService(uint64)void'] | undefined]>;
    /**
     * Calls the unpauseService(uint64)void ABI method.
     *
     * unpauseService activates an service for a merchant
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    unpauseService(params?: CallParams<SubscriptionsArgs['obj']['unpauseService(uint64)void'] | SubscriptionsArgs['tuple']['unpauseService(uint64)void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['unpauseService(uint64)void'] | undefined]>;
    /**
     * Calls the shutdownService(uint64)void ABI method.
     *
    * shutdownService permanently shuts down an service for a merchant
    it also shutsdown pre-existing subscriptions
  
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    shutdownService(params?: CallParams<SubscriptionsArgs['obj']['shutdownService(uint64)void'] | SubscriptionsArgs['tuple']['shutdownService(uint64)void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['shutdownService(uint64)void'] | undefined]>;
    /**
     * Calls the block(pay,address)void ABI method.
     *
     * block blacklists an address for a merchant
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    block(params?: CallParams<SubscriptionsArgs['obj']['block(pay,address)void'] | SubscriptionsArgs['tuple']['block(pay,address)void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['block(pay,address)void'] | undefined]>;
    /**
     * Calls the unblock(address)void ABI method.
     *
     * unblock removes an address from a merchants blocks
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    unblock(params?: CallParams<SubscriptionsArgs['obj']['unblock(address)void'] | SubscriptionsArgs['tuple']['unblock(address)void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['unblock(address)void'] | undefined]>;
    /**
     * Calls the gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    gatedSubscribe(params?: CallParams<SubscriptionsArgs['obj']['gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64'] | SubscriptionsArgs['tuple']['gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['gatedSubscribe(pay,appl,address,uint64,uint64,uint64)uint64'] | undefined]>;
    /**
     * Calls the subscribe(pay,address,uint64,uint64,uint64)uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    subscribe(params?: CallParams<SubscriptionsArgs['obj']['subscribe(pay,address,uint64,uint64,uint64)uint64'] | SubscriptionsArgs['tuple']['subscribe(pay,address,uint64,uint64,uint64)uint64']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['subscribe(pay,address,uint64,uint64,uint64)uint64'] | undefined]>;
    /**
     * Calls the gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    gatedSubscribeAsa(params?: CallParams<SubscriptionsArgs['obj']['gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64'] | SubscriptionsArgs['tuple']['gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['gatedSubscribeAsa(pay,axfer,appl,address,uint64,uint64,uint64)uint64'] | undefined]>;
    /**
     * Calls the subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    subscribeAsa(params?: CallParams<SubscriptionsArgs['obj']['subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64'] | SubscriptionsArgs['tuple']['subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['subscribeAsa(pay,axfer,address,uint64,uint64,uint64)uint64'] | undefined]>;
    /**
     * Calls the deposit(pay,uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    deposit(params?: CallParams<SubscriptionsArgs['obj']['deposit(pay,uint64)void'] | SubscriptionsArgs['tuple']['deposit(pay,uint64)void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['deposit(pay,uint64)void'] | undefined]>;
    /**
     * Calls the depositAsa(axfer,uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    depositAsa(params?: CallParams<SubscriptionsArgs['obj']['depositAsa(axfer,uint64)void'] | SubscriptionsArgs['tuple']['depositAsa(axfer,uint64)void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['depositAsa(axfer,uint64)void'] | undefined]>;
    /**
     * Calls the withdraw(uint64,uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    withdraw(params?: CallParams<SubscriptionsArgs['obj']['withdraw(uint64,uint64)void'] | SubscriptionsArgs['tuple']['withdraw(uint64,uint64)void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['withdraw(uint64,uint64)void'] | undefined]>;
    /**
     * Calls the unsubscribe(uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    unsubscribe(params?: CallParams<SubscriptionsArgs['obj']['unsubscribe(uint64)void'] | SubscriptionsArgs['tuple']['unsubscribe(uint64)void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['unsubscribe(uint64)void'] | undefined]>;
    /**
     * Calls the gatedTriggerPayment(appl,(address,uint64))void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    gatedTriggerPayment(params?: CallParams<SubscriptionsArgs['obj']['gatedTriggerPayment(appl,(address,uint64))void'] | SubscriptionsArgs['tuple']['gatedTriggerPayment(appl,(address,uint64))void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['gatedTriggerPayment(appl,(address,uint64))void'] | undefined]>;
    /**
     * Calls the triggerPayment((address,uint64))void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    triggerPayment(params?: CallParams<SubscriptionsArgs['obj']['triggerPayment((address,uint64))void'] | SubscriptionsArgs['tuple']['triggerPayment((address,uint64))void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['triggerPayment((address,uint64))void'] | undefined]>;
    /**
     * Calls the streakCheck((address,uint64))void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    streakCheck(params?: CallParams<SubscriptionsArgs['obj']['streakCheck((address,uint64))void'] | SubscriptionsArgs['tuple']['streakCheck((address,uint64))void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['streakCheck((address,uint64))void'] | undefined]>;
    /**
     * Calls the setPasses(uint64,address[])void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    setPasses(params?: CallParams<SubscriptionsArgs['obj']['setPasses(uint64,address[])void'] | SubscriptionsArgs['tuple']['setPasses(uint64,address[])void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['setPasses(uint64,address[])void'] | undefined]>;
    /**
     * Calls the triggerList((address,uint64[])[])bool[] ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    triggerList(params?: CallParams<SubscriptionsArgs['obj']['triggerList((address,uint64[])[])bool[]'] | SubscriptionsArgs['tuple']['triggerList((address,uint64[])[])bool[]']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['triggerList((address,uint64[])[])bool[]'] | undefined]>;
    /**
     * Calls the isBlocked(address,address)bool ABI method.
     *
     * isBlocked checks if an address is blocked for a merchant
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    isBlocked(params?: CallParams<SubscriptionsArgs['obj']['isBlocked(address,address)bool'] | SubscriptionsArgs['tuple']['isBlocked(address,address)bool']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['isBlocked(address,address)bool'] | undefined]>;
    /**
     * Calls the isShutdown(address,uint64)bool ABI method.
     *
     * serviceIsActive checks if an service is shutdown
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    isShutdown(params?: CallParams<SubscriptionsArgs['obj']['isShutdown(address,uint64)bool'] | SubscriptionsArgs['tuple']['isShutdown(address,uint64)bool']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['isShutdown(address,uint64)bool'] | undefined]>;
    /**
     * Calls the newServiceCost(uint64)uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    newServiceCost(params?: CallParams<SubscriptionsArgs['obj']['newServiceCost(uint64)uint64'] | SubscriptionsArgs['tuple']['newServiceCost(uint64)uint64']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['newServiceCost(uint64)uint64'] | undefined]>;
    /**
     * Calls the newSubscriptionCost(address,uint64,uint64)uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    newSubscriptionCost(params?: CallParams<SubscriptionsArgs['obj']['newSubscriptionCost(address,uint64,uint64)uint64'] | SubscriptionsArgs['tuple']['newSubscriptionCost(address,uint64,uint64)uint64']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['newSubscriptionCost(address,uint64,uint64)uint64'] | undefined]>;
    /**
     * Calls the blockCost()uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    blockCost(params?: CallParams<SubscriptionsArgs['obj']['blockCost()uint64'] | SubscriptionsArgs['tuple']['blockCost()uint64']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['blockCost()uint64'] | undefined]>;
    /**
     * Calls the getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3]) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    getService(params?: CallParams<SubscriptionsArgs['obj']['getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])'] | SubscriptionsArgs['tuple']['getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['getService(address,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])'] | undefined]>;
    /**
     * Calls the getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[] ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    getServicesByAddress(params?: CallParams<SubscriptionsArgs['obj']['getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]'] | SubscriptionsArgs['tuple']['getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['getServicesByAddress(address,uint64,uint64)(uint8,uint64,uint64,uint64,uint64,uint64,string,string,byte[36],uint8,byte[3])[]'] | undefined]>;
    /**
     * Calls the getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    getSubscription(params?: CallParams<SubscriptionsArgs['obj']['getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | SubscriptionsArgs['tuple']['getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['getSubscription((address,uint64))(bool,address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | undefined]>;
    /**
     * Calls the mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    mustGetSubscription(params?: CallParams<SubscriptionsArgs['obj']['mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | SubscriptionsArgs['tuple']['mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['mustGetSubscription((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | undefined]>;
    /**
     * Calls the getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[]) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    getSubscriptionWithDetails(params?: CallParams<SubscriptionsArgs['obj']['getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])'] | SubscriptionsArgs['tuple']['getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['getSubscriptionWithDetails((address,uint64))(address,uint64,uint64,uint64,uint64,uint64,uint64,uint8,string,string,byte[36],uint8,byte[3],uint64,uint64,uint64,address[])'] | undefined]>;
    /**
     * Calls the isFirstSubscription(address)bool ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    isFirstSubscription(params?: CallParams<SubscriptionsArgs['obj']['isFirstSubscription(address)bool'] | SubscriptionsArgs['tuple']['isFirstSubscription(address)bool']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['isFirstSubscription(address)bool'] | undefined]>;
    /**
     * Calls the getServiceList(address)uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    getServiceList(params?: CallParams<SubscriptionsArgs['obj']['getServiceList(address)uint64'] | SubscriptionsArgs['tuple']['getServiceList(address)uint64']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['getServiceList(address)uint64'] | undefined]>;
    /**
     * Calls the getSubscriptionList(address)uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    getSubscriptionList(params?: CallParams<SubscriptionsArgs['obj']['getSubscriptionList(address)uint64'] | SubscriptionsArgs['tuple']['getSubscriptionList(address)uint64']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['getSubscriptionList(address)uint64'] | undefined]>;
    /**
     * Calls the optIn(pay,uint64)void ABI method.
     *
     * optin tells the contract to opt into an asa
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    optIn(params?: CallParams<SubscriptionsArgs['obj']['optIn(pay,uint64)void'] | SubscriptionsArgs['tuple']['optIn(pay,uint64)void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['optIn(pay,uint64)void'] | undefined]>;
    /**
     * Calls the optInCost(uint64)uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    optInCost(params?: CallParams<SubscriptionsArgs['obj']['optInCost(uint64)uint64'] | SubscriptionsArgs['tuple']['optInCost(uint64)uint64']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['optInCost(uint64)uint64'] | undefined]>;
    /**
     * Calls the updateAkitaDAOEscrow(uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    updateAkitaDaoEscrow(params?: CallParams<SubscriptionsArgs['obj']['updateAkitaDAOEscrow(uint64)void'] | SubscriptionsArgs['tuple']['updateAkitaDAOEscrow(uint64)void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['updateAkitaDAOEscrow(uint64)void'] | undefined]>;
    /**
     * Calls the updateAkitaDAO(uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    updateAkitaDao(params?: CallParams<SubscriptionsArgs['obj']['updateAkitaDAO(uint64)void'] | SubscriptionsArgs['tuple']['updateAkitaDAO(uint64)void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['updateAkitaDAO(uint64)void'] | undefined]>;
    /**
     * Calls the opUp()void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    opUp(params?: CallParams<SubscriptionsArgs['obj']['opUp()void'] | SubscriptionsArgs['tuple']['opUp()void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['opUp()void'] | undefined]>;
    /**
     * Gets available update methods
     */
    readonly update: {
        /**
         * Updates an existing instance of the Subscriptions smart contract using the update(string)void ABI method.
         *
         * @param args The arguments for the smart contract call
         * @param params Any additional parameters for the call
         * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
         */
        update(params?: CallParams<SubscriptionsArgs['obj']['update(string)void'] | SubscriptionsArgs['tuple']['update(string)void']>): SubscriptionsComposer<[...TReturns, SubscriptionsReturns['update(string)void'] | undefined]>;
    };
    /**
     * Makes a clear_state call to an existing instance of the Subscriptions smart contract.
     *
     * @param args The arguments for the bare call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    clearState(params?: AppClientBareCallParams): SubscriptionsComposer<[...TReturns, undefined]>;
    /**
     * Adds a transaction to the composer
     *
     * @param txn A transaction to add to the transaction group
     * @param signer The optional signer to use when signing this transaction.
     */
    addTransaction(txn: Transaction, signer?: TransactionSigner): SubscriptionsComposer<TReturns>;
    /**
     * Returns the underlying AtomicTransactionComposer instance
     */
    composer(): Promise<TransactionComposer>;
    /**
     * Simulates the transaction group and returns the result
     */
    simulate(): Promise<SubscriptionsComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    simulate(options: SkipSignaturesSimulateOptions): Promise<SubscriptionsComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    simulate(options: RawSimulateOptions): Promise<SubscriptionsComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    /**
     * Sends the transaction group to the network and returns the results
     */
    send(params?: SendParams): Promise<SubscriptionsComposerResults<TReturns>>;
};
export type SubscriptionsComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
    returns: TReturns;
}>;
