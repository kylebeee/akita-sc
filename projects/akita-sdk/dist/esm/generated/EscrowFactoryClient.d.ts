/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client';
import { ABIReturn } from '@algorandfoundation/algokit-utils/types/app';
import { Arc56Contract } from '@algorandfoundation/algokit-utils/types/app-arc56';
import { AppClient as _AppClient, AppClientMethodCallParams, AppClientParams, AppClientBareCallParams, CallOnComplete, AppClientCompilationParams, ResolveAppClientByCreatorAndName, ResolveAppClientByNetwork, CloneAppClientParams } from '@algorandfoundation/algokit-utils/types/app-client';
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory';
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer';
import { SendParams, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction';
import { Address, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk';
export declare const APP_SPEC: Arc56Contract;
/**
 * A state record containing binary data
 */
export interface BinaryState {
    /**
     * Gets the state value as a Uint8Array
     */
    asByteArray(): Uint8Array | undefined;
    /**
     * Gets the state value as a string
     */
    asString(): string | undefined;
}
/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R ? (...args: Expand<A>) => Expand<R> : T extends infer O ? {
    [K in keyof O]: O[K];
} : never;
/**
 * The argument types for the EscrowFactory contract
 */
export type EscrowFactoryArgs = {
    /**
     * The object representation of the arguments for each method
     */
    obj: {
        'new(pay)uint64': {
            payment: AppMethodCallTransactionArgument;
        };
        'register(pay,uint64)void': {
            payment: AppMethodCallTransactionArgument;
            app: bigint | number;
        };
        'delete(uint64)void': {
            id: bigint | number;
        };
        'cost()uint64': Record<string, never>;
        'registerCost()uint64': Record<string, never>;
        'exists(address)bool': {
            address: string;
        };
        'get(address)byte[]': {
            address: string;
        };
        'mustGet(address)byte[]': {
            address: string;
        };
        'getList(address[])byte[][]': {
            addresses: string[];
        };
        'mustGetList(address[])byte[][]': {
            addresses: string[];
        };
    };
    /**
     * The tuple representation of the arguments for each method
     */
    tuple: {
        'new(pay)uint64': [payment: AppMethodCallTransactionArgument];
        'register(pay,uint64)void': [payment: AppMethodCallTransactionArgument, app: bigint | number];
        'delete(uint64)void': [id: bigint | number];
        'cost()uint64': [];
        'registerCost()uint64': [];
        'exists(address)bool': [address: string];
        'get(address)byte[]': [address: string];
        'mustGet(address)byte[]': [address: string];
        'getList(address[])byte[][]': [addresses: string[]];
        'mustGetList(address[])byte[][]': [addresses: string[]];
    };
};
/**
 * The return type for each method
 */
export type EscrowFactoryReturns = {
    'new(pay)uint64': bigint;
    'register(pay,uint64)void': void;
    'delete(uint64)void': void;
    'cost()uint64': bigint;
    'registerCost()uint64': bigint;
    'exists(address)bool': boolean;
    'get(address)byte[]': Uint8Array;
    'mustGet(address)byte[]': Uint8Array;
    'getList(address[])byte[][]': Uint8Array[];
    'mustGetList(address[])byte[][]': Uint8Array[];
};
/**
 * Defines the types of available calls and state of the EscrowFactory smart contract.
 */
export type EscrowFactoryTypes = {
    /**
     * Maps method signatures / names to their argument and return types.
     */
    methods: Record<'new(pay)uint64' | 'new', {
        argsObj: EscrowFactoryArgs['obj']['new(pay)uint64'];
        argsTuple: EscrowFactoryArgs['tuple']['new(pay)uint64'];
        returns: EscrowFactoryReturns['new(pay)uint64'];
    }> & Record<'register(pay,uint64)void' | 'register', {
        argsObj: EscrowFactoryArgs['obj']['register(pay,uint64)void'];
        argsTuple: EscrowFactoryArgs['tuple']['register(pay,uint64)void'];
        returns: EscrowFactoryReturns['register(pay,uint64)void'];
    }> & Record<'delete(uint64)void' | 'delete', {
        argsObj: EscrowFactoryArgs['obj']['delete(uint64)void'];
        argsTuple: EscrowFactoryArgs['tuple']['delete(uint64)void'];
        returns: EscrowFactoryReturns['delete(uint64)void'];
    }> & Record<'cost()uint64' | 'cost', {
        argsObj: EscrowFactoryArgs['obj']['cost()uint64'];
        argsTuple: EscrowFactoryArgs['tuple']['cost()uint64'];
        returns: EscrowFactoryReturns['cost()uint64'];
    }> & Record<'registerCost()uint64' | 'registerCost', {
        argsObj: EscrowFactoryArgs['obj']['registerCost()uint64'];
        argsTuple: EscrowFactoryArgs['tuple']['registerCost()uint64'];
        returns: EscrowFactoryReturns['registerCost()uint64'];
    }> & Record<'exists(address)bool' | 'exists', {
        argsObj: EscrowFactoryArgs['obj']['exists(address)bool'];
        argsTuple: EscrowFactoryArgs['tuple']['exists(address)bool'];
        returns: EscrowFactoryReturns['exists(address)bool'];
    }> & Record<'get(address)byte[]' | 'get', {
        argsObj: EscrowFactoryArgs['obj']['get(address)byte[]'];
        argsTuple: EscrowFactoryArgs['tuple']['get(address)byte[]'];
        returns: EscrowFactoryReturns['get(address)byte[]'];
    }> & Record<'mustGet(address)byte[]' | 'mustGet', {
        argsObj: EscrowFactoryArgs['obj']['mustGet(address)byte[]'];
        argsTuple: EscrowFactoryArgs['tuple']['mustGet(address)byte[]'];
        returns: EscrowFactoryReturns['mustGet(address)byte[]'];
    }> & Record<'getList(address[])byte[][]' | 'getList', {
        argsObj: EscrowFactoryArgs['obj']['getList(address[])byte[][]'];
        argsTuple: EscrowFactoryArgs['tuple']['getList(address[])byte[][]'];
        returns: EscrowFactoryReturns['getList(address[])byte[][]'];
    }> & Record<'mustGetList(address[])byte[][]' | 'mustGetList', {
        argsObj: EscrowFactoryArgs['obj']['mustGetList(address[])byte[][]'];
        argsTuple: EscrowFactoryArgs['tuple']['mustGetList(address[])byte[][]'];
        returns: EscrowFactoryReturns['mustGetList(address[])byte[][]'];
    }>;
    /**
     * Defines the shape of the state of the application.
     */
    state: {
        box: {
            keys: {};
            maps: {
                walletIDsByAccounts: Map<Uint8Array | string, Uint8Array>;
            };
        };
    };
};
/**
 * Defines the possible abi call signatures.
 */
export type EscrowFactorySignatures = keyof EscrowFactoryTypes['methods'];
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type EscrowFactoryNonVoidMethodSignatures = keyof EscrowFactoryTypes['methods'] extends infer T ? T extends keyof EscrowFactoryTypes['methods'] ? MethodReturn<T> extends void ? never : T : never : never;
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> & {
    /** The args for the ABI method call, either as an ordered array or an object */
    args: Expand<TArgs>;
}>;
/**
 * Maps a method signature from the EscrowFactory smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends EscrowFactorySignatures> = EscrowFactoryTypes['methods'][TSignature]['argsObj' | 'argsTuple'];
/**
 * Maps a method signature from the EscrowFactory smart contract to the method's return type
 */
export type MethodReturn<TSignature extends EscrowFactorySignatures> = EscrowFactoryTypes['methods'][TSignature]['returns'];
/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = EscrowFactoryTypes['state']['box']['keys'];
/**
 * Defines supported create method params for this smart contract
 */
export type EscrowFactoryCreateCallParams = Expand<AppClientBareCallParams & {
    method?: never;
} & {
    onComplete?: OnApplicationComplete.NoOpOC;
} & CreateSchema>;
/**
 * Defines arguments required for the deploy method.
 */
export type EscrowFactoryDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
    /**
     * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
     */
    createParams?: EscrowFactoryCreateCallParams;
}>;
/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the EscrowFactory smart contract
 */
export declare abstract class EscrowFactoryParamsFactory {
    /**
     * Constructs a no op call for the new(pay)uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static new(params: CallParams<EscrowFactoryArgs['obj']['new(pay)uint64'] | EscrowFactoryArgs['tuple']['new(pay)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the register(pay,uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static register(params: CallParams<EscrowFactoryArgs['obj']['register(pay,uint64)void'] | EscrowFactoryArgs['tuple']['register(pay,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the delete(uint64)void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static delete(params: CallParams<EscrowFactoryArgs['obj']['delete(uint64)void'] | EscrowFactoryArgs['tuple']['delete(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the cost()uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static cost(params: CallParams<EscrowFactoryArgs['obj']['cost()uint64'] | EscrowFactoryArgs['tuple']['cost()uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the registerCost()uint64 ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static registerCost(params: CallParams<EscrowFactoryArgs['obj']['registerCost()uint64'] | EscrowFactoryArgs['tuple']['registerCost()uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the exists(address)bool ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static exists(params: CallParams<EscrowFactoryArgs['obj']['exists(address)bool'] | EscrowFactoryArgs['tuple']['exists(address)bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the get(address)byte[] ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static get(params: CallParams<EscrowFactoryArgs['obj']['get(address)byte[]'] | EscrowFactoryArgs['tuple']['get(address)byte[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the mustGet(address)byte[] ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static mustGet(params: CallParams<EscrowFactoryArgs['obj']['mustGet(address)byte[]'] | EscrowFactoryArgs['tuple']['mustGet(address)byte[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the getList(address[])byte[][] ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static getList(params: CallParams<EscrowFactoryArgs['obj']['getList(address[])byte[][]'] | EscrowFactoryArgs['tuple']['getList(address[])byte[][]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the mustGetList(address[])byte[][] ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static mustGetList(params: CallParams<EscrowFactoryArgs['obj']['mustGetList(address[])byte[][]'] | EscrowFactoryArgs['tuple']['mustGetList(address[])byte[][]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
}
/**
 * A factory to create and deploy one or more instance of the EscrowFactory smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export declare class EscrowFactoryFactory {
    /**
     * The underlying `AppFactory` for when you want to have more flexibility
     */
    readonly appFactory: _AppFactory;
    /**
     * Creates a new instance of `EscrowFactoryFactory`
     *
     * @param params The parameters to initialise the app factory with
     */
    constructor(params: Omit<AppFactoryParams, 'appSpec'>);
    /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
    get appName(): string;
    /** The ARC-56 app spec being used */
    get appSpec(): Arc56Contract;
    /** A reference to the underlying `AlgorandClient` this app factory is using. */
    get algorand(): AlgorandClient;
    /**
     * Returns a new `AppClient` client for an app instance of the given ID.
     *
     * Automatically populates appName, defaultSender and source maps from the factory
     * if not specified in the params.
     * @param params The parameters to create the app client
     * @returns The `AppClient`
     */
    getAppClientById(params: AppFactoryAppClientParams): EscrowFactoryClient;
    /**
     * Returns a new `AppClient` client, resolving the app by creator address and name
     * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
     *
     * Automatically populates appName, defaultSender and source maps from the factory
     * if not specified in the params.
     * @param params The parameters to create the app client
     * @returns The `AppClient`
     */
    getAppClientByCreatorAndName(params: AppFactoryResolveAppClientByCreatorAndNameParams): Promise<EscrowFactoryClient>;
    /**
     * Idempotently deploys the EscrowFactory smart contract.
     *
     * @param params The arguments for the contract calls and any additional parameters for the call
     * @returns The deployment result
     */
    deploy(params?: EscrowFactoryDeployParams): Promise<{
        result: {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "create";
            version: string;
            name: string;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            appId: bigint;
            appAddress: Address;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "update";
            appId: bigint;
            appAddress: Address;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            name: string;
            version: string;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "replace";
            version: string;
            name: string;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            appId: bigint;
            appAddress: Address;
            deleteResult: import("@algorandfoundation/algokit-utils/types/transaction").ConfirmedTransactionResult;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "nothing";
            appId: bigint;
            appAddress: Address;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            name: string;
            version: string;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
        };
        appClient: EscrowFactoryClient;
    }>;
    /**
     * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
     */
    readonly params: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the EscrowFactory smart contract using a bare call.
             *
             * @param params The params for the bare (raw) call
             * @returns The params for a create call
             */
            bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }>) => Promise<{
                approvalProgram: Uint8Array;
                clearStateProgram: Uint8Array;
                compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                deployTimeParams: import("@algorandfoundation/algokit-utils/types/app").TealTemplateParams | undefined;
                schema: {
                    globalInts: number;
                    globalByteSlices: number;
                    localInts: number;
                    localByteSlices: number;
                };
                maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                note?: string | Uint8Array | undefined;
                args?: Uint8Array[] | undefined;
                signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                lease?: string | Uint8Array | undefined;
                rekeyTo?: string | Address | undefined;
                staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                validityWindow?: number | bigint | undefined;
                firstValidRound?: bigint | undefined;
                lastValidRound?: bigint | undefined;
                accountReferences?: (string | Address)[] | undefined;
                appReferences?: bigint[] | undefined;
                assetReferences?: bigint[] | undefined;
                boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                sender?: string | Address | undefined;
                updatable?: boolean | undefined;
                deletable?: boolean | undefined;
                onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                extraProgramPages?: number | undefined;
            } & {
                sender: Address;
                signer: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                onComplete: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC;
            }>;
        };
    };
    /**
     * Create transactions for the current app
     */
    readonly createTransaction: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the EscrowFactory smart contract using a bare call.
             *
             * @param params The params for the bare (raw) call
             * @returns The transaction for a create call
             */
            bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }>) => Promise<Transaction>;
        };
    };
    /**
     * Send calls to the current app
     */
    readonly send: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the EscrowFactory smart contract using a bare call.
             *
             * @param params The params for the bare (raw) call
             * @returns The create result
             */
            bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & SendParams & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }>) => Promise<{
                result: {
                    compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                    compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                    return: undefined;
                    groupId: string;
                    txIds: string[];
                    returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
                    confirmations: modelsv2.PendingTransactionResponse[];
                    transactions: Transaction[];
                    confirmation: modelsv2.PendingTransactionResponse;
                    transaction: Transaction;
                    appId: bigint;
                    appAddress: Address;
                };
                appClient: EscrowFactoryClient;
            }>;
        };
    };
}
/**
 * A client to make calls to the EscrowFactory smart contract
 */
export declare class EscrowFactoryClient {
    /**
     * The underlying `AppClient` for when you want to have more flexibility
     */
    readonly appClient: _AppClient;
    /**
     * Creates a new instance of `EscrowFactoryClient`
     *
     * @param appClient An `AppClient` instance which has been created with the EscrowFactory app spec
     */
    constructor(appClient: _AppClient);
    /**
     * Creates a new instance of `EscrowFactoryClient`
     *
     * @param params The parameters to initialise the app client with
     */
    constructor(params: Omit<AppClientParams, 'appSpec'>);
    /**
     * Checks for decode errors on the given return value and maps the return value to the return type for the given method
     * @returns The typed return value or undefined if there was no value
     */
    decodeReturnValue<TSignature extends EscrowFactoryNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined): MethodReturn<TSignature> | undefined;
    /**
     * Returns a new `EscrowFactoryClient` client, resolving the app by creator address and name
     * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
     * @param params The parameters to create the app client
     */
    static fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<EscrowFactoryClient>;
    /**
     * Returns an `EscrowFactoryClient` instance for the current network based on
     * pre-determined network-specific app IDs specified in the ARC-56 app spec.
     *
     * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
     * @param params The parameters to create the app client
     */
    static fromNetwork(params: Omit<ResolveAppClientByNetwork, 'appSpec'>): Promise<EscrowFactoryClient>;
    /** The ID of the app instance this client is linked to. */
    get appId(): bigint;
    /** The app address of the app instance this client is linked to. */
    get appAddress(): Address;
    /** The name of the app. */
    get appName(): string;
    /** The ARC-56 app spec being used */
    get appSpec(): Arc56Contract;
    /** A reference to the underlying `AlgorandClient` this app client is using. */
    get algorand(): AlgorandClient;
    /**
     * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
     */
    readonly params: {
        /**
         * Makes a clear_state call to an existing instance of the EscrowFactory smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams>) => import("@algorandfoundation/algokit-utils/types/composer").AppCallParams;
        /**
         * Makes a call to the EscrowFactory smart contract using the `new(pay)uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        new: (params: CallParams<EscrowFactoryArgs["obj"]["new(pay)uint64"] | EscrowFactoryArgs["tuple"]["new(pay)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `register(pay,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        register: (params: CallParams<EscrowFactoryArgs["obj"]["register(pay,uint64)void"] | EscrowFactoryArgs["tuple"]["register(pay,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `delete(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        delete: (params: CallParams<EscrowFactoryArgs["obj"]["delete(uint64)void"] | EscrowFactoryArgs["tuple"]["delete(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `cost()uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        cost: (params?: CallParams<EscrowFactoryArgs["obj"]["cost()uint64"] | EscrowFactoryArgs["tuple"]["cost()uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `registerCost()uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        registerCost: (params?: CallParams<EscrowFactoryArgs["obj"]["registerCost()uint64"] | EscrowFactoryArgs["tuple"]["registerCost()uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `exists(address)bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        exists: (params: CallParams<EscrowFactoryArgs["obj"]["exists(address)bool"] | EscrowFactoryArgs["tuple"]["exists(address)bool"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `get(address)byte[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        get: (params: CallParams<EscrowFactoryArgs["obj"]["get(address)byte[]"] | EscrowFactoryArgs["tuple"]["get(address)byte[]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `mustGet(address)byte[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        mustGet: (params: CallParams<EscrowFactoryArgs["obj"]["mustGet(address)byte[]"] | EscrowFactoryArgs["tuple"]["mustGet(address)byte[]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `getList(address[])byte[][]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        getList: (params: CallParams<EscrowFactoryArgs["obj"]["getList(address[])byte[][]"] | EscrowFactoryArgs["tuple"]["getList(address[])byte[][]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `mustGetList(address[])byte[][]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        mustGetList: (params: CallParams<EscrowFactoryArgs["obj"]["mustGetList(address[])byte[][]"] | EscrowFactoryArgs["tuple"]["mustGetList(address[])byte[][]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
    };
    /**
     * Create transactions for the current app
     */
    readonly createTransaction: {
        /**
         * Makes a clear_state call to an existing instance of the EscrowFactory smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams>) => Promise<Transaction>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `new(pay)uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        new: (params: CallParams<EscrowFactoryArgs["obj"]["new(pay)uint64"] | EscrowFactoryArgs["tuple"]["new(pay)uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `register(pay,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        register: (params: CallParams<EscrowFactoryArgs["obj"]["register(pay,uint64)void"] | EscrowFactoryArgs["tuple"]["register(pay,uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `delete(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        delete: (params: CallParams<EscrowFactoryArgs["obj"]["delete(uint64)void"] | EscrowFactoryArgs["tuple"]["delete(uint64)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `cost()uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        cost: (params?: CallParams<EscrowFactoryArgs["obj"]["cost()uint64"] | EscrowFactoryArgs["tuple"]["cost()uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `registerCost()uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        registerCost: (params?: CallParams<EscrowFactoryArgs["obj"]["registerCost()uint64"] | EscrowFactoryArgs["tuple"]["registerCost()uint64"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `exists(address)bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        exists: (params: CallParams<EscrowFactoryArgs["obj"]["exists(address)bool"] | EscrowFactoryArgs["tuple"]["exists(address)bool"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `get(address)byte[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        get: (params: CallParams<EscrowFactoryArgs["obj"]["get(address)byte[]"] | EscrowFactoryArgs["tuple"]["get(address)byte[]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `mustGet(address)byte[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        mustGet: (params: CallParams<EscrowFactoryArgs["obj"]["mustGet(address)byte[]"] | EscrowFactoryArgs["tuple"]["mustGet(address)byte[]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `getList(address[])byte[][]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        getList: (params: CallParams<EscrowFactoryArgs["obj"]["getList(address[])byte[][]"] | EscrowFactoryArgs["tuple"]["getList(address[])byte[][]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `mustGetList(address[])byte[][]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        mustGetList: (params: CallParams<EscrowFactoryArgs["obj"]["mustGetList(address[])byte[][]"] | EscrowFactoryArgs["tuple"]["mustGetList(address[])byte[][]"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
    };
    /**
     * Send calls to the current app
     */
    readonly send: {
        /**
         * Makes a clear_state call to an existing instance of the EscrowFactory smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => Promise<{
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            return?: ABIReturn | undefined;
        }>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `new(pay)uint64` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        new: (params: CallParams<EscrowFactoryArgs["obj"]["new(pay)uint64"] | EscrowFactoryArgs["tuple"]["new(pay)uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | EscrowFactoryReturns["new(pay)uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `register(pay,uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        register: (params: CallParams<EscrowFactoryArgs["obj"]["register(pay,uint64)void"] | EscrowFactoryArgs["tuple"]["register(pay,uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | EscrowFactoryReturns["register(pay,uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `delete(uint64)void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        delete: (params: CallParams<EscrowFactoryArgs["obj"]["delete(uint64)void"] | EscrowFactoryArgs["tuple"]["delete(uint64)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | EscrowFactoryReturns["delete(uint64)void"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `cost()uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        cost: (params?: CallParams<EscrowFactoryArgs["obj"]["cost()uint64"] | EscrowFactoryArgs["tuple"]["cost()uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | EscrowFactoryReturns["cost()uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `registerCost()uint64` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        registerCost: (params?: CallParams<EscrowFactoryArgs["obj"]["registerCost()uint64"] | EscrowFactoryArgs["tuple"]["registerCost()uint64"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | EscrowFactoryReturns["registerCost()uint64"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `exists(address)bool` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        exists: (params: CallParams<EscrowFactoryArgs["obj"]["exists(address)bool"] | EscrowFactoryArgs["tuple"]["exists(address)bool"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | EscrowFactoryReturns["exists(address)bool"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `get(address)byte[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        get: (params: CallParams<EscrowFactoryArgs["obj"]["get(address)byte[]"] | EscrowFactoryArgs["tuple"]["get(address)byte[]"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | EscrowFactoryReturns["get(address)byte[]"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `mustGet(address)byte[]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        mustGet: (params: CallParams<EscrowFactoryArgs["obj"]["mustGet(address)byte[]"] | EscrowFactoryArgs["tuple"]["mustGet(address)byte[]"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | EscrowFactoryReturns["mustGet(address)byte[]"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `getList(address[])byte[][]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        getList: (params: CallParams<EscrowFactoryArgs["obj"]["getList(address[])byte[][]"] | EscrowFactoryArgs["tuple"]["getList(address[])byte[][]"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | EscrowFactoryReturns["getList(address[])byte[][]"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the EscrowFactory smart contract using the `mustGetList(address[])byte[][]` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        mustGetList: (params: CallParams<EscrowFactoryArgs["obj"]["mustGetList(address[])byte[][]"] | EscrowFactoryArgs["tuple"]["mustGetList(address[])byte[][]"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | EscrowFactoryReturns["mustGetList(address[])byte[][]"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
    };
    /**
     * Clone this app client with different params
     *
     * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
     * @returns A new app client with the altered params
     */
    clone(params: CloneAppClientParams): EscrowFactoryClient;
    /**
     * Makes a readonly (simulated) call to the EscrowFactory smart contract using the `cost()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    cost(params?: CallParams<EscrowFactoryArgs['obj']['cost()uint64'] | EscrowFactoryArgs['tuple']['cost()uint64']>): Promise<bigint>;
    /**
     * Makes a readonly (simulated) call to the EscrowFactory smart contract using the `registerCost()uint64` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    registerCost(params?: CallParams<EscrowFactoryArgs['obj']['registerCost()uint64'] | EscrowFactoryArgs['tuple']['registerCost()uint64']>): Promise<bigint>;
    /**
     * Makes a readonly (simulated) call to the EscrowFactory smart contract using the `exists(address)bool` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    exists(params: CallParams<EscrowFactoryArgs['obj']['exists(address)bool'] | EscrowFactoryArgs['tuple']['exists(address)bool']>): Promise<boolean>;
    /**
     * Makes a readonly (simulated) call to the EscrowFactory smart contract using the `get(address)byte[]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    get(params: CallParams<EscrowFactoryArgs['obj']['get(address)byte[]'] | EscrowFactoryArgs['tuple']['get(address)byte[]']>): Promise<Uint8Array<ArrayBufferLike>>;
    /**
     * Makes a readonly (simulated) call to the EscrowFactory smart contract using the `mustGet(address)byte[]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mustGet(params: CallParams<EscrowFactoryArgs['obj']['mustGet(address)byte[]'] | EscrowFactoryArgs['tuple']['mustGet(address)byte[]']>): Promise<Uint8Array<ArrayBufferLike>>;
    /**
     * Makes a readonly (simulated) call to the EscrowFactory smart contract using the `getList(address[])byte[][]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getList(params: CallParams<EscrowFactoryArgs['obj']['getList(address[])byte[][]'] | EscrowFactoryArgs['tuple']['getList(address[])byte[][]']>): Promise<Uint8Array<ArrayBufferLike>[]>;
    /**
     * Makes a readonly (simulated) call to the EscrowFactory smart contract using the `mustGetList(address[])byte[][]` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    mustGetList(params: CallParams<EscrowFactoryArgs['obj']['mustGetList(address[])byte[][]'] | EscrowFactoryArgs['tuple']['mustGetList(address[])byte[][]']>): Promise<Uint8Array<ArrayBufferLike>[]>;
    /**
     * Methods to access state for the current EscrowFactory app
     */
    state: {
        /**
         * Methods to access box state for the current EscrowFactory app
         */
        box: {
            /**
             * Get all current keyed values from box state
             */
            getAll: () => Promise<Partial<Expand<BoxKeysState>>>;
            /**
             * Get values from the walletIDsByAccounts map in box state
             */
            walletIDsByAccounts: {
                /**
                 * Get all current values of the walletIDsByAccounts map in box state
                 */
                getMap: () => Promise<Map<Uint8Array, Uint8Array>>;
                /**
                 * Get a current value of the walletIDsByAccounts map by key from box state
                 */
                value: (key: Uint8Array | string) => Promise<Uint8Array | undefined>;
            };
        };
    };
    newGroup(): EscrowFactoryComposer;
}
export type EscrowFactoryComposer<TReturns extends [...any[]] = []> = {
    /**
     * Calls the new(pay)uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    new (params?: CallParams<EscrowFactoryArgs['obj']['new(pay)uint64'] | EscrowFactoryArgs['tuple']['new(pay)uint64']>): EscrowFactoryComposer<[...TReturns, EscrowFactoryReturns['new(pay)uint64'] | undefined]>;
    /**
     * Calls the register(pay,uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    register(params?: CallParams<EscrowFactoryArgs['obj']['register(pay,uint64)void'] | EscrowFactoryArgs['tuple']['register(pay,uint64)void']>): EscrowFactoryComposer<[...TReturns, EscrowFactoryReturns['register(pay,uint64)void'] | undefined]>;
    /**
     * Calls the delete(uint64)void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    delete(params?: CallParams<EscrowFactoryArgs['obj']['delete(uint64)void'] | EscrowFactoryArgs['tuple']['delete(uint64)void']>): EscrowFactoryComposer<[...TReturns, EscrowFactoryReturns['delete(uint64)void'] | undefined]>;
    /**
     * Calls the cost()uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    cost(params?: CallParams<EscrowFactoryArgs['obj']['cost()uint64'] | EscrowFactoryArgs['tuple']['cost()uint64']>): EscrowFactoryComposer<[...TReturns, EscrowFactoryReturns['cost()uint64'] | undefined]>;
    /**
     * Calls the registerCost()uint64 ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    registerCost(params?: CallParams<EscrowFactoryArgs['obj']['registerCost()uint64'] | EscrowFactoryArgs['tuple']['registerCost()uint64']>): EscrowFactoryComposer<[...TReturns, EscrowFactoryReturns['registerCost()uint64'] | undefined]>;
    /**
     * Calls the exists(address)bool ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    exists(params?: CallParams<EscrowFactoryArgs['obj']['exists(address)bool'] | EscrowFactoryArgs['tuple']['exists(address)bool']>): EscrowFactoryComposer<[...TReturns, EscrowFactoryReturns['exists(address)bool'] | undefined]>;
    /**
     * Calls the get(address)byte[] ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    get(params?: CallParams<EscrowFactoryArgs['obj']['get(address)byte[]'] | EscrowFactoryArgs['tuple']['get(address)byte[]']>): EscrowFactoryComposer<[...TReturns, EscrowFactoryReturns['get(address)byte[]'] | undefined]>;
    /**
     * Calls the mustGet(address)byte[] ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    mustGet(params?: CallParams<EscrowFactoryArgs['obj']['mustGet(address)byte[]'] | EscrowFactoryArgs['tuple']['mustGet(address)byte[]']>): EscrowFactoryComposer<[...TReturns, EscrowFactoryReturns['mustGet(address)byte[]'] | undefined]>;
    /**
     * Calls the getList(address[])byte[][] ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    getList(params?: CallParams<EscrowFactoryArgs['obj']['getList(address[])byte[][]'] | EscrowFactoryArgs['tuple']['getList(address[])byte[][]']>): EscrowFactoryComposer<[...TReturns, EscrowFactoryReturns['getList(address[])byte[][]'] | undefined]>;
    /**
     * Calls the mustGetList(address[])byte[][] ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    mustGetList(params?: CallParams<EscrowFactoryArgs['obj']['mustGetList(address[])byte[][]'] | EscrowFactoryArgs['tuple']['mustGetList(address[])byte[][]']>): EscrowFactoryComposer<[...TReturns, EscrowFactoryReturns['mustGetList(address[])byte[][]'] | undefined]>;
    /**
     * Makes a clear_state call to an existing instance of the EscrowFactory smart contract.
     *
     * @param args The arguments for the bare call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    clearState(params?: AppClientBareCallParams): EscrowFactoryComposer<[...TReturns, undefined]>;
    /**
     * Adds a transaction to the composer
     *
     * @param txn A transaction to add to the transaction group
     * @param signer The optional signer to use when signing this transaction.
     */
    addTransaction(txn: Transaction, signer?: TransactionSigner): EscrowFactoryComposer<TReturns>;
    /**
     * Returns the underlying AtomicTransactionComposer instance
     */
    composer(): Promise<TransactionComposer>;
    /**
     * Simulates the transaction group and returns the result
     */
    simulate(): Promise<EscrowFactoryComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    simulate(options: SkipSignaturesSimulateOptions): Promise<EscrowFactoryComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    simulate(options: RawSimulateOptions): Promise<EscrowFactoryComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    /**
     * Sends the transaction group to the network and returns the results
     */
    send(params?: SendParams): Promise<EscrowFactoryComposerResults<TReturns>>;
};
export type EscrowFactoryComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
    returns: TReturns;
}>;
