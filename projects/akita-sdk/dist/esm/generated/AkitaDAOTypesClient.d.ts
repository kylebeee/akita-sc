/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client';
import { ABIReturn } from '@algorandfoundation/algokit-utils/types/app';
import { Arc56Contract } from '@algorandfoundation/algokit-utils/types/app-arc56';
import { AppClient as _AppClient, AppClientMethodCallParams, AppClientParams, AppClientBareCallParams, CallOnComplete, AppClientCompilationParams, ResolveAppClientByCreatorAndName, ResolveAppClientByNetwork, CloneAppClientParams } from '@algorandfoundation/algokit-utils/types/app-client';
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory';
import { TransactionComposer, AppCallMethodCall, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer';
import { SendParams, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction';
import { Address, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk';
export declare const APP_SPEC: Arc56Contract;
/**
 * A state record containing binary data
 */
export interface BinaryState {
    /**
     * Gets the state value as a Uint8Array
     */
    asByteArray(): Uint8Array | undefined;
    /**
     * Gets the state value as a string
     */
    asString(): string | undefined;
}
/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R ? (...args: Expand<A>) => Expand<R> : T extends infer O ? {
    [K in keyof O]: O[K];
} : never;
export type ProposalAddAllowances = {
    escrow: string;
    allowances: [bigint, number, bigint, bigint, bigint, boolean][];
};
/**
 * Converts the ABI tuple representation of a ProposalAddAllowances to the struct representation
 */
export declare function ProposalAddAllowancesFromTuple(abiTuple: [string, [bigint, number, bigint, bigint, bigint, boolean][]]): ProposalAddAllowances;
export type ProposalAddNamedPlugin = {
    name: string;
    plugin: bigint;
    caller: string;
    escrow: string;
    delegationType: number;
    lastValid: bigint;
    cooldown: bigint;
    methods: [Uint8Array, bigint][];
    useRounds: boolean;
    useExecutionKey: boolean;
    coverFees: boolean;
    defaultToEscrow: boolean;
    fee: bigint;
    power: bigint;
    duration: bigint;
    participation: bigint;
    approval: bigint;
    sourceLink: string;
    allowances: [bigint, number, bigint, bigint, bigint, boolean][];
};
/**
 * Converts the ABI tuple representation of a ProposalAddNamedPlugin to the struct representation
 */
export declare function ProposalAddNamedPluginFromTuple(abiTuple: [string, bigint, string, string, number, bigint, bigint, [Uint8Array, bigint][], boolean, boolean, boolean, boolean, bigint, bigint, bigint, bigint, bigint, string, [bigint, number, bigint, bigint, bigint, boolean][]]): ProposalAddNamedPlugin;
export type ProposalAddPlugin = {
    plugin: bigint;
    caller: string;
    escrow: string;
    delegationType: number;
    lastValid: bigint;
    cooldown: bigint;
    methods: [Uint8Array, bigint][];
    useRounds: boolean;
    useExecutionKey: boolean;
    coverFees: boolean;
    defaultToEscrow: boolean;
    fee: bigint;
    power: bigint;
    duration: bigint;
    participation: bigint;
    approval: bigint;
    sourceLink: string;
    allowances: [bigint, number, bigint, bigint, bigint, boolean][];
};
/**
 * Converts the ABI tuple representation of a ProposalAddPlugin to the struct representation
 */
export declare function ProposalAddPluginFromTuple(abiTuple: [bigint, string, string, number, bigint, bigint, [Uint8Array, bigint][], boolean, boolean, boolean, boolean, bigint, bigint, bigint, bigint, bigint, string, [bigint, number, bigint, bigint, bigint, boolean][]]): ProposalAddPlugin;
export type ProposalExecuteNamedPlugin = {
    name: string;
    executionKey: Uint8Array;
    groups: Uint8Array[];
    firstValid: bigint;
    lastValid: bigint;
};
/**
 * Converts the ABI tuple representation of a ProposalExecuteNamedPlugin to the struct representation
 */
export declare function ProposalExecuteNamedPluginFromTuple(abiTuple: [string, Uint8Array, Uint8Array[], bigint, bigint]): ProposalExecuteNamedPlugin;
export type ProposalExecutePlugin = {
    plugin: bigint;
    escrow: string;
    executionKey: Uint8Array;
    groups: Uint8Array[];
    firstValid: bigint;
    lastValid: bigint;
};
/**
 * Converts the ABI tuple representation of a ProposalExecutePlugin to the struct representation
 */
export declare function ProposalExecutePluginFromTuple(abiTuple: [bigint, string, Uint8Array, Uint8Array[], bigint, bigint]): ProposalExecutePlugin;
export type ProposalNewEscrow = {
    escrow: string;
};
/**
 * Converts the ABI tuple representation of a ProposalNewEscrow to the struct representation
 */
export declare function ProposalNewEscrowFromTuple(abiTuple: [string]): ProposalNewEscrow;
export type ProposalRemoveAllowances = {
    escrow: string;
    assets: bigint[];
};
/**
 * Converts the ABI tuple representation of a ProposalRemoveAllowances to the struct representation
 */
export declare function ProposalRemoveAllowancesFromTuple(abiTuple: [string, bigint[]]): ProposalRemoveAllowances;
export type ProposalRemoveExecutePlugin = {
    executionKey: Uint8Array;
};
/**
 * Converts the ABI tuple representation of a ProposalRemoveExecutePlugin to the struct representation
 */
export declare function ProposalRemoveExecutePluginFromTuple(abiTuple: [Uint8Array]): ProposalRemoveExecutePlugin;
export type ProposalRemoveNamedPlugin = {
    name: string;
    plugin: bigint;
    caller: string;
    escrow: string;
};
/**
 * Converts the ABI tuple representation of a ProposalRemoveNamedPlugin to the struct representation
 */
export declare function ProposalRemoveNamedPluginFromTuple(abiTuple: [string, bigint, string, string]): ProposalRemoveNamedPlugin;
export type ProposalRemovePlugin = {
    plugin: bigint;
    caller: string;
    escrow: string;
};
/**
 * Converts the ABI tuple representation of a ProposalRemovePlugin to the struct representation
 */
export declare function ProposalRemovePluginFromTuple(abiTuple: [bigint, string, string]): ProposalRemovePlugin;
export type ProposalToggleEscrowLock = {
    escrow: string;
};
/**
 * Converts the ABI tuple representation of a ProposalToggleEscrowLock to the struct representation
 */
export declare function ProposalToggleEscrowLockFromTuple(abiTuple: [string]): ProposalToggleEscrowLock;
export type ProposalUpdateField = {
    field: string;
    value: Uint8Array;
};
/**
 * Converts the ABI tuple representation of a ProposalUpdateField to the struct representation
 */
export declare function ProposalUpdateFieldFromTuple(abiTuple: [string, Uint8Array]): ProposalUpdateField;
export type ProposalUpgradeApp = {
    app: bigint;
    executionKey: Uint8Array;
    groups: Uint8Array[];
    firstValid: bigint;
    lastValid: bigint;
};
/**
 * Converts the ABI tuple representation of a ProposalUpgradeApp to the struct representation
 */
export declare function ProposalUpgradeAppFromTuple(abiTuple: [bigint, Uint8Array, Uint8Array[], bigint, bigint]): ProposalUpgradeApp;
/**
 * The argument types for the AkitaDaoTypes contract
 */
export type AkitaDaoTypesArgs = {
    /**
     * The object representation of the arguments for each method
     */
    obj: {
        'proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)': {
            shape: ProposalUpgradeApp;
        };
        'proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])': {
            shape: ProposalAddPlugin;
        };
        'proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])': {
            shape: ProposalAddNamedPlugin;
        };
        'proposalRemovePluginShape((uint64,address,string))(uint64,address,string)': {
            shape: ProposalRemovePlugin;
        };
        'proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)': {
            shape: ProposalRemoveNamedPlugin;
        };
        'proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)': {
            shape: ProposalExecutePlugin;
        };
        'proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)': {
            shape: ProposalExecuteNamedPlugin;
        };
        'proposalRemoveExecutePluginShape((byte[32]))(byte[32])': {
            shape: ProposalRemoveExecutePlugin;
        };
        'proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])': {
            shape: ProposalAddAllowances;
        };
        'proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])': {
            shape: ProposalRemoveAllowances;
        };
        'proposalNewEscrowShape((string))(string)': {
            shape: ProposalNewEscrow;
        };
        'proposalToggleEscrowLockShape((string))(string)': {
            shape: ProposalToggleEscrowLock;
        };
        'proposalUpdateFieldShape((string,byte[]))(string,byte[])': {
            shape: ProposalUpdateField;
        };
    };
    /**
     * The tuple representation of the arguments for each method
     */
    tuple: {
        'proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)': [shape: ProposalUpgradeApp];
        'proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])': [shape: ProposalAddPlugin];
        'proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])': [shape: ProposalAddNamedPlugin];
        'proposalRemovePluginShape((uint64,address,string))(uint64,address,string)': [shape: ProposalRemovePlugin];
        'proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)': [shape: ProposalRemoveNamedPlugin];
        'proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)': [shape: ProposalExecutePlugin];
        'proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)': [shape: ProposalExecuteNamedPlugin];
        'proposalRemoveExecutePluginShape((byte[32]))(byte[32])': [shape: ProposalRemoveExecutePlugin];
        'proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])': [shape: ProposalAddAllowances];
        'proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])': [shape: ProposalRemoveAllowances];
        'proposalNewEscrowShape((string))(string)': [shape: ProposalNewEscrow];
        'proposalToggleEscrowLockShape((string))(string)': [shape: ProposalToggleEscrowLock];
        'proposalUpdateFieldShape((string,byte[]))(string,byte[])': [shape: ProposalUpdateField];
    };
};
/**
 * The return type for each method
 */
export type AkitaDaoTypesReturns = {
    'proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)': ProposalUpgradeApp;
    'proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])': ProposalAddPlugin;
    'proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])': ProposalAddNamedPlugin;
    'proposalRemovePluginShape((uint64,address,string))(uint64,address,string)': ProposalRemovePlugin;
    'proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)': ProposalRemoveNamedPlugin;
    'proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)': ProposalExecutePlugin;
    'proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)': ProposalExecuteNamedPlugin;
    'proposalRemoveExecutePluginShape((byte[32]))(byte[32])': ProposalRemoveExecutePlugin;
    'proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])': ProposalAddAllowances;
    'proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])': ProposalRemoveAllowances;
    'proposalNewEscrowShape((string))(string)': ProposalNewEscrow;
    'proposalToggleEscrowLockShape((string))(string)': ProposalToggleEscrowLock;
    'proposalUpdateFieldShape((string,byte[]))(string,byte[])': ProposalUpdateField;
};
/**
 * Defines the types of available calls and state of the AkitaDaoTypes smart contract.
 */
export type AkitaDaoTypesTypes = {
    /**
     * Maps method signatures / names to their argument and return types.
     */
    methods: Record<'proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)' | 'proposalUpgradeAppShape', {
        argsObj: AkitaDaoTypesArgs['obj']['proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)'];
        argsTuple: AkitaDaoTypesArgs['tuple']['proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)'];
        returns: AkitaDaoTypesReturns['proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)'];
    }> & Record<'proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])' | 'proposalAddPluginShape', {
        argsObj: AkitaDaoTypesArgs['obj']['proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])'];
        argsTuple: AkitaDaoTypesArgs['tuple']['proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])'];
        returns: AkitaDaoTypesReturns['proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])'];
    }> & Record<'proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])' | 'proposalAddNamedPluginShape', {
        argsObj: AkitaDaoTypesArgs['obj']['proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])'];
        argsTuple: AkitaDaoTypesArgs['tuple']['proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])'];
        returns: AkitaDaoTypesReturns['proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])'];
    }> & Record<'proposalRemovePluginShape((uint64,address,string))(uint64,address,string)' | 'proposalRemovePluginShape', {
        argsObj: AkitaDaoTypesArgs['obj']['proposalRemovePluginShape((uint64,address,string))(uint64,address,string)'];
        argsTuple: AkitaDaoTypesArgs['tuple']['proposalRemovePluginShape((uint64,address,string))(uint64,address,string)'];
        returns: AkitaDaoTypesReturns['proposalRemovePluginShape((uint64,address,string))(uint64,address,string)'];
    }> & Record<'proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)' | 'proposalRemoveNamedPluginShape', {
        argsObj: AkitaDaoTypesArgs['obj']['proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)'];
        argsTuple: AkitaDaoTypesArgs['tuple']['proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)'];
        returns: AkitaDaoTypesReturns['proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)'];
    }> & Record<'proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)' | 'proposalExecutePluginShape', {
        argsObj: AkitaDaoTypesArgs['obj']['proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)'];
        argsTuple: AkitaDaoTypesArgs['tuple']['proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)'];
        returns: AkitaDaoTypesReturns['proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)'];
    }> & Record<'proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)' | 'proposalExecuteNamedPluginShape', {
        argsObj: AkitaDaoTypesArgs['obj']['proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)'];
        argsTuple: AkitaDaoTypesArgs['tuple']['proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)'];
        returns: AkitaDaoTypesReturns['proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)'];
    }> & Record<'proposalRemoveExecutePluginShape((byte[32]))(byte[32])' | 'proposalRemoveExecutePluginShape', {
        argsObj: AkitaDaoTypesArgs['obj']['proposalRemoveExecutePluginShape((byte[32]))(byte[32])'];
        argsTuple: AkitaDaoTypesArgs['tuple']['proposalRemoveExecutePluginShape((byte[32]))(byte[32])'];
        returns: AkitaDaoTypesReturns['proposalRemoveExecutePluginShape((byte[32]))(byte[32])'];
    }> & Record<'proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])' | 'proposalAddAllowancesShape', {
        argsObj: AkitaDaoTypesArgs['obj']['proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])'];
        argsTuple: AkitaDaoTypesArgs['tuple']['proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])'];
        returns: AkitaDaoTypesReturns['proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])'];
    }> & Record<'proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])' | 'proposalRemoveAllowancesShape', {
        argsObj: AkitaDaoTypesArgs['obj']['proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])'];
        argsTuple: AkitaDaoTypesArgs['tuple']['proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])'];
        returns: AkitaDaoTypesReturns['proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])'];
    }> & Record<'proposalNewEscrowShape((string))(string)' | 'proposalNewEscrowShape', {
        argsObj: AkitaDaoTypesArgs['obj']['proposalNewEscrowShape((string))(string)'];
        argsTuple: AkitaDaoTypesArgs['tuple']['proposalNewEscrowShape((string))(string)'];
        returns: AkitaDaoTypesReturns['proposalNewEscrowShape((string))(string)'];
    }> & Record<'proposalToggleEscrowLockShape((string))(string)' | 'proposalToggleEscrowLockShape', {
        argsObj: AkitaDaoTypesArgs['obj']['proposalToggleEscrowLockShape((string))(string)'];
        argsTuple: AkitaDaoTypesArgs['tuple']['proposalToggleEscrowLockShape((string))(string)'];
        returns: AkitaDaoTypesReturns['proposalToggleEscrowLockShape((string))(string)'];
    }> & Record<'proposalUpdateFieldShape((string,byte[]))(string,byte[])' | 'proposalUpdateFieldShape', {
        argsObj: AkitaDaoTypesArgs['obj']['proposalUpdateFieldShape((string,byte[]))(string,byte[])'];
        argsTuple: AkitaDaoTypesArgs['tuple']['proposalUpdateFieldShape((string,byte[]))(string,byte[])'];
        returns: AkitaDaoTypesReturns['proposalUpdateFieldShape((string,byte[]))(string,byte[])'];
    }>;
};
/**
 * Defines the possible abi call signatures.
 */
export type AkitaDaoTypesSignatures = keyof AkitaDaoTypesTypes['methods'];
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type AkitaDaoTypesNonVoidMethodSignatures = keyof AkitaDaoTypesTypes['methods'] extends infer T ? T extends keyof AkitaDaoTypesTypes['methods'] ? MethodReturn<T> extends void ? never : T : never : never;
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> & {
    /** The args for the ABI method call, either as an ordered array or an object */
    args: Expand<TArgs>;
}>;
/**
 * Maps a method signature from the AkitaDaoTypes smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends AkitaDaoTypesSignatures> = AkitaDaoTypesTypes['methods'][TSignature]['argsObj' | 'argsTuple'];
/**
 * Maps a method signature from the AkitaDaoTypes smart contract to the method's return type
 */
export type MethodReturn<TSignature extends AkitaDaoTypesSignatures> = AkitaDaoTypesTypes['methods'][TSignature]['returns'];
/**
 * Defines supported create method params for this smart contract
 */
export type AkitaDaoTypesCreateCallParams = Expand<AppClientBareCallParams & {
    method?: never;
} & {
    onComplete?: OnApplicationComplete.NoOpOC;
} & CreateSchema>;
/**
 * Defines arguments required for the deploy method.
 */
export type AkitaDaoTypesDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
    /**
     * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
     */
    createParams?: AkitaDaoTypesCreateCallParams;
}>;
/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the AkitaDaoTypes smart contract
 */
export declare abstract class AkitaDaoTypesParamsFactory {
    /**
     * Constructs a no op call for the proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static proposalUpgradeAppShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)'] | AkitaDaoTypesArgs['tuple']['proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static proposalAddPluginShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])'] | AkitaDaoTypesArgs['tuple']['proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static proposalAddNamedPluginShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])'] | AkitaDaoTypesArgs['tuple']['proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the proposalRemovePluginShape((uint64,address,string))(uint64,address,string) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static proposalRemovePluginShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalRemovePluginShape((uint64,address,string))(uint64,address,string)'] | AkitaDaoTypesArgs['tuple']['proposalRemovePluginShape((uint64,address,string))(uint64,address,string)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static proposalRemoveNamedPluginShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)'] | AkitaDaoTypesArgs['tuple']['proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static proposalExecutePluginShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)'] | AkitaDaoTypesArgs['tuple']['proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static proposalExecuteNamedPluginShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)'] | AkitaDaoTypesArgs['tuple']['proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the proposalRemoveExecutePluginShape((byte[32]))(byte[32]) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static proposalRemoveExecutePluginShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalRemoveExecutePluginShape((byte[32]))(byte[32])'] | AkitaDaoTypesArgs['tuple']['proposalRemoveExecutePluginShape((byte[32]))(byte[32])']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[]) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static proposalAddAllowancesShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])'] | AkitaDaoTypesArgs['tuple']['proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[]) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static proposalRemoveAllowancesShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])'] | AkitaDaoTypesArgs['tuple']['proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the proposalNewEscrowShape((string))(string) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static proposalNewEscrowShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalNewEscrowShape((string))(string)'] | AkitaDaoTypesArgs['tuple']['proposalNewEscrowShape((string))(string)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the proposalToggleEscrowLockShape((string))(string) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static proposalToggleEscrowLockShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalToggleEscrowLockShape((string))(string)'] | AkitaDaoTypesArgs['tuple']['proposalToggleEscrowLockShape((string))(string)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the proposalUpdateFieldShape((string,byte[]))(string,byte[]) ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static proposalUpdateFieldShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalUpdateFieldShape((string,byte[]))(string,byte[])'] | AkitaDaoTypesArgs['tuple']['proposalUpdateFieldShape((string,byte[]))(string,byte[])']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
}
/**
 * A factory to create and deploy one or more instance of the AkitaDAOTypes smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export declare class AkitaDaoTypesFactory {
    /**
     * The underlying `AppFactory` for when you want to have more flexibility
     */
    readonly appFactory: _AppFactory;
    /**
     * Creates a new instance of `AkitaDaoTypesFactory`
     *
     * @param params The parameters to initialise the app factory with
     */
    constructor(params: Omit<AppFactoryParams, 'appSpec'>);
    /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
    get appName(): string;
    /** The ARC-56 app spec being used */
    get appSpec(): Arc56Contract;
    /** A reference to the underlying `AlgorandClient` this app factory is using. */
    get algorand(): AlgorandClient;
    /**
     * Returns a new `AppClient` client for an app instance of the given ID.
     *
     * Automatically populates appName, defaultSender and source maps from the factory
     * if not specified in the params.
     * @param params The parameters to create the app client
     * @returns The `AppClient`
     */
    getAppClientById(params: AppFactoryAppClientParams): AkitaDaoTypesClient;
    /**
     * Returns a new `AppClient` client, resolving the app by creator address and name
     * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
     *
     * Automatically populates appName, defaultSender and source maps from the factory
     * if not specified in the params.
     * @param params The parameters to create the app client
     * @returns The `AppClient`
     */
    getAppClientByCreatorAndName(params: AppFactoryResolveAppClientByCreatorAndNameParams): Promise<AkitaDaoTypesClient>;
    /**
     * Idempotently deploys the AkitaDAOTypes smart contract.
     *
     * @param params The arguments for the contract calls and any additional parameters for the call
     * @returns The deployment result
     */
    deploy(params?: AkitaDaoTypesDeployParams): Promise<{
        result: {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "create";
            version: string;
            name: string;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            appId: bigint;
            appAddress: Address;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "update";
            appId: bigint;
            appAddress: Address;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            name: string;
            version: string;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "replace";
            version: string;
            name: string;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            appId: bigint;
            appAddress: Address;
            deleteResult: import("@algorandfoundation/algokit-utils/types/transaction").ConfirmedTransactionResult;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "nothing";
            appId: bigint;
            appAddress: Address;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            name: string;
            version: string;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
        };
        appClient: AkitaDaoTypesClient;
    }>;
    /**
     * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
     */
    readonly params: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the AkitaDAOTypes smart contract using a bare call.
             *
             * @param params The params for the bare (raw) call
             * @returns The params for a create call
             */
            bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }>) => Promise<{
                approvalProgram: Uint8Array;
                clearStateProgram: Uint8Array;
                compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                deployTimeParams: import("@algorandfoundation/algokit-utils/types/app").TealTemplateParams | undefined;
                schema: {
                    globalInts: number;
                    globalByteSlices: number;
                    localInts: number;
                    localByteSlices: number;
                };
                maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                note?: string | Uint8Array | undefined;
                args?: Uint8Array[] | undefined;
                signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                lease?: string | Uint8Array | undefined;
                rekeyTo?: string | Address | undefined;
                staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                validityWindow?: number | bigint | undefined;
                firstValidRound?: bigint | undefined;
                lastValidRound?: bigint | undefined;
                accountReferences?: (string | Address)[] | undefined;
                appReferences?: bigint[] | undefined;
                assetReferences?: bigint[] | undefined;
                boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                sender?: string | Address | undefined;
                updatable?: boolean | undefined;
                deletable?: boolean | undefined;
                onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                extraProgramPages?: number | undefined;
            } & {
                sender: Address;
                signer: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                onComplete: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC;
            }>;
        };
    };
    /**
     * Create transactions for the current app
     */
    readonly createTransaction: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the AkitaDAOTypes smart contract using a bare call.
             *
             * @param params The params for the bare (raw) call
             * @returns The transaction for a create call
             */
            bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }>) => Promise<Transaction>;
        };
    };
    /**
     * Send calls to the current app
     */
    readonly send: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the AkitaDAOTypes smart contract using a bare call.
             *
             * @param params The params for the bare (raw) call
             * @returns The create result
             */
            bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & SendParams & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }>) => Promise<{
                result: {
                    compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                    compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                    return: undefined;
                    groupId: string;
                    txIds: string[];
                    returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
                    confirmations: modelsv2.PendingTransactionResponse[];
                    transactions: Transaction[];
                    confirmation: modelsv2.PendingTransactionResponse;
                    transaction: Transaction;
                    appId: bigint;
                    appAddress: Address;
                };
                appClient: AkitaDaoTypesClient;
            }>;
        };
    };
}
/**
 * A client to make calls to the AkitaDAOTypes smart contract
 */
export declare class AkitaDaoTypesClient {
    /**
     * The underlying `AppClient` for when you want to have more flexibility
     */
    readonly appClient: _AppClient;
    /**
     * Creates a new instance of `AkitaDaoTypesClient`
     *
     * @param appClient An `AppClient` instance which has been created with the AkitaDaoTypes app spec
     */
    constructor(appClient: _AppClient);
    /**
     * Creates a new instance of `AkitaDaoTypesClient`
     *
     * @param params The parameters to initialise the app client with
     */
    constructor(params: Omit<AppClientParams, 'appSpec'>);
    /**
     * Checks for decode errors on the given return value and maps the return value to the return type for the given method
     * @returns The typed return value or undefined if there was no value
     */
    decodeReturnValue<TSignature extends AkitaDaoTypesNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined): MethodReturn<TSignature> | undefined;
    /**
     * Returns a new `AkitaDaoTypesClient` client, resolving the app by creator address and name
     * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
     * @param params The parameters to create the app client
     */
    static fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<AkitaDaoTypesClient>;
    /**
     * Returns an `AkitaDaoTypesClient` instance for the current network based on
     * pre-determined network-specific app IDs specified in the ARC-56 app spec.
     *
     * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
     * @param params The parameters to create the app client
     */
    static fromNetwork(params: Omit<ResolveAppClientByNetwork, 'appSpec'>): Promise<AkitaDaoTypesClient>;
    /** The ID of the app instance this client is linked to. */
    get appId(): bigint;
    /** The app address of the app instance this client is linked to. */
    get appAddress(): Address;
    /** The name of the app. */
    get appName(): string;
    /** The ARC-56 app spec being used */
    get appSpec(): Arc56Contract;
    /** A reference to the underlying `AlgorandClient` this app client is using. */
    get algorand(): AlgorandClient;
    /**
     * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
     */
    readonly params: {
        /**
         * Makes a clear_state call to an existing instance of the AkitaDAOTypes smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams>) => import("@algorandfoundation/algokit-utils/types/composer").AppCallParams;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        proposalUpgradeAppShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)"] | AkitaDaoTypesArgs["tuple"]["proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        proposalAddPluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])"] | AkitaDaoTypesArgs["tuple"]["proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        proposalAddNamedPluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])"] | AkitaDaoTypesArgs["tuple"]["proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalRemovePluginShape((uint64,address,string))(uint64,address,string)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        proposalRemovePluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalRemovePluginShape((uint64,address,string))(uint64,address,string)"] | AkitaDaoTypesArgs["tuple"]["proposalRemovePluginShape((uint64,address,string))(uint64,address,string)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        proposalRemoveNamedPluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)"] | AkitaDaoTypesArgs["tuple"]["proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        proposalExecutePluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)"] | AkitaDaoTypesArgs["tuple"]["proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        proposalExecuteNamedPluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)"] | AkitaDaoTypesArgs["tuple"]["proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalRemoveExecutePluginShape((byte[32]))(byte[32])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        proposalRemoveExecutePluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalRemoveExecutePluginShape((byte[32]))(byte[32])"] | AkitaDaoTypesArgs["tuple"]["proposalRemoveExecutePluginShape((byte[32]))(byte[32])"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        proposalAddAllowancesShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])"] | AkitaDaoTypesArgs["tuple"]["proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        proposalRemoveAllowancesShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])"] | AkitaDaoTypesArgs["tuple"]["proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalNewEscrowShape((string))(string)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        proposalNewEscrowShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalNewEscrowShape((string))(string)"] | AkitaDaoTypesArgs["tuple"]["proposalNewEscrowShape((string))(string)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalToggleEscrowLockShape((string))(string)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        proposalToggleEscrowLockShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalToggleEscrowLockShape((string))(string)"] | AkitaDaoTypesArgs["tuple"]["proposalToggleEscrowLockShape((string))(string)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalUpdateFieldShape((string,byte[]))(string,byte[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        proposalUpdateFieldShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalUpdateFieldShape((string,byte[]))(string,byte[])"] | AkitaDaoTypesArgs["tuple"]["proposalUpdateFieldShape((string,byte[]))(string,byte[])"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
    };
    /**
     * Create transactions for the current app
     */
    readonly createTransaction: {
        /**
         * Makes a clear_state call to an existing instance of the AkitaDAOTypes smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams>) => Promise<Transaction>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        proposalUpgradeAppShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)"] | AkitaDaoTypesArgs["tuple"]["proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        proposalAddPluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])"] | AkitaDaoTypesArgs["tuple"]["proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        proposalAddNamedPluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])"] | AkitaDaoTypesArgs["tuple"]["proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalRemovePluginShape((uint64,address,string))(uint64,address,string)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        proposalRemovePluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalRemovePluginShape((uint64,address,string))(uint64,address,string)"] | AkitaDaoTypesArgs["tuple"]["proposalRemovePluginShape((uint64,address,string))(uint64,address,string)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        proposalRemoveNamedPluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)"] | AkitaDaoTypesArgs["tuple"]["proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        proposalExecutePluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)"] | AkitaDaoTypesArgs["tuple"]["proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        proposalExecuteNamedPluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)"] | AkitaDaoTypesArgs["tuple"]["proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalRemoveExecutePluginShape((byte[32]))(byte[32])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        proposalRemoveExecutePluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalRemoveExecutePluginShape((byte[32]))(byte[32])"] | AkitaDaoTypesArgs["tuple"]["proposalRemoveExecutePluginShape((byte[32]))(byte[32])"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        proposalAddAllowancesShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])"] | AkitaDaoTypesArgs["tuple"]["proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        proposalRemoveAllowancesShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])"] | AkitaDaoTypesArgs["tuple"]["proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalNewEscrowShape((string))(string)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        proposalNewEscrowShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalNewEscrowShape((string))(string)"] | AkitaDaoTypesArgs["tuple"]["proposalNewEscrowShape((string))(string)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalToggleEscrowLockShape((string))(string)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        proposalToggleEscrowLockShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalToggleEscrowLockShape((string))(string)"] | AkitaDaoTypesArgs["tuple"]["proposalToggleEscrowLockShape((string))(string)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalUpdateFieldShape((string,byte[]))(string,byte[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        proposalUpdateFieldShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalUpdateFieldShape((string,byte[]))(string,byte[])"] | AkitaDaoTypesArgs["tuple"]["proposalUpdateFieldShape((string,byte[]))(string,byte[])"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
    };
    /**
     * Send calls to the current app
     */
    readonly send: {
        /**
         * Makes a clear_state call to an existing instance of the AkitaDAOTypes smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => Promise<{
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            return?: ABIReturn | undefined;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        proposalUpgradeAppShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)"] | AkitaDaoTypesArgs["tuple"]["proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoTypesReturns["proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        proposalAddPluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])"] | AkitaDaoTypesArgs["tuple"]["proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoTypesReturns["proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        proposalAddNamedPluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])"] | AkitaDaoTypesArgs["tuple"]["proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoTypesReturns["proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalRemovePluginShape((uint64,address,string))(uint64,address,string)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        proposalRemovePluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalRemovePluginShape((uint64,address,string))(uint64,address,string)"] | AkitaDaoTypesArgs["tuple"]["proposalRemovePluginShape((uint64,address,string))(uint64,address,string)"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoTypesReturns["proposalRemovePluginShape((uint64,address,string))(uint64,address,string)"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        proposalRemoveNamedPluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)"] | AkitaDaoTypesArgs["tuple"]["proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoTypesReturns["proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        proposalExecutePluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)"] | AkitaDaoTypesArgs["tuple"]["proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoTypesReturns["proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        proposalExecuteNamedPluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)"] | AkitaDaoTypesArgs["tuple"]["proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoTypesReturns["proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalRemoveExecutePluginShape((byte[32]))(byte[32])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        proposalRemoveExecutePluginShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalRemoveExecutePluginShape((byte[32]))(byte[32])"] | AkitaDaoTypesArgs["tuple"]["proposalRemoveExecutePluginShape((byte[32]))(byte[32])"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoTypesReturns["proposalRemoveExecutePluginShape((byte[32]))(byte[32])"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        proposalAddAllowancesShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])"] | AkitaDaoTypesArgs["tuple"]["proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoTypesReturns["proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        proposalRemoveAllowancesShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])"] | AkitaDaoTypesArgs["tuple"]["proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoTypesReturns["proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalNewEscrowShape((string))(string)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        proposalNewEscrowShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalNewEscrowShape((string))(string)"] | AkitaDaoTypesArgs["tuple"]["proposalNewEscrowShape((string))(string)"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoTypesReturns["proposalNewEscrowShape((string))(string)"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalToggleEscrowLockShape((string))(string)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        proposalToggleEscrowLockShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalToggleEscrowLockShape((string))(string)"] | AkitaDaoTypesArgs["tuple"]["proposalToggleEscrowLockShape((string))(string)"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoTypesReturns["proposalToggleEscrowLockShape((string))(string)"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the AkitaDAOTypes smart contract using the `proposalUpdateFieldShape((string,byte[]))(string,byte[])` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        proposalUpdateFieldShape: (params: CallParams<AkitaDaoTypesArgs["obj"]["proposalUpdateFieldShape((string,byte[]))(string,byte[])"] | AkitaDaoTypesArgs["tuple"]["proposalUpdateFieldShape((string,byte[]))(string,byte[])"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | AkitaDaoTypesReturns["proposalUpdateFieldShape((string,byte[]))(string,byte[])"]);
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
    };
    /**
     * Clone this app client with different params
     *
     * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
     * @returns A new app client with the altered params
     */
    clone(params: CloneAppClientParams): AkitaDaoTypesClient;
    /**
     * Makes a readonly (simulated) call to the AkitaDAOTypes smart contract using the `proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    proposalUpgradeAppShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)'] | AkitaDaoTypesArgs['tuple']['proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)']>): Promise<ProposalUpgradeApp>;
    /**
     * Makes a readonly (simulated) call to the AkitaDAOTypes smart contract using the `proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    proposalAddPluginShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])'] | AkitaDaoTypesArgs['tuple']['proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])']>): Promise<ProposalAddPlugin>;
    /**
     * Makes a readonly (simulated) call to the AkitaDAOTypes smart contract using the `proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    proposalAddNamedPluginShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])'] | AkitaDaoTypesArgs['tuple']['proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])']>): Promise<ProposalAddNamedPlugin>;
    /**
     * Makes a readonly (simulated) call to the AkitaDAOTypes smart contract using the `proposalRemovePluginShape((uint64,address,string))(uint64,address,string)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    proposalRemovePluginShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalRemovePluginShape((uint64,address,string))(uint64,address,string)'] | AkitaDaoTypesArgs['tuple']['proposalRemovePluginShape((uint64,address,string))(uint64,address,string)']>): Promise<ProposalRemovePlugin>;
    /**
     * Makes a readonly (simulated) call to the AkitaDAOTypes smart contract using the `proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    proposalRemoveNamedPluginShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)'] | AkitaDaoTypesArgs['tuple']['proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)']>): Promise<ProposalRemoveNamedPlugin>;
    /**
     * Makes a readonly (simulated) call to the AkitaDAOTypes smart contract using the `proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    proposalExecutePluginShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)'] | AkitaDaoTypesArgs['tuple']['proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)']>): Promise<ProposalExecutePlugin>;
    /**
     * Makes a readonly (simulated) call to the AkitaDAOTypes smart contract using the `proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    proposalExecuteNamedPluginShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)'] | AkitaDaoTypesArgs['tuple']['proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)']>): Promise<ProposalExecuteNamedPlugin>;
    /**
     * Makes a readonly (simulated) call to the AkitaDAOTypes smart contract using the `proposalRemoveExecutePluginShape((byte[32]))(byte[32])` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    proposalRemoveExecutePluginShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalRemoveExecutePluginShape((byte[32]))(byte[32])'] | AkitaDaoTypesArgs['tuple']['proposalRemoveExecutePluginShape((byte[32]))(byte[32])']>): Promise<ProposalRemoveExecutePlugin>;
    /**
     * Makes a readonly (simulated) call to the AkitaDAOTypes smart contract using the `proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    proposalAddAllowancesShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])'] | AkitaDaoTypesArgs['tuple']['proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])']>): Promise<ProposalAddAllowances>;
    /**
     * Makes a readonly (simulated) call to the AkitaDAOTypes smart contract using the `proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    proposalRemoveAllowancesShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])'] | AkitaDaoTypesArgs['tuple']['proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])']>): Promise<ProposalRemoveAllowances>;
    /**
     * Makes a readonly (simulated) call to the AkitaDAOTypes smart contract using the `proposalNewEscrowShape((string))(string)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    proposalNewEscrowShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalNewEscrowShape((string))(string)'] | AkitaDaoTypesArgs['tuple']['proposalNewEscrowShape((string))(string)']>): Promise<ProposalNewEscrow>;
    /**
     * Makes a readonly (simulated) call to the AkitaDAOTypes smart contract using the `proposalToggleEscrowLockShape((string))(string)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    proposalToggleEscrowLockShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalToggleEscrowLockShape((string))(string)'] | AkitaDaoTypesArgs['tuple']['proposalToggleEscrowLockShape((string))(string)']>): Promise<ProposalToggleEscrowLock>;
    /**
     * Makes a readonly (simulated) call to the AkitaDAOTypes smart contract using the `proposalUpdateFieldShape((string,byte[]))(string,byte[])` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    proposalUpdateFieldShape(params: CallParams<AkitaDaoTypesArgs['obj']['proposalUpdateFieldShape((string,byte[]))(string,byte[])'] | AkitaDaoTypesArgs['tuple']['proposalUpdateFieldShape((string,byte[]))(string,byte[])']>): Promise<ProposalUpdateField>;
    /**
     * Methods to access state for the current AkitaDAOTypes app
     */
    state: {};
    newGroup(): AkitaDaoTypesComposer;
}
export type AkitaDaoTypesComposer<TReturns extends [...any[]] = []> = {
    /**
     * Calls the proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    proposalUpgradeAppShape(params?: CallParams<AkitaDaoTypesArgs['obj']['proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)'] | AkitaDaoTypesArgs['tuple']['proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)']>): AkitaDaoTypesComposer<[...TReturns, AkitaDaoTypesReturns['proposalUpgradeAppShape((uint64,byte[32],byte[32][],uint64,uint64))(uint64,byte[32],byte[32][],uint64,uint64)'] | undefined]>;
    /**
     * Calls the proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    proposalAddPluginShape(params?: CallParams<AkitaDaoTypesArgs['obj']['proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])'] | AkitaDaoTypesArgs['tuple']['proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])']>): AkitaDaoTypesComposer<[...TReturns, AkitaDaoTypesReturns['proposalAddPluginShape((uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])'] | undefined]>;
    /**
     * Calls the proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    proposalAddNamedPluginShape(params?: CallParams<AkitaDaoTypesArgs['obj']['proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])'] | AkitaDaoTypesArgs['tuple']['proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])']>): AkitaDaoTypesComposer<[...TReturns, AkitaDaoTypesReturns['proposalAddNamedPluginShape((string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,uint64,address,string,uint8,uint64,uint64,(byte[4],uint64)[],bool,bool,bool,bool,uint64,uint64,uint64,uint64,uint64,string,(uint64,uint8,uint64,uint64,uint64,bool)[])'] | undefined]>;
    /**
     * Calls the proposalRemovePluginShape((uint64,address,string))(uint64,address,string) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    proposalRemovePluginShape(params?: CallParams<AkitaDaoTypesArgs['obj']['proposalRemovePluginShape((uint64,address,string))(uint64,address,string)'] | AkitaDaoTypesArgs['tuple']['proposalRemovePluginShape((uint64,address,string))(uint64,address,string)']>): AkitaDaoTypesComposer<[...TReturns, AkitaDaoTypesReturns['proposalRemovePluginShape((uint64,address,string))(uint64,address,string)'] | undefined]>;
    /**
     * Calls the proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    proposalRemoveNamedPluginShape(params?: CallParams<AkitaDaoTypesArgs['obj']['proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)'] | AkitaDaoTypesArgs['tuple']['proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)']>): AkitaDaoTypesComposer<[...TReturns, AkitaDaoTypesReturns['proposalRemoveNamedPluginShape((string,uint64,address,string))(string,uint64,address,string)'] | undefined]>;
    /**
     * Calls the proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    proposalExecutePluginShape(params?: CallParams<AkitaDaoTypesArgs['obj']['proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)'] | AkitaDaoTypesArgs['tuple']['proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)']>): AkitaDaoTypesComposer<[...TReturns, AkitaDaoTypesReturns['proposalExecutePluginShape((uint64,string,byte[32],byte[32][],uint64,uint64))(uint64,string,byte[32],byte[32][],uint64,uint64)'] | undefined]>;
    /**
     * Calls the proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    proposalExecuteNamedPluginShape(params?: CallParams<AkitaDaoTypesArgs['obj']['proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)'] | AkitaDaoTypesArgs['tuple']['proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)']>): AkitaDaoTypesComposer<[...TReturns, AkitaDaoTypesReturns['proposalExecuteNamedPluginShape((string,byte[32],byte[32][],uint64,uint64))(string,byte[32],byte[32][],uint64,uint64)'] | undefined]>;
    /**
     * Calls the proposalRemoveExecutePluginShape((byte[32]))(byte[32]) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    proposalRemoveExecutePluginShape(params?: CallParams<AkitaDaoTypesArgs['obj']['proposalRemoveExecutePluginShape((byte[32]))(byte[32])'] | AkitaDaoTypesArgs['tuple']['proposalRemoveExecutePluginShape((byte[32]))(byte[32])']>): AkitaDaoTypesComposer<[...TReturns, AkitaDaoTypesReturns['proposalRemoveExecutePluginShape((byte[32]))(byte[32])'] | undefined]>;
    /**
     * Calls the proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[]) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    proposalAddAllowancesShape(params?: CallParams<AkitaDaoTypesArgs['obj']['proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])'] | AkitaDaoTypesArgs['tuple']['proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])']>): AkitaDaoTypesComposer<[...TReturns, AkitaDaoTypesReturns['proposalAddAllowancesShape((string,(uint64,uint8,uint64,uint64,uint64,bool)[]))(string,(uint64,uint8,uint64,uint64,uint64,bool)[])'] | undefined]>;
    /**
     * Calls the proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[]) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    proposalRemoveAllowancesShape(params?: CallParams<AkitaDaoTypesArgs['obj']['proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])'] | AkitaDaoTypesArgs['tuple']['proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])']>): AkitaDaoTypesComposer<[...TReturns, AkitaDaoTypesReturns['proposalRemoveAllowancesShape((string,uint64[]))(string,uint64[])'] | undefined]>;
    /**
     * Calls the proposalNewEscrowShape((string))(string) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    proposalNewEscrowShape(params?: CallParams<AkitaDaoTypesArgs['obj']['proposalNewEscrowShape((string))(string)'] | AkitaDaoTypesArgs['tuple']['proposalNewEscrowShape((string))(string)']>): AkitaDaoTypesComposer<[...TReturns, AkitaDaoTypesReturns['proposalNewEscrowShape((string))(string)'] | undefined]>;
    /**
     * Calls the proposalToggleEscrowLockShape((string))(string) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    proposalToggleEscrowLockShape(params?: CallParams<AkitaDaoTypesArgs['obj']['proposalToggleEscrowLockShape((string))(string)'] | AkitaDaoTypesArgs['tuple']['proposalToggleEscrowLockShape((string))(string)']>): AkitaDaoTypesComposer<[...TReturns, AkitaDaoTypesReturns['proposalToggleEscrowLockShape((string))(string)'] | undefined]>;
    /**
     * Calls the proposalUpdateFieldShape((string,byte[]))(string,byte[]) ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    proposalUpdateFieldShape(params?: CallParams<AkitaDaoTypesArgs['obj']['proposalUpdateFieldShape((string,byte[]))(string,byte[])'] | AkitaDaoTypesArgs['tuple']['proposalUpdateFieldShape((string,byte[]))(string,byte[])']>): AkitaDaoTypesComposer<[...TReturns, AkitaDaoTypesReturns['proposalUpdateFieldShape((string,byte[]))(string,byte[])'] | undefined]>;
    /**
     * Makes a clear_state call to an existing instance of the AkitaDAOTypes smart contract.
     *
     * @param args The arguments for the bare call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    clearState(params?: AppClientBareCallParams): AkitaDaoTypesComposer<[...TReturns, undefined]>;
    /**
     * Adds a transaction to the composer
     *
     * @param txn A transaction to add to the transaction group
     * @param signer The optional signer to use when signing this transaction.
     */
    addTransaction(txn: Transaction, signer?: TransactionSigner): AkitaDaoTypesComposer<TReturns>;
    /**
     * Returns the underlying AtomicTransactionComposer instance
     */
    composer(): Promise<TransactionComposer>;
    /**
     * Simulates the transaction group and returns the result
     */
    simulate(): Promise<AkitaDaoTypesComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    simulate(options: SkipSignaturesSimulateOptions): Promise<AkitaDaoTypesComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    simulate(options: RawSimulateOptions): Promise<AkitaDaoTypesComposerResults<TReturns> & {
        simulateResponse: modelsv2.SimulateResponse;
    }>;
    /**
     * Sends the transaction group to the network and returns the results
     */
    send(params?: SendParams): Promise<AkitaDaoTypesComposerResults<TReturns>>;
};
export type AkitaDaoTypesComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
    returns: TReturns;
}>;
