#pragma version 10
intcblock 1 32 0 1024 100_000_000 6
bytecblock 0x 0x64 0x0014 "l.schema" "l.type" 0x00000000000000000000000000000000 0x0022 0x74 0x151f7c75 0x73 0x0000000000000000 0x0a8101

// This TEAL was generated by TEALScript v0.106.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 5 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// getRootBoxDelta(name: string): uint64
getRootBoxDelta:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/metaMerkles/meta_merkles.algo.ts:78
	// pre = globals.currentApplicationAddress.minBalance
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	frame_bury 0 // pre: uint64

	// contracts/metaMerkles/meta_merkles.algo.ts:79
	// rKey: RootKey = { address: globals.zeroAddress, name: name }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 6 //  initial head offset
	global ZeroAddress
	callsub *process_static_tuple_element
	frame_dig -1 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // rKey: RootKey

	// contracts/metaMerkles/meta_merkles.algo.ts:80
	// this.roots(rKey).value = EMPTY_BYTES_32
	frame_dig 1 // rKey: RootKey
	pushbytes 0x4141414141414141414141414141414141414141414141414141414141414141 // "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
	box_put

	// contracts/metaMerkles/meta_merkles.algo.ts:81
	// delta = globals.currentApplicationAddress.minBalance - pre
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	frame_dig 0 // pre: uint64
	-
	frame_bury 2 // delta: uint64

	// contracts/metaMerkles/meta_merkles.algo.ts:82
	// this.roots(rKey).delete()
	frame_dig 1 // rKey: RootKey
	box_del

	// contracts/metaMerkles/meta_merkles.algo.ts:83
	// return delta;
	frame_dig 2 // delta: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// getDataBoxDelta(name: string, key: string, value: string): uint64
getDataBoxDelta:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/metaMerkles/meta_merkles.algo.ts:87
	// pre = globals.currentApplicationAddress.minBalance
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	frame_bury 0 // pre: uint64

	// contracts/metaMerkles/meta_merkles.algo.ts:88
	// dKey: DataKey = { address: EMPTY_BYTES_16, name: name, key: key }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 2 //  initial head offset
	pushbytes 0x41414141414141414141414141414141 // "AAAAAAAAAAAAAAAA"
	callsub *process_static_tuple_element
	frame_dig -1 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -2 // key: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // dKey: DataKey

	// contracts/metaMerkles/meta_merkles.algo.ts:89
	// this.data(dKey).value = value
	bytec 1 //  "d"
	frame_dig 1 // dKey: DataKey
	concat
	dup
	box_del
	pop
	frame_dig -3 // value: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/metaMerkles/meta_merkles.algo.ts:90
	// delta = globals.currentApplicationAddress.minBalance - pre
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	frame_dig 0 // pre: uint64
	-
	frame_bury 2 // delta: uint64

	// contracts/metaMerkles/meta_merkles.algo.ts:91
	// this.data(dKey).delete()
	bytec 1 //  "d"
	frame_dig 1 // dKey: DataKey
	concat
	box_del

	// contracts/metaMerkles/meta_merkles.algo.ts:92
	// return delta;
	frame_dig 2 // delta: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// rootCosts(name: string): uint64
rootCosts:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/metaMerkles/meta_merkles.algo.ts:96
	// rootCost = this.getRootBoxDelta(name)
	frame_dig -1 // name: string
	callsub getRootBoxDelta
	frame_bury 0 // rootCost: uint64

	// contracts/metaMerkles/meta_merkles.algo.ts:97
	// schemaCost = this.getDataBoxDelta(name, treeSchemaKey, itob(0))
	bytec 10 // 0x0000000000000000
	bytec 3 // "l.schema"
	frame_dig -1 // name: string
	callsub getDataBoxDelta
	frame_bury 1 // schemaCost: uint64

	// contracts/metaMerkles/meta_merkles.algo.ts:98
	// typeCost = this.getDataBoxDelta(name, treeTypeKey, itob(0))
	bytec 10 // 0x0000000000000000
	bytec 4 // "l.type"
	frame_dig -1 // name: string
	callsub getDataBoxDelta
	frame_bury 2 // typeCost: uint64

	// contracts/metaMerkles/meta_merkles.algo.ts:99
	// return rootCost + schemaCost + typeCost;
	frame_dig 0 // rootCost: uint64
	frame_dig 1 // schemaCost: uint64
	+
	frame_dig 2 // typeCost: uint64
	+

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// addRoot(pay,string,byte[32],uint64,uint64)void
*abi_route_addRoot:
	// type: uint64
	txna ApplicationArgs 4
	btoi

	// schema: uint64
	txna ApplicationArgs 3
	btoi

	// root: byte[32]
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 32
	==

	// argument 2 (root) for addRoot must be a byte[32]
	assert

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// pmt: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 4 (pmt) for addRoot must be a pay transaction
	assert

	// execute addRoot(pay,string,byte[32],uint64,uint64)void
	callsub addRoot
	intc 0 // 1
	return

// addRoot(pmt: PayTxn, name: string, root: bytes32, schema: uint64, type: uint64): void
//
// Creates two boxes and adds a merkle root
// using a `RootKey` to the root box map and also a list type to the
// metadata attached to the root in the data box map
//
// @param pmt the fee to cover box storage allocation
// @param name the name alias of the root being added
// @param root a merkle tree root
// @param schema an index of the schema enum from box storage
// @param type an index of the tree type enum from box storage
addRoot:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts/metaMerkles/meta_merkles.algo.ts:114
	// assert(name.length <= 32, 'Cannot add root with name longer than 32 bytes')
	frame_dig -2 // name: string
	len
	intc 1 // 32
	<=

	// Cannot add root with name longer than 32 bytes
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:115
	// assert(this.schemas(schema).exists, errs.NO_TREE_SCHEMA)
	frame_dig -4 // schema: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:116
	// assert(this.types(type).exists, errs.NO_TREE_TYPE)
	bytec 7 //  "t"
	frame_dig -5 // type: uint64
	itob
	concat
	box_len
	swap
	pop
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:118
	// truncatedAddress = extract3(this.txn.sender, 0, 16) as bytes16
	txn Sender
	extract 0 16
	bytec 5 // 0x00000000000000000000000000000000
	concat
	dup
	extract 16 0
	bytec 0 // 0x
	b==
	assert
	extract 0 16
	frame_bury 0 // truncatedAddress: byte[16]

	// contracts/metaMerkles/meta_merkles.algo.ts:120
	// rootKey: RootKey = {
	//       address: this.txn.sender,
	//       name: name
	//     }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 6 //  initial head offset
	txn Sender
	callsub *process_static_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // rootKey: RootKey

	// contracts/metaMerkles/meta_merkles.algo.ts:125
	// schemaKey: DataKey = {
	//       address: truncatedAddress,
	//       name: name,
	//       key: treeSchemaKey
	//     }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 2 //  initial head offset
	frame_dig 0 // truncatedAddress: byte[16]
	callsub *process_static_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	bytec 3 // "l.schema"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 2 // schemaKey: DataKey

	// contracts/metaMerkles/meta_merkles.algo.ts:131
	// typeKey: DataKey = {
	//       address: truncatedAddress,
	//       name: name,
	//       key: treeTypeKey
	//     }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 2 //  initial head offset
	frame_dig 0 // truncatedAddress: byte[16]
	callsub *process_static_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	bytec 4 // "l.type"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 3 // typeKey: DataKey

	// contracts/metaMerkles/meta_merkles.algo.ts:137
	// assert(!this.roots(rootKey).exists, errs.NAME_TAKEN)
	frame_dig 1 // rootKey: RootKey
	box_len
	swap
	pop
	!
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:138
	// assert(!this.data(schemaKey).exists, errs.TREE_SCHEMA_KEY_ALREADY_EXISTS)
	bytec 1 //  "d"
	frame_dig 2 // schemaKey: DataKey
	concat
	box_len
	swap
	pop
	!
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:139
	// assert(!this.data(typeKey).exists, errs.TREE_TYPE_KEY_ALREADY_EXISTS)
	bytec 1 //  "d"
	frame_dig 3 // typeKey: DataKey
	concat
	box_len
	swap
	pop
	!
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:141
	// verifyPayTxn(pmt, {
	//       receiver: this.app.address,
	//       amount: this.rootCosts(name),
	//     })
	// verify receiver
	frame_dig -1 // pmt: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"pmt","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // pmt: PayTxn
	gtxns Amount
	frame_dig -2 // name: string
	callsub rootCosts
	==

	// transaction verification failed: {"txn":"pmt","field":"amount","expected":"this.rootCosts(name)"}
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:146
	// this.roots(rootKey).value = root
	frame_dig 1 // rootKey: RootKey
	frame_dig -3 // root: bytes32
	box_put

	// contracts/metaMerkles/meta_merkles.algo.ts:147
	// this.data(schemaKey).value = itob(schema)
	bytec 1 //  "d"
	frame_dig 2 // schemaKey: DataKey
	concat
	dup
	box_del
	pop
	frame_dig -4 // schema: uint64
	itob
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/metaMerkles/meta_merkles.algo.ts:148
	// this.data(typeKey).value = itob(type)
	bytec 1 //  "d"
	frame_dig 3 // typeKey: DataKey
	concat
	dup
	box_del
	pop
	frame_dig -5 // type: uint64
	itob
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put
	retsub

// deleteRoot(string)void
*abi_route_deleteRoot:
	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute deleteRoot(string)void
	callsub deleteRoot
	intc 0 // 1
	return

// deleteRoot(name: string): void
//
// Deletes the merkle root from the root box map
//
// @param name the name of the merkle tree root
deleteRoot:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts/metaMerkles/meta_merkles.algo.ts:157
	// truncatedAddress = extract3(this.txn.sender, 0, 16) as bytes16
	txn Sender
	extract 0 16
	bytec 5 // 0x00000000000000000000000000000000
	concat
	dup
	extract 16 0
	bytec 0 // 0x
	b==
	assert
	extract 0 16
	frame_bury 0 // truncatedAddress: byte[16]

	// contracts/metaMerkles/meta_merkles.algo.ts:159
	// rootKey: RootKey = {
	//       address: this.txn.sender,
	//       name: name
	//     }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 6 //  initial head offset
	txn Sender
	callsub *process_static_tuple_element
	frame_dig -1 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // rootKey: RootKey

	// contracts/metaMerkles/meta_merkles.algo.ts:164
	// schemaKey: DataKey = {
	//       address: truncatedAddress,
	//       name: name,
	//       key: treeSchemaKey
	//     }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 2 //  initial head offset
	frame_dig 0 // truncatedAddress: byte[16]
	callsub *process_static_tuple_element
	frame_dig -1 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	bytec 3 // "l.schema"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 2 // schemaKey: DataKey

	// contracts/metaMerkles/meta_merkles.algo.ts:170
	// typeKey: DataKey = {
	//       address: truncatedAddress,
	//       name: name,
	//       key: treeTypeKey
	//     }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 2 //  initial head offset
	frame_dig 0 // truncatedAddress: byte[16]
	callsub *process_static_tuple_element
	frame_dig -1 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	bytec 4 // "l.type"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 3 // typeKey: DataKey

	// contracts/metaMerkles/meta_merkles.algo.ts:176
	// assert(this.roots(rootKey).exists, errs.NO_NAME)
	frame_dig 1 // rootKey: RootKey
	box_len
	swap
	pop
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:178
	// this.roots(rootKey).delete()
	frame_dig 1 // rootKey: RootKey
	box_del

	// contracts/metaMerkles/meta_merkles.algo.ts:179
	// this.data(schemaKey).delete()
	bytec 1 //  "d"
	frame_dig 2 // schemaKey: DataKey
	concat
	box_del

	// contracts/metaMerkles/meta_merkles.algo.ts:180
	// this.data(typeKey).delete()
	bytec 1 //  "d"
	frame_dig 3 // typeKey: DataKey
	concat
	box_del

	// contracts/metaMerkles/meta_merkles.algo.ts:183
	// sendPayment({
	//       receiver: this.txn.sender,
	//       amount: this.rootCosts(name),
	//       fee: 0,
	//     })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts/metaMerkles/meta_merkles.algo.ts:184
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/metaMerkles/meta_merkles.algo.ts:185
	// amount: this.rootCosts(name)
	frame_dig -1 // name: string
	callsub rootCosts
	itxn_field Amount

	// contracts/metaMerkles/meta_merkles.algo.ts:186
	// fee: 0
	intc 2 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// updateRoot(string,byte[32])void
*abi_route_updateRoot:
	// newRoot: byte[32]
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 32
	==

	// argument 0 (newRoot) for updateRoot must be a byte[32]
	assert

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute updateRoot(string,byte[32])void
	callsub updateRoot
	intc 0 // 1
	return

// updateRoot(name: string, newRoot: bytes32): void
//
// Replaces the merkle root with another
//
// @param name the name of the merkle group data
// @param newRoot the new 32 byte merkle tree root
updateRoot:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/metaMerkles/meta_merkles.algo.ts:197
	// key: RootKey = { address: this.txn.sender, name: name }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 6 //  initial head offset
	txn Sender
	callsub *process_static_tuple_element
	frame_dig -1 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 0 // key: RootKey

	// contracts/metaMerkles/meta_merkles.algo.ts:198
	// assert(this.roots(key).exists, errs.NO_NAME)
	frame_dig 0 // key: RootKey
	box_len
	swap
	pop
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:199
	// this.roots(key).value = newRoot
	frame_dig 0 // key: RootKey
	frame_dig -2 // newRoot: bytes32
	box_put
	retsub

// addData(pay,string,string,string)void
*abi_route_addData:
	// value: string
	txna ApplicationArgs 3
	extract 2 0

	// key: string
	txna ApplicationArgs 2
	extract 2 0

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// pmt: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 3 (pmt) for addData must be a pay transaction
	assert

	// execute addData(pay,string,string,string)void
	callsub addData
	intc 0 // 1
	return

// addData(pmt: PayTxn, name: string, key: string, value: string): void
//
// Registers a key & value in the data box map that
// corresponds to a merkle root in the root box map
//
// @param pmt the payment to cover the increased mbr of adding to box storage
// @param name the name of the merkle tree root
// @param key the metadata key eg. `Royalty`
// @param value the metadata value eg. `5` encoded as a bytestring for 5%
addData:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/metaMerkles/meta_merkles.algo.ts:212
	// rootKey: RootKey = { address: this.txn.sender, name: name }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 6 //  initial head offset
	txn Sender
	callsub *process_static_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 0 // rootKey: RootKey

	// contracts/metaMerkles/meta_merkles.algo.ts:214
	// assert(key.length <= maxDataKeyLength, errs.KEY_TOO_LONG)
	frame_dig -3 // key: string
	len
	pushint 15
	<=
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:215
	// assert(value.length <= maxDataLength, errs.DATA_TOO_LONG)
	frame_dig -4 // value: string
	len
	intc 3 // 1024
	<=
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:216
	// assert(key.length < 2 || !(extract3(key, 0, 2) === reservedDataKeyPrefix), errs.RESERVED_KEY_PREFIX)
	frame_dig -3 // key: string
	len
	pushint 2
	<
	dup
	bnz *skip_or0
	frame_dig -3 // key: string
	extract 0 2
	pushbytes "l."
	==
	!
	||

*skip_or0:
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:217
	// assert(this.roots(rootKey).exists, errs.NO_ROOT_FOR_DATA)
	frame_dig 0 // rootKey: RootKey
	box_len
	swap
	pop
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:219
	// verifyPayTxn(pmt, {
	//       receiver: this.app.address,
	//       amount: this.getBoxCreateMinBalance(48 + key.length, value.length),
	//     })
	// verify receiver
	frame_dig -1 // pmt: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"pmt","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // pmt: PayTxn
	gtxns Amount
	frame_dig -4 // value: string
	len
	pushint 48
	frame_dig -3 // key: string
	len
	+
	callsub getBoxCreateMinBalance
	==

	// transaction verification failed: {"txn":"pmt","field":"amount","expected":"this.getBoxCreateMinBalance(48 + key.length, value.length)"}
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:224
	// dataKey: DataKey = {
	//       address: extract3(this.txn.sender, 0, 16) as bytes16,
	//       name: name,
	//       key: key,
	//     }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 2 //  initial head offset
	txn Sender
	extract 0 16
	bytec 5 // 0x00000000000000000000000000000000
	concat
	dup
	extract 16 0
	bytec 0 // 0x
	b==
	assert
	extract 0 16
	callsub *process_static_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -3 // key: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // dataKey: DataKey

	// contracts/metaMerkles/meta_merkles.algo.ts:230
	// this.data(dataKey).value = value
	bytec 1 //  "d"
	frame_dig 1 // dataKey: DataKey
	concat
	dup
	box_del
	pop
	frame_dig -4 // value: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put
	retsub

// deleteData(string,string)void
*abi_route_deleteData:
	// key: string
	txna ApplicationArgs 2
	extract 2 0

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute deleteData(string,string)void
	callsub deleteData
	intc 0 // 1
	return

// deleteData(name: string, key: string): void
//
// Deletes a metadata key & value pair from the data box map
//
// @param name the name of the merkle tree root
// @param key the metadata key you want to remove
deleteData:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/metaMerkles/meta_merkles.algo.ts:240
	// dataKey: DataKey = {
	//       address: extract3(this.txn.sender, 0, 16) as bytes16,
	//       name: name,
	//       key: key,
	//     }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 2 //  initial head offset
	txn Sender
	extract 0 16
	bytec 5 // 0x00000000000000000000000000000000
	concat
	dup
	extract 16 0
	bytec 0 // 0x
	b==
	assert
	extract 0 16
	callsub *process_static_tuple_element
	frame_dig -1 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -2 // key: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 0 // dataKey: DataKey

	// contracts/metaMerkles/meta_merkles.algo.ts:246
	// assert(this.data(dataKey).exists, errs.NO_DATA)
	bytec 1 //  "d"
	frame_dig 0 // dataKey: DataKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:248
	// valueLength = this.data(dataKey).value.length
	bytec 1 //  "d"
	frame_dig 0 // dataKey: DataKey
	concat
	box_get

	// box value does not exist: this.data(dataKey).value
	assert
	extract 2 0
	len
	frame_bury 1 // valueLength: uint64

	// contracts/metaMerkles/meta_merkles.algo.ts:250
	// this.data(dataKey).delete()
	bytec 1 //  "d"
	frame_dig 0 // dataKey: DataKey
	concat
	box_del

	// contracts/metaMerkles/meta_merkles.algo.ts:252
	// sendPayment({
	//       receiver: this.txn.sender,
	//       amount: this.getBoxCreateMinBalance(32 + key.length, valueLength),
	//       fee: 0,
	//     })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts/metaMerkles/meta_merkles.algo.ts:253
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/metaMerkles/meta_merkles.algo.ts:254
	// amount: this.getBoxCreateMinBalance(32 + key.length, valueLength)
	frame_dig 1 // valueLength: uint64
	intc 1 // 32
	frame_dig -2 // key: string
	len
	+
	callsub getBoxCreateMinBalance
	itxn_field Amount

	// contracts/metaMerkles/meta_merkles.algo.ts:255
	// fee: 0
	intc 2 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// verify(address,string,byte[32],byte[32][],uint64)bool
*abi_route_verify:
	// The ABI return prefix
	bytec 8 // 0x151f7c75

	// type: uint64
	txna ApplicationArgs 5
	btoi

	// proof: byte[32][]
	txna ApplicationArgs 4
	extract 2 0

	// leaf: byte[32]
	txna ApplicationArgs 3
	dup
	len
	intc 1 // 32
	==

	// argument 2 (leaf) for verify must be a byte[32]
	assert

	// name: string
	txna ApplicationArgs 2
	extract 2 0

	// address: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 4 (address) for verify must be a address
	assert

	// execute verify(address,string,byte[32],byte[32][],uint64)bool
	callsub verify
	pushbytes 0x00
	intc 2 // 0
	uncover 2
	setbit
	concat
	log
	intc 0 // 1
	return

// verify(address: Address, name: string, leaf: bytes32, proof: bytes32[], type: uint64): boolean
//
// verify an inclusion in a double sha256 based merkle tree
//
// @param address the address of the merkle tree root creator
// @param name The name alias of the root
// @param leaf The hashed leaf to verify
// @param proof The merkle proof
// @param type The type check for the lists purpose
//
// @returns a boolean indicating whether the proof is valid
verify:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// contracts/metaMerkles/meta_merkles.algo.ts:271
	// truncatedAddress = extract3(address, 0, 16) as bytes16
	frame_dig -1 // address: Address
	extract 0 16
	bytec 5 // 0x00000000000000000000000000000000
	concat
	dup
	extract 16 0
	bytec 0 // 0x
	b==
	assert
	extract 0 16
	frame_bury 0 // truncatedAddress: byte[16]

	// contracts/metaMerkles/meta_merkles.algo.ts:273
	// rootKey: RootKey = {
	//       address: this.txn.sender,
	//       name: name
	//     }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 6 //  initial head offset
	txn Sender
	callsub *process_static_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // rootKey: RootKey

	// contracts/metaMerkles/meta_merkles.algo.ts:278
	// schemaKey: DataKey = {
	//       address: truncatedAddress,
	//       name: name,
	//       key: treeSchemaKey
	//     }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 2 //  initial head offset
	frame_dig 0 // truncatedAddress: byte[16]
	callsub *process_static_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	bytec 3 // "l.schema"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 2 // schemaKey: DataKey

	// contracts/metaMerkles/meta_merkles.algo.ts:284
	// typeKey: DataKey = {
	//       address: truncatedAddress,
	//       name: name,
	//       key: treeTypeKey
	//     }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 2 //  initial head offset
	frame_dig 0 // truncatedAddress: byte[16]
	callsub *process_static_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	bytec 4 // "l.type"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 3 // typeKey: DataKey

	// contracts/metaMerkles/meta_merkles.algo.ts:290
	// assert(this.roots(rootKey).exists, errs.NO_NAME)
	frame_dig 1 // rootKey: RootKey
	box_len
	swap
	pop
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:291
	// assert(this.data(schemaKey).exists, errs.NO_TREE_SCHEMA)
	bytec 1 //  "d"
	frame_dig 2 // schemaKey: DataKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:292
	// assert(this.data(typeKey).exists, errs.NO_TREE_TYPE)
	bytec 1 //  "d"
	frame_dig 3 // typeKey: DataKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:294
	// assert(btoi(this.data(typeKey).value) === type, errs.TYPE_MISMATCH)
	bytec 1 //  "d"
	frame_dig 3 // typeKey: DataKey
	concat
	box_get

	// box value does not exist: this.data(typeKey).value
	assert
	extract 2 0
	btoi
	frame_dig -5 // type: uint64
	==
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:297
	// for (let i = 0; i < proof.length; i += 1)
	intc 2 // 0
	frame_bury 4 // i: uint64

*for_0:
	// contracts/metaMerkles/meta_merkles.algo.ts:297
	// i < proof.length
	frame_dig 4 // i: uint64
	frame_dig -4 // proof: bytes32[]
	len
	intc 1 // 32
	/
	<
	bz *for_0_end

	// *if0_condition
	// contracts/metaMerkles/meta_merkles.algo.ts:298
	// globals.opcodeBudget < 50
	global OpcodeBudget
	pushint 50
	<
	bz *if0_end

	// *if0_consequent
	// contracts/metaMerkles/meta_merkles.algo.ts:299
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 2 // 0
	itxn_field Fee
	bytec 11 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	pushint 5 // DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if0_end:
	// contracts/metaMerkles/meta_merkles.algo.ts:302
	// hash = this.hash(proof[i], hash)
	frame_dig -3 // leaf: bytes32
	frame_dig -4 // proof: bytes32[]
	store 255 // full array
	intc 2 //  initial offset
	frame_dig 4 // i: uint64
	intc 1 // 32
	* // acc * typeLength
	+
	load 255 // full array
	swap
	intc 1 // 32
	extract3
	callsub hash
	frame_bury -3 // hash: bytes32

*for_0_continue:
	// contracts/metaMerkles/meta_merkles.algo.ts:297
	// i += 1
	frame_dig 4 // i: uint64
	intc 0 // 1
	+
	frame_bury 4 // i: uint64
	b *for_0

*for_0_end:
	// contracts/metaMerkles/meta_merkles.algo.ts:305
	// return hash === this.roots(rootKey).value;
	frame_dig -3 // leaf: bytes32
	frame_dig 1 // rootKey: RootKey
	box_get

	// box value does not exist: this.roots(rootKey).value
	assert
	==

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// read(address,string,string)string
*abi_route_read:
	// The ABI return prefix
	bytec 8 // 0x151f7c75

	// key: string
	txna ApplicationArgs 3
	extract 2 0

	// name: string
	txna ApplicationArgs 2
	extract 2 0

	// address: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 2 (address) for read must be a address
	assert

	// execute read(address,string,string)string
	callsub read
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// read(address: Address, name: string, key: string): string
//
// Fetch a metadata properties
//
// @param address the address of the merkle tree root creator
// @param name the name of the merkle tree root
// @param key the metadata key eg. `Royalty`
// @returns the value set eg. `5` encoded as a bytestring for 5%
read:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/metaMerkles/meta_merkles.algo.ts:318
	// truncatedAddress = extract3(address, 0, 16) as bytes16
	frame_dig -1 // address: Address
	extract 0 16
	bytec 5 // 0x00000000000000000000000000000000
	concat
	dup
	extract 16 0
	bytec 0 // 0x
	b==
	assert
	extract 0 16
	frame_bury 0 // truncatedAddress: byte[16]

	// contracts/metaMerkles/meta_merkles.algo.ts:319
	// return this.data({ address: truncatedAddress, name: name, key: key }).value
	bytec 1 //  "d"
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 2 //  initial head offset
	frame_dig 0 // truncatedAddress: byte[16]
	callsub *process_static_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -3 // key: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	box_get

	// box value does not exist: this.data({ address: truncatedAddress, name: name, key: key }).value
	assert
	extract 2 0

	// set the subroutine return value
	frame_bury 0
	retsub

// verifiedRead(address,string,byte[32],byte[32][],uint64,string)string
*abi_route_verifiedRead:
	// The ABI return prefix
	bytec 8 // 0x151f7c75

	// key: string
	txna ApplicationArgs 6
	extract 2 0

	// type: uint64
	txna ApplicationArgs 5
	btoi

	// proof: byte[32][]
	txna ApplicationArgs 4
	extract 2 0

	// leaf: byte[32]
	txna ApplicationArgs 3
	dup
	len
	intc 1 // 32
	==

	// argument 3 (leaf) for verifiedRead must be a byte[32]
	assert

	// name: string
	txna ApplicationArgs 2
	extract 2 0

	// address: address
	txna ApplicationArgs 1
	dup
	len
	intc 1 // 32
	==

	// argument 5 (address) for verifiedRead must be a address
	assert

	// execute verifiedRead(address,string,byte[32],byte[32][],uint64,string)string
	callsub verifiedRead
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// verifiedRead(address: Address, name: string, leaf: bytes32, proof: bytes32[], type: uint64, key: string): string
//
// Read metadata from box storage and verify the data provided is included
// in the merkle tree given a sha256'd 32 byte merkle tree root & a proof
// thats pre-computed off chain.
//
// verify an inclusion in a merkle tree
// & read an associated key value pair
// & check against the underlying data's schema
// & check against the underlying data's list type or purpose
//
// @param address the address of the merkle tree root creator
// @param name the name of the root
// @param leaf the leaf node to be verified
// @param proof the proof the hash is included
// @param key the metadata key eg. `Royalty`
// @param type the list type that helps contracts ensure
// the lists purpose isn't being misused ( 0 if the caller doesnt care )
// @returns a string of metadata
verifiedRead:
	proto 6 1

	// contracts/metaMerkles/meta_merkles.algo.ts:349
	// assert(this.verify(address, name, leaf, proof, type), errs.FAILED_TO_VERIFY_INCLUSION)
	frame_dig -5 // type: uint64
	frame_dig -4 // proof: bytes32[]
	frame_dig -3 // leaf: bytes32
	frame_dig -2 // name: string
	frame_dig -1 // address: Address
	callsub verify
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:350
	// return this.read(address, name, key);
	frame_dig -6 // key: string
	frame_dig -2 // name: string
	frame_dig -1 // address: Address
	callsub read
	retsub

// addType(pay,string)void
*abi_route_addType:
	// desc: string
	txna ApplicationArgs 1
	extract 2 0

	// pmt: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 1 (pmt) for addType must be a pay transaction
	assert

	// execute addType(pay,string)void
	callsub addType
	intc 0 // 1
	return

// addType(pmt: PayTxn, desc: string): void
addType:
	proto 2 0

	// contracts/metaMerkles/meta_merkles.algo.ts:354
	// verifyPayTxn(pmt, {
	//       receiver: this.app.address,
	//       amount: 100_000_000,
	//     })
	// verify receiver
	frame_dig -1 // pmt: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"pmt","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // pmt: PayTxn
	gtxns Amount
	intc 4 // 100_000_000
	==

	// transaction verification failed: {"txn":"pmt","field":"amount","expected":"100_000_000"}
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:359
	// assert(desc.length <= 1024, errs.DATA_TOO_LONG)
	frame_dig -2 // desc: string
	len
	intc 3 // 1024
	<=
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:361
	// this.types(this.typesIndex.value).value = desc
	bytec 7 //  "t"
	dup
	app_global_get
	itob
	concat
	dup
	box_del
	pop
	frame_dig -2 // desc: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/metaMerkles/meta_merkles.algo.ts:362
	// this.typesIndex.value = (this.typesIndex.value + 1)
	bytec 7 //  "t"
	dup
	app_global_get
	intc 0 // 1
	+
	app_global_put
	retsub

// addSchema(pay,string)void
*abi_route_addSchema:
	// desc: string
	txna ApplicationArgs 1
	extract 2 0

	// pmt: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 1 (pmt) for addSchema must be a pay transaction
	assert

	// execute addSchema(pay,string)void
	callsub addSchema
	intc 0 // 1
	return

// addSchema(pmt: PayTxn, desc: string): void
addSchema:
	proto 2 0

	// contracts/metaMerkles/meta_merkles.algo.ts:366
	// verifyPayTxn(pmt, {
	//       receiver: this.app.address,
	//       amount: 100_000_000,
	//     })
	// verify receiver
	frame_dig -1 // pmt: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"pmt","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // pmt: PayTxn
	gtxns Amount
	intc 4 // 100_000_000
	==

	// transaction verification failed: {"txn":"pmt","field":"amount","expected":"100_000_000"}
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:371
	// assert(desc.length <= 1024, errs.DATA_TOO_LONG)
	frame_dig -2 // desc: string
	len
	intc 3 // 1024
	<=
	assert

	// contracts/metaMerkles/meta_merkles.algo.ts:373
	// this.schemas(this.schemaIndex.value).value = desc
	bytec 9 //  "s"
	app_global_get
	itob
	dup
	box_del
	pop
	frame_dig -2 // desc: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/metaMerkles/meta_merkles.algo.ts:374
	// this.schemaIndex.value = (this.schemaIndex.value + 1)
	bytec 9 //  "s"
	dup
	app_global_get
	intc 0 // 1
	+
	app_global_put
	retsub

// hash(a: bytes32, b: bytes32): bytes32
hash:
	proto 2 1

	// *if1_condition
	// contracts/metaMerkles/meta_merkles.algo.ts:378
	// btobigint(a) > btobigint(b)
	frame_dig -1 // a: bytes32
	frame_dig -2 // b: bytes32
	b>
	bz *if1_else

	// *if1_consequent
	// contracts/metaMerkles/meta_merkles.algo.ts:379
	// return sha256(b + a)
	frame_dig -2 // b: bytes32
	frame_dig -1 // a: bytes32
	concat
	sha256
	retsub
	b *if1_end

*if1_else:
	// contracts/metaMerkles/meta_merkles.algo.ts:381
	// return sha256(a + b);
	frame_dig -1 // a: bytes32
	frame_dig -2 // b: bytes32
	concat
	sha256
	retsub

*if1_end:
	retsub

// getBoxCreateMinBalance(a: uint64, b: uint64): uint64
getBoxCreateMinBalance:
	proto 2 1

	// contracts/metaMerkles/meta_merkles.algo.ts:386
	// return 2_500 + (400 * (a + b))
	pushint 2_500
	pushint 400
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	+
	*
	+
	retsub

*abi_route_createApplication:
	intc 0 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x64ccf1d3 // method "addRoot(pay,string,byte[32],uint64,uint64)void"
	pushbytes 0xdf287a7d // method "deleteRoot(string)void"
	pushbytes 0xc6d3d704 // method "updateRoot(string,byte[32])void"
	pushbytes 0x42fc7202 // method "addData(pay,string,string,string)void"
	pushbytes 0x06d38904 // method "deleteData(string,string)void"
	pushbytes 0x2bf3cc5a // method "verify(address,string,byte[32],byte[32][],uint64)bool"
	pushbytes 0x50c36e41 // method "read(address,string,string)string"
	pushbytes 0x0cf1b9cf // method "verifiedRead(address,string,byte[32],byte[32][],uint64,string)string"
	pushbytes 0x51067bbc // method "addType(pay,string)void"
	pushbytes 0xc12e0be7 // method "addSchema(pay,string)void"
	txna ApplicationArgs 0
	match *abi_route_addRoot *abi_route_deleteRoot *abi_route_updateRoot *abi_route_addData *abi_route_deleteData *abi_route_verify *abi_route_read *abi_route_verifiedRead *abi_route_addType *abi_route_addSchema

	// this contract does not implement the given ABI method for call NoOp
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub