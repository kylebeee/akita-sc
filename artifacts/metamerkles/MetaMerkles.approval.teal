#pragma version 10

// This TEAL was generated by TEALScript v0.103.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createRoot(pmt: PayTxn, name: string, root: bytes32, treeSchema: uint64, treeType: uint64): void
createRoot:
	proto 5 0
	retsub

// addRoot(pay,string,byte[32],uint64,uint64)void
*abi_route_addRoot:
	// type: uint64
	txna ApplicationArgs 4
	btoi

	// schema: uint64
	txna ApplicationArgs 3
	btoi

	// root: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 2 (root) for addRoot must be a byte[32]
	assert

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// pmt: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 4 (pmt) for addRoot must be a pay transaction
	assert

	// execute addRoot(pay,string,byte[32],uint64,uint64)void
	callsub addRoot
	int 1
	return

// addRoot(pmt: PayTxn, name: string, root: bytes32, schema: uint64, type: uint64): void
//
// Creates two boxes and adds a merkle root
// using a `RootKey` to the root box map and also a list type to the
// metadata attached to the root in the data box map
//
// @param pmt the fee to cover box storage allocation
// @param name the name alias of the root being added
// @param root a merkle tree root
// @param schema an index of the schema enum from box storage
// @param type an index of the tree type enum from box storage
addRoot:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// contracts/metamerkles/metamerkles.algo.ts:100
	// assert(name.length <= 32, 'Cannot add root with name longer than 32 bytes')
	frame_dig -2 // name: string
	len
	int 32
	<=

	// Cannot add root with name longer than 32 bytes
	assert

	// contracts/metamerkles/metamerkles.algo.ts:101
	// assert(this.schemas(schema).exists, errs.NO_TREE_SCHEMA)
	frame_dig -4 // schema: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/metamerkles/metamerkles.algo.ts:102
	// assert(this.types(type).exists, errs.NO_TREE_TYPE)
	byte 0x74 // "t"
	frame_dig -5 // type: uint64
	itob
	concat
	box_len
	swap
	pop
	assert

	// contracts/metamerkles/metamerkles.algo.ts:104
	// truncatedAddress = extract3(this.txn.sender, 0, 16) as bytes16
	txn Sender
	extract 0 16
	byte 0x00000000000000000000000000000000
	concat
	dup
	extract 16 0
	byte 0x
	b==
	assert
	extract 0 16
	frame_bury 0 // truncatedAddress: byte[16]

	// contracts/metamerkles/metamerkles.algo.ts:106
	// rootKey: RootKey = {
	//       address: this.txn.sender,
	//       name: name
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0022 // initial head offset
	txn Sender
	callsub *process_static_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // rootKey: RootKey

	// contracts/metamerkles/metamerkles.algo.ts:111
	// schemaKey: DataKey = {
	//       address: truncatedAddress,
	//       name: name,
	//       key: treeSchemaKey
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0014 // initial head offset
	frame_dig 0 // truncatedAddress: byte[16]
	callsub *process_static_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	byte "l.schema"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 2 // schemaKey: DataKey

	// contracts/metamerkles/metamerkles.algo.ts:117
	// typeKey: DataKey = {
	//       address: truncatedAddress,
	//       name: name,
	//       key: treeTypeKey
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0014 // initial head offset
	frame_dig 0 // truncatedAddress: byte[16]
	callsub *process_static_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	byte "l.type"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 3 // typeKey: DataKey

	// contracts/metamerkles/metamerkles.algo.ts:123
	// assert(!this.roots(rootKey).exists, errs.NAME_TAKEN)
	frame_dig 1 // rootKey: RootKey
	box_len
	swap
	pop
	!
	assert

	// contracts/metamerkles/metamerkles.algo.ts:124
	// assert(!this.data(schemaKey).exists, errs.TREE_SCHEMA_KEY_ALREADY_EXISTS)
	byte 0x64 // "d"
	frame_dig 2 // schemaKey: DataKey
	concat
	box_len
	swap
	pop
	!
	assert

	// contracts/metamerkles/metamerkles.algo.ts:125
	// assert(!this.data(typeKey).exists, errs.TREE_TYPE_KEY_ALREADY_EXISTS)
	byte 0x64 // "d"
	frame_dig 3 // typeKey: DataKey
	concat
	box_len
	swap
	pop
	!
	assert

	// contracts/metamerkles/metamerkles.algo.ts:127
	// verifyPayTxn(pmt, {
	//       receiver: this.app.address,
	//       amount: rootMinBalance + schemaMinBalance + treeTypeMinBalance,
	//     })
	// verify receiver
	frame_dig -1 // pmt: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"pmt","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // pmt: PayTxn
	gtxns Amount
	int 70300
	==

	// transaction verification failed: {"txn":"pmt","field":"amount","expected":"rootMinBalance + schemaMinBalance + treeTypeMinBalance"}
	assert

	// contracts/metamerkles/metamerkles.algo.ts:132
	// this.roots(rootKey).value = root
	frame_dig 1 // rootKey: RootKey
	frame_dig -3 // root: bytes32
	box_put

	// contracts/metamerkles/metamerkles.algo.ts:133
	// this.data(schemaKey).value = itob(schema)
	byte 0x64 // "d"
	frame_dig 2 // schemaKey: DataKey
	concat
	dup
	box_del
	pop
	frame_dig -4 // schema: uint64
	itob
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/metamerkles/metamerkles.algo.ts:134
	// this.data(typeKey).value = itob(type)
	byte 0x64 // "d"
	frame_dig 3 // typeKey: DataKey
	concat
	dup
	box_del
	pop
	frame_dig -5 // type: uint64
	itob
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put
	retsub

// deleteRoot(string)void
*abi_route_deleteRoot:
	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute deleteRoot(string)void
	callsub deleteRoot
	int 1
	return

// deleteRoot(name: string): void
//
// Deletes the merkle root from the root box map
//
// @param root the 32 byte merkle tree root
deleteRoot:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// contracts/metamerkles/metamerkles.algo.ts:143
	// truncatedAddress = extract3(this.txn.sender, 0, 16) as bytes16
	txn Sender
	extract 0 16
	byte 0x00000000000000000000000000000000
	concat
	dup
	extract 16 0
	byte 0x
	b==
	assert
	extract 0 16
	frame_bury 0 // truncatedAddress: byte[16]

	// contracts/metamerkles/metamerkles.algo.ts:145
	// rootKey: RootKey = {
	//       address: this.txn.sender,
	//       name: name
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0022 // initial head offset
	txn Sender
	callsub *process_static_tuple_element
	frame_dig -1 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // rootKey: RootKey

	// contracts/metamerkles/metamerkles.algo.ts:150
	// schemaKey: DataKey = {
	//       address: truncatedAddress,
	//       name: name,
	//       key: treeSchemaKey
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0014 // initial head offset
	frame_dig 0 // truncatedAddress: byte[16]
	callsub *process_static_tuple_element
	frame_dig -1 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	byte "l.schema"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 2 // schemaKey: DataKey

	// contracts/metamerkles/metamerkles.algo.ts:156
	// typeKey: DataKey = {
	//       address: truncatedAddress,
	//       name: name,
	//       key: treeTypeKey
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0014 // initial head offset
	frame_dig 0 // truncatedAddress: byte[16]
	callsub *process_static_tuple_element
	frame_dig -1 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	byte "l.type"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 3 // typeKey: DataKey

	// contracts/metamerkles/metamerkles.algo.ts:162
	// assert(this.roots(rootKey).exists, errs.NO_NAME)
	frame_dig 1 // rootKey: RootKey
	box_len
	swap
	pop
	assert

	// contracts/metamerkles/metamerkles.algo.ts:164
	// this.roots(rootKey).delete()
	frame_dig 1 // rootKey: RootKey
	box_del

	// contracts/metamerkles/metamerkles.algo.ts:165
	// this.data(schemaKey).delete()
	byte 0x64 // "d"
	frame_dig 2 // schemaKey: DataKey
	concat
	box_del

	// contracts/metamerkles/metamerkles.algo.ts:166
	// this.data(typeKey).delete()
	byte 0x64 // "d"
	frame_dig 3 // typeKey: DataKey
	concat
	box_del

	// contracts/metamerkles/metamerkles.algo.ts:169
	// sendPayment({
	//       receiver: this.txn.sender,
	//       amount: rootMinBalance,
	//     })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/metamerkles/metamerkles.algo.ts:170
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/metamerkles/metamerkles.algo.ts:171
	// amount: rootMinBalance
	int 28100
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// updateRoot(string,byte[32])void
*abi_route_updateRoot:
	// newRoot: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (newRoot) for updateRoot must be a byte[32]
	assert

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute updateRoot(string,byte[32])void
	callsub updateRoot
	int 1
	return

// updateRoot(name: string, newRoot: bytes32): void
//
// Replaces the merkle root with another
//
// @param name the name of the merkle group data
// @param newRoot the new 32 byte merkle tree root
updateRoot:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/metamerkles/metamerkles.algo.ts:182
	// key: RootKey = { address: this.txn.sender, name: name }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0022 // initial head offset
	txn Sender
	callsub *process_static_tuple_element
	frame_dig -1 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 0 // key: RootKey

	// contracts/metamerkles/metamerkles.algo.ts:183
	// assert(this.roots(key).exists, errs.NO_NAME)
	frame_dig 0 // key: RootKey
	box_len
	swap
	pop
	assert

	// contracts/metamerkles/metamerkles.algo.ts:184
	// this.roots(key).value = newRoot
	frame_dig 0 // key: RootKey
	frame_dig -2 // newRoot: bytes32
	box_put
	retsub

// addData(pay,string,string,string)void
*abi_route_addData:
	// value: string
	txna ApplicationArgs 3
	extract 2 0

	// key: string
	txna ApplicationArgs 2
	extract 2 0

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// pmt: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 3 (pmt) for addData must be a pay transaction
	assert

	// execute addData(pay,string,string,string)void
	callsub addData
	int 1
	return

// addData(pmt: PayTxn, name: string, key: string, value: string): void
//
// Registers a key & value in the data box map that
// corresponds to a merkle root in the root box map
//
// @param pmt the payment to cover the increased mbr of adding to box storage
// @param root the 32 byte merkle tree root
// @param key the metadata key eg. `Royalty`
// @param value the metadata value eg. `5` encoded as a bytestring for 5%
addData:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/metamerkles/metamerkles.algo.ts:197
	// rootKey: RootKey = { address: this.txn.sender, name: name }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0022 // initial head offset
	txn Sender
	callsub *process_static_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 0 // rootKey: RootKey

	// contracts/metamerkles/metamerkles.algo.ts:199
	// assert(key.length <= maxDataKeyLength, errs.KEY_TOO_LONG)
	frame_dig -3 // key: string
	len
	int 15
	<=
	assert

	// contracts/metamerkles/metamerkles.algo.ts:200
	// assert(value.length <= maxDataLength, errs.DATA_TOO_LONG)
	frame_dig -4 // value: string
	len
	int 1024
	<=
	assert

	// contracts/metamerkles/metamerkles.algo.ts:201
	// assert(key.length < 2 || !(extract3(key, 0, 2) === reservedDataKeyPrefix), errs.RESERVED_KEY_PREFIX)
	frame_dig -3 // key: string
	len
	int 2
	<
	dup
	bnz *skip_or0
	frame_dig -3 // key: string
	extract 0 2
	byte "l."
	==
	!
	||

*skip_or0:
	assert

	// contracts/metamerkles/metamerkles.algo.ts:202
	// assert(this.roots(rootKey).exists, errs.NO_ROOT_FOR_DATA)
	frame_dig 0 // rootKey: RootKey
	box_len
	swap
	pop
	assert

	// contracts/metamerkles/metamerkles.algo.ts:204
	// verifyPayTxn(pmt, {
	//       receiver: this.app.address,
	//       amount: this.getBoxCreateMinBalance(48 + key.length, value.length),
	//     })
	// verify receiver
	frame_dig -1 // pmt: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"pmt","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // pmt: PayTxn
	gtxns Amount
	frame_dig -4 // value: string
	len
	int 48
	frame_dig -3 // key: string
	len
	+
	callsub getBoxCreateMinBalance
	==

	// transaction verification failed: {"txn":"pmt","field":"amount","expected":"this.getBoxCreateMinBalance(48 + key.length, value.length)"}
	assert

	// contracts/metamerkles/metamerkles.algo.ts:209
	// dataKey: DataKey = {
	//       address: extract3(this.txn.sender, 0, 16) as bytes16,
	//       name: name,
	//       key: key,
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0014 // initial head offset
	txn Sender
	extract 0 16
	byte 0x00000000000000000000000000000000
	concat
	dup
	extract 16 0
	byte 0x
	b==
	assert
	extract 0 16
	callsub *process_static_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -3 // key: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // dataKey: DataKey

	// contracts/metamerkles/metamerkles.algo.ts:215
	// this.data(dataKey).value = value
	byte 0x64 // "d"
	frame_dig 1 // dataKey: DataKey
	concat
	dup
	box_del
	pop
	frame_dig -4 // value: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put
	retsub

// deleteData(string,string)void
*abi_route_deleteData:
	// key: string
	txna ApplicationArgs 2
	extract 2 0

	// name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute deleteData(string,string)void
	callsub deleteData
	int 1
	return

// deleteData(name: string, key: string): void
//
// Deletes a metadata key & value pair from the data box map
//
// @param root the sha256'd 32 byte merkle tree root
// @param key the metadata key you want to remove
deleteData:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/metamerkles/metamerkles.algo.ts:225
	// dataKey: DataKey = {
	//       address: extract3(this.txn.sender, 0, 16) as bytes16,
	//       name: name,
	//       key: key,
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0014 // initial head offset
	txn Sender
	extract 0 16
	byte 0x00000000000000000000000000000000
	concat
	dup
	extract 16 0
	byte 0x
	b==
	assert
	extract 0 16
	callsub *process_static_tuple_element
	frame_dig -1 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -2 // key: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 0 // dataKey: DataKey

	// contracts/metamerkles/metamerkles.algo.ts:231
	// assert(this.data(dataKey).exists, errs.NO_DATA)
	byte 0x64 // "d"
	frame_dig 0 // dataKey: DataKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/metamerkles/metamerkles.algo.ts:233
	// valueLength = this.data(dataKey).value.length
	byte 0x64 // "d"
	frame_dig 0 // dataKey: DataKey
	concat
	box_get

	// box value does not exist: this.data(dataKey).value
	assert
	extract 2 0
	len
	frame_bury 1 // valueLength: uint64

	// contracts/metamerkles/metamerkles.algo.ts:235
	// this.data(dataKey).delete()
	byte 0x64 // "d"
	frame_dig 0 // dataKey: DataKey
	concat
	box_del

	// contracts/metamerkles/metamerkles.algo.ts:237
	// sendPayment({
	//       receiver: this.txn.sender,
	//       amount: this.getBoxCreateMinBalance(32 + key.length, valueLength),
	//       fee: 0,
	//     })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/metamerkles/metamerkles.algo.ts:238
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/metamerkles/metamerkles.algo.ts:239
	// amount: this.getBoxCreateMinBalance(32 + key.length, valueLength)
	frame_dig 1 // valueLength: uint64
	int 32
	frame_dig -2 // key: string
	len
	+
	callsub getBoxCreateMinBalance
	itxn_field Amount

	// contracts/metamerkles/metamerkles.algo.ts:240
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// verify(address,string,byte[32],byte[32][],uint64)bool
*abi_route_verify:
	// The ABI return prefix
	byte 0x151f7c75

	// type: uint64
	txna ApplicationArgs 5
	btoi

	// proof: byte[32][]
	txna ApplicationArgs 4
	extract 2 0

	// leaf: byte[32]
	txna ApplicationArgs 3
	dup
	len
	int 32
	==

	// argument 2 (leaf) for verify must be a byte[32]
	assert

	// name: string
	txna ApplicationArgs 2
	extract 2 0

	// address: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 4 (address) for verify must be a address
	assert

	// execute verify(address,string,byte[32],byte[32][],uint64)bool
	callsub verify
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// verify(address: Address, name: string, leaf: bytes32, proof: bytes32[], type: uint64): boolean
//
// verify an inclusion in a double sha256 based merkle tree
//
// @param address the address of the merkle tree root creator
// @param name The name alias of the root
// @param leaf The hashed leaf to verify
// @param proof The merkle proof
// @param type The type check for the lists purpose
//
// @returns a boolean indicating whether the proof is valid
verify:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// contracts/metamerkles/metamerkles.algo.ts:256
	// truncatedAddress = extract3(address, 0, 16) as bytes16
	frame_dig -1 // address: Address
	extract 0 16
	byte 0x00000000000000000000000000000000
	concat
	dup
	extract 16 0
	byte 0x
	b==
	assert
	extract 0 16
	frame_bury 0 // truncatedAddress: byte[16]

	// contracts/metamerkles/metamerkles.algo.ts:258
	// rootKey: RootKey = {
	//       address: this.txn.sender,
	//       name: name
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0022 // initial head offset
	txn Sender
	callsub *process_static_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // rootKey: RootKey

	// contracts/metamerkles/metamerkles.algo.ts:263
	// schemaKey: DataKey = {
	//       address: truncatedAddress,
	//       name: name,
	//       key: treeSchemaKey
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0014 // initial head offset
	frame_dig 0 // truncatedAddress: byte[16]
	callsub *process_static_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	byte "l.schema"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 2 // schemaKey: DataKey

	// contracts/metamerkles/metamerkles.algo.ts:269
	// typeKey: DataKey = {
	//       address: truncatedAddress,
	//       name: name,
	//       key: treeTypeKey
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0014 // initial head offset
	frame_dig 0 // truncatedAddress: byte[16]
	callsub *process_static_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	byte "l.type"
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 3 // typeKey: DataKey

	// contracts/metamerkles/metamerkles.algo.ts:275
	// assert(this.roots(rootKey).exists, errs.NO_NAME)
	frame_dig 1 // rootKey: RootKey
	box_len
	swap
	pop
	assert

	// contracts/metamerkles/metamerkles.algo.ts:276
	// assert(this.data(schemaKey).exists, errs.NO_TREE_SCHEMA)
	byte 0x64 // "d"
	frame_dig 2 // schemaKey: DataKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/metamerkles/metamerkles.algo.ts:277
	// assert(this.data(typeKey).exists, errs.NO_TREE_TYPE)
	byte 0x64 // "d"
	frame_dig 3 // typeKey: DataKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/metamerkles/metamerkles.algo.ts:279
	// assert(btoi(this.data(typeKey).value) === type, errs.TYPE_MISMATCH)
	byte 0x64 // "d"
	frame_dig 3 // typeKey: DataKey
	concat
	box_get

	// box value does not exist: this.data(typeKey).value
	assert
	extract 2 0
	btoi
	frame_dig -5 // type: uint64
	==
	assert

	// contracts/metamerkles/metamerkles.algo.ts:282
	// for (let i = 0; i < proof.length; i += 1)
	int 0
	frame_bury 4 // i: uint64

*for_0:
	// contracts/metamerkles/metamerkles.algo.ts:282
	// i < proof.length
	frame_dig 4 // i: uint64
	frame_dig -4 // proof: bytes32[]
	len
	int 32
	/
	<
	bz *for_0_end

	// *if0_condition
	// contracts/metamerkles/metamerkles.algo.ts:283
	// globals.opcodeBudget < 50
	global OpcodeBudget
	int 50
	<
	bz *if0_end

	// *if0_consequent
	// contracts/metamerkles/metamerkles.algo.ts:284
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if0_end:
	// contracts/metamerkles/metamerkles.algo.ts:287
	// hash = this.hash(proof[i], hash)
	frame_dig -3 // leaf: bytes32
	frame_dig -4 // proof: bytes32[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 4 // i: uint64
	int 32
	* // acc * typeLength
	+
	load 255 // full array
	swap
	int 32
	extract3
	callsub hash
	frame_bury -3 // hash: bytes32

*for_0_continue:
	// contracts/metamerkles/metamerkles.algo.ts:282
	// i += 1
	frame_dig 4 // i: uint64
	int 1
	+
	frame_bury 4 // i: uint64
	b *for_0

*for_0_end:
	// contracts/metamerkles/metamerkles.algo.ts:290
	// return hash === this.roots(rootKey).value;
	frame_dig -3 // leaf: bytes32
	frame_dig 1 // rootKey: RootKey
	box_get

	// box value does not exist: this.roots(rootKey).value
	assert
	==

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// read(address,string,string)string
*abi_route_read:
	// The ABI return prefix
	byte 0x151f7c75

	// key: string
	txna ApplicationArgs 3
	extract 2 0

	// name: string
	txna ApplicationArgs 2
	extract 2 0

	// address: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (address) for read must be a address
	assert

	// execute read(address,string,string)string
	callsub read
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// read(address: Address, name: string, key: string): string
//
// Fetch a metadata properties
//
// @param address the address of the merkle tree root creator
// @param root the 32 byte merkle tree root
// @param key the metadata key eg. `Royalty`
// @returns the value set eg. `5` encoded as a bytestring for 5%
read:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/metamerkles/metamerkles.algo.ts:303
	// truncatedAddress = extract3(address, 0, 16) as bytes16
	frame_dig -1 // address: Address
	extract 0 16
	byte 0x00000000000000000000000000000000
	concat
	dup
	extract 16 0
	byte 0x
	b==
	assert
	extract 0 16
	frame_bury 0 // truncatedAddress: byte[16]

	// contracts/metamerkles/metamerkles.algo.ts:304
	// return this.data({ address: truncatedAddress, name: name, key: key }).value
	byte 0x64 // "d"
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0014 // initial head offset
	frame_dig 0 // truncatedAddress: byte[16]
	callsub *process_static_tuple_element
	frame_dig -2 // name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -3 // key: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	box_get

	// box value does not exist: this.data({ address: truncatedAddress, name: name, key: key }).value
	assert
	extract 2 0

	// set the subroutine return value
	frame_bury 0
	retsub

// verifiedRead(address,string,byte[32],byte[32][],uint64,string)string
*abi_route_verifiedRead:
	// The ABI return prefix
	byte 0x151f7c75

	// key: string
	txna ApplicationArgs 6
	extract 2 0

	// schema: uint64
	txna ApplicationArgs 5
	btoi

	// proof: byte[32][]
	txna ApplicationArgs 4
	extract 2 0

	// leaf: byte[32]
	txna ApplicationArgs 3
	dup
	len
	int 32
	==

	// argument 3 (leaf) for verifiedRead must be a byte[32]
	assert

	// name: string
	txna ApplicationArgs 2
	extract 2 0

	// address: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 5 (address) for verifiedRead must be a address
	assert

	// execute verifiedRead(address,string,byte[32],byte[32][],uint64,string)string
	callsub verifiedRead
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// verifiedRead(address: Address, name: string, leaf: bytes32, proof: bytes32[], schema: uint64, key: string): string
//
// Read metadata from box storage and verify the data provided is included
// in the merkle tree given a sha256'd 32 byte merkle tree root & a proof
// thats pre-computed off chain.
//
// verify an inclusion in a merkle tree
// & read an associated key value pair
// & check against the underlying data's schema
// & check against the underlying data's list type or purpose
//
// @param address the address of the merkle tree root creator
// @param root the sha256'd 32 byte merkle tree root
// @param proof the proof the hash is included
// @param data the data being verified
// @param key the metadata key eg. `Royalty`
// @param schema the schema to verify the underlying data shape ( 0 if the caller doesnt care )
// @param treeType the list type that helps contracts ensure
// the lists purpose isn't being misused ( 0 if the caller doesnt care )
// @returns a string of metadata
verifiedRead:
	proto 6 1

	// contracts/metamerkles/metamerkles.algo.ts:335
	// assert(this.verify(address, name, leaf, proof, schema), errs.FAILED_TO_VERIFY_INCLUSION)
	frame_dig -5 // schema: uint64
	frame_dig -4 // proof: bytes32[]
	frame_dig -3 // leaf: bytes32
	frame_dig -2 // name: string
	frame_dig -1 // address: Address
	callsub verify
	assert

	// contracts/metamerkles/metamerkles.algo.ts:336
	// return this.read(address, name, key);
	frame_dig -6 // key: string
	frame_dig -2 // name: string
	frame_dig -1 // address: Address
	callsub read
	retsub

// addType(pay,string)void
*abi_route_addType:
	// desc: string
	txna ApplicationArgs 1
	extract 2 0

	// pmt: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 1 (pmt) for addType must be a pay transaction
	assert

	// execute addType(pay,string)void
	callsub addType
	int 1
	return

// addType(pmt: PayTxn, desc: string): void
addType:
	proto 2 0

	// contracts/metamerkles/metamerkles.algo.ts:340
	// verifyPayTxn(pmt, {
	//       receiver: this.app.address,
	//       amount: 100_000_000,
	//     })
	// verify receiver
	frame_dig -1 // pmt: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"pmt","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // pmt: PayTxn
	gtxns Amount
	int 100_000_000
	==

	// transaction verification failed: {"txn":"pmt","field":"amount","expected":"100_000_000"}
	assert

	// contracts/metamerkles/metamerkles.algo.ts:345
	// assert(desc.length <= 1024, errs.DATA_TOO_LONG)
	frame_dig -2 // desc: string
	len
	int 1024
	<=
	assert

	// contracts/metamerkles/metamerkles.algo.ts:347
	// this.types(this.typesIndex.value).value = desc
	byte 0x74 // "t"
	dup
	app_global_get
	itob
	concat
	dup
	box_del
	pop
	frame_dig -2 // desc: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/metamerkles/metamerkles.algo.ts:348
	// this.typesIndex.value = (this.typesIndex.value + 1)
	byte 0x74 // "t"
	dup
	app_global_get
	int 1
	+
	app_global_put
	retsub

// addSchema(pay,string)void
*abi_route_addSchema:
	// desc: string
	txna ApplicationArgs 1
	extract 2 0

	// pmt: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 1 (pmt) for addSchema must be a pay transaction
	assert

	// execute addSchema(pay,string)void
	callsub addSchema
	int 1
	return

// addSchema(pmt: PayTxn, desc: string): void
addSchema:
	proto 2 0

	// contracts/metamerkles/metamerkles.algo.ts:352
	// verifyPayTxn(pmt, {
	//       receiver: this.app.address,
	//       amount: 100_000_000,
	//     })
	// verify receiver
	frame_dig -1 // pmt: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"pmt","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // pmt: PayTxn
	gtxns Amount
	int 100_000_000
	==

	// transaction verification failed: {"txn":"pmt","field":"amount","expected":"100_000_000"}
	assert

	// contracts/metamerkles/metamerkles.algo.ts:357
	// assert(desc.length <= 1024, errs.DATA_TOO_LONG)
	frame_dig -2 // desc: string
	len
	int 1024
	<=
	assert

	// contracts/metamerkles/metamerkles.algo.ts:359
	// this.schemas(this.schemaIndex.value).value = desc
	byte 0x73 // "s"
	app_global_get
	itob
	dup
	box_del
	pop
	frame_dig -2 // desc: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/metamerkles/metamerkles.algo.ts:360
	// this.schemaIndex.value = (this.schemaIndex.value + 1)
	byte 0x73 // "s"
	dup
	app_global_get
	int 1
	+
	app_global_put
	retsub

// hash(a: bytes32, b: bytes32): bytes32
hash:
	proto 2 1

	// *if1_condition
	// contracts/metamerkles/metamerkles.algo.ts:364
	// btobigint(a) > btobigint(b)
	frame_dig -1 // a: bytes32
	frame_dig -2 // b: bytes32
	b>
	bz *if1_else

	// *if1_consequent
	// contracts/metamerkles/metamerkles.algo.ts:365
	// return sha256(b + a)
	frame_dig -2 // b: bytes32
	frame_dig -1 // a: bytes32
	concat
	sha256
	retsub
	b *if1_end

*if1_else:
	// contracts/metamerkles/metamerkles.algo.ts:367
	// return sha256(a + b);
	frame_dig -1 // a: bytes32
	frame_dig -2 // b: bytes32
	concat
	sha256
	retsub

*if1_end:
	retsub

// getBoxCreateMinBalance(a: uint64, b: uint64): uint64
getBoxCreateMinBalance:
	proto 2 1

	// contracts/metamerkles/metamerkles.algo.ts:372
	// return 2_500 + (400 * (a + b))
	int 2_500
	int 400
	frame_dig -1 // a: uint64
	frame_dig -2 // b: uint64
	+
	*
	+
	retsub

*abi_route_createApplication:
	int 1
	return

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "addRoot(pay,string,byte[32],uint64,uint64)void"
	method "deleteRoot(string)void"
	method "updateRoot(string,byte[32])void"
	method "addData(pay,string,string,string)void"
	method "deleteData(string,string)void"
	method "verify(address,string,byte[32],byte[32][],uint64)bool"
	method "read(address,string,string)string"
	method "verifiedRead(address,string,byte[32],byte[32][],uint64,string)string"
	method "addType(pay,string)void"
	method "addSchema(pay,string)void"
	txna ApplicationArgs 0
	match *abi_route_addRoot *abi_route_deleteRoot *abi_route_updateRoot *abi_route_addData *abi_route_deleteData *abi_route_verify *abi_route_read *abi_route_verifiedRead *abi_route_addType *abi_route_addSchema

	// this contract does not implement the given ABI method for call NoOp
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub