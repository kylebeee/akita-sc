#pragma version 10

// This TEAL was generated by TEALScript v0.103.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// register((uint64,uint64,uint64)[],byte[][])uint64
*abi_route_register:
	// The ABI return prefix
	byte 0x151f7c75

	// args: byte[][]
	txna ApplicationArgs 2

	// filters: (uint64,uint64,uint64)[]
	txna ApplicationArgs 1
	extract 2 0

	// execute register((uint64,uint64,uint64)[],byte[][])uint64
	callsub register
	itob
	concat
	log
	int 1
	return

// register(filters: GateFilter[], args: bytes[]): uint64
register:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 5

	// contracts/gates/gate.algo.ts:40
	// entries: GateFilterEntry[] = []
	byte 0x
	frame_bury 0 // entries: GateFilterEntry[]

	// contracts/gates/gate.algo.ts:41
	// lastFilterLayer: uint64 = 0
	int 0
	frame_bury 1 // lastFilterLayer: uint64

	// contracts/gates/gate.algo.ts:42
	// for (let i = 0; i < filters.length; i += 1)
	int 0
	frame_bury 2 // i: uint64

*for_0:
	// contracts/gates/gate.algo.ts:42
	// i < filters.length
	frame_dig 2 // i: uint64
	frame_dig -1 // filters: GateFilter[]
	len
	int 24
	/
	<
	bz *for_0_end

	// contracts/gates/gate.algo.ts:43
	// assert(this.appRegistry(filters[i].app).exists)
	frame_dig -1 // filters: GateFilter[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 2 // i: uint64
	int 24
	* // acc * typeLength
	+
	int 8 // headOffset
	+
	load 255 // full array
	swap
	int 8
	extract3
	btoi
	itob
	box_len
	swap
	pop
	assert

	// contracts/gates/gate.algo.ts:44
	// assert(filters[i].layer >= lastFilterLayer)
	frame_dig -1 // filters: GateFilter[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 2 // i: uint64
	int 24
	* // acc * typeLength
	+
	int 0 // headOffset
	+
	load 255 // full array
	swap
	int 8
	extract3
	btoi
	frame_dig 1 // lastFilterLayer: uint64
	>=
	assert

	// contracts/gates/gate.algo.ts:45
	// lastFilterLayer = filters[i].layer
	frame_dig -1 // filters: GateFilter[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 2 // i: uint64
	int 24
	* // acc * typeLength
	+
	int 0 // headOffset
	+
	load 255 // full array
	swap
	int 8
	extract3
	btoi
	frame_bury 1 // lastFilterLayer: uint64

	// contracts/gates/gate.algo.ts:47
	// registryEntry = sendMethodCall<typeof MockGate.prototype.register, uint64>({
	//                 applicationID: filters[i].app,
	//                 methodArgs: [ args[i] ],
	//                 fee: 0,
	//             })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "register(byte[])uint64"
	itxn_field ApplicationArgs

	// contracts/gates/gate.algo.ts:48
	// applicationID: filters[i].app
	frame_dig -1 // filters: GateFilter[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 2 // i: uint64
	int 24
	* // acc * typeLength
	+
	int 8 // headOffset
	+
	load 255 // full array
	swap
	int 8
	extract3
	btoi
	itxn_field ApplicationID

	// contracts/gates/gate.algo.ts:49
	// methodArgs: [ args[i] ]
	frame_dig -2 // args: bytes[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 2 // i: uint64
	int 2
	* // acc * 2
	+
	int 2
	+ // add two for length
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	int 2
	+ // add two for length
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs

	// contracts/gates/gate.algo.ts:50
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	btoi
	frame_bury 3 // registryEntry: uint64

	// contracts/gates/gate.algo.ts:53
	// entry: GateFilterEntry = {
	//                 layer: filters[i].layer,
	//                 app: filters[i].app,
	//                 registeryEntry: registryEntry,
	//                 operator: filters[i].operator,
	//             }
	frame_dig -1 // filters: GateFilter[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 2 // i: uint64
	int 24
	* // acc * typeLength
	+
	int 0 // headOffset
	+
	load 255 // full array
	swap
	int 8
	extract3
	btoi
	itob
	frame_dig -1 // filters: GateFilter[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 2 // i: uint64
	int 24
	* // acc * typeLength
	+
	int 8 // headOffset
	+
	load 255 // full array
	swap
	int 8
	extract3
	btoi
	itob
	concat
	frame_dig 3 // registryEntry: uint64
	itob
	concat
	frame_dig -1 // filters: GateFilter[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 2 // i: uint64
	int 24
	* // acc * typeLength
	+
	int 16 // headOffset
	+
	load 255 // full array
	swap
	int 8
	extract3
	btoi
	itob
	concat
	frame_bury 4 // entry: GateFilterEntry

	// contracts/gates/gate.algo.ts:60
	// entries.push(entry)
	frame_dig 0 // entries: GateFilterEntry[]
	frame_dig 4 // entry: GateFilterEntry
	concat
	frame_bury 0 // entries: GateFilterEntry[]

*for_0_continue:
	// contracts/gates/gate.algo.ts:42
	// i += 1
	frame_dig 2 // i: uint64
	int 1
	+
	frame_bury 2 // i: uint64
	b *for_0

*for_0_end:
	// contracts/gates/gate.algo.ts:63
	// counter = this.filterRegistryCounter.value
	byte 0x63 // "c"
	app_global_get
	frame_bury 5 // counter: uint64

	// contracts/gates/gate.algo.ts:64
	// this.filterRegistry(counter).value = entries
	byte 0x66 // "f"
	frame_dig 5 // counter: uint64
	itob
	concat
	dup
	box_del
	pop
	frame_dig 0 // entries: GateFilterEntry[]
	dup
	len
	int 32
	/
	itob
	extract 6 2
	swap
	concat
	box_put

	// contracts/gates/gate.algo.ts:65
	// this.filterRegistryCounter.value += 1
	byte 0x63 // "c"
	app_global_get
	int 1
	+
	byte 0x63 // "c"
	swap
	app_global_put

	// contracts/gates/gate.algo.ts:66
	// return counter;
	frame_dig 5 // counter: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 5
	retsub

// check(uint64,byte[][])bool
*abi_route_check:
	// The ABI return prefix
	byte 0x151f7c75

	// args: byte[][]
	txna ApplicationArgs 2

	// filterIndex: uint64
	txna ApplicationArgs 1
	btoi

	// execute check(uint64,byte[][])bool
	callsub check
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// check(filterIndex: uint64, args: bytes[]): boolean
check:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/gates/gate.algo.ts:70
	// assert(this.filterRegistry(filterIndex).exists)
	byte 0x66 // "f"
	frame_dig -1 // filterIndex: uint64
	itob
	concat
	box_len
	swap
	pop
	assert

	// contracts/gates/gate.algo.ts:71
	// filters = this.filterRegistry(filterIndex).value
	byte 0x66 // "f"
	frame_dig -1 // filterIndex: uint64
	itob
	concat
	frame_bury 0 // storage key//filters

	// contracts/gates/gate.algo.ts:72
	// return this.evaluateFilters(filters, 0, (filters.length - 1), args);
	frame_dig -2 // args: bytes[]
	frame_dig 0 // storage key//filters
	box_get

	// box value does not exist: this.filterRegistry(filterIndex).value
	assert
	extract 2 0
	len
	int 32
	/
	int 1
	-
	int 0
	frame_dig 0 // storage key//filters
	box_get

	// box value does not exist: this.filterRegistry(filterIndex).value
	assert
	extract 2 0
	callsub evaluateFilters

	// set the subroutine return value
	frame_bury 0
	retsub

// evaluateFilters(filters: GateFilterEntry[], start: uint64, end: uint64, args: bytes[]): boolean
evaluateFilters:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 5

	// *if0_condition
	// contracts/gates/gate.algo.ts:76
	// start > end
	frame_dig -2 // start: uint64
	frame_dig -3 // end: uint64
	>
	bz *if0_end

	// *if0_consequent
	// contracts/gates/gate.algo.ts:76
	// return true;
	int 1
	b *evaluateFilters*return

*if0_end:
	// contracts/gates/gate.algo.ts:78
	// result = this.evaluateFilter(filters[start], args[start])
	frame_dig -4 // args: bytes[]
	store 255 // full array
	int 0 // initial offset
	frame_dig -2 // start: uint64
	int 2
	* // acc * 2
	+
	int 2
	+ // add two for length
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	int 2
	+ // add two for length
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	frame_dig -1 // filters: GateFilterEntry[]
	store 255 // full array
	int 0 // initial offset
	frame_dig -2 // start: uint64
	int 32
	* // acc * typeLength
	+
	load 255 // full array
	swap
	int 32
	extract3
	callsub evaluateFilter
	frame_bury 0 // result: bool

	// contracts/gates/gate.algo.ts:80
	// for (let i = start; i < end; i += 1)
	frame_dig -2 // start: uint64
	frame_bury 1 // i: uint64

*for_1:
	// contracts/gates/gate.algo.ts:80
	// i < end
	frame_dig 1 // i: uint64
	frame_dig -3 // end: uint64
	<
	bz *for_1_end

	// *if1_condition
	// contracts/gates/gate.algo.ts:82
	// globals.opcodeBudget < 50
	global OpcodeBudget
	int 50
	<
	bz *if1_end

	// *if1_consequent
	// contracts/gates/gate.algo.ts:83
	// increaseOpcodeBudget()
	itxn_begin
	int appl
	itxn_field TypeEnum
	int 0
	itxn_field Fee
	byte b64 CoEB // #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	int DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if1_end:
	// contracts/gates/gate.algo.ts:86
	// currentOperator = filters[i].operator
	frame_dig -1 // filters: GateFilterEntry[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 1 // i: uint64
	int 32
	* // acc * typeLength
	+
	int 24 // headOffset
	+
	load 255 // full array
	swap
	int 8
	extract3
	btoi
	frame_bury 2 // currentOperator: uint64

	// contracts/gates/gate.algo.ts:87
	// nextResult = this.evaluateFilter(filters[i + 1], args[i + 1])
	frame_dig -4 // args: bytes[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 1 // i: uint64
	int 1
	+
	int 2
	* // acc * 2
	+
	int 2
	+ // add two for length
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	int 2
	+ // add two for length
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	frame_dig -1 // filters: GateFilterEntry[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 1 // i: uint64
	int 1
	+
	int 32
	* // acc * typeLength
	+
	load 255 // full array
	swap
	int 32
	extract3
	callsub evaluateFilter
	frame_bury 3 // nextResult: bool

	// *if2_condition
	// contracts/gates/gate.algo.ts:89
	// currentOperator === AND
	frame_dig 2 // currentOperator: uint64
	int 0
	==
	bz *if2_elseif1_condition

	// *if2_consequent
	// contracts/gates/gate.algo.ts:90
	// result = result && nextResult
	frame_dig 0 // result: bool
	dup
	bz *skip_and0
	frame_dig 3 // nextResult: bool
	&&

*skip_and0:
	frame_bury 0 // result: bool
	b *if2_end

*if2_elseif1_condition:
	// contracts/gates/gate.algo.ts:91
	// currentOperator === OR
	frame_dig 2 // currentOperator: uint64
	int 1
	==
	bz *if2_end

	// *if2_elseif1_consequent
	// contracts/gates/gate.algo.ts:92
	// result = result || nextResult
	frame_dig 0 // result: bool
	dup
	bnz *skip_or0
	frame_dig 3 // nextResult: bool
	||

*skip_or0:
	frame_bury 0 // result: bool

*if2_end:
	// *if3_condition
	// contracts/gates/gate.algo.ts:96
	// i + 1 < end && filters[i + 2].layer > filters[i + 1].layer
	frame_dig 1 // i: uint64
	int 1
	+
	frame_dig -3 // end: uint64
	<
	dup
	bz *skip_and1
	frame_dig -1 // filters: GateFilterEntry[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 1 // i: uint64
	int 2
	+
	int 32
	* // acc * typeLength
	+
	int 0 // headOffset
	+
	load 255 // full array
	swap
	int 8
	extract3
	btoi
	frame_dig -1 // filters: GateFilterEntry[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 1 // i: uint64
	int 1
	+
	int 32
	* // acc * typeLength
	+
	int 0 // headOffset
	+
	load 255 // full array
	swap
	int 8
	extract3
	btoi
	>
	&&

*skip_and1:
	bz *if3_end

	// *if3_consequent
	// contracts/gates/gate.algo.ts:97
	// nestedEnd = this.findEndOfLayer(filters, i + 2, filters[i + 2].layer)
	frame_dig -1 // filters: GateFilterEntry[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 1 // i: uint64
	int 2
	+
	int 32
	* // acc * typeLength
	+
	int 0 // headOffset
	+
	load 255 // full array
	swap
	int 8
	extract3
	btoi
	frame_dig 1 // i: uint64
	int 2
	+
	frame_dig -1 // filters: GateFilterEntry[]
	callsub findEndOfLayer
	frame_bury 4 // nestedEnd: uint64

	// contracts/gates/gate.algo.ts:98
	// nestedResult = this.evaluateFilters(filters, i + 2, nestedEnd, args)
	frame_dig -4 // args: bytes[]
	frame_dig 4 // nestedEnd: uint64
	frame_dig 1 // i: uint64
	int 2
	+
	frame_dig -1 // filters: GateFilterEntry[]
	callsub evaluateFilters
	frame_bury 5 // nestedResult: bool

	// *if4_condition
	// contracts/gates/gate.algo.ts:100
	// currentOperator === AND
	frame_dig 2 // currentOperator: uint64
	int 0
	==
	bz *if4_elseif1_condition

	// *if4_consequent
	// contracts/gates/gate.algo.ts:101
	// result = result && nestedResult
	frame_dig 0 // result: bool
	dup
	bz *skip_and2
	frame_dig 5 // nestedResult: bool
	&&

*skip_and2:
	frame_bury 0 // result: bool
	b *if4_end

*if4_elseif1_condition:
	// contracts/gates/gate.algo.ts:102
	// currentOperator === OR
	frame_dig 2 // currentOperator: uint64
	int 1
	==
	bz *if4_end

	// *if4_elseif1_consequent
	// contracts/gates/gate.algo.ts:103
	// result = result || nestedResult
	frame_dig 0 // result: bool
	dup
	bnz *skip_or1
	frame_dig 5 // nestedResult: bool
	||

*skip_or1:
	frame_bury 0 // result: bool

*if4_end:
	// contracts/gates/gate.algo.ts:106
	// i = nestedEnd
	frame_dig 4 // nestedEnd: uint64
	frame_bury 1 // i: uint64

*if3_end:

*for_1_continue:
	// contracts/gates/gate.algo.ts:80
	// i += 1
	frame_dig 1 // i: uint64
	int 1
	+
	frame_bury 1 // i: uint64
	b *for_1

*for_1_end:
	// contracts/gates/gate.algo.ts:110
	// return result;
	frame_dig 0 // result: bool

*evaluateFilters*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 5
	retsub

// evaluateFilter(filter: GateFilterEntry, args: bytes): boolean
evaluateFilter:
	proto 2 1

	// contracts/gates/gate.algo.ts:114
	// return sendMethodCall<typeof MockGate.prototype.check, boolean>({
	//             applicationID: filter.app,
	//             methodArgs: [args],
	//             fee: 0,
	//         });
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "check(byte[])bool"
	itxn_field ApplicationArgs

	// contracts/gates/gate.algo.ts:115
	// applicationID: filter.app
	frame_dig -1 // filter: GateFilterEntry
	extract 8 8
	btoi
	itxn_field ApplicationID

	// contracts/gates/gate.algo.ts:116
	// methodArgs: [args]
	frame_dig -2 // args: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs

	// contracts/gates/gate.algo.ts:117
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	int 0
	getbit
	retsub

// findEndOfLayer(filters: GateFilterEntry[], start: uint64, layer: uint64): uint64
findEndOfLayer:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/gates/gate.algo.ts:122
	// end = start
	frame_dig -2 // start: uint64
	frame_bury 0 // end: uint64

	// contracts/gates/gate.algo.ts:123
	// for (let i = start; i < filters.length; i += 1)
	frame_dig -2 // start: uint64
	frame_bury 1 // i: uint64

*for_2:
	// contracts/gates/gate.algo.ts:123
	// i < filters.length
	frame_dig 1 // i: uint64
	frame_dig -1 // filters: GateFilterEntry[]
	len
	int 32
	/
	<
	bz *for_2_end

	// *if5_condition
	// contracts/gates/gate.algo.ts:124
	// filters[i].layer < layer
	frame_dig -1 // filters: GateFilterEntry[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 1 // i: uint64
	int 32
	* // acc * typeLength
	+
	int 0 // headOffset
	+
	load 255 // full array
	swap
	int 8
	extract3
	btoi
	frame_dig -3 // layer: uint64
	<
	bz *if5_end

	// *if5_consequent
	b *for_2_end

*if5_end:
	// contracts/gates/gate.algo.ts:127
	// end = i
	frame_dig 1 // i: uint64
	frame_bury 0 // end: uint64

*for_2_continue:
	// contracts/gates/gate.algo.ts:123
	// i += 1
	frame_dig 1 // i: uint64
	int 1
	+
	frame_bury 1 // i: uint64
	b *for_2

*for_2_end:
	// contracts/gates/gate.algo.ts:129
	// return end;
	frame_dig 0 // end: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

*abi_route_createApplication:
	int 1
	return

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "register((uint64,uint64,uint64)[],byte[][])uint64"
	method "check(uint64,byte[][])bool"
	txna ApplicationArgs 0
	match *abi_route_register *abi_route_check

	// this contract does not implement the given ABI method for call NoOp
	err