#pragma version 10

// This TEAL was generated by TEALScript v0.103.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// register(byte[])uint64
*abi_route_register:
	// The ABI return prefix
	byte 0x151f7c75

	// args: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute register(byte[])uint64
	callsub register
	itob
	concat
	log
	int 1
	return

// register(args: bytes): uint64
register:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/gates/merkle.algo.ts:31
	// assert(args.length === 64, errs.WRONG_ARG_COUNT)
	frame_dig -1 // args: bytes
	len
	int 64
	==
	assert

	// contracts/gates/merkle.algo.ts:33
	// counter = this.registryCounter.value
	byte 0x63 // "c"
	app_global_get
	frame_bury 0 // counter: uint64

	// contracts/gates/merkle.algo.ts:34
	// this.registry(counter).value = {
	//             rootCreator: Address.fromBytes(extract3(args, 0, 32)),
	//             root: extract3(args, 32, 32) as bytes32,
	//             schema: extractUint64(args, 64),
	//             treeType: extractUint64(args, 72),
	//         }
	frame_dig 0 // counter: uint64
	itob
	frame_dig -1 // args: bytes
	extract 0 32
	frame_dig -1 // args: bytes
	extract 32 32
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	concat
	frame_dig -1 // args: bytes
	int 64
	extract_uint64
	itob
	concat
	frame_dig -1 // args: bytes
	int 72
	extract_uint64
	itob
	concat
	box_put

	// contracts/gates/merkle.algo.ts:40
	// this.registryCounter.value += 1
	byte 0x63 // "c"
	app_global_get
	int 1
	+
	byte 0x63 // "c"
	swap
	app_global_put

	// contracts/gates/merkle.algo.ts:41
	// return counter;
	frame_dig 0 // counter: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// check(byte[])bool
*abi_route_check:
	// The ABI return prefix
	byte 0x151f7c75

	// args: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute check(byte[])bool
	callsub check
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// check(args: bytes): boolean
check:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 5

	// contracts/gates/merkle.algo.ts:46
	// assert(args.length >= 80, errs.WRONG_ARG_COUNT)
	frame_dig -1 // args: bytes
	len
	int 80
	>=
	assert

	// contracts/gates/merkle.algo.ts:48
	// registryIndex = extractUint64(args, 0)
	frame_dig -1 // args: bytes
	int 0
	extract_uint64
	frame_bury 0 // registryIndex: uint64

	// contracts/gates/merkle.algo.ts:49
	// user = Address.fromBytes(extract3(args, 8, 32))
	frame_dig -1 // args: bytes
	extract 8 32
	frame_bury 1 // user: address

	// contracts/gates/merkle.algo.ts:50
	// asset = AssetID.fromUint64(extractUint64(args, 40))
	frame_dig -1 // args: bytes
	int 40
	extract_uint64
	frame_bury 2 // asset: uint64

	// *if0_condition
	// contracts/gates/merkle.algo.ts:52
	// !(user.assetBalance(asset) > 0)
	frame_dig 1 // user: address
	frame_dig 2 // asset: uint64
	asset_holding_get AssetBalance
	pop
	int 0
	>
	!
	bz *if0_end

	// *if0_consequent
	// contracts/gates/merkle.algo.ts:53
	// return false;
	int 0
	b *check*return

*if0_end:
	// contracts/gates/merkle.algo.ts:56
	// proof: bytes32[] = []
	byte 0x
	frame_bury 3 // proof: bytes32[]

	// contracts/gates/merkle.algo.ts:57
	// for (let i = 48; i < args.length; i += 32)
	int 48
	frame_bury 4 // i: uint64

*for_0:
	// contracts/gates/merkle.algo.ts:57
	// i < args.length
	frame_dig 4 // i: uint64
	frame_dig -1 // args: bytes
	len
	<
	bz *for_0_end

	// contracts/gates/merkle.algo.ts:58
	// proof.push(extract3(args, i, 32) as bytes32)
	frame_dig 3 // proof: bytes32[]
	frame_dig -1 // args: bytes
	frame_dig 4 // i: uint64
	int 32
	extract3
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	concat
	frame_bury 3 // proof: bytes32[]

*for_0_continue:
	// contracts/gates/merkle.algo.ts:57
	// i += 32
	frame_dig 4 // i: uint64
	int 32
	+
	frame_bury 4 // i: uint64
	b *for_0

*for_0_end:
	// contracts/gates/merkle.algo.ts:61
	// registryInfo = this.registry(registryIndex).value
	frame_dig 0 // registryIndex: uint64
	itob
	frame_bury 5 // storage key//registryInfo

	// contracts/gates/merkle.algo.ts:63
	// return sendMethodCall<typeof MetaMerkles.prototype.verify, boolean>({
	//             applicationID: AppID.fromUint64(META_MERKLE_APP_ID),
	//             methodArgs: [
	//                 registryInfo.rootCreator,
	//                 registryInfo.root,
	//                 sha256(sha256(itob(asset.id))),
	//                 proof,
	//                 registryInfo.treeType
	//             ],
	//             fee: 0,
	//         });
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "verify(address,string,byte[32],byte[32][],uint64)bool"
	itxn_field ApplicationArgs

	// contracts/gates/merkle.algo.ts:64
	// applicationID: AppID.fromUint64(META_MERKLE_APP_ID)
	int 0
	itxn_field ApplicationID

	// contracts/gates/merkle.algo.ts:65
	// methodArgs: [
	//                 registryInfo.rootCreator,
	//                 registryInfo.root,
	//                 sha256(sha256(itob(asset.id))),
	//                 proof,
	//                 registryInfo.treeType
	//             ]
	int 0
	int 32
	frame_dig 0 // registryIndex: uint64
	itob
	cover 2
	box_extract
	itxn_field ApplicationArgs
	int 32 // headOffset
	int 32
	frame_dig 0 // registryIndex: uint64
	itob
	cover 2
	box_extract
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig 2 // asset: uint64
	itob
	sha256
	sha256
	itxn_field ApplicationArgs
	frame_dig 3 // proof: bytes32[]
	dup
	len
	int 32
	/
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	int 72 // headOffset
	int 8
	frame_dig 0 // registryIndex: uint64
	itob
	cover 2
	box_extract
	btoi
	itob
	itxn_field ApplicationArgs

	// contracts/gates/merkle.algo.ts:72
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	int 0
	getbit

*check*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 5
	retsub

*abi_route_createApplication:
	int 1
	return

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "register(byte[])uint64"
	method "check(byte[])bool"
	txna ApplicationArgs 0
	match *abi_route_register *abi_route_check

	// this contract does not implement the given ABI method for call NoOp
	err