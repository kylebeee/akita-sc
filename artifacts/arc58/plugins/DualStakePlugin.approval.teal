#pragma version 10
intcblock 1 0 6 32
bytecblock 0x6170704944

// This TEAL was generated by TEALScript v0.106.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 2 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(uint64)void
*abi_route_createApplication:
	// appID: uint64
	txna ApplicationArgs 1
	btoi

	// execute createApplication(uint64)void
	callsub createApplication
	intc 0 // 1
	return

// createApplication(appID: AppID): void
createApplication:
	proto 1 0

	// contracts/arc58/plugins/dual_stake.algo.ts:10
	// this.appID.value = appID
	bytec 0 //  "appID"
	frame_dig -1 // appID: AppID
	app_global_put
	retsub

// registerOnline(uint64,bool,byte[],byte[],byte[],uint64,uint64,uint64)void
*abi_route_registerOnline:
	// keyDilution: uint64
	txna ApplicationArgs 8
	btoi

	// lastRound: uint64
	txna ApplicationArgs 7
	btoi

	// firstRound: uint64
	txna ApplicationArgs 6
	btoi

	// spKey: byte[]
	txna ApplicationArgs 5
	extract 2 0

	// votingKey: byte[]
	txna ApplicationArgs 4
	extract 2 0

	// selectionKey: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 1
	==

	// argument 6 (rekeyBack) for registerOnline must be a bool
	assert
	intc 1 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute registerOnline(uint64,bool,byte[],byte[],byte[],uint64,uint64,uint64)void
	callsub registerOnline
	intc 0 // 1
	return

// registerOnline(sender: AppID, rekeyBack: boolean, selectionKey: bytes, votingKey: bytes, spKey: bytes, firstRound: uint64, lastRound: uint64, keyDilution: uint64): void
registerOnline:
	proto 8 0

	// contracts/arc58/plugins/dual_stake.algo.ts:23
	// sendMethodCall<typeof DualStake.prototype.register_online, void>({
	//             sender: sender.address,
	//             applicationID: this.appID.value,
	//             methodArgs: [
	//                 selectionKey,
	//                 votingKey,
	//                 spKey,
	//                 firstRound,
	//                 lastRound,
	//                 keyDilution
	//             ],
	//             rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//             fee: 0,
	//         })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0x8c2dae10 // method "register_online(byte[],byte[],byte[],uint64,uint64,uint64)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:24
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/dual_stake.algo.ts:25
	// applicationID: this.appID.value
	bytec 0 //  "appID"
	app_global_get
	itxn_field ApplicationID

	// contracts/arc58/plugins/dual_stake.algo.ts:26
	// methodArgs: [
	//                 selectionKey,
	//                 votingKey,
	//                 spKey,
	//                 firstRound,
	//                 lastRound,
	//                 keyDilution
	//             ]
	frame_dig -3 // selectionKey: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -4 // votingKey: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -5 // spKey: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -6 // firstRound: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -7 // lastRound: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -8 // keyDilution: uint64
	itob
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:34
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary0_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary0_end

*ternary0_false:
	global ZeroAddress

*ternary0_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/dual_stake.algo.ts:35
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// registerOffline(uint64,bool,address)void
*abi_route_registerOffline:
	// address: address
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for registerOffline must be a address
	assert

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 1
	==

	// argument 1 (rekeyBack) for registerOffline must be a bool
	assert
	intc 1 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute registerOffline(uint64,bool,address)void
	callsub registerOffline
	intc 0 // 1
	return

// registerOffline(sender: AppID, rekeyBack: boolean, address: Address): void
registerOffline:
	proto 3 0

	// contracts/arc58/plugins/dual_stake.algo.ts:40
	// sendMethodCall<typeof DualStake.prototype.register_offline, void>({
	//             sender: sender.address,
	//             applicationID: this.appID.value,
	//             methodArgs: [ address ],
	//             rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//             fee: 0,
	//         })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0xaab562e5 // method "register_offline(address)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:41
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/dual_stake.algo.ts:42
	// applicationID: this.appID.value
	bytec 0 //  "appID"
	app_global_get
	itxn_field ApplicationID

	// contracts/arc58/plugins/dual_stake.algo.ts:43
	// methodArgs: [ address ]
	frame_dig -3 // address: Address
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:44
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary1_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary1_end

*ternary1_false:
	global ZeroAddress

*ternary1_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/dual_stake.algo.ts:45
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// initStorage(uint64,bool)void
*abi_route_initStorage:
	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 1
	==

	// argument 0 (rekeyBack) for initStorage must be a bool
	assert
	intc 1 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute initStorage(uint64,bool)void
	callsub initStorage
	intc 0 // 1
	return

// initStorage(sender: AppID, rekeyBack: boolean): void
initStorage:
	proto 2 0

	// contracts/arc58/plugins/dual_stake.algo.ts:50
	// sendMethodCall<typeof DualStake.prototype.init_storage, void>({
	//             sender: sender.address,
	//             applicationID: this.appID.value,
	//             methodArgs: [],
	//             rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//             fee: 0,
	//         })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0x07dccd59 // method "init_storage()void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:51
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/dual_stake.algo.ts:52
	// applicationID: this.appID.value
	bytec 0 //  "appID"
	app_global_get
	itxn_field ApplicationID

	// contracts/arc58/plugins/dual_stake.algo.ts:53
	// methodArgs: []
	// contracts/arc58/plugins/dual_stake.algo.ts:54
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary2_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary2_end

*ternary2_false:
	global ZeroAddress

*ternary2_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/dual_stake.algo.ts:55
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// withdrawPlatformFees(uint64,bool,uint64)void
*abi_route_withdrawPlatformFees:
	// amt: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 1
	==

	// argument 1 (rekeyBack) for withdrawPlatformFees must be a bool
	assert
	intc 1 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute withdrawPlatformFees(uint64,bool,uint64)void
	callsub withdrawPlatformFees
	intc 0 // 1
	return

// withdrawPlatformFees(sender: AppID, rekeyBack: boolean, amt: uint64): void
withdrawPlatformFees:
	proto 3 0

	// contracts/arc58/plugins/dual_stake.algo.ts:60
	// sendMethodCall<typeof DualStake.prototype.withdraw_platform_fees, void>({
	//             sender: sender.address,
	//             applicationID: this.appID.value,
	//             methodArgs: [ amt ],
	//             rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//             fee: 0,
	//         })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0x4e11b419 // method "withdraw_platform_fees(uint64)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:61
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/dual_stake.algo.ts:62
	// applicationID: this.appID.value
	bytec 0 //  "appID"
	app_global_get
	itxn_field ApplicationID

	// contracts/arc58/plugins/dual_stake.algo.ts:63
	// methodArgs: [ amt ]
	frame_dig -3 // amt: uint64
	itob
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:64
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary3_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary3_end

*ternary3_false:
	global ZeroAddress

*ternary3_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/dual_stake.algo.ts:65
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// mint(uint64,bool)void
*abi_route_mint:
	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 1
	==

	// argument 0 (rekeyBack) for mint must be a bool
	assert
	intc 1 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute mint(uint64,bool)void
	callsub mint
	intc 0 // 1
	return

// mint(sender: AppID, rekeyBack: boolean): void
mint:
	proto 2 0

	// contracts/arc58/plugins/dual_stake.algo.ts:70
	// sendMethodCall<typeof DualStake.prototype.mint, void>({
	//             sender: sender.address,
	//             applicationID: this.appID.value,
	//             methodArgs: [],
	//             rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//             fee: 0,
	//         })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0x5588dcb4 // method "mint()void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:71
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/dual_stake.algo.ts:72
	// applicationID: this.appID.value
	bytec 0 //  "appID"
	app_global_get
	itxn_field ApplicationID

	// contracts/arc58/plugins/dual_stake.algo.ts:73
	// methodArgs: []
	// contracts/arc58/plugins/dual_stake.algo.ts:74
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary4_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary4_end

*ternary4_false:
	global ZeroAddress

*ternary4_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/dual_stake.algo.ts:75
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// burn(uint64,bool)void
*abi_route_burn:
	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 1
	==

	// argument 0 (rekeyBack) for burn must be a bool
	assert
	intc 1 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute burn(uint64,bool)void
	callsub burn
	intc 0 // 1
	return

// burn(sender: AppID, rekeyBack: boolean): void
burn:
	proto 2 0

	// contracts/arc58/plugins/dual_stake.algo.ts:80
	// sendMethodCall<typeof DualStake.prototype.burn, void>({
	//             sender: sender.address,
	//             applicationID: this.appID.value,
	//             methodArgs: [],
	//             rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//             fee: 0,
	//         })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0x15eb2f81 // method "burn()void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:81
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/dual_stake.algo.ts:82
	// applicationID: this.appID.value
	bytec 0 //  "appID"
	app_global_get
	itxn_field ApplicationID

	// contracts/arc58/plugins/dual_stake.algo.ts:83
	// methodArgs: []
	// contracts/arc58/plugins/dual_stake.algo.ts:84
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary5_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary5_end

*ternary5_false:
	global ZeroAddress

*ternary5_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/dual_stake.algo.ts:85
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// nullun(uint64,bool)void
*abi_route_nullun:
	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 1
	==

	// argument 0 (rekeyBack) for nullun must be a bool
	assert
	intc 1 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute nullun(uint64,bool)void
	callsub nullun
	intc 0 // 1
	return

// nullun(sender: AppID, rekeyBack: boolean): void
nullun:
	proto 2 0

	// contracts/arc58/plugins/dual_stake.algo.ts:90
	// sendMethodCall<typeof DualStake.prototype.nullun, void>({
	//             sender: sender.address,
	//             applicationID: this.appID.value,
	//             methodArgs: [],
	//             rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//             fee: 0,
	//         })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0x7388abe1 // method "nullun()void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:91
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/dual_stake.algo.ts:92
	// applicationID: this.appID.value
	bytec 0 //  "appID"
	app_global_get
	itxn_field ApplicationID

	// contracts/arc58/plugins/dual_stake.algo.ts:93
	// methodArgs: []
	// contracts/arc58/plugins/dual_stake.algo.ts:94
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary6_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary6_end

*ternary6_false:
	global ZeroAddress

*ternary6_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/dual_stake.algo.ts:95
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// createAsset(uint64,bool,byte[],byte[])void
*abi_route_createAsset:
	// lstUnitName: byte[]
	txna ApplicationArgs 4
	extract 2 0

	// lstAsaName: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 1
	==

	// argument 2 (rekeyBack) for createAsset must be a bool
	assert
	intc 1 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute createAsset(uint64,bool,byte[],byte[])void
	callsub createAsset
	intc 0 // 1
	return

// createAsset(sender: AppID, rekeyBack: boolean, lstAsaName: bytes, lstUnitName: bytes): void
createAsset:
	proto 4 0

	// contracts/arc58/plugins/dual_stake.algo.ts:100
	// sendMethodCall<typeof DualStake.prototype.create_asset, void>({
	//             sender: sender.address,
	//             applicationID: this.appID.value,
	//             methodArgs: [ lstAsaName, lstUnitName ],
	//             rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//             fee: 0,
	//         })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0x5f860c07 // method "create_asset(byte[],byte[])void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:101
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/dual_stake.algo.ts:102
	// applicationID: this.appID.value
	bytec 0 //  "appID"
	app_global_get
	itxn_field ApplicationID

	// contracts/arc58/plugins/dual_stake.algo.ts:103
	// methodArgs: [ lstAsaName, lstUnitName ]
	frame_dig -3 // lstAsaName: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -4 // lstUnitName: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:104
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary7_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary7_end

*ternary7_false:
	global ZeroAddress

*ternary7_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/dual_stake.algo.ts:105
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// configure(uint64,bool,byte[],byte[],uint64,byte[],byte[],uint64,uint64,address,address)void
*abi_route_configure:
	// noderunnerAddr: address
	txna ApplicationArgs 11
	dup
	len
	intc 3 // 32
	==

	// argument 0 (noderunnerAddr) for configure must be a address
	assert

	// adminAddr: address
	txna ApplicationArgs 10
	dup
	len
	intc 3 // 32
	==

	// argument 1 (adminAddr) for configure must be a address
	assert

	// noderunnerFeeBps: uint64
	txna ApplicationArgs 9
	btoi

	// platformFeeBps: uint64
	txna ApplicationArgs 8
	btoi

	// lpID: byte[]
	txna ApplicationArgs 7
	extract 2 0

	// lpType: byte[]
	txna ApplicationArgs 6
	extract 2 0

	// asaID: uint64
	txna ApplicationArgs 5
	btoi

	// lstUnitName: byte[]
	txna ApplicationArgs 4
	extract 2 0

	// lstAsaName: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 1
	==

	// argument 9 (rekeyBack) for configure must be a bool
	assert
	intc 1 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute configure(uint64,bool,byte[],byte[],uint64,byte[],byte[],uint64,uint64,address,address)void
	callsub configure
	intc 0 // 1
	return

// configure(sender: AppID, rekeyBack: boolean, lstAsaName: bytes, lstUnitName: bytes, asaID: uint64, lpType: bytes, lpID: bytes, platformFeeBps: uint64, noderunnerFeeBps: uint64, adminAddr: Address, noderunnerAddr: Address): void
configure:
	proto 11 0

	// contracts/arc58/plugins/dual_stake.algo.ts:122
	// sendMethodCall<typeof DualStake.prototype.configure, void>({
	//             sender: sender.address,
	//             applicationID: this.appID.value,
	//             methodArgs: [
	//                 lstAsaName,
	//                 lstUnitName,
	//                 asaID,
	//                 lpType,
	//                 lpID,
	//                 platformFeeBps,
	//                 noderunnerFeeBps,
	//                 adminAddr,
	//                 noderunnerAddr
	//             ],
	//             rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//             fee: 0,
	//         })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0x29cabaef // method "configure(byte[],byte[],uint64,byte[],byte[],uint64,uint64,address,address)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:123
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/dual_stake.algo.ts:124
	// applicationID: this.appID.value
	bytec 0 //  "appID"
	app_global_get
	itxn_field ApplicationID

	// contracts/arc58/plugins/dual_stake.algo.ts:125
	// methodArgs: [
	//                 lstAsaName,
	//                 lstUnitName,
	//                 asaID,
	//                 lpType,
	//                 lpID,
	//                 platformFeeBps,
	//                 noderunnerFeeBps,
	//                 adminAddr,
	//                 noderunnerAddr
	//             ]
	frame_dig -3 // lstAsaName: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -4 // lstUnitName: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -5 // asaID: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -6 // lpType: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -7 // lpID: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -8 // platformFeeBps: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -9 // noderunnerFeeBps: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -10 // adminAddr: Address
	itxn_field ApplicationArgs
	frame_dig -11 // noderunnerAddr: Address
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:136
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary8_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary8_end

*ternary8_false:
	global ZeroAddress

*ternary8_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/dual_stake.algo.ts:137
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// changeAdmin1(uint64,bool,address)void
*abi_route_changeAdmin1:
	// newAdmin: address
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 32
	==

	// argument 0 (newAdmin) for changeAdmin1 must be a address
	assert

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 1
	==

	// argument 1 (rekeyBack) for changeAdmin1 must be a bool
	assert
	intc 1 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeAdmin1(uint64,bool,address)void
	callsub changeAdmin1
	intc 0 // 1
	return

// changeAdmin1(sender: AppID, rekeyBack: boolean, newAdmin: Address): void
changeAdmin1:
	proto 3 0

	// contracts/arc58/plugins/dual_stake.algo.ts:142
	// sendMethodCall<typeof DualStake.prototype.change_admin_1, void>({
	//             sender: sender.address,
	//             applicationID: this.appID.value,
	//             methodArgs: [ newAdmin ],
	//             rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//             fee: 0,
	//         })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0x8ceb725c // method "change_admin_1(address)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:143
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/dual_stake.algo.ts:144
	// applicationID: this.appID.value
	bytec 0 //  "appID"
	app_global_get
	itxn_field ApplicationID

	// contracts/arc58/plugins/dual_stake.algo.ts:145
	// methodArgs: [ newAdmin ]
	frame_dig -3 // newAdmin: Address
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:146
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary9_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary9_end

*ternary9_false:
	global ZeroAddress

*ternary9_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/dual_stake.algo.ts:147
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// changeAdmin2(uint64,bool)void
*abi_route_changeAdmin2:
	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 1
	==

	// argument 0 (rekeyBack) for changeAdmin2 must be a bool
	assert
	intc 1 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeAdmin2(uint64,bool)void
	callsub changeAdmin2
	intc 0 // 1
	return

// changeAdmin2(sender: AppID, rekeyBack: boolean): void
changeAdmin2:
	proto 2 0

	// contracts/arc58/plugins/dual_stake.algo.ts:152
	// sendMethodCall<typeof DualStake.prototype.change_admin_2, void>({
	//             sender: sender.address,
	//             applicationID: this.appID.value,
	//             methodArgs: [],
	//             rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//             fee: 0,
	//         })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0x7060fdf4 // method "change_admin_2()void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:153
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/dual_stake.algo.ts:154
	// applicationID: this.appID.value
	bytec 0 //  "appID"
	app_global_get
	itxn_field ApplicationID

	// contracts/arc58/plugins/dual_stake.algo.ts:155
	// methodArgs: []
	// contracts/arc58/plugins/dual_stake.algo.ts:156
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary10_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary10_end

*ternary10_false:
	global ZeroAddress

*ternary10_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/dual_stake.algo.ts:157
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// changeNoderunner(uint64,bool,address)void
*abi_route_changeNoderunner:
	// newNoderunner: address
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 32
	==

	// argument 0 (newNoderunner) for changeNoderunner must be a address
	assert

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 1
	==

	// argument 1 (rekeyBack) for changeNoderunner must be a bool
	assert
	intc 1 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeNoderunner(uint64,bool,address)void
	callsub changeNoderunner
	intc 0 // 1
	return

// changeNoderunner(sender: AppID, rekeyBack: boolean, newNoderunner: Address): void
changeNoderunner:
	proto 3 0

	// contracts/arc58/plugins/dual_stake.algo.ts:162
	// sendMethodCall<typeof DualStake.prototype.change_noderunner, void>({
	//             sender: sender.address,
	//             applicationID: this.appID.value,
	//             methodArgs: [ newNoderunner ],
	//             rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//             fee: 0,
	//         })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0x2c8b0679 // method "change_noderunner(address)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:163
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/dual_stake.algo.ts:164
	// applicationID: this.appID.value
	bytec 0 //  "appID"
	app_global_get
	itxn_field ApplicationID

	// contracts/arc58/plugins/dual_stake.algo.ts:165
	// methodArgs: [ newNoderunner ]
	frame_dig -3 // newNoderunner: Address
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:166
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary11_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary11_end

*ternary11_false:
	global ZeroAddress

*ternary11_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/dual_stake.algo.ts:167
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// changeFeeAddr(uint64,bool,address)void
*abi_route_changeFeeAddr:
	// newFeeAddr: address
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 32
	==

	// argument 0 (newFeeAddr) for changeFeeAddr must be a address
	assert

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 0 // 1
	==

	// argument 1 (rekeyBack) for changeFeeAddr must be a bool
	assert
	intc 1 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeFeeAddr(uint64,bool,address)void
	callsub changeFeeAddr
	intc 0 // 1
	return

// changeFeeAddr(sender: AppID, rekeyBack: boolean, newFeeAddr: Address): void
changeFeeAddr:
	proto 3 0

	// contracts/arc58/plugins/dual_stake.algo.ts:172
	// sendMethodCall<typeof DualStake.prototype.change_feeaddr, void>({
	//             sender: sender.address,
	//             applicationID: this.appID.value,
	//             methodArgs: [ newFeeAddr ],
	//             rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//             fee: 0,
	//         })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0xff645ef0 // method "change_feeaddr(address)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:173
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/dual_stake.algo.ts:174
	// applicationID: this.appID.value
	bytec 0 //  "appID"
	app_global_get
	itxn_field ApplicationID

	// contracts/arc58/plugins/dual_stake.algo.ts:175
	// methodArgs: [ newFeeAddr ]
	frame_dig -3 // newFeeAddr: Address
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/dual_stake.algo.ts:176
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary12_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary12_end

*ternary12_false:
	global ZeroAddress

*ternary12_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/dual_stake.algo.ts:177
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

*create_NoOp:
	pushbytes 0x973b616f // method "createApplication(uint64)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x6ddfc3a2 // method "registerOnline(uint64,bool,byte[],byte[],byte[],uint64,uint64,uint64)void"
	pushbytes 0x52efb372 // method "registerOffline(uint64,bool,address)void"
	pushbytes 0x3b50ca2c // method "initStorage(uint64,bool)void"
	pushbytes 0x0ad91787 // method "withdrawPlatformFees(uint64,bool,uint64)void"
	pushbytes 0xb4089e27 // method "mint(uint64,bool)void"
	pushbytes 0xa60b86cb // method "burn(uint64,bool)void"
	pushbytes 0x0275845d // method "nullun(uint64,bool)void"
	pushbytes 0x5b7aa237 // method "createAsset(uint64,bool,byte[],byte[])void"
	pushbytes 0x313f8636 // method "configure(uint64,bool,byte[],byte[],uint64,byte[],byte[],uint64,uint64,address,address)void"
	pushbytes 0x6728a686 // method "changeAdmin1(uint64,bool,address)void"
	pushbytes 0x99088800 // method "changeAdmin2(uint64,bool)void"
	pushbytes 0xba1b5d9b // method "changeNoderunner(uint64,bool,address)void"
	pushbytes 0x7f0100d1 // method "changeFeeAddr(uint64,bool,address)void"
	txna ApplicationArgs 0
	match *abi_route_registerOnline *abi_route_registerOffline *abi_route_initStorage *abi_route_withdrawPlatformFees *abi_route_mint *abi_route_burn *abi_route_nullun *abi_route_createAsset *abi_route_configure *abi_route_changeAdmin1 *abi_route_changeAdmin2 *abi_route_changeNoderunner *abi_route_changeFeeAddr

	// this contract does not implement the given ABI method for call NoOp
	err