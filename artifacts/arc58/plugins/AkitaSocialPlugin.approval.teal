#pragma version 10

// This TEAL was generated by TEALScript v0.103.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// controls(address: Address): boolean
controls:
	proto 1 1

	// contracts/arc58/plugins/akita_social.algo.ts:236
	// return address.authAddr === this.app.address;
	frame_dig -1 // address: Address
	acct_params_get AcctAuthAddr
	pop
	global CurrentApplicationAddress
	==
	retsub

// isBanned(address: Address): boolean
isBanned:
	proto 1 1

	// contracts/arc58/plugins/akita_social.algo.ts:240
	// return this.banned(address).exists && this.banned(address).value > globals.latestTimestamp;
	byte 0x62 // "b"
	frame_dig -1 // address: Address
	concat
	box_len
	swap
	pop
	dup
	bz *skip_and0
	byte 0x62 // "b"
	frame_dig -1 // address: Address
	concat
	box_get

	// box value does not exist: this.banned(address).value
	assert
	btoi
	global LatestTimestamp
	>
	&&

*skip_and0:
	retsub

// isBlocked(user: Address, blocked: Address): boolean
isBlocked:
	proto 2 1

	// contracts/arc58/plugins/akita_social.algo.ts:244
	// return this.blocks({ user: user, blocked: blocked }).exists;
	frame_dig -1 // user: Address
	frame_dig -2 // blocked: Address
	concat
	box_len
	swap
	pop
	retsub

// gate(filterIndex: uint64, args: bytes[]): boolean
gate:
	proto 2 1

	// contracts/arc58/plugins/akita_social.algo.ts:248
	// return sendMethodCall<typeof Gate.prototype.check, boolean>({
	//             applicationID: AppID.fromUint64(GATE_APP_ID),
	//             methodArgs: [
	//                 filterIndex,
	//                 args,
	//             ]
	//         })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "check(uint64,byte[][])bool"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:249
	// applicationID: AppID.fromUint64(GATE_APP_ID)
	int 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/akita_social.algo.ts:250
	// methodArgs: [
	//                 filterIndex,
	//                 args,
	//             ]
	frame_dig -1 // filterIndex: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -2 // args: bytes[]
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	int 0
	getbit
	retsub

// isSubscribed(address: Address, index: uint64): { active: boolean, index: uint64, streak: uint64 }
isSubscribed:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// contracts/arc58/plugins/akita_social.algo.ts:258
	// info = sendMethodCall<typeof SubscriptionPlugin.prototype.getSubsriptionInfo>({
	//             applicationID: AppID.fromUint64(SUBSCRIPTION_PLUGIN_APP_ID),
	//             methodArgs: [ address, index ],
	//             fee: 0,
	//         })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:259
	// applicationID: AppID.fromUint64(SUBSCRIPTION_PLUGIN_APP_ID)
	int 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/akita_social.algo.ts:260
	// methodArgs: [ address, index ]
	frame_dig -1 // address: Address
	itxn_field ApplicationArgs
	frame_dig -2 // index: uint64
	itob
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:261
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 0 // info: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])

	// contracts/arc58/plugins/akita_social.algo.ts:265
	// toAkita = info.recipient === AKITA_SUBSCRIPTION_RECEIVER_ADDRESS
	frame_dig 0 // info: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])
	store 255 // full array
	load 255 // full array
	extract 0 32

	// contracts/arc58/plugins/akita_social.algo.ts:29
	// addr('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ')
	addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
	==
	frame_bury 1 // toAkita: bool

	// contracts/arc58/plugins/akita_social.algo.ts:269
	// notDonating = info.index !== 0
	frame_dig 0 // info: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])
	store 255 // full array
	load 255 // full array
	extract 32 8
	btoi
	int 0
	!=
	frame_bury 2 // notDonating: bool

	// contracts/arc58/plugins/akita_social.algo.ts:271
	// lastWindowStart = globals.latestTimestamp - (
	//             ((globals.latestTimestamp - info.startDate) % info.interval) + info.interval
	//         )
	global LatestTimestamp
	global LatestTimestamp
	frame_dig 0 // info: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])
	store 255 // full array
	load 255 // full array
	extract 40 8
	btoi
	-
	frame_dig 0 // info: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])
	store 255 // full array
	load 255 // full array
	extract 56 8
	btoi
	%
	frame_dig 0 // info: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])
	store 255 // full array
	load 255 // full array
	extract 56 8
	btoi
	+
	-
	frame_bury 3 // lastWindowStart: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:277
	// notStale = info.lastPayment > lastWindowStart
	frame_dig 0 // info: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])
	store 255 // full array
	load 255 // full array
	extract 72 8
	btoi
	frame_dig 3 // lastWindowStart: uint64
	>
	frame_bury 4 // notStale: bool

	// contracts/arc58/plugins/akita_social.algo.ts:279
	// return { active: (toAkita && notDonating && notStale), index: info.index, streak: info.streak };
	byte 0x00
	int 0
	frame_dig 1 // toAkita: bool
	dup
	bz *skip_and1
	frame_dig 2 // notDonating: bool
	&&

*skip_and1:
	dup
	bz *skip_and2
	frame_dig 4 // notStale: bool
	&&

*skip_and2:
	setbit
	frame_dig 0 // info: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])
	store 255 // full array
	load 255 // full array
	extract 32 8
	btoi
	itob
	concat
	frame_dig 0 // info: (address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])
	store 255 // full array
	load 255 // full array
	extract 80 8
	btoi
	itob
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// isNFD(NFD: AppID): boolean
isNFD:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/arc58/plugins/akita_social.algo.ts:283
	// nfdName = NFD.globalState(NFD_NAME_KEY) as bytes
	frame_dig -1 // NFD: AppID
	byte "i.name"
	app_global_get_ex

	// global state value does not exist: NFD.globalState(NFD_NAME_KEY)
	assert
	frame_bury 0 // nfdName: byte[]

	// contracts/arc58/plugins/akita_social.algo.ts:285
	// sendAppCall({
	//             applicationID: AppID.fromUint64(NFD_REGISTRY_ID),
	//             applicationArgs: [
	//                 'is_valid_nfd_appid',
	//                 nfdName,
	//                 itob(NFD.id),
	//             ],
	//             applications: [NFD],
	//             fee: 0,
	//         })
	itxn_begin
	int appl
	itxn_field TypeEnum

	// contracts/arc58/plugins/akita_social.algo.ts:286
	// applicationID: AppID.fromUint64(NFD_REGISTRY_ID)
	int 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/akita_social.algo.ts:287
	// applicationArgs: [
	//                 'is_valid_nfd_appid',
	//                 nfdName,
	//                 itob(NFD.id),
	//             ]
	byte 0x69735f76616c69645f6e66645f6170706964 // "is_valid_nfd_appid"
	itxn_field ApplicationArgs
	frame_dig 0 // nfdName: byte[]
	itxn_field ApplicationArgs
	frame_dig -1 // NFD: AppID
	itob
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:292
	// applications: [NFD]
	frame_dig -1 // NFD: AppID
	itxn_field Applications

	// contracts/arc58/plugins/akita_social.algo.ts:293
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/arc58/plugins/akita_social.algo.ts:296
	// return btoi(this.itxn.lastLog) !== 0;
	itxn LastLog
	btoi
	int 0
	!=

	// set the subroutine return value
	frame_bury 0
	retsub

// isAkitaNFT(akitaNFT: AssetID): boolean
isAkitaNFT:
	proto 1 1

	// contracts/arc58/plugins/akita_social.algo.ts:300
	// return akitaNFT.creator === AKC_CREATOR_ADDRESS;
	frame_dig -1 // akitaNFT: AssetID
	asset_params_get AssetCreator
	pop

	// contracts/arc58/plugins/akita_social.algo.ts:26
	// addr('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ')
	addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
	==
	retsub

// userHolds(address: Address, NFT: AssetID): boolean
userHolds:
	proto 2 1

	// contracts/arc58/plugins/akita_social.algo.ts:304
	// return address.assetBalance(NFT) > 0;
	frame_dig -1 // address: Address
	frame_dig -2 // NFT: AssetID
	asset_holding_get AssetBalance
	pop
	int 0
	>
	retsub

// addressVerifiedOnNFD(address: Address, NFD: AppID): boolean
addressVerifiedOnNFD:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/arc58/plugins/akita_social.algo.ts:310
	// sendAppCall({
	//             applicationID: NFD,
	//             applicationArgs: ['read_property', 'v.caAlgo.0.as'],
	//             fee: 0,
	//         })
	itxn_begin
	int appl
	itxn_field TypeEnum

	// contracts/arc58/plugins/akita_social.algo.ts:311
	// applicationID: NFD
	frame_dig -2 // NFD: AppID
	itxn_field ApplicationID

	// contracts/arc58/plugins/akita_social.algo.ts:312
	// applicationArgs: ['read_property', 'v.caAlgo.0.as']
	byte 0x726561645f70726f7065727479 // "read_property"
	itxn_field ApplicationArgs
	byte 0x762e6361416c676f2e302e6173 // "v.caAlgo.0.as"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:313
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/arc58/plugins/akita_social.algo.ts:316
	// caAlgoData = this.itxn.lastLog
	itxn LastLog
	frame_bury 0 // caAlgoData: byte[]

	// contracts/arc58/plugins/akita_social.algo.ts:318
	// for (let i = 0; i < caAlgoData.length; i += 32)
	int 0
	frame_bury 1 // i: uint64

*for_0:
	// contracts/arc58/plugins/akita_social.algo.ts:318
	// i < caAlgoData.length
	frame_dig 1 // i: uint64
	frame_dig 0 // caAlgoData: byte[]
	len
	<
	bz *for_0_end

	// contracts/arc58/plugins/akita_social.algo.ts:319
	// addr = extract3(caAlgoData, i, 32)
	frame_dig 0 // caAlgoData: byte[]
	frame_dig 1 // i: uint64
	int 32
	extract3
	frame_bury 2 // addr: byte[]

	// *if0_condition
	// contracts/arc58/plugins/akita_social.algo.ts:320
	// addr !== rawBytes(globals.zeroAddress) && addr === rawBytes(address)
	frame_dig 2 // addr: byte[]
	global ZeroAddress
	!=
	dup
	bz *skip_and3
	frame_dig 2 // addr: byte[]
	frame_dig -1 // address: Address
	==
	&&

*skip_and3:
	bz *if0_end

	// *if0_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:321
	// return true;
	int 1
	b *addressVerifiedOnNFD*return

*if0_end:

*for_0_continue:
	// contracts/arc58/plugins/akita_social.algo.ts:318
	// i += 32
	frame_dig 1 // i: uint64
	int 32
	+
	frame_bury 1 // i: uint64
	b *for_0

*for_0_end:
	// contracts/arc58/plugins/akita_social.algo.ts:325
	// return false;
	int 0

*addressVerifiedOnNFD*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// userImpact(address: Address): uint64
userImpact:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 7

	// contracts/arc58/plugins/akita_social.algo.ts:333
	// meta = this.meta(address).value
	frame_dig -1 // address: Address
	frame_bury 0 // storage key//meta

	// contracts/arc58/plugins/akita_social.algo.ts:335
	// stakedAktaImpact = this.getStakingImpactScore(address)
	frame_dig -1 // address: Address
	callsub getStakingImpactScore
	frame_bury 1 // stakedAktaImpact: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:336
	// subscriberImpact = this.getSubscriberImpactScore(address, meta.subscriptionIndex)
	frame_dig 0 // storage key//meta
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	extract 32 8
	btoi
	frame_dig -1 // address: Address
	callsub getSubscriberImpactScore
	frame_bury 2 // subscriberImpact: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:337
	// socialImpact = this.getSocialImpactScore(address)
	frame_dig -1 // address: Address
	callsub getSocialImpactScore
	frame_bury 3 // socialImpact: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:338
	// nfdScore = this.getNFDImpactScore(address, meta.NFD)
	frame_dig 0 // storage key//meta
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	extract 40 8
	btoi
	frame_dig -1 // address: Address
	callsub getNFDImpactScore
	frame_bury 4 // nfdScore: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:339
	// heldAkitaImpact = this.getHeldAktaImpactScore(address)
	frame_dig -1 // address: Address
	callsub getHeldAktaImpactScore
	frame_bury 5 // heldAkitaImpact: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:340
	// nftImpact = this.getNFTImpactScore(address, meta.akitaNFT)
	frame_dig 0 // storage key//meta
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	extract 64 8
	btoi
	frame_dig -1 // address: Address
	callsub getNFTImpactScore
	frame_bury 6 // nftImpact: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:342
	// total = stakedAktaImpact + subscriberImpact + socialImpact + nfdScore + heldAkitaImpact + nftImpact
	frame_dig 1 // stakedAktaImpact: uint64
	frame_dig 2 // subscriberImpact: uint64
	+
	frame_dig 3 // socialImpact: uint64
	+
	frame_dig 4 // nfdScore: uint64
	+
	frame_dig 5 // heldAkitaImpact: uint64
	+
	frame_dig 6 // nftImpact: uint64
	+
	frame_bury 7 // total: uint64

	// *if1_condition
	// contracts/arc58/plugins/akita_social.algo.ts:343
	// total === 0
	frame_dig 7 // total: uint64
	int 0
	==
	bz *if1_end

	// *if1_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:344
	// return 1
	int 1
	b *userImpact*return

*if1_end:
	// contracts/arc58/plugins/akita_social.algo.ts:347
	// return total;
	frame_dig 7 // total: uint64

*userImpact*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

// getStakingImpactScore(address: Address): uint64
getStakingImpactScore:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// contracts/arc58/plugins/akita_social.algo.ts:352
	// info = sendMethodCall<typeof StakingPlugin.prototype.getInfo, StakeValue>({
	//             applicationID: AppID.fromUint64(TIME_LOCK_PLUGIN_ID),
	//             methodArgs: [
	//                 address,
	//                 {
	//                     asset: AssetID.fromUint64(AKITA_ASSET_ID),
	//                     locked: false,
	//                 },
	//             ],
	//             fee: 0,
	//         })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "getInfo(address,(uint64,bool))(uint64,uint64,uint64)"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:353
	// applicationID: AppID.fromUint64(TIME_LOCK_PLUGIN_ID)
	int 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/akita_social.algo.ts:354
	// methodArgs: [
	//                 address,
	//                 {
	//                     asset: AssetID.fromUint64(AKITA_ASSET_ID),
	//                     locked: false,
	//                 },
	//             ]
	frame_dig -1 // address: Address
	itxn_field ApplicationArgs
	byte 0x000000001f36c5b8
	byte 0x00
	int 0
	dup
	setbit
	concat
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:361
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 0 // info: (uint64,uint64,uint64)

	// contracts/arc58/plugins/akita_social.algo.ts:364
	// elapsed = globals.latestTimestamp - info.lastUpdate
	global LatestTimestamp
	frame_dig 0 // info: (uint64,uint64,uint64)
	extract 8 8
	btoi
	-
	frame_bury 1 // elapsed: uint64

	// *if2_condition
	// contracts/arc58/plugins/akita_social.algo.ts:367
	// info.amount < TEN_THOUSAND_AKITA || elapsed < THIRTY_DAYS
	frame_dig 0 // info: (uint64,uint64,uint64)
	extract 0 8
	btoi
	int 10000000000
	<
	dup
	bnz *skip_or0
	frame_dig 1 // elapsed: uint64
	int 2592000
	<
	||

*skip_or0:
	bz *if2_end

	// *if2_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:368
	// return 0;
	int 0
	b *getStakingImpactScore*return

*if2_end:
	// contracts/arc58/plugins/akita_social.algo.ts:372
	// amtCapped = info.amount >= TWO_HUNDRED_THOUSAND_AKITA ? TWO_HUNDRED_THOUSAND_AKITA : info.amount
	frame_dig 0 // info: (uint64,uint64,uint64)
	extract 0 8
	btoi
	int 200000000000
	>=
	bz *ternary0_false
	int 200000000000
	b *ternary0_end

*ternary0_false:
	frame_dig 0 // info: (uint64,uint64,uint64)
	extract 0 8
	btoi

*ternary0_end:
	frame_bury 2 // amtCapped: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:375
	// maxScore = (amtCapped * 250) / TWO_HUNDRED_THOUSAND_AKITA
	frame_dig 2 // amtCapped: uint64
	int 250
	*
	int 200000000000
	/
	frame_bury 3 // maxScore: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:378
	// timeCapped = elapsed >= ONE_YEAR ? ONE_YEAR : elapsed
	frame_dig 1 // elapsed: uint64
	int 31536000
	>=
	bz *ternary1_false
	int 31536000
	b *ternary1_end

*ternary1_false:
	frame_dig 1 // elapsed: uint64

*ternary1_end:
	frame_bury 4 // timeCapped: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:380
	// return (timeCapped * maxScore) / ONE_YEAR;
	frame_dig 4 // timeCapped: uint64
	frame_dig 3 // maxScore: uint64
	*
	int 31536000
	/

*getStakingImpactScore*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// getHeldAktaImpactScore(address: Address): uint64
getHeldAktaImpactScore:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/arc58/plugins/akita_social.algo.ts:384
	// amount = address.assetBalance(AKITA_ASSET_ID)
	frame_dig -1 // address: Address
	int 523683256
	asset_holding_get AssetBalance
	pop
	frame_bury 0 // amount: uint64

	// *if3_condition
	// contracts/arc58/plugins/akita_social.algo.ts:387
	// amount < TEN_THOUSAND_AKITA
	frame_dig 0 // amount: uint64
	int 10000000000
	<
	bz *if3_end

	// *if3_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:388
	// return 0;
	int 0
	b *getHeldAktaImpactScore*return

*if3_end:
	// contracts/arc58/plugins/akita_social.algo.ts:391
	// capped = amount >= ONE_MILLION_AKITA ? ONE_MILLION_AKITA : amount
	frame_dig 0 // amount: uint64
	int 1000000000000
	>=
	bz *ternary2_false
	int 1000000000000
	b *ternary2_end

*ternary2_false:
	frame_dig 0 // amount: uint64

*ternary2_end:
	frame_bury 1 // capped: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:392
	// return (capped * 50) / ONE_MILLION_AKITA;
	frame_dig 1 // capped: uint64
	int 50
	*
	int 1000000000000
	/

*getHeldAktaImpactScore*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// getSubscriberImpactScore(address: Address, subscriptionIndex: uint64): uint64
getSubscriberImpactScore:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/arc58/plugins/akita_social.algo.ts:396
	// subscriberImpact = 0
	int 0
	frame_bury 0 // subscriberImpact: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:398
	// subscriptionState = this.isSubscribed(address, subscriptionIndex)
	frame_dig -2 // subscriptionIndex: uint64
	frame_dig -1 // address: Address
	callsub isSubscribed
	frame_bury 1 // subscriptionState: (bool,uint64,uint64)

	// *if4_condition
	// contracts/arc58/plugins/akita_social.algo.ts:400
	// !subscriptionState.active
	frame_dig 1 // subscriptionState: (bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	int 0
	getbit
	!
	bz *if4_end

	// *if4_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:401
	// return subscriberImpact;
	frame_dig 0 // subscriberImpact: uint64
	b *getSubscriberImpactScore*return

*if4_end:
	// contracts/arc58/plugins/akita_social.algo.ts:404
	// modifier = this.subscriptionStateModifier(subscriptionState.index).value
	frame_dig 1 // subscriptionState: (bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	extract 1 8
	btoi
	itob
	box_get

	// box value does not exist: this.subscriptionStateModifier(subscriptionState.index).value
	assert
	btoi
	frame_bury 2 // modifier: uint64

	// *if5_condition
	// contracts/arc58/plugins/akita_social.algo.ts:407
	// subscriptionState.streak >= 12
	frame_dig 1 // subscriptionState: (bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	extract 9 8
	btoi
	int 12
	>=
	bz *if5_else

	// *if5_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:408
	// subscriberImpact += (250 / modifier)
	frame_dig 0 // subscriberImpact: uint64
	int 250
	frame_dig 2 // modifier: uint64
	/
	+
	frame_bury 0 // subscriberImpact: uint64
	b *if5_end

*if5_else:
	// contracts/arc58/plugins/akita_social.algo.ts:410
	// subscriberImpact += (subscriptionState.streak * 20) / modifier
	frame_dig 0 // subscriberImpact: uint64
	frame_dig 1 // subscriptionState: (bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	extract 9 8
	btoi
	int 20
	*
	frame_dig 2 // modifier: uint64
	/
	+
	frame_bury 0 // subscriberImpact: uint64

*if5_end:
	// contracts/arc58/plugins/akita_social.algo.ts:413
	// return subscriberImpact;
	frame_dig 0 // subscriberImpact: uint64

*getSubscriberImpactScore*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// calcNFDImpactScore(NFD: AppID): uint64
calcNFDImpactScore:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 5

	// contracts/arc58/plugins/akita_social.algo.ts:418
	// nfdImpact = 50
	int 50
	frame_bury 0 // nfdImpact: uint64

	// *if6_condition
	// contracts/arc58/plugins/akita_social.algo.ts:421
	// NFD.globalStateExists('i.parentAppID')
	//             && btoi(NFD.globalState('i.parentAppID') as bytes) === AKITA_NFD_APP_ID
	frame_dig -1 // NFD: AppID
	byte 0x692e706172656e744170704944 // "i.parentAppID"
	app_global_get_ex
	swap
	pop
	dup
	bz *skip_and4
	frame_dig -1 // NFD: AppID
	byte 0x692e706172656e744170704944 // "i.parentAppID"
	app_global_get_ex

	// global state value does not exist: NFD.globalState('i.parentAppID')
	assert
	btoi
	int 0
	==
	&&

*skip_and4:
	bz *if6_end

	// *if6_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:424
	// nfdImpact += 50
	frame_dig 0 // nfdImpact: uint64
	int 50
	+
	frame_bury 0 // nfdImpact: uint64

*if6_end:
	// contracts/arc58/plugins/akita_social.algo.ts:427
	// hasVerifiedDomain = false
	int 0
	frame_bury 1 // hasVerifiedDomain: bool

	// contracts/arc58/plugins/akita_social.algo.ts:428
	// hasVerifiedTwitter = false
	int 0
	frame_bury 2 // hasVerifiedTwitter: bool

	// contracts/arc58/plugins/akita_social.algo.ts:429
	// hasVerifiedDiscord = false
	int 0
	frame_bury 3 // hasVerifiedDiscord: bool

	// contracts/arc58/plugins/akita_social.algo.ts:430
	// hasVerifiedTelegram = false
	int 0
	frame_bury 4 // hasVerifiedTelegram: bool

	// contracts/arc58/plugins/akita_social.algo.ts:431
	// version = extract3((NFD.globalState('i.ver') as bytes), 0, 2)
	frame_dig -1 // NFD: AppID
	byte 0x692e766572 // "i.ver"
	app_global_get_ex

	// global state value does not exist: NFD.globalState('i.ver')
	assert
	extract 0 2
	frame_bury 5 // version: byte[]

	// *if7_condition
	// contracts/arc58/plugins/akita_social.algo.ts:433
	// version === '1.'
	frame_dig 5 // version: byte[]
	byte 0x312e // "1."
	==
	bz *if7_else

	// *if7_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:434
	// hasVerifiedDomain = NFD.globalStateExists('v.domain')
	frame_dig -1 // NFD: AppID
	byte 0x762e646f6d61696e // "v.domain"
	app_global_get_ex
	swap
	pop
	frame_bury 1 // hasVerifiedDomain: bool

	// contracts/arc58/plugins/akita_social.algo.ts:435
	// hasVerifiedTwitter = NFD.globalStateExists('v.twitter')
	frame_dig -1 // NFD: AppID
	byte 0x762e74776974746572 // "v.twitter"
	app_global_get_ex
	swap
	pop
	frame_bury 2 // hasVerifiedTwitter: bool

	// contracts/arc58/plugins/akita_social.algo.ts:436
	// hasVerifiedDiscord = NFD.globalStateExists('v.discord')
	frame_dig -1 // NFD: AppID
	byte 0x762e646973636f7264 // "v.discord"
	app_global_get_ex
	swap
	pop
	frame_bury 3 // hasVerifiedDiscord: bool

	// contracts/arc58/plugins/akita_social.algo.ts:437
	// hasVerifiedTelegram = NFD.globalStateExists('v.telegram')
	frame_dig -1 // NFD: AppID
	byte 0x762e74656c656772616d // "v.telegram"
	app_global_get_ex
	swap
	pop
	frame_bury 4 // hasVerifiedTelegram: bool
	b *if7_end

*if7_else:
	// contracts/arc58/plugins/akita_social.algo.ts:439
	// sendAppCall({
	//                 applicationID: NFD,
	//                 applicationArgs: ['read_property', 'v.domain'],
	//                 fee: 0,
	//             })
	itxn_begin
	int appl
	itxn_field TypeEnum

	// contracts/arc58/plugins/akita_social.algo.ts:440
	// applicationID: NFD
	frame_dig -1 // NFD: AppID
	itxn_field ApplicationID

	// contracts/arc58/plugins/akita_social.algo.ts:441
	// applicationArgs: ['read_property', 'v.domain']
	byte 0x726561645f70726f7065727479 // "read_property"
	itxn_field ApplicationArgs
	byte 0x762e646f6d61696e // "v.domain"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:442
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/arc58/plugins/akita_social.algo.ts:444
	// hasVerifiedDomain = this.itxn.lastLog !== ''
	itxn LastLog
	byte 0x // ""
	!=
	frame_bury 1 // hasVerifiedDomain: bool

	// contracts/arc58/plugins/akita_social.algo.ts:446
	// sendAppCall({
	//                 applicationID: NFD,
	//                 applicationArgs: ['read_property', 'v.twitter'],
	//                 fee: 0,
	//             })
	itxn_begin
	int appl
	itxn_field TypeEnum

	// contracts/arc58/plugins/akita_social.algo.ts:447
	// applicationID: NFD
	frame_dig -1 // NFD: AppID
	itxn_field ApplicationID

	// contracts/arc58/plugins/akita_social.algo.ts:448
	// applicationArgs: ['read_property', 'v.twitter']
	byte 0x726561645f70726f7065727479 // "read_property"
	itxn_field ApplicationArgs
	byte 0x762e74776974746572 // "v.twitter"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:449
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/arc58/plugins/akita_social.algo.ts:451
	// hasVerifiedTwitter = this.itxn.lastLog !== ''
	itxn LastLog
	byte 0x // ""
	!=
	frame_bury 2 // hasVerifiedTwitter: bool

	// contracts/arc58/plugins/akita_social.algo.ts:453
	// sendAppCall({
	//                 applicationID: NFD,
	//                 applicationArgs: ['read_property', 'v.discord'],
	//                 fee: 0,
	//             })
	itxn_begin
	int appl
	itxn_field TypeEnum

	// contracts/arc58/plugins/akita_social.algo.ts:454
	// applicationID: NFD
	frame_dig -1 // NFD: AppID
	itxn_field ApplicationID

	// contracts/arc58/plugins/akita_social.algo.ts:455
	// applicationArgs: ['read_property', 'v.discord']
	byte 0x726561645f70726f7065727479 // "read_property"
	itxn_field ApplicationArgs
	byte 0x762e646973636f7264 // "v.discord"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:456
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/arc58/plugins/akita_social.algo.ts:458
	// hasVerifiedDiscord = this.itxn.lastLog !== ''
	itxn LastLog
	byte 0x // ""
	!=
	frame_bury 3 // hasVerifiedDiscord: bool

	// contracts/arc58/plugins/akita_social.algo.ts:460
	// sendAppCall({
	//                 applicationID: NFD,
	//                 applicationArgs: ['read_property', 'v.telegram'],
	//                 fee: 0,
	//             })
	itxn_begin
	int appl
	itxn_field TypeEnum

	// contracts/arc58/plugins/akita_social.algo.ts:461
	// applicationID: NFD
	frame_dig -1 // NFD: AppID
	itxn_field ApplicationID

	// contracts/arc58/plugins/akita_social.algo.ts:462
	// applicationArgs: ['read_property', 'v.telegram']
	byte 0x726561645f70726f7065727479 // "read_property"
	itxn_field ApplicationArgs
	byte 0x762e74656c656772616d // "v.telegram"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:463
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/arc58/plugins/akita_social.algo.ts:465
	// hasVerifiedTelegram = this.itxn.lastLog !== ''
	itxn LastLog
	byte 0x // ""
	!=
	frame_bury 4 // hasVerifiedTelegram: bool

*if7_end:
	// *if8_condition
	// contracts/arc58/plugins/akita_social.algo.ts:469
	// hasVerifiedDomain
	frame_dig 1 // hasVerifiedDomain: bool
	bz *if8_end

	// *if8_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:470
	// nfdImpact += 10
	frame_dig 0 // nfdImpact: uint64
	int 10
	+
	frame_bury 0 // nfdImpact: uint64

*if8_end:
	// *if9_condition
	// contracts/arc58/plugins/akita_social.algo.ts:473
	// hasVerifiedTwitter
	frame_dig 2 // hasVerifiedTwitter: bool
	bz *if9_end

	// *if9_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:474
	// nfdImpact += 20
	frame_dig 0 // nfdImpact: uint64
	int 20
	+
	frame_bury 0 // nfdImpact: uint64

*if9_end:
	// *if10_condition
	// contracts/arc58/plugins/akita_social.algo.ts:477
	// hasVerifiedDiscord
	frame_dig 3 // hasVerifiedDiscord: bool
	bz *if10_end

	// *if10_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:478
	// nfdImpact += 10
	frame_dig 0 // nfdImpact: uint64
	int 10
	+
	frame_bury 0 // nfdImpact: uint64

*if10_end:
	// *if11_condition
	// contracts/arc58/plugins/akita_social.algo.ts:481
	// hasVerifiedTelegram
	frame_dig 4 // hasVerifiedTelegram: bool
	bz *if11_end

	// *if11_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:482
	// nfdImpact += 10
	frame_dig 0 // nfdImpact: uint64
	int 10
	+
	frame_bury 0 // nfdImpact: uint64

*if11_end:
	// contracts/arc58/plugins/akita_social.algo.ts:485
	// return nfdImpact;
	frame_dig 0 // nfdImpact: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 5
	retsub

// getNFDImpactScore(address: Address, NFD: AppID): uint64
getNFDImpactScore:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/arc58/plugins/akita_social.algo.ts:489
	// meta = this.meta(address).value
	frame_dig -1 // address: Address
	frame_bury 0 // storage key//meta

	// contracts/arc58/plugins/akita_social.algo.ts:490
	// timeChanged = btoi(meta.NFD.globalState(NFD_TIME_CHANGED_KEY) as bytes)
	frame_dig 0 // storage key//meta
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	extract 40 8
	btoi
	byte "i.timeChanged"
	app_global_get_ex

	// global state value does not exist: meta.NFD.globalState(NFD_TIME_CHANGED_KEY)
	assert
	btoi
	frame_bury 1 // timeChanged: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:492
	// assert(NFD.id === meta.NFD.id, errs.INVALID_NFD)
	frame_dig -2 // NFD: AppID
	frame_dig 0 // storage key//meta
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	extract 40 8
	btoi
	==
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:493
	// assert(meta.nfdTimeChanged === timeChanged, errs.NFD_CHANGED)
	frame_dig 0 // storage key//meta
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	extract 48 8
	btoi
	frame_dig 1 // timeChanged: uint64
	==
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:495
	// return meta.nfdImpact;
	frame_dig 0 // storage key//meta
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	extract 56 8
	btoi

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// getSocialImpactScore(address: Address): uint64
getSocialImpactScore:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// contracts/arc58/plugins/akita_social.algo.ts:500
	// socialImpact = 0
	int 0
	frame_bury 0 // socialImpact: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:502
	// meta = this.meta(address).value
	frame_dig -1 // address: Address
	frame_bury 1 // storage key//meta

	// *if12_condition
	// contracts/arc58/plugins/akita_social.algo.ts:504
	// meta.streak >= 60
	frame_dig 1 // storage key//meta
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	int 60
	>=
	bz *if12_else

	// *if12_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:505
	// socialImpact += 100
	frame_dig 0 // socialImpact: uint64
	int 100
	+
	frame_bury 0 // socialImpact: uint64
	b *if12_end

*if12_else:
	// contracts/arc58/plugins/akita_social.algo.ts:508
	// socialImpact += (meta.streak * 100) / 60
	frame_dig 0 // socialImpact: uint64
	frame_dig 1 // storage key//meta
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	int 100
	*
	int 60
	/
	+
	frame_bury 0 // socialImpact: uint64

*if12_end:
	// contracts/arc58/plugins/akita_social.algo.ts:513
	// accountAge = globals.latestTimestamp - meta.startDate
	global LatestTimestamp
	frame_dig 1 // storage key//meta
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	extract 16 8
	btoi
	-
	frame_bury 2 // accountAge: uint64

	// *if13_condition
	// contracts/arc58/plugins/akita_social.algo.ts:516
	// accountAge >= twoYearsInSeconds
	frame_dig 2 // accountAge: uint64
	int 63072000
	>=
	bz *if13_else

	// *if13_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:517
	// socialImpact += 75
	frame_dig 0 // socialImpact: uint64
	int 75
	+
	frame_bury 0 // socialImpact: uint64
	b *if13_end

*if13_else:
	// contracts/arc58/plugins/akita_social.algo.ts:520
	// socialImpact += (accountAge * 75) / twoYearsInSeconds
	frame_dig 0 // socialImpact: uint64
	frame_dig 2 // accountAge: uint64
	int 75
	*
	int 63072000
	/
	+
	frame_bury 0 // socialImpact: uint64

*if13_end:
	// *if14_condition
	// contracts/arc58/plugins/akita_social.algo.ts:524
	// this.votes(rawBytes(address) as bytes32).exists
	byte 0x76 // "v"
	frame_dig -1 // address: Address
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	concat
	box_len
	swap
	pop
	bz *if14_end

	// *if14_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:525
	// score = this.votes(rawBytes(address) as bytes32).value
	byte 0x76 // "v"
	frame_dig -1 // address: Address
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	concat
	frame_bury 3 // storage key//score

	// contracts/arc58/plugins/akita_social.algo.ts:527
	// impact = (score.voteCount * 75) / 100_000
	frame_dig 3 // storage key//score
	box_get

	// box value does not exist: this.votes(rawBytes(address) as bytes32).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	int 75
	*
	int 100_000
	/
	frame_bury 4 // impact: uint64

	// *if15_condition
	// contracts/arc58/plugins/akita_social.algo.ts:528
	// impact > 75
	frame_dig 4 // impact: uint64
	int 75
	>
	bz *if15_end

	// *if15_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:529
	// impact = 75
	int 75
	frame_bury 4 // impact: uint64

*if15_end:
	// *if16_condition
	// contracts/arc58/plugins/akita_social.algo.ts:532
	// score.isNegative
	frame_dig 3 // storage key//score
	box_get

	// box value does not exist: this.votes(rawBytes(address) as bytes32).value
	assert
	store 255 // full array
	load 255 // full array
	int 64
	getbit
	bz *if16_else

	// *if16_consequent
	// *if17_condition
	// contracts/arc58/plugins/akita_social.algo.ts:534
	// socialImpact > impact
	frame_dig 0 // socialImpact: uint64
	frame_dig 4 // impact: uint64
	>
	bz *if17_else

	// *if17_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:535
	// socialImpact -= impact
	frame_dig 0 // socialImpact: uint64
	frame_dig 4 // impact: uint64
	-
	frame_bury 0 // socialImpact: uint64
	b *if17_end

*if17_else:
	// contracts/arc58/plugins/akita_social.algo.ts:537
	// socialImpact = 0
	int 0
	frame_bury 0 // socialImpact: uint64

*if17_end:
	b *if16_end

*if16_else:
	// contracts/arc58/plugins/akita_social.algo.ts:541
	// socialImpact += impact
	frame_dig 0 // socialImpact: uint64
	frame_dig 4 // impact: uint64
	+
	frame_bury 0 // socialImpact: uint64

*if16_end:

*if14_end:
	// contracts/arc58/plugins/akita_social.algo.ts:545
	// return socialImpact;
	frame_dig 0 // socialImpact: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// getNFTImpactScore(address: Address, asa: AssetID): uint64
getNFTImpactScore:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/arc58/plugins/akita_social.algo.ts:549
	// prefix = extract3(asa.unitName, 0, 3)
	frame_dig -2 // asa: AssetID
	asset_params_get AssetUnitName
	pop
	extract 0 3
	frame_bury 0 // prefix: byte[]

	// *if18_condition
	// contracts/arc58/plugins/akita_social.algo.ts:550
	// asa.creator === AKC_CREATOR_ADDRESS && address.assetBalance(asa) > 0
	frame_dig -2 // asa: AssetID
	asset_params_get AssetCreator
	pop

	// contracts/arc58/plugins/akita_social.algo.ts:26
	// addr('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ')
	addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
	==
	dup
	bz *skip_and5

	// contracts/arc58/plugins/akita_social.algo.ts:550
	// address.assetBalance(asa)
	frame_dig -1 // address: Address
	frame_dig -2 // asa: AssetID
	asset_holding_get AssetBalance
	pop
	int 0
	>
	&&

*skip_and5:
	bz *if18_end

	// *if18_consequent
	// *if19_condition
	// contracts/arc58/plugins/akita_social.algo.ts:551
	// prefix === 'AKC'
	frame_dig 0 // prefix: byte[]
	byte 0x414b43 // "AKC"
	==
	bz *if19_end

	// *if19_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:552
	// return 50;
	int 50
	b *getNFTImpactScore*return

*if19_end:
	// *if20_condition
	// contracts/arc58/plugins/akita_social.algo.ts:554
	// prefix === 'AOG'
	frame_dig 0 // prefix: byte[]
	byte 0x414f47 // "AOG"
	==
	bz *if20_end

	// *if20_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:555
	// return 25;
	int 25
	b *getNFTImpactScore*return

*if20_end:

*if18_end:
	// contracts/arc58/plugins/akita_social.algo.ts:558
	// return 0;
	int 0

*getNFTImpactScore*return:
	// set the subroutine return value
	frame_bury 0
	retsub

// getTax(impact: uint64): uint64
getTax:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/arc58/plugins/akita_social.algo.ts:566
	// taxRate = MAX_TAX - ((MAX_TAX - MIN_TAX) * (impact - 1)) / 999
	int 20
	int 19
	frame_dig -1 // impact: uint64
	int 1
	-
	*
	int 999
	/
	-
	frame_bury 0 // taxRate: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:567
	// return (REACT_FEE * taxRate - 1) / 1001
	int 10000000
	frame_dig 0 // taxRate: uint64
	*
	int 1
	-
	int 1001
	/

	// set the subroutine return value
	frame_bury 0
	retsub

// canCallArc58OptIn(sender: Address, walletAppID: AppID): boolean
canCallArc58OptIn:
	proto 2 1

	// contracts/arc58/plugins/akita_social.algo.ts:571
	// return sendMethodCall<typeof AbstractedAccount.prototype.arc58_canCall, boolean>({
	//             sender: sender,
	//             applicationID: walletAppID,
	//             methodArgs: [
	//                 AppID.fromUint64(OPT_IN_PLUGIN_APP_ID),
	//                 sender,
	//             ],
	//             fee: 0,
	//         });
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "arc58_canCall(uint64,address)bool"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:572
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/akita_social.algo.ts:573
	// applicationID: walletAppID
	frame_dig -2 // walletAppID: AppID
	itxn_field ApplicationID

	// contracts/arc58/plugins/akita_social.algo.ts:574
	// methodArgs: [
	//                 AppID.fromUint64(OPT_IN_PLUGIN_APP_ID),
	//                 sender,
	//             ]
	byte 0x0000000000000000
	itxn_field ApplicationArgs
	frame_dig -1 // sender: Address
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:578
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	int 0
	getbit
	retsub

// arc58OptInAndSendReactionPayments(sender: Address, recipientAppID: AppID, tax: uint64): void
arc58OptInAndSendReactionPayments:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/arc58/plugins/akita_social.algo.ts:583
	// recipientAddress = recipientAppID.globalState(ARC58_CONTROLLED_ADDRESS_KEY) as Address
	frame_dig -2 // recipientAppID: AppID
	byte "c"
	app_global_get_ex

	// global state value does not exist: recipientAppID.globalState(ARC58_CONTROLLED_ADDRESS_KEY)
	assert
	frame_bury 0 // recipientAddress: address

	// contracts/arc58/plugins/akita_social.algo.ts:585
	// this.pendingGroup.addMethodCall<typeof AbstractedAccount.prototype.arc58_rekeyToPlugin, void>({
	//             sender: sender,
	//             applicationID: recipientAppID,
	//             methodArgs: [
	//                 AppID.fromUint64(OPT_IN_PLUGIN_APP_ID)
	//             ],
	//             fee: 0,
	//         })
	itxn_next
	int appl
	itxn_field TypeEnum
	method "arc58_rekeyToPlugin(uint64)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:586
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/akita_social.algo.ts:587
	// applicationID: recipientAppID
	frame_dig -2 // recipientAppID: AppID
	itxn_field ApplicationID

	// contracts/arc58/plugins/akita_social.algo.ts:588
	// methodArgs: [
	//                 AppID.fromUint64(OPT_IN_PLUGIN_APP_ID)
	//             ]
	byte 0x0000000000000000
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:591
	// fee: 0
	int 0
	itxn_field Fee

	// contracts/arc58/plugins/akita_social.algo.ts:594
	// this.pendingGroup.addMethodCall<typeof OptInPlugin.prototype.optInToAsset, void>({
	//             sender: sender,
	//             applicationID: AppID.fromUint64(OPT_IN_PLUGIN_APP_ID),
	//             methodArgs: [
	//                 recipientAddress,
	//                 AssetID.fromUint64(AKITA_ASSET_ID),
	//                 {
	//                     sender: sender, // sender pays the recipient mbr
	//                     receiver: recipientAddress,
	//                     amount: globals.assetOptInMinBalance,
	//                     fee: 0,
	//                 }
	//             ],
	//             fee: 0,
	//         })
	itxn_next
	int pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/akita_social.algo.ts:601
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/akita_social.algo.ts:602
	// receiver: recipientAddress
	frame_dig 0 // recipientAddress: address
	itxn_field Receiver

	// contracts/arc58/plugins/akita_social.algo.ts:603
	// amount: globals.assetOptInMinBalance
	global AssetOptInMinBalance
	itxn_field Amount

	// contracts/arc58/plugins/akita_social.algo.ts:604
	// fee: 0
	int 0
	itxn_field Fee
	itxn_next
	int appl
	itxn_field TypeEnum
	method "optInToAsset(address,uint64,pay)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:595
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/akita_social.algo.ts:596
	// applicationID: AppID.fromUint64(OPT_IN_PLUGIN_APP_ID)
	int 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/akita_social.algo.ts:597
	// methodArgs: [
	//                 recipientAddress,
	//                 AssetID.fromUint64(AKITA_ASSET_ID),
	//                 {
	//                     sender: sender, // sender pays the recipient mbr
	//                     receiver: recipientAddress,
	//                     amount: globals.assetOptInMinBalance,
	//                     fee: 0,
	//                 }
	//             ]
	frame_dig 0 // recipientAddress: address
	itxn_field ApplicationArgs
	byte 0x000000001f36c5b8
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:607
	// fee: 0
	int 0
	itxn_field Fee

	// contracts/arc58/plugins/akita_social.algo.ts:610
	// this.pendingGroup.addMethodCall<typeof AbstractedAccount.prototype.arc58_verifyAuthAddr, void>({
	//             sender: sender,
	//             applicationID: recipientAppID,
	//             fee: 0,
	//         })
	itxn_next
	int appl
	itxn_field TypeEnum
	method "arc58_verifyAuthAddr()void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:611
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/akita_social.algo.ts:612
	// applicationID: recipientAppID
	frame_dig -2 // recipientAppID: AppID
	itxn_field ApplicationID

	// contracts/arc58/plugins/akita_social.algo.ts:613
	// fee: 0
	int 0
	itxn_field Fee

	// contracts/arc58/plugins/akita_social.algo.ts:616
	// this.pendingGroup.addAssetTransfer({
	//             sender: sender,
	//             assetReceiver: AKITA_SOCIAL_TREASURY,
	//             assetAmount: tax,
	//             xferAsset: AssetID.fromUint64(AKITA_ASSET_ID),
	//             fee: 0,
	//         })
	itxn_next
	int axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/akita_social.algo.ts:617
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/akita_social.algo.ts:618
	// assetReceiver: AKITA_SOCIAL_TREASURY
	// contracts/arc58/plugins/akita_social.algo.ts:25
	// addr('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ')
	addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
	itxn_field AssetReceiver

	// contracts/arc58/plugins/akita_social.algo.ts:619
	// assetAmount: tax
	frame_dig -3 // tax: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/akita_social.algo.ts:620
	// xferAsset: AssetID.fromUint64(AKITA_ASSET_ID)
	int 523683256
	itxn_field XferAsset

	// contracts/arc58/plugins/akita_social.algo.ts:621
	// fee: 0
	int 0
	itxn_field Fee

	// contracts/arc58/plugins/akita_social.algo.ts:624
	// this.pendingGroup.addAssetTransfer({
	//             sender: sender,
	//             assetReceiver: recipientAddress,
	//             assetAmount: (REACT_FEE - tax),
	//             xferAsset: AssetID.fromUint64(AKITA_ASSET_ID),
	//             rekeyTo: sender,
	//             fee: 0,
	//         })
	itxn_next
	int axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/akita_social.algo.ts:625
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/akita_social.algo.ts:626
	// assetReceiver: recipientAddress
	frame_dig 0 // recipientAddress: address
	itxn_field AssetReceiver

	// contracts/arc58/plugins/akita_social.algo.ts:627
	// assetAmount: (REACT_FEE - tax)
	int 10000000
	frame_dig -3 // tax: uint64
	-
	itxn_field AssetAmount

	// contracts/arc58/plugins/akita_social.algo.ts:628
	// xferAsset: AssetID.fromUint64(AKITA_ASSET_ID)
	int 523683256
	itxn_field XferAsset

	// contracts/arc58/plugins/akita_social.algo.ts:629
	// rekeyTo: sender
	frame_dig -1 // sender: Address
	itxn_field RekeyTo

	// contracts/arc58/plugins/akita_social.algo.ts:630
	// fee: 0
	int 0
	itxn_field Fee

	// contracts/arc58/plugins/akita_social.algo.ts:633
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// arc59OptInAndSendReactionPayments(sender: Address, recipientAppID: AppID, tax: uint64): void
arc59OptInAndSendReactionPayments:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// contracts/arc58/plugins/akita_social.algo.ts:637
	// recipientAddress = recipientAppID.globalState(ARC58_CONTROLLED_ADDRESS_KEY) as Address
	frame_dig -2 // recipientAppID: AppID
	byte "c"
	app_global_get_ex

	// global state value does not exist: recipientAppID.globalState(ARC58_CONTROLLED_ADDRESS_KEY)
	assert
	frame_bury 0 // recipientAddress: address

	// contracts/arc58/plugins/akita_social.algo.ts:639
	// canCallData = sendMethodCall<[Address, uint64], arc59GetSendAssetInfoResponse>({
	//             name: 'arc59_getSendAssetInfo',
	//             applicationID: AppID.fromUint64(ARC59_ROUTER_APP_ID),
	//             methodArgs: [
	//                 recipientAddress,
	//                 AKITA_ASSET_ID,
	//             ],
	//             fee: 0,
	//         })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "arc59_getSendAssetInfo(address,uint64)(uint64,uint64,bool,bool,uint64)"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:641
	// applicationID: AppID.fromUint64(ARC59_ROUTER_APP_ID)
	int 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/akita_social.algo.ts:642
	// methodArgs: [
	//                 recipientAddress,
	//                 AKITA_ASSET_ID,
	//             ]
	frame_dig 0 // recipientAddress: address
	itxn_field ApplicationArgs
	byte 0x000000001f36c5b8
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:646
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 1 // canCallData: (uint64,uint64,bool,bool,uint64)

	// contracts/arc58/plugins/akita_social.algo.ts:649
	// mbr = canCallData.mbr
	frame_dig 1 // canCallData: (uint64,uint64,bool,bool,uint64)
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	frame_bury 2 // mbr: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:650
	// routerOptedIn = canCallData.routerOptedIn
	frame_dig 1 // canCallData: (uint64,uint64,bool,bool,uint64)
	store 255 // full array
	load 255 // full array
	int 128
	getbit
	frame_bury 3 // routerOptedIn: bool

	// contracts/arc58/plugins/akita_social.algo.ts:651
	// receiverAlgoNeededForClaim = canCallData.receiverAlgoNeededForClaim
	frame_dig 1 // canCallData: (uint64,uint64,bool,bool,uint64)
	store 255 // full array
	load 255 // full array
	extract 17 8
	btoi
	frame_bury 4 // receiverAlgoNeededForClaim: uint64

	// *if21_condition
	// contracts/arc58/plugins/akita_social.algo.ts:653
	// mbr || receiverAlgoNeededForClaim
	frame_dig 2 // mbr: uint64
	dup
	bnz *skip_or1
	frame_dig 4 // receiverAlgoNeededForClaim: uint64
	||

*skip_or1:
	bz *if21_end

	// *if21_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:654
	// this.pendingGroup.addPayment({
	//                 sender: sender,
	//                 receiver: ARC59_ROUTER_APP_ADDRESS,
	//                 amount: (mbr + receiverAlgoNeededForClaim),
	//                 fee: 0,
	//             })
	itxn_next
	int pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/akita_social.algo.ts:655
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/akita_social.algo.ts:656
	// receiver: ARC59_ROUTER_APP_ADDRESS
	// contracts/arc58/plugins/akita_social.algo.ts:35
	// addr('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ')
	addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
	itxn_field Receiver

	// contracts/arc58/plugins/akita_social.algo.ts:657
	// amount: (mbr + receiverAlgoNeededForClaim)
	frame_dig 2 // mbr: uint64
	frame_dig 4 // receiverAlgoNeededForClaim: uint64
	+
	itxn_field Amount

	// contracts/arc58/plugins/akita_social.algo.ts:658
	// fee: 0
	int 0
	itxn_field Fee

*if21_end:
	// *if22_condition
	// contracts/arc58/plugins/akita_social.algo.ts:662
	// !routerOptedIn
	frame_dig 3 // routerOptedIn: bool
	!
	bz *if22_end

	// *if22_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:663
	// this.pendingGroup.addMethodCall<[uint64], void>({
	//                 sender: sender,
	//                 name: 'arc59_optRouterIn',
	//                 applicationID: AppID.fromUint64(ARC59_ROUTER_APP_ID),
	//                 methodArgs: [AKITA_ASSET_ID],
	//                 fee: 0
	//             })
	itxn_next
	int appl
	itxn_field TypeEnum
	method "arc59_optRouterIn(uint64)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:664
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/akita_social.algo.ts:666
	// applicationID: AppID.fromUint64(ARC59_ROUTER_APP_ID)
	int 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/akita_social.algo.ts:667
	// methodArgs: [AKITA_ASSET_ID]
	byte 0x000000001f36c5b8
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:668
	// fee: 0
	int 0
	itxn_field Fee

*if22_end:
	// contracts/arc58/plugins/akita_social.algo.ts:672
	// this.pendingGroup.addAssetTransfer({
	//             sender: sender,
	//             assetReceiver: AKITA_SOCIAL_TREASURY,
	//             assetAmount: tax,
	//             xferAsset: AssetID.fromUint64(AKITA_ASSET_ID),
	//             fee: 0,
	//         })
	itxn_next
	int axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/akita_social.algo.ts:673
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/akita_social.algo.ts:674
	// assetReceiver: AKITA_SOCIAL_TREASURY
	// contracts/arc58/plugins/akita_social.algo.ts:25
	// addr('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ')
	addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
	itxn_field AssetReceiver

	// contracts/arc58/plugins/akita_social.algo.ts:675
	// assetAmount: tax
	frame_dig -3 // tax: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/akita_social.algo.ts:676
	// xferAsset: AssetID.fromUint64(AKITA_ASSET_ID)
	int 523683256
	itxn_field XferAsset

	// contracts/arc58/plugins/akita_social.algo.ts:677
	// fee: 0
	int 0
	itxn_field Fee

	// contracts/arc58/plugins/akita_social.algo.ts:680
	// this.pendingGroup.addMethodCall<[AssetTransferTxn, Address, uint64], Address>({
	//             sender: sender,
	//             name: 'arc59_sendAsset',
	//             applicationID: AppID.fromUint64(ARC59_ROUTER_APP_ID),
	//             methodArgs: [
	//                 {
	//                     sender: sender,
	//                     assetReceiver: ARC59_ROUTER_APP_ADDRESS,
	//                     assetAmount: (REACT_FEE - tax),
	//                     xferAsset: AssetID.fromUint64(AKITA_ASSET_ID),
	//                     fee: 0,
	//                 },
	//                 recipientAddress,
	//                 receiverAlgoNeededForClaim,
	//             ],
	//             fee: 0
	//         })
	itxn_next
	int axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/akita_social.algo.ts:686
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/akita_social.algo.ts:687
	// assetReceiver: ARC59_ROUTER_APP_ADDRESS
	// contracts/arc58/plugins/akita_social.algo.ts:35
	// addr('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ')
	addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
	itxn_field AssetReceiver

	// contracts/arc58/plugins/akita_social.algo.ts:688
	// assetAmount: (REACT_FEE - tax)
	int 10000000
	frame_dig -3 // tax: uint64
	-
	itxn_field AssetAmount

	// contracts/arc58/plugins/akita_social.algo.ts:689
	// xferAsset: AssetID.fromUint64(AKITA_ASSET_ID)
	int 523683256
	itxn_field XferAsset

	// contracts/arc58/plugins/akita_social.algo.ts:690
	// fee: 0
	int 0
	itxn_field Fee
	itxn_next
	int appl
	itxn_field TypeEnum
	method "arc59_sendAsset(axfer,address,uint64)address"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:681
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/akita_social.algo.ts:683
	// applicationID: AppID.fromUint64(ARC59_ROUTER_APP_ID)
	int 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/akita_social.algo.ts:684
	// methodArgs: [
	//                 {
	//                     sender: sender,
	//                     assetReceiver: ARC59_ROUTER_APP_ADDRESS,
	//                     assetAmount: (REACT_FEE - tax),
	//                     xferAsset: AssetID.fromUint64(AKITA_ASSET_ID),
	//                     fee: 0,
	//                 },
	//                 recipientAddress,
	//                 receiverAlgoNeededForClaim,
	//             ]
	frame_dig 0 // recipientAddress: address
	itxn_field ApplicationArgs
	frame_dig 4 // receiverAlgoNeededForClaim: uint64
	itob
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/akita_social.algo.ts:695
	// fee: 0
	int 0
	itxn_field Fee

	// contracts/arc58/plugins/akita_social.algo.ts:698
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// sendReactionPayments(sender: Address, recipientAddress: Address, tax: uint64): void
sendReactionPayments:
	proto 3 0

	// contracts/arc58/plugins/akita_social.algo.ts:702
	// this.pendingGroup.addAssetTransfer({
	//             sender: sender,
	//             assetReceiver: AKITA_SOCIAL_TREASURY,
	//             assetAmount: tax,
	//             xferAsset: AssetID.fromUint64(AKITA_ASSET_ID),
	//             fee: 0,
	//         })
	itxn_next
	int axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/akita_social.algo.ts:703
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/akita_social.algo.ts:704
	// assetReceiver: AKITA_SOCIAL_TREASURY
	// contracts/arc58/plugins/akita_social.algo.ts:25
	// addr('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ')
	addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
	itxn_field AssetReceiver

	// contracts/arc58/plugins/akita_social.algo.ts:705
	// assetAmount: tax
	frame_dig -3 // tax: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/akita_social.algo.ts:706
	// xferAsset: AssetID.fromUint64(AKITA_ASSET_ID)
	int 523683256
	itxn_field XferAsset

	// contracts/arc58/plugins/akita_social.algo.ts:707
	// fee: 0
	int 0
	itxn_field Fee

	// contracts/arc58/plugins/akita_social.algo.ts:710
	// this.pendingGroup.addAssetTransfer({
	//             sender: sender,
	//             assetReceiver: recipientAddress,
	//             assetAmount: (REACT_FEE - tax),
	//             xferAsset: AssetID.fromUint64(AKITA_ASSET_ID),
	//             rekeyTo: sender,
	//             fee: 0,
	//         })
	itxn_next
	int axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/akita_social.algo.ts:711
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/akita_social.algo.ts:712
	// assetReceiver: recipientAddress
	frame_dig -2 // recipientAddress: Address
	itxn_field AssetReceiver

	// contracts/arc58/plugins/akita_social.algo.ts:713
	// assetAmount: (REACT_FEE - tax)
	int 10000000
	frame_dig -3 // tax: uint64
	-
	itxn_field AssetAmount

	// contracts/arc58/plugins/akita_social.algo.ts:714
	// xferAsset: AssetID.fromUint64(AKITA_ASSET_ID)
	int 523683256
	itxn_field XferAsset

	// contracts/arc58/plugins/akita_social.algo.ts:715
	// rekeyTo: sender
	frame_dig -1 // sender: Address
	itxn_field RekeyTo

	// contracts/arc58/plugins/akita_social.algo.ts:716
	// fee: 0
	int 0
	itxn_field Fee

	// contracts/arc58/plugins/akita_social.algo.ts:719
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// createEmptyPostIfNecessary(ref: bytes32, creator: Address): void
createEmptyPostIfNecessary:
	proto 2 0

	// *if23_condition
	// contracts/arc58/plugins/akita_social.algo.ts:727
	// !this.posts(ref).exists
	byte 0x70 // "p"
	frame_dig -1 // ref: bytes32
	concat
	box_len
	swap
	pop
	!
	bz *if23_end

	// *if23_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:728
	// this.posts(ref).value = {
	//                 ref: ref,
	//                 cid: EMPTY_CID,
	//                 /**
	//                  * when a user reacts to content other than posts
	//                  * we set the creator to the following:
	//                  * - AssetID: Asset Creator
	//                  * - Address: Address
	//                  * -   AppID: Application Creator
	//                 */
	//                 creator: creator,
	//                 amendment: EMPTY_BYTES32,
	//                 isAmendment: false,
	//                 timestamp: globals.latestTimestamp,
	//                 collectible: false,
	//                 replyFilterIndex: 0,
	//                 reactFilterIndex: 0,
	//             }
	byte 0x70 // "p"
	frame_dig -1 // ref: bytes32
	concat
	frame_dig -1 // ref: bytes32
	byte 0x5858585858585858585858585858585858585858585858585858585858585858585858585858585858585858585858585858585858585858585858 // "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
	concat
	frame_dig -2 // creator: Address
	concat
	byte 0x5858585858585858585858585858585858585858585858585858585858585858 // "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
	concat
	byte 0x00
	int 0
	dup
	setbit
	concat // 5
	global LatestTimestamp
	itob
	concat
	byte 0x00
	int 0
	dup
	setbit
	concat // 7
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	box_put

*if23_end:
	retsub

// updateStreak(address: Address): void
updateStreak:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/arc58/plugins/akita_social.algo.ts:750
	// assert(this.meta(address).exists, errs.META_DOESNT_EXIST)
	frame_dig -1 // address: Address
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:752
	// meta = clone(this.meta(address).value)
	frame_dig -1 // address: Address
	box_get

	// box value does not exist: this.meta(address).value
	assert
	frame_bury 0 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)

	// contracts/arc58/plugins/akita_social.algo.ts:754
	// thisWindowStart = globals.latestTimestamp - (
	//             (globals.latestTimestamp - meta.startDate) % ONE_DAY
	//         )
	global LatestTimestamp
	global LatestTimestamp
	frame_dig 0 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	extract 16 8
	btoi
	-
	int 86400
	%
	-
	frame_bury 1 // thisWindowStart: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:757
	// lastWindowStart = thisWindowStart - ONE_DAY
	frame_dig 1 // thisWindowStart: uint64
	int 86400
	-
	frame_bury 2 // lastWindowStart: uint64

	// *if24_condition
	// contracts/arc58/plugins/akita_social.algo.ts:761
	// lastWindowStart > meta.lastActive
	frame_dig 2 // lastWindowStart: uint64
	frame_dig 0 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	extract 24 8
	btoi
	>
	bz *if24_end

	// *if24_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:762
	// meta.streak = 1
	frame_dig 0 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	byte 0x0000000000000001
	replace2 8
	frame_bury 0 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)

	// contracts/arc58/plugins/akita_social.algo.ts:763
	// meta.lastActive = globals.latestTimestamp
	frame_dig 0 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	int 24
	global LatestTimestamp
	itob
	replace3
	frame_bury 0 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)

	// contracts/arc58/plugins/akita_social.algo.ts:764
	// this.meta(address).value = meta
	frame_dig -1 // address: Address
	frame_dig 0 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)
	box_put

	// contracts/arc58/plugins/akita_social.algo.ts:765
	// return;
	retsub

*if24_end:
	// *if25_condition
	// contracts/arc58/plugins/akita_social.algo.ts:770
	// meta.lastActive < thisWindowStart
	frame_dig 0 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	extract 24 8
	btoi
	frame_dig 1 // thisWindowStart: uint64
	<
	bz *if25_end

	// *if25_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:771
	// meta.streak = meta.streak + 1
	frame_dig 0 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	int 8
	frame_dig 0 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	int 1
	+
	itob
	replace3
	frame_bury 0 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)

	// contracts/arc58/plugins/akita_social.algo.ts:772
	// meta.lastActive = globals.latestTimestamp
	frame_dig 0 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	int 24
	global LatestTimestamp
	itob
	replace3
	frame_bury 0 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)

	// contracts/arc58/plugins/akita_social.algo.ts:773
	// this.meta(address).value = meta
	frame_dig -1 // address: Address
	frame_dig 0 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)
	box_put

*if25_end:
	retsub

// calcVotes(ref: bytes32, isUp: boolean, impact: uint64): { newCount: uint64, isNegative: boolean }
calcVotes:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 6

	// contracts/arc58/plugins/akita_social.algo.ts:780
	// votesData = this.votes(ref).value
	byte 0x76 // "v"
	frame_dig -1 // ref: bytes32
	concat
	frame_bury 0 // storage key//votesData

	// contracts/arc58/plugins/akita_social.algo.ts:781
	// isNegative = votesData.isNegative
	frame_dig 0 // storage key//votesData
	box_get

	// box value does not exist: this.votes(ref).value
	assert
	store 255 // full array
	load 255 // full array
	int 64
	getbit
	frame_bury 1 // isNegative: bool

	// contracts/arc58/plugins/akita_social.algo.ts:782
	// voteCount = votesData.voteCount
	frame_dig 0 // storage key//votesData
	box_get

	// box value does not exist: this.votes(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	frame_bury 2 // voteCount: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:785
	// differingDirections = (isUp && isNegative) || (!isUp && !isNegative)
	frame_dig -2 // isUp: boolean
	dup
	bz *skip_and6
	frame_dig 1 // isNegative: bool
	&&

*skip_and6:
	dup
	bnz *skip_or2
	frame_dig -2 // isUp: boolean
	!
	dup
	bz *skip_and7
	frame_dig 1 // isNegative: bool
	!
	&&

*skip_and7:
	||

*skip_or2:
	frame_bury 3 // differingDirections: bool

	// contracts/arc58/plugins/akita_social.algo.ts:788
	// flip = impact > voteCount && differingDirections
	frame_dig -3 // impact: uint64
	frame_dig 2 // voteCount: uint64
	>
	dup
	bz *skip_and8
	frame_dig 3 // differingDirections: bool
	&&

*skip_and8:
	frame_bury 4 // flip: bool

	// *if26_condition
	// contracts/arc58/plugins/akita_social.algo.ts:789
	// flip
	frame_dig 4 // flip: bool
	bz *if26_end

	// *if26_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:790
	// newCount = impact - voteCount
	frame_dig -3 // impact: uint64
	frame_dig 2 // voteCount: uint64
	-
	frame_bury 5 // newCount: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:791
	// return { newCount: newCount, isNegative: !isNegative };
	frame_dig 5 // newCount: uint64
	itob
	byte 0x00
	int 0
	frame_dig 1 // isNegative: bool
	!
	setbit
	concat
	b *calcVotes*return

*if26_end:
	// contracts/arc58/plugins/akita_social.algo.ts:794
	// newCount = differingDirections ? voteCount - impact : voteCount + impact
	frame_dig 3 // differingDirections: bool
	bz *ternary3_false
	frame_dig 2 // voteCount: uint64
	frame_dig -3 // impact: uint64
	-
	b *ternary3_end

*ternary3_false:
	frame_dig 2 // voteCount: uint64
	frame_dig -3 // impact: uint64
	+

*ternary3_end:
	frame_bury 6 // newCount: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:795
	// return { newCount: newCount, isNegative: isNegative };
	frame_dig 6 // newCount: uint64
	itob
	byte 0x00
	int 0
	frame_dig 1 // isNegative: bool
	setbit
	concat

*calcVotes*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 6
	retsub

// updateVotes(ref: bytes32, isUp: boolean, impact: uint64): void
updateVotes:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/arc58/plugins/akita_social.algo.ts:799
	// calcData = this.calcVotes(ref, isUp, impact)
	frame_dig -3 // impact: uint64
	frame_dig -2 // isUp: boolean
	frame_dig -1 // ref: bytes32
	callsub calcVotes
	frame_bury 0 // calcData: (uint64,bool)

	// contracts/arc58/plugins/akita_social.algo.ts:800
	// newCount = calcData.newCount
	frame_dig 0 // calcData: (uint64,bool)
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	frame_bury 1 // newCount: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:801
	// isNegative = calcData.isNegative
	frame_dig 0 // calcData: (uint64,bool)
	store 255 // full array
	load 255 // full array
	int 64
	getbit
	frame_bury 2 // isNegative: bool

	// contracts/arc58/plugins/akita_social.algo.ts:802
	// this.votes(ref).value = { voteCount: newCount, isNegative: isNegative }
	byte 0x76 // "v"
	frame_dig -1 // ref: bytes32
	concat
	frame_dig 1 // newCount: uint64
	itob
	byte 0x00
	int 0
	frame_dig 2 // isNegative: bool
	setbit
	concat
	box_put
	retsub

// createPost(sender: Address, cid: bytes59, collectible: boolean, replyFilterIndex: uint64, reactFilterIndex: uint64, isAmendment: boolean): void
createPost:
	proto 6 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/arc58/plugins/akita_social.algo.ts:813
	// assert(!this.isBanned(sender), errs.BANNED)
	frame_dig -1 // sender: Address
	callsub isBanned
	!
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:817
	// this.updateStreak(sender)
	frame_dig -1 // sender: Address
	callsub updateStreak

	// contracts/arc58/plugins/akita_social.algo.ts:819
	// impact = this.userImpact(sender)
	frame_dig -1 // sender: Address
	callsub userImpact
	frame_bury 0 // impact: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:821
	// sendAssetTransfer({
	//             sender: sender,
	//             assetReceiver: AKITA_SOCIAL_TREASURY,
	//             assetAmount: POST_FEE,
	//             xferAsset: AssetID.fromUint64(AKITA_ASSET_ID),
	//             rekeyTo: sender,
	//             fee: 0,
	//         })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/akita_social.algo.ts:822
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/akita_social.algo.ts:823
	// assetReceiver: AKITA_SOCIAL_TREASURY
	// contracts/arc58/plugins/akita_social.algo.ts:25
	// addr('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ')
	addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
	itxn_field AssetReceiver

	// contracts/arc58/plugins/akita_social.algo.ts:824
	// assetAmount: POST_FEE
	int 100000000
	itxn_field AssetAmount

	// contracts/arc58/plugins/akita_social.algo.ts:825
	// xferAsset: AssetID.fromUint64(AKITA_ASSET_ID)
	int 523683256
	itxn_field XferAsset

	// contracts/arc58/plugins/akita_social.algo.ts:826
	// rekeyTo: sender
	frame_dig -1 // sender: Address
	itxn_field RekeyTo

	// contracts/arc58/plugins/akita_social.algo.ts:827
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/arc58/plugins/akita_social.algo.ts:830
	// postID = this.txn.txID as bytes32
	txn TxID
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	frame_bury 1 // postID: byte[32]

	// contracts/arc58/plugins/akita_social.algo.ts:831
	// post: PostValue = {
	//             ref: EMPTY_BYTES32,
	//             cid: cid,
	//             creator: sender,
	//             amendment: EMPTY_BYTES32,
	//             isAmendment: isAmendment,
	//             timestamp: globals.latestTimestamp,
	//             collectible: collectible,
	//             replyFilterIndex: replyFilterIndex,
	//             reactFilterIndex: reactFilterIndex,
	//         }
	byte 0x5858585858585858585858585858585858585858585858585858585858585858 // "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
	frame_dig -2 // cid: bytes59
	concat
	frame_dig -1 // sender: Address
	concat
	byte 0x5858585858585858585858585858585858585858585858585858585858585858 // "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
	concat
	byte 0x00
	int 0
	frame_dig -6 // isAmendment: boolean
	setbit
	concat // 5
	global LatestTimestamp
	itob
	concat
	byte 0x00
	int 0
	frame_dig -3 // collectible: boolean
	setbit
	concat // 7
	frame_dig -4 // replyFilterIndex: uint64
	itob
	concat
	frame_dig -5 // reactFilterIndex: uint64
	itob
	concat
	frame_bury 2 // post: PostValue

	// contracts/arc58/plugins/akita_social.algo.ts:843
	// this.posts(postID).value = post
	byte 0x70 // "p"
	frame_dig 1 // postID: byte[32]
	concat
	frame_dig 2 // post: PostValue
	box_put

	// contracts/arc58/plugins/akita_social.algo.ts:844
	// this.updateVotes(postID, true, impact)
	frame_dig 0 // impact: uint64
	int 1
	frame_dig 1 // postID: byte[32]
	callsub updateVotes

	// contracts/arc58/plugins/akita_social.algo.ts:845
	// this.votelist({ user: sender, ref: postID }).value = { impact: impact, isUp: true }
	frame_dig -1 // sender: Address
	frame_dig 1 // postID: byte[32]
	concat
	frame_dig 0 // impact: uint64
	itob
	byte 0x00
	int 0
	int 1
	setbit
	concat
	box_put
	retsub

// createReply(sender: Address, cid: bytes59, ref: bytes32, collectible: boolean, replyFilterIndex: uint64, reactFilterIndex: uint64, args: bytes[], isAmendment: boolean): void
createReply:
	proto 8 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 5

	// contracts/arc58/plugins/akita_social.algo.ts:858
	// assert(!this.isBanned(sender), errs.BANNED)
	frame_dig -1 // sender: Address
	callsub isBanned
	!
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:859
	// assert(this.posts(ref).exists, errs.POST_NOT_FOUND)
	byte 0x70 // "p"
	frame_dig -3 // ref: bytes32
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:860
	// post = this.posts(ref).value
	byte 0x70 // "p"
	frame_dig -3 // ref: bytes32
	concat
	frame_bury 0 // storage key//post

	// contracts/arc58/plugins/akita_social.algo.ts:861
	// assert(!this.isBlocked(post.creator, sender), errs.BLOCKED)
	frame_dig -1 // sender: Address
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 91 32
	callsub isBlocked
	!
	assert

	// *if27_condition
	// contracts/arc58/plugins/akita_social.algo.ts:863
	// post.replyFilterIndex !== 0
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 165 8
	btoi
	int 0
	!=
	bz *if27_end

	// *if27_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:864
	// assert(this.gate(post.replyFilterIndex, args), errs.DOES_NOT_PASS_GATE)
	frame_dig -7 // args: bytes[]
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 165 8
	btoi
	callsub gate
	assert

*if27_end:
	// contracts/arc58/plugins/akita_social.algo.ts:869
	// this.updateStreak(sender)
	frame_dig -1 // sender: Address
	callsub updateStreak

	// contracts/arc58/plugins/akita_social.algo.ts:871
	// postCreatorImpact = this.userImpact(post.creator)
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 91 32
	callsub userImpact
	frame_bury 1 // postCreatorImpact: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:872
	// tax = this.getTax(postCreatorImpact)
	frame_dig 1 // postCreatorImpact: uint64
	callsub getTax
	frame_bury 2 // tax: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:874
	// this.pendingGroup.addAssetTransfer({
	//             sender: sender,
	//             assetReceiver: AKITA_SOCIAL_TREASURY,
	//             assetAmount: tax,
	//             xferAsset: AssetID.fromUint64(AKITA_ASSET_ID),
	//             fee: 0,
	//         })
	itxn_next
	int axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/akita_social.algo.ts:875
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/akita_social.algo.ts:876
	// assetReceiver: AKITA_SOCIAL_TREASURY
	// contracts/arc58/plugins/akita_social.algo.ts:25
	// addr('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ')
	addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
	itxn_field AssetReceiver

	// contracts/arc58/plugins/akita_social.algo.ts:877
	// assetAmount: tax
	frame_dig 2 // tax: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/akita_social.algo.ts:878
	// xferAsset: AssetID.fromUint64(AKITA_ASSET_ID)
	int 523683256
	itxn_field XferAsset

	// contracts/arc58/plugins/akita_social.algo.ts:879
	// fee: 0
	int 0
	itxn_field Fee

	// contracts/arc58/plugins/akita_social.algo.ts:882
	// this.pendingGroup.addAssetTransfer({
	//             sender: sender,
	//             assetReceiver: post.creator,
	//             assetAmount: (REACT_FEE - tax),
	//             xferAsset: AssetID.fromUint64(AKITA_ASSET_ID),
	//             rekeyTo: sender,
	//             fee: 0,
	//         })
	itxn_next
	int axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/akita_social.algo.ts:883
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/akita_social.algo.ts:884
	// assetReceiver: post.creator
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 91 32
	itxn_field AssetReceiver

	// contracts/arc58/plugins/akita_social.algo.ts:885
	// assetAmount: (REACT_FEE - tax)
	int 10000000
	frame_dig 2 // tax: uint64
	-
	itxn_field AssetAmount

	// contracts/arc58/plugins/akita_social.algo.ts:886
	// xferAsset: AssetID.fromUint64(AKITA_ASSET_ID)
	int 523683256
	itxn_field XferAsset

	// contracts/arc58/plugins/akita_social.algo.ts:887
	// rekeyTo: sender
	frame_dig -1 // sender: Address
	itxn_field RekeyTo

	// contracts/arc58/plugins/akita_social.algo.ts:888
	// fee: 0
	int 0
	itxn_field Fee

	// contracts/arc58/plugins/akita_social.algo.ts:891
	// this.pendingGroup.submit()
	itxn_submit

	// contracts/arc58/plugins/akita_social.algo.ts:893
	// replyPostID = this.txn.txID as bytes32
	txn TxID
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	frame_bury 3 // replyPostID: byte[32]

	// contracts/arc58/plugins/akita_social.algo.ts:894
	// replyPost: PostValue = {
	//             ref: ref,
	//             cid: cid,
	//             creator: sender,
	//             amendment: EMPTY_BYTES32,
	//             isAmendment: isAmendment,
	//             timestamp: globals.latestTimestamp,
	//             collectible: collectible,
	//             replyFilterIndex: replyFilterIndex,
	//             reactFilterIndex: reactFilterIndex,
	//         }
	frame_dig -3 // ref: bytes32
	frame_dig -2 // cid: bytes59
	concat
	frame_dig -1 // sender: Address
	concat
	byte 0x5858585858585858585858585858585858585858585858585858585858585858 // "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
	concat
	byte 0x00
	int 0
	frame_dig -8 // isAmendment: boolean
	setbit
	concat // 5
	global LatestTimestamp
	itob
	concat
	byte 0x00
	int 0
	frame_dig -4 // collectible: boolean
	setbit
	concat // 7
	frame_dig -5 // replyFilterIndex: uint64
	itob
	concat
	frame_dig -6 // reactFilterIndex: uint64
	itob
	concat
	frame_bury 4 // replyPost: PostValue

	// contracts/arc58/plugins/akita_social.algo.ts:906
	// this.posts(replyPostID).value = replyPost
	byte 0x70 // "p"
	frame_dig 3 // replyPostID: byte[32]
	concat
	frame_dig 4 // replyPost: PostValue
	box_put

	// contracts/arc58/plugins/akita_social.algo.ts:908
	// senderImpact = this.userImpact(sender)
	frame_dig -1 // sender: Address
	callsub userImpact
	frame_bury 5 // senderImpact: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:909
	// this.updateVotes(replyPostID, true, senderImpact)
	frame_dig 5 // senderImpact: uint64
	int 1
	frame_dig 3 // replyPostID: byte[32]
	callsub updateVotes

	// contracts/arc58/plugins/akita_social.algo.ts:910
	// this.votelist({ user: sender, ref: replyPostID }).value = { impact: senderImpact, isUp: true }
	frame_dig -1 // sender: Address
	frame_dig 3 // replyPostID: byte[32]
	concat
	frame_dig 5 // senderImpact: uint64
	itob
	byte 0x00
	int 0
	int 1
	setbit
	concat
	box_put
	retsub

// createVote(sender: Address, ref: bytes32, isUp: boolean): void
createVote:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 7

	// contracts/arc58/plugins/akita_social.algo.ts:914
	// assert(!this.isBanned(sender), errs.BANNED)
	frame_dig -1 // sender: Address
	callsub isBanned
	!
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:915
	// assert(this.posts(ref).exists, errs.POST_NOT_FOUND)
	byte 0x70 // "p"
	frame_dig -2 // ref: bytes32
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:917
	// post = this.posts(ref).value
	byte 0x70 // "p"
	frame_dig -2 // ref: bytes32
	concat
	frame_bury 0 // storage key//post

	// contracts/arc58/plugins/akita_social.algo.ts:918
	// assert(!this.isBlocked(post.creator, sender), errs.BLOCKED)
	frame_dig -1 // sender: Address
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 91 32
	callsub isBlocked
	!
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:919
	// assert(!this.votelist({ user: sender, ref: ref }).exists, errs.ALREADY_VOTED)
	frame_dig -1 // sender: Address
	frame_dig -2 // ref: bytes32
	concat
	box_len
	swap
	pop
	!
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:920
	// assert(sender !== post.creator, errs.NO_SELF_VOTE)
	frame_dig -1 // sender: Address
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 91 32
	!=
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:922
	// senderIsAutomated = this.meta(sender).value.automated
	frame_dig -1 // sender: Address
	box_get

	// box value does not exist: this.meta(sender).value
	assert
	store 255 // full array
	load 255 // full array
	int 704
	getbit
	frame_bury 1 // senderIsAutomated: bool

	// contracts/arc58/plugins/akita_social.algo.ts:923
	// assert(!senderIsAutomated, errs.AUTOMATED_ACCOUNT)
	frame_dig 1 // senderIsAutomated: bool
	!
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:927
	// this.updateStreak(sender)
	frame_dig -1 // sender: Address
	callsub updateStreak

	// *if28_condition
	// contracts/arc58/plugins/akita_social.algo.ts:929
	// isUp
	frame_dig -3 // isUp: boolean
	bz *if28_else

	// *if28_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:930
	// postCreatorMeta = this.meta(post.creator).value
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 91 32
	frame_bury 2 // storage key//postCreatorMeta

	// contracts/arc58/plugins/akita_social.algo.ts:932
	// recipientImpact = this.userImpact(post.creator)
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 91 32
	callsub userImpact
	frame_bury 3 // recipientImpact: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:933
	// tax = this.getTax(recipientImpact)
	frame_dig 3 // recipientImpact: uint64
	callsub getTax
	frame_bury 4 // tax: uint64

	// *if29_condition
	// contracts/arc58/plugins/akita_social.algo.ts:935
	// !post.creator.isOptedInToAsset(AKITA_ASSET_ID)
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 91 32
	int 523683256
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if29_else

	// *if29_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:937
	// canCallArc58OptIn = this.canCallArc58OptIn(sender, postCreatorMeta.walletAppID)
	frame_dig 2 // storage key//postCreatorMeta
	box_get

	// box value does not exist: this.meta(post.creator).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	frame_dig -1 // sender: Address
	callsub canCallArc58OptIn
	frame_bury 5 // canCallArc58OptIn: bool

	// *if30_condition
	// contracts/arc58/plugins/akita_social.algo.ts:938
	// canCallArc58OptIn
	frame_dig 5 // canCallArc58OptIn: bool
	bz *if30_else

	// *if30_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:940
	// this.arc58OptInAndSendReactionPayments(sender, postCreatorMeta.walletAppID, tax)
	frame_dig 4 // tax: uint64
	frame_dig 2 // storage key//postCreatorMeta
	box_get

	// box value does not exist: this.meta(post.creator).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	frame_dig -1 // sender: Address
	callsub arc58OptInAndSendReactionPayments
	b *if30_end

*if30_else:
	// contracts/arc58/plugins/akita_social.algo.ts:943
	// this.arc59OptInAndSendReactionPayments(sender, postCreatorMeta.walletAppID, tax)
	frame_dig 4 // tax: uint64
	frame_dig 2 // storage key//postCreatorMeta
	box_get

	// box value does not exist: this.meta(post.creator).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	frame_dig -1 // sender: Address
	callsub arc59OptInAndSendReactionPayments

*if30_end:
	b *if29_end

*if29_else:
	// contracts/arc58/plugins/akita_social.algo.ts:947
	// address = postCreatorMeta.walletAppID.globalState(ARC58_CONTROLLED_ADDRESS_KEY) as Address
	frame_dig 2 // storage key//postCreatorMeta
	box_get

	// box value does not exist: this.meta(post.creator).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	byte "c"
	app_global_get_ex

	// global state value does not exist: postCreatorMeta.walletAppID.globalState(ARC58_CONTROLLED_ADDRESS_KEY)
	assert
	frame_bury 6 // address: address

	// contracts/arc58/plugins/akita_social.algo.ts:948
	// this.sendReactionPayments(sender, address, tax)
	frame_dig 4 // tax: uint64
	frame_dig 6 // address: address
	frame_dig -1 // sender: Address
	callsub sendReactionPayments

*if29_end:
	b *if28_end

*if28_else:
	// contracts/arc58/plugins/akita_social.algo.ts:951
	// sendAssetTransfer({
	//                 sender: sender,
	//                 assetReceiver: AKITA_SOCIAL_TREASURY,
	//                 assetAmount: REACT_FEE,
	//                 xferAsset: AssetID.fromUint64(AKITA_ASSET_ID),
	//                 rekeyTo: sender,
	//                 fee: 0,
	//             })
	itxn_begin
	int axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/akita_social.algo.ts:952
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/akita_social.algo.ts:953
	// assetReceiver: AKITA_SOCIAL_TREASURY
	// contracts/arc58/plugins/akita_social.algo.ts:25
	// addr('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ')
	addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
	itxn_field AssetReceiver

	// contracts/arc58/plugins/akita_social.algo.ts:954
	// assetAmount: REACT_FEE
	int 10000000
	itxn_field AssetAmount

	// contracts/arc58/plugins/akita_social.algo.ts:955
	// xferAsset: AssetID.fromUint64(AKITA_ASSET_ID)
	int 523683256
	itxn_field XferAsset

	// contracts/arc58/plugins/akita_social.algo.ts:956
	// rekeyTo: sender
	frame_dig -1 // sender: Address
	itxn_field RekeyTo

	// contracts/arc58/plugins/akita_social.algo.ts:957
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if28_end:
	// contracts/arc58/plugins/akita_social.algo.ts:962
	// senderImpact = this.userImpact(sender)
	frame_dig -1 // sender: Address
	callsub userImpact
	frame_bury 7 // senderImpact: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:963
	// this.updateVotes(ref, isUp, senderImpact)
	frame_dig 7 // senderImpact: uint64
	frame_dig -3 // isUp: boolean
	frame_dig -2 // ref: bytes32
	callsub updateVotes

	// contracts/arc58/plugins/akita_social.algo.ts:964
	// this.votelist({ user: sender, ref: ref }).value = { impact: senderImpact, isUp: isUp }
	frame_dig -1 // sender: Address
	frame_dig -2 // ref: bytes32
	concat
	frame_dig 7 // senderImpact: uint64
	itob
	byte 0x00
	int 0
	frame_dig -3 // isUp: boolean
	setbit
	concat
	box_put
	retsub

// createReaction(sender: Address, ref: bytes32, NFT: AssetID, args: bytes[]): void
createReaction:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 7

	// contracts/arc58/plugins/akita_social.algo.ts:968
	// assert(!this.isBanned(sender), errs.BANNED)
	frame_dig -1 // sender: Address
	callsub isBanned
	!
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:969
	// assert(this.posts(ref).exists, errs.POST_NOT_FOUND)
	byte 0x70 // "p"
	frame_dig -2 // ref: bytes32
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:970
	// post = this.posts(ref).value
	byte 0x70 // "p"
	frame_dig -2 // ref: bytes32
	concat
	frame_bury 0 // storage key//post

	// contracts/arc58/plugins/akita_social.algo.ts:971
	// assert(!this.isBlocked(post.creator, sender), errs.BLOCKED)
	frame_dig -1 // sender: Address
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 91 32
	callsub isBlocked
	!
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:972
	// assert(sender.assetBalance(NFT) > 0, errs.USER_DOES_NOT_OWN_NFT)
	frame_dig -1 // sender: Address
	frame_dig -3 // NFT: AssetID
	asset_holding_get AssetBalance
	pop
	int 0
	>
	assert

	// *if31_condition
	// contracts/arc58/plugins/akita_social.algo.ts:974
	// post.reactFilterIndex !== 0
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 173 8
	btoi
	int 0
	!=
	bz *if31_end

	// *if31_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:975
	// assert(this.gate(post.reactFilterIndex, args), errs.DOES_NOT_PASS_GATE)
	frame_dig -4 // args: bytes[]
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 173 8
	btoi
	callsub gate
	assert

*if31_end:
	// contracts/arc58/plugins/akita_social.algo.ts:978
	// reactionListKey: ReactionListKey = {
	//             user: rawBytes(sender).substring(0, 24) as bytes24,
	//             ref: rawBytes(ref).substring(0, 24) as bytes24,
	//             NFT: NFT
	//         }
	frame_dig -1 // sender: Address
	substring 0 24
	byte 0x000000000000000000000000000000000000000000000000
	concat
	dup
	extract 24 0
	byte 0x
	b==
	assert
	extract 0 24
	frame_dig -2 // ref: bytes32
	substring 0 24
	byte 0x000000000000000000000000000000000000000000000000
	concat
	dup
	extract 24 0
	byte 0x
	b==
	assert
	extract 0 24
	concat
	frame_dig -3 // NFT: AssetID
	itob
	concat
	frame_bury 1 // reactionListKey: ReactionListKey

	// contracts/arc58/plugins/akita_social.algo.ts:984
	// assert(!this.reactionlist(reactionListKey).exists, errs.ALREADY_REACTED)
	frame_dig 1 // reactionListKey: ReactionListKey
	box_len
	swap
	pop
	!
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:988
	// this.updateStreak(sender)
	frame_dig -1 // sender: Address
	callsub updateStreak

	// contracts/arc58/plugins/akita_social.algo.ts:990
	// creatorMeta = this.meta(post.creator).value
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 91 32
	frame_bury 2 // storage key//creatorMeta

	// contracts/arc58/plugins/akita_social.algo.ts:991
	// recipientImpact = this.userImpact(post.creator)
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 91 32
	callsub userImpact
	frame_bury 3 // recipientImpact: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:992
	// tax = this.getTax(recipientImpact)
	frame_dig 3 // recipientImpact: uint64
	callsub getTax
	frame_bury 4 // tax: uint64

	// *if32_condition
	// contracts/arc58/plugins/akita_social.algo.ts:994
	// !post.creator.isOptedInToAsset(AKITA_ASSET_ID)
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 91 32
	int 523683256
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if32_else

	// *if32_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:995
	// canCallArc58OptIn = this.canCallArc58OptIn(sender, creatorMeta.walletAppID)
	frame_dig 2 // storage key//creatorMeta
	box_get

	// box value does not exist: this.meta(post.creator).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	frame_dig -1 // sender: Address
	callsub canCallArc58OptIn
	frame_bury 5 // canCallArc58OptIn: bool

	// *if33_condition
	// contracts/arc58/plugins/akita_social.algo.ts:996
	// canCallArc58OptIn
	frame_dig 5 // canCallArc58OptIn: bool
	bz *if33_else

	// *if33_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:997
	// this.arc58OptInAndSendReactionPayments(sender, creatorMeta.walletAppID, tax)
	frame_dig 4 // tax: uint64
	frame_dig 2 // storage key//creatorMeta
	box_get

	// box value does not exist: this.meta(post.creator).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	frame_dig -1 // sender: Address
	callsub arc58OptInAndSendReactionPayments
	b *if33_end

*if33_else:
	// contracts/arc58/plugins/akita_social.algo.ts:999
	// this.arc59OptInAndSendReactionPayments(sender, creatorMeta.walletAppID, tax)
	frame_dig 4 // tax: uint64
	frame_dig 2 // storage key//creatorMeta
	box_get

	// box value does not exist: this.meta(post.creator).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	frame_dig -1 // sender: Address
	callsub arc59OptInAndSendReactionPayments

*if33_end:
	b *if32_end

*if32_else:
	// contracts/arc58/plugins/akita_social.algo.ts:1002
	// address = creatorMeta.walletAppID.globalState(ARC58_CONTROLLED_ADDRESS_KEY) as Address
	frame_dig 2 // storage key//creatorMeta
	box_get

	// box value does not exist: this.meta(post.creator).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	byte "c"
	app_global_get_ex

	// global state value does not exist: creatorMeta.walletAppID.globalState(ARC58_CONTROLLED_ADDRESS_KEY)
	assert
	frame_bury 6 // address: address

	// contracts/arc58/plugins/akita_social.algo.ts:1003
	// this.sendReactionPayments(sender, address, tax)
	frame_dig 4 // tax: uint64
	frame_dig 6 // address: address
	frame_dig -1 // sender: Address
	callsub sendReactionPayments

*if32_end:
	// contracts/arc58/plugins/akita_social.algo.ts:1006
	// reactionExists = this.reactions({ ref: ref, NFT: NFT }).exists
	byte 0x72 // "r"
	frame_dig -2 // ref: bytes32
	frame_dig -3 // NFT: AssetID
	itob
	concat
	concat
	box_len
	swap
	pop
	frame_bury 7 // reactionExists: bool

	// *if34_condition
	// contracts/arc58/plugins/akita_social.algo.ts:1007
	// reactionExists
	frame_dig 7 // reactionExists: bool
	bz *if34_else

	// *if34_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:1008
	// this.reactions({ ref: ref, NFT: NFT }).value += 1
	byte 0x72 // "r"
	frame_dig -2 // ref: bytes32
	frame_dig -3 // NFT: AssetID
	itob
	concat
	concat
	box_get

	// box value does not exist: this.reactions({ ref: ref, NFT: NFT }).value
	assert
	btoi
	int 1
	+
	byte 0x72 // "r"
	frame_dig -2 // ref: bytes32
	frame_dig -3 // NFT: AssetID
	itob
	concat
	concat
	swap
	itob
	box_put
	b *if34_end

*if34_else:
	// contracts/arc58/plugins/akita_social.algo.ts:1010
	// this.reactions({ ref: ref, NFT: NFT }).value = 1
	byte 0x72 // "r"
	frame_dig -2 // ref: bytes32
	frame_dig -3 // NFT: AssetID
	itob
	concat
	concat
	byte 0x0000000000000001
	box_put

*if34_end:
	// contracts/arc58/plugins/akita_social.algo.ts:1013
	// this.reactionlist(reactionListKey).create(0)
	frame_dig 1 // reactionListKey: ReactionListKey
	int 0
	box_create
	pop
	retsub

// post(address,byte[59],bool,uint64,uint64)void
*abi_route_post:
	// reactFilterIndex: uint64
	txna ApplicationArgs 5
	btoi

	// replyFilterIndex: uint64
	txna ApplicationArgs 4
	btoi

	// collectible: bool
	txna ApplicationArgs 3
	dup
	len
	int 1
	==

	// argument 2 (collectible) for post must be a bool
	assert
	int 0
	getbit

	// cid: byte[59]
	txna ApplicationArgs 2
	dup
	len
	int 59
	==

	// argument 3 (cid) for post must be a byte[59]
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 4 (sender) for post must be a address
	assert

	// execute post(address,byte[59],bool,uint64,uint64)void
	callsub post
	int 1
	return

// post(sender: Address, cid: bytes59, collectible: boolean, replyFilterIndex: uint64, reactFilterIndex: uint64): void
post:
	proto 5 0

	// contracts/arc58/plugins/akita_social.algo.ts:1027
	// this.createPost(sender, cid, collectible, replyFilterIndex, reactFilterIndex, false)
	int 0
	frame_dig -5 // reactFilterIndex: uint64
	frame_dig -4 // replyFilterIndex: uint64
	frame_dig -3 // collectible: boolean
	frame_dig -2 // cid: bytes59
	frame_dig -1 // sender: Address
	callsub createPost
	retsub

// editPost(address,byte[59],bool,uint64,uint64,byte[32])void
*abi_route_editPost:
	// amendment: byte[32]
	txna ApplicationArgs 6
	dup
	len
	int 32
	==

	// argument 0 (amendment) for editPost must be a byte[32]
	assert

	// reactFilterIndex: uint64
	txna ApplicationArgs 5
	btoi

	// replyFilterIndex: uint64
	txna ApplicationArgs 4
	btoi

	// collectible: bool
	txna ApplicationArgs 3
	dup
	len
	int 1
	==

	// argument 3 (collectible) for editPost must be a bool
	assert
	int 0
	getbit

	// cid: byte[59]
	txna ApplicationArgs 2
	dup
	len
	int 59
	==

	// argument 4 (cid) for editPost must be a byte[59]
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 5 (sender) for editPost must be a address
	assert

	// execute editPost(address,byte[59],bool,uint64,uint64,byte[32])void
	callsub editPost
	int 1
	return

// editPost(sender: Address, cid: bytes59, collectible: boolean, replyFilterIndex: uint64, reactFilterIndex: uint64, amendment: bytes32): void
editPost:
	proto 6 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/arc58/plugins/akita_social.algo.ts:1038
	// assert(this.posts(amendment).exists, errs.POST_NOT_FOUND)
	byte 0x70 // "p"
	frame_dig -6 // amendment: bytes32
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1039
	// post = clone(this.posts(amendment).value)
	byte 0x70 // "p"
	frame_dig -6 // amendment: bytes32
	concat
	box_get

	// box value does not exist: this.posts(amendment).value
	assert
	frame_bury 0 // post: (byte[32],byte[59],address,byte[32],bool,uint64,bool,uint64,uint64)

	// contracts/arc58/plugins/akita_social.algo.ts:1040
	// assert(post.creator === sender, errs.NOT_YOUR_POST_TO_EDIT)
	frame_dig 0 // post: (byte[32],byte[59],address,byte[32],bool,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	extract 91 32
	frame_dig -1 // sender: Address
	==
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1041
	// assert(post.ref === EMPTY_BYTES32)
	frame_dig 0 // post: (byte[32],byte[59],address,byte[32],bool,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	extract 0 32
	byte 0x5858585858585858585858585858585858585858585858585858585858585858 // "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
	==
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1043
	// this.posts(amendment).value = {
	//             ref: post.ref,
	//             cid: post.cid,
	//             creator: post.creator,
	//             amendment: this.txn.txID as bytes32,
	//             isAmendment: post.isAmendment,
	//             timestamp: post.timestamp,
	//             collectible: false,
	//             replyFilterIndex: post.replyFilterIndex,
	//             reactFilterIndex: post.reactFilterIndex
	//         }
	byte 0x70 // "p"
	frame_dig -6 // amendment: bytes32
	concat
	frame_dig 0 // post: (byte[32],byte[59],address,byte[32],bool,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	extract 0 32
	frame_dig 0 // post: (byte[32],byte[59],address,byte[32],bool,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	extract 32 59
	concat
	frame_dig 0 // post: (byte[32],byte[59],address,byte[32],bool,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	extract 91 32
	concat
	txn TxID
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	concat
	byte 0x00
	int 0
	frame_dig 0 // post: (byte[32],byte[59],address,byte[32],bool,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	int 1240
	getbit
	setbit
	concat // 5
	frame_dig 0 // post: (byte[32],byte[59],address,byte[32],bool,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	extract 156 8
	btoi
	itob
	concat
	byte 0x00
	int 0
	dup
	setbit
	concat // 7
	frame_dig 0 // post: (byte[32],byte[59],address,byte[32],bool,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	extract 165 8
	btoi
	itob
	concat
	frame_dig 0 // post: (byte[32],byte[59],address,byte[32],bool,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	extract 173 8
	btoi
	itob
	concat
	box_put

	// contracts/arc58/plugins/akita_social.algo.ts:1055
	// this.createPost(sender, cid, collectible, replyFilterIndex, reactFilterIndex, true)
	int 1
	frame_dig -5 // reactFilterIndex: uint64
	frame_dig -4 // replyFilterIndex: uint64
	frame_dig -3 // collectible: boolean
	frame_dig -2 // cid: bytes59
	frame_dig -1 // sender: Address
	callsub createPost
	retsub

// replyPost(address,byte[59],byte[32],bool,uint64,uint64,byte[][])void
*abi_route_replyPost:
	// args: byte[][]
	txna ApplicationArgs 7

	// reactFilterIndex: uint64
	txna ApplicationArgs 6
	btoi

	// replyFilterIndex: uint64
	txna ApplicationArgs 5
	btoi

	// collectible: bool
	txna ApplicationArgs 4
	dup
	len
	int 1
	==

	// argument 3 (collectible) for replyPost must be a bool
	assert
	int 0
	getbit

	// ref: byte[32]
	txna ApplicationArgs 3
	dup
	len
	int 32
	==

	// argument 4 (ref) for replyPost must be a byte[32]
	assert

	// cid: byte[59]
	txna ApplicationArgs 2
	dup
	len
	int 59
	==

	// argument 5 (cid) for replyPost must be a byte[59]
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 6 (sender) for replyPost must be a address
	assert

	// execute replyPost(address,byte[59],byte[32],bool,uint64,uint64,byte[][])void
	callsub replyPost
	int 1
	return

// replyPost(sender: Address, cid: bytes59, ref: bytes32, collectible: boolean, replyFilterIndex: uint64, reactFilterIndex: uint64, args: bytes[]): void
replyPost:
	proto 7 0

	// contracts/arc58/plugins/akita_social.algo.ts:1067
	// this.createReply(sender, cid, ref, collectible, replyFilterIndex, reactFilterIndex, args, false)
	int 0
	frame_dig -7 // args: bytes[]
	frame_dig -6 // reactFilterIndex: uint64
	frame_dig -5 // replyFilterIndex: uint64
	frame_dig -4 // collectible: boolean
	frame_dig -3 // ref: bytes32
	frame_dig -2 // cid: bytes59
	frame_dig -1 // sender: Address
	callsub createReply
	retsub

// replyAsset(address,byte[59],uint64,bool,uint64,uint64)void
*abi_route_replyAsset:
	// reactFilterIndex: uint64
	txna ApplicationArgs 6
	btoi

	// replyFilterIndex: uint64
	txna ApplicationArgs 5
	btoi

	// collectible: bool
	txna ApplicationArgs 4
	dup
	len
	int 1
	==

	// argument 2 (collectible) for replyAsset must be a bool
	assert
	int 0
	getbit

	// ref: uint64
	txna ApplicationArgs 3
	btoi

	// cid: byte[59]
	txna ApplicationArgs 2
	dup
	len
	int 59
	==

	// argument 4 (cid) for replyAsset must be a byte[59]
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 5 (sender) for replyAsset must be a address
	assert

	// execute replyAsset(address,byte[59],uint64,bool,uint64,uint64)void
	callsub replyAsset
	int 1
	return

// replyAsset(sender: Address, cid: bytes59, ref: AssetID, collectible: boolean, replyFilterIndex: uint64, reactFilterIndex: uint64): void
replyAsset:
	proto 6 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/arc58/plugins/akita_social.algo.ts:1078
	// assert(ref.id !== 0, errs.INVALID_ASSET)
	frame_dig -3 // ref: AssetID
	int 0
	!=
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1079
	// paddedRef = itob(ref.id) as bytes32
	frame_dig -3 // ref: AssetID
	itob
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	frame_bury 0 // paddedRef: byte[32]

	// contracts/arc58/plugins/akita_social.algo.ts:1080
	// this.createEmptyPostIfNecessary(paddedRef, ref.creator)
	frame_dig -3 // ref: AssetID
	asset_params_get AssetCreator
	pop
	frame_dig 0 // paddedRef: byte[32]
	callsub createEmptyPostIfNecessary

	// contracts/arc58/plugins/akita_social.algo.ts:1081
	// this.createReply(sender, cid, paddedRef, collectible, replyFilterIndex, reactFilterIndex, [], false)
	int 0
	byte 0x
	frame_dig -6 // reactFilterIndex: uint64
	frame_dig -5 // replyFilterIndex: uint64
	frame_dig -4 // collectible: boolean
	frame_dig 0 // paddedRef: byte[32]
	frame_dig -2 // cid: bytes59
	frame_dig -1 // sender: Address
	callsub createReply
	retsub

// replyAddress(address,byte[59],address,bool,uint64,uint64,byte[][])void
*abi_route_replyAddress:
	// args: byte[][]
	txna ApplicationArgs 7

	// reactFilterIndex: uint64
	txna ApplicationArgs 6
	btoi

	// replyFilterIndex: uint64
	txna ApplicationArgs 5
	btoi

	// collectible: bool
	txna ApplicationArgs 4
	dup
	len
	int 1
	==

	// argument 3 (collectible) for replyAddress must be a bool
	assert
	int 0
	getbit

	// ref: address
	txna ApplicationArgs 3
	dup
	len
	int 32
	==

	// argument 4 (ref) for replyAddress must be a address
	assert

	// cid: byte[59]
	txna ApplicationArgs 2
	dup
	len
	int 59
	==

	// argument 5 (cid) for replyAddress must be a byte[59]
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 6 (sender) for replyAddress must be a address
	assert

	// execute replyAddress(address,byte[59],address,bool,uint64,uint64,byte[][])void
	callsub replyAddress
	int 1
	return

// replyAddress(sender: Address, cid: bytes59, ref: Address, collectible: boolean, replyFilterIndex: uint64, reactFilterIndex: uint64, args: bytes[]): void
replyAddress:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// *if35_condition
	// contracts/arc58/plugins/akita_social.algo.ts:1094
	// this.meta(ref).exists
	frame_dig -3 // ref: Address
	box_len
	swap
	pop
	bz *if35_end

	// *if35_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:1095
	// meta = this.meta(ref).value
	frame_dig -3 // ref: Address
	frame_bury 0 // storage key//meta

	// *if36_condition
	// contracts/arc58/plugins/akita_social.algo.ts:1097
	// meta.addressFilterIndex !== 0
	frame_dig 0 // storage key//meta
	box_get

	// box value does not exist: this.meta(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 97 8
	btoi
	int 0
	!=
	bz *if36_end

	// *if36_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:1098
	// assert(this.gate(meta.addressFilterIndex, args), errs.DOES_NOT_PASS_GATE)
	frame_dig -7 // args: bytes[]
	frame_dig 0 // storage key//meta
	box_get

	// box value does not exist: this.meta(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 97 8
	btoi
	callsub gate
	assert

*if36_end:

*if35_end:
	// contracts/arc58/plugins/akita_social.algo.ts:1102
	// r = rawBytes(ref) as bytes32
	frame_dig -3 // ref: Address
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	frame_bury 1 // r: byte[32]

	// contracts/arc58/plugins/akita_social.algo.ts:1103
	// this.createEmptyPostIfNecessary(r, ref)
	frame_dig -3 // ref: Address
	frame_dig 1 // r: byte[32]
	callsub createEmptyPostIfNecessary

	// contracts/arc58/plugins/akita_social.algo.ts:1104
	// this.createReply(sender, cid, r, collectible, replyFilterIndex, reactFilterIndex, [], false)
	int 0
	byte 0x
	frame_dig -6 // reactFilterIndex: uint64
	frame_dig -5 // replyFilterIndex: uint64
	frame_dig -4 // collectible: boolean
	frame_dig 1 // r: byte[32]
	frame_dig -2 // cid: bytes59
	frame_dig -1 // sender: Address
	callsub createReply
	retsub

// replyApp(address,byte[59],uint64,bool,uint64,uint64)void
*abi_route_replyApp:
	// reactFilterIndex: uint64
	txna ApplicationArgs 6
	btoi

	// replyFilterIndex: uint64
	txna ApplicationArgs 5
	btoi

	// collectible: bool
	txna ApplicationArgs 4
	dup
	len
	int 1
	==

	// argument 2 (collectible) for replyApp must be a bool
	assert
	int 0
	getbit

	// ref: uint64
	txna ApplicationArgs 3
	btoi

	// cid: byte[59]
	txna ApplicationArgs 2
	dup
	len
	int 59
	==

	// argument 4 (cid) for replyApp must be a byte[59]
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 5 (sender) for replyApp must be a address
	assert

	// execute replyApp(address,byte[59],uint64,bool,uint64,uint64)void
	callsub replyApp
	int 1
	return

// replyApp(sender: Address, cid: bytes59, ref: AppID, collectible: boolean, replyFilterIndex: uint64, reactFilterIndex: uint64): void
replyApp:
	proto 6 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/arc58/plugins/akita_social.algo.ts:1115
	// assert(ref.id !== 0, errs.INVALID_APP)
	frame_dig -3 // ref: AppID
	int 0
	!=
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1116
	// paddedRef = itob(ref.id) as bytes32
	frame_dig -3 // ref: AppID
	itob
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	frame_bury 0 // paddedRef: byte[32]

	// contracts/arc58/plugins/akita_social.algo.ts:1117
	// this.createEmptyPostIfNecessary(paddedRef, ref.creator)
	frame_dig -3 // ref: AppID
	app_params_get AppCreator
	pop
	frame_dig 0 // paddedRef: byte[32]
	callsub createEmptyPostIfNecessary

	// contracts/arc58/plugins/akita_social.algo.ts:1118
	// this.createReply(sender, cid, paddedRef, collectible, replyFilterIndex, reactFilterIndex, [], false)
	int 0
	byte 0x
	frame_dig -6 // reactFilterIndex: uint64
	frame_dig -5 // replyFilterIndex: uint64
	frame_dig -4 // collectible: boolean
	frame_dig 0 // paddedRef: byte[32]
	frame_dig -2 // cid: bytes59
	frame_dig -1 // sender: Address
	callsub createReply
	retsub

// editReply(address,byte[59],bool,uint64,uint64,byte[][],byte[32])void
*abi_route_editReply:
	// amendment: byte[32]
	txna ApplicationArgs 7
	dup
	len
	int 32
	==

	// argument 0 (amendment) for editReply must be a byte[32]
	assert

	// args: byte[][]
	txna ApplicationArgs 6

	// reactFilterIndex: uint64
	txna ApplicationArgs 5
	btoi

	// replyFilterIndex: uint64
	txna ApplicationArgs 4
	btoi

	// collectible: bool
	txna ApplicationArgs 3
	dup
	len
	int 1
	==

	// argument 4 (collectible) for editReply must be a bool
	assert
	int 0
	getbit

	// cid: byte[59]
	txna ApplicationArgs 2
	dup
	len
	int 59
	==

	// argument 5 (cid) for editReply must be a byte[59]
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 6 (sender) for editReply must be a address
	assert

	// execute editReply(address,byte[59],bool,uint64,uint64,byte[][],byte[32])void
	callsub editReply
	int 1
	return

// editReply(sender: Address, cid: bytes59, collectible: boolean, replyFilterIndex: uint64, reactFilterIndex: uint64, args: bytes[], amendment: bytes32): void
editReply:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/arc58/plugins/akita_social.algo.ts:1130
	// assert(this.posts(amendment).exists, errs.REPLY_NOT_FOUND)
	byte 0x70 // "p"
	frame_dig -7 // amendment: bytes32
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1131
	// post = this.posts(amendment).value
	byte 0x70 // "p"
	frame_dig -7 // amendment: bytes32
	concat
	frame_bury 0 // storage key//post

	// contracts/arc58/plugins/akita_social.algo.ts:1132
	// assert(post.creator === sender, errs.NOT_YOUR_POST_TO_EDIT)
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(amendment).value
	assert
	store 255 // full array
	load 255 // full array
	extract 91 32
	frame_dig -1 // sender: Address
	==
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1133
	// assert(post.ref !== EMPTY_BYTES32, errs.NOT_A_REPLY)
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(amendment).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 32
	byte 0x5858585858585858585858585858585858585858585858585858585858585858 // "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
	!=
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1134
	// this.posts(amendment).value.amendment = this.txn.txID
	byte 0x70 // "p"
	frame_dig -7 // amendment: bytes32
	concat
	box_get

	// box value does not exist: this.posts(amendment).value
	assert
	store 255 // full array
	load 255 // full array
	int 123
	txn TxID
	dup
	len
	itob
	extract 6 2
	swap
	concat
	byte 0x70 // "p"
	frame_dig -7 // amendment: bytes32
	concat
	cover 2
	box_replace

	// contracts/arc58/plugins/akita_social.algo.ts:1135
	// this.createReply(sender, cid, post.ref, collectible, replyFilterIndex, reactFilterIndex, args, true)
	int 1
	frame_dig -6 // args: bytes[]
	frame_dig -5 // reactFilterIndex: uint64
	frame_dig -4 // replyFilterIndex: uint64
	frame_dig -3 // collectible: boolean
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(amendment).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 32
	frame_dig -2 // cid: bytes59
	frame_dig -1 // sender: Address
	callsub createReply
	retsub

// votePost(address,byte[32],bool)void
*abi_route_votePost:
	// isUp: bool
	txna ApplicationArgs 3
	dup
	len
	int 1
	==

	// argument 0 (isUp) for votePost must be a bool
	assert
	int 0
	getbit

	// ref: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 1 (ref) for votePost must be a byte[32]
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (sender) for votePost must be a address
	assert

	// execute votePost(address,byte[32],bool)void
	callsub votePost
	int 1
	return

// votePost(sender: Address, ref: bytes32, isUp: boolean): void
votePost:
	proto 3 0

	// contracts/arc58/plugins/akita_social.algo.ts:1139
	// this.createVote(sender, ref, isUp)
	frame_dig -3 // isUp: boolean
	frame_dig -2 // ref: bytes32
	frame_dig -1 // sender: Address
	callsub createVote
	retsub

// voteAsset(address,uint64,bool)void
*abi_route_voteAsset:
	// isUp: bool
	txna ApplicationArgs 3
	dup
	len
	int 1
	==

	// argument 0 (isUp) for voteAsset must be a bool
	assert
	int 0
	getbit

	// ref: uint64
	txna ApplicationArgs 2
	btoi

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (sender) for voteAsset must be a address
	assert

	// execute voteAsset(address,uint64,bool)void
	callsub voteAsset
	int 1
	return

// voteAsset(sender: Address, ref: AssetID, isUp: boolean): void
voteAsset:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/arc58/plugins/akita_social.algo.ts:1143
	// assert(ref.id !== 0, errs.INVALID_ASSET)
	frame_dig -2 // ref: AssetID
	int 0
	!=
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1144
	// paddedRef = itob(ref.id) as bytes32
	frame_dig -2 // ref: AssetID
	itob
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	frame_bury 0 // paddedRef: byte[32]

	// contracts/arc58/plugins/akita_social.algo.ts:1145
	// this.createEmptyPostIfNecessary(paddedRef, ref.creator)
	frame_dig -2 // ref: AssetID
	asset_params_get AssetCreator
	pop
	frame_dig 0 // paddedRef: byte[32]
	callsub createEmptyPostIfNecessary

	// contracts/arc58/plugins/akita_social.algo.ts:1146
	// this.createVote(sender, paddedRef, isUp)
	frame_dig -3 // isUp: boolean
	frame_dig 0 // paddedRef: byte[32]
	frame_dig -1 // sender: Address
	callsub createVote
	retsub

// voteAddress(address,address,bool)void
*abi_route_voteAddress:
	// isUp: bool
	txna ApplicationArgs 3
	dup
	len
	int 1
	==

	// argument 0 (isUp) for voteAddress must be a bool
	assert
	int 0
	getbit

	// ref: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 1 (ref) for voteAddress must be a address
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (sender) for voteAddress must be a address
	assert

	// execute voteAddress(address,address,bool)void
	callsub voteAddress
	int 1
	return

// voteAddress(sender: Address, ref: Address, isUp: boolean): void
voteAddress:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/arc58/plugins/akita_social.algo.ts:1150
	// r = rawBytes(ref) as bytes32
	frame_dig -2 // ref: Address
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	frame_bury 0 // r: byte[32]

	// contracts/arc58/plugins/akita_social.algo.ts:1151
	// this.createEmptyPostIfNecessary(r, ref)
	frame_dig -2 // ref: Address
	frame_dig 0 // r: byte[32]
	callsub createEmptyPostIfNecessary

	// contracts/arc58/plugins/akita_social.algo.ts:1152
	// this.createVote(sender, r, isUp)
	frame_dig -3 // isUp: boolean
	frame_dig 0 // r: byte[32]
	frame_dig -1 // sender: Address
	callsub createVote
	retsub

// voteApp(address,uint64,bool)void
*abi_route_voteApp:
	// isUp: bool
	txna ApplicationArgs 3
	dup
	len
	int 1
	==

	// argument 0 (isUp) for voteApp must be a bool
	assert
	int 0
	getbit

	// ref: uint64
	txna ApplicationArgs 2
	btoi

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (sender) for voteApp must be a address
	assert

	// execute voteApp(address,uint64,bool)void
	callsub voteApp
	int 1
	return

// voteApp(sender: Address, ref: AppID, isUp: boolean): void
voteApp:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/arc58/plugins/akita_social.algo.ts:1156
	// assert(ref.id !== 0, errs.INVALID_APP)
	frame_dig -2 // ref: AppID
	int 0
	!=
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1157
	// paddedRef = itob(ref.id) as bytes32
	frame_dig -2 // ref: AppID
	itob
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	frame_bury 0 // paddedRef: byte[32]

	// contracts/arc58/plugins/akita_social.algo.ts:1158
	// this.createEmptyPostIfNecessary(paddedRef, ref.creator)
	frame_dig -2 // ref: AppID
	app_params_get AppCreator
	pop
	frame_dig 0 // paddedRef: byte[32]
	callsub createEmptyPostIfNecessary

	// contracts/arc58/plugins/akita_social.algo.ts:1159
	// this.createVote(sender, paddedRef, isUp)
	frame_dig -3 // isUp: boolean
	frame_dig 0 // paddedRef: byte[32]
	frame_dig -1 // sender: Address
	callsub createVote
	retsub

// editVote(address,byte[32],bool)void
*abi_route_editVote:
	// flip: bool
	txna ApplicationArgs 3
	dup
	len
	int 1
	==

	// argument 0 (flip) for editVote must be a bool
	assert
	int 0
	getbit

	// ref: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 1 (ref) for editVote must be a byte[32]
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (sender) for editVote must be a address
	assert

	// execute editVote(address,byte[32],bool)void
	callsub editVote
	int 1
	return

// editVote(sender: Address, ref: bytes32, flip: boolean): void
editVote:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// contracts/arc58/plugins/akita_social.algo.ts:1163
	// voteListKey: VoteListKey = { user: sender, ref: ref }
	frame_dig -1 // sender: Address
	frame_dig -2 // ref: bytes32
	concat
	frame_bury 0 // voteListKey: VoteListKey

	// contracts/arc58/plugins/akita_social.algo.ts:1164
	// assert(this.votelist(voteListKey).exists, errs.HAVENT_VOTED)
	frame_dig 0 // voteListKey: VoteListKey
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1166
	// voteListData = this.votelist(voteListKey).value
	frame_dig 0 // voteListKey: VoteListKey
	frame_bury 1 // storage key//voteListData

	// contracts/arc58/plugins/akita_social.algo.ts:1167
	// impact = voteListData.impact
	frame_dig 1 // storage key//voteListData
	box_get

	// box value does not exist: this.votelist(voteListKey).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	frame_bury 2 // impact: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:1168
	// isUp = voteListData.isUp
	frame_dig 1 // storage key//voteListData
	box_get

	// box value does not exist: this.votelist(voteListKey).value
	assert
	store 255 // full array
	load 255 // full array
	int 64
	getbit
	frame_bury 3 // isUp: bool

	// contracts/arc58/plugins/akita_social.algo.ts:1171
	// this.updateVotes(ref, !isUp, impact)
	frame_dig 2 // impact: uint64
	frame_dig 3 // isUp: bool
	!
	frame_dig -2 // ref: bytes32
	callsub updateVotes

	// *if37_condition
	// contracts/arc58/plugins/akita_social.algo.ts:1172
	// !flip
	frame_dig -3 // flip: boolean
	!
	bz *if37_end

	// *if37_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:1173
	// return;
	retsub

*if37_end:
	// contracts/arc58/plugins/akita_social.algo.ts:1176
	// this.createVote(sender, ref, !isUp)
	frame_dig 3 // isUp: bool
	!
	frame_dig -2 // ref: bytes32
	frame_dig -1 // sender: Address
	callsub createVote
	retsub

// reactPost(address,byte[32],uint64,byte[][])void
*abi_route_reactPost:
	// args: byte[][]
	txna ApplicationArgs 4

	// NFT: uint64
	txna ApplicationArgs 3
	btoi

	// ref: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 2 (ref) for reactPost must be a byte[32]
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 3 (sender) for reactPost must be a address
	assert

	// execute reactPost(address,byte[32],uint64,byte[][])void
	callsub reactPost
	int 1
	return

// reactPost(sender: Address, ref: bytes32, NFT: AssetID, args: bytes[]): void
reactPost:
	proto 4 0

	// contracts/arc58/plugins/akita_social.algo.ts:1180
	// this.createReaction(sender, ref, NFT, args)
	frame_dig -4 // args: bytes[]
	frame_dig -3 // NFT: AssetID
	frame_dig -2 // ref: bytes32
	frame_dig -1 // sender: Address
	callsub createReaction
	retsub

// reactAsset(address,uint64,uint64)void
*abi_route_reactAsset:
	// NFT: uint64
	txna ApplicationArgs 3
	btoi

	// ref: uint64
	txna ApplicationArgs 2
	btoi

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (sender) for reactAsset must be a address
	assert

	// execute reactAsset(address,uint64,uint64)void
	callsub reactAsset
	int 1
	return

// reactAsset(sender: Address, ref: AssetID, NFT: AssetID): void
reactAsset:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/arc58/plugins/akita_social.algo.ts:1184
	// assert(ref.id !== 0, errs.INVALID_ASSET)
	frame_dig -2 // ref: AssetID
	int 0
	!=
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1185
	// paddedRef = itob(ref.id) as bytes32
	frame_dig -2 // ref: AssetID
	itob
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	frame_bury 0 // paddedRef: byte[32]

	// contracts/arc58/plugins/akita_social.algo.ts:1186
	// this.createEmptyPostIfNecessary(paddedRef, ref.creator)
	frame_dig -2 // ref: AssetID
	asset_params_get AssetCreator
	pop
	frame_dig 0 // paddedRef: byte[32]
	callsub createEmptyPostIfNecessary

	// contracts/arc58/plugins/akita_social.algo.ts:1187
	// this.createReaction(sender, paddedRef, NFT, [])
	byte 0x
	frame_dig -3 // NFT: AssetID
	frame_dig 0 // paddedRef: byte[32]
	frame_dig -1 // sender: Address
	callsub createReaction
	retsub

// reactAddress(address,address,uint64,byte[][])void
*abi_route_reactAddress:
	// args: byte[][]
	txna ApplicationArgs 4

	// NFT: uint64
	txna ApplicationArgs 3
	btoi

	// ref: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 2 (ref) for reactAddress must be a address
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 3 (sender) for reactAddress must be a address
	assert

	// execute reactAddress(address,address,uint64,byte[][])void
	callsub reactAddress
	int 1
	return

// reactAddress(sender: Address, ref: Address, NFT: AssetID, args: bytes[]): void
reactAddress:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// *if38_condition
	// contracts/arc58/plugins/akita_social.algo.ts:1192
	// this.meta(ref).exists
	frame_dig -2 // ref: Address
	box_len
	swap
	pop
	bz *if38_end

	// *if38_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:1193
	// meta = this.meta(ref).value
	frame_dig -2 // ref: Address
	frame_bury 0 // storage key//meta

	// *if39_condition
	// contracts/arc58/plugins/akita_social.algo.ts:1195
	// meta.addressFilterIndex !== 0
	frame_dig 0 // storage key//meta
	box_get

	// box value does not exist: this.meta(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 97 8
	btoi
	int 0
	!=
	bz *if39_end

	// *if39_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:1196
	// assert(this.gate(meta.addressFilterIndex, args), errs.DOES_NOT_PASS_GATE)
	frame_dig -4 // args: bytes[]
	frame_dig 0 // storage key//meta
	box_get

	// box value does not exist: this.meta(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 97 8
	btoi
	callsub gate
	assert

*if39_end:

*if38_end:
	// contracts/arc58/plugins/akita_social.algo.ts:1200
	// r = rawBytes(ref) as bytes32
	frame_dig -2 // ref: Address
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	frame_bury 1 // r: byte[32]

	// contracts/arc58/plugins/akita_social.algo.ts:1201
	// this.createEmptyPostIfNecessary(r, ref)
	frame_dig -2 // ref: Address
	frame_dig 1 // r: byte[32]
	callsub createEmptyPostIfNecessary

	// contracts/arc58/plugins/akita_social.algo.ts:1202
	// this.createReaction(sender, r, NFT, [])
	byte 0x
	frame_dig -3 // NFT: AssetID
	frame_dig 1 // r: byte[32]
	frame_dig -1 // sender: Address
	callsub createReaction
	retsub

// reactApp(address,uint64,uint64)void
*abi_route_reactApp:
	// NFT: uint64
	txna ApplicationArgs 3
	btoi

	// ref: uint64
	txna ApplicationArgs 2
	btoi

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (sender) for reactApp must be a address
	assert

	// execute reactApp(address,uint64,uint64)void
	callsub reactApp
	int 1
	return

// reactApp(sender: Address, ref: AppID, NFT: AssetID): void
reactApp:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/arc58/plugins/akita_social.algo.ts:1206
	// assert(ref.id !== 0, errs.INVALID_APP)
	frame_dig -2 // ref: AppID
	int 0
	!=
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1207
	// paddedRef = itob(ref.id) as bytes32
	frame_dig -2 // ref: AppID
	itob
	byte 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	byte 0x
	b==
	assert
	extract 0 32
	frame_bury 0 // paddedRef: byte[32]

	// contracts/arc58/plugins/akita_social.algo.ts:1208
	// this.createEmptyPostIfNecessary(paddedRef, ref.creator)
	frame_dig -2 // ref: AppID
	app_params_get AppCreator
	pop
	frame_dig 0 // paddedRef: byte[32]
	callsub createEmptyPostIfNecessary

	// contracts/arc58/plugins/akita_social.algo.ts:1209
	// this.createReaction(sender, paddedRef, NFT, [])
	byte 0x
	frame_dig -3 // NFT: AssetID
	frame_dig 0 // paddedRef: byte[32]
	frame_dig -1 // sender: Address
	callsub createReaction
	retsub

// deleteReaction(address,byte[32],uint64)void
*abi_route_deleteReaction:
	// NFT: uint64
	txna ApplicationArgs 3
	btoi

	// ref: byte[32]
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 1 (ref) for deleteReaction must be a byte[32]
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (sender) for deleteReaction must be a address
	assert

	// execute deleteReaction(address,byte[32],uint64)void
	callsub deleteReaction
	int 1
	return

// deleteReaction(sender: Address, ref: bytes32, NFT: AssetID): void
deleteReaction:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/arc58/plugins/akita_social.algo.ts:1213
	// assert(this.controls(sender), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: Address
	callsub controls
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1214
	// assert(!this.isBanned(sender), errs.BANNED)
	frame_dig -1 // sender: Address
	callsub isBanned
	!
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1215
	// assert(this.posts(ref).exists, errs.POST_NOT_FOUND)
	byte 0x70 // "p"
	frame_dig -2 // ref: bytes32
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1216
	// post = this.posts(ref).value
	byte 0x70 // "p"
	frame_dig -2 // ref: bytes32
	concat
	frame_bury 0 // storage key//post

	// contracts/arc58/plugins/akita_social.algo.ts:1217
	// assert(!this.isBlocked(post.creator, sender), errs.BLOCKED)
	frame_dig -1 // sender: Address
	frame_dig 0 // storage key//post
	box_get

	// box value does not exist: this.posts(ref).value
	assert
	store 255 // full array
	load 255 // full array
	extract 91 32
	callsub isBlocked
	!
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1219
	// reactionListKey: ReactionListKey = {
	//             user: rawBytes(sender).substring(0, 24) as bytes24,
	//             ref: rawBytes(ref).substring(0, 24) as bytes24,
	//             NFT: NFT
	//         }
	frame_dig -1 // sender: Address
	substring 0 24
	byte 0x000000000000000000000000000000000000000000000000
	concat
	dup
	extract 24 0
	byte 0x
	b==
	assert
	extract 0 24
	frame_dig -2 // ref: bytes32
	substring 0 24
	byte 0x000000000000000000000000000000000000000000000000
	concat
	dup
	extract 24 0
	byte 0x
	b==
	assert
	extract 0 24
	concat
	frame_dig -3 // NFT: AssetID
	itob
	concat
	frame_bury 1 // reactionListKey: ReactionListKey

	// contracts/arc58/plugins/akita_social.algo.ts:1225
	// assert(this.reactionlist(reactionListKey).exists, errs.ALREADY_REACTED)
	frame_dig 1 // reactionListKey: ReactionListKey
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1227
	// this.reactions({ ref: ref, NFT: NFT }).value -= 1
	byte 0x72 // "r"
	frame_dig -2 // ref: bytes32
	frame_dig -3 // NFT: AssetID
	itob
	concat
	concat
	box_get

	// box value does not exist: this.reactions({ ref: ref, NFT: NFT }).value
	assert
	btoi
	int 1
	-
	byte 0x72 // "r"
	frame_dig -2 // ref: bytes32
	frame_dig -3 // NFT: AssetID
	itob
	concat
	concat
	swap
	itob
	box_put

	// contracts/arc58/plugins/akita_social.algo.ts:1228
	// this.reactionlist(reactionListKey).delete()
	frame_dig 1 // reactionListKey: ReactionListKey
	box_del
	retsub

// follow(address,address,byte[][])void
*abi_route_follow:
	// args: byte[][]
	txna ApplicationArgs 3

	// address: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 1 (address) for follow must be a address
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (sender) for follow must be a address
	assert

	// execute follow(address,address,byte[][])void
	callsub follow
	int 1
	return

// follow(sender: Address, address: Address, args: bytes[]): void
follow:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/arc58/plugins/akita_social.algo.ts:1250
	// assert(this.controls(sender), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: Address
	callsub controls
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1251
	// assert(!this.isBanned(sender), errs.BANNED)
	frame_dig -1 // sender: Address
	callsub isBanned
	!
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1252
	// assert(!this.isBlocked(address, sender), errs.BLOCKED)
	frame_dig -1 // sender: Address
	frame_dig -2 // address: Address
	callsub isBlocked
	!
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1254
	// senderIsAutomated = this.meta(sender).value.automated
	frame_dig -1 // sender: Address
	box_get

	// box value does not exist: this.meta(sender).value
	assert
	store 255 // full array
	load 255 // full array
	int 704
	getbit
	frame_bury 0 // senderIsAutomated: bool

	// contracts/arc58/plugins/akita_social.algo.ts:1255
	// assert(!senderIsAutomated, errs.AUTOMATED_ACCOUNT)
	frame_dig 0 // senderIsAutomated: bool
	!
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1257
	// meta = this.meta(address).value
	frame_dig -2 // address: Address
	frame_bury 1 // storage key//meta

	// *if40_condition
	// contracts/arc58/plugins/akita_social.algo.ts:1259
	// meta.followFilterIndex !== 0
	frame_dig 1 // storage key//meta
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	extract 89 8
	btoi
	int 0
	!=
	bz *if40_end

	// *if40_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:1260
	// assert(this.gate(meta.followFilterIndex, args), errs.DOES_NOT_PASS_GATE)
	frame_dig -3 // args: bytes[]
	frame_dig 1 // storage key//meta
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	extract 89 8
	btoi
	callsub gate
	assert

*if40_end:
	// contracts/arc58/plugins/akita_social.algo.ts:1263
	// followerIndex = meta.followerIndex
	frame_dig 1 // storage key//meta
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	extract 72 8
	btoi
	frame_bury 2 // followerIndex: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:1264
	// this.follows({ user: address, index: (followerIndex + 1) }).value = sender
	byte 0x66 // "f"
	frame_dig -2 // address: Address
	frame_dig 2 // followerIndex: uint64
	int 1
	+
	itob
	concat
	concat
	frame_dig -1 // sender: Address
	box_put

	// contracts/arc58/plugins/akita_social.algo.ts:1265
	// this.meta(address).value.followerIndex += 1
	frame_dig -2 // address: Address
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	int 72
	frame_dig -2 // address: Address
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	extract 72 8
	btoi
	int 1
	+
	itob
	frame_dig -2 // address: Address
	cover 2
	box_replace

	// contracts/arc58/plugins/akita_social.algo.ts:1266
	// this.meta(address).value.followerCount += 1
	frame_dig -2 // address: Address
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	int 80
	frame_dig -2 // address: Address
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	extract 80 8
	btoi
	int 1
	+
	itob
	frame_dig -2 // address: Address
	cover 2
	box_replace
	retsub

// unfollow(address,address,uint64)void
*abi_route_unfollow:
	// followerIndex: uint64
	txna ApplicationArgs 3
	btoi

	// address: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 1 (address) for unfollow must be a address
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (sender) for unfollow must be a address
	assert

	// execute unfollow(address,address,uint64)void
	callsub unfollow
	int 1
	return

// unfollow(sender: Address, address: Address, followerIndex: uint64): void
unfollow:
	proto 3 0

	// contracts/arc58/plugins/akita_social.algo.ts:1270
	// assert(this.controls(sender), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: Address
	callsub controls
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1271
	// assert(!this.isBanned(sender), errs.BANNED)
	frame_dig -1 // sender: Address
	callsub isBanned
	!
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1272
	// assert(this.follows({ user: address, index: followerIndex }).value === sender, errs.WRONG_FOLLOWER_KEY)
	byte 0x66 // "f"
	frame_dig -2 // address: Address
	frame_dig -3 // followerIndex: uint64
	itob
	concat
	concat
	box_get

	// box value does not exist: this.follows({ user: address, index: followerIndex }).value
	assert
	frame_dig -1 // sender: Address
	==
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1274
	// this.follows({ user: address, index: followerIndex }).delete()
	byte 0x66 // "f"
	frame_dig -2 // address: Address
	frame_dig -3 // followerIndex: uint64
	itob
	concat
	concat
	box_del

	// contracts/arc58/plugins/akita_social.algo.ts:1275
	// this.meta(address).value.followerCount -= 1
	frame_dig -2 // address: Address
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	int 80
	frame_dig -2 // address: Address
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	extract 80 8
	btoi
	int 1
	-
	itob
	frame_dig -2 // address: Address
	cover 2
	box_replace
	retsub

// block(address,address)void
*abi_route_block:
	// address: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (address) for block must be a address
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (sender) for block must be a address
	assert

	// execute block(address,address)void
	callsub block
	int 1
	return

// block(sender: Address, address: Address): void
block:
	proto 2 0

	// contracts/arc58/plugins/akita_social.algo.ts:1281
	// assert(this.controls(sender), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: Address
	callsub controls
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1282
	// assert(!this.isBanned(sender), errs.BANNED)
	frame_dig -1 // sender: Address
	callsub isBanned
	!
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1283
	// this.blocks({ user: sender, blocked: address }).create(0)
	frame_dig -1 // sender: Address
	frame_dig -2 // address: Address
	concat
	int 0
	box_create
	pop
	retsub

// unblock(address,address)void
*abi_route_unblock:
	// address: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (address) for unblock must be a address
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (sender) for unblock must be a address
	assert

	// execute unblock(address,address)void
	callsub unblock
	int 1
	return

// unblock(sender: Address, address: Address): void
unblock:
	proto 2 0

	// contracts/arc58/plugins/akita_social.algo.ts:1287
	// assert(this.controls(sender), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: Address
	callsub controls
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1288
	// assert(!this.isBanned(sender), errs.BANNED)
	frame_dig -1 // sender: Address
	callsub isBanned
	!
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1289
	// this.blocks({ user: sender, blocked: address }).delete()
	frame_dig -1 // sender: Address
	frame_dig -2 // address: Address
	concat
	box_del
	retsub

// addModerator(address)void
*abi_route_addModerator:
	// address: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (address) for addModerator must be a address
	assert

	// execute addModerator(address)void
	callsub addModerator
	int 1
	return

// addModerator(address: Address): void
addModerator:
	proto 1 0
	retsub

// removeModerator(address)void
*abi_route_removeModerator:
	// address: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (address) for removeModerator must be a address
	assert

	// execute removeModerator(address)void
	callsub removeModerator
	int 1
	return

// removeModerator(address: Address): void
removeModerator:
	proto 1 0
	retsub

// ban(address,address,uint64)void
*abi_route_ban:
	// expiration: uint64
	txna ApplicationArgs 3
	btoi

	// address: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 1 (address) for ban must be a address
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (sender) for ban must be a address
	assert

	// execute ban(address,address,uint64)void
	callsub ban
	int 1
	return

// ban(sender: Address, address: Address, expiration: uint64): void
ban:
	proto 3 0

	// contracts/arc58/plugins/akita_social.algo.ts:1305
	// assert(this.controls(sender), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: Address
	callsub controls
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1306
	// assert(this.moderators(sender).exists, errs.NOT_A_MODERATOR)
	byte 0x6d // "m"
	frame_dig -1 // sender: Address
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1307
	// assert(!this.banned(address).exists, errs.ALREADY_BANNED)
	byte 0x62 // "b"
	frame_dig -2 // address: Address
	concat
	box_len
	swap
	pop
	!
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1308
	// this.banned(address).value = expiration
	byte 0x62 // "b"
	frame_dig -2 // address: Address
	concat
	frame_dig -3 // expiration: uint64
	itob
	box_put
	retsub

// unban(address,address)void
*abi_route_unban:
	// address: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (address) for unban must be a address
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (sender) for unban must be a address
	assert

	// execute unban(address,address)void
	callsub unban
	int 1
	return

// unban(sender: Address, address: Address): void
unban:
	proto 2 0

	// contracts/arc58/plugins/akita_social.algo.ts:1312
	// assert(this.controls(sender), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: Address
	callsub controls
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1313
	// assert(this.moderators(sender).exists, errs.NOT_A_MODERATOR)
	byte 0x6d // "m"
	frame_dig -1 // sender: Address
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1314
	// this.banned(address).delete()
	byte 0x62 // "b"
	frame_dig -2 // address: Address
	concat
	box_del
	retsub

// cacheMeta(uint64,bool,uint64,uint64,uint64)uint64
*abi_route_cacheMeta:
	// The ABI return prefix
	byte 0x151f7c75

	// akitaNFT: uint64
	txna ApplicationArgs 5
	btoi

	// NFD: uint64
	txna ApplicationArgs 4
	btoi

	// subscriptionIndex: uint64
	txna ApplicationArgs 3
	btoi

	// automated: bool
	txna ApplicationArgs 2
	dup
	len
	int 1
	==

	// argument 3 (automated) for cacheMeta must be a bool
	assert
	int 0
	getbit

	// walletAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute cacheMeta(uint64,bool,uint64,uint64,uint64)uint64
	callsub cacheMeta
	itob
	concat
	log
	int 1
	return

// cacheMeta(walletAppID: AppID, automated: boolean, subscriptionIndex: uint64, NFD: AppID, akitaNFT: AssetID): uint64
cacheMeta:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// contracts/arc58/plugins/akita_social.algo.ts:1322
	// address = walletAppID.globalState(ARC58_CONTROLLED_ADDRESS_KEY) as Address
	frame_dig -1 // walletAppID: AppID
	byte "c"
	app_global_get_ex

	// global state value does not exist: walletAppID.globalState(ARC58_CONTROLLED_ADDRESS_KEY)
	assert
	frame_bury 0 // address: address

	// contracts/arc58/plugins/akita_social.algo.ts:1323
	// assert(this.controls(address), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig 0 // address: address
	callsub controls
	assert

	// *if41_condition
	// contracts/arc58/plugins/akita_social.algo.ts:1325
	// !this.meta(address).exists
	frame_dig 0 // address: address
	box_len
	swap
	pop
	!
	bz *if41_else

	// *if41_consequent
	// *if42_condition
	// contracts/arc58/plugins/akita_social.algo.ts:1326
	// automated
	frame_dig -2 // automated: boolean
	bz *if42_end

	// *if42_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:1327
	// this.meta(address).value = {
	//                     walletAppID: walletAppID,
	//                     streak: 1,
	//                     startDate: globals.latestTimestamp,
	//                     lastActive: globals.latestTimestamp,
	//                     subscriptionIndex: 0,
	//                     NFD: AppID.fromUint64(0),
	//                     nfdTimeChanged: 0,
	//                     nfdImpact: 0,
	//                     akitaNFT: AssetID.fromUint64(0),
	//                     followerIndex: 0,
	//                     followerCount: 0,
	//                     automated: true,
	//                     followFilterIndex: 0,
	//                     addressFilterIndex: 0,
	//                 }
	frame_dig 0 // address: address
	frame_dig -1 // walletAppID: AppID
	itob
	byte 0x0000000000000001
	concat
	global LatestTimestamp
	itob
	concat
	global LatestTimestamp
	itob
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x00
	int 0
	int 1
	setbit
	concat // 12
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	box_put

	// contracts/arc58/plugins/akita_social.algo.ts:1343
	// return 0;
	int 0
	b *cacheMeta*return

*if42_end:
	b *if41_end

*if41_else:
	// contracts/arc58/plugins/akita_social.algo.ts:1346
	// assert(!this.meta(address).value.automated, errs.AUTOMATED_ACCOUNT)
	frame_dig 0 // address: address
	box_get

	// box value does not exist: this.meta(address).value
	assert
	store 255 // full array
	load 255 // full array
	int 704
	getbit
	!
	assert

*if41_end:
	// *if43_condition
	// contracts/arc58/plugins/akita_social.algo.ts:1349
	// subscriptionIndex !== 0
	frame_dig -3 // subscriptionIndex: uint64
	int 0
	!=
	bz *if43_end

	// *if43_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:1350
	// assert(this.isSubscribed(address, subscriptionIndex).active, errs.NOT_A_SUBSCRIPTION)
	frame_dig -3 // subscriptionIndex: uint64
	frame_dig 0 // address: address
	callsub isSubscribed
	store 255 // full array
	load 255 // full array
	int 0
	getbit
	assert

*if43_end:
	// contracts/arc58/plugins/akita_social.algo.ts:1353
	// nfdTimeChanged: uint64 = 0
	int 0
	frame_bury 1 // nfdTimeChanged: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:1354
	// nfdImpact: uint64 = 0
	int 0
	frame_bury 2 // nfdImpact: uint64

	// *if44_condition
	// contracts/arc58/plugins/akita_social.algo.ts:1355
	// NFD.id !== 0
	frame_dig -4 // NFD: AppID
	int 0
	!=
	bz *if44_end

	// *if44_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:1356
	// assert(this.isNFD(NFD), errs.NOT_AN_NFD)
	frame_dig -4 // NFD: AppID
	callsub isNFD
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1357
	// assert(this.addressVerifiedOnNFD(address, NFD), errs.USER_DOES_NOT_OWN_NFD)
	frame_dig -4 // NFD: AppID
	frame_dig 0 // address: address
	callsub addressVerifiedOnNFD
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1358
	// nfdTimeChanged = btoi(NFD.globalState(NFD_TIME_CHANGED_KEY) as bytes)
	frame_dig -4 // NFD: AppID
	byte "i.timeChanged"
	app_global_get_ex

	// global state value does not exist: NFD.globalState(NFD_TIME_CHANGED_KEY)
	assert
	btoi
	frame_bury 1 // nfdTimeChanged: uint64

	// contracts/arc58/plugins/akita_social.algo.ts:1359
	// nfdImpact = this.calcNFDImpactScore(NFD)
	frame_dig -4 // NFD: AppID
	callsub calcNFDImpactScore
	frame_bury 2 // nfdImpact: uint64

*if44_end:
	// *if45_condition
	// contracts/arc58/plugins/akita_social.algo.ts:1362
	// akitaNFT.id !== 0
	frame_dig -5 // akitaNFT: AssetID
	int 0
	!=
	bz *if45_end

	// *if45_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:1363
	// assert(this.isAkitaNFT(akitaNFT), errs.NOT_AN_AKITA_NFT)
	frame_dig -5 // akitaNFT: AssetID
	callsub isAkitaNFT
	assert

	// contracts/arc58/plugins/akita_social.algo.ts:1364
	// assert(this.userHolds(address, akitaNFT), errs.USER_DOES_NOT_OWN_NFT)
	frame_dig -5 // akitaNFT: AssetID
	frame_dig 0 // address: address
	callsub userHolds
	assert

*if45_end:
	// *if46_condition
	// contracts/arc58/plugins/akita_social.algo.ts:1367
	// !this.meta(address).exists
	frame_dig 0 // address: address
	box_len
	swap
	pop
	!
	bz *if46_else

	// *if46_consequent
	// contracts/arc58/plugins/akita_social.algo.ts:1368
	// this.meta(address).value = {
	//                 walletAppID: walletAppID,
	//                 streak: 1,
	//                 startDate: globals.latestTimestamp,
	//                 lastActive: globals.latestTimestamp,
	//                 subscriptionIndex: subscriptionIndex,
	//                 NFD: NFD,
	//                 nfdTimeChanged: nfdTimeChanged,
	//                 nfdImpact: nfdImpact,
	//                 akitaNFT: akitaNFT,
	//                 followerIndex: 0,
	//                 followerCount: 0,
	//                 automated: false,
	//                 followFilterIndex: 0,
	//                 addressFilterIndex: 0,
	//             }
	frame_dig 0 // address: address
	frame_dig -1 // walletAppID: AppID
	itob
	byte 0x0000000000000001
	concat
	global LatestTimestamp
	itob
	concat
	global LatestTimestamp
	itob
	concat
	frame_dig -3 // subscriptionIndex: uint64
	itob
	concat
	frame_dig -4 // NFD: AppID
	itob
	concat
	frame_dig 1 // nfdTimeChanged: uint64
	itob
	concat
	frame_dig 2 // nfdImpact: uint64
	itob
	concat
	frame_dig -5 // akitaNFT: AssetID
	itob
	concat
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	byte 0x00
	int 0
	dup
	setbit
	concat // 12
	byte 0x0000000000000000
	concat
	byte 0x0000000000000000
	concat
	box_put
	b *if46_end

*if46_else:
	// contracts/arc58/plugins/akita_social.algo.ts:1385
	// meta = clone(this.meta(address).value)
	frame_dig 0 // address: address
	box_get

	// box value does not exist: this.meta(address).value
	assert
	frame_bury 3 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)

	// contracts/arc58/plugins/akita_social.algo.ts:1387
	// meta.subscriptionIndex = subscriptionIndex
	frame_dig 3 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	int 32
	frame_dig -3 // subscriptionIndex: uint64
	itob
	replace3
	frame_bury 3 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)

	// contracts/arc58/plugins/akita_social.algo.ts:1388
	// meta.NFD = NFD
	frame_dig 3 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	int 40
	frame_dig -4 // NFD: AppID
	itob
	replace3
	frame_bury 3 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)

	// contracts/arc58/plugins/akita_social.algo.ts:1389
	// meta.nfdTimeChanged = nfdTimeChanged
	frame_dig 3 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	int 48
	frame_dig 1 // nfdTimeChanged: uint64
	itob
	replace3
	frame_bury 3 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)

	// contracts/arc58/plugins/akita_social.algo.ts:1390
	// meta.nfdImpact = nfdImpact
	frame_dig 3 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	int 56
	frame_dig 2 // nfdImpact: uint64
	itob
	replace3
	frame_bury 3 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)

	// contracts/arc58/plugins/akita_social.algo.ts:1391
	// meta.akitaNFT = akitaNFT
	frame_dig 3 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)
	store 255 // full array
	load 255 // full array
	int 64
	frame_dig -5 // akitaNFT: AssetID
	itob
	replace3
	frame_bury 3 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)

	// contracts/arc58/plugins/akita_social.algo.ts:1393
	// this.meta(address).value = meta
	frame_dig 0 // address: address
	frame_dig 3 // meta: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)
	box_put

*if46_end:
	// contracts/arc58/plugins/akita_social.algo.ts:1396
	// return nfdImpact;
	frame_dig 2 // nfdImpact: uint64

*cacheMeta*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// updateSubscriptionStateModifier(uint64,uint64)void
*abi_route_updateSubscriptionStateModifier:
	// newModifier: uint64
	txna ApplicationArgs 2
	btoi

	// subscriptionIndex: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateSubscriptionStateModifier(uint64,uint64)void
	callsub updateSubscriptionStateModifier
	int 1
	return

// updateSubscriptionStateModifier(subscriptionIndex: uint64, newModifier: uint64): void
updateSubscriptionStateModifier:
	proto 2 0

	// contracts/arc58/plugins/akita_social.algo.ts:1401
	// this.subscriptionStateModifier(subscriptionIndex).value = newModifier
	frame_dig -1 // subscriptionIndex: uint64
	itob
	frame_dig -2 // newModifier: uint64
	itob
	box_put
	retsub

// getUserImpact(address)uint64
*abi_route_getUserImpact:
	// The ABI return prefix
	byte 0x151f7c75

	// address: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (address) for getUserImpact must be a address
	assert

	// execute getUserImpact(address)uint64
	callsub getUserImpact
	itob
	concat
	log
	int 1
	return

// getUserImpact(address: Address): uint64
getUserImpact:
	proto 1 1

	// contracts/arc58/plugins/akita_social.algo.ts:1409
	// return this.userImpact(address);
	frame_dig -1 // address: Address
	callsub userImpact
	retsub

// isFollower(address,uint64,address)bool
*abi_route_isFollower:
	// The ABI return prefix
	byte 0x151f7c75

	// follower: address
	txna ApplicationArgs 3
	dup
	len
	int 32
	==

	// argument 0 (follower) for isFollower must be a address
	assert

	// index: uint64
	txna ApplicationArgs 2
	btoi

	// user: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (user) for isFollower must be a address
	assert

	// execute isFollower(address,uint64,address)bool
	callsub isFollower
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// isFollower(user: Address, index: uint64, follower: Address): boolean
isFollower:
	proto 3 1

	// contracts/arc58/plugins/akita_social.algo.ts:1414
	// return this.follows({ user: user, index: index }).value === follower;
	byte 0x66 // "f"
	frame_dig -1 // user: Address
	frame_dig -2 // index: uint64
	itob
	concat
	concat
	box_get

	// box value does not exist: this.follows({ user: user, index: index }).value
	assert
	frame_dig -3 // follower: Address
	==
	retsub

// getMeta(address)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)
*abi_route_getMeta:
	// The ABI return prefix
	byte 0x151f7c75

	// user: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (user) for getMeta must be a address
	assert

	// execute getMeta(address)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)
	callsub getMeta
	concat
	log
	int 1
	return

// getMeta(user: Address): MetaValue
getMeta:
	proto 1 1

	// contracts/arc58/plugins/akita_social.algo.ts:1419
	// return this.meta(user).value;
	frame_dig -1 // user: Address
	box_get

	// box value does not exist: this.meta(user).value
	assert
	retsub

*abi_route_createApplication:
	int 1
	return

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "post(address,byte[59],bool,uint64,uint64)void"
	method "editPost(address,byte[59],bool,uint64,uint64,byte[32])void"
	method "replyPost(address,byte[59],byte[32],bool,uint64,uint64,byte[][])void"
	method "replyAsset(address,byte[59],uint64,bool,uint64,uint64)void"
	method "replyAddress(address,byte[59],address,bool,uint64,uint64,byte[][])void"
	method "replyApp(address,byte[59],uint64,bool,uint64,uint64)void"
	method "editReply(address,byte[59],bool,uint64,uint64,byte[][],byte[32])void"
	method "votePost(address,byte[32],bool)void"
	method "voteAsset(address,uint64,bool)void"
	method "voteAddress(address,address,bool)void"
	method "voteApp(address,uint64,bool)void"
	method "editVote(address,byte[32],bool)void"
	method "reactPost(address,byte[32],uint64,byte[][])void"
	method "reactAsset(address,uint64,uint64)void"
	method "reactAddress(address,address,uint64,byte[][])void"
	method "reactApp(address,uint64,uint64)void"
	method "deleteReaction(address,byte[32],uint64)void"
	method "follow(address,address,byte[][])void"
	method "unfollow(address,address,uint64)void"
	method "block(address,address)void"
	method "unblock(address,address)void"
	method "addModerator(address)void"
	method "removeModerator(address)void"
	method "ban(address,address,uint64)void"
	method "unban(address,address)void"
	method "cacheMeta(uint64,bool,uint64,uint64,uint64)uint64"
	method "updateSubscriptionStateModifier(uint64,uint64)void"
	method "getUserImpact(address)uint64"
	method "isFollower(address,uint64,address)bool"
	method "getMeta(address)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint64,uint64)"
	txna ApplicationArgs 0
	match *abi_route_post *abi_route_editPost *abi_route_replyPost *abi_route_replyAsset *abi_route_replyAddress *abi_route_replyApp *abi_route_editReply *abi_route_votePost *abi_route_voteAsset *abi_route_voteAddress *abi_route_voteApp *abi_route_editVote *abi_route_reactPost *abi_route_reactAsset *abi_route_reactAddress *abi_route_reactApp *abi_route_deleteReaction *abi_route_follow *abi_route_unfollow *abi_route_block *abi_route_unblock *abi_route_addModerator *abi_route_removeModerator *abi_route_ban *abi_route_unban *abi_route_cacheMeta *abi_route_updateSubscriptionStateModifier *abi_route_getUserImpact *abi_route_isFollower *abi_route_getMeta

	// this contract does not implement the given ABI method for call NoOp
	err