#pragma version 10
intcblock 0 1 8 6 32 4 48 96 83500 56
bytecblock 0x 0x0000000000000003 0x68 0x0000000000000000 0x2bf3cc5a 0x6f666665725f637572736f72 0x0000000000000001 0x0000000000000004 0x64ccf1d3

// This TEAL was generated by TEALScript v0.106.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 3 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// controls(address: Address): boolean
controls:
	proto 1 1

	// contracts/arc58/plugins/hyper_swap.algo.ts:98
	// return address.authAddr === this.app.address;
	frame_dig -1 // address: Address
	acct_params_get AcctAuthAddr
	pop
	global CurrentApplicationAddress
	==
	retsub

// rekeyBack(address: Address): void
rekeyBack:
	proto 1 0

	// contracts/arc58/plugins/hyper_swap.algo.ts:102
	// sendPayment({
	//             sender: address,
	//             amount: 0,
	//             receiver: address,
	//             rekeyTo: address,
	//             fee: 0,
	//         })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:103
	// sender: address
	frame_dig -1 // address: Address
	itxn_field Sender

	// contracts/arc58/plugins/hyper_swap.algo.ts:104
	// amount: 0
	intc 0 // 0
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:105
	// receiver: address
	frame_dig -1 // address: Address
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:106
	// rekeyTo: address
	frame_dig -1 // address: Address
	itxn_field RekeyTo

	// contracts/arc58/plugins/hyper_swap.algo.ts:107
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// newOfferID(): uint64
newOfferID:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/arc58/plugins/hyper_swap.algo.ts:112
	// id = this._offerCursor.value
	bytec 5 //  "offer_cursor"
	app_global_get
	frame_bury 0 // id: uint64

	// contracts/arc58/plugins/hyper_swap.algo.ts:113
	// this._offerCursor.value += 1
	bytec 5 //  "offer_cursor"
	app_global_get
	intc 1 // 1
	+
	bytec 5 //  "offer_cursor"
	swap
	app_global_put

	// contracts/arc58/plugins/hyper_swap.algo.ts:114
	// return id
	frame_dig 0 // id: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// canCallArc58OptIn(walletAppID: AppID): boolean
canCallArc58OptIn:
	proto 1 1

	// contracts/arc58/plugins/hyper_swap.algo.ts:118
	// return sendMethodCall<typeof AbstractedAccount.prototype.arc58_canCall, boolean>({
	//             applicationID: walletAppID,
	//             methodArgs: [
	//                 AppID.fromUint64(AkitaAppIDsOptinPlugin),
	//                 this.app.address,
	//             ],
	//             fee: 0,
	//         });
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0xe9026da8 // method "arc58_canCall(uint64,address)bool"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:119
	// applicationID: walletAppID
	frame_dig -1 // walletAppID: AppID
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:120
	// methodArgs: [
	//                 AppID.fromUint64(AkitaAppIDsOptinPlugin),
	//                 this.app.address,
	//             ]
	bytec 3 // 0x0000000000000000
	itxn_field ApplicationArgs
	global CurrentApplicationAddress
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:124
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	retsub

// arc58OptInAndSend(recipientAppID: AppID, asset: AssetID, amount: uint64): void
arc58OptInAndSend:
	proto 3 0

	// contracts/arc58/plugins/hyper_swap.algo.ts:129
	// this.pendingGroup.addMethodCall<typeof AbstractedAccount.prototype.arc58_rekeyToPlugin, void>({
	//             applicationID: recipientAppID,
	//             methodArgs: [
	//                 AppID.fromUint64(AkitaAppIDsOptinPlugin),
	//                 []
	//             ],
	//             fee: 0,
	//         })
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0x3f8615d7 // method "arc58_rekeyToPlugin(uint64,uint64[])void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:130
	// applicationID: recipientAppID
	frame_dig -1 // recipientAppID: AppID
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:131
	// methodArgs: [
	//                 AppID.fromUint64(AkitaAppIDsOptinPlugin),
	//                 []
	//             ]
	bytec 3 // 0x0000000000000000
	itxn_field ApplicationArgs
	pushbytes 0x0000
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:135
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:138
	// this.pendingGroup.addMethodCall<typeof OptInPlugin.prototype.optInToAsset, void>({
	//             applicationID: AppID.fromUint64(AkitaAppIDsOptinPlugin),
	//             methodArgs: [
	//                 recipientAppID,
	//                 true,
	//                 asset,
	//                 {
	//                     receiver: recipientAppID.address,
	//                     amount: globals.assetOptInMinBalance,
	//                     fee: 0,
	//                 }
	//             ],
	//             fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:145
	// receiver: recipientAppID.address
	frame_dig -1 // recipientAppID: AppID
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:146
	// amount: globals.assetOptInMinBalance
	global AssetOptInMinBalance
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:147
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0xbfcbeee9 // method "optInToAsset(uint64,bool,uint64,pay)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:139
	// applicationID: AppID.fromUint64(AkitaAppIDsOptinPlugin)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:140
	// methodArgs: [
	//                 recipientAppID,
	//                 true,
	//                 asset,
	//                 {
	//                     receiver: recipientAppID.address,
	//                     amount: globals.assetOptInMinBalance,
	//                     fee: 0,
	//                 }
	//             ]
	frame_dig -1 // recipientAppID: AppID
	itob
	itxn_field ApplicationArgs
	intc 1 // 1
	pushbytes 0x00
	intc 0 // 0
	uncover 2
	setbit
	itxn_field ApplicationArgs
	frame_dig -2 // asset: AssetID
	itob
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:150
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:153
	// this.pendingGroup.addMethodCall<typeof AbstractedAccount.prototype.arc58_verifyAuthAddr, void>({
	//             applicationID: recipientAppID,
	//             fee: 0,
	//         })
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0x0f885493 // method "arc58_verifyAuthAddr()void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:154
	// applicationID: recipientAppID
	frame_dig -1 // recipientAppID: AppID
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:155
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:158
	// this.pendingGroup.addAssetTransfer({
	//             assetReceiver: recipientAppID.address,
	//             assetAmount: amount,
	//             xferAsset: asset,
	//             fee: 0,
	//         })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:159
	// assetReceiver: recipientAppID.address
	frame_dig -1 // recipientAppID: AppID
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:160
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:161
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:162
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:165
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// arc59OptInAndSend(recipientAppID: AppID, asset: AssetID, amount: uint64): void
arc59OptInAndSend:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts/arc58/plugins/hyper_swap.algo.ts:169
	// canCallData = sendMethodCall<typeof AssetInbox.prototype.arc59_getSendAssetInfo, arc59GetSendAssetInfoResponse>({
	//             applicationID: AppID.fromUint64(OtherAppIDsAssetInbox),
	//             methodArgs: [
	//                 recipientAppID.address,
	//                 asset.id,
	//             ],
	//             fee: 0,
	//         })
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0xcaa8daa5 // method "arc59_getSendAssetInfo(address,uint64)(uint64,uint64,bool,bool,uint64)"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:170
	// applicationID: AppID.fromUint64(OtherAppIDsAssetInbox)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:171
	// methodArgs: [
	//                 recipientAppID.address,
	//                 asset.id,
	//             ]
	frame_dig -1 // recipientAppID: AppID
	app_params_get AppAddress
	pop
	itxn_field ApplicationArgs
	frame_dig -2 // asset: AssetID
	itob
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:175
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 0 // canCallData: (uint64,uint64,bool,bool,uint64)

	// contracts/arc58/plugins/hyper_swap.algo.ts:178
	// mbr = canCallData.mbr
	frame_dig 0 // canCallData: (uint64,uint64,bool,bool,uint64)
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	frame_bury 1 // mbr: uint64

	// contracts/arc58/plugins/hyper_swap.algo.ts:179
	// routerOptedIn = canCallData.routerOptedIn
	frame_dig 0 // canCallData: (uint64,uint64,bool,bool,uint64)
	store 255 // full array
	load 255 // full array
	pushint 128
	getbit
	frame_bury 2 // routerOptedIn: bool

	// contracts/arc58/plugins/hyper_swap.algo.ts:180
	// receiverAlgoNeededForClaim = canCallData.receiverAlgoNeededForClaim
	frame_dig 0 // canCallData: (uint64,uint64,bool,bool,uint64)
	store 255 // full array
	load 255 // full array
	extract 17 8
	btoi
	frame_bury 3 // receiverAlgoNeededForClaim: uint64

	// *if0_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:182
	// mbr || receiverAlgoNeededForClaim
	frame_dig 1 // mbr: uint64
	dup
	bnz *skip_or0
	frame_dig 3 // receiverAlgoNeededForClaim: uint64
	||

*skip_or0:
	bz *if0_end

	// *if0_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:183
	// this.pendingGroup.addPayment({
	//                 receiver: AppID.fromUint64(OtherAppIDsAssetInbox).address,
	//                 amount: (mbr + receiverAlgoNeededForClaim),
	//                 fee: 0,
	//             })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:184
	// receiver: AppID.fromUint64(OtherAppIDsAssetInbox).address
	intc 0 // 0
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:185
	// amount: (mbr + receiverAlgoNeededForClaim)
	frame_dig 1 // mbr: uint64
	frame_dig 3 // receiverAlgoNeededForClaim: uint64
	+
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:186
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if0_end:
	// *if1_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:190
	// !routerOptedIn
	frame_dig 2 // routerOptedIn: bool
	!
	bz *if1_end

	// *if1_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:191
	// this.pendingGroup.addMethodCall<typeof AssetInbox.prototype.arc59_optRouterIn, void>({
	//                 applicationID: AppID.fromUint64(OtherAppIDsAssetInbox),
	//                 methodArgs: [asset.id],
	//                 fee: 0
	//             })
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0xe8540810 // method "arc59_optRouterIn(uint64)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:192
	// applicationID: AppID.fromUint64(OtherAppIDsAssetInbox)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:193
	// methodArgs: [asset.id]
	frame_dig -2 // asset: AssetID
	itob
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:194
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if1_end:
	// contracts/arc58/plugins/hyper_swap.algo.ts:198
	// this.pendingGroup.addMethodCall<typeof AssetInbox.prototype.arc59_sendAsset, Address>({
	//             applicationID: AppID.fromUint64(OtherAppIDsAssetInbox),
	//             methodArgs: [
	//                 {
	//                     assetReceiver: AppID.fromUint64(OtherAppIDsAssetInbox).address,
	//                     assetAmount: amount,
	//                     xferAsset: asset,
	//                     fee: 0,
	//                 },
	//                 recipientAppID.address,
	//                 receiverAlgoNeededForClaim,
	//             ],
	//             fee: 0
	//         })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:202
	// assetReceiver: AppID.fromUint64(OtherAppIDsAssetInbox).address
	intc 0 // 0
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:203
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:204
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:205
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0x08531ed7 // method "arc59_sendAsset(axfer,address,uint64)address"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:199
	// applicationID: AppID.fromUint64(OtherAppIDsAssetInbox)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:200
	// methodArgs: [
	//                 {
	//                     assetReceiver: AppID.fromUint64(OtherAppIDsAssetInbox).address,
	//                     assetAmount: amount,
	//                     xferAsset: asset,
	//                     fee: 0,
	//                 },
	//                 recipientAppID.address,
	//                 receiverAlgoNeededForClaim,
	//             ]
	frame_dig -1 // recipientAppID: AppID
	app_params_get AppAddress
	pop
	itxn_field ApplicationArgs
	frame_dig 3 // receiverAlgoNeededForClaim: uint64
	itob
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:210
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:213
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// offer(uint64,bool,byte[32],uint64,byte[32],uint64,uint64,address,uint64)void
*abi_route_offer:
	// marketFee: uint64
	txna ApplicationArgs 9
	btoi

	// marketplace: address
	txna ApplicationArgs 8
	dup
	len
	intc 4 // 32
	==

	// argument 1 (marketplace) for offer must be a address
	assert

	// expiration: uint64
	txna ApplicationArgs 7
	btoi

	// participantLeaves: uint64
	txna ApplicationArgs 6
	btoi

	// participantsRoot: byte[32]
	txna ApplicationArgs 5
	dup
	len
	intc 4 // 32
	==

	// argument 4 (participantsRoot) for offer must be a byte[32]
	assert

	// leaves: uint64
	txna ApplicationArgs 4
	btoi

	// root: byte[32]
	txna ApplicationArgs 3
	dup
	len
	intc 4 // 32
	==

	// argument 6 (root) for offer must be a byte[32]
	assert

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 7 (rekeyBack) for offer must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute offer(uint64,bool,byte[32],uint64,byte[32],uint64,uint64,address,uint64)void
	callsub offer
	intc 1 // 1
	return

// offer(sender: AppID, rekeyBack: boolean, root: bytes32, leaves: uint64, participantsRoot: bytes32, participantLeaves: uint64, expiration: uint64, marketplace: Address, marketFee: uint64): void
//
// Creates a merkle tree based atomic payment/xfer group
//
// @param sender the account creating the offering
// @param root the merkle tree root of trades consisting of from address, recipient address, asset id & amount
// @param leaves the number of leaves in the tree
// @param participantsRoot the merkle tree root of participating addresses
// @param participantLeaves the number of leaves in the participant tree
// @param expiration the unix timestamp that the offer auto-expires at if it has not been accepted by all participants
// @param marketplace the address of the marketplace to pay the fee to
// @param marketFee the fee to pay the marketplace for facilitating the offer
offer:
	proto 9 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/arc58/plugins/hyper_swap.algo.ts:239
	// assert(root !== participantsRoot, errs.BAD_ROOTS)
	frame_dig -3 // root: bytes32
	frame_dig -5 // participantsRoot: bytes32
	!=
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:241
	// sendPayment({
	//             sender: sender.address,
	//             amount: 18_500 + 50_500 + ((MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR) * 2),
	//             receiver: this.app.address,
	//             fee: 0,
	//         })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:242
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/hyper_swap.algo.ts:243
	// amount: 18_500 + 50_500 + ((MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR) * 2)
	pushint 236000
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:244
	// receiver: this.app.address
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:245
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/arc58/plugins/hyper_swap.algo.ts:249
	// this.pendingGroup.addPayment({
	//             sender: sender.address,
	//             receiver: marketplace,
	//             amount: marketFee,
	//             fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:250
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/hyper_swap.algo.ts:251
	// receiver: marketplace
	frame_dig -8 // marketplace: Address
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:252
	// amount: marketFee
	frame_dig -9 // marketFee: uint64
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:253
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:257
	// this.pendingGroup.addMethodCall<typeof MetaMerkles.prototype.addRoot, boolean>({
	//             applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles),
	//             methodArgs: [
	//                 {
	//                     amount: (MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR),
	//                     receiver: AppID.fromUint64(AkitaAppIDsMetaMerkles).address,
	//                     fee: 0,
	//                 },
	//                 root,
	//                 root,
	//                 META_MERKLE_TRADE_SCHEMA,
	//                 META_MERKLE_TRADE_TYPE
	//             ],
	//             fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:261
	// amount: (MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR)
	intc 8 // 83500
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:262
	// receiver: AppID.fromUint64(AkitaAppIDsMetaMerkles).address
	intc 0 // 0
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:263
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 8 //  method "addRoot(pay,string,byte[32],uint64,uint64)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:258
	// applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:259
	// methodArgs: [
	//                 {
	//                     amount: (MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR),
	//                     receiver: AppID.fromUint64(AkitaAppIDsMetaMerkles).address,
	//                     fee: 0,
	//                 },
	//                 root,
	//                 root,
	//                 META_MERKLE_TRADE_SCHEMA,
	//                 META_MERKLE_TRADE_TYPE
	//             ]
	frame_dig -3 // root: bytes32
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -3 // root: bytes32
	itxn_field ApplicationArgs
	bytec 7 // 0x0000000000000004
	itxn_field ApplicationArgs
	bytec 1 // 0x0000000000000003
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:270
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:274
	// this.pendingGroup.addMethodCall<typeof MetaMerkles.prototype.addRoot, boolean>({
	//             applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles),
	//             methodArgs: [
	//                 {
	//                     amount: (MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR),
	//                     receiver: AppID.fromUint64(AkitaAppIDsMetaMerkles).address,
	//                     fee: 0,
	//                 },
	//                 participantsRoot,
	//                 participantsRoot,
	//                 META_MERKLE_ADDRESS_SCHEMA,
	//                 META_MERKLE_TRADE_TYPE
	//             ],
	//             fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:278
	// amount: (MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR)
	intc 8 // 83500
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:279
	// receiver: AppID.fromUint64(AkitaAppIDsMetaMerkles).address
	intc 0 // 0
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:280
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 8 //  method "addRoot(pay,string,byte[32],uint64,uint64)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:275
	// applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:276
	// methodArgs: [
	//                 {
	//                     amount: (MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR),
	//                     receiver: AppID.fromUint64(AkitaAppIDsMetaMerkles).address,
	//                     fee: 0,
	//                 },
	//                 participantsRoot,
	//                 participantsRoot,
	//                 META_MERKLE_ADDRESS_SCHEMA,
	//                 META_MERKLE_TRADE_TYPE
	//             ]
	frame_dig -5 // participantsRoot: bytes32
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -5 // participantsRoot: bytes32
	itxn_field ApplicationArgs
	bytec 6 // 0x0000000000000001
	itxn_field ApplicationArgs
	bytec 1 // 0x0000000000000003
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:287
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:290
	// id = this.newOfferID()
	callsub newOfferID
	frame_bury 0 // id: uint64

	// contracts/arc58/plugins/hyper_swap.algo.ts:293
	// this.participants({ id: id, address: sender.address }).create(0)
	frame_dig 0 // id: uint64
	itob
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	intc 0 // 0
	box_create
	pop

	// contracts/arc58/plugins/hyper_swap.algo.ts:296
	// this.offers(id).value = {
	//             state: STATE_OFFERED,
	//             root: root,
	//             leaves: leaves,
	//             escrowed: 0,
	//             participantRoot: participantsRoot,
	//             participantLeaves: participantLeaves,
	//             acceptances: 1,
	//             expiration: expiration
	//         }
	frame_dig 0 // id: uint64
	itob
	bytec 3 // 0x0000000000000000
	frame_dig -3 // root: bytes32
	concat
	frame_dig -4 // leaves: uint64
	itob
	concat
	bytec 3 // 0x0000000000000000
	concat
	frame_dig -5 // participantsRoot: bytes32
	concat
	frame_dig -6 // participantLeaves: uint64
	itob
	concat
	bytec 6 // 0x0000000000000001
	concat
	frame_dig -7 // expiration: uint64
	itob
	concat
	box_put

	// contracts/arc58/plugins/hyper_swap.algo.ts:308
	// this.pendingGroup.submit()
	itxn_submit

	// *if2_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:310
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if2_end

	// *if2_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:311
	// this.rekeyBack(sender.address)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub rekeyBack

*if2_end:
	retsub

// accept(uint64,bool,uint64,byte[32][])void
*abi_route_accept:
	// proof: byte[32][]
	txna ApplicationArgs 4
	extract 2 0

	// id: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 2 (rekeyBack) for accept must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute accept(uint64,bool,uint64,byte[32][])void
	callsub accept
	intc 1 // 1
	return

// accept(sender: AppID, rekeyBack: boolean, id: uint64, proof: bytes32[]): void
//
// Accepts an offer
//
// @param sender the account accepting the offering
// @param id the id of the offer being accepted
// @param proof the bytes32 array proof of inclusion in the participants list
accept:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/arc58/plugins/hyper_swap.algo.ts:324
	// assert(this.controls(sender.address))
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:326
	// assert(this.offers(id).exists)
	frame_dig -3 // id: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:327
	// offer = this.offers(id).value
	frame_dig -3 // id: uint64
	itob
	frame_bury 0 // storage key//offer

	// contracts/arc58/plugins/hyper_swap.algo.ts:329
	// assert(offer.state === STATE_OFFERED)
	intc 0 // 0
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 0 // 0
	==
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:331
	// assert(
	//             sendMethodCall<typeof MetaMerkles.prototype.verify, boolean>({
	//                 applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles),
	//                 methodArgs: [
	//                     this.app.address,
	//                     offer.participantRoot,
	//                     sha256(sha256(sender.address)),
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ],
	//                 fee: 0,
	//             })
	//         )
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 4 //  method "verify(address,string,byte[32],byte[32][],uint64)bool"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:333
	// applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:334
	// methodArgs: [
	//                     this.app.address,
	//                     offer.participantRoot,
	//                     sha256(sha256(sender.address)),
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ]
	global CurrentApplicationAddress
	itxn_field ApplicationArgs
	intc 9 //  headOffset
	intc 4 // 32
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	sha256
	sha256
	itxn_field ApplicationArgs
	frame_dig -4 // proof: bytes32[]
	dup
	len
	intc 4 // 32
	/
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	bytec 1 // 0x0000000000000003
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:341
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:345
	// assert(!this.participants({ id: id, address: sender.address }).exists)
	frame_dig -3 // id: uint64
	itob
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	box_len
	swap
	pop
	!
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:347
	// this.offers(id).value.acceptances += 1
	intc 7 //  headOffset
	dup
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	+
	itob
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_replace

	// contracts/arc58/plugins/hyper_swap.algo.ts:350
	// sendPayment({
	//             sender: sender.address,
	//             amount: 18_500,
	//             receiver: this.app.address,
	//             fee: 0,
	//         })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:351
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/hyper_swap.algo.ts:352
	// amount: 18_500
	pushint 18_500
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:353
	// receiver: this.app.address
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:354
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/arc58/plugins/hyper_swap.algo.ts:358
	// this.participants({ id: id, address: sender.address }).create(0)
	frame_dig -3 // id: uint64
	itob
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	intc 0 // 0
	box_create
	pop

	// *if3_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:360
	// offer.participantLeaves === (offer.acceptances + 1)
	pushint 88 // headOffset
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 7 //  headOffset
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	+
	==
	bz *if3_end

	// *if3_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:361
	// this.offers(id).value.state = STATE_ESCROWING
	intc 0 // 0
	bytec 6 // 0x0000000000000001
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_replace

*if3_end:
	// *if4_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:364
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if4_end

	// *if4_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:365
	// this.rekeyBack(sender.address)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub rekeyBack

*if4_end:
	retsub

// escrow(uint64,bool,uint64,address,uint64,uint64,byte[32][])void
*abi_route_escrow:
	// proof: byte[32][]
	txna ApplicationArgs 7
	extract 2 0

	// amount: uint64
	txna ApplicationArgs 6
	btoi

	// asset: uint64
	txna ApplicationArgs 5
	btoi

	// receiver: address
	txna ApplicationArgs 4
	dup
	len
	intc 4 // 32
	==

	// argument 3 (receiver) for escrow must be a address
	assert

	// id: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 5 (rekeyBack) for escrow must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute escrow(uint64,bool,uint64,address,uint64,uint64,byte[32][])void
	callsub escrow
	intc 1 // 1
	return

// escrow(sender: AppID, rekeyBack: boolean, id: uint64, receiver: Address, asset: AssetID, amount: uint64, proof: bytes32[]): void
//
// Escrows the assets in the trade for a given leaf in the tree
//
// @param sender the sender in the offer leaf
// @param id the id of the offer
// @param receiver the recipient in the offer leaf
// @param asset the asset in the offer leaf
// @param amount the amount in the offer leaf
// @param proof the proof to verify the details are part of the tree
escrow:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts/arc58/plugins/hyper_swap.algo.ts:389
	// assert(this.controls(sender.address))
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:391
	// assert(this.offers(id).exists)
	frame_dig -3 // id: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:392
	// offer = this.offers(id).value
	frame_dig -3 // id: uint64
	itob
	frame_bury 0 // storage key//offer

	// contracts/arc58/plugins/hyper_swap.algo.ts:394
	// assert(offer.state === STATE_ESCROWING)
	intc 0 // 0
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	==
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:396
	// assert(this.participants({ id: id, address: sender.address }).exists)
	frame_dig -3 // id: uint64
	itob
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:398
	// hash = sha256(sha256(concat(sender.address, concat(receiver, itob(asset) + itob(amount)))))
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -4 // receiver: Address
	frame_dig -5 // asset: AssetID
	itob
	frame_dig -6 // amount: uint64
	itob
	concat
	concat
	concat
	sha256
	sha256
	frame_bury 1 // hash: byte[32]

	// contracts/arc58/plugins/hyper_swap.algo.ts:399
	// assert(!this.hashes({ id: id, hash: hash }).exists)
	bytec 2 //  "h"
	frame_dig -3 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_len
	swap
	pop
	!
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:401
	// assert(
	//             sendMethodCall<typeof MetaMerkles.prototype.verify, boolean>({
	//                 applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles),
	//                 methodArgs: [
	//                     this.app.address,
	//                     offer.root,
	//                     hash,
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ],
	//                 fee: 0,
	//             })
	//         )
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 4 //  method "verify(address,string,byte[32],byte[32][],uint64)bool"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:403
	// applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:404
	// methodArgs: [
	//                     this.app.address,
	//                     offer.root,
	//                     hash,
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ]
	global CurrentApplicationAddress
	itxn_field ApplicationArgs
	intc 2 //  headOffset
	intc 4 // 32
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig 1 // hash: byte[32]
	itxn_field ApplicationArgs
	frame_dig -7 // proof: bytes32[]
	dup
	len
	intc 4 // 32
	/
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	bytec 1 // 0x0000000000000003
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:411
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:416
	// mbrAmount = 0
	intc 0 // 0
	frame_bury 2 // mbrAmount: uint64

	// *if5_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:418
	// asset.id === 0
	frame_dig -5 // asset: AssetID
	intc 0 // 0
	==
	bz *if5_else

	// *if5_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:419
	// sendPayment({
	//                 sender: sender.address,
	//                 amount: amount,
	//                 receiver: this.app.address,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:420
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/hyper_swap.algo.ts:421
	// amount: amount
	frame_dig -6 // amount: uint64
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:422
	// receiver: this.app.address
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:423
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if5_end

*if5_else:
	// *if6_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:427
	// !receiver.isOptedInToAsset(asset)
	frame_dig -4 // receiver: Address
	frame_dig -5 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if6_end

	// *if6_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:428
	// mbrAmount += globals.minBalance + globals.assetOptInMinBalance + globals.minTxnFee
	frame_dig 2 // mbrAmount: uint64
	global MinBalance
	global AssetOptInMinBalance
	+
	global MinTxnFee
	+
	+
	frame_bury 2 // mbrAmount: uint64

*if6_end:
	// *if7_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:431
	// !this.app.address.isOptedInToAsset(asset)
	global CurrentApplicationAddress
	frame_dig -5 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if7_end

	// *if7_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:432
	// this.pendingGroup.addAssetTransfer({
	//                     xferAsset: asset,
	//                     assetAmount: 0,
	//                     assetReceiver: this.app.address,
	//                     fee: 0,
	//                 })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:433
	// xferAsset: asset
	frame_dig -5 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:434
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:435
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:436
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:438
	// mbrAmount += globals.assetOptInMinBalance
	frame_dig 2 // mbrAmount: uint64
	global AssetOptInMinBalance
	+
	frame_bury 2 // mbrAmount: uint64

*if7_end:
	// contracts/arc58/plugins/hyper_swap.algo.ts:441
	// this.pendingGroup.addPayment({
	//                 sender: sender.address,
	//                 amount: mbrAmount,
	//                 receiver: this.app.address,
	//                 fee: 0,
	//             })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:442
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/hyper_swap.algo.ts:443
	// amount: mbrAmount
	frame_dig 2 // mbrAmount: uint64
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:444
	// receiver: this.app.address
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:445
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:448
	// this.pendingGroup.addAssetTransfer({
	//                 sender: sender.address,
	//                 xferAsset: asset,
	//                 assetAmount: amount,
	//                 assetReceiver: this.app.address,
	//                 fee: 0,
	//             })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:449
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/hyper_swap.algo.ts:450
	// xferAsset: asset
	frame_dig -5 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:451
	// assetAmount: amount
	frame_dig -6 // amount: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:452
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:453
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:456
	// leftOver = sender.address.assetBalance(asset) - amount
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -5 // asset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -6 // amount: uint64
	-
	frame_bury 3 // leftOver: uint64

	// *if8_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:457
	// leftOver === 0
	frame_dig 3 // leftOver: uint64
	intc 0 // 0
	==
	bz *if8_end

	// *if8_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:458
	// this.pendingGroup.addAssetTransfer({
	//                     sender: sender.address,
	//                     xferAsset: asset,
	//                     assetAmount: 0,
	//                     assetReceiver: asset.creator,
	//                     assetCloseTo: asset.creator,
	//                     fee: 0,
	//                 })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:459
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/hyper_swap.algo.ts:460
	// xferAsset: asset
	frame_dig -5 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:461
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:462
	// assetReceiver: asset.creator
	frame_dig -5 // asset: AssetID
	asset_params_get AssetCreator
	pop
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:463
	// assetCloseTo: asset.creator
	frame_dig -5 // asset: AssetID
	asset_params_get AssetCreator
	pop
	itxn_field AssetCloseTo

	// contracts/arc58/plugins/hyper_swap.algo.ts:464
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if8_end:
	// contracts/arc58/plugins/hyper_swap.algo.ts:468
	// this.pendingGroup.submit()
	itxn_submit

*if5_end:
	// contracts/arc58/plugins/hyper_swap.algo.ts:472
	// this.hashes({ id: id, hash: hash }).value = mbrAmount
	bytec 2 //  "h"
	frame_dig -3 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	frame_dig 2 // mbrAmount: uint64
	itob
	box_put

	// contracts/arc58/plugins/hyper_swap.algo.ts:474
	// this.offers(id).value.escrowed += 1
	intc 6 //  headOffset
	dup
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	+
	itob
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_replace

	// *if9_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:476
	// offer.leaves === (offer.escrowed + 1)
	pushint 40 // headOffset
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 6 //  headOffset
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	+
	==
	bz *if9_end

	// *if9_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:477
	// this.offers(id).value.state = STATE_DISBURSING
	intc 0 // 0
	pushbytes 0x0000000000000002
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_replace

*if9_end:
	retsub

// disburse(uint64,bool,uint64,uint64,uint64,uint64)void
*abi_route_disburse:
	// amount: uint64
	txna ApplicationArgs 6
	btoi

	// asset: uint64
	txna ApplicationArgs 5
	btoi

	// receiver: uint64
	txna ApplicationArgs 4
	btoi

	// id: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 4 (rekeyBack) for disburse must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute disburse(uint64,bool,uint64,uint64,uint64,uint64)void
	callsub disburse
	intc 1 // 1
	return

// disburse(sender: AppID, rekeyBack: boolean, id: uint64, receiver: AppID, asset: AssetID, amount: uint64): void
//
// Disburses assets for a leaf in the tree, ensuring ordered processing
//
// @param sender the sender abstracted account app id in the leaf
// @param id the id of the offer
// @param receiver the recipient abstracted account app id for the address in the leaf
// @param asset the asset being transferred
// @param amount the amount being transferred
disburse:
	proto 6 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts/arc58/plugins/hyper_swap.algo.ts:499
	// assert(this.offers(id).exists)
	frame_dig -3 // id: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:500
	// offer = this.offers(id).value
	frame_dig -3 // id: uint64
	itob
	frame_bury 0 // storage key//offer

	// contracts/arc58/plugins/hyper_swap.algo.ts:502
	// assert(offer.state === STATE_DISBURSING)
	intc 0 // 0
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	pushint 2
	==
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:505
	// hash = sha256(sha256(concat(sender.address, concat(receiver.address, itob(asset) + itob(amount)))))
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -4 // receiver: AppID
	app_params_get AppAddress
	pop
	frame_dig -5 // asset: AssetID
	itob
	frame_dig -6 // amount: uint64
	itob
	concat
	concat
	concat
	sha256
	sha256
	frame_bury 1 // hash: byte[32]

	// contracts/arc58/plugins/hyper_swap.algo.ts:506
	// assert(this.hashes({ id: id, hash: hash }).exists)
	bytec 2 //  "h"
	frame_dig -3 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_len
	swap
	pop
	assert

	// *if10_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:509
	// asset.id === 0
	frame_dig -5 // asset: AssetID
	intc 0 // 0
	==
	bz *if10_else

	// *if10_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:510
	// sendPayment({
	//                 amount: amount,
	//                 receiver: receiver.address,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:511
	// amount: amount
	frame_dig -6 // amount: uint64
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:512
	// receiver: receiver.address
	frame_dig -4 // receiver: AppID
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:513
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if10_end

*if10_else:
	// *if11_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:516
	// !receiver.address.isOptedInToAsset(asset)
	frame_dig -4 // receiver: AppID
	app_params_get AppAddress
	pop
	frame_dig -5 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if11_else

	// *if11_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:517
	// canCallArc58OptIn = this.canCallArc58OptIn(receiver)
	frame_dig -4 // receiver: AppID
	callsub canCallArc58OptIn
	frame_bury 2 // canCallArc58OptIn: bool

	// *if12_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:518
	// canCallArc58OptIn
	frame_dig 2 // canCallArc58OptIn: bool
	bz *if12_else

	// *if12_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:520
	// this.arc58OptInAndSend(receiver, asset, amount)
	frame_dig -6 // amount: uint64
	frame_dig -5 // asset: AssetID
	frame_dig -4 // receiver: AppID
	callsub arc58OptInAndSend
	b *if12_end

*if12_else:
	// contracts/arc58/plugins/hyper_swap.algo.ts:523
	// this.arc59OptInAndSend(receiver, asset, amount)
	frame_dig -6 // amount: uint64
	frame_dig -5 // asset: AssetID
	frame_dig -4 // receiver: AppID
	callsub arc59OptInAndSend

*if12_end:
	b *if11_end

*if11_else:
	// contracts/arc58/plugins/hyper_swap.algo.ts:526
	// this.pendingGroup.addAssetTransfer({
	//                     xferAsset: asset,
	//                     assetAmount: amount,
	//                     assetReceiver: receiver.address,
	//                     fee: 0,
	//                 })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:527
	// xferAsset: asset
	frame_dig -5 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:528
	// assetAmount: amount
	frame_dig -6 // amount: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:529
	// assetReceiver: receiver.address
	frame_dig -4 // receiver: AppID
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:530
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:533
	// refundAmount = this.hashes({ id: id, hash: hash }).value
	bytec 2 //  "h"
	frame_dig -3 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_get

	// box value does not exist: this.hashes({ id: id, hash: hash }).value
	assert
	btoi
	frame_bury 3 // refundAmount: uint64

	// *if13_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:534
	// (this.app.address.assetBalance(asset) - amount) === 0
	global CurrentApplicationAddress
	frame_dig -5 // asset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -6 // amount: uint64
	-
	intc 0 // 0
	==
	bz *if13_else

	// *if13_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:535
	// this.pendingGroup.addAssetTransfer({
	//                         xferAsset: asset,
	//                         assetAmount: 0,
	//                         assetReceiver: asset.creator,
	//                         assetCloseTo: asset.creator,
	//                         fee: 0,
	//                     })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:536
	// xferAsset: asset
	frame_dig -5 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:537
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:538
	// assetReceiver: asset.creator
	frame_dig -5 // asset: AssetID
	asset_params_get AssetCreator
	pop
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:539
	// assetCloseTo: asset.creator
	frame_dig -5 // asset: AssetID
	asset_params_get AssetCreator
	pop
	itxn_field AssetCloseTo

	// contracts/arc58/plugins/hyper_swap.algo.ts:540
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	b *if13_end

*if13_else:
	// contracts/arc58/plugins/hyper_swap.algo.ts:543
	// refundAmount -= globals.assetOptInMinBalance
	frame_dig 3 // refundAmount: uint64
	global AssetOptInMinBalance
	-
	frame_bury 3 // refundAmount: uint64

*if13_end:
	// contracts/arc58/plugins/hyper_swap.algo.ts:546
	// this.pendingGroup.addPayment({
	//                     amount: refundAmount,
	//                     receiver: sender.address,
	//                     fee: 0,
	//                 })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:547
	// amount: refundAmount
	frame_dig 3 // refundAmount: uint64
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:548
	// receiver: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:549
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if11_end:

*if10_end:
	// contracts/arc58/plugins/hyper_swap.algo.ts:554
	// this.hashes({ id: id, hash: hash }).delete()
	bytec 2 //  "h"
	frame_dig -3 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_del

	// contracts/arc58/plugins/hyper_swap.algo.ts:555
	// this.offers(id).value.escrowed -= 1
	intc 6 //  headOffset
	dup
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	-
	itob
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_replace

	// *if14_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:558
	// (offer.escrowed - 1) === 0
	intc 6 //  headOffset
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	-
	intc 0 // 0
	==
	bz *if14_end

	// *if14_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:559
	// this.offers(id).value.state = STATE_COMPLETED
	intc 0 // 0
	bytec 1 // 0x0000000000000003
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_replace

*if14_end:
	retsub

// cancel(uint64,bool,uint64,byte[32][])void
*abi_route_cancel:
	// proof: byte[32][]
	txna ApplicationArgs 4
	extract 2 0

	// id: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 2 (rekeyBack) for cancel must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute cancel(uint64,bool,uint64,byte[32][])void
	callsub cancel
	intc 1 // 1
	return

// cancel(sender: AppID, rekeyBack: boolean, id: uint64, proof: bytes32[]): void
//
//
// @param sender the abstracted account of the user cancelling the swap
// @param id the id of the offer being cancelled
// @param proof a proof of inclusion in the participants list
cancel:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/arc58/plugins/hyper_swap.algo.ts:570
	// assert(this.controls(sender.address))
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:572
	// assert(this.offers(id).exists)
	frame_dig -3 // id: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:573
	// offer = this.offers(id).value
	frame_dig -3 // id: uint64
	itob
	frame_bury 0 // storage key//offer

	// contracts/arc58/plugins/hyper_swap.algo.ts:575
	// assert(offer.state === STATE_OFFERED || offer.state === STATE_ESCROWING)
	intc 0 // 0
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 0 // 0
	==
	dup
	bnz *skip_or1
	intc 0 // 0
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	==
	||

*skip_or1:
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:577
	// assert(
	//             sendMethodCall<typeof MetaMerkles.prototype.verify, boolean>({
	//                 applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles),
	//                 methodArgs: [
	//                     this.app.address,
	//                     offer.participantRoot,
	//                     sha256(sha256(sender.address)),
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ],
	//                 fee: 0,
	//             })
	//         )
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 4 //  method "verify(address,string,byte[32],byte[32][],uint64)bool"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:579
	// applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:580
	// methodArgs: [
	//                     this.app.address,
	//                     offer.participantRoot,
	//                     sha256(sha256(sender.address)),
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ]
	global CurrentApplicationAddress
	itxn_field ApplicationArgs
	intc 9 //  headOffset
	intc 4 // 32
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	sha256
	sha256
	itxn_field ApplicationArgs
	frame_dig -4 // proof: bytes32[]
	dup
	len
	intc 4 // 32
	/
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	bytec 1 // 0x0000000000000003
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:587
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:591
	// this.offers(id).value.state = STATE_CANCELLED
	intc 0 // 0
	bytec 7 // 0x0000000000000004
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_replace
	retsub

// withdraw(uint64,bool,uint64,address,uint64,uint64,byte[32][])void
*abi_route_withdraw:
	// proof: byte[32][]
	txna ApplicationArgs 7
	extract 2 0

	// amount: uint64
	txna ApplicationArgs 6
	btoi

	// asset: uint64
	txna ApplicationArgs 5
	btoi

	// receiver: address
	txna ApplicationArgs 4
	dup
	len
	intc 4 // 32
	==

	// argument 3 (receiver) for withdraw must be a address
	assert

	// id: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 5 (rekeyBack) for withdraw must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute withdraw(uint64,bool,uint64,address,uint64,uint64,byte[32][])void
	callsub withdraw
	intc 1 // 1
	return

// withdraw(sender: AppID, rekeyBack: boolean, id: uint64, receiver: Address, asset: AssetID, amount: uint64, proof: bytes32[]): void
//
// Withdraws your assets from a cancelled swap if they're escrowed
//
// @param sender the abstracted account of the user reclaiming their assets
// @param id the id of the cancelled offer
// @param receiver the receiver of the leaf's swap
// @param asset the asset of the leaf's swap
// @param amount the amount of the leaf's swap
// @param proof the proof that the leaf is in the tree
// @param rekeyBack whether the abstracted account should be rekeyed back at the end
withdraw:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/arc58/plugins/hyper_swap.algo.ts:615
	// assert(this.controls(sender.address))
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:617
	// assert(this.offers(id).exists)
	frame_dig -3 // id: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:618
	// offer = this.offers(id).value
	frame_dig -3 // id: uint64
	itob
	frame_bury 0 // storage key//offer

	// contracts/arc58/plugins/hyper_swap.algo.ts:620
	// assert(offer.state === STATE_CANCELLED)
	intc 0 // 0
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 5 // 4
	==
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:622
	// assert(offer.escrowed > 0)
	intc 6 //  headOffset
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 0 // 0
	>
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:624
	// hash = sha256(sha256(concat(sender.address, concat(receiver, itob(asset) + itob(amount)))))
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -4 // receiver: Address
	frame_dig -5 // asset: AssetID
	itob
	frame_dig -6 // amount: uint64
	itob
	concat
	concat
	concat
	sha256
	sha256
	frame_bury 1 // hash: byte[32]

	// contracts/arc58/plugins/hyper_swap.algo.ts:625
	// assert(this.hashes({ id: id, hash: hash }).exists)
	bytec 2 //  "h"
	frame_dig -3 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:627
	// assert(
	//             sendMethodCall<typeof MetaMerkles.prototype.verify, boolean>({
	//                 applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles),
	//                 methodArgs: [
	//                     this.app.address,
	//                     offer.root,
	//                     hash,
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ],
	//                 fee: 0,
	//             })
	//         )
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 4 //  method "verify(address,string,byte[32],byte[32][],uint64)bool"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:629
	// applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:630
	// methodArgs: [
	//                     this.app.address,
	//                     offer.root,
	//                     hash,
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ]
	global CurrentApplicationAddress
	itxn_field ApplicationArgs
	intc 2 //  headOffset
	intc 4 // 32
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig 1 // hash: byte[32]
	itxn_field ApplicationArgs
	frame_dig -7 // proof: bytes32[]
	dup
	len
	intc 4 // 32
	/
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	bytec 1 // 0x0000000000000003
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:637
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	assert

	// *if15_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:641
	// asset.id === 0
	frame_dig -5 // asset: AssetID
	intc 0 // 0
	==
	bz *if15_else

	// *if15_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:642
	// sendPayment({
	//                 amount: amount,
	//                 receiver: sender.address,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:643
	// amount: amount
	frame_dig -6 // amount: uint64
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:644
	// receiver: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:645
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// *if16_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:648
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if16_end

	// *if16_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:649
	// this.rekeyBack(sender.address)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub rekeyBack

*if16_end:
	b *if15_end

*if15_else:
	// *if17_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:653
	// !sender.address.isOptedInToAsset(asset) && rekeyBack
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -5 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	dup
	bz *skip_and0
	frame_dig -2 // rekeyBack: boolean
	&&

*skip_and0:
	bz *if17_elseif1_condition

	// *if17_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:654
	// this.pendingGroup.addAssetTransfer({
	//                     sender: sender.address,
	//                     xferAsset: asset,
	//                     assetAmount: 0,
	//                     assetReceiver: sender.address,
	//                     rekeyTo: sender.address,
	//                     fee: 0,
	//                 })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:655
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/hyper_swap.algo.ts:656
	// xferAsset: asset
	frame_dig -5 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:657
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:658
	// assetReceiver: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:659
	// rekeyTo: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field RekeyTo

	// contracts/arc58/plugins/hyper_swap.algo.ts:660
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	b *if17_end

*if17_elseif1_condition:
	// contracts/arc58/plugins/hyper_swap.algo.ts:662
	// !sender.address.isOptedInToAsset(asset)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -5 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if17_end

	// *if17_elseif1_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:663
	// this.pendingGroup.addAssetTransfer({
	//                     sender: sender.address,
	//                     xferAsset: asset,
	//                     assetAmount: 0,
	//                     assetReceiver: sender.address,
	//                     fee: 0,
	//                 })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:664
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/hyper_swap.algo.ts:665
	// xferAsset: asset
	frame_dig -5 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:666
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:667
	// assetReceiver: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:668
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if17_end:
	// contracts/arc58/plugins/hyper_swap.algo.ts:672
	// this.pendingGroup.addAssetTransfer({
	//                 xferAsset: asset,
	//                 assetAmount: amount,
	//                 assetReceiver: sender.address,
	//                 fee: 0,
	//             })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:673
	// xferAsset: asset
	frame_dig -5 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:674
	// assetAmount: amount
	frame_dig -6 // amount: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:675
	// assetReceiver: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:676
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:679
	// this.pendingGroup.submit()
	itxn_submit

*if15_end:
	// contracts/arc58/plugins/hyper_swap.algo.ts:683
	// this.hashes({ id: id, hash: hash }).delete()
	bytec 2 //  "h"
	frame_dig -3 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_del

	// contracts/arc58/plugins/hyper_swap.algo.ts:685
	// this.offers(id).value.escrowed -= 1
	intc 6 //  headOffset
	dup
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	-
	itob
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_replace

	// *if18_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:687
	// (offer.escrowed - 1) === 0
	intc 6 //  headOffset
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	-
	intc 0 // 0
	==
	bz *if18_end

	// *if18_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:688
	// this.offers(id).value.state = STATE_CANCEL_COMPLETED
	intc 0 // 0
	pushbytes 0x0000000000000005
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_replace

*if18_end:
	retsub

*abi_route_createApplication:
	intc 1 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xcfec8b31 // method "offer(uint64,bool,byte[32],uint64,byte[32],uint64,uint64,address,uint64)void"
	pushbytes 0xf9dbd50c // method "accept(uint64,bool,uint64,byte[32][])void"
	pushbytes 0x9e290396 // method "escrow(uint64,bool,uint64,address,uint64,uint64,byte[32][])void"
	pushbytes 0x5e7153f1 // method "disburse(uint64,bool,uint64,uint64,uint64,uint64)void"
	pushbytes 0x7f0ad198 // method "cancel(uint64,bool,uint64,byte[32][])void"
	pushbytes 0xb63ab0d3 // method "withdraw(uint64,bool,uint64,address,uint64,uint64,byte[32][])void"
	txna ApplicationArgs 0
	match *abi_route_offer *abi_route_accept *abi_route_escrow *abi_route_disburse *abi_route_cancel *abi_route_withdraw

	// this contract does not implement the given ABI method for call NoOp
	err