#pragma version 10
intcblock 0 1 8 6 32 4 48 96 83500 56
bytecblock 0x 0x0000000000000003 0x68 0x0000000000000000 0x636f756e746572 0x2bf3cc5a 0x0000000000000001 0x0000000000000004 0x64ccf1d3

// This TEAL was generated by TEALScript v0.105.5
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 3 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// controls(address: Address): boolean
controls:
	proto 1 1

	// contracts/arc58/plugins/hyper_swap.algo.ts:98
	// return address.authAddr === this.app.address;
	frame_dig -1 // address: Address
	acct_params_get AcctAuthAddr
	pop
	global CurrentApplicationAddress
	==
	retsub

// rekeyBack(address: Address): void
rekeyBack:
	proto 1 0

	// contracts/arc58/plugins/hyper_swap.algo.ts:102
	// sendPayment({
	//             sender: address,
	//             amount: 0,
	//             receiver: address,
	//             rekeyTo: address,
	//             fee: 0,
	//         })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:103
	// sender: address
	frame_dig -1 // address: Address
	itxn_field Sender

	// contracts/arc58/plugins/hyper_swap.algo.ts:104
	// amount: 0
	intc 0 // 0
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:105
	// receiver: address
	frame_dig -1 // address: Address
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:106
	// rekeyTo: address
	frame_dig -1 // address: Address
	itxn_field RekeyTo

	// contracts/arc58/plugins/hyper_swap.algo.ts:107
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// canCallArc58OptIn(walletAppID: AppID): boolean
canCallArc58OptIn:
	proto 1 1

	// contracts/arc58/plugins/hyper_swap.algo.ts:112
	// return sendMethodCall<typeof AbstractedAccount.prototype.arc58_canCall, boolean>({
	//             applicationID: walletAppID,
	//             methodArgs: [
	//                 AppID.fromUint64(AkitaAppIDsOptinPlugin),
	//                 this.app.address,
	//             ],
	//             fee: 0,
	//         });
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0xe9026da8 // method "arc58_canCall(uint64,address)bool"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:113
	// applicationID: walletAppID
	frame_dig -1 // walletAppID: AppID
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:114
	// methodArgs: [
	//                 AppID.fromUint64(AkitaAppIDsOptinPlugin),
	//                 this.app.address,
	//             ]
	bytec 3 // 0x0000000000000000
	itxn_field ApplicationArgs
	global CurrentApplicationAddress
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:118
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	retsub

// arc58OptInAndSend(recipientAppID: AppID, asset: AssetID, amount: uint64): void
arc58OptInAndSend:
	proto 3 0

	// contracts/arc58/plugins/hyper_swap.algo.ts:123
	// this.pendingGroup.addMethodCall<typeof AbstractedAccount.prototype.arc58_rekeyToPlugin, void>({
	//             applicationID: recipientAppID,
	//             methodArgs: [
	//                 AppID.fromUint64(AkitaAppIDsOptinPlugin),
	//             ],
	//             fee: 0,
	//         })
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0x7c766ddc // method "arc58_rekeyToPlugin(uint64)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:124
	// applicationID: recipientAppID
	frame_dig -1 // recipientAppID: AppID
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:125
	// methodArgs: [
	//                 AppID.fromUint64(AkitaAppIDsOptinPlugin),
	//             ]
	bytec 3 // 0x0000000000000000
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:128
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:131
	// this.pendingGroup.addMethodCall<typeof OptInPlugin.prototype.optInToAsset, void>({
	//             applicationID: AppID.fromUint64(AkitaAppIDsOptinPlugin),
	//             methodArgs: [
	//                 recipientAppID,
	//                 true,
	//                 asset,
	//                 {
	//                     receiver: recipientAppID.address,
	//                     amount: globals.assetOptInMinBalance,
	//                     fee: 0,
	//                 }
	//             ],
	//             fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:138
	// receiver: recipientAppID.address
	frame_dig -1 // recipientAppID: AppID
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:139
	// amount: globals.assetOptInMinBalance
	global AssetOptInMinBalance
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:140
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0xbfcbeee9 // method "optInToAsset(uint64,bool,uint64,pay)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:132
	// applicationID: AppID.fromUint64(AkitaAppIDsOptinPlugin)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:133
	// methodArgs: [
	//                 recipientAppID,
	//                 true,
	//                 asset,
	//                 {
	//                     receiver: recipientAppID.address,
	//                     amount: globals.assetOptInMinBalance,
	//                     fee: 0,
	//                 }
	//             ]
	frame_dig -1 // recipientAppID: AppID
	itob
	itxn_field ApplicationArgs
	intc 1 // 1
	pushbytes 0x00
	intc 0 // 0
	uncover 2
	setbit
	itxn_field ApplicationArgs
	frame_dig -2 // asset: AssetID
	itob
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:143
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:146
	// this.pendingGroup.addMethodCall<typeof AbstractedAccount.prototype.arc58_verifyAuthAddr, void>({
	//             applicationID: recipientAppID,
	//             fee: 0,
	//         })
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0x0f885493 // method "arc58_verifyAuthAddr()void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:147
	// applicationID: recipientAppID
	frame_dig -1 // recipientAppID: AppID
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:148
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:151
	// this.pendingGroup.addAssetTransfer({
	//             assetReceiver: recipientAppID.address,
	//             assetAmount: amount,
	//             xferAsset: asset,
	//             fee: 0,
	//         })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:152
	// assetReceiver: recipientAppID.address
	frame_dig -1 // recipientAppID: AppID
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:153
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:154
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:155
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:158
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// arc59OptInAndSend(recipientAppID: AppID, asset: AssetID, amount: uint64): void
arc59OptInAndSend:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts/arc58/plugins/hyper_swap.algo.ts:162
	// canCallData = sendMethodCall<typeof AssetInbox.prototype.arc59_getSendAssetInfo, arc59GetSendAssetInfoResponse>({
	//             applicationID: AppID.fromUint64(OtherAppIDsAssetInbox),
	//             methodArgs: [
	//                 recipientAppID.address,
	//                 asset.id,
	//             ],
	//             fee: 0,
	//         })
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0xcaa8daa5 // method "arc59_getSendAssetInfo(address,uint64)(uint64,uint64,bool,bool,uint64)"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:163
	// applicationID: AppID.fromUint64(OtherAppIDsAssetInbox)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:164
	// methodArgs: [
	//                 recipientAppID.address,
	//                 asset.id,
	//             ]
	frame_dig -1 // recipientAppID: AppID
	app_params_get AppAddress
	pop
	itxn_field ApplicationArgs
	frame_dig -2 // asset: AssetID
	itob
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:168
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 0 // canCallData: (uint64,uint64,bool,bool,uint64)

	// contracts/arc58/plugins/hyper_swap.algo.ts:171
	// mbr = canCallData.mbr
	frame_dig 0 // canCallData: (uint64,uint64,bool,bool,uint64)
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	frame_bury 1 // mbr: uint64

	// contracts/arc58/plugins/hyper_swap.algo.ts:172
	// routerOptedIn = canCallData.routerOptedIn
	frame_dig 0 // canCallData: (uint64,uint64,bool,bool,uint64)
	store 255 // full array
	load 255 // full array
	pushint 128
	getbit
	frame_bury 2 // routerOptedIn: bool

	// contracts/arc58/plugins/hyper_swap.algo.ts:173
	// receiverAlgoNeededForClaim = canCallData.receiverAlgoNeededForClaim
	frame_dig 0 // canCallData: (uint64,uint64,bool,bool,uint64)
	store 255 // full array
	load 255 // full array
	extract 17 8
	btoi
	frame_bury 3 // receiverAlgoNeededForClaim: uint64

	// *if0_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:175
	// mbr || receiverAlgoNeededForClaim
	frame_dig 1 // mbr: uint64
	dup
	bnz *skip_or0
	frame_dig 3 // receiverAlgoNeededForClaim: uint64
	||

*skip_or0:
	bz *if0_end

	// *if0_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:176
	// this.pendingGroup.addPayment({
	//                 receiver: AppID.fromUint64(OtherAppIDsAssetInbox).address,
	//                 amount: (mbr + receiverAlgoNeededForClaim),
	//                 fee: 0,
	//             })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:177
	// receiver: AppID.fromUint64(OtherAppIDsAssetInbox).address
	intc 0 // 0
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:178
	// amount: (mbr + receiverAlgoNeededForClaim)
	frame_dig 1 // mbr: uint64
	frame_dig 3 // receiverAlgoNeededForClaim: uint64
	+
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:179
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if0_end:
	// *if1_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:183
	// !routerOptedIn
	frame_dig 2 // routerOptedIn: bool
	!
	bz *if1_end

	// *if1_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:184
	// this.pendingGroup.addMethodCall<typeof AssetInbox.prototype.arc59_optRouterIn, void>({
	//                 applicationID: AppID.fromUint64(OtherAppIDsAssetInbox),
	//                 methodArgs: [asset.id],
	//                 fee: 0
	//             })
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0xe8540810 // method "arc59_optRouterIn(uint64)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:185
	// applicationID: AppID.fromUint64(OtherAppIDsAssetInbox)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:186
	// methodArgs: [asset.id]
	frame_dig -2 // asset: AssetID
	itob
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:187
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if1_end:
	// contracts/arc58/plugins/hyper_swap.algo.ts:191
	// this.pendingGroup.addMethodCall<typeof AssetInbox.prototype.arc59_sendAsset, Address>({
	//             applicationID: AppID.fromUint64(OtherAppIDsAssetInbox),
	//             methodArgs: [
	//                 {
	//                     assetReceiver: AppID.fromUint64(OtherAppIDsAssetInbox).address,
	//                     assetAmount: amount,
	//                     xferAsset: asset,
	//                     fee: 0,
	//                 },
	//                 recipientAppID.address,
	//                 receiverAlgoNeededForClaim,
	//             ],
	//             fee: 0
	//         })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:195
	// assetReceiver: AppID.fromUint64(OtherAppIDsAssetInbox).address
	intc 0 // 0
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:196
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:197
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:198
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0x08531ed7 // method "arc59_sendAsset(axfer,address,uint64)address"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:192
	// applicationID: AppID.fromUint64(OtherAppIDsAssetInbox)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:193
	// methodArgs: [
	//                 {
	//                     assetReceiver: AppID.fromUint64(OtherAppIDsAssetInbox).address,
	//                     assetAmount: amount,
	//                     xferAsset: asset,
	//                     fee: 0,
	//                 },
	//                 recipientAppID.address,
	//                 receiverAlgoNeededForClaim,
	//             ]
	frame_dig -1 // recipientAppID: AppID
	app_params_get AppAddress
	pop
	itxn_field ApplicationArgs
	frame_dig 3 // receiverAlgoNeededForClaim: uint64
	itob
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:203
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:206
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// offer(address,byte[32],uint64,byte[32],uint64,uint64,address,uint64)void
*abi_route_offer:
	// marketFee: uint64
	txna ApplicationArgs 8
	btoi

	// marketplace: address
	txna ApplicationArgs 7
	dup
	len
	intc 4 // 32
	==

	// argument 1 (marketplace) for offer must be a address
	assert

	// expiration: uint64
	txna ApplicationArgs 6
	btoi

	// participantLeaves: uint64
	txna ApplicationArgs 5
	btoi

	// participantsRoot: byte[32]
	txna ApplicationArgs 4
	dup
	len
	intc 4 // 32
	==

	// argument 4 (participantsRoot) for offer must be a byte[32]
	assert

	// leaves: uint64
	txna ApplicationArgs 3
	btoi

	// root: byte[32]
	txna ApplicationArgs 2
	dup
	len
	intc 4 // 32
	==

	// argument 6 (root) for offer must be a byte[32]
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	intc 4 // 32
	==

	// argument 7 (sender) for offer must be a address
	assert

	// execute offer(address,byte[32],uint64,byte[32],uint64,uint64,address,uint64)void
	callsub offer
	intc 1 // 1
	return

// offer(sender: Address, root: bytes32, leaves: uint64, participantsRoot: bytes32, participantLeaves: uint64, expiration: uint64, marketplace: Address, marketFee: uint64): void
//
// Creates a merkle tree based atomic payment/xfer group
//
// @param sender the account creating the offering
// @param root the merkle tree root of trades consisting of from address, recipient address, asset id & amount
// @param leaves the number of leaves in the tree
// @param participantsRoot the merkle tree root of participating addresses
// @param participantLeaves the number of leaves in the participant tree
// @param expiration the unix timestamp that the offer auto-expires at if it has not been accepted by all participants
// @param marketplace the address of the marketplace to pay the fee to
// @param marketFee the fee to pay the marketplace for facilitating the offer
offer:
	proto 8 0

	// contracts/arc58/plugins/hyper_swap.algo.ts:231
	// assert(root !== participantsRoot, errs.BAD_ROOTS)
	frame_dig -2 // root: bytes32
	frame_dig -4 // participantsRoot: bytes32
	!=
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:234
	// this.pendingGroup.addPayment({
	//             sender: sender,
	//             receiver: marketplace,
	//             amount: marketFee,
	//             fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:235
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/hyper_swap.algo.ts:236
	// receiver: marketplace
	frame_dig -7 // marketplace: Address
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:237
	// amount: marketFee
	frame_dig -8 // marketFee: uint64
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:238
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:242
	// this.pendingGroup.addMethodCall<typeof MetaMerkles.prototype.addRoot, boolean>({
	//             applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles),
	//             methodArgs: [
	//                 {
	//                     amount: (MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR),
	//                     receiver: AppID.fromUint64(AkitaAppIDsMetaMerkles).address,
	//                     fee: 0,
	//                 },
	//                 root,
	//                 root,
	//                 META_MERKLE_TRADE_SCHEMA,
	//                 META_MERKLE_TRADE_TYPE
	//             ],
	//             fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:246
	// amount: (MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR)
	intc 8 // 83500
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:247
	// receiver: AppID.fromUint64(AkitaAppIDsMetaMerkles).address
	intc 0 // 0
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:248
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 8 //  method "addRoot(pay,string,byte[32],uint64,uint64)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:243
	// applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:244
	// methodArgs: [
	//                 {
	//                     amount: (MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR),
	//                     receiver: AppID.fromUint64(AkitaAppIDsMetaMerkles).address,
	//                     fee: 0,
	//                 },
	//                 root,
	//                 root,
	//                 META_MERKLE_TRADE_SCHEMA,
	//                 META_MERKLE_TRADE_TYPE
	//             ]
	frame_dig -2 // root: bytes32
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -2 // root: bytes32
	itxn_field ApplicationArgs
	bytec 7 // 0x0000000000000004
	itxn_field ApplicationArgs
	bytec 1 // 0x0000000000000003
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:255
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:259
	// this.pendingGroup.addMethodCall<typeof MetaMerkles.prototype.addRoot, boolean>({
	//             applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles),
	//             methodArgs: [
	//                 {
	//                     amount: (MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR),
	//                     receiver: AppID.fromUint64(AkitaAppIDsMetaMerkles).address,
	//                     fee: 0,
	//                 },
	//                 participantsRoot,
	//                 participantsRoot,
	//                 META_MERKLE_ADDRESS_SCHEMA,
	//                 META_MERKLE_TRADE_TYPE
	//             ],
	//             fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:263
	// amount: (MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR)
	intc 8 // 83500
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:264
	// receiver: AppID.fromUint64(AkitaAppIDsMetaMerkles).address
	intc 0 // 0
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:265
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 8 //  method "addRoot(pay,string,byte[32],uint64,uint64)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:260
	// applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:261
	// methodArgs: [
	//                 {
	//                     amount: (MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR),
	//                     receiver: AppID.fromUint64(AkitaAppIDsMetaMerkles).address,
	//                     fee: 0,
	//                 },
	//                 participantsRoot,
	//                 participantsRoot,
	//                 META_MERKLE_ADDRESS_SCHEMA,
	//                 META_MERKLE_TRADE_TYPE
	//             ]
	frame_dig -4 // participantsRoot: bytes32
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -4 // participantsRoot: bytes32
	itxn_field ApplicationArgs
	bytec 6 // 0x0000000000000001
	itxn_field ApplicationArgs
	bytec 1 // 0x0000000000000003
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:272
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:276
	// this.pendingGroup.submit()
	itxn_submit

	// contracts/arc58/plugins/hyper_swap.algo.ts:279
	// this.participants({ id: this.counter.value, address: sender }).create(0)
	bytec 4 //  "counter"
	app_global_get
	itob
	frame_dig -1 // sender: Address
	concat
	intc 0 // 0
	box_create
	pop

	// contracts/arc58/plugins/hyper_swap.algo.ts:282
	// this.offers(this.counter.value).value = {
	//             state: STATE_OFFERED,
	//             root: root,
	//             leaves: leaves,
	//             escrowed: 0,
	//             participantRoot: participantsRoot,
	//             participantLeaves: participantLeaves,
	//             acceptances: 1,
	//             expiration: expiration
	//         }
	bytec 4 //  "counter"
	app_global_get
	itob
	bytec 3 // 0x0000000000000000
	frame_dig -2 // root: bytes32
	concat
	frame_dig -3 // leaves: uint64
	itob
	concat
	bytec 3 // 0x0000000000000000
	concat
	frame_dig -4 // participantsRoot: bytes32
	concat
	frame_dig -5 // participantLeaves: uint64
	itob
	concat
	bytec 6 // 0x0000000000000001
	concat
	frame_dig -6 // expiration: uint64
	itob
	concat
	box_put

	// contracts/arc58/plugins/hyper_swap.algo.ts:294
	// this.counter.value += 1
	bytec 4 //  "counter"
	app_global_get
	intc 1 // 1
	+
	bytec 4 //  "counter"
	swap
	app_global_put
	retsub

// accept(uint64,uint64,byte[32][])void
*abi_route_accept:
	// proof: byte[32][]
	txna ApplicationArgs 3
	extract 2 0

	// id: uint64
	txna ApplicationArgs 2
	btoi

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute accept(uint64,uint64,byte[32][])void
	callsub accept
	intc 1 // 1
	return

// accept(sender: AppID, id: uint64, proof: bytes32[]): void
//
// Accepts an offer
//
// @param sender the account accepting the offering
// @param id the id of the offer being accepted
// @param proof the bytes32 array proof of inclusion in the participants list
accept:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/arc58/plugins/hyper_swap.algo.ts:306
	// assert(this.controls(sender.address))
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:308
	// assert(this.offers(id).exists)
	frame_dig -2 // id: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:309
	// offer = this.offers(id).value
	frame_dig -2 // id: uint64
	itob
	frame_bury 0 // storage key//offer

	// contracts/arc58/plugins/hyper_swap.algo.ts:311
	// assert(offer.state === STATE_OFFERED)
	intc 0 // 0
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 0 // 0
	==
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:313
	// assert(
	//             sendMethodCall<typeof MetaMerkles.prototype.verify, boolean>({
	//                 applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles),
	//                 methodArgs: [
	//                     this.app.address,
	//                     offer.participantRoot,
	//                     sha256(sha256(sender.address)),
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ],
	//                 fee: 0,
	//             })
	//         )
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 5 //  method "verify(address,string,byte[32],byte[32][],uint64)bool"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:315
	// applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:316
	// methodArgs: [
	//                     this.app.address,
	//                     offer.participantRoot,
	//                     sha256(sha256(sender.address)),
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ]
	global CurrentApplicationAddress
	itxn_field ApplicationArgs
	intc 9 //  headOffset
	intc 4 // 32
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	sha256
	sha256
	itxn_field ApplicationArgs
	frame_dig -3 // proof: bytes32[]
	dup
	len
	intc 4 // 32
	/
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	bytec 1 // 0x0000000000000003
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:323
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:327
	// assert(!this.participants({ id: id, address: sender.address }).exists)
	frame_dig -2 // id: uint64
	itob
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	box_len
	swap
	pop
	!
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:329
	// this.offers(id).value.acceptances += 1
	intc 7 //  headOffset
	dup
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	+
	itob
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_replace

	// contracts/arc58/plugins/hyper_swap.algo.ts:331
	// this.participants({ id: id, address: sender.address }).create(0)
	frame_dig -2 // id: uint64
	itob
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	intc 0 // 0
	box_create
	pop

	// *if2_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:333
	// offer.participantLeaves === (offer.acceptances + 1)
	pushint 88 // headOffset
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 7 //  headOffset
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	+
	==
	bz *if2_end

	// *if2_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:334
	// this.offers(id).value.state = STATE_ESCROWING
	intc 0 // 0
	bytec 6 // 0x0000000000000001
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_replace

*if2_end:
	retsub

// escrow(uint64,uint64,address,uint64,uint64,byte[32][])void
*abi_route_escrow:
	// proof: byte[32][]
	txna ApplicationArgs 6
	extract 2 0

	// amount: uint64
	txna ApplicationArgs 5
	btoi

	// asset: uint64
	txna ApplicationArgs 4
	btoi

	// receiver: address
	txna ApplicationArgs 3
	dup
	len
	intc 4 // 32
	==

	// argument 3 (receiver) for escrow must be a address
	assert

	// id: uint64
	txna ApplicationArgs 2
	btoi

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute escrow(uint64,uint64,address,uint64,uint64,byte[32][])void
	callsub escrow
	intc 1 // 1
	return

// escrow(sender: AppID, id: uint64, receiver: Address, asset: AssetID, amount: uint64, proof: bytes32[]): void
//
// Escrows the assets in the trade for a given leaf in the tree
//
// @param sender the sender in the offer leaf
// @param id the id of the offer
// @param receiver the recipient in the offer leaf
// @param asset the asset in the offer leaf
// @param amount the amount in the offer leaf
// @param proof the proof to verify the details are part of the tree
escrow:
	proto 6 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts/arc58/plugins/hyper_swap.algo.ts:357
	// assert(this.controls(sender.address))
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:359
	// assert(this.offers(id).exists)
	frame_dig -2 // id: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:360
	// offer = this.offers(id).value
	frame_dig -2 // id: uint64
	itob
	frame_bury 0 // storage key//offer

	// contracts/arc58/plugins/hyper_swap.algo.ts:362
	// assert(offer.state === STATE_ESCROWING)
	intc 0 // 0
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	==
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:364
	// assert(this.participants({ id: id, address: sender.address }).exists)
	frame_dig -2 // id: uint64
	itob
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:366
	// hash = sha256(sha256(concat(sender.address, concat(receiver, itob(asset) + itob(amount)))))
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -3 // receiver: Address
	frame_dig -4 // asset: AssetID
	itob
	frame_dig -5 // amount: uint64
	itob
	concat
	concat
	concat
	sha256
	sha256
	frame_bury 1 // hash: byte[32]

	// contracts/arc58/plugins/hyper_swap.algo.ts:367
	// assert(!this.hashes({ id: id, hash: hash }).exists)
	bytec 2 //  "h"
	frame_dig -2 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_len
	swap
	pop
	!
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:369
	// assert(
	//             sendMethodCall<typeof MetaMerkles.prototype.verify, boolean>({
	//                 applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles),
	//                 methodArgs: [
	//                     this.app.address,
	//                     offer.root,
	//                     hash,
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ],
	//                 fee: 0,
	//             })
	//         )
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 5 //  method "verify(address,string,byte[32],byte[32][],uint64)bool"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:371
	// applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:372
	// methodArgs: [
	//                     this.app.address,
	//                     offer.root,
	//                     hash,
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ]
	global CurrentApplicationAddress
	itxn_field ApplicationArgs
	intc 2 //  headOffset
	intc 4 // 32
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig 1 // hash: byte[32]
	itxn_field ApplicationArgs
	frame_dig -6 // proof: bytes32[]
	dup
	len
	intc 4 // 32
	/
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	bytec 1 // 0x0000000000000003
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:379
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:384
	// mbrAmount = 0
	intc 0 // 0
	frame_bury 2 // mbrAmount: uint64

	// *if3_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:386
	// asset.id === 0
	frame_dig -4 // asset: AssetID
	intc 0 // 0
	==
	bz *if3_else

	// *if3_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:387
	// sendPayment({
	//                 sender: sender.address,
	//                 amount: amount,
	//                 receiver: this.app.address,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:388
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/hyper_swap.algo.ts:389
	// amount: amount
	frame_dig -5 // amount: uint64
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:390
	// receiver: this.app.address
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:391
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if3_end

*if3_else:
	// *if4_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:395
	// !receiver.isOptedInToAsset(asset)
	frame_dig -3 // receiver: Address
	frame_dig -4 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if4_end

	// *if4_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:396
	// mbrAmount += globals.minBalance + globals.assetOptInMinBalance + globals.minTxnFee
	frame_dig 2 // mbrAmount: uint64
	global MinBalance
	global AssetOptInMinBalance
	+
	global MinTxnFee
	+
	+
	frame_bury 2 // mbrAmount: uint64

*if4_end:
	// *if5_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:399
	// !this.app.address.isOptedInToAsset(asset)
	global CurrentApplicationAddress
	frame_dig -4 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if5_end

	// *if5_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:400
	// this.pendingGroup.addAssetTransfer({
	//                     xferAsset: asset,
	//                     assetAmount: 0,
	//                     assetReceiver: this.app.address,
	//                     fee: 0,
	//                 })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:401
	// xferAsset: asset
	frame_dig -4 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:402
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:403
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:404
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:406
	// mbrAmount += globals.assetOptInMinBalance
	frame_dig 2 // mbrAmount: uint64
	global AssetOptInMinBalance
	+
	frame_bury 2 // mbrAmount: uint64

*if5_end:
	// contracts/arc58/plugins/hyper_swap.algo.ts:409
	// this.pendingGroup.addPayment({
	//                 sender: sender.address,
	//                 amount: mbrAmount,
	//                 receiver: this.app.address,
	//                 fee: 0,
	//             })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:410
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/hyper_swap.algo.ts:411
	// amount: mbrAmount
	frame_dig 2 // mbrAmount: uint64
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:412
	// receiver: this.app.address
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:413
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:416
	// this.pendingGroup.addAssetTransfer({
	//                 sender: sender.address,
	//                 xferAsset: asset,
	//                 assetAmount: amount,
	//                 assetReceiver: this.app.address,
	//                 fee: 0,
	//             })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:417
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/hyper_swap.algo.ts:418
	// xferAsset: asset
	frame_dig -4 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:419
	// assetAmount: amount
	frame_dig -5 // amount: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:420
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:421
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:424
	// leftOver = sender.address.assetBalance(asset) - amount
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -4 // asset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -5 // amount: uint64
	-
	frame_bury 3 // leftOver: uint64

	// *if6_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:425
	// leftOver === 0
	frame_dig 3 // leftOver: uint64
	intc 0 // 0
	==
	bz *if6_end

	// *if6_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:426
	// this.pendingGroup.addAssetTransfer({
	//                     sender: sender.address,
	//                     xferAsset: asset,
	//                     assetAmount: 0,
	//                     assetReceiver: asset.creator,
	//                     assetCloseTo: asset.creator,
	//                     fee: 0,
	//                 })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:427
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/hyper_swap.algo.ts:428
	// xferAsset: asset
	frame_dig -4 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:429
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:430
	// assetReceiver: asset.creator
	frame_dig -4 // asset: AssetID
	asset_params_get AssetCreator
	pop
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:431
	// assetCloseTo: asset.creator
	frame_dig -4 // asset: AssetID
	asset_params_get AssetCreator
	pop
	itxn_field AssetCloseTo

	// contracts/arc58/plugins/hyper_swap.algo.ts:432
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if6_end:
	// contracts/arc58/plugins/hyper_swap.algo.ts:436
	// this.pendingGroup.submit()
	itxn_submit

*if3_end:
	// contracts/arc58/plugins/hyper_swap.algo.ts:440
	// this.hashes({ id: id, hash: hash }).value = mbrAmount
	bytec 2 //  "h"
	frame_dig -2 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	frame_dig 2 // mbrAmount: uint64
	itob
	box_put

	// contracts/arc58/plugins/hyper_swap.algo.ts:442
	// this.offers(id).value.escrowed += 1
	intc 6 //  headOffset
	dup
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	+
	itob
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_replace

	// *if7_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:444
	// offer.leaves === (offer.escrowed + 1)
	pushint 40 // headOffset
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 6 //  headOffset
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	+
	==
	bz *if7_end

	// *if7_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:445
	// this.offers(id).value.state = STATE_DISBURSING
	intc 0 // 0
	pushbytes 0x0000000000000002
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_replace

*if7_end:
	retsub

// disburse(uint64,uint64,uint64,uint64,uint64)void
*abi_route_disburse:
	// amount: uint64
	txna ApplicationArgs 5
	btoi

	// asset: uint64
	txna ApplicationArgs 4
	btoi

	// receiver: uint64
	txna ApplicationArgs 3
	btoi

	// id: uint64
	txna ApplicationArgs 2
	btoi

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute disburse(uint64,uint64,uint64,uint64,uint64)void
	callsub disburse
	intc 1 // 1
	return

// disburse(sender: AppID, id: uint64, receiver: AppID, asset: AssetID, amount: uint64): void
//
// Disburses assets for a leaf in the tree, ensuring ordered processing
//
// @param sender the sender abstracted account app id in the leaf
// @param id the id of the offer
// @param receiver the recipient abstracted account app id for the address in the leaf
// @param asset the asset being transferred
// @param amount the amount being transferred
disburse:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts/arc58/plugins/hyper_swap.algo.ts:466
	// assert(this.offers(id).exists)
	frame_dig -2 // id: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:467
	// offer = this.offers(id).value
	frame_dig -2 // id: uint64
	itob
	frame_bury 0 // storage key//offer

	// contracts/arc58/plugins/hyper_swap.algo.ts:469
	// assert(offer.state === STATE_DISBURSING)
	intc 0 // 0
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	pushint 2
	==
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:472
	// hash = sha256(sha256(concat(sender.address, concat(receiver.address, itob(asset) + itob(amount)))))
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -3 // receiver: AppID
	app_params_get AppAddress
	pop
	frame_dig -4 // asset: AssetID
	itob
	frame_dig -5 // amount: uint64
	itob
	concat
	concat
	concat
	sha256
	sha256
	frame_bury 1 // hash: byte[32]

	// contracts/arc58/plugins/hyper_swap.algo.ts:473
	// assert(this.hashes({ id: id, hash: hash }).exists)
	bytec 2 //  "h"
	frame_dig -2 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_len
	swap
	pop
	assert

	// *if8_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:476
	// asset.id === 0
	frame_dig -4 // asset: AssetID
	intc 0 // 0
	==
	bz *if8_else

	// *if8_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:477
	// sendPayment({
	//                 amount: amount,
	//                 receiver: receiver.address,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:478
	// amount: amount
	frame_dig -5 // amount: uint64
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:479
	// receiver: receiver.address
	frame_dig -3 // receiver: AppID
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:480
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if8_end

*if8_else:
	// *if9_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:483
	// !receiver.address.isOptedInToAsset(asset)
	frame_dig -3 // receiver: AppID
	app_params_get AppAddress
	pop
	frame_dig -4 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if9_else

	// *if9_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:484
	// canCallArc58OptIn = this.canCallArc58OptIn(receiver)
	frame_dig -3 // receiver: AppID
	callsub canCallArc58OptIn
	frame_bury 2 // canCallArc58OptIn: bool

	// *if10_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:485
	// canCallArc58OptIn
	frame_dig 2 // canCallArc58OptIn: bool
	bz *if10_else

	// *if10_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:487
	// this.arc58OptInAndSend(receiver, asset, amount)
	frame_dig -5 // amount: uint64
	frame_dig -4 // asset: AssetID
	frame_dig -3 // receiver: AppID
	callsub arc58OptInAndSend
	b *if10_end

*if10_else:
	// contracts/arc58/plugins/hyper_swap.algo.ts:490
	// this.arc59OptInAndSend(receiver, asset, amount)
	frame_dig -5 // amount: uint64
	frame_dig -4 // asset: AssetID
	frame_dig -3 // receiver: AppID
	callsub arc59OptInAndSend

*if10_end:
	b *if9_end

*if9_else:
	// contracts/arc58/plugins/hyper_swap.algo.ts:493
	// this.pendingGroup.addAssetTransfer({
	//                     xferAsset: asset,
	//                     assetAmount: amount,
	//                     assetReceiver: receiver.address,
	//                     fee: 0,
	//                 })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:494
	// xferAsset: asset
	frame_dig -4 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:495
	// assetAmount: amount
	frame_dig -5 // amount: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:496
	// assetReceiver: receiver.address
	frame_dig -3 // receiver: AppID
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:497
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:500
	// refundAmount = this.hashes({ id: id, hash: hash }).value
	bytec 2 //  "h"
	frame_dig -2 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_get

	// box value does not exist: this.hashes({ id: id, hash: hash }).value
	assert
	btoi
	frame_bury 3 // refundAmount: uint64

	// *if11_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:501
	// (this.app.address.assetBalance(asset) - amount) === 0
	global CurrentApplicationAddress
	frame_dig -4 // asset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -5 // amount: uint64
	-
	intc 0 // 0
	==
	bz *if11_else

	// *if11_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:502
	// this.pendingGroup.addAssetTransfer({
	//                         xferAsset: asset,
	//                         assetAmount: 0,
	//                         assetReceiver: asset.creator,
	//                         assetCloseTo: asset.creator,
	//                         fee: 0,
	//                     })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:503
	// xferAsset: asset
	frame_dig -4 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:504
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:505
	// assetReceiver: asset.creator
	frame_dig -4 // asset: AssetID
	asset_params_get AssetCreator
	pop
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:506
	// assetCloseTo: asset.creator
	frame_dig -4 // asset: AssetID
	asset_params_get AssetCreator
	pop
	itxn_field AssetCloseTo

	// contracts/arc58/plugins/hyper_swap.algo.ts:507
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	b *if11_end

*if11_else:
	// contracts/arc58/plugins/hyper_swap.algo.ts:510
	// refundAmount -= globals.assetOptInMinBalance
	frame_dig 3 // refundAmount: uint64
	global AssetOptInMinBalance
	-
	frame_bury 3 // refundAmount: uint64

*if11_end:
	// contracts/arc58/plugins/hyper_swap.algo.ts:513
	// this.pendingGroup.addPayment({
	//                     amount: refundAmount,
	//                     receiver: sender.address,
	//                     fee: 0,
	//                 })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:514
	// amount: refundAmount
	frame_dig 3 // refundAmount: uint64
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:515
	// receiver: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:516
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if9_end:

*if8_end:
	// contracts/arc58/plugins/hyper_swap.algo.ts:521
	// this.hashes({ id: id, hash: hash }).delete()
	bytec 2 //  "h"
	frame_dig -2 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_del

	// contracts/arc58/plugins/hyper_swap.algo.ts:522
	// this.offers(id).value.escrowed -= 1
	intc 6 //  headOffset
	dup
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	-
	itob
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_replace

	// *if12_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:525
	// (offer.escrowed - 1) === 0
	intc 6 //  headOffset
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	-
	intc 0 // 0
	==
	bz *if12_end

	// *if12_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:526
	// this.offers(id).value.state = STATE_COMPLETED
	intc 0 // 0
	bytec 1 // 0x0000000000000003
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_replace

*if12_end:
	retsub

// cancel(uint64,uint64,byte[32][])void
*abi_route_cancel:
	// proof: byte[32][]
	txna ApplicationArgs 3
	extract 2 0

	// id: uint64
	txna ApplicationArgs 2
	btoi

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute cancel(uint64,uint64,byte[32][])void
	callsub cancel
	intc 1 // 1
	return

// cancel(sender: AppID, id: uint64, proof: bytes32[]): void
//
//
// @param sender the abstracted account of the user cancelling the swap
// @param id the id of the offer being cancelled
// @param proof a proof of inclusion in the participants list
cancel:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/arc58/plugins/hyper_swap.algo.ts:537
	// assert(this.controls(sender.address))
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:539
	// assert(this.offers(id).exists)
	frame_dig -2 // id: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:540
	// offer = this.offers(id).value
	frame_dig -2 // id: uint64
	itob
	frame_bury 0 // storage key//offer

	// contracts/arc58/plugins/hyper_swap.algo.ts:542
	// assert(offer.state === STATE_OFFERED || offer.state === STATE_ESCROWING)
	intc 0 // 0
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 0 // 0
	==
	dup
	bnz *skip_or1
	intc 0 // 0
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	==
	||

*skip_or1:
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:544
	// assert(
	//             sendMethodCall<typeof MetaMerkles.prototype.verify, boolean>({
	//                 applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles),
	//                 methodArgs: [
	//                     this.app.address,
	//                     offer.participantRoot,
	//                     sha256(sha256(sender.address)),
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ],
	//                 fee: 0,
	//             })
	//         )
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 5 //  method "verify(address,string,byte[32],byte[32][],uint64)bool"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:546
	// applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:547
	// methodArgs: [
	//                     this.app.address,
	//                     offer.participantRoot,
	//                     sha256(sha256(sender.address)),
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ]
	global CurrentApplicationAddress
	itxn_field ApplicationArgs
	intc 9 //  headOffset
	intc 4 // 32
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	sha256
	sha256
	itxn_field ApplicationArgs
	frame_dig -3 // proof: bytes32[]
	dup
	len
	intc 4 // 32
	/
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	bytec 1 // 0x0000000000000003
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:554
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:558
	// this.offers(id).value.state = STATE_CANCELLED
	intc 0 // 0
	bytec 7 // 0x0000000000000004
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_replace
	retsub

// withdraw(uint64,uint64,address,uint64,uint64,byte[32][],bool)void
*abi_route_withdraw:
	// rekeyBack: bool
	txna ApplicationArgs 7
	dup
	len
	intc 1 // 1
	==

	// argument 0 (rekeyBack) for withdraw must be a bool
	assert
	intc 0 // 0
	getbit

	// proof: byte[32][]
	txna ApplicationArgs 6
	extract 2 0

	// amount: uint64
	txna ApplicationArgs 5
	btoi

	// asset: uint64
	txna ApplicationArgs 4
	btoi

	// receiver: address
	txna ApplicationArgs 3
	dup
	len
	intc 4 // 32
	==

	// argument 4 (receiver) for withdraw must be a address
	assert

	// id: uint64
	txna ApplicationArgs 2
	btoi

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute withdraw(uint64,uint64,address,uint64,uint64,byte[32][],bool)void
	callsub withdraw
	intc 1 // 1
	return

// withdraw(sender: AppID, id: uint64, receiver: Address, asset: AssetID, amount: uint64, proof: bytes32[], rekeyBack: boolean): void
//
// Withdraws your assets from a cancelled swap if they're escrowed
//
// @param sender the abstracted account of the user reclaiming their assets
// @param id the id of the cancelled offer
// @param receiver the receiver of the leaf's swap
// @param asset the asset of the leaf's swap
// @param amount the amount of the leaf's swap
// @param proof the proof that the leaf is in the tree
// @param rekeyBack whether the abstracted account should be rekeyed back at the end
withdraw:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/arc58/plugins/hyper_swap.algo.ts:582
	// assert(this.controls(sender.address))
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:584
	// assert(this.offers(id).exists)
	frame_dig -2 // id: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:585
	// offer = this.offers(id).value
	frame_dig -2 // id: uint64
	itob
	frame_bury 0 // storage key//offer

	// contracts/arc58/plugins/hyper_swap.algo.ts:587
	// assert(offer.state === STATE_CANCELLED)
	intc 0 // 0
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 5 // 4
	==
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:589
	// assert(offer.escrowed > 0)
	intc 6 //  headOffset
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 0 // 0
	>
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:591
	// hash = sha256(sha256(concat(sender.address, concat(receiver, itob(asset) + itob(amount)))))
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -3 // receiver: Address
	frame_dig -4 // asset: AssetID
	itob
	frame_dig -5 // amount: uint64
	itob
	concat
	concat
	concat
	sha256
	sha256
	frame_bury 1 // hash: byte[32]

	// contracts/arc58/plugins/hyper_swap.algo.ts:592
	// assert(this.hashes({ id: id, hash: hash }).exists)
	bytec 2 //  "h"
	frame_dig -2 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/hyper_swap.algo.ts:594
	// assert(
	//             sendMethodCall<typeof MetaMerkles.prototype.verify, boolean>({
	//                 applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles),
	//                 methodArgs: [
	//                     this.app.address,
	//                     offer.root,
	//                     hash,
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ],
	//                 fee: 0,
	//             })
	//         )
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 5 //  method "verify(address,string,byte[32],byte[32][],uint64)bool"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:596
	// applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/hyper_swap.algo.ts:597
	// methodArgs: [
	//                     this.app.address,
	//                     offer.root,
	//                     hash,
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ]
	global CurrentApplicationAddress
	itxn_field ApplicationArgs
	intc 2 //  headOffset
	intc 4 // 32
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig 1 // hash: byte[32]
	itxn_field ApplicationArgs
	frame_dig -6 // proof: bytes32[]
	dup
	len
	intc 4 // 32
	/
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	bytec 1 // 0x0000000000000003
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/hyper_swap.algo.ts:604
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	assert

	// *if13_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:608
	// asset.id === 0
	frame_dig -4 // asset: AssetID
	intc 0 // 0
	==
	bz *if13_else

	// *if13_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:609
	// sendPayment({
	//                 amount: amount,
	//                 receiver: sender.address,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:610
	// amount: amount
	frame_dig -5 // amount: uint64
	itxn_field Amount

	// contracts/arc58/plugins/hyper_swap.algo.ts:611
	// receiver: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:612
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// *if14_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:615
	// rekeyBack
	frame_dig -7 // rekeyBack: boolean
	bz *if14_end

	// *if14_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:616
	// this.rekeyBack(sender.address)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub rekeyBack

*if14_end:
	b *if13_end

*if13_else:
	// *if15_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:620
	// !sender.address.isOptedInToAsset(asset) && rekeyBack
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -4 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	dup
	bz *skip_and0
	frame_dig -7 // rekeyBack: boolean
	&&

*skip_and0:
	bz *if15_elseif1_condition

	// *if15_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:621
	// this.pendingGroup.addAssetTransfer({
	//                     sender: sender.address,
	//                     xferAsset: asset,
	//                     assetAmount: 0,
	//                     assetReceiver: sender.address,
	//                     rekeyTo: sender.address,
	//                     fee: 0,
	//                 })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:622
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/hyper_swap.algo.ts:623
	// xferAsset: asset
	frame_dig -4 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:624
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:625
	// assetReceiver: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:626
	// rekeyTo: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field RekeyTo

	// contracts/arc58/plugins/hyper_swap.algo.ts:627
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	b *if15_end

*if15_elseif1_condition:
	// contracts/arc58/plugins/hyper_swap.algo.ts:629
	// !sender.address.isOptedInToAsset(asset)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -4 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if15_end

	// *if15_elseif1_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:630
	// this.pendingGroup.addAssetTransfer({
	//                     sender: sender.address,
	//                     xferAsset: asset,
	//                     assetAmount: 0,
	//                     assetReceiver: sender.address,
	//                     fee: 0,
	//                 })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:631
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/hyper_swap.algo.ts:632
	// xferAsset: asset
	frame_dig -4 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:633
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:634
	// assetReceiver: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:635
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if15_end:
	// contracts/arc58/plugins/hyper_swap.algo.ts:639
	// this.pendingGroup.addAssetTransfer({
	//                 xferAsset: asset,
	//                 assetAmount: amount,
	//                 assetReceiver: sender.address,
	//                 fee: 0,
	//             })
	itxn_next
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/hyper_swap.algo.ts:640
	// xferAsset: asset
	frame_dig -4 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/hyper_swap.algo.ts:641
	// assetAmount: amount
	frame_dig -5 // amount: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/hyper_swap.algo.ts:642
	// assetReceiver: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts/arc58/plugins/hyper_swap.algo.ts:643
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/hyper_swap.algo.ts:646
	// this.pendingGroup.submit()
	itxn_submit

*if13_end:
	// contracts/arc58/plugins/hyper_swap.algo.ts:650
	// this.hashes({ id: id, hash: hash }).delete()
	bytec 2 //  "h"
	frame_dig -2 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_del

	// contracts/arc58/plugins/hyper_swap.algo.ts:652
	// this.offers(id).value.escrowed -= 1
	intc 6 //  headOffset
	dup
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	-
	itob
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_replace

	// *if16_condition
	// contracts/arc58/plugins/hyper_swap.algo.ts:654
	// (offer.escrowed - 1) === 0
	intc 6 //  headOffset
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	-
	intc 0 // 0
	==
	bz *if16_end

	// *if16_consequent
	// contracts/arc58/plugins/hyper_swap.algo.ts:655
	// this.offers(id).value.state = STATE_CANCEL_COMPLETED
	intc 0 // 0
	pushbytes 0x0000000000000005
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_replace

*if16_end:
	retsub

*abi_route_createApplication:
	intc 1 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xd86019de // method "offer(address,byte[32],uint64,byte[32],uint64,uint64,address,uint64)void"
	pushbytes 0x9efabff8 // method "accept(uint64,uint64,byte[32][])void"
	pushbytes 0x3f6985b3 // method "escrow(uint64,uint64,address,uint64,uint64,byte[32][])void"
	pushbytes 0x70930031 // method "disburse(uint64,uint64,uint64,uint64,uint64)void"
	pushbytes 0x6345dbcb // method "cancel(uint64,uint64,byte[32][])void"
	pushbytes 0xba1e100b // method "withdraw(uint64,uint64,address,uint64,uint64,byte[32][],bool)void"
	txna ApplicationArgs 0
	match *abi_route_offer *abi_route_accept *abi_route_escrow *abi_route_disburse *abi_route_cancel *abi_route_withdraw

	// this contract does not implement the given ABI method for call NoOp
	err