#pragma version 10
intcblock 0 1 6 32 18500 53700
bytecblock 0x 0x64616f5f6170705f6964 0x603d7297

// This TEAL was generated by TEALScript v0.106.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 2 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(uint64)void
*abi_route_createApplication:
	// daoAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute createApplication(uint64)void
	callsub createApplication
	intc 1 // 1
	return

// createApplication(daoAppID: AppID): void
createApplication:
	proto 1 0

	// contracts/arc58/plugins/subscriptions.algo.ts:11
	// this.daoAppID.value = daoAppID
	bytec 1 //  "dao_app_id"
	frame_dig -1 // daoAppID: AppID
	app_global_put
	retsub

// newService(uint64,bool,uint64,uint64,uint64,uint64,uint64,byte[59])uint64
*abi_route_newService:
	// The ABI return prefix
	pushbytes 0x151f7c75

	// cid: byte[59]
	txna ApplicationArgs 8
	dup
	len
	pushint 59
	==

	// argument 0 (cid) for newService must be a byte[59]
	assert

	// gate: uint64
	txna ApplicationArgs 7
	btoi

	// passes: uint64
	txna ApplicationArgs 6
	btoi

	// amount: uint64
	txna ApplicationArgs 5
	btoi

	// asset: uint64
	txna ApplicationArgs 4
	btoi

	// interval: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 6 (rekeyBack) for newService must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute newService(uint64,bool,uint64,uint64,uint64,uint64,uint64,byte[59])uint64
	callsub newService
	itob
	concat
	log
	intc 1 // 1
	return

// newService(sender: AppID, rekeyBack: boolean, interval: uint64, asset: AssetID, amount: uint64, passes: uint64, gate: uint64, cid: bytes<59>): uint64
newService:
	proto 8 1

	// contracts/arc58/plugins/subscriptions.algo.ts:24
	// return sendMethodCall<typeof Subscriptions.prototype.newService, uint64>({
	//       sender: sender.address,
	//       applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions),
	//       methodArgs: [
	//         {},
	//         interval,
	//         asset,
	//         amount,
	//         passes,
	//         gate,
	//         cid
	//       ],
	//       rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//       fee: 0,
	//     });
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0xc07fd4c8 // method "newService(pay,uint64,uint64,uint64,uint64,uint64,byte[59])uint64"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:25
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:26
	// applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/subscriptions.algo.ts:27
	// methodArgs: [
	//         {},
	//         interval,
	//         asset,
	//         amount,
	//         passes,
	//         gate,
	//         cid
	//       ]
	frame_dig -3 // interval: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -4 // asset: AssetID
	itob
	itxn_field ApplicationArgs
	frame_dig -5 // amount: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -6 // passes: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -7 // gate: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -8 // cid: bytes<59>
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:36
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary0_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary0_end

*ternary0_false:
	global ZeroAddress

*ternary0_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscriptions.algo.ts:37
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	btoi
	retsub

// block(uint64,bool,address)void
*abi_route_block:
	// address: address
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for block must be a address
	assert

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 1 (rekeyBack) for block must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute block(uint64,bool,address)void
	callsub block
	intc 1 // 1
	return

// block(sender: AppID, rekeyBack: boolean, address: Address): void
block:
	proto 3 0

	// contracts/arc58/plugins/subscriptions.algo.ts:72
	// sendMethodCall<typeof Subscriptions.prototype.block, uint64>({
	//       sender: sender.address,
	//       applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions),
	//       methodArgs: [
	//         {
	//           sender: sender.address,
	//           receiver: AppID.fromUint64(AkitaAppIDsSubscriptions).address,
	//           amount: blockMBR,
	//         },
	//         address
	//       ],
	//       rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//       fee: 0,
	//     })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:77
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:78
	// receiver: AppID.fromUint64(AkitaAppIDsSubscriptions).address
	intc 0 // 0
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/arc58/plugins/subscriptions.algo.ts:79
	// amount: blockMBR
	pushint 28100
	itxn_field Amount

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0xb59c8a54 // method "block(pay,address)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:73
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:74
	// applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/subscriptions.algo.ts:75
	// methodArgs: [
	//         {
	//           sender: sender.address,
	//           receiver: AppID.fromUint64(AkitaAppIDsSubscriptions).address,
	//           amount: blockMBR,
	//         },
	//         address
	//       ]
	frame_dig -3 // address: Address
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:83
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary1_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary1_end

*ternary1_false:
	global ZeroAddress

*ternary1_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscriptions.algo.ts:84
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// unblock(uint64,bool,address)void
*abi_route_unblock:
	// address: address
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for unblock must be a address
	assert

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 1 (rekeyBack) for unblock must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute unblock(uint64,bool,address)void
	callsub unblock
	intc 1 // 1
	return

// unblock(sender: AppID, rekeyBack: boolean, address: Address): void
unblock:
	proto 3 0

	// contracts/arc58/plugins/subscriptions.algo.ts:89
	// sendMethodCall<typeof Subscriptions.prototype.unblock, uint64>({
	//       sender: sender.address,
	//       applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions),
	//       methodArgs: [address],
	//       rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//       fee: 0,
	//     })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0xaeebb378 // method "unblock(address)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:90
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:91
	// applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/subscriptions.algo.ts:92
	// methodArgs: [address]
	frame_dig -3 // address: Address
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:93
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary2_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary2_end

*ternary2_false:
	global ZeroAddress

*ternary2_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscriptions.algo.ts:94
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// subscribe(uint64,bool,address,uint64,uint64,uint64,byte[][])void
*abi_route_subscribe:
	// args: byte[][]
	txna ApplicationArgs 7

	// index: uint64
	txna ApplicationArgs 6
	btoi

	// interval: uint64
	txna ApplicationArgs 5
	btoi

	// amount: uint64
	txna ApplicationArgs 4
	btoi

	// recipient: address
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 32
	==

	// argument 4 (recipient) for subscribe must be a address
	assert

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 5 (rekeyBack) for subscribe must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute subscribe(uint64,bool,address,uint64,uint64,uint64,byte[][])void
	callsub subscribe
	intc 1 // 1
	return

// subscribe(sender: AppID, rekeyBack: boolean, recipient: Address, amount: uint64, interval: uint64, index: uint64, args: bytes[]): void
subscribe:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/arc58/plugins/subscriptions.algo.ts:108
	// mbrAmount = subscriptionsMBR
	intc 5 // 53700
	frame_bury 0 // mbrAmount: uint64

	// contracts/arc58/plugins/subscriptions.algo.ts:110
	// firstSubscription = sendMethodCall<typeof Subscriptions.prototype.isFirstSubscription, boolean>({
	//       sender: sender.address,
	//       applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions),
	//       methodArgs: [sender.address],
	//       fee: 0,
	//     })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	bytec 2 //  method "isFirstSubscription(address)bool"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:111
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:112
	// applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/subscriptions.algo.ts:113
	// methodArgs: [sender.address]
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:114
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	frame_bury 1 // firstSubscription: bool

	// *if0_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:117
	// firstSubscription
	frame_dig 1 // firstSubscription: bool
	bz *if0_end

	// *if0_consequent
	// contracts/arc58/plugins/subscriptions.algo.ts:118
	// mbrAmount += subscriptionsListMBR
	frame_dig 0 // mbrAmount: uint64
	intc 4 // 18500
	+
	frame_bury 0 // mbrAmount: uint64

*if0_end:
	// contracts/arc58/plugins/subscriptions.algo.ts:121
	// sendMethodCall<typeof Subscriptions.prototype.subscribe, uint64>({
	//       sender: sender.address,
	//       applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions),
	//       methodArgs: [
	//         {
	//           sender: sender.address,
	//           receiver: recipient,
	//           amount: (amount + mbrAmount),
	//         },
	//         recipient,
	//         amount,
	//         interval,
	//         index,
	//         args,
	//       ],
	//       rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//       fee: 0,
	//     })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:126
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:127
	// receiver: recipient
	frame_dig -3 // recipient: Address
	itxn_field Receiver

	// contracts/arc58/plugins/subscriptions.algo.ts:128
	// amount: (amount + mbrAmount)
	frame_dig -4 // amount: uint64
	frame_dig 0 // mbrAmount: uint64
	+
	itxn_field Amount

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0xaaf5a3a1 // method "subscribe(pay,address,uint64,uint64,uint64,byte[][])void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:122
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:123
	// applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/subscriptions.algo.ts:124
	// methodArgs: [
	//         {
	//           sender: sender.address,
	//           receiver: recipient,
	//           amount: (amount + mbrAmount),
	//         },
	//         recipient,
	//         amount,
	//         interval,
	//         index,
	//         args,
	//       ]
	frame_dig -3 // recipient: Address
	itxn_field ApplicationArgs
	frame_dig -4 // amount: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -5 // interval: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -6 // index: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -7 // args: bytes[]
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:136
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary3_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary3_end

*ternary3_false:
	global ZeroAddress

*ternary3_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscriptions.algo.ts:137
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// optin(uint64,bool,uint64)void
*abi_route_optin:
	// asset: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 1 (rekeyBack) for optin must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute optin(uint64,bool,uint64)void
	callsub optin
	intc 1 // 1
	return

// optin(sender: AppID, rekeyBack: boolean, asset: AssetID): void
optin:
	proto 3 0

	// contracts/arc58/plugins/subscriptions.algo.ts:142
	// sendMethodCall<typeof Subscriptions.prototype.optin, uint64>({
	//       sender: sender.address,
	//       applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions),
	//       methodArgs: [
	//         {
	//           sender: sender.address,
	//           receiver: AppID.fromUint64(AkitaAppIDsSubscriptions).address,
	//           amount: globals.assetOptInMinBalance,
	//           fee: 0,
	//         },
	//         asset
	//       ],
	//       rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//       fee: 0,
	//     })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:147
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:148
	// receiver: AppID.fromUint64(AkitaAppIDsSubscriptions).address
	intc 0 // 0
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/arc58/plugins/subscriptions.algo.ts:149
	// amount: globals.assetOptInMinBalance
	global AssetOptInMinBalance
	itxn_field Amount

	// contracts/arc58/plugins/subscriptions.algo.ts:150
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0x3ea11832 // method "optin(pay,uint64)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:143
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:144
	// applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/subscriptions.algo.ts:145
	// methodArgs: [
	//         {
	//           sender: sender.address,
	//           receiver: AppID.fromUint64(AkitaAppIDsSubscriptions).address,
	//           amount: globals.assetOptInMinBalance,
	//           fee: 0,
	//         },
	//         asset
	//       ]
	frame_dig -3 // asset: AssetID
	itob
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:154
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary4_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary4_end

*ternary4_false:
	global ZeroAddress

*ternary4_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscriptions.algo.ts:155
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// subscribeAsa(uint64,bool,uint64,address,uint64,uint64,uint64,byte[][])void
*abi_route_subscribeAsa:
	// args: byte[][]
	txna ApplicationArgs 8

	// index: uint64
	txna ApplicationArgs 7
	btoi

	// interval: uint64
	txna ApplicationArgs 6
	btoi

	// amount: uint64
	txna ApplicationArgs 5
	btoi

	// recipient: address
	txna ApplicationArgs 4
	dup
	len
	intc 3 // 32
	==

	// argument 4 (recipient) for subscribeAsa must be a address
	assert

	// asset: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 6 (rekeyBack) for subscribeAsa must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute subscribeAsa(uint64,bool,uint64,address,uint64,uint64,uint64,byte[][])void
	callsub subscribeAsa
	intc 1 // 1
	return

// subscribeAsa(sender: AppID, rekeyBack: boolean, asset: AssetID, recipient: Address, amount: uint64, interval: uint64, index: uint64, args: bytes[]): void
subscribeAsa:
	proto 8 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/arc58/plugins/subscriptions.algo.ts:170
	// mbrAmount = subscriptionsMBR
	intc 5 // 53700
	frame_bury 0 // mbrAmount: uint64

	// contracts/arc58/plugins/subscriptions.algo.ts:172
	// firstSubscription = sendMethodCall<typeof Subscriptions.prototype.isFirstSubscription, boolean>({
	//       sender: sender.address,
	//       applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions),
	//       methodArgs: [sender.address],
	//       fee: 0,
	//     })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	bytec 2 //  method "isFirstSubscription(address)bool"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:173
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:174
	// applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/subscriptions.algo.ts:175
	// methodArgs: [sender.address]
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:176
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	frame_bury 1 // firstSubscription: bool

	// *if1_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:179
	// firstSubscription
	frame_dig 1 // firstSubscription: bool
	bz *if1_end

	// *if1_consequent
	// contracts/arc58/plugins/subscriptions.algo.ts:180
	// mbrAmount += subscriptionsListMBR
	frame_dig 0 // mbrAmount: uint64
	intc 4 // 18500
	+
	frame_bury 0 // mbrAmount: uint64

*if1_end:
	// *if2_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:183
	// !this.daoAppID.value.address.isOptedInToAsset(asset)
	bytec 1 //  "dao_app_id"
	app_global_get
	app_params_get AppAddress
	pop
	frame_dig -3 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if2_end

	// *if2_consequent
	// contracts/arc58/plugins/subscriptions.algo.ts:184
	// mbrAmount += globals.assetOptInMinBalance
	frame_dig 0 // mbrAmount: uint64
	global AssetOptInMinBalance
	+
	frame_bury 0 // mbrAmount: uint64

*if2_end:
	// contracts/arc58/plugins/subscriptions.algo.ts:187
	// sendMethodCall<typeof Subscriptions.prototype.subscribeAsa, void>({
	//       sender: sender.address,
	//       applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions),
	//       methodArgs: [
	//         {
	//           sender: sender.address,
	//           receiver: recipient,
	//           amount: mbrAmount,
	//         },
	//         {
	//           sender: sender.address,
	//           assetReceiver: AppID.fromUint64(AkitaAppIDsSubscriptions).address,
	//           xferAsset: asset,
	//           assetAmount: amount,
	//         },
	//         recipient,
	//         amount,
	//         interval,
	//         index,
	//         args,
	//       ],
	//       rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//       fee: 0,
	//     })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:192
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:193
	// receiver: recipient
	frame_dig -4 // recipient: Address
	itxn_field Receiver

	// contracts/arc58/plugins/subscriptions.algo.ts:194
	// amount: mbrAmount
	frame_dig 0 // mbrAmount: uint64
	itxn_field Amount

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	pushint 4 // axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:197
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:198
	// assetReceiver: AppID.fromUint64(AkitaAppIDsSubscriptions).address
	intc 0 // 0
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscriptions.algo.ts:199
	// xferAsset: asset
	frame_dig -3 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/subscriptions.algo.ts:200
	// assetAmount: amount
	frame_dig -5 // amount: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0x47b8fced // method "subscribeAsa(pay,axfer,address,uint64,uint64,uint64,byte[][])void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:188
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:189
	// applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/subscriptions.algo.ts:190
	// methodArgs: [
	//         {
	//           sender: sender.address,
	//           receiver: recipient,
	//           amount: mbrAmount,
	//         },
	//         {
	//           sender: sender.address,
	//           assetReceiver: AppID.fromUint64(AkitaAppIDsSubscriptions).address,
	//           xferAsset: asset,
	//           assetAmount: amount,
	//         },
	//         recipient,
	//         amount,
	//         interval,
	//         index,
	//         args,
	//       ]
	frame_dig -4 // recipient: Address
	itxn_field ApplicationArgs
	frame_dig -5 // amount: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -6 // interval: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -7 // index: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -8 // args: bytes[]
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:208
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary5_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary5_end

*ternary5_false:
	global ZeroAddress

*ternary5_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscriptions.algo.ts:209
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// triggerPayment(uint64,bool,address,uint64,byte[][])void
*abi_route_triggerPayment:
	// args: byte[][]
	txna ApplicationArgs 5

	// index: uint64
	txna ApplicationArgs 4
	btoi

	// address: address
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 32
	==

	// argument 2 (address) for triggerPayment must be a address
	assert

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 3 (rekeyBack) for triggerPayment must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute triggerPayment(uint64,bool,address,uint64,byte[][])void
	callsub triggerPayment
	intc 1 // 1
	return

// triggerPayment(sender: AppID, rekeyBack: boolean, address: Address, index: uint64, args: bytes[]): void
triggerPayment:
	proto 5 0

	// contracts/arc58/plugins/subscriptions.algo.ts:214
	// sendMethodCall<typeof Subscriptions.prototype.triggerPayment, uint64>({
	//       sender: sender.address,
	//       applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions),
	//       methodArgs: [address, index, args],
	//       rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//       fee: 0,
	//     })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0x12daa571 // method "triggerPayment(address,uint64,byte[][])void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:215
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:216
	// applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/subscriptions.algo.ts:217
	// methodArgs: [address, index, args]
	frame_dig -3 // address: Address
	itxn_field ApplicationArgs
	frame_dig -4 // index: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -5 // args: bytes[]
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:218
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary6_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary6_end

*ternary6_false:
	global ZeroAddress

*ternary6_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscriptions.algo.ts:219
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// streakCheck(uint64,bool,address,uint64)void
*abi_route_streakCheck:
	// index: uint64
	txna ApplicationArgs 4
	btoi

	// address: address
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 32
	==

	// argument 1 (address) for streakCheck must be a address
	assert

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 2 (rekeyBack) for streakCheck must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute streakCheck(uint64,bool,address,uint64)void
	callsub streakCheck
	intc 1 // 1
	return

// streakCheck(sender: AppID, rekeyBack: boolean, address: Address, index: uint64): void
streakCheck:
	proto 4 0

	// contracts/arc58/plugins/subscriptions.algo.ts:224
	// sendMethodCall<typeof Subscriptions.prototype.streakCheck, uint64>({
	//       sender: sender.address,
	//       applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions),
	//       methodArgs: [address, index],
	//       rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//       fee: 0,
	//     })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0xadb2c60e // method "streakCheck(address,uint64)void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:225
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:226
	// applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/subscriptions.algo.ts:227
	// methodArgs: [address, index]
	frame_dig -3 // address: Address
	itxn_field ApplicationArgs
	frame_dig -4 // index: uint64
	itob
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:228
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary7_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary7_end

*ternary7_false:
	global ZeroAddress

*ternary7_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscriptions.algo.ts:229
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// setPasses(uint64,bool,uint64,address[])void
*abi_route_setPasses:
	// addresses: address[]
	txna ApplicationArgs 4
	extract 2 0

	// index: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 2 (rekeyBack) for setPasses must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute setPasses(uint64,bool,uint64,address[])void
	callsub setPasses
	intc 1 // 1
	return

// setPasses(sender: AppID, rekeyBack: boolean, index: uint64, addresses: Address[]): void
setPasses:
	proto 4 0

	// contracts/arc58/plugins/subscriptions.algo.ts:234
	// sendMethodCall<typeof Subscriptions.prototype.setPasses, uint64>({
	//       sender: sender.address,
	//       applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions),
	//       methodArgs: [index, addresses],
	//       rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//       fee: 0,
	//     })
	itxn_begin
	intc 2 //  appl
	itxn_field TypeEnum
	pushbytes 0x275203af // method "setPasses(uint64,address[])void"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:235
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:236
	// applicationID: AppID.fromUint64(AkitaAppIDsSubscriptions)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/subscriptions.algo.ts:237
	// methodArgs: [index, addresses]
	frame_dig -3 // index: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -4 // addresses: Address[]
	dup
	len
	intc 3 // 32
	/
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:238
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary8_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary8_end

*ternary8_false:
	global ZeroAddress

*ternary8_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscriptions.algo.ts:239
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

*create_NoOp:
	pushbytes 0x973b616f // method "createApplication(uint64)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xbe1ef1b8 // method "newService(uint64,bool,uint64,uint64,uint64,uint64,uint64,byte[59])uint64"
	pushbytes 0xbec86c34 // method "block(uint64,bool,address)void"
	pushbytes 0x9f59a970 // method "unblock(uint64,bool,address)void"
	pushbytes 0x4a1464f4 // method "subscribe(uint64,bool,address,uint64,uint64,uint64,byte[][])void"
	pushbytes 0x698a83d2 // method "optin(uint64,bool,uint64)void"
	pushbytes 0x3226a3c1 // method "subscribeAsa(uint64,bool,uint64,address,uint64,uint64,uint64,byte[][])void"
	pushbytes 0x23e337bd // method "triggerPayment(uint64,bool,address,uint64,byte[][])void"
	pushbytes 0x36714eb7 // method "streakCheck(uint64,bool,address,uint64)void"
	pushbytes 0x1c42461b // method "setPasses(uint64,bool,uint64,address[])void"
	txna ApplicationArgs 0
	match *abi_route_newService *abi_route_block *abi_route_unblock *abi_route_subscribe *abi_route_optin *abi_route_subscribeAsa *abi_route_triggerPayment *abi_route_streakCheck *abi_route_setPasses

	// this contract does not implement the given ABI method for call NoOp
	err