#pragma version 10

// This TEAL was generated by TEALScript v0.103.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// controls(address: Address): boolean
controls:
	proto 1 1

	// contracts/arc58/plugins/subscription.algo.ts:112
	// return address.authAddr === this.app.address;
	frame_dig -1 // address: Address
	acct_params_get AcctAuthAddr
	pop
	global CurrentApplicationAddress
	==
	retsub

// addPendingOptin(sender: Address, asa: AssetID, amount: uint64, rekeyBack: boolean): void
addPendingOptin:
	proto 4 0

	// *if0_condition
	// contracts/arc58/plugins/subscription.algo.ts:116
	// rekeyBack
	frame_dig -4 // rekeyBack: boolean
	bz *if0_else

	// *if0_consequent
	// contracts/arc58/plugins/subscription.algo.ts:117
	// this.pendingGroup.addPayment({
	//         sender: sender,
	//         receiver: globals.currentApplicationAddress,
	//         amount: (globals.assetOptInMinBalance + amount),
	//         // always rekey the user back
	//         rekeyTo: sender,
	//         fee: 0,
	//       })
	itxn_next
	int pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:118
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:119
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:120
	// amount: (globals.assetOptInMinBalance + amount)
	global AssetOptInMinBalance
	frame_dig -3 // amount: uint64
	+
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:122
	// rekeyTo: sender
	frame_dig -1 // sender: Address
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscription.algo.ts:123
	// fee: 0
	int 0
	itxn_field Fee
	b *if0_end

*if0_else:
	// contracts/arc58/plugins/subscription.algo.ts:126
	// this.pendingGroup.addPayment({
	//         sender: sender,
	//         receiver: globals.currentApplicationAddress,
	//         amount: (globals.assetOptInMinBalance + amount),
	//         fee: 0,
	//       })
	itxn_next
	int pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:127
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:128
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:129
	// amount: (globals.assetOptInMinBalance + amount)
	global AssetOptInMinBalance
	frame_dig -3 // amount: uint64
	+
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:130
	// fee: 0
	int 0
	itxn_field Fee

*if0_end:
	// contracts/arc58/plugins/subscription.algo.ts:134
	// this.pendingGroup.addAssetTransfer({
	//       sender: globals.currentApplicationAddress,
	//       assetReceiver: globals.currentApplicationAddress,
	//       assetAmount: 0,
	//       xferAsset: asa,
	//       fee: 0,
	//     })
	itxn_next
	int axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:135
	// sender: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:136
	// assetReceiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscription.algo.ts:137
	// assetAmount: 0
	int 0
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscription.algo.ts:138
	// xferAsset: asa
	frame_dig -2 // asa: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/subscription.algo.ts:139
	// fee: 0
	int 0
	itxn_field Fee
	retsub

// getLatestWindowStart(startDate: uint64, interval: uint64): uint64
getLatestWindowStart:
	proto 2 1

	// contracts/arc58/plugins/subscription.algo.ts:144
	// return globals.latestTimestamp - ((globals.latestTimestamp - startDate) % interval);
	global LatestTimestamp
	global LatestTimestamp
	frame_dig -1 // startDate: uint64
	-
	frame_dig -2 // interval: uint64
	%
	-
	retsub

// updateStreak(sender: Address, index: uint64, elseStreak: uint64): void
updateStreak:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// contracts/arc58/plugins/subscription.algo.ts:148
	// subKey: SubscriptionKey = { user: sender, index: index }
	frame_dig -1 // sender: Address
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // subKey: SubscriptionKey

	// contracts/arc58/plugins/subscription.algo.ts:149
	// sub = this.subscriptions(subKey).value
	frame_dig 0 // subKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/arc58/plugins/subscription.algo.ts:151
	// currentWindowStart = this.getLatestWindowStart(sub.startDate, sub.interval)
	frame_dig 0 // subKey: SubscriptionKey
	int 56 // headOffset
	int 8
	box_extract
	btoi
	frame_dig 0 // subKey: SubscriptionKey
	int 40 // headOffset
	int 8
	box_extract
	btoi
	callsub getLatestWindowStart
	frame_bury 2 // currentWindowStart: uint64

	// contracts/arc58/plugins/subscription.algo.ts:152
	// lastWindowStart = (currentWindowStart - sub.interval)
	frame_dig 2 // currentWindowStart: uint64
	frame_dig 0 // subKey: SubscriptionKey
	int 56 // headOffset
	int 8
	box_extract
	btoi
	-
	frame_bury 3 // lastWindowStart: uint64

	// *if1_condition
	// contracts/arc58/plugins/subscription.algo.ts:154
	// sub.lastPayment < lastWindowStart
	frame_dig 0 // subKey: SubscriptionKey
	int 72 // headOffset
	int 8
	box_extract
	btoi
	frame_dig 3 // lastWindowStart: uint64
	<
	bz *if1_end

	// *if1_consequent
	// contracts/arc58/plugins/subscription.algo.ts:156
	// this.subscriptions(subKey).value.streak = elseStreak
	int 80 // headOffset
	frame_dig -3 // elseStreak: uint64
	itob
	frame_dig 0 // subKey: SubscriptionKey
	cover 2
	box_replace

	// contracts/arc58/plugins/subscription.algo.ts:157
	// return;
	retsub

*if1_end:
	// *if2_condition
	// contracts/arc58/plugins/subscription.algo.ts:163
	// sub.lastPayment >= lastWindowStart && !(sub.lastPayment >= currentWindowStart)
	frame_dig 0 // subKey: SubscriptionKey
	int 72 // headOffset
	int 8
	box_extract
	btoi
	frame_dig 3 // lastWindowStart: uint64
	>=
	dup
	bz *skip_and0
	frame_dig 0 // subKey: SubscriptionKey
	int 72 // headOffset
	int 8
	box_extract
	btoi
	frame_dig 2 // currentWindowStart: uint64
	>=
	!
	&&

*skip_and0:
	bz *if2_end

	// *if2_consequent
	// contracts/arc58/plugins/subscription.algo.ts:164
	// this.subscriptions(subKey).value.streak += 1
	int 80 // headOffset
	frame_dig 0 // subKey: SubscriptionKey
	int 80 // headOffset
	int 8
	box_extract
	btoi
	int 1
	+
	itob
	frame_dig 0 // subKey: SubscriptionKey
	cover 2
	box_replace

*if2_end:
	retsub

// getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])
*abi_route_getSubsriptionInfo:
	// The ABI return prefix
	byte 0x151f7c75

	// index: uint64
	txna ApplicationArgs 2
	btoi

	// user: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (user) for getSubsriptionInfo must be a address
	assert

	// execute getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])
	callsub getSubsriptionInfo
	concat
	log
	int 1
	return

// getSubsriptionInfo(user: Address, index: uint64): SubscriptionInfoWithPasses
getSubsriptionInfo:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/arc58/plugins/subscription.algo.ts:169
	// key: SubscriptionKey = { user: user, index: index }
	frame_dig -1 // user: Address
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // key: SubscriptionKey

	// contracts/arc58/plugins/subscription.algo.ts:171
	// assert(this.subscriptions(key).exists, errs.SUBSCRIPTION_DOES_NOT_EXIST)
	frame_dig 0 // key: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscription.algo.ts:173
	// subInfo = this.subscriptions(key).value
	frame_dig 0 // key: SubscriptionKey
	frame_bury 1 // storage key//subInfo

	// contracts/arc58/plugins/subscription.algo.ts:175
	// passes: Address[] = []
	byte 0x
	frame_bury 2 // passes: Address[]

	// *if3_condition
	// contracts/arc58/plugins/subscription.algo.ts:176
	// this.passes(key).exists
	byte 0x70 // "p"
	frame_dig 0 // key: SubscriptionKey
	concat
	box_len
	swap
	pop
	bz *if3_end

	// *if3_consequent
	// contracts/arc58/plugins/subscription.algo.ts:177
	// passes = this.passes(key).value
	byte 0x70 // "p"
	frame_dig 0 // key: SubscriptionKey
	concat
	box_get

	// box value does not exist: this.passes(key).value
	assert
	extract 2 0
	frame_bury 2 // passes: Address[]

*if3_end:
	// contracts/arc58/plugins/subscription.algo.ts:180
	// return {
	//       recipient: subInfo.recipient,
	//       index: subInfo.index,
	//       startDate: subInfo.startDate,
	//       amount: subInfo.amount,
	//       interval: subInfo.interval,
	//       asa: subInfo.asa,
	//       lastPayment: subInfo.lastPayment,
	//       streak: subInfo.streak,
	//       passes: passes,
	//     };
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x005a // initial head offset
	frame_dig 0 // key: SubscriptionKey
	int 0
	int 32
	box_extract
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	int 32 // headOffset
	int 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	int 40 // headOffset
	int 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	int 48 // headOffset
	int 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	int 56 // headOffset
	int 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	int 64 // headOffset
	int 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	int 72 // headOffset
	int 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	int 80 // headOffset
	int 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 2 // passes: Address[]
	dup
	len
	int 32
	/
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// newService(address,uint64,uint64,uint64,uint64,byte[59],bool)uint64
*abi_route_newService:
	// The ABI return prefix
	byte 0x151f7c75

	// allowTraversal: bool
	txna ApplicationArgs 7
	dup
	len
	int 1
	==

	// argument 0 (allowTraversal) for newService must be a bool
	assert
	int 0
	getbit

	// cid: byte[59]
	txna ApplicationArgs 6
	dup
	len
	int 59
	==

	// argument 1 (cid) for newService must be a byte[59]
	assert

	// passes: uint64
	txna ApplicationArgs 5
	btoi

	// amount: uint64
	txna ApplicationArgs 4
	btoi

	// asa: uint64
	txna ApplicationArgs 3
	btoi

	// interval: uint64
	txna ApplicationArgs 2
	btoi

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 6 (sender) for newService must be a address
	assert

	// execute newService(address,uint64,uint64,uint64,uint64,byte[59],bool)uint64
	callsub newService
	itob
	concat
	log
	int 1
	return

// newService(sender: Address, interval: uint64, asa: AssetID, amount: uint64, passes: uint64, cid: bytes<59>, allowTraversal: boolean): uint64
//
// newService creates a new service for a merchant
// @param sender The address the plugin currently controls
// @param interval The interval in seconds
// @param asa The asa to be used for the subscription
// @param amount The amount of the asa to be used for the subscription
// @param passes The number of accounts the subscription can be shared with
// @param cid The ipfs cid of the subscription contract
// @param allowTraversal Indicates whether the user can downgrade
// or upgrade the subscription to a different service from the user without losing their streak
newService:
	proto 7 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/arc58/plugins/subscription.algo.ts:214
	// index: uint64 = 0
	int 0
	frame_bury 0 // index: uint64

	// *if4_condition
	// contracts/arc58/plugins/subscription.algo.ts:215
	// this.serviceslist(sender).exists
	byte 0x6c // "l"
	frame_dig -1 // sender: Address
	concat
	box_len
	swap
	pop
	bz *if4_else

	// *if4_consequent
	// contracts/arc58/plugins/subscription.algo.ts:216
	// index = this.serviceslist(sender).value
	byte 0x6c // "l"
	frame_dig -1 // sender: Address
	concat
	box_get

	// box value does not exist: this.serviceslist(sender).value
	assert
	btoi
	frame_bury 0 // index: uint64

	// contracts/arc58/plugins/subscription.algo.ts:217
	// this.serviceslist(sender).value += 1
	byte 0x6c // "l"
	frame_dig -1 // sender: Address
	concat
	box_get

	// box value does not exist: this.serviceslist(sender).value
	assert
	btoi
	int 1
	+
	byte 0x6c // "l"
	frame_dig -1 // sender: Address
	concat
	swap
	itob
	box_put
	b *if4_end

*if4_else:
	// contracts/arc58/plugins/subscription.algo.ts:219
	// index = 1
	int 1
	frame_bury 0 // index: uint64

	// contracts/arc58/plugins/subscription.algo.ts:220
	// this.serviceslist(sender).value = 1
	byte 0x6c // "l"
	frame_dig -1 // sender: Address
	concat
	byte 0x0000000000000001
	box_put

*if4_end:
	// contracts/arc58/plugins/subscription.algo.ts:223
	// boxKey: ServicesKey = { user: sender, index: index }
	frame_dig -1 // sender: Address
	frame_dig 0 // index: uint64
	itob
	concat
	frame_bury 1 // boxKey: ServicesKey

	// contracts/arc58/plugins/subscription.algo.ts:226
	// assert(amount > 3, errs.MIN_AMOUNT_IS_THREE)
	frame_dig -4 // amount: uint64
	int 3
	>
	assert

	// contracts/arc58/plugins/subscription.algo.ts:228
	// assert(interval >= 60, errs.MIN_INTERVAL_IS_SIXTY)
	frame_dig -2 // interval: uint64
	int 60
	>=
	assert

	// contracts/arc58/plugins/subscription.algo.ts:230
	// assert(passes <= 5, errs.MAX_PASSES_IS_FIVE)
	frame_dig -5 // passes: uint64
	int 5
	<=
	assert

	// *if5_condition
	// contracts/arc58/plugins/subscription.algo.ts:232
	// !this.app.address.isOptedInToAsset(asa)
	global CurrentApplicationAddress
	frame_dig -3 // asa: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if5_else

	// *if5_consequent
	// contracts/arc58/plugins/subscription.algo.ts:233
	// this.addPendingOptin(sender, asa, 5_000_000, true)
	int 1
	int 5_000_000
	frame_dig -3 // asa: AssetID
	frame_dig -1 // sender: Address
	callsub addPendingOptin

	// contracts/arc58/plugins/subscription.algo.ts:234
	// this.pendingGroup.submit()
	itxn_submit
	b *if5_end

*if5_else:
	// contracts/arc58/plugins/subscription.algo.ts:237
	// sendPayment({
	//         sender: sender,
	//         receiver: globals.currentApplicationAddress,
	//         amount: 5_000_000,
	//         // always rekey the user back
	//         rekeyTo: sender,
	//         fee: 0,
	//       })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:238
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:239
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:240
	// amount: 5_000_000
	int 5_000_000
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:242
	// rekeyTo: sender
	frame_dig -1 // sender: Address
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscription.algo.ts:243
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if5_end:
	// contracts/arc58/plugins/subscription.algo.ts:247
	// this.services(boxKey).value = {
	//       shutdown: false,
	//       active: true,
	//       interval: interval,
	//       asa: asa,
	//       amount: amount,
	//       passes: passes,
	//       cid: cid,
	//       allowTraversal: allowTraversal,
	//     }
	byte 0x73 // "s"
	frame_dig 1 // boxKey: ServicesKey
	concat
	byte 0x00
	int 0
	dup
	setbit
	int 1
	dup
	setbit
	frame_dig -2 // interval: uint64
	itob
	concat
	frame_dig -3 // asa: AssetID
	itob
	concat
	frame_dig -4 // amount: uint64
	itob
	concat
	frame_dig -5 // passes: uint64
	itob
	concat
	frame_dig -6 // cid: bytes<59>
	concat
	byte 0x00
	int 0
	frame_dig -7 // allowTraversal: boolean
	setbit
	concat
	box_put

	// contracts/arc58/plugins/subscription.algo.ts:258
	// return index;
	frame_dig 0 // index: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// pauseService(address,uint64)void
*abi_route_pauseService:
	// index: uint64
	txna ApplicationArgs 2
	btoi

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (sender) for pauseService must be a address
	assert

	// execute pauseService(address,uint64)void
	callsub pauseService
	int 1
	return

// pauseService(sender: Address, index: uint64): void
//
// pauseService pauses a service for a merchant
// it does not shutdown pre-existing subscriptions
// it simply prevents new subscriptions from being created
// for a specific service
// @param sender The address the plugin currently controls
// @param index The index of the box to be used for the subscription
pauseService:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/arc58/plugins/subscription.algo.ts:270
	// boxKey: ServicesKey = { user: sender, index: index }
	frame_dig -1 // sender: Address
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // boxKey: ServicesKey

	// contracts/arc58/plugins/subscription.algo.ts:273
	// assert(this.controls(sender), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: Address
	callsub controls
	assert

	// contracts/arc58/plugins/subscription.algo.ts:276
	// assert(index > 0, errs.SERVICE_INDEX_MUST_BE_ABOVE_ZERO)
	frame_dig -2 // index: uint64
	int 0
	>
	assert

	// contracts/arc58/plugins/subscription.algo.ts:278
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	byte 0x73 // "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscription.algo.ts:280
	// assert(!this.services(boxKey).value.shutdown, errs.SERVICE_IS_SHUTDOWN)
	byte 0x73 // "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	int 0
	getbit
	!
	assert

	// contracts/arc58/plugins/subscription.algo.ts:282
	// this.services(boxKey).value.active = false
	byte 0x73 // "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	int 1
	int 0
	setbit
	byte 0x73 // "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_replace
	retsub

// activateService(address,uint64)void
*abi_route_activateService:
	// index: uint64
	txna ApplicationArgs 2
	btoi

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (sender) for activateService must be a address
	assert

	// execute activateService(address,uint64)void
	callsub activateService
	int 1
	return

// activateService(sender: Address, index: uint64): void
//
// activateService activates an service for a merchant
// @param boxIndex The index of the box to be used for the subscription
activateService:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/arc58/plugins/subscription.algo.ts:290
	// boxKey: ServicesKey = { user: sender, index: index }
	frame_dig -1 // sender: Address
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // boxKey: ServicesKey

	// contracts/arc58/plugins/subscription.algo.ts:293
	// assert(this.controls(sender), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: Address
	callsub controls
	assert

	// contracts/arc58/plugins/subscription.algo.ts:295
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	byte 0x73 // "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscription.algo.ts:297
	// assert(!this.services(boxKey).value.shutdown, errs.SERVICE_IS_SHUTDOWN)
	byte 0x73 // "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	int 0
	getbit
	!
	assert

	// contracts/arc58/plugins/subscription.algo.ts:299
	// this.services(boxKey).value.active = true
	byte 0x73 // "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	int 1
	dup
	setbit
	byte 0x73 // "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_replace
	retsub

// shutdownService(address,uint64)void
*abi_route_shutdownService:
	// index: uint64
	txna ApplicationArgs 2
	btoi

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (sender) for shutdownService must be a address
	assert

	// execute shutdownService(address,uint64)void
	callsub shutdownService
	int 1
	return

// shutdownService(sender: Address, index: uint64): void
//
// shutdownService permanently shuts down an service for a merchant
// it also shutsdown pre-existing subscriptions
// @param sender The address the plugin currently controls
// @param index The index of the box to be used for the subscription
shutdownService:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/arc58/plugins/subscription.algo.ts:309
	// boxKey: ServicesKey = { user: sender, index: index }
	frame_dig -1 // sender: Address
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // boxKey: ServicesKey

	// contracts/arc58/plugins/subscription.algo.ts:312
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	byte 0x73 // "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscription.algo.ts:314
	// assert(!this.services(boxKey).value.shutdown, errs.SERVICE_IS_SHUTDOWN)
	byte 0x73 // "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	int 0
	getbit
	!
	assert

	// contracts/arc58/plugins/subscription.algo.ts:316
	// service = clone(this.services(boxKey).value)
	byte 0x73 // "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	frame_bury 1 // service: (bool,bool,uint64,uint64,uint64,uint64,byte[59],bool)

	// contracts/arc58/plugins/subscription.algo.ts:318
	// this.services(boxKey).value = {
	//       shutdown: true,
	//       active: false,
	//       interval: service.interval,
	//       asa: service.asa,
	//       amount: service.amount,
	//       passes: service.passes,
	//       cid: service.cid,
	//       allowTraversal: service.allowTraversal,
	//     }
	byte 0x73 // "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	byte 0x00
	int 0
	int 1
	setbit
	int 1
	int 0
	setbit
	frame_dig 1 // service: (bool,bool,uint64,uint64,uint64,uint64,byte[59],bool)
	store 255 // full array
	load 255 // full array
	extract 1 8
	btoi
	itob
	concat
	frame_dig 1 // service: (bool,bool,uint64,uint64,uint64,uint64,byte[59],bool)
	store 255 // full array
	load 255 // full array
	extract 9 8
	btoi
	itob
	concat
	frame_dig 1 // service: (bool,bool,uint64,uint64,uint64,uint64,byte[59],bool)
	store 255 // full array
	load 255 // full array
	extract 17 8
	btoi
	itob
	concat
	frame_dig 1 // service: (bool,bool,uint64,uint64,uint64,uint64,byte[59],bool)
	store 255 // full array
	load 255 // full array
	extract 25 8
	btoi
	itob
	concat
	frame_dig 1 // service: (bool,bool,uint64,uint64,uint64,uint64,byte[59],bool)
	store 255 // full array
	load 255 // full array
	extract 33 59
	concat
	byte 0x00
	int 0
	frame_dig 1 // service: (bool,bool,uint64,uint64,uint64,uint64,byte[59],bool)
	store 255 // full array
	load 255 // full array
	int 736
	getbit
	setbit
	concat
	box_put
	retsub

// isShutdown(address,uint64)bool
*abi_route_isShutdown:
	// The ABI return prefix
	byte 0x151f7c75

	// boxIndex: uint64
	txna ApplicationArgs 2
	btoi

	// merchant: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (merchant) for isShutdown must be a address
	assert

	// execute isShutdown(address,uint64)bool
	callsub isShutdown
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// isShutdown(merchant: Address, boxIndex: uint64): boolean
//
// serviceIsActive checks if an service is shutdown
isShutdown:
	proto 2 1

	// contracts/arc58/plugins/subscription.algo.ts:335
	// return this.services({ user: merchant, index: boxIndex }).value.shutdown;
	byte 0x73 // "s"
	frame_dig -1 // merchant: Address
	frame_dig -2 // boxIndex: uint64
	itob
	concat
	concat
	box_get

	// box value does not exist: this.services({ user: merchant, index: boxIndex }).value
	assert
	store 255 // full array
	load 255 // full array
	int 0
	getbit
	retsub

// block(address,address)void
*abi_route_block:
	// address: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (address) for block must be a address
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (sender) for block must be a address
	assert

	// execute block(address,address)void
	callsub block
	int 1
	return

// block(sender: Address, address: Address): void
//
// block blacklists an address for a merchant
// @param sender The address the plugin currently controls
// @param address The address to be blocked
block:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/arc58/plugins/subscription.algo.ts:344
	// boxKey: BlockListKey = { user: sender, blocked: address }
	frame_dig -1 // sender: Address
	frame_dig -2 // address: Address
	concat
	frame_bury 0 // boxKey: BlockListKey

	// contracts/arc58/plugins/subscription.algo.ts:347
	// assert(!this.blocks(boxKey).exists, errs.USER_ALREADY_BLOCKED)
	frame_dig 0 // boxKey: BlockListKey
	box_len
	swap
	pop
	!
	assert

	// contracts/arc58/plugins/subscription.algo.ts:350
	// sendPayment({
	//       sender: sender,
	//       receiver: globals.currentApplicationAddress,
	//       amount: 28_100,
	//       // always rekey the user back
	//       rekeyTo: sender,
	//       fee: 0,
	//     })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:351
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:352
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:353
	// amount: 28_100
	int 28_100
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:355
	// rekeyTo: sender
	frame_dig -1 // sender: Address
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscription.algo.ts:356
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/arc58/plugins/subscription.algo.ts:359
	// this.blocks(boxKey).create(0)
	frame_dig 0 // boxKey: BlockListKey
	int 0
	box_create
	pop
	retsub

// unblock(address,address)void
*abi_route_unblock:
	// address: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (address) for unblock must be a address
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (sender) for unblock must be a address
	assert

	// execute unblock(address,address)void
	callsub unblock
	int 1
	return

// unblock(sender: Address, address: Address): void
//
// unblock removes an address from a merchants blocks
// @param address The address to be unblocked
unblock:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/arc58/plugins/subscription.algo.ts:367
	// boxKey: BlockListKey = { user: sender, blocked: address }
	frame_dig -1 // sender: Address
	frame_dig -2 // address: Address
	concat
	frame_bury 0 // boxKey: BlockListKey

	// contracts/arc58/plugins/subscription.algo.ts:370
	// assert(this.blocks(boxKey).exists, errs.USER_NOT_BLOCKED)
	frame_dig 0 // boxKey: BlockListKey
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscription.algo.ts:372
	// this.blocks(boxKey).delete()
	frame_dig 0 // boxKey: BlockListKey
	box_del
	retsub

// isBlocked(address,address)bool
*abi_route_isBlocked:
	// The ABI return prefix
	byte 0x151f7c75

	// address: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (address) for isBlocked must be a address
	assert

	// merchant: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (merchant) for isBlocked must be a address
	assert

	// execute isBlocked(address,address)bool
	callsub isBlocked
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// isBlocked(merchant: Address, address: Address): boolean
//
// isBlocked checks if an address is blocked for a merchant
// @param merchant The merchant address to be checked
// @param address The address to be checked
isBlocked:
	proto 2 1

	// contracts/arc58/plugins/subscription.algo.ts:382
	// return this.blocks({ user: merchant, blocked: address }).exists;
	frame_dig -1 // merchant: Address
	frame_dig -2 // address: Address
	concat
	box_len
	swap
	pop
	retsub

// subscribe(address,address,uint64,uint64,uint64,uint64)void
*abi_route_subscribe:
	// asa: uint64
	txna ApplicationArgs 6
	btoi

	// interval: uint64
	txna ApplicationArgs 5
	btoi

	// amount: uint64
	txna ApplicationArgs 4
	btoi

	// index: uint64
	txna ApplicationArgs 3
	btoi

	// recipient: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 4 (recipient) for subscribe must be a address
	assert

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 5 (sender) for subscribe must be a address
	assert

	// execute subscribe(address,address,uint64,uint64,uint64,uint64)void
	callsub subscribe
	int 1
	return

// subscribe(sender: Address, recipient: Address, index: uint64, amount: uint64, interval: uint64, asa: AssetID): void
subscribe:
	proto 6 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 10

	// contracts/arc58/plugins/subscription.algo.ts:393
	// isDonation = index === 0
	frame_dig -3 // index: uint64
	int 0
	==
	frame_bury 0 // isDonation: bool

	// contracts/arc58/plugins/subscription.algo.ts:394
	// isAsa = asa.id !== 0
	frame_dig -6 // asa: AssetID
	int 0
	!=
	frame_bury 1 // isAsa: bool

	// contracts/arc58/plugins/subscription.algo.ts:397
	// assert(amount > 3, errs.MIN_AMOUNT_IS_THREE)
	frame_dig -4 // amount: uint64
	int 3
	>
	assert

	// contracts/arc58/plugins/subscription.algo.ts:399
	// assert(interval >= 60, errs.MIN_INTERVAL_IS_SIXTY)
	frame_dig -5 // interval: uint64
	int 60
	>=
	assert

	// *if6_condition
	// contracts/arc58/plugins/subscription.algo.ts:401
	// !isDonation
	frame_dig 0 // isDonation: bool
	!
	bz *if6_end

	// *if6_consequent
	// contracts/arc58/plugins/subscription.algo.ts:402
	// boxKey: ServicesKey = { user: recipient, index: index }
	frame_dig -2 // recipient: Address
	frame_dig -3 // index: uint64
	itob
	concat
	frame_bury 2 // boxKey: ServicesKey

	// contracts/arc58/plugins/subscription.algo.ts:403
	// blocksKey: BlockListKey = { user: recipient, blocked: sender }
	frame_dig -2 // recipient: Address
	frame_dig -1 // sender: Address
	concat
	frame_bury 3 // blocksKey: BlockListKey

	// contracts/arc58/plugins/subscription.algo.ts:406
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	byte 0x73 // "s"
	frame_dig 2 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscription.algo.ts:408
	// service = this.services(boxKey).value
	byte 0x73 // "s"
	frame_dig 2 // boxKey: ServicesKey
	concat
	frame_bury 4 // storage key//service

	// contracts/arc58/plugins/subscription.algo.ts:411
	// assert(!this.blocks(blocksKey).exists, errs.BLOCKED)
	frame_dig 3 // blocksKey: BlockListKey
	box_len
	swap
	pop
	!
	assert

	// contracts/arc58/plugins/subscription.algo.ts:413
	// assert(!service.shutdown, errs.SERVICE_IS_SHUTDOWN)
	frame_dig 4 // storage key//service
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	int 0
	getbit
	!
	assert

	// contracts/arc58/plugins/subscription.algo.ts:415
	// assert(service.active, errs.SERVICE_IS_PAUSED)
	frame_dig 4 // storage key//service
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	int 1
	getbit
	assert

	// contracts/arc58/plugins/subscription.algo.ts:417
	// amount = service.amount
	frame_dig 4 // storage key//service
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	extract 17 8
	btoi
	frame_bury -4 // amount: uint64

	// contracts/arc58/plugins/subscription.algo.ts:418
	// interval = service.interval
	frame_dig 4 // storage key//service
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	extract 1 8
	btoi
	frame_bury -5 // interval: uint64

*if6_end:
	// contracts/arc58/plugins/subscription.algo.ts:421
	// algoMBRFee: uint64 = 53_700
	int 53_700
	frame_bury 5 // algoMBRFee: uint64

	// contracts/arc58/plugins/subscription.algo.ts:422
	// subIndex: uint64 = 0
	int 0
	frame_bury 6 // subIndex: uint64

	// contracts/arc58/plugins/subscription.algo.ts:423
	// subscriptionsListExists: boolean = this.subscriptionslist(sender).exists
	frame_dig -1 // sender: Address
	box_len
	swap
	pop
	frame_bury 7 // subscriptionsListExists: boolean

	// *if7_condition
	// contracts/arc58/plugins/subscription.algo.ts:424
	// subscriptionsListExists
	frame_dig 7 // subscriptionsListExists: boolean
	bz *if7_else

	// *if7_consequent
	// contracts/arc58/plugins/subscription.algo.ts:425
	// subIndex = this.subscriptionslist(sender).value
	frame_dig -1 // sender: Address
	box_get

	// box value does not exist: this.subscriptionslist(sender).value
	assert
	btoi
	frame_bury 6 // subIndex: uint64

	// contracts/arc58/plugins/subscription.algo.ts:426
	// this.subscriptionslist(sender).value += 1
	frame_dig -1 // sender: Address
	box_get

	// box value does not exist: this.subscriptionslist(sender).value
	assert
	btoi
	int 1
	+
	frame_dig -1 // sender: Address
	swap
	itob
	box_put
	b *if7_end

*if7_else:
	// contracts/arc58/plugins/subscription.algo.ts:428
	// algoMBRFee += 18_500
	frame_dig 5 // algoMBRFee: uint64
	int 18_500
	+
	frame_bury 5 // algoMBRFee: uint64

	// contracts/arc58/plugins/subscription.algo.ts:429
	// subIndex = 0
	int 0
	frame_bury 6 // subIndex: uint64

	// contracts/arc58/plugins/subscription.algo.ts:430
	// this.subscriptionslist(sender).value = 0
	frame_dig -1 // sender: Address
	byte 0x0000000000000000
	box_put

*if7_end:
	// contracts/arc58/plugins/subscription.algo.ts:433
	// subscriptionKey: SubscriptionKey = { user: sender, index: subIndex }
	frame_dig -1 // sender: Address
	frame_dig 6 // subIndex: uint64
	itob
	concat
	frame_bury 8 // subscriptionKey: SubscriptionKey

	// contracts/arc58/plugins/subscription.algo.ts:435
	// this.subscriptions(subscriptionKey).value = {
	//       recipient: recipient,
	//       index: index,
	//       startDate: globals.latestTimestamp,
	//       amount: amount,
	//       interval: interval,
	//       asa: asa,
	//       lastPayment: globals.latestTimestamp,
	//       streak: 1,
	//     }
	frame_dig 8 // subscriptionKey: SubscriptionKey
	frame_dig -2 // recipient: Address
	frame_dig -3 // index: uint64
	itob
	concat
	global LatestTimestamp
	itob
	concat
	frame_dig -4 // amount: uint64
	itob
	concat
	frame_dig -5 // interval: uint64
	itob
	concat
	frame_dig -6 // asa: AssetID
	itob
	concat
	global LatestTimestamp
	itob
	concat
	byte 0x0000000000000001
	concat
	box_put

	// contracts/arc58/plugins/subscription.algo.ts:446
	// initialFee = (amount * 40 - 1) / 1000 + 1
	frame_dig -4 // amount: uint64
	int 40
	*
	int 1
	-
	int 1000
	/
	int 1
	+
	frame_bury 9 // initialFee: uint64

	// contracts/arc58/plugins/subscription.algo.ts:447
	// leftOver = amount - initialFee
	frame_dig -4 // amount: uint64
	frame_dig 9 // initialFee: uint64
	-
	frame_bury 10 // leftOver: uint64

	// *if8_condition
	// contracts/arc58/plugins/subscription.algo.ts:449
	// isAsa
	frame_dig 1 // isAsa: bool
	bz *if8_else

	// *if8_consequent
	// *if9_condition
	// contracts/arc58/plugins/subscription.algo.ts:450
	// !this.app.address.isOptedInToAsset(asa)
	global CurrentApplicationAddress
	frame_dig -6 // asa: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if9_else

	// *if9_consequent
	// contracts/arc58/plugins/subscription.algo.ts:451
	// this.addPendingOptin(sender, asa, algoMBRFee, false)
	int 0
	frame_dig 5 // algoMBRFee: uint64
	frame_dig -6 // asa: AssetID
	frame_dig -1 // sender: Address
	callsub addPendingOptin
	b *if9_end

*if9_else:
	// contracts/arc58/plugins/subscription.algo.ts:454
	// this.pendingGroup.addPayment({
	//           sender: sender,
	//           receiver: globals.currentApplicationAddress,
	//           amount: algoMBRFee,
	//           fee: 0,
	//         })
	itxn_next
	int pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:455
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:456
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:457
	// amount: algoMBRFee
	frame_dig 5 // algoMBRFee: uint64
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:458
	// fee: 0
	int 0
	itxn_field Fee

*if9_end:
	// contracts/arc58/plugins/subscription.algo.ts:462
	// this.pendingGroup.addAssetTransfer({
	//         sender: sender,
	//         assetReceiver: globals.currentApplicationAddress,
	//         xferAsset: asa,
	//         assetAmount: initialFee,
	//         fee: 0,
	//       })
	itxn_next
	int axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:463
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:464
	// assetReceiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscription.algo.ts:465
	// xferAsset: asa
	frame_dig -6 // asa: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/subscription.algo.ts:466
	// assetAmount: initialFee
	frame_dig 9 // initialFee: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscription.algo.ts:467
	// fee: 0
	int 0
	itxn_field Fee

	// contracts/arc58/plugins/subscription.algo.ts:470
	// this.pendingGroup.addAssetTransfer({
	//         sender: sender,
	//         assetReceiver: recipient,
	//         xferAsset: asa,
	//         assetAmount: leftOver,
	//         // always rekey the user back
	//         rekeyTo: sender,
	//         fee: 0,
	//       })
	itxn_next
	int axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:471
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:472
	// assetReceiver: recipient
	frame_dig -2 // recipient: Address
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscription.algo.ts:473
	// xferAsset: asa
	frame_dig -6 // asa: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/subscription.algo.ts:474
	// assetAmount: leftOver
	frame_dig 10 // leftOver: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscription.algo.ts:476
	// rekeyTo: sender
	frame_dig -1 // sender: Address
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscription.algo.ts:477
	// fee: 0
	int 0
	itxn_field Fee
	b *if8_end

*if8_else:
	// contracts/arc58/plugins/subscription.algo.ts:481
	// this.pendingGroup.addPayment({
	//         sender: sender,
	//         receiver: globals.currentApplicationAddress,
	//         amount: (algoMBRFee + initialFee),
	//         fee: 0,
	//       })
	itxn_next
	int pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:482
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:483
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:484
	// amount: (algoMBRFee + initialFee)
	frame_dig 5 // algoMBRFee: uint64
	frame_dig 9 // initialFee: uint64
	+
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:485
	// fee: 0
	int 0
	itxn_field Fee

	// contracts/arc58/plugins/subscription.algo.ts:488
	// this.pendingGroup.addPayment({
	//         sender: sender,
	//         receiver: recipient,
	//         amount: leftOver,
	//         // always rekey the user back
	//         rekeyTo: sender,
	//         fee: 0,
	//       })
	itxn_next
	int pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:489
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:490
	// receiver: recipient
	frame_dig -2 // recipient: Address
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:491
	// amount: leftOver
	frame_dig 10 // leftOver: uint64
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:493
	// rekeyTo: sender
	frame_dig -1 // sender: Address
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscription.algo.ts:494
	// fee: 0
	int 0
	itxn_field Fee

*if8_end:
	// contracts/arc58/plugins/subscription.algo.ts:498
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// triggerPayment(address,uint64)void
*abi_route_triggerPayment:
	// index: uint64
	txna ApplicationArgs 2
	btoi

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (sender) for triggerPayment must be a address
	assert

	// execute triggerPayment(address,uint64)void
	callsub triggerPayment
	int 1
	return

// triggerPayment(sender: Address, index: uint64): void
triggerPayment:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 7

	// contracts/arc58/plugins/subscription.algo.ts:502
	// subscriptionsKey: SubscriptionKey = { user: sender, index: index }
	frame_dig -1 // sender: Address
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // subscriptionsKey: SubscriptionKey

	// contracts/arc58/plugins/subscription.algo.ts:505
	// assert(this.subscriptions(subscriptionsKey).exists)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscription.algo.ts:507
	// sub = this.subscriptions(subscriptionsKey).value
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/arc58/plugins/subscription.algo.ts:509
	// blocksKey: BlockListKey = { user: sub.recipient, blocked: sender }
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	int 0
	int 32
	box_extract
	frame_dig -1 // sender: Address
	concat
	frame_bury 2 // blocksKey: BlockListKey

	// contracts/arc58/plugins/subscription.algo.ts:512
	// assert(!this.blocks(blocksKey).exists, errs.BLOCKED)
	frame_dig 2 // blocksKey: BlockListKey
	box_len
	swap
	pop
	!
	assert

	// *if10_condition
	// contracts/arc58/plugins/subscription.algo.ts:514
	// index > 0
	frame_dig -2 // index: uint64
	int 0
	>
	bz *if10_end

	// *if10_consequent
	// contracts/arc58/plugins/subscription.algo.ts:515
	// servicesKey: ServicesKey = { user: sub.recipient, index: sub.index }
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	int 0
	int 32
	box_extract
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	int 32 // headOffset
	int 8
	box_extract
	btoi
	itob
	concat
	frame_bury 3 // servicesKey: ServicesKey

	// contracts/arc58/plugins/subscription.algo.ts:517
	// assert(!this.services(servicesKey).value.active, errs.SERVICE_IS_PAUSED)
	byte 0x73 // "s"
	frame_dig 3 // servicesKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(servicesKey).value
	assert
	store 255 // full array
	load 255 // full array
	int 1
	getbit
	!
	assert

*if10_end:
	// contracts/arc58/plugins/subscription.algo.ts:521
	// assert(sub.lastPayment < this.getLatestWindowStart(sub.startDate, sub.interval), errs.BAD_WINDOW)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	int 72 // headOffset
	int 8
	box_extract
	btoi
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	int 56 // headOffset
	int 8
	box_extract
	btoi
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	int 40 // headOffset
	int 8
	box_extract
	btoi
	callsub getLatestWindowStart
	<
	assert

	// contracts/arc58/plugins/subscription.algo.ts:523
	// isAsa = sub.asa.id !== 0
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	int 64 // headOffset
	int 8
	box_extract
	btoi
	int 0
	!=
	frame_bury 4 // isAsa: bool

	// contracts/arc58/plugins/subscription.algo.ts:525
	// akitaFee = (sub.amount * 35 - 1) / 1000 + 1
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	int 48 // headOffset
	int 8
	box_extract
	btoi
	int 35
	*
	int 1
	-
	int 1000
	/
	int 1
	+
	frame_bury 5 // akitaFee: uint64

	// contracts/arc58/plugins/subscription.algo.ts:526
	// triggerFee = (sub.amount * 5 - 1) / 1000 + 1
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	int 48 // headOffset
	int 8
	box_extract
	btoi
	int 5
	*
	int 1
	-
	int 1000
	/
	int 1
	+
	frame_bury 6 // triggerFee: uint64

	// contracts/arc58/plugins/subscription.algo.ts:527
	// leftOver = sub.amount - (akitaFee + triggerFee)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	int 48 // headOffset
	int 8
	box_extract
	btoi
	frame_dig 5 // akitaFee: uint64
	frame_dig 6 // triggerFee: uint64
	+
	-
	frame_bury 7 // leftOver: uint64

	// *if11_condition
	// contracts/arc58/plugins/subscription.algo.ts:529
	// isAsa
	frame_dig 4 // isAsa: bool
	bz *if11_else

	// *if11_consequent
	// contracts/arc58/plugins/subscription.algo.ts:530
	// this.pendingGroup.addAssetTransfer({
	//         sender: sender,
	//         assetReceiver: globals.currentApplicationAddress,
	//         xferAsset: sub.asa,
	//         assetAmount: akitaFee,
	//         fee: 0,
	//       })
	itxn_next
	int axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:531
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:532
	// assetReceiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscription.algo.ts:533
	// xferAsset: sub.asa
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	int 64 // headOffset
	int 8
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/arc58/plugins/subscription.algo.ts:534
	// assetAmount: akitaFee
	frame_dig 5 // akitaFee: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscription.algo.ts:535
	// fee: 0
	int 0
	itxn_field Fee

	// contracts/arc58/plugins/subscription.algo.ts:538
	// this.pendingGroup.addAssetTransfer({
	//         sender: sender,
	//         assetReceiver: this.txn.sender,
	//         xferAsset: sub.asa,
	//         assetAmount: triggerFee,
	//         fee: 0,
	//       })
	itxn_next
	int axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:539
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:540
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscription.algo.ts:541
	// xferAsset: sub.asa
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	int 64 // headOffset
	int 8
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/arc58/plugins/subscription.algo.ts:542
	// assetAmount: triggerFee
	frame_dig 6 // triggerFee: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscription.algo.ts:543
	// fee: 0
	int 0
	itxn_field Fee

	// contracts/arc58/plugins/subscription.algo.ts:546
	// this.pendingGroup.addAssetTransfer({
	//         sender: sender,
	//         assetReceiver: sub.recipient,
	//         xferAsset: sub.asa,
	//         assetAmount: leftOver,
	//         // always rekey the user back
	//         rekeyTo: sender,
	//         fee: 0,
	//       })
	itxn_next
	int axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:547
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:548
	// assetReceiver: sub.recipient
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	int 0
	int 32
	box_extract
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscription.algo.ts:549
	// xferAsset: sub.asa
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	int 64 // headOffset
	int 8
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/arc58/plugins/subscription.algo.ts:550
	// assetAmount: leftOver
	frame_dig 7 // leftOver: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscription.algo.ts:552
	// rekeyTo: sender
	frame_dig -1 // sender: Address
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscription.algo.ts:553
	// fee: 0
	int 0
	itxn_field Fee
	b *if11_end

*if11_else:
	// contracts/arc58/plugins/subscription.algo.ts:557
	// this.pendingGroup.addPayment({
	//         sender: sender,
	//         receiver: globals.currentApplicationAddress,
	//         amount: akitaFee,
	//         fee: 0,
	//       })
	itxn_next
	int pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:558
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:559
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:560
	// amount: akitaFee
	frame_dig 5 // akitaFee: uint64
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:561
	// fee: 0
	int 0
	itxn_field Fee

	// contracts/arc58/plugins/subscription.algo.ts:564
	// this.pendingGroup.addPayment({
	//         sender: sender,
	//         receiver: this.txn.sender,
	//         amount: triggerFee,
	//         fee: 0,
	//       })
	itxn_next
	int pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:565
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:566
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:567
	// amount: triggerFee
	frame_dig 6 // triggerFee: uint64
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:568
	// fee: 0
	int 0
	itxn_field Fee

	// contracts/arc58/plugins/subscription.algo.ts:571
	// this.pendingGroup.addPayment({
	//         sender: sender,
	//         receiver: sub.recipient,
	//         amount: leftOver,
	//         // always rekey the user back
	//         rekeyTo: sender,
	//         fee: 0,
	//       })
	itxn_next
	int pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:572
	// sender: sender
	frame_dig -1 // sender: Address
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:573
	// receiver: sub.recipient
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	int 0
	int 32
	box_extract
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:574
	// amount: leftOver
	frame_dig 7 // leftOver: uint64
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:576
	// rekeyTo: sender
	frame_dig -1 // sender: Address
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscription.algo.ts:577
	// fee: 0
	int 0
	itxn_field Fee

*if11_end:
	// contracts/arc58/plugins/subscription.algo.ts:581
	// this.pendingGroup.submit()
	itxn_submit

	// contracts/arc58/plugins/subscription.algo.ts:583
	// this.updateStreak(sender, index, 1)
	int 1
	frame_dig -2 // index: uint64
	frame_dig -1 // sender: Address
	callsub updateStreak

	// contracts/arc58/plugins/subscription.algo.ts:585
	// this.subscriptions(subscriptionsKey).value.lastPayment = globals.latestTimestamp
	int 72 // headOffset
	global LatestTimestamp
	itob
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	cover 2
	box_replace
	retsub

// streakCheck(address,uint64)void
*abi_route_streakCheck:
	// index: uint64
	txna ApplicationArgs 2
	btoi

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (sender) for streakCheck must be a address
	assert

	// execute streakCheck(address,uint64)void
	callsub streakCheck
	int 1
	return

// streakCheck(sender: Address, index: uint64): void
streakCheck:
	proto 2 0

	// contracts/arc58/plugins/subscription.algo.ts:589
	// this.updateStreak(sender, index, 0)
	int 0
	frame_dig -2 // index: uint64
	frame_dig -1 // sender: Address
	callsub updateStreak
	retsub

// setPasses(address,uint64,address[])void
*abi_route_setPasses:
	// addresses: address[]
	txna ApplicationArgs 3
	extract 2 0

	// index: uint64
	txna ApplicationArgs 2
	btoi

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (sender) for setPasses must be a address
	assert

	// execute setPasses(address,uint64,address[])void
	callsub setPasses
	int 1
	return

// setPasses(sender: Address, index: uint64, addresses: Address[]): void
setPasses:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// contracts/arc58/plugins/subscription.algo.ts:593
	// assert(index > 0, errs.NO_DONATIONS)
	frame_dig -2 // index: uint64
	int 0
	>
	assert

	// contracts/arc58/plugins/subscription.algo.ts:595
	// subscriptionsKey: SubscriptionKey = { user: sender, index: index }
	frame_dig -1 // sender: Address
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // subscriptionsKey: SubscriptionKey

	// contracts/arc58/plugins/subscription.algo.ts:597
	// assert(this.subscriptions(subscriptionsKey).exists, errs.SUBSCRIPTION_DOES_NOT_EXIST)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscription.algo.ts:599
	// sub = this.subscriptions(subscriptionsKey).value
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/arc58/plugins/subscription.algo.ts:601
	// serviceKey: ServicesKey = { user: sub.recipient, index: index }
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	int 0
	int 32
	box_extract
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 2 // serviceKey: ServicesKey

	// contracts/arc58/plugins/subscription.algo.ts:602
	// service = this.services(serviceKey).value
	byte 0x73 // "s"
	frame_dig 2 // serviceKey: ServicesKey
	concat
	frame_bury 3 // storage key//service

	// contracts/arc58/plugins/subscription.algo.ts:604
	// assert(service.active, errs.SERVICE_IS_PAUSED)
	frame_dig 3 // storage key//service
	box_get

	// box value does not exist: this.services(serviceKey).value
	assert
	store 255 // full array
	load 255 // full array
	int 1
	getbit
	assert

	// contracts/arc58/plugins/subscription.algo.ts:605
	// assert(!service.shutdown, errs.SERVICE_IS_SHUTDOWN)
	frame_dig 3 // storage key//service
	box_get

	// box value does not exist: this.services(serviceKey).value
	assert
	store 255 // full array
	load 255 // full array
	int 0
	getbit
	!
	assert

	// contracts/arc58/plugins/subscription.algo.ts:606
	// assert(service.passes >= addresses.length, errs.PASS_COUNT_OVERFLOW)
	frame_dig 3 // storage key//service
	box_get

	// box value does not exist: this.services(serviceKey).value
	assert
	store 255 // full array
	load 255 // full array
	extract 25 8
	btoi
	frame_dig -3 // addresses: Address[]
	len
	int 32
	/
	>=
	assert

	// contracts/arc58/plugins/subscription.algo.ts:608
	// for (let i = 0; i < addresses.length; i += 1)
	int 0
	frame_bury 4 // i: uint64

*for_0:
	// contracts/arc58/plugins/subscription.algo.ts:608
	// i < addresses.length
	frame_dig 4 // i: uint64
	frame_dig -3 // addresses: Address[]
	len
	int 32
	/
	<
	bz *for_0_end

	// contracts/arc58/plugins/subscription.algo.ts:609
	// assert(!this.blocks({ user: sub.recipient, blocked: addresses[i] }).exists, errs.BLOCKED)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	int 0
	int 32
	box_extract
	frame_dig -3 // addresses: Address[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 4 // i: uint64
	int 32
	* // acc * typeLength
	+
	load 255 // full array
	swap
	int 32
	extract3
	concat
	box_len
	swap
	pop
	!
	assert

*for_0_continue:
	// contracts/arc58/plugins/subscription.algo.ts:608
	// i += 1
	frame_dig 4 // i: uint64
	int 1
	+
	frame_bury 4 // i: uint64
	b *for_0

*for_0_end:
	// contracts/arc58/plugins/subscription.algo.ts:612
	// this.passes(subscriptionsKey).value = addresses
	byte 0x70 // "p"
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	concat
	dup
	box_del
	pop
	frame_dig -3 // addresses: Address[]
	dup
	len
	int 32
	/
	itob
	extract 6 2
	swap
	concat
	box_put
	retsub

*abi_route_createApplication:
	int 1
	return

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])"
	method "newService(address,uint64,uint64,uint64,uint64,byte[59],bool)uint64"
	method "pauseService(address,uint64)void"
	method "activateService(address,uint64)void"
	method "shutdownService(address,uint64)void"
	method "isShutdown(address,uint64)bool"
	method "block(address,address)void"
	method "unblock(address,address)void"
	method "isBlocked(address,address)bool"
	method "subscribe(address,address,uint64,uint64,uint64,uint64)void"
	method "triggerPayment(address,uint64)void"
	method "streakCheck(address,uint64)void"
	method "setPasses(address,uint64,address[])void"
	txna ApplicationArgs 0
	match *abi_route_getSubsriptionInfo *abi_route_newService *abi_route_pauseService *abi_route_activateService *abi_route_shutdownService *abi_route_isShutdown *abi_route_block *abi_route_unblock *abi_route_isBlocked *abi_route_subscribe *abi_route_triggerPayment *abi_route_streakCheck *abi_route_setPasses

	// this contract does not implement the given ABI method for call NoOp
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub