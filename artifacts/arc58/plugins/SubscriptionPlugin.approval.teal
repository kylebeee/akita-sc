#pragma version 10
intcblock 0 1 8 32 4 80 64 48 56 88 1000 40 3 6 60
bytecblock 0x 0x73 0x64616f5f6170705f6964 0x6c 0x151f7c75 0x70 0x00 "subscription_payment_percentage" "subscription_trigger_percentage" 0x0000000000000001

// This TEAL was generated by TEALScript v0.106.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 13 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// controls(address: Address): boolean
controls:
	proto 1 1

	// contracts/arc58/plugins/subscriptions.algo.ts:132
	// return address.authAddr === this.app.address;
	frame_dig -1 // address: Address
	acct_params_get AcctAuthAddr
	pop
	global CurrentApplicationAddress
	==
	retsub

// rekeyBack(address: Address): void
rekeyBack:
	proto 1 0

	// contracts/arc58/plugins/subscriptions.algo.ts:136
	// sendPayment({
	//       sender: address,
	//       amount: 0,
	//       receiver: address,
	//       rekeyTo: address,
	//       fee: 0,
	//     })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:137
	// sender: address
	frame_dig -1 // address: Address
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:138
	// amount: 0
	intc 0 // 0
	itxn_field Amount

	// contracts/arc58/plugins/subscriptions.algo.ts:139
	// receiver: address
	frame_dig -1 // address: Address
	itxn_field Receiver

	// contracts/arc58/plugins/subscriptions.algo.ts:140
	// rekeyTo: address
	frame_dig -1 // address: Address
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscriptions.algo.ts:141
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// gate(index: uint64, args: bytes[]): boolean
gate:
	proto 2 1

	// *if0_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:146
	// index === 0
	frame_dig -1 // index: uint64
	intc 0 // 0
	==
	bz *if0_end

	// *if0_consequent
	// contracts/arc58/plugins/subscriptions.algo.ts:147
	// return true;
	intc 1 // 1
	retsub

*if0_end:
	// contracts/arc58/plugins/subscriptions.algo.ts:150
	// return sendMethodCall<typeof Gate.prototype.check, boolean>({
	//       applicationID: AppID.fromUint64(AkitaAppIDsGate),
	//       methodArgs: [ index, args ],
	//       fee: 0
	//     });
	itxn_begin
	intc 13 //  appl
	itxn_field TypeEnum
	pushbytes 0xb5feb87b // method "check(uint64,byte[][])bool"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:151
	// applicationID: AppID.fromUint64(AkitaAppIDsGate)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/subscriptions.algo.ts:152
	// methodArgs: [ index, args ]
	frame_dig -1 // index: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -2 // args: bytes[]
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscriptions.algo.ts:153
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	retsub

// addPendingOptin(sender: AppID, rekeyBack: boolean, asset: AssetID, amount: uint64): void
addPendingOptin:
	proto 4 0

	// contracts/arc58/plugins/subscriptions.algo.ts:158
	// this.pendingGroup.addAssetTransfer({
	//       sender: globals.currentApplicationAddress,
	//       assetReceiver: globals.currentApplicationAddress,
	//       assetAmount: 0,
	//       xferAsset: asset,
	//       fee: 0,
	//     })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:159
	// sender: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:160
	// assetReceiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscriptions.algo.ts:161
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscriptions.algo.ts:162
	// xferAsset: asset
	frame_dig -3 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/subscriptions.algo.ts:163
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/subscriptions.algo.ts:166
	// this.pendingGroup.addPayment({
	//       sender: sender.address,
	//       receiver: globals.currentApplicationAddress,
	//       amount: (globals.assetOptInMinBalance + amount),
	//       rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//       fee: 0,
	//     })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:167
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:168
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscriptions.algo.ts:169
	// amount: (globals.assetOptInMinBalance + amount)
	global AssetOptInMinBalance
	frame_dig -4 // amount: uint64
	+
	itxn_field Amount

	// contracts/arc58/plugins/subscriptions.algo.ts:170
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary0_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary0_end

*ternary0_false:
	global ZeroAddress

*ternary0_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscriptions.algo.ts:171
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	retsub

// getLatestWindowStart(startDate: uint64, interval: uint64): uint64
getLatestWindowStart:
	proto 2 1

	// contracts/arc58/plugins/subscriptions.algo.ts:176
	// return globals.latestTimestamp - ((globals.latestTimestamp - startDate) % interval);
	global LatestTimestamp
	global LatestTimestamp
	frame_dig -1 // startDate: uint64
	-
	frame_dig -2 // interval: uint64
	%
	-
	retsub

// updateStreak(sender: Address, index: uint64, elseStreak: uint64): void
updateStreak:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts/arc58/plugins/subscriptions.algo.ts:180
	// subKey: SubscriptionKey = { user: sender, index: index }
	frame_dig -1 // sender: Address
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // subKey: SubscriptionKey

	// contracts/arc58/plugins/subscriptions.algo.ts:181
	// sub = this.subscriptions(subKey).value
	frame_dig 0 // subKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/arc58/plugins/subscriptions.algo.ts:183
	// currentWindowStart = this.getLatestWindowStart(sub.startDate, sub.interval)
	frame_dig 0 // subKey: SubscriptionKey
	intc 8 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 0 // subKey: SubscriptionKey
	intc 11 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	callsub getLatestWindowStart
	frame_bury 2 // currentWindowStart: uint64

	// contracts/arc58/plugins/subscriptions.algo.ts:184
	// lastWindowStart = (currentWindowStart - sub.interval)
	frame_dig 2 // currentWindowStart: uint64
	frame_dig 0 // subKey: SubscriptionKey
	intc 8 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	-
	frame_bury 3 // lastWindowStart: uint64

	// *if1_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:186
	// sub.lastPayment < lastWindowStart
	frame_dig 0 // subKey: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 3 // lastWindowStart: uint64
	<
	bz *if1_end

	// *if1_consequent
	// contracts/arc58/plugins/subscriptions.algo.ts:188
	// this.subscriptions(subKey).value.streak = elseStreak
	intc 9 //  headOffset
	frame_dig -3 // elseStreak: uint64
	itob
	frame_dig 0 // subKey: SubscriptionKey
	cover 2
	box_replace

	// contracts/arc58/plugins/subscriptions.algo.ts:189
	// return;
	retsub

*if1_end:
	// *if2_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:195
	// sub.lastPayment >= lastWindowStart && !(sub.lastPayment >= currentWindowStart)
	frame_dig 0 // subKey: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 3 // lastWindowStart: uint64
	>=
	dup
	bz *skip_and0
	frame_dig 0 // subKey: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 2 // currentWindowStart: uint64
	>=
	!
	&&

*skip_and0:
	bz *if2_end

	// *if2_consequent
	// contracts/arc58/plugins/subscriptions.algo.ts:196
	// this.subscriptions(subKey).value.streak += 1
	intc 9 //  headOffset
	frame_dig 0 // subKey: SubscriptionKey
	intc 9 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	intc 1 // 1
	+
	itob
	frame_dig 0 // subKey: SubscriptionKey
	cover 2
	box_replace

*if2_end:
	retsub

// getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])
*abi_route_getSubsriptionInfo:
	// The ABI return prefix
	bytec 4 // 0x151f7c75

	// index: uint64
	txna ApplicationArgs 2
	btoi

	// user: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 1 (user) for getSubsriptionInfo must be a address
	assert

	// execute getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])
	callsub getSubsriptionInfo
	concat
	log
	intc 1 // 1
	return

// getSubsriptionInfo(user: Address, index: uint64): SubscriptionInfoWithPasses
getSubsriptionInfo:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/arc58/plugins/subscriptions.algo.ts:201
	// key: SubscriptionKey = { user: user, index: index }
	frame_dig -1 // user: Address
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // key: SubscriptionKey

	// contracts/arc58/plugins/subscriptions.algo.ts:203
	// assert(this.subscriptions(key).exists, errs.SUBSCRIPTION_DOES_NOT_EXIST)
	frame_dig 0 // key: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:205
	// subInfo = this.subscriptions(key).value
	frame_dig 0 // key: SubscriptionKey
	frame_bury 1 // storage key//subInfo

	// contracts/arc58/plugins/subscriptions.algo.ts:207
	// passes: Address[] = []
	bytec 0 // 0x
	frame_bury 2 // passes: Address[]

	// *if3_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:208
	// this.passes(key).exists
	bytec 5 //  "p"
	frame_dig 0 // key: SubscriptionKey
	concat
	box_len
	swap
	pop
	bz *if3_end

	// *if3_consequent
	// contracts/arc58/plugins/subscriptions.algo.ts:209
	// passes = this.passes(key).value
	bytec 5 //  "p"
	frame_dig 0 // key: SubscriptionKey
	concat
	box_get

	// box value does not exist: this.passes(key).value
	assert
	extract 2 0
	frame_bury 2 // passes: Address[]

*if3_end:
	// contracts/arc58/plugins/subscriptions.algo.ts:212
	// return {
	//       recipient: subInfo.recipient,
	//       index: subInfo.index,
	//       startDate: subInfo.startDate,
	//       amount: subInfo.amount,
	//       interval: subInfo.interval,
	//       asset: subInfo.asset,
	//       gate: subInfo.gate,
	//       lastPayment: subInfo.lastPayment,
	//       streak: subInfo.streak,
	//       passes: passes,
	//     };
	bytec 0 //  initial head
	bytec 0 //  initial tail
	pushbytes 0x0062 // initial head offset
	frame_dig 0 // key: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 3 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 11 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 7 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 8 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 6 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	pushint 72 // headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 9 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 2 // passes: Address[]
	dup
	len
	intc 3 // 32
	/
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// newService(uint64,bool,uint64,uint64,uint64,uint64,uint64,byte[59])uint64
*abi_route_newService:
	// The ABI return prefix
	bytec 4 // 0x151f7c75

	// cid: byte[59]
	txna ApplicationArgs 8
	dup
	len
	pushint 59
	==

	// argument 0 (cid) for newService must be a byte[59]
	assert

	// gate: uint64
	txna ApplicationArgs 7
	btoi

	// passes: uint64
	txna ApplicationArgs 6
	btoi

	// amount: uint64
	txna ApplicationArgs 5
	btoi

	// asset: uint64
	txna ApplicationArgs 4
	btoi

	// interval: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 6 (rekeyBack) for newService must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute newService(uint64,bool,uint64,uint64,uint64,uint64,uint64,byte[59])uint64
	callsub newService
	itob
	concat
	log
	intc 1 // 1
	return

// newService(sender: AppID, rekeyBack: boolean, interval: uint64, asset: AssetID, amount: uint64, passes: uint64, gate: uint64, cid: bytes<59>): uint64
//
// newService creates a new service for a merchant
// @param sender The address the plugin currently controls
// @param rekeyBack Indicates whether the user wants to rekey back after the transaction
// @param interval The interval in seconds
// @param asset The asa to be used for the subscription
// @param amount The amount of the asa to be used for the subscription
// @param passes The number of accounts the subscription can be shared with
// @param cid The ipfs cid of the subscription contract
// or upgrade the subscription to a different service from the user without losing their streak
newService:
	proto 8 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/arc58/plugins/subscriptions.algo.ts:247
	// index: uint64 = 0
	intc 0 // 0
	frame_bury 0 // index: uint64

	// *if4_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:248
	// this.serviceslist(sender.address).exists
	bytec 3 //  "l"
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	box_len
	swap
	pop
	bz *if4_else

	// *if4_consequent
	// contracts/arc58/plugins/subscriptions.algo.ts:249
	// index = this.serviceslist(sender.address).value
	bytec 3 //  "l"
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	box_get

	// box value does not exist: this.serviceslist(sender.address).value
	assert
	btoi
	frame_bury 0 // index: uint64

	// contracts/arc58/plugins/subscriptions.algo.ts:250
	// this.serviceslist(sender.address).value += 1
	bytec 3 //  "l"
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	box_get

	// box value does not exist: this.serviceslist(sender.address).value
	assert
	btoi
	intc 1 // 1
	+
	bytec 3 //  "l"
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	swap
	itob
	box_put
	b *if4_end

*if4_else:
	// contracts/arc58/plugins/subscriptions.algo.ts:252
	// index = 1
	intc 1 // 1
	frame_bury 0 // index: uint64

	// contracts/arc58/plugins/subscriptions.algo.ts:253
	// this.serviceslist(sender.address).value = 1
	bytec 3 //  "l"
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	bytec 9 // 0x0000000000000001
	box_put

*if4_end:
	// contracts/arc58/plugins/subscriptions.algo.ts:256
	// boxKey: ServicesKey = { user: sender.address, index: index }
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig 0 // index: uint64
	itob
	concat
	frame_bury 1 // boxKey: ServicesKey

	// contracts/arc58/plugins/subscriptions.algo.ts:259
	// assert(amount > 3, errs.MIN_AMOUNT_IS_THREE)
	frame_dig -5 // amount: uint64
	intc 12 // 3
	>
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:261
	// assert(interval >= 60, errs.MIN_INTERVAL_IS_SIXTY)
	frame_dig -3 // interval: uint64
	intc 14 // 60
	>=
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:263
	// assert(passes <= 5, errs.MAX_PASSES_IS_FIVE)
	frame_dig -6 // passes: uint64
	pushint 5
	<=
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:266
	// serviceCreationFee = this.daoAppID.value.globalState(SUBSCRIPTION_SERVICE_CREATION_FEE) as uint64
	bytec 2 //  "dao_app_id"
	app_global_get
	pushbytes "subscription_service_creation_fee"
	app_global_get_ex

	// global state value does not exist: this.daoAppID.value.globalState(SUBSCRIPTION_SERVICE_CREATION_FEE)
	assert
	frame_bury 2 // serviceCreationFee: uint64

	// *if5_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:268
	// asset.id !== 0 && !this.app.address.isOptedInToAsset(asset)
	frame_dig -4 // asset: AssetID
	intc 0 // 0
	!=
	dup
	bz *skip_and1
	global CurrentApplicationAddress
	frame_dig -4 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	&&

*skip_and1:
	bz *if5_else

	// *if5_consequent
	// contracts/arc58/plugins/subscriptions.algo.ts:269
	// this.addPendingOptin(sender, rekeyBack, asset, serviceCreationFee)
	frame_dig 2 // serviceCreationFee: uint64
	frame_dig -4 // asset: AssetID
	frame_dig -2 // rekeyBack: boolean
	frame_dig -1 // sender: AppID
	callsub addPendingOptin

	// contracts/arc58/plugins/subscriptions.algo.ts:270
	// this.pendingGroup.submit()
	itxn_submit
	b *if5_end

*if5_else:
	// contracts/arc58/plugins/subscriptions.algo.ts:272
	// sendPayment({
	//         sender: sender.address,
	//         receiver: globals.currentApplicationAddress,
	//         amount: serviceCreationFee,
	//         rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//         fee: 0,
	//       })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:273
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:274
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscriptions.algo.ts:275
	// amount: serviceCreationFee
	frame_dig 2 // serviceCreationFee: uint64
	itxn_field Amount

	// contracts/arc58/plugins/subscriptions.algo.ts:276
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary1_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary1_end

*ternary1_false:
	global ZeroAddress

*ternary1_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscriptions.algo.ts:277
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if5_end:
	// contracts/arc58/plugins/subscriptions.algo.ts:281
	// this.services(boxKey).value = {
	//       shutdown: false,
	//       active: true,
	//       interval: interval,
	//       asset: asset,
	//       amount: amount,
	//       passes: passes,
	//       gate: gate,
	//       cid: cid,
	//     }
	bytec 1 //  "s"
	frame_dig 1 // boxKey: ServicesKey
	concat
	bytec 6 // 0x00
	intc 0 // 0
	dup
	setbit
	intc 1 // 1
	dup
	setbit
	frame_dig -3 // interval: uint64
	itob
	concat
	frame_dig -4 // asset: AssetID
	itob
	concat
	frame_dig -5 // amount: uint64
	itob
	concat
	frame_dig -6 // passes: uint64
	itob
	concat
	frame_dig -7 // gate: uint64
	itob
	concat
	frame_dig -8 // cid: bytes<59>
	concat
	box_put

	// contracts/arc58/plugins/subscriptions.algo.ts:292
	// return index;
	frame_dig 0 // index: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// pauseService(uint64,bool,uint64)void
*abi_route_pauseService:
	// index: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 1 (rekeyBack) for pauseService must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute pauseService(uint64,bool,uint64)void
	callsub pauseService
	intc 1 // 1
	return

// pauseService(sender: AppID, rekeyBack: boolean, index: uint64): void
//
// pauseService pauses a service for a merchant
// it does not shutdown pre-existing subscriptions
// it simply prevents new subscriptions from being created
// for a specific service
// @param sender The address the plugin currently controls
// @param index The index of the box to be used for the subscription
pauseService:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/arc58/plugins/subscriptions.algo.ts:304
	// boxKey: ServicesKey = { user: sender.address, index: index }
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -3 // index: uint64
	itob
	concat
	frame_bury 0 // boxKey: ServicesKey

	// contracts/arc58/plugins/subscriptions.algo.ts:307
	// assert(this.controls(sender.address), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:310
	// assert(index > 0, errs.SERVICE_INDEX_MUST_BE_ABOVE_ZERO)
	frame_dig -3 // index: uint64
	intc 0 // 0
	>
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:312
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:314
	// assert(!this.services(boxKey).value.shutdown, errs.SERVICE_IS_SHUTDOWN)
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	getbit
	!
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:316
	// this.services(boxKey).value.active = false
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 1 // 1
	intc 0 // 0
	setbit
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_replace

	// *if6_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:318
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if6_end

	// *if6_consequent
	// contracts/arc58/plugins/subscriptions.algo.ts:319
	// this.rekeyBack(sender.address)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub rekeyBack

*if6_end:
	retsub

// activateService(uint64,bool,uint64)void
*abi_route_activateService:
	// index: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 1 (rekeyBack) for activateService must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute activateService(uint64,bool,uint64)void
	callsub activateService
	intc 1 // 1
	return

// activateService(sender: AppID, rekeyBack: boolean, index: uint64): void
//
// activateService activates an service for a merchant
//
// @param sender The address the plugin currently controls
// @param rekeyBack Indicates whether the user wants to rekey back after the transaction
// @param index The index of the box to be used for the subscription
activateService:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/arc58/plugins/subscriptions.algo.ts:331
	// boxKey: ServicesKey = { user: sender.address, index: index }
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -3 // index: uint64
	itob
	concat
	frame_bury 0 // boxKey: ServicesKey

	// contracts/arc58/plugins/subscriptions.algo.ts:334
	// assert(this.controls(sender.address), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:336
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:338
	// assert(!this.services(boxKey).value.shutdown, errs.SERVICE_IS_SHUTDOWN)
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	getbit
	!
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:340
	// this.services(boxKey).value.active = true
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 1 // 1
	dup
	setbit
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_replace

	// *if7_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:342
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if7_end

	// *if7_consequent
	// contracts/arc58/plugins/subscriptions.algo.ts:343
	// this.rekeyBack(sender.address)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub rekeyBack

*if7_end:
	retsub

// shutdownService(uint64,bool,uint64)void
*abi_route_shutdownService:
	// index: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 1 (rekeyBack) for shutdownService must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute shutdownService(uint64,bool,uint64)void
	callsub shutdownService
	intc 1 // 1
	return

// shutdownService(sender: AppID, rekeyBack: boolean, index: uint64): void
//
// shutdownService permanently shuts down an service for a merchant
// it also shutsdown pre-existing subscriptions
// @param sender The address the plugin currently controls
// @param index The index of the box to be used for the subscription
shutdownService:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/arc58/plugins/subscriptions.algo.ts:354
	// boxKey: ServicesKey = { user: sender.address, index: index }
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -3 // index: uint64
	itob
	concat
	frame_bury 0 // boxKey: ServicesKey

	// contracts/arc58/plugins/subscriptions.algo.ts:357
	// assert(this.controls(sender.address), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:359
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:361
	// assert(!this.services(boxKey).value.shutdown, errs.SERVICE_IS_SHUTDOWN)
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	getbit
	!
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:363
	// this.services(boxKey).value.shutdown = true
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	intc 1 // 1
	setbit
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_replace

	// contracts/arc58/plugins/subscriptions.algo.ts:364
	// this.services(boxKey).value.active = false
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 1 // 1
	intc 0 // 0
	setbit
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_replace

	// *if8_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:366
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if8_end

	// *if8_consequent
	// contracts/arc58/plugins/subscriptions.algo.ts:367
	// this.rekeyBack(sender.address)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub rekeyBack

*if8_end:
	retsub

// isShutdown(address,uint64)bool
*abi_route_isShutdown:
	// The ABI return prefix
	bytec 4 // 0x151f7c75

	// boxIndex: uint64
	txna ApplicationArgs 2
	btoi

	// merchant: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 1 (merchant) for isShutdown must be a address
	assert

	// execute isShutdown(address,uint64)bool
	callsub isShutdown
	bytec 6 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	concat
	log
	intc 1 // 1
	return

// isShutdown(merchant: Address, boxIndex: uint64): boolean
//
// serviceIsActive checks if an service is shutdown
isShutdown:
	proto 2 1

	// contracts/arc58/plugins/subscriptions.algo.ts:376
	// return this.services({ user: merchant, index: boxIndex }).value.shutdown;
	bytec 1 //  "s"
	frame_dig -1 // merchant: Address
	frame_dig -2 // boxIndex: uint64
	itob
	concat
	concat
	box_get

	// box value does not exist: this.services({ user: merchant, index: boxIndex }).value
	assert
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	getbit
	retsub

// block(uint64,bool,address)void
*abi_route_block:
	// address: address
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for block must be a address
	assert

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 1 (rekeyBack) for block must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute block(uint64,bool,address)void
	callsub block
	intc 1 // 1
	return

// block(sender: AppID, rekeyBack: boolean, address: Address): void
//
// block blacklists an address for a merchant
// @param sender The address the plugin currently controls
// @param address The address to be blocked
block:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/arc58/plugins/subscriptions.algo.ts:385
	// boxKey: BlockListKey = { user: sender.address, blocked: address }
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -3 // address: Address
	concat
	frame_bury 0 // boxKey: BlockListKey

	// contracts/arc58/plugins/subscriptions.algo.ts:388
	// assert(this.controls(sender.address), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:390
	// assert(!this.blocks(boxKey).exists, errs.USER_ALREADY_BLOCKED)
	frame_dig 0 // boxKey: BlockListKey
	box_len
	swap
	pop
	!
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:393
	// sendPayment({
	//       sender: sender.address,
	//       receiver: globals.currentApplicationAddress,
	//       amount: 28_100,
	//       rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//       fee: 0,
	//     })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:394
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:395
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscriptions.algo.ts:396
	// amount: 28_100
	pushint 28_100
	itxn_field Amount

	// contracts/arc58/plugins/subscriptions.algo.ts:397
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary2_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary2_end

*ternary2_false:
	global ZeroAddress

*ternary2_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscriptions.algo.ts:398
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/arc58/plugins/subscriptions.algo.ts:401
	// this.blocks(boxKey).create(0)
	frame_dig 0 // boxKey: BlockListKey
	intc 0 // 0
	box_create
	pop
	retsub

// unblock(uint64,bool,address)void
*abi_route_unblock:
	// address: address
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for unblock must be a address
	assert

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 1 (rekeyBack) for unblock must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute unblock(uint64,bool,address)void
	callsub unblock
	intc 1 // 1
	return

// unblock(sender: AppID, rekeyBack: boolean, address: Address): void
//
// unblock removes an address from a merchants blocks
// @param address The address to be unblocked
unblock:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/arc58/plugins/subscriptions.algo.ts:409
	// boxKey: BlockListKey = { user: sender.address, blocked: address }
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -3 // address: Address
	concat
	frame_bury 0 // boxKey: BlockListKey

	// contracts/arc58/plugins/subscriptions.algo.ts:412
	// assert(this.controls(sender.address), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:414
	// assert(this.blocks(boxKey).exists, errs.USER_NOT_BLOCKED)
	frame_dig 0 // boxKey: BlockListKey
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:416
	// this.blocks(boxKey).delete()
	frame_dig 0 // boxKey: BlockListKey
	box_del

	// *if9_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:418
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if9_end

	// *if9_consequent
	// contracts/arc58/plugins/subscriptions.algo.ts:419
	// this.rekeyBack(sender.address)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub rekeyBack

*if9_end:
	retsub

// isBlocked(address,address)bool
*abi_route_isBlocked:
	// The ABI return prefix
	bytec 4 // 0x151f7c75

	// address: address
	txna ApplicationArgs 2
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for isBlocked must be a address
	assert

	// merchant: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 1 (merchant) for isBlocked must be a address
	assert

	// execute isBlocked(address,address)bool
	callsub isBlocked
	bytec 6 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	concat
	log
	intc 1 // 1
	return

// isBlocked(merchant: Address, address: Address): boolean
//
// isBlocked checks if an address is blocked for a merchant
// @param merchant The merchant address to be checked
// @param address The address to be checked
isBlocked:
	proto 2 1

	// contracts/arc58/plugins/subscriptions.algo.ts:430
	// return this.blocks({ user: merchant, blocked: address }).exists;
	frame_dig -1 // merchant: Address
	frame_dig -2 // address: Address
	concat
	box_len
	swap
	pop
	retsub

// subscribe(uint64,bool,address,uint64,uint64,uint64,uint64,uint64,byte[][])void
*abi_route_subscribe:
	// args: byte[][]
	txna ApplicationArgs 9

	// gate: uint64
	txna ApplicationArgs 8
	btoi

	// index: uint64
	txna ApplicationArgs 7
	btoi

	// asset: uint64
	txna ApplicationArgs 6
	btoi

	// interval: uint64
	txna ApplicationArgs 5
	btoi

	// amount: uint64
	txna ApplicationArgs 4
	btoi

	// recipient: address
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 32
	==

	// argument 6 (recipient) for subscribe must be a address
	assert

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 7 (rekeyBack) for subscribe must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute subscribe(uint64,bool,address,uint64,uint64,uint64,uint64,uint64,byte[][])void
	callsub subscribe
	intc 1 // 1
	return

// subscribe(sender: AppID, rekeyBack: boolean, recipient: Address, amount: uint64, interval: uint64, asset: AssetID, index: uint64, gate: uint64, args: bytes[]): void
subscribe:
	proto 9 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 12

	// contracts/arc58/plugins/subscriptions.algo.ts:444
	// isDonation = index === 0
	frame_dig -7 // index: uint64
	intc 0 // 0
	==
	frame_bury 0 // isDonation: bool

	// contracts/arc58/plugins/subscriptions.algo.ts:445
	// isAsa = asset.id !== 0
	frame_dig -6 // asset: AssetID
	intc 0 // 0
	!=
	frame_bury 1 // isAsa: bool

	// contracts/arc58/plugins/subscriptions.algo.ts:448
	// assert(this.controls(sender.address), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:450
	// assert(amount > 3, errs.MIN_AMOUNT_IS_THREE)
	frame_dig -4 // amount: uint64
	intc 12 // 3
	>
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:452
	// assert(interval >= 60, errs.MIN_INTERVAL_IS_SIXTY)
	frame_dig -5 // interval: uint64
	intc 14 // 60
	>=
	assert

	// *if10_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:454
	// !isDonation
	frame_dig 0 // isDonation: bool
	!
	bz *if10_end

	// *if10_consequent
	// contracts/arc58/plugins/subscriptions.algo.ts:455
	// boxKey: ServicesKey = { user: recipient, index: index }
	frame_dig -3 // recipient: Address
	frame_dig -7 // index: uint64
	itob
	concat
	frame_bury 2 // boxKey: ServicesKey

	// contracts/arc58/plugins/subscriptions.algo.ts:456
	// blocksKey: BlockListKey = { user: recipient, blocked: sender.address }
	frame_dig -3 // recipient: Address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	frame_bury 3 // blocksKey: BlockListKey

	// contracts/arc58/plugins/subscriptions.algo.ts:459
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	bytec 1 //  "s"
	frame_dig 2 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:461
	// service = this.services(boxKey).value
	bytec 1 //  "s"
	frame_dig 2 // boxKey: ServicesKey
	concat
	frame_bury 4 // storage key//service

	// contracts/arc58/plugins/subscriptions.algo.ts:464
	// assert(!this.blocks(blocksKey).exists, errs.BLOCKED)
	frame_dig 3 // blocksKey: BlockListKey
	box_len
	swap
	pop
	!
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:466
	// assert(!service.shutdown, errs.SERVICE_IS_SHUTDOWN)
	frame_dig 4 // storage key//service
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	getbit
	!
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:468
	// assert(service.active, errs.SERVICE_IS_PAUSED)
	frame_dig 4 // storage key//service
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 1 // 1
	getbit
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:470
	// assert(this.gate(service.gate, args), errs.FAILED_GATE)
	frame_dig -9 // args: bytes[]
	frame_dig 4 // storage key//service
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	extract 33 8
	btoi
	callsub gate
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:472
	// amount = service.amount
	frame_dig 4 // storage key//service
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	extract 17 8
	btoi
	frame_bury -4 // amount: uint64

	// contracts/arc58/plugins/subscriptions.algo.ts:473
	// interval = service.interval
	frame_dig 4 // storage key//service
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	extract 1 8
	btoi
	frame_bury -5 // interval: uint64

	// contracts/arc58/plugins/subscriptions.algo.ts:474
	// gate = service.gate
	frame_dig 4 // storage key//service
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	extract 33 8
	btoi
	frame_bury -8 // gate: uint64

*if10_end:
	// contracts/arc58/plugins/subscriptions.algo.ts:477
	// algoMBRFee: uint64 = 53_700
	pushint 53_700
	frame_bury 5 // algoMBRFee: uint64

	// contracts/arc58/plugins/subscriptions.algo.ts:478
	// subIndex: uint64 = 0
	intc 0 // 0
	frame_bury 6 // subIndex: uint64

	// contracts/arc58/plugins/subscriptions.algo.ts:479
	// subscriptionsListExists: boolean = this.subscriptionslist(sender.address).exists
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	box_len
	swap
	pop
	frame_bury 7 // subscriptionsListExists: boolean

	// *if11_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:480
	// subscriptionsListExists
	frame_dig 7 // subscriptionsListExists: boolean
	bz *if11_else

	// *if11_consequent
	// contracts/arc58/plugins/subscriptions.algo.ts:481
	// subIndex = this.subscriptionslist(sender.address).value
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	box_get

	// box value does not exist: this.subscriptionslist(sender.address).value
	assert
	btoi
	frame_bury 6 // subIndex: uint64

	// contracts/arc58/plugins/subscriptions.algo.ts:482
	// this.subscriptionslist(sender.address).value += 1
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	box_get

	// box value does not exist: this.subscriptionslist(sender.address).value
	assert
	btoi
	intc 1 // 1
	+
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	swap
	itob
	box_put
	b *if11_end

*if11_else:
	// contracts/arc58/plugins/subscriptions.algo.ts:484
	// algoMBRFee += 18_500
	frame_dig 5 // algoMBRFee: uint64
	pushint 18_500
	+
	frame_bury 5 // algoMBRFee: uint64

	// contracts/arc58/plugins/subscriptions.algo.ts:485
	// subIndex = 0
	intc 0 // 0
	frame_bury 6 // subIndex: uint64

	// contracts/arc58/plugins/subscriptions.algo.ts:486
	// this.subscriptionslist(sender.address).value = 0
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	pushbytes 0x0000000000000000
	box_put

*if11_end:
	// contracts/arc58/plugins/subscriptions.algo.ts:489
	// subscriptionKey: SubscriptionKey = { user: sender.address, index: subIndex }
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig 6 // subIndex: uint64
	itob
	concat
	frame_bury 8 // subscriptionKey: SubscriptionKey

	// contracts/arc58/plugins/subscriptions.algo.ts:491
	// this.subscriptions(subscriptionKey).value = {
	//       recipient: recipient,
	//       index: index,
	//       startDate: globals.latestTimestamp,
	//       amount: amount,
	//       interval: interval,
	//       asset: asset,
	//       gate: gate,
	//       lastPayment: globals.latestTimestamp,
	//       streak: 1,
	//     }
	frame_dig 8 // subscriptionKey: SubscriptionKey
	frame_dig -3 // recipient: Address
	frame_dig -7 // index: uint64
	itob
	concat
	global LatestTimestamp
	itob
	concat
	frame_dig -4 // amount: uint64
	itob
	concat
	frame_dig -5 // interval: uint64
	itob
	concat
	frame_dig -6 // asset: AssetID
	itob
	concat
	frame_dig -8 // gate: uint64
	itob
	concat
	global LatestTimestamp
	itob
	concat
	bytec 9 // 0x0000000000000001
	concat
	box_put

	// contracts/arc58/plugins/subscriptions.algo.ts:505
	// akitaPercentage = this.daoAppID.value.globalState(SUBSCRIPTION_PAYMENT_PERCENTAGE_KEY) as uint64
	bytec 2 //  "dao_app_id"
	app_global_get
	bytec 7 // "subscription_payment_percentage"
	app_global_get_ex

	// global state value does not exist: this.daoAppID.value.globalState(SUBSCRIPTION_PAYMENT_PERCENTAGE_KEY)
	assert
	frame_bury 9 // akitaPercentage: uint64

	// contracts/arc58/plugins/subscriptions.algo.ts:506
	// triggerPercentage = this.daoAppID.value.globalState(SUBSCRIPTION_TRIGGER_PERCENTAGE_KEY) as uint64
	bytec 2 //  "dao_app_id"
	app_global_get
	bytec 8 // "subscription_trigger_percentage"
	app_global_get_ex

	// global state value does not exist: this.daoAppID.value.globalState(SUBSCRIPTION_TRIGGER_PERCENTAGE_KEY)
	assert
	frame_bury 10 // triggerPercentage: uint64

	// contracts/arc58/plugins/subscriptions.algo.ts:507
	// initialFee = (amount * (akitaPercentage + triggerPercentage) - 1) / 1000 + 1
	frame_dig -4 // amount: uint64
	frame_dig 9 // akitaPercentage: uint64
	frame_dig 10 // triggerPercentage: uint64
	+
	*
	intc 1 // 1
	-
	intc 10 // 1000
	/
	intc 1 // 1
	+
	frame_bury 11 // initialFee: uint64

	// contracts/arc58/plugins/subscriptions.algo.ts:508
	// leftOver = amount - initialFee
	frame_dig -4 // amount: uint64
	frame_dig 11 // initialFee: uint64
	-
	frame_bury 12 // leftOver: uint64

	// *if12_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:510
	// isAsa
	frame_dig 1 // isAsa: bool
	bz *if12_else

	// *if12_consequent
	// *if13_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:511
	// !this.app.address.isOptedInToAsset(asset)
	global CurrentApplicationAddress
	frame_dig -6 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if13_else

	// *if13_consequent
	// contracts/arc58/plugins/subscriptions.algo.ts:513
	// this.addPendingOptin(sender, false, asset, algoMBRFee)
	frame_dig 5 // algoMBRFee: uint64
	frame_dig -6 // asset: AssetID
	intc 0 // 0
	frame_dig -1 // sender: AppID
	callsub addPendingOptin
	b *if13_end

*if13_else:
	// contracts/arc58/plugins/subscriptions.algo.ts:516
	// this.pendingGroup.addPayment({
	//           sender: sender.address,
	//           receiver: globals.currentApplicationAddress,
	//           amount: algoMBRFee,
	//           fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:517
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:518
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscriptions.algo.ts:519
	// amount: algoMBRFee
	frame_dig 5 // algoMBRFee: uint64
	itxn_field Amount

	// contracts/arc58/plugins/subscriptions.algo.ts:520
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if13_end:
	// contracts/arc58/plugins/subscriptions.algo.ts:524
	// this.pendingGroup.addAssetTransfer({
	//         sender: sender.address,
	//         assetReceiver: globals.currentApplicationAddress,
	//         xferAsset: asset,
	//         assetAmount: initialFee,
	//         fee: 0,
	//       })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:525
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:526
	// assetReceiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscriptions.algo.ts:527
	// xferAsset: asset
	frame_dig -6 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/subscriptions.algo.ts:528
	// assetAmount: initialFee
	frame_dig 11 // initialFee: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscriptions.algo.ts:529
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/subscriptions.algo.ts:532
	// this.pendingGroup.addAssetTransfer({
	//         sender: sender.address,
	//         assetReceiver: recipient,
	//         xferAsset: asset,
	//         assetAmount: leftOver,
	//         rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//         fee: 0,
	//       })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:533
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:534
	// assetReceiver: recipient
	frame_dig -3 // recipient: Address
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscriptions.algo.ts:535
	// xferAsset: asset
	frame_dig -6 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/subscriptions.algo.ts:536
	// assetAmount: leftOver
	frame_dig 12 // leftOver: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscriptions.algo.ts:537
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary3_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary3_end

*ternary3_false:
	global ZeroAddress

*ternary3_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscriptions.algo.ts:538
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	b *if12_end

*if12_else:
	// contracts/arc58/plugins/subscriptions.algo.ts:542
	// this.pendingGroup.addPayment({
	//         sender: sender.address,
	//         receiver: globals.currentApplicationAddress,
	//         amount: (algoMBRFee + initialFee),
	//         fee: 0,
	//       })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:543
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:544
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscriptions.algo.ts:545
	// amount: (algoMBRFee + initialFee)
	frame_dig 5 // algoMBRFee: uint64
	frame_dig 11 // initialFee: uint64
	+
	itxn_field Amount

	// contracts/arc58/plugins/subscriptions.algo.ts:546
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/subscriptions.algo.ts:549
	// this.pendingGroup.addPayment({
	//         sender: sender.address,
	//         receiver: recipient,
	//         amount: leftOver,
	//         rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//         fee: 0,
	//       })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:550
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:551
	// receiver: recipient
	frame_dig -3 // recipient: Address
	itxn_field Receiver

	// contracts/arc58/plugins/subscriptions.algo.ts:552
	// amount: leftOver
	frame_dig 12 // leftOver: uint64
	itxn_field Amount

	// contracts/arc58/plugins/subscriptions.algo.ts:553
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary4_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary4_end

*ternary4_false:
	global ZeroAddress

*ternary4_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscriptions.algo.ts:554
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if12_end:
	// contracts/arc58/plugins/subscriptions.algo.ts:558
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// triggerPayment(uint64,bool,uint64,byte[][])void
*abi_route_triggerPayment:
	// args: byte[][]
	txna ApplicationArgs 4

	// index: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 2 (rekeyBack) for triggerPayment must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute triggerPayment(uint64,bool,uint64,byte[][])void
	callsub triggerPayment
	intc 1 // 1
	return

// triggerPayment(sender: AppID, rekeyBack: boolean, index: uint64, args: bytes[]): void
triggerPayment:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 9

	// contracts/arc58/plugins/subscriptions.algo.ts:562
	// subscriptionsKey: SubscriptionKey = { user: sender.address, index: index }
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -3 // index: uint64
	itob
	concat
	frame_bury 0 // subscriptionsKey: SubscriptionKey

	// contracts/arc58/plugins/subscriptions.algo.ts:565
	// assert(this.subscriptions(subscriptionsKey).exists)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:567
	// sub = this.subscriptions(subscriptionsKey).value
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/arc58/plugins/subscriptions.algo.ts:569
	// blocksKey: BlockListKey = { user: sub.recipient, blocked: sender.address }
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	frame_bury 2 // blocksKey: BlockListKey

	// contracts/arc58/plugins/subscriptions.algo.ts:572
	// assert(!this.blocks(blocksKey).exists, errs.BLOCKED)
	frame_dig 2 // blocksKey: BlockListKey
	box_len
	swap
	pop
	!
	assert

	// *if14_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:574
	// index > 0
	frame_dig -3 // index: uint64
	intc 0 // 0
	>
	bz *if14_end

	// *if14_consequent
	// contracts/arc58/plugins/subscriptions.algo.ts:575
	// servicesKey: ServicesKey = { user: sub.recipient, index: sub.index }
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 3 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	concat
	frame_bury 3 // servicesKey: ServicesKey

	// contracts/arc58/plugins/subscriptions.algo.ts:577
	// assert(!this.services(servicesKey).value.shutdown, errs.SERVICE_IS_PAUSED)
	bytec 1 //  "s"
	frame_dig 3 // servicesKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(servicesKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	getbit
	!
	assert

*if14_end:
	// contracts/arc58/plugins/subscriptions.algo.ts:581
	// assert(sub.lastPayment < this.getLatestWindowStart(sub.startDate, sub.interval), errs.BAD_WINDOW)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 8 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 11 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	callsub getLatestWindowStart
	<
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:583
	// isAsa = sub.asset.id !== 0
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 6 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	intc 0 // 0
	!=
	frame_bury 4 // isAsa: bool

	// contracts/arc58/plugins/subscriptions.algo.ts:585
	// akitaPercentage = this.daoAppID.value.globalState(SUBSCRIPTION_PAYMENT_PERCENTAGE_KEY) as uint64
	bytec 2 //  "dao_app_id"
	app_global_get
	bytec 7 // "subscription_payment_percentage"
	app_global_get_ex

	// global state value does not exist: this.daoAppID.value.globalState(SUBSCRIPTION_PAYMENT_PERCENTAGE_KEY)
	assert
	frame_bury 5 // akitaPercentage: uint64

	// contracts/arc58/plugins/subscriptions.algo.ts:586
	// akitaFee = (sub.amount * akitaPercentage - 1) / 1000 + 1
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 7 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 5 // akitaPercentage: uint64
	*
	intc 1 // 1
	-
	intc 10 // 1000
	/
	intc 1 // 1
	+
	frame_bury 6 // akitaFee: uint64

	// contracts/arc58/plugins/subscriptions.algo.ts:587
	// triggerPercentage = this.daoAppID.value.globalState(SUBSCRIPTION_TRIGGER_PERCENTAGE_KEY) as uint64
	bytec 2 //  "dao_app_id"
	app_global_get
	bytec 8 // "subscription_trigger_percentage"
	app_global_get_ex

	// global state value does not exist: this.daoAppID.value.globalState(SUBSCRIPTION_TRIGGER_PERCENTAGE_KEY)
	assert
	frame_bury 7 // triggerPercentage: uint64

	// contracts/arc58/plugins/subscriptions.algo.ts:588
	// triggerFee = (sub.amount * triggerPercentage - 1) / 1000 + 1
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 7 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 7 // triggerPercentage: uint64
	*
	intc 1 // 1
	-
	intc 10 // 1000
	/
	intc 1 // 1
	+
	frame_bury 8 // triggerFee: uint64

	// contracts/arc58/plugins/subscriptions.algo.ts:589
	// leftOver = sub.amount - (akitaFee + triggerFee)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 7 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 6 // akitaFee: uint64
	frame_dig 8 // triggerFee: uint64
	+
	-
	frame_bury 9 // leftOver: uint64

	// *if15_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:591
	// isAsa
	frame_dig 4 // isAsa: bool
	bz *if15_else

	// *if15_consequent
	// contracts/arc58/plugins/subscriptions.algo.ts:592
	// this.pendingGroup.addAssetTransfer({
	//         sender: sender.address,
	//         assetReceiver: globals.currentApplicationAddress,
	//         xferAsset: sub.asset,
	//         assetAmount: akitaFee,
	//         fee: 0,
	//       })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:593
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:594
	// assetReceiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscriptions.algo.ts:595
	// xferAsset: sub.asset
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 6 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/arc58/plugins/subscriptions.algo.ts:596
	// assetAmount: akitaFee
	frame_dig 6 // akitaFee: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscriptions.algo.ts:597
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/subscriptions.algo.ts:600
	// this.pendingGroup.addAssetTransfer({
	//         sender: sender.address,
	//         assetReceiver: this.txn.sender,
	//         xferAsset: sub.asset,
	//         assetAmount: triggerFee,
	//         fee: 0,
	//       })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:601
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:602
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscriptions.algo.ts:603
	// xferAsset: sub.asset
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 6 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/arc58/plugins/subscriptions.algo.ts:604
	// assetAmount: triggerFee
	frame_dig 8 // triggerFee: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscriptions.algo.ts:605
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/subscriptions.algo.ts:608
	// this.pendingGroup.addAssetTransfer({
	//         sender: sender.address,
	//         assetReceiver: sub.recipient,
	//         xferAsset: sub.asset,
	//         assetAmount: leftOver,
	//         rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//         fee: 0,
	//       })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:609
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:610
	// assetReceiver: sub.recipient
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscriptions.algo.ts:611
	// xferAsset: sub.asset
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 6 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/arc58/plugins/subscriptions.algo.ts:612
	// assetAmount: leftOver
	frame_dig 9 // leftOver: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscriptions.algo.ts:613
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary5_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary5_end

*ternary5_false:
	global ZeroAddress

*ternary5_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscriptions.algo.ts:614
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	b *if15_end

*if15_else:
	// contracts/arc58/plugins/subscriptions.algo.ts:619
	// this.pendingGroup.addPayment({
	//         sender: sender.address,
	//         receiver: globals.currentApplicationAddress,
	//         amount: akitaFee,
	//         fee: 0,
	//       })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:620
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:621
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscriptions.algo.ts:622
	// amount: akitaFee
	frame_dig 6 // akitaFee: uint64
	itxn_field Amount

	// contracts/arc58/plugins/subscriptions.algo.ts:623
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/subscriptions.algo.ts:626
	// this.pendingGroup.addPayment({
	//         sender: sender.address,
	//         receiver: this.txn.sender,
	//         amount: triggerFee,
	//         fee: 0,
	//       })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:627
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:628
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/arc58/plugins/subscriptions.algo.ts:629
	// amount: triggerFee
	frame_dig 8 // triggerFee: uint64
	itxn_field Amount

	// contracts/arc58/plugins/subscriptions.algo.ts:630
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/subscriptions.algo.ts:633
	// this.pendingGroup.addPayment({
	//         sender: sender.address,
	//         receiver: sub.recipient,
	//         amount: leftOver,
	//         rekeyTo: rekeyBack ? sender.address : Address.zeroAddress,
	//         fee: 0,
	//       })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscriptions.algo.ts:634
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscriptions.algo.ts:635
	// receiver: sub.recipient
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	itxn_field Receiver

	// contracts/arc58/plugins/subscriptions.algo.ts:636
	// amount: leftOver
	frame_dig 9 // leftOver: uint64
	itxn_field Amount

	// contracts/arc58/plugins/subscriptions.algo.ts:637
	// rekeyTo: rekeyBack ? sender.address : Address.zeroAddress
	frame_dig -2 // rekeyBack: boolean
	bz *ternary6_false
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	b *ternary6_end

*ternary6_false:
	global ZeroAddress

*ternary6_end:
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscriptions.algo.ts:638
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if15_end:
	// contracts/arc58/plugins/subscriptions.algo.ts:642
	// this.pendingGroup.submit()
	itxn_submit

	// contracts/arc58/plugins/subscriptions.algo.ts:643
	// this.updateStreak(sender.address, index, 1)
	intc 1 // 1
	frame_dig -3 // index: uint64
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub updateStreak

	// contracts/arc58/plugins/subscriptions.algo.ts:644
	// this.subscriptions(subscriptionsKey).value.lastPayment = globals.latestTimestamp
	intc 5 //  headOffset
	global LatestTimestamp
	itob
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	cover 2
	box_replace
	retsub

// streakCheck(address,uint64)void
*abi_route_streakCheck:
	// index: uint64
	txna ApplicationArgs 2
	btoi

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 1 (sender) for streakCheck must be a address
	assert

	// execute streakCheck(address,uint64)void
	callsub streakCheck
	intc 1 // 1
	return

// streakCheck(sender: Address, index: uint64): void
streakCheck:
	proto 2 0

	// contracts/arc58/plugins/subscriptions.algo.ts:648
	// this.updateStreak(sender, index, 0)
	intc 0 // 0
	frame_dig -2 // index: uint64
	frame_dig -1 // sender: Address
	callsub updateStreak
	retsub

// setPasses(uint64,bool,uint64,address[])void
*abi_route_setPasses:
	// addresses: address[]
	txna ApplicationArgs 4
	extract 2 0

	// index: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 2 (rekeyBack) for setPasses must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute setPasses(uint64,bool,uint64,address[])void
	callsub setPasses
	intc 1 // 1
	return

// setPasses(sender: AppID, rekeyBack: boolean, index: uint64, addresses: Address[]): void
setPasses:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// contracts/arc58/plugins/subscriptions.algo.ts:652
	// assert(index > 0, errs.NO_DONATIONS)
	frame_dig -3 // index: uint64
	intc 0 // 0
	>
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:653
	// subscriptionsKey: SubscriptionKey = { user: sender.address, index: index }
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -3 // index: uint64
	itob
	concat
	frame_bury 0 // subscriptionsKey: SubscriptionKey

	// contracts/arc58/plugins/subscriptions.algo.ts:655
	// assert(this.subscriptions(subscriptionsKey).exists, errs.SUBSCRIPTION_DOES_NOT_EXIST)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:657
	// sub = this.subscriptions(subscriptionsKey).value
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/arc58/plugins/subscriptions.algo.ts:659
	// serviceKey: ServicesKey = { user: sub.recipient, index: index }
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	frame_dig -3 // index: uint64
	itob
	concat
	frame_bury 2 // serviceKey: ServicesKey

	// contracts/arc58/plugins/subscriptions.algo.ts:660
	// service = this.services(serviceKey).value
	bytec 1 //  "s"
	frame_dig 2 // serviceKey: ServicesKey
	concat
	frame_bury 3 // storage key//service

	// contracts/arc58/plugins/subscriptions.algo.ts:662
	// assert(service.active, errs.SERVICE_IS_PAUSED)
	frame_dig 3 // storage key//service
	box_get

	// box value does not exist: this.services(serviceKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 1 // 1
	getbit
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:663
	// assert(!service.shutdown, errs.SERVICE_IS_SHUTDOWN)
	frame_dig 3 // storage key//service
	box_get

	// box value does not exist: this.services(serviceKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	getbit
	!
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:664
	// assert(service.passes >= addresses.length, errs.PASS_COUNT_OVERFLOW)
	frame_dig 3 // storage key//service
	box_get

	// box value does not exist: this.services(serviceKey).value
	assert
	store 255 // full array
	load 255 // full array
	extract 25 8
	btoi
	frame_dig -4 // addresses: Address[]
	len
	intc 3 // 32
	/
	>=
	assert

	// contracts/arc58/plugins/subscriptions.algo.ts:666
	// for (let i = 0; i < addresses.length; i += 1)
	intc 0 // 0
	frame_bury 4 // i: uint64

*for_0:
	// contracts/arc58/plugins/subscriptions.algo.ts:666
	// i < addresses.length
	frame_dig 4 // i: uint64
	frame_dig -4 // addresses: Address[]
	len
	intc 3 // 32
	/
	<
	bz *for_0_end

	// contracts/arc58/plugins/subscriptions.algo.ts:667
	// assert(!this.blocks({ user: sub.recipient, blocked: addresses[i] }).exists, errs.BLOCKED)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	frame_dig -4 // addresses: Address[]
	store 255 // full array
	intc 0 //  initial offset
	frame_dig 4 // i: uint64
	intc 3 // 32
	* // acc * typeLength
	+
	load 255 // full array
	swap
	intc 3 // 32
	extract3
	concat
	box_len
	swap
	pop
	!
	assert

*for_0_continue:
	// contracts/arc58/plugins/subscriptions.algo.ts:666
	// i += 1
	frame_dig 4 // i: uint64
	intc 1 // 1
	+
	frame_bury 4 // i: uint64
	b *for_0

*for_0_end:
	// contracts/arc58/plugins/subscriptions.algo.ts:670
	// this.passes(subscriptionsKey).value = addresses
	bytec 5 //  "p"
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	concat
	dup
	box_del
	pop
	frame_dig -4 // addresses: Address[]
	dup
	len
	intc 3 // 32
	/
	itob
	extract 6 2
	swap
	concat
	box_put

	// *if16_condition
	// contracts/arc58/plugins/subscriptions.algo.ts:672
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if16_end

	// *if16_consequent
	// contracts/arc58/plugins/subscriptions.algo.ts:673
	// this.rekeyBack(sender.address)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub rekeyBack

*if16_end:
	retsub

*abi_route_createApplication:
	intc 1 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x3362f0b0 // method "getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])"
	pushbytes 0xbe1ef1b8 // method "newService(uint64,bool,uint64,uint64,uint64,uint64,uint64,byte[59])uint64"
	pushbytes 0x39a3ae47 // method "pauseService(uint64,bool,uint64)void"
	pushbytes 0x7c88de8f // method "activateService(uint64,bool,uint64)void"
	pushbytes 0x19b1fc2b // method "shutdownService(uint64,bool,uint64)void"
	pushbytes 0x0d6a47a3 // method "isShutdown(address,uint64)bool"
	pushbytes 0xbec86c34 // method "block(uint64,bool,address)void"
	pushbytes 0x9f59a970 // method "unblock(uint64,bool,address)void"
	pushbytes 0x4303668e // method "isBlocked(address,address)bool"
	pushbytes 0x44e36da6 // method "subscribe(uint64,bool,address,uint64,uint64,uint64,uint64,uint64,byte[][])void"
	pushbytes 0x8471855c // method "triggerPayment(uint64,bool,uint64,byte[][])void"
	pushbytes 0xadb2c60e // method "streakCheck(address,uint64)void"
	pushbytes 0x1c42461b // method "setPasses(uint64,bool,uint64,address[])void"
	txna ApplicationArgs 0
	match *abi_route_getSubsriptionInfo *abi_route_newService *abi_route_pauseService *abi_route_activateService *abi_route_shutdownService *abi_route_isShutdown *abi_route_block *abi_route_unblock *abi_route_isBlocked *abi_route_subscribe *abi_route_triggerPayment *abi_route_streakCheck *abi_route_setPasses

	// this contract does not implement the given ABI method for call NoOp
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub