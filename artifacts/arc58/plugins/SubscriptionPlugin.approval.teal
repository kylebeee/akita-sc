#pragma version 10
intcblock 0 1 8 32 4 64 80 40 48 56 88 5000000 1000 28_100 3 5 6 60
bytecblock 0x 0x73 0x6c 0x151f7c75 0x70 0x00 0x0000000000000001

// This TEAL was generated by TEALScript v0.106.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 16 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// controls(address: Address): boolean
controls:
	proto 1 1

	// contracts/arc58/plugins/subscription.algo.ts:130
	// return address.authAddr === this.app.address;
	frame_dig -1 // address: Address
	acct_params_get AcctAuthAddr
	pop
	global CurrentApplicationAddress
	==
	retsub

// rekeyBack(address: Address): void
rekeyBack:
	proto 1 0

	// contracts/arc58/plugins/subscription.algo.ts:134
	// sendPayment({
	//       sender: address,
	//       amount: 0,
	//       receiver: address,
	//       rekeyTo: address,
	//       fee: 0,
	//     })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:135
	// sender: address
	frame_dig -1 // address: Address
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:136
	// amount: 0
	intc 0 // 0
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:137
	// receiver: address
	frame_dig -1 // address: Address
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:138
	// rekeyTo: address
	frame_dig -1 // address: Address
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscription.algo.ts:139
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// gate(index: uint64, args: bytes[]): boolean
gate:
	proto 2 1

	// *if0_condition
	// contracts/arc58/plugins/subscription.algo.ts:144
	// index === 0
	frame_dig -1 // index: uint64
	intc 0 // 0
	==
	bz *if0_end

	// *if0_consequent
	// contracts/arc58/plugins/subscription.algo.ts:145
	// return true;
	intc 1 // 1
	retsub

*if0_end:
	// contracts/arc58/plugins/subscription.algo.ts:148
	// return sendMethodCall<typeof Gate.prototype.check, boolean>({
	//       applicationID: AppID.fromUint64(AkitaAppIDsGate),
	//       methodArgs: [
	//         index,
	//         args,
	//       ],
	//       fee: 0
	//     });
	itxn_begin
	intc 16 //  appl
	itxn_field TypeEnum
	pushbytes 0xb5feb87b // method "check(uint64,byte[][])bool"
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscription.algo.ts:149
	// applicationID: AppID.fromUint64(AkitaAppIDsGate)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/arc58/plugins/subscription.algo.ts:150
	// methodArgs: [
	//         index,
	//         args,
	//       ]
	frame_dig -1 // index: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -2 // args: bytes[]
	itxn_field ApplicationArgs

	// contracts/arc58/plugins/subscription.algo.ts:154
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	retsub

// addPendingOptin(sender: AppID, rekeyBack: boolean, asset: AssetID, amount: uint64): void
addPendingOptin:
	proto 4 0

	// contracts/arc58/plugins/subscription.algo.ts:159
	// this.pendingGroup.addAssetTransfer({
	//       sender: globals.currentApplicationAddress,
	//       assetReceiver: globals.currentApplicationAddress,
	//       assetAmount: 0,
	//       xferAsset: asset,
	//       fee: 0,
	//     })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:160
	// sender: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:161
	// assetReceiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscription.algo.ts:162
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscription.algo.ts:163
	// xferAsset: asset
	frame_dig -3 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/subscription.algo.ts:164
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// *if1_condition
	// contracts/arc58/plugins/subscription.algo.ts:167
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if1_else

	// *if1_consequent
	// contracts/arc58/plugins/subscription.algo.ts:168
	// this.pendingGroup.addPayment({
	//         sender: sender.address,
	//         receiver: globals.currentApplicationAddress,
	//         amount: (globals.assetOptInMinBalance + amount),
	//         rekeyTo: sender.address,
	//         fee: 0,
	//       })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:169
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:170
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:171
	// amount: (globals.assetOptInMinBalance + amount)
	global AssetOptInMinBalance
	frame_dig -4 // amount: uint64
	+
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:172
	// rekeyTo: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscription.algo.ts:173
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	b *if1_end

*if1_else:
	// contracts/arc58/plugins/subscription.algo.ts:176
	// this.pendingGroup.addPayment({
	//         sender: sender.address,
	//         receiver: globals.currentApplicationAddress,
	//         amount: (globals.assetOptInMinBalance + amount),
	//         fee: 0,
	//       })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:177
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:178
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:179
	// amount: (globals.assetOptInMinBalance + amount)
	global AssetOptInMinBalance
	frame_dig -4 // amount: uint64
	+
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:180
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if1_end:
	retsub

// getLatestWindowStart(startDate: uint64, interval: uint64): uint64
getLatestWindowStart:
	proto 2 1

	// contracts/arc58/plugins/subscription.algo.ts:186
	// return globals.latestTimestamp - ((globals.latestTimestamp - startDate) % interval);
	global LatestTimestamp
	global LatestTimestamp
	frame_dig -1 // startDate: uint64
	-
	frame_dig -2 // interval: uint64
	%
	-
	retsub

// updateStreak(sender: Address, index: uint64, elseStreak: uint64): void
updateStreak:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts/arc58/plugins/subscription.algo.ts:190
	// subKey: SubscriptionKey = { user: sender, index: index }
	frame_dig -1 // sender: Address
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // subKey: SubscriptionKey

	// contracts/arc58/plugins/subscription.algo.ts:191
	// sub = this.subscriptions(subKey).value
	frame_dig 0 // subKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/arc58/plugins/subscription.algo.ts:193
	// currentWindowStart = this.getLatestWindowStart(sub.startDate, sub.interval)
	frame_dig 0 // subKey: SubscriptionKey
	intc 9 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 0 // subKey: SubscriptionKey
	intc 7 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	callsub getLatestWindowStart
	frame_bury 2 // currentWindowStart: uint64

	// contracts/arc58/plugins/subscription.algo.ts:194
	// lastWindowStart = (currentWindowStart - sub.interval)
	frame_dig 2 // currentWindowStart: uint64
	frame_dig 0 // subKey: SubscriptionKey
	intc 9 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	-
	frame_bury 3 // lastWindowStart: uint64

	// *if2_condition
	// contracts/arc58/plugins/subscription.algo.ts:196
	// sub.lastPayment < lastWindowStart
	frame_dig 0 // subKey: SubscriptionKey
	intc 6 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 3 // lastWindowStart: uint64
	<
	bz *if2_end

	// *if2_consequent
	// contracts/arc58/plugins/subscription.algo.ts:198
	// this.subscriptions(subKey).value.streak = elseStreak
	intc 10 //  headOffset
	frame_dig -3 // elseStreak: uint64
	itob
	frame_dig 0 // subKey: SubscriptionKey
	cover 2
	box_replace

	// contracts/arc58/plugins/subscription.algo.ts:199
	// return;
	retsub

*if2_end:
	// *if3_condition
	// contracts/arc58/plugins/subscription.algo.ts:205
	// sub.lastPayment >= lastWindowStart && !(sub.lastPayment >= currentWindowStart)
	frame_dig 0 // subKey: SubscriptionKey
	intc 6 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 3 // lastWindowStart: uint64
	>=
	dup
	bz *skip_and0
	frame_dig 0 // subKey: SubscriptionKey
	intc 6 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 2 // currentWindowStart: uint64
	>=
	!
	&&

*skip_and0:
	bz *if3_end

	// *if3_consequent
	// contracts/arc58/plugins/subscription.algo.ts:206
	// this.subscriptions(subKey).value.streak += 1
	intc 10 //  headOffset
	frame_dig 0 // subKey: SubscriptionKey
	intc 10 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	intc 1 // 1
	+
	itob
	frame_dig 0 // subKey: SubscriptionKey
	cover 2
	box_replace

*if3_end:
	retsub

// getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])
*abi_route_getSubsriptionInfo:
	// The ABI return prefix
	bytec 3 // 0x151f7c75

	// index: uint64
	txna ApplicationArgs 2
	btoi

	// user: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 1 (user) for getSubsriptionInfo must be a address
	assert

	// execute getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])
	callsub getSubsriptionInfo
	concat
	log
	intc 1 // 1
	return

// getSubsriptionInfo(user: Address, index: uint64): SubscriptionInfoWithPasses
getSubsriptionInfo:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/arc58/plugins/subscription.algo.ts:211
	// key: SubscriptionKey = { user: user, index: index }
	frame_dig -1 // user: Address
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // key: SubscriptionKey

	// contracts/arc58/plugins/subscription.algo.ts:213
	// assert(this.subscriptions(key).exists, errs.SUBSCRIPTION_DOES_NOT_EXIST)
	frame_dig 0 // key: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscription.algo.ts:215
	// subInfo = this.subscriptions(key).value
	frame_dig 0 // key: SubscriptionKey
	frame_bury 1 // storage key//subInfo

	// contracts/arc58/plugins/subscription.algo.ts:217
	// passes: Address[] = []
	bytec 0 // 0x
	frame_bury 2 // passes: Address[]

	// *if4_condition
	// contracts/arc58/plugins/subscription.algo.ts:218
	// this.passes(key).exists
	bytec 4 //  "p"
	frame_dig 0 // key: SubscriptionKey
	concat
	box_len
	swap
	pop
	bz *if4_end

	// *if4_consequent
	// contracts/arc58/plugins/subscription.algo.ts:219
	// passes = this.passes(key).value
	bytec 4 //  "p"
	frame_dig 0 // key: SubscriptionKey
	concat
	box_get

	// box value does not exist: this.passes(key).value
	assert
	extract 2 0
	frame_bury 2 // passes: Address[]

*if4_end:
	// contracts/arc58/plugins/subscription.algo.ts:222
	// return {
	//       recipient: subInfo.recipient,
	//       index: subInfo.index,
	//       startDate: subInfo.startDate,
	//       amount: subInfo.amount,
	//       interval: subInfo.interval,
	//       asset: subInfo.asset,
	//       gate: subInfo.gate,
	//       lastPayment: subInfo.lastPayment,
	//       streak: subInfo.streak,
	//       passes: passes,
	//     };
	bytec 0 //  initial head
	bytec 0 //  initial tail
	pushbytes 0x0062 // initial head offset
	frame_dig 0 // key: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 3 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 7 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 8 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 9 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	pushint 72 // headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 6 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 10 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 2 // passes: Address[]
	dup
	len
	intc 3 // 32
	/
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// newService(uint64,bool,uint64,uint64,uint64,uint64,uint64,byte[59])uint64
*abi_route_newService:
	// The ABI return prefix
	bytec 3 // 0x151f7c75

	// cid: byte[59]
	txna ApplicationArgs 8
	dup
	len
	pushint 59
	==

	// argument 0 (cid) for newService must be a byte[59]
	assert

	// gate: uint64
	txna ApplicationArgs 7
	btoi

	// passes: uint64
	txna ApplicationArgs 6
	btoi

	// amount: uint64
	txna ApplicationArgs 5
	btoi

	// asset: uint64
	txna ApplicationArgs 4
	btoi

	// interval: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 6 (rekeyBack) for newService must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute newService(uint64,bool,uint64,uint64,uint64,uint64,uint64,byte[59])uint64
	callsub newService
	itob
	concat
	log
	intc 1 // 1
	return

// newService(sender: AppID, rekeyBack: boolean, interval: uint64, asset: AssetID, amount: uint64, passes: uint64, gate: uint64, cid: bytes59): uint64
//
// newService creates a new service for a merchant
// @param sender The address the plugin currently controls
// @param rekeyBack Indicates whether the user wants to rekey back after the transaction
// @param interval The interval in seconds
// @param asset The asa to be used for the subscription
// @param amount The amount of the asa to be used for the subscription
// @param passes The number of accounts the subscription can be shared with
// @param cid The ipfs cid of the subscription contract
// or upgrade the subscription to a different service from the user without losing their streak
newService:
	proto 8 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/arc58/plugins/subscription.algo.ts:257
	// index: uint64 = 0
	intc 0 // 0
	frame_bury 0 // index: uint64

	// *if5_condition
	// contracts/arc58/plugins/subscription.algo.ts:258
	// this.serviceslist(sender.address).exists
	bytec 2 //  "l"
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	box_len
	swap
	pop
	bz *if5_else

	// *if5_consequent
	// contracts/arc58/plugins/subscription.algo.ts:259
	// index = this.serviceslist(sender.address).value
	bytec 2 //  "l"
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	box_get

	// box value does not exist: this.serviceslist(sender.address).value
	assert
	btoi
	frame_bury 0 // index: uint64

	// contracts/arc58/plugins/subscription.algo.ts:260
	// this.serviceslist(sender.address).value += 1
	bytec 2 //  "l"
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	box_get

	// box value does not exist: this.serviceslist(sender.address).value
	assert
	btoi
	intc 1 // 1
	+
	bytec 2 //  "l"
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	swap
	itob
	box_put
	b *if5_end

*if5_else:
	// contracts/arc58/plugins/subscription.algo.ts:262
	// index = 1
	intc 1 // 1
	frame_bury 0 // index: uint64

	// contracts/arc58/plugins/subscription.algo.ts:263
	// this.serviceslist(sender.address).value = 1
	bytec 2 //  "l"
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	bytec 6 // 0x0000000000000001
	box_put

*if5_end:
	// contracts/arc58/plugins/subscription.algo.ts:266
	// boxKey: ServicesKey = { user: sender.address, index: index }
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig 0 // index: uint64
	itob
	concat
	frame_bury 1 // boxKey: ServicesKey

	// contracts/arc58/plugins/subscription.algo.ts:269
	// assert(amount > 3, errs.MIN_AMOUNT_IS_THREE)
	frame_dig -5 // amount: uint64
	intc 14 // 3
	>
	assert

	// contracts/arc58/plugins/subscription.algo.ts:271
	// assert(interval >= 60, errs.MIN_INTERVAL_IS_SIXTY)
	frame_dig -3 // interval: uint64
	intc 17 // 60
	>=
	assert

	// contracts/arc58/plugins/subscription.algo.ts:273
	// assert(passes <= 5, errs.MAX_PASSES_IS_FIVE)
	frame_dig -6 // passes: uint64
	intc 15 // 5
	<=
	assert

	// *if6_condition
	// contracts/arc58/plugins/subscription.algo.ts:276
	// asset.id !== 0 && !this.app.address.isOptedInToAsset(asset)
	frame_dig -4 // asset: AssetID
	intc 0 // 0
	!=
	dup
	bz *skip_and1
	global CurrentApplicationAddress
	frame_dig -4 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	&&

*skip_and1:
	bz *if6_elseif1_condition

	// *if6_consequent
	// contracts/arc58/plugins/subscription.algo.ts:277
	// this.addPendingOptin(sender, rekeyBack, asset, FIVE_ALGO)
	intc 11 // 5000000
	frame_dig -4 // asset: AssetID
	frame_dig -2 // rekeyBack: boolean
	frame_dig -1 // sender: AppID
	callsub addPendingOptin

	// contracts/arc58/plugins/subscription.algo.ts:278
	// this.pendingGroup.submit()
	itxn_submit
	b *if6_end

*if6_elseif1_condition:
	// contracts/arc58/plugins/subscription.algo.ts:279
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if6_else

	// *if6_elseif1_consequent
	// contracts/arc58/plugins/subscription.algo.ts:280
	// sendPayment({
	//         sender: sender.address,
	//         receiver: globals.currentApplicationAddress,
	//         amount: FIVE_ALGO,
	//         rekeyTo: sender.address,
	//         fee: 0,
	//       })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:281
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:282
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:283
	// amount: FIVE_ALGO
	intc 11 // 5000000
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:284
	// rekeyTo: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscription.algo.ts:285
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if6_end

*if6_else:
	// contracts/arc58/plugins/subscription.algo.ts:288
	// sendPayment({
	//         sender: sender.address,
	//         receiver: globals.currentApplicationAddress,
	//         amount: FIVE_ALGO,
	//         fee: 0,
	//       })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:289
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:290
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:291
	// amount: FIVE_ALGO
	intc 11 // 5000000
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:292
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if6_end:
	// contracts/arc58/plugins/subscription.algo.ts:296
	// this.services(boxKey).value = {
	//       shutdown: false,
	//       active: true,
	//       interval: interval,
	//       asset: asset,
	//       amount: amount,
	//       passes: passes,
	//       gate: gate,
	//       cid: cid,
	//     }
	bytec 1 //  "s"
	frame_dig 1 // boxKey: ServicesKey
	concat
	bytec 5 // 0x00
	intc 0 // 0
	dup
	setbit
	intc 1 // 1
	dup
	setbit
	frame_dig -3 // interval: uint64
	itob
	concat
	frame_dig -4 // asset: AssetID
	itob
	concat
	frame_dig -5 // amount: uint64
	itob
	concat
	frame_dig -6 // passes: uint64
	itob
	concat
	frame_dig -7 // gate: uint64
	itob
	concat
	frame_dig -8 // cid: bytes59
	concat
	box_put

	// contracts/arc58/plugins/subscription.algo.ts:307
	// return index;
	frame_dig 0 // index: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// pauseService(uint64,bool,uint64)void
*abi_route_pauseService:
	// index: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 1 (rekeyBack) for pauseService must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute pauseService(uint64,bool,uint64)void
	callsub pauseService
	intc 1 // 1
	return

// pauseService(sender: AppID, rekeyBack: boolean, index: uint64): void
//
// pauseService pauses a service for a merchant
// it does not shutdown pre-existing subscriptions
// it simply prevents new subscriptions from being created
// for a specific service
// @param sender The address the plugin currently controls
// @param index The index of the box to be used for the subscription
pauseService:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/arc58/plugins/subscription.algo.ts:319
	// boxKey: ServicesKey = { user: sender.address, index: index }
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -3 // index: uint64
	itob
	concat
	frame_bury 0 // boxKey: ServicesKey

	// contracts/arc58/plugins/subscription.algo.ts:322
	// assert(this.controls(sender.address), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/subscription.algo.ts:325
	// assert(index > 0, errs.SERVICE_INDEX_MUST_BE_ABOVE_ZERO)
	frame_dig -3 // index: uint64
	intc 0 // 0
	>
	assert

	// contracts/arc58/plugins/subscription.algo.ts:327
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscription.algo.ts:329
	// assert(!this.services(boxKey).value.shutdown, errs.SERVICE_IS_SHUTDOWN)
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	getbit
	!
	assert

	// contracts/arc58/plugins/subscription.algo.ts:331
	// this.services(boxKey).value.active = false
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 1 // 1
	intc 0 // 0
	setbit
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_replace

	// *if7_condition
	// contracts/arc58/plugins/subscription.algo.ts:333
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if7_end

	// *if7_consequent
	// contracts/arc58/plugins/subscription.algo.ts:334
	// this.rekeyBack(sender.address)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub rekeyBack

*if7_end:
	retsub

// activateService(uint64,bool,uint64)void
*abi_route_activateService:
	// index: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 1 (rekeyBack) for activateService must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute activateService(uint64,bool,uint64)void
	callsub activateService
	intc 1 // 1
	return

// activateService(sender: AppID, rekeyBack: boolean, index: uint64): void
//
// activateService activates an service for a merchant
//
// @param sender The address the plugin currently controls
// @param rekeyBack Indicates whether the user wants to rekey back after the transaction
// @param index The index of the box to be used for the subscription
activateService:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/arc58/plugins/subscription.algo.ts:346
	// boxKey: ServicesKey = { user: sender.address, index: index }
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -3 // index: uint64
	itob
	concat
	frame_bury 0 // boxKey: ServicesKey

	// contracts/arc58/plugins/subscription.algo.ts:349
	// assert(this.controls(sender.address), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/subscription.algo.ts:351
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscription.algo.ts:353
	// assert(!this.services(boxKey).value.shutdown, errs.SERVICE_IS_SHUTDOWN)
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	getbit
	!
	assert

	// contracts/arc58/plugins/subscription.algo.ts:355
	// this.services(boxKey).value.active = true
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 1 // 1
	dup
	setbit
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_replace

	// *if8_condition
	// contracts/arc58/plugins/subscription.algo.ts:357
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if8_end

	// *if8_consequent
	// contracts/arc58/plugins/subscription.algo.ts:358
	// this.rekeyBack(sender.address)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub rekeyBack

*if8_end:
	retsub

// shutdownService(uint64,bool,uint64)void
*abi_route_shutdownService:
	// index: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 1 (rekeyBack) for shutdownService must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute shutdownService(uint64,bool,uint64)void
	callsub shutdownService
	intc 1 // 1
	return

// shutdownService(sender: AppID, rekeyBack: boolean, index: uint64): void
//
// shutdownService permanently shuts down an service for a merchant
// it also shutsdown pre-existing subscriptions
// @param sender The address the plugin currently controls
// @param index The index of the box to be used for the subscription
shutdownService:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/arc58/plugins/subscription.algo.ts:369
	// boxKey: ServicesKey = { user: sender.address, index: index }
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -3 // index: uint64
	itob
	concat
	frame_bury 0 // boxKey: ServicesKey

	// contracts/arc58/plugins/subscription.algo.ts:372
	// assert(this.controls(sender.address), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/subscription.algo.ts:374
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscription.algo.ts:376
	// assert(!this.services(boxKey).value.shutdown, errs.SERVICE_IS_SHUTDOWN)
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	getbit
	!
	assert

	// contracts/arc58/plugins/subscription.algo.ts:378
	// this.services(boxKey).value.shutdown = true
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	intc 1 // 1
	setbit
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_replace

	// contracts/arc58/plugins/subscription.algo.ts:379
	// this.services(boxKey).value.active = false
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 1 // 1
	intc 0 // 0
	setbit
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_replace

	// *if9_condition
	// contracts/arc58/plugins/subscription.algo.ts:381
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if9_end

	// *if9_consequent
	// contracts/arc58/plugins/subscription.algo.ts:382
	// this.rekeyBack(sender.address)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub rekeyBack

*if9_end:
	retsub

// isShutdown(address,uint64)bool
*abi_route_isShutdown:
	// The ABI return prefix
	bytec 3 // 0x151f7c75

	// boxIndex: uint64
	txna ApplicationArgs 2
	btoi

	// merchant: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 1 (merchant) for isShutdown must be a address
	assert

	// execute isShutdown(address,uint64)bool
	callsub isShutdown
	bytec 5 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	concat
	log
	intc 1 // 1
	return

// isShutdown(merchant: Address, boxIndex: uint64): boolean
//
// serviceIsActive checks if an service is shutdown
isShutdown:
	proto 2 1

	// contracts/arc58/plugins/subscription.algo.ts:391
	// return this.services({ user: merchant, index: boxIndex }).value.shutdown;
	bytec 1 //  "s"
	frame_dig -1 // merchant: Address
	frame_dig -2 // boxIndex: uint64
	itob
	concat
	concat
	box_get

	// box value does not exist: this.services({ user: merchant, index: boxIndex }).value
	assert
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	getbit
	retsub

// block(uint64,bool,address)void
*abi_route_block:
	// address: address
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for block must be a address
	assert

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 1 (rekeyBack) for block must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute block(uint64,bool,address)void
	callsub block
	intc 1 // 1
	return

// block(sender: AppID, rekeyBack: boolean, address: Address): void
//
// block blacklists an address for a merchant
// @param sender The address the plugin currently controls
// @param address The address to be blocked
block:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/arc58/plugins/subscription.algo.ts:400
	// boxKey: BlockListKey = { user: sender.address, blocked: address }
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -3 // address: Address
	concat
	frame_bury 0 // boxKey: BlockListKey

	// contracts/arc58/plugins/subscription.algo.ts:403
	// assert(this.controls(sender.address), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/subscription.algo.ts:405
	// assert(!this.blocks(boxKey).exists, errs.USER_ALREADY_BLOCKED)
	frame_dig 0 // boxKey: BlockListKey
	box_len
	swap
	pop
	!
	assert

	// *if10_condition
	// contracts/arc58/plugins/subscription.algo.ts:408
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if10_else

	// *if10_consequent
	// contracts/arc58/plugins/subscription.algo.ts:409
	// sendPayment({
	//         sender: sender.address,
	//         receiver: globals.currentApplicationAddress,
	//         amount: 28_100,
	//         rekeyTo: sender.address,
	//         fee: 0,
	//       })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:410
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:411
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:412
	// amount: 28_100
	intc 13 // 28_100
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:413
	// rekeyTo: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscription.algo.ts:414
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if10_end

*if10_else:
	// contracts/arc58/plugins/subscription.algo.ts:417
	// sendPayment({
	//         sender: sender.address,
	//         receiver: globals.currentApplicationAddress,
	//         amount: 28_100,
	//         fee: 0,
	//       })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:418
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:419
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:420
	// amount: 28_100
	intc 13 // 28_100
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:421
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if10_end:
	// contracts/arc58/plugins/subscription.algo.ts:425
	// this.blocks(boxKey).create(0)
	frame_dig 0 // boxKey: BlockListKey
	intc 0 // 0
	box_create
	pop
	retsub

// unblock(uint64,bool,address)void
*abi_route_unblock:
	// address: address
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for unblock must be a address
	assert

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 1 (rekeyBack) for unblock must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute unblock(uint64,bool,address)void
	callsub unblock
	intc 1 // 1
	return

// unblock(sender: AppID, rekeyBack: boolean, address: Address): void
//
// unblock removes an address from a merchants blocks
// @param address The address to be unblocked
unblock:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/arc58/plugins/subscription.algo.ts:433
	// boxKey: BlockListKey = { user: sender.address, blocked: address }
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -3 // address: Address
	concat
	frame_bury 0 // boxKey: BlockListKey

	// contracts/arc58/plugins/subscription.algo.ts:436
	// assert(this.controls(sender.address), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/subscription.algo.ts:438
	// assert(this.blocks(boxKey).exists, errs.USER_NOT_BLOCKED)
	frame_dig 0 // boxKey: BlockListKey
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscription.algo.ts:440
	// this.blocks(boxKey).delete()
	frame_dig 0 // boxKey: BlockListKey
	box_del

	// *if11_condition
	// contracts/arc58/plugins/subscription.algo.ts:442
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if11_end

	// *if11_consequent
	// contracts/arc58/plugins/subscription.algo.ts:443
	// this.rekeyBack(sender.address)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub rekeyBack

*if11_end:
	retsub

// isBlocked(address,address)bool
*abi_route_isBlocked:
	// The ABI return prefix
	bytec 3 // 0x151f7c75

	// address: address
	txna ApplicationArgs 2
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for isBlocked must be a address
	assert

	// merchant: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 1 (merchant) for isBlocked must be a address
	assert

	// execute isBlocked(address,address)bool
	callsub isBlocked
	bytec 5 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	concat
	log
	intc 1 // 1
	return

// isBlocked(merchant: Address, address: Address): boolean
//
// isBlocked checks if an address is blocked for a merchant
// @param merchant The merchant address to be checked
// @param address The address to be checked
isBlocked:
	proto 2 1

	// contracts/arc58/plugins/subscription.algo.ts:454
	// return this.blocks({ user: merchant, blocked: address }).exists;
	frame_dig -1 // merchant: Address
	frame_dig -2 // address: Address
	concat
	box_len
	swap
	pop
	retsub

// subscribe(uint64,bool,address,uint64,uint64,uint64,uint64,uint64,byte[][])void
*abi_route_subscribe:
	// args: byte[][]
	txna ApplicationArgs 9

	// gate: uint64
	txna ApplicationArgs 8
	btoi

	// index: uint64
	txna ApplicationArgs 7
	btoi

	// asset: uint64
	txna ApplicationArgs 6
	btoi

	// interval: uint64
	txna ApplicationArgs 5
	btoi

	// amount: uint64
	txna ApplicationArgs 4
	btoi

	// recipient: address
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 32
	==

	// argument 6 (recipient) for subscribe must be a address
	assert

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 7 (rekeyBack) for subscribe must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute subscribe(uint64,bool,address,uint64,uint64,uint64,uint64,uint64,byte[][])void
	callsub subscribe
	intc 1 // 1
	return

// subscribe(sender: AppID, rekeyBack: boolean, recipient: Address, amount: uint64, interval: uint64, asset: AssetID, index: uint64, gate: uint64, args: bytes[]): void
subscribe:
	proto 9 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 10

	// contracts/arc58/plugins/subscription.algo.ts:468
	// isDonation = index === 0
	frame_dig -7 // index: uint64
	intc 0 // 0
	==
	frame_bury 0 // isDonation: bool

	// contracts/arc58/plugins/subscription.algo.ts:469
	// isAsa = asset.id !== 0
	frame_dig -6 // asset: AssetID
	intc 0 // 0
	!=
	frame_bury 1 // isAsa: bool

	// contracts/arc58/plugins/subscription.algo.ts:472
	// assert(this.controls(sender.address), errs.PLUGIN_NOT_AUTH_ADDR)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub controls
	assert

	// contracts/arc58/plugins/subscription.algo.ts:474
	// assert(amount > 3, errs.MIN_AMOUNT_IS_THREE)
	frame_dig -4 // amount: uint64
	intc 14 // 3
	>
	assert

	// contracts/arc58/plugins/subscription.algo.ts:476
	// assert(interval >= 60, errs.MIN_INTERVAL_IS_SIXTY)
	frame_dig -5 // interval: uint64
	intc 17 // 60
	>=
	assert

	// *if12_condition
	// contracts/arc58/plugins/subscription.algo.ts:478
	// !isDonation
	frame_dig 0 // isDonation: bool
	!
	bz *if12_end

	// *if12_consequent
	// contracts/arc58/plugins/subscription.algo.ts:479
	// boxKey: ServicesKey = { user: recipient, index: index }
	frame_dig -3 // recipient: Address
	frame_dig -7 // index: uint64
	itob
	concat
	frame_bury 2 // boxKey: ServicesKey

	// contracts/arc58/plugins/subscription.algo.ts:480
	// blocksKey: BlockListKey = { user: recipient, blocked: sender.address }
	frame_dig -3 // recipient: Address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	frame_bury 3 // blocksKey: BlockListKey

	// contracts/arc58/plugins/subscription.algo.ts:483
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	bytec 1 //  "s"
	frame_dig 2 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscription.algo.ts:485
	// service = this.services(boxKey).value
	bytec 1 //  "s"
	frame_dig 2 // boxKey: ServicesKey
	concat
	frame_bury 4 // storage key//service

	// contracts/arc58/plugins/subscription.algo.ts:488
	// assert(!this.blocks(blocksKey).exists, errs.BLOCKED)
	frame_dig 3 // blocksKey: BlockListKey
	box_len
	swap
	pop
	!
	assert

	// contracts/arc58/plugins/subscription.algo.ts:490
	// assert(!service.shutdown, errs.SERVICE_IS_SHUTDOWN)
	frame_dig 4 // storage key//service
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	getbit
	!
	assert

	// contracts/arc58/plugins/subscription.algo.ts:492
	// assert(service.active, errs.SERVICE_IS_PAUSED)
	frame_dig 4 // storage key//service
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 1 // 1
	getbit
	assert

	// contracts/arc58/plugins/subscription.algo.ts:494
	// assert(this.gate(service.gate, args), errs.FAILED_GATE)
	frame_dig -9 // args: bytes[]
	frame_dig 4 // storage key//service
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	extract 33 8
	btoi
	callsub gate
	assert

	// contracts/arc58/plugins/subscription.algo.ts:496
	// amount = service.amount
	frame_dig 4 // storage key//service
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	extract 17 8
	btoi
	frame_bury -4 // amount: uint64

	// contracts/arc58/plugins/subscription.algo.ts:497
	// interval = service.interval
	frame_dig 4 // storage key//service
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	extract 1 8
	btoi
	frame_bury -5 // interval: uint64

	// contracts/arc58/plugins/subscription.algo.ts:498
	// gate = service.gate
	frame_dig 4 // storage key//service
	box_get

	// box value does not exist: this.services(boxKey).value
	assert
	store 255 // full array
	load 255 // full array
	extract 33 8
	btoi
	frame_bury -8 // gate: uint64

*if12_end:
	// contracts/arc58/plugins/subscription.algo.ts:501
	// algoMBRFee: uint64 = 53_700
	pushint 53_700
	frame_bury 5 // algoMBRFee: uint64

	// contracts/arc58/plugins/subscription.algo.ts:502
	// subIndex: uint64 = 0
	intc 0 // 0
	frame_bury 6 // subIndex: uint64

	// contracts/arc58/plugins/subscription.algo.ts:503
	// subscriptionsListExists: boolean = this.subscriptionslist(sender.address).exists
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	box_len
	swap
	pop
	frame_bury 7 // subscriptionsListExists: boolean

	// *if13_condition
	// contracts/arc58/plugins/subscription.algo.ts:504
	// subscriptionsListExists
	frame_dig 7 // subscriptionsListExists: boolean
	bz *if13_else

	// *if13_consequent
	// contracts/arc58/plugins/subscription.algo.ts:505
	// subIndex = this.subscriptionslist(sender.address).value
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	box_get

	// box value does not exist: this.subscriptionslist(sender.address).value
	assert
	btoi
	frame_bury 6 // subIndex: uint64

	// contracts/arc58/plugins/subscription.algo.ts:506
	// this.subscriptionslist(sender.address).value += 1
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	box_get

	// box value does not exist: this.subscriptionslist(sender.address).value
	assert
	btoi
	intc 1 // 1
	+
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	swap
	itob
	box_put
	b *if13_end

*if13_else:
	// contracts/arc58/plugins/subscription.algo.ts:508
	// algoMBRFee += 18_500
	frame_dig 5 // algoMBRFee: uint64
	pushint 18_500
	+
	frame_bury 5 // algoMBRFee: uint64

	// contracts/arc58/plugins/subscription.algo.ts:509
	// subIndex = 0
	intc 0 // 0
	frame_bury 6 // subIndex: uint64

	// contracts/arc58/plugins/subscription.algo.ts:510
	// this.subscriptionslist(sender.address).value = 0
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	pushbytes 0x0000000000000000
	box_put

*if13_end:
	// contracts/arc58/plugins/subscription.algo.ts:513
	// subscriptionKey: SubscriptionKey = { user: sender.address, index: subIndex }
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig 6 // subIndex: uint64
	itob
	concat
	frame_bury 8 // subscriptionKey: SubscriptionKey

	// contracts/arc58/plugins/subscription.algo.ts:515
	// this.subscriptions(subscriptionKey).value = {
	//       recipient: recipient,
	//       index: index,
	//       startDate: globals.latestTimestamp,
	//       amount: amount,
	//       interval: interval,
	//       asset: asset,
	//       gate: gate,
	//       lastPayment: globals.latestTimestamp,
	//       streak: 1,
	//     }
	frame_dig 8 // subscriptionKey: SubscriptionKey
	frame_dig -3 // recipient: Address
	frame_dig -7 // index: uint64
	itob
	concat
	global LatestTimestamp
	itob
	concat
	frame_dig -4 // amount: uint64
	itob
	concat
	frame_dig -5 // interval: uint64
	itob
	concat
	frame_dig -6 // asset: AssetID
	itob
	concat
	frame_dig -8 // gate: uint64
	itob
	concat
	global LatestTimestamp
	itob
	concat
	bytec 6 // 0x0000000000000001
	concat
	box_put

	// contracts/arc58/plugins/subscription.algo.ts:527
	// initialFee = (amount * 40 - 1) / 1000 + 1
	frame_dig -4 // amount: uint64
	intc 7 // 40
	*
	intc 1 // 1
	-
	intc 12 // 1000
	/
	intc 1 // 1
	+
	frame_bury 9 // initialFee: uint64

	// contracts/arc58/plugins/subscription.algo.ts:528
	// leftOver = amount - initialFee
	frame_dig -4 // amount: uint64
	frame_dig 9 // initialFee: uint64
	-
	frame_bury 10 // leftOver: uint64

	// *if14_condition
	// contracts/arc58/plugins/subscription.algo.ts:530
	// isAsa
	frame_dig 1 // isAsa: bool
	bz *if14_else

	// *if14_consequent
	// *if15_condition
	// contracts/arc58/plugins/subscription.algo.ts:531
	// !this.app.address.isOptedInToAsset(asset)
	global CurrentApplicationAddress
	frame_dig -6 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if15_else

	// *if15_consequent
	// contracts/arc58/plugins/subscription.algo.ts:533
	// this.addPendingOptin(sender, false, asset, algoMBRFee)
	frame_dig 5 // algoMBRFee: uint64
	frame_dig -6 // asset: AssetID
	intc 0 // 0
	frame_dig -1 // sender: AppID
	callsub addPendingOptin
	b *if15_end

*if15_else:
	// contracts/arc58/plugins/subscription.algo.ts:536
	// this.pendingGroup.addPayment({
	//           sender: sender.address,
	//           receiver: globals.currentApplicationAddress,
	//           amount: algoMBRFee,
	//           fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:537
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:538
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:539
	// amount: algoMBRFee
	frame_dig 5 // algoMBRFee: uint64
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:540
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if15_end:
	// contracts/arc58/plugins/subscription.algo.ts:544
	// this.pendingGroup.addAssetTransfer({
	//         sender: sender.address,
	//         assetReceiver: globals.currentApplicationAddress,
	//         xferAsset: asset,
	//         assetAmount: initialFee,
	//         fee: 0,
	//       })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:545
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:546
	// assetReceiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscription.algo.ts:547
	// xferAsset: asset
	frame_dig -6 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/subscription.algo.ts:548
	// assetAmount: initialFee
	frame_dig 9 // initialFee: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscription.algo.ts:549
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// *if16_condition
	// contracts/arc58/plugins/subscription.algo.ts:552
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if16_else

	// *if16_consequent
	// contracts/arc58/plugins/subscription.algo.ts:553
	// this.pendingGroup.addAssetTransfer({
	//           sender: sender.address,
	//           assetReceiver: recipient,
	//           xferAsset: asset,
	//           assetAmount: leftOver,
	//           rekeyTo: sender.address,
	//           fee: 0,
	//         })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:554
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:555
	// assetReceiver: recipient
	frame_dig -3 // recipient: Address
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscription.algo.ts:556
	// xferAsset: asset
	frame_dig -6 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/subscription.algo.ts:557
	// assetAmount: leftOver
	frame_dig 10 // leftOver: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscription.algo.ts:558
	// rekeyTo: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscription.algo.ts:559
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	b *if16_end

*if16_else:
	// contracts/arc58/plugins/subscription.algo.ts:562
	// this.pendingGroup.addAssetTransfer({
	//           sender: sender.address,
	//           assetReceiver: recipient,
	//           xferAsset: asset,
	//           assetAmount: leftOver,
	//           rekeyTo: sender.address,
	//           fee: 0,
	//         })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:563
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:564
	// assetReceiver: recipient
	frame_dig -3 // recipient: Address
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscription.algo.ts:565
	// xferAsset: asset
	frame_dig -6 // asset: AssetID
	itxn_field XferAsset

	// contracts/arc58/plugins/subscription.algo.ts:566
	// assetAmount: leftOver
	frame_dig 10 // leftOver: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscription.algo.ts:567
	// rekeyTo: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscription.algo.ts:568
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if16_end:
	b *if14_end

*if14_else:
	// contracts/arc58/plugins/subscription.algo.ts:573
	// this.pendingGroup.addPayment({
	//         sender: sender.address,
	//         receiver: globals.currentApplicationAddress,
	//         amount: (algoMBRFee + initialFee),
	//         fee: 0,
	//       })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:574
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:575
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:576
	// amount: (algoMBRFee + initialFee)
	frame_dig 5 // algoMBRFee: uint64
	frame_dig 9 // initialFee: uint64
	+
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:577
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// *if17_condition
	// contracts/arc58/plugins/subscription.algo.ts:580
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if17_else

	// *if17_consequent
	// contracts/arc58/plugins/subscription.algo.ts:581
	// this.pendingGroup.addPayment({
	//           sender: sender.address,
	//           receiver: recipient,
	//           amount: leftOver,
	//           rekeyTo: sender.address,
	//           fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:582
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:583
	// receiver: recipient
	frame_dig -3 // recipient: Address
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:584
	// amount: leftOver
	frame_dig 10 // leftOver: uint64
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:585
	// rekeyTo: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscription.algo.ts:586
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	b *if17_end

*if17_else:
	// contracts/arc58/plugins/subscription.algo.ts:589
	// this.pendingGroup.addPayment({
	//           sender: sender.address,
	//           receiver: recipient,
	//           amount: leftOver,
	//           fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:590
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:591
	// receiver: recipient
	frame_dig -3 // recipient: Address
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:592
	// amount: leftOver
	frame_dig 10 // leftOver: uint64
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:593
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if17_end:

*if14_end:
	// contracts/arc58/plugins/subscription.algo.ts:598
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// triggerPayment(uint64,bool,uint64,byte[][])void
*abi_route_triggerPayment:
	// args: byte[][]
	txna ApplicationArgs 4

	// index: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 2 (rekeyBack) for triggerPayment must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute triggerPayment(uint64,bool,uint64,byte[][])void
	callsub triggerPayment
	intc 1 // 1
	return

// triggerPayment(sender: AppID, rekeyBack: boolean, index: uint64, args: bytes[]): void
triggerPayment:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 7

	// contracts/arc58/plugins/subscription.algo.ts:602
	// subscriptionsKey: SubscriptionKey = { user: sender.address, index: index }
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -3 // index: uint64
	itob
	concat
	frame_bury 0 // subscriptionsKey: SubscriptionKey

	// contracts/arc58/plugins/subscription.algo.ts:605
	// assert(this.subscriptions(subscriptionsKey).exists)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscription.algo.ts:607
	// sub = this.subscriptions(subscriptionsKey).value
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/arc58/plugins/subscription.algo.ts:609
	// blocksKey: BlockListKey = { user: sub.recipient, blocked: sender.address }
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	concat
	frame_bury 2 // blocksKey: BlockListKey

	// contracts/arc58/plugins/subscription.algo.ts:612
	// assert(!this.blocks(blocksKey).exists, errs.BLOCKED)
	frame_dig 2 // blocksKey: BlockListKey
	box_len
	swap
	pop
	!
	assert

	// *if18_condition
	// contracts/arc58/plugins/subscription.algo.ts:614
	// index > 0
	frame_dig -3 // index: uint64
	intc 0 // 0
	>
	bz *if18_end

	// *if18_consequent
	// contracts/arc58/plugins/subscription.algo.ts:615
	// servicesKey: ServicesKey = { user: sub.recipient, index: sub.index }
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 3 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	concat
	frame_bury 3 // servicesKey: ServicesKey

	// contracts/arc58/plugins/subscription.algo.ts:617
	// assert(!this.services(servicesKey).value.shutdown, errs.SERVICE_IS_PAUSED)
	bytec 1 //  "s"
	frame_dig 3 // servicesKey: ServicesKey
	concat
	box_get

	// box value does not exist: this.services(servicesKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	getbit
	!
	assert

*if18_end:
	// contracts/arc58/plugins/subscription.algo.ts:621
	// assert(sub.lastPayment < this.getLatestWindowStart(sub.startDate, sub.interval), errs.BAD_WINDOW)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 6 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 9 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 7 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	callsub getLatestWindowStart
	<
	assert

	// contracts/arc58/plugins/subscription.algo.ts:623
	// isAsa = sub.asset.id !== 0
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	intc 0 // 0
	!=
	frame_bury 4 // isAsa: bool

	// contracts/arc58/plugins/subscription.algo.ts:625
	// akitaFee = (sub.amount * 35 - 1) / 1000 + 1
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 8 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	pushint 35
	*
	intc 1 // 1
	-
	intc 12 // 1000
	/
	intc 1 // 1
	+
	frame_bury 5 // akitaFee: uint64

	// contracts/arc58/plugins/subscription.algo.ts:626
	// triggerFee = (sub.amount * 5 - 1) / 1000 + 1
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 8 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	intc 15 // 5
	*
	intc 1 // 1
	-
	intc 12 // 1000
	/
	intc 1 // 1
	+
	frame_bury 6 // triggerFee: uint64

	// contracts/arc58/plugins/subscription.algo.ts:627
	// leftOver = sub.amount - (akitaFee + triggerFee)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 8 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 5 // akitaFee: uint64
	frame_dig 6 // triggerFee: uint64
	+
	-
	frame_bury 7 // leftOver: uint64

	// *if19_condition
	// contracts/arc58/plugins/subscription.algo.ts:629
	// isAsa
	frame_dig 4 // isAsa: bool
	bz *if19_else

	// *if19_consequent
	// contracts/arc58/plugins/subscription.algo.ts:630
	// this.pendingGroup.addAssetTransfer({
	//         sender: sender.address,
	//         assetReceiver: globals.currentApplicationAddress,
	//         xferAsset: sub.asset,
	//         assetAmount: akitaFee,
	//         fee: 0,
	//       })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:631
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:632
	// assetReceiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscription.algo.ts:633
	// xferAsset: sub.asset
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/arc58/plugins/subscription.algo.ts:634
	// assetAmount: akitaFee
	frame_dig 5 // akitaFee: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscription.algo.ts:635
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/subscription.algo.ts:638
	// this.pendingGroup.addAssetTransfer({
	//         sender: sender.address,
	//         assetReceiver: this.txn.sender,
	//         xferAsset: sub.asset,
	//         assetAmount: triggerFee,
	//         fee: 0,
	//       })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:639
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:640
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscription.algo.ts:641
	// xferAsset: sub.asset
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/arc58/plugins/subscription.algo.ts:642
	// assetAmount: triggerFee
	frame_dig 6 // triggerFee: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscription.algo.ts:643
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// *if20_condition
	// contracts/arc58/plugins/subscription.algo.ts:646
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if20_else

	// *if20_consequent
	// contracts/arc58/plugins/subscription.algo.ts:647
	// this.pendingGroup.addAssetTransfer({
	//           sender: sender.address,
	//           assetReceiver: sub.recipient,
	//           xferAsset: sub.asset,
	//           assetAmount: leftOver,
	//           rekeyTo: sender.address,
	//           fee: 0,
	//         })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:648
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:649
	// assetReceiver: sub.recipient
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscription.algo.ts:650
	// xferAsset: sub.asset
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/arc58/plugins/subscription.algo.ts:651
	// assetAmount: leftOver
	frame_dig 7 // leftOver: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscription.algo.ts:652
	// rekeyTo: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscription.algo.ts:653
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	b *if20_end

*if20_else:
	// contracts/arc58/plugins/subscription.algo.ts:656
	// this.pendingGroup.addAssetTransfer({
	//           sender: sender.address,
	//           assetReceiver: sub.recipient,
	//           xferAsset: sub.asset,
	//           assetAmount: leftOver,
	//           fee: 0,
	//         })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:657
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:658
	// assetReceiver: sub.recipient
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	itxn_field AssetReceiver

	// contracts/arc58/plugins/subscription.algo.ts:659
	// xferAsset: sub.asset
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/arc58/plugins/subscription.algo.ts:660
	// assetAmount: leftOver
	frame_dig 7 // leftOver: uint64
	itxn_field AssetAmount

	// contracts/arc58/plugins/subscription.algo.ts:661
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if20_end:
	b *if19_end

*if19_else:
	// contracts/arc58/plugins/subscription.algo.ts:666
	// this.pendingGroup.addPayment({
	//         sender: sender.address,
	//         receiver: globals.currentApplicationAddress,
	//         amount: akitaFee,
	//         fee: 0,
	//       })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:667
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:668
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:669
	// amount: akitaFee
	frame_dig 5 // akitaFee: uint64
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:670
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/arc58/plugins/subscription.algo.ts:673
	// this.pendingGroup.addPayment({
	//         sender: sender.address,
	//         receiver: this.txn.sender,
	//         amount: triggerFee,
	//         fee: 0,
	//       })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:674
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:675
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:676
	// amount: triggerFee
	frame_dig 6 // triggerFee: uint64
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:677
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// *if21_condition
	// contracts/arc58/plugins/subscription.algo.ts:680
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if21_else

	// *if21_consequent
	// contracts/arc58/plugins/subscription.algo.ts:681
	// this.pendingGroup.addPayment({
	//           sender: sender.address,
	//           receiver: sub.recipient,
	//           amount: leftOver,
	//           rekeyTo: sender.address,
	//           fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:682
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:683
	// receiver: sub.recipient
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:684
	// amount: leftOver
	frame_dig 7 // leftOver: uint64
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:685
	// rekeyTo: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field RekeyTo

	// contracts/arc58/plugins/subscription.algo.ts:686
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	b *if21_end

*if21_else:
	// contracts/arc58/plugins/subscription.algo.ts:689
	// this.pendingGroup.addPayment({
	//           sender: sender.address,
	//           receiver: sub.recipient,
	//           amount: leftOver,
	//           fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/arc58/plugins/subscription.algo.ts:690
	// sender: sender.address
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	itxn_field Sender

	// contracts/arc58/plugins/subscription.algo.ts:691
	// receiver: sub.recipient
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	itxn_field Receiver

	// contracts/arc58/plugins/subscription.algo.ts:692
	// amount: leftOver
	frame_dig 7 // leftOver: uint64
	itxn_field Amount

	// contracts/arc58/plugins/subscription.algo.ts:693
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if21_end:

*if19_end:
	// contracts/arc58/plugins/subscription.algo.ts:698
	// this.pendingGroup.submit()
	itxn_submit

	// contracts/arc58/plugins/subscription.algo.ts:699
	// this.updateStreak(sender.address, index, 1)
	intc 1 // 1
	frame_dig -3 // index: uint64
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub updateStreak

	// contracts/arc58/plugins/subscription.algo.ts:700
	// this.subscriptions(subscriptionsKey).value.lastPayment = globals.latestTimestamp
	intc 6 //  headOffset
	global LatestTimestamp
	itob
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	cover 2
	box_replace
	retsub

// streakCheck(address,uint64)void
*abi_route_streakCheck:
	// index: uint64
	txna ApplicationArgs 2
	btoi

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 1 (sender) for streakCheck must be a address
	assert

	// execute streakCheck(address,uint64)void
	callsub streakCheck
	intc 1 // 1
	return

// streakCheck(sender: Address, index: uint64): void
streakCheck:
	proto 2 0

	// contracts/arc58/plugins/subscription.algo.ts:704
	// this.updateStreak(sender, index, 0)
	intc 0 // 0
	frame_dig -2 // index: uint64
	frame_dig -1 // sender: Address
	callsub updateStreak
	retsub

// setPasses(uint64,bool,uint64,address[])void
*abi_route_setPasses:
	// addresses: address[]
	txna ApplicationArgs 4
	extract 2 0

	// index: uint64
	txna ApplicationArgs 3
	btoi

	// rekeyBack: bool
	txna ApplicationArgs 2
	dup
	len
	intc 1 // 1
	==

	// argument 2 (rekeyBack) for setPasses must be a bool
	assert
	intc 0 // 0
	getbit

	// sender: uint64
	txna ApplicationArgs 1
	btoi

	// execute setPasses(uint64,bool,uint64,address[])void
	callsub setPasses
	intc 1 // 1
	return

// setPasses(sender: AppID, rekeyBack: boolean, index: uint64, addresses: Address[]): void
setPasses:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// contracts/arc58/plugins/subscription.algo.ts:708
	// assert(index > 0, errs.NO_DONATIONS)
	frame_dig -3 // index: uint64
	intc 0 // 0
	>
	assert

	// contracts/arc58/plugins/subscription.algo.ts:709
	// subscriptionsKey: SubscriptionKey = { user: sender.address, index: index }
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	frame_dig -3 // index: uint64
	itob
	concat
	frame_bury 0 // subscriptionsKey: SubscriptionKey

	// contracts/arc58/plugins/subscription.algo.ts:711
	// assert(this.subscriptions(subscriptionsKey).exists, errs.SUBSCRIPTION_DOES_NOT_EXIST)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/arc58/plugins/subscription.algo.ts:713
	// sub = this.subscriptions(subscriptionsKey).value
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/arc58/plugins/subscription.algo.ts:715
	// serviceKey: ServicesKey = { user: sub.recipient, index: index }
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	frame_dig -3 // index: uint64
	itob
	concat
	frame_bury 2 // serviceKey: ServicesKey

	// contracts/arc58/plugins/subscription.algo.ts:716
	// service = this.services(serviceKey).value
	bytec 1 //  "s"
	frame_dig 2 // serviceKey: ServicesKey
	concat
	frame_bury 3 // storage key//service

	// contracts/arc58/plugins/subscription.algo.ts:718
	// assert(service.active, errs.SERVICE_IS_PAUSED)
	frame_dig 3 // storage key//service
	box_get

	// box value does not exist: this.services(serviceKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 1 // 1
	getbit
	assert

	// contracts/arc58/plugins/subscription.algo.ts:719
	// assert(!service.shutdown, errs.SERVICE_IS_SHUTDOWN)
	frame_dig 3 // storage key//service
	box_get

	// box value does not exist: this.services(serviceKey).value
	assert
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	getbit
	!
	assert

	// contracts/arc58/plugins/subscription.algo.ts:720
	// assert(service.passes >= addresses.length, errs.PASS_COUNT_OVERFLOW)
	frame_dig 3 // storage key//service
	box_get

	// box value does not exist: this.services(serviceKey).value
	assert
	store 255 // full array
	load 255 // full array
	extract 25 8
	btoi
	frame_dig -4 // addresses: Address[]
	len
	intc 3 // 32
	/
	>=
	assert

	// contracts/arc58/plugins/subscription.algo.ts:722
	// for (let i = 0; i < addresses.length; i += 1)
	intc 0 // 0
	frame_bury 4 // i: uint64

*for_0:
	// contracts/arc58/plugins/subscription.algo.ts:722
	// i < addresses.length
	frame_dig 4 // i: uint64
	frame_dig -4 // addresses: Address[]
	len
	intc 3 // 32
	/
	<
	bz *for_0_end

	// contracts/arc58/plugins/subscription.algo.ts:723
	// assert(!this.blocks({ user: sub.recipient, blocked: addresses[i] }).exists, errs.BLOCKED)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	frame_dig -4 // addresses: Address[]
	store 255 // full array
	intc 0 //  initial offset
	frame_dig 4 // i: uint64
	intc 3 // 32
	* // acc * typeLength
	+
	load 255 // full array
	swap
	intc 3 // 32
	extract3
	concat
	box_len
	swap
	pop
	!
	assert

*for_0_continue:
	// contracts/arc58/plugins/subscription.algo.ts:722
	// i += 1
	frame_dig 4 // i: uint64
	intc 1 // 1
	+
	frame_bury 4 // i: uint64
	b *for_0

*for_0_end:
	// contracts/arc58/plugins/subscription.algo.ts:726
	// this.passes(subscriptionsKey).value = addresses
	bytec 4 //  "p"
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	concat
	dup
	box_del
	pop
	frame_dig -4 // addresses: Address[]
	dup
	len
	intc 3 // 32
	/
	itob
	extract 6 2
	swap
	concat
	box_put

	// *if22_condition
	// contracts/arc58/plugins/subscription.algo.ts:728
	// rekeyBack
	frame_dig -2 // rekeyBack: boolean
	bz *if22_end

	// *if22_consequent
	// contracts/arc58/plugins/subscription.algo.ts:729
	// this.rekeyBack(sender.address)
	frame_dig -1 // sender: AppID
	app_params_get AppAddress
	pop
	callsub rekeyBack

*if22_end:
	retsub

*abi_route_createApplication:
	intc 1 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x3362f0b0 // method "getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])"
	pushbytes 0xbe1ef1b8 // method "newService(uint64,bool,uint64,uint64,uint64,uint64,uint64,byte[59])uint64"
	pushbytes 0x39a3ae47 // method "pauseService(uint64,bool,uint64)void"
	pushbytes 0x7c88de8f // method "activateService(uint64,bool,uint64)void"
	pushbytes 0x19b1fc2b // method "shutdownService(uint64,bool,uint64)void"
	pushbytes 0x0d6a47a3 // method "isShutdown(address,uint64)bool"
	pushbytes 0xbec86c34 // method "block(uint64,bool,address)void"
	pushbytes 0x9f59a970 // method "unblock(uint64,bool,address)void"
	pushbytes 0x4303668e // method "isBlocked(address,address)bool"
	pushbytes 0x44e36da6 // method "subscribe(uint64,bool,address,uint64,uint64,uint64,uint64,uint64,byte[][])void"
	pushbytes 0x8471855c // method "triggerPayment(uint64,bool,uint64,byte[][])void"
	pushbytes 0xadb2c60e // method "streakCheck(address,uint64)void"
	pushbytes 0x1c42461b // method "setPasses(uint64,bool,uint64,address[])void"
	txna ApplicationArgs 0
	match *abi_route_getSubsriptionInfo *abi_route_newService *abi_route_pauseService *abi_route_activateService *abi_route_shutdownService *abi_route_isShutdown *abi_route_block *abi_route_unblock *abi_route_isBlocked *abi_route_subscribe *abi_route_triggerPayment *abi_route_streakCheck *abi_route_setPasses

	// this contract does not implement the given ABI method for call NoOp
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub