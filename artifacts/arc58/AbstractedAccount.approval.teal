#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 4 192
    bytecblock "p" "controlled_address" 0x00 "" "admin" 0x001b 0x151f7c75 0x0000000000000000 "d" "revocation_app" "n" 0x0000 "akita_dao" 0x0f885493 "version" "nickname"
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txn NumAppArgs
    bz main_after_if_else@28
    pushbytess 0xae2f66dd 0x1747405b 0xe500dfb6 0x9f91cccd 0x17d8bcb4 0x385658ab 0x5ef0b415 0xd24b7556 0x5fa449c6 0x13bc44e4 // method "createApplication(string,address,address,uint64,string)void", method "updateApplication(string)void", method "changeRevocationApp(uint64)void", method "setNickname(string)void", method "setAvatar(uint64)void", method "setBanner(uint64)void", method "setBio(string)void", method "arc58_changeAdmin(address)void", method "arc58_pluginChangeAdmin(uint64,address,address)void", method "arc58_getAdmin()address"
    bytec 13 // method "arc58_verifyAuthAddr()void"
    pushbytess 0xc95a5d3d 0x7699308f 0x3f8615d7 0x5c34f3d6 0x0a8a19d4 0x57a51d88 0x4d372355 0xea8bb9ec 0xe350b9d4 0x124c0a7f 0x33e92c94 // method "arc58_rekeyTo(address,bool)void", method "arc58_canCall(uint64,address,byte[4])bool", method "arc58_rekeyToPlugin(uint64,uint64[])void", method "arc58_rekeyToNamedPlugin(string,uint64[])void", method "arc58_addPlugin(uint64,address,uint64,uint64,bool,(byte[4],uint64)[])void", method "assignDomain(address,string)void", method "arc58_removePlugin(uint64,address)void", method "arc58_addNamedPlugin(string,uint64,address,uint64,uint64,bool,(byte[4],uint64)[])void", method "arc58_removeNamedPlugin(string)void", method "balance(uint64[])uint64[]", method "updateAkitaDAO(uint64)void"
    txna ApplicationArgs 0
    match main_createApplication_route@3 main_updateApplication_route@4 main_changeRevocationApp_route@5 main_setNickname_route@6 main_setAvatar_route@7 main_setBanner_route@8 main_setBio_route@9 main_arc58_changeAdmin_route@10 main_arc58_pluginChangeAdmin_route@11 main_arc58_getAdmin_route@12 main_arc58_verifyAuthAddr_route@13 main_arc58_rekeyTo_route@14 main_arc58_canCall_route@15 main_arc58_rekeyToPlugin_route@16 main_arc58_rekeyToNamedPlugin_route@17 main_arc58_addPlugin_route@18 main_assignDomain_route@19 main_arc58_removePlugin_route@20 main_arc58_addNamedPlugin_route@21 main_arc58_removeNamedPlugin_route@22 main_balance_route@23 main_updateAkitaDAO_route@24

main_after_if_else@28:
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    intc_0 // 0
    return

main_updateAkitaDAO_route@24:
    // utils/base_contracts/base.algo.ts:27
    // updateAkitaDAO(app: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    btoi
    // utils/base_contracts/base.algo.ts:27
    // updateAkitaDAO(app: uint64): void {
    callsub updateAkitaDAO
    intc_1 // 1
    return

main_balance_route@23:
    // contracts/arc58/abstracted_account.algo.ts:730
    // balance(assets: uint64[]): uint64[] {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    // contracts/arc58/abstracted_account.algo.ts:730
    // balance(assets: uint64[]): uint64[] {
    callsub balance
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc58_removeNamedPlugin_route@22:
    // contracts/arc58/abstracted_account.algo.ts:715
    // arc58_removeNamedPlugin(name: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/arc58/abstracted_account.algo.ts:715
    // arc58_removeNamedPlugin(name: string): void {
    callsub arc58_removeNamedPlugin
    intc_1 // 1
    return

main_arc58_addNamedPlugin_route@21:
    // contracts/arc58/abstracted_account.algo.ts:674-682
    // arc58_addNamedPlugin(
    //     name: string,
    //     app: uint64,
    //     allowedCaller: Address,
    //     lastValidRound: uint64,
    //     cooldown: uint64,
    //     adminPrivileges: boolean,
    //     methods: MethodRestriction[]
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    intc_0 // 0
    getbit
    txna ApplicationArgs 7
    // contracts/arc58/abstracted_account.algo.ts:674-682
    // arc58_addNamedPlugin(
    //     name: string,
    //     app: uint64,
    //     allowedCaller: Address,
    //     lastValidRound: uint64,
    //     cooldown: uint64,
    //     adminPrivileges: boolean,
    //     methods: MethodRestriction[]
    // ): void {
    callsub arc58_addNamedPlugin
    intc_1 // 1
    return

main_arc58_removePlugin_route@20:
    // contracts/arc58/abstracted_account.algo.ts:653
    // arc58_removePlugin(app: uint64, allowedCaller: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // contracts/arc58/abstracted_account.algo.ts:653
    // arc58_removePlugin(app: uint64, allowedCaller: Address): void {
    callsub arc58_removePlugin
    intc_1 // 1
    return

main_assignDomain_route@19:
    // contracts/arc58/abstracted_account.algo.ts:640
    // assignDomain(caller: Address, domain: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    extract 2 0
    // contracts/arc58/abstracted_account.algo.ts:640
    // assignDomain(caller: Address, domain: string): void {
    callsub assignDomain
    intc_1 // 1
    return

main_arc58_addPlugin_route@18:
    // contracts/arc58/abstracted_account.algo.ts:603-610
    // arc58_addPlugin(
    //     app: uint64,
    //     allowedCaller: Address,
    //     lastValidRound: uint64,
    //     cooldown: uint64,
    //     adminPrivileges: boolean,
    //     methods: MethodRestriction[]
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    intc_0 // 0
    getbit
    txna ApplicationArgs 6
    // contracts/arc58/abstracted_account.algo.ts:603-610
    // arc58_addPlugin(
    //     app: uint64,
    //     allowedCaller: Address,
    //     lastValidRound: uint64,
    //     cooldown: uint64,
    //     adminPrivileges: boolean,
    //     methods: MethodRestriction[]
    // ): void {
    callsub arc58_addPlugin
    intc_1 // 1
    return

main_arc58_rekeyToNamedPlugin_route@17:
    // contracts/arc58/abstracted_account.algo.ts:587
    // arc58_rekeyToNamedPlugin(name: string, methodOffsets: uint64[]): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    // contracts/arc58/abstracted_account.algo.ts:587
    // arc58_rekeyToNamedPlugin(name: string, methodOffsets: uint64[]): void {
    callsub arc58_rekeyToNamedPlugin
    intc_1 // 1
    return

main_arc58_rekeyToPlugin_route@16:
    // contracts/arc58/abstracted_account.algo.ts:566
    // arc58_rekeyToPlugin(plugin: uint64, methodOffsets: uint64[]): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // contracts/arc58/abstracted_account.algo.ts:566
    // arc58_rekeyToPlugin(plugin: uint64, methodOffsets: uint64[]): void {
    callsub arc58_rekeyToPlugin
    intc_1 // 1
    return

main_arc58_canCall_route@15:
    // contracts/arc58/abstracted_account.algo.ts:549
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // contracts/arc58/abstracted_account.algo.ts:549
    // @abimethod({ readonly: true })
    callsub arc58_canCall
    bytec_2 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc58_rekeyTo_route@14:
    // contracts/arc58/abstracted_account.algo.ts:526
    // arc58_rekeyTo(address: Address, flash: boolean): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    intc_0 // 0
    getbit
    // contracts/arc58/abstracted_account.algo.ts:526
    // arc58_rekeyTo(address: Address, flash: boolean): void {
    callsub arc58_rekeyTo
    intc_1 // 1
    return

main_arc58_verifyAuthAddr_route@13:
    // contracts/arc58/abstracted_account.algo.ts:516
    // arc58_verifyAuthAddr(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc58_verifyAuthAddr
    intc_1 // 1
    return

main_arc58_getAdmin_route@12:
    // contracts/arc58/abstracted_account.algo.ts:508
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc58_getAdmin
    bytec 6 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc58_pluginChangeAdmin_route@11:
    // contracts/arc58/abstracted_account.algo.ts:485
    // arc58_pluginChangeAdmin(plugin: uint64, allowedCaller: Address, newAdmin: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // contracts/arc58/abstracted_account.algo.ts:485
    // arc58_pluginChangeAdmin(plugin: uint64, allowedCaller: Address, newAdmin: Address): void {
    callsub arc58_pluginChangeAdmin
    intc_1 // 1
    return

main_arc58_changeAdmin_route@10:
    // contracts/arc58/abstracted_account.algo.ts:471
    // arc58_changeAdmin(newAdmin: Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    // contracts/arc58/abstracted_account.algo.ts:471
    // arc58_changeAdmin(newAdmin: Address): void {
    callsub arc58_changeAdmin
    intc_1 // 1
    return

main_setBio_route@9:
    // contracts/arc58/abstracted_account.algo.ts:461
    // setBio(bio: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/arc58/abstracted_account.algo.ts:461
    // setBio(bio: string): void {
    callsub setBio
    intc_1 // 1
    return

main_setBanner_route@8:
    // contracts/arc58/abstracted_account.algo.ts:449
    // setBanner(banner: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    btoi
    // contracts/arc58/abstracted_account.algo.ts:449
    // setBanner(banner: uint64): void {
    callsub setBanner
    intc_1 // 1
    return

main_setAvatar_route@7:
    // contracts/arc58/abstracted_account.algo.ts:437
    // setAvatar(avatar: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    btoi
    // contracts/arc58/abstracted_account.algo.ts:437
    // setAvatar(avatar: uint64): void {
    callsub setAvatar
    intc_1 // 1
    return

main_setNickname_route@6:
    // contracts/arc58/abstracted_account.algo.ts:427
    // setNickname(nickname: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/arc58/abstracted_account.algo.ts:427
    // setNickname(nickname: string): void {
    callsub setNickname
    intc_1 // 1
    return

main_changeRevocationApp_route@5:
    // contracts/arc58/abstracted_account.algo.ts:417
    // changeRevocationApp(newRevocationApp: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    btoi
    // contracts/arc58/abstracted_account.algo.ts:417
    // changeRevocationApp(newRevocationApp: uint64): void {
    callsub changeRevocationApp
    intc_1 // 1
    return

main_updateApplication_route@4:
    // contracts/arc58/abstracted_account.algo.ts:406
    // @abimethod({ allowActions: ['UpdateApplication'] })
    txn OnCompletion
    intc_3 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/arc58/abstracted_account.algo.ts:406
    // @abimethod({ allowActions: ['UpdateApplication'] })
    callsub updateApplication
    intc_1 // 1
    return

main_createApplication_route@3:
    // contracts/arc58/abstracted_account.algo.ts:379
    // @abimethod({ onCreate: 'require' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // contracts/arc58/abstracted_account.algo.ts:49
    // export class AbstractedAccount extends AkitaBaseContract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    extract 2 0
    // contracts/arc58/abstracted_account.algo.ts:379
    // @abimethod({ onCreate: 'require' })
    callsub createApplication
    intc_1 // 1
    return


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.isAdmin() -> uint64:
isAdmin:
    // contracts/arc58/abstracted_account.algo.ts:95
    // Txn.sender === this.admin.value ||
    txn Sender
    // contracts/arc58/constants.ts:1
    // export const AbstractAccountGlobalStateKeysAdmin = 'admin'
    intc_0 // 0
    bytec 4 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/arc58/abstracted_account.algo.ts:95
    // Txn.sender === this.admin.value ||
    ==
    // contracts/arc58/abstracted_account.algo.ts:95-96
    // Txn.sender === this.admin.value ||
    // (this.domainKeys(new Address(Txn.sender)).exists && this.domainKeys(new Address(Txn.sender)).value === AkitaDomain)
    bnz isAdmin_bool_true@3
    // contracts/arc58/constants.ts:11
    // export const AbstractAccountBoxPrefixDomainKeys = 'd'
    bytec 8 // "d"
    // contracts/arc58/abstracted_account.algo.ts:96
    // (this.domainKeys(new Address(Txn.sender)).exists && this.domainKeys(new Address(Txn.sender)).value === AkitaDomain)
    txn Sender
    // contracts/arc58/constants.ts:11
    // export const AbstractAccountBoxPrefixDomainKeys = 'd'
    concat
    // contracts/arc58/abstracted_account.algo.ts:96
    // (this.domainKeys(new Address(Txn.sender)).exists && this.domainKeys(new Address(Txn.sender)).value === AkitaDomain)
    box_len
    bury 1
    bz isAdmin_bool_false@4
    // contracts/arc58/constants.ts:11
    // export const AbstractAccountBoxPrefixDomainKeys = 'd'
    bytec 8 // "d"
    // contracts/arc58/abstracted_account.algo.ts:96
    // (this.domainKeys(new Address(Txn.sender)).exists && this.domainKeys(new Address(Txn.sender)).value === AkitaDomain)
    txn Sender
    // contracts/arc58/constants.ts:11
    // export const AbstractAccountBoxPrefixDomainKeys = 'd'
    concat
    // contracts/arc58/abstracted_account.algo.ts:96
    // (this.domainKeys(new Address(Txn.sender)).exists && this.domainKeys(new Address(Txn.sender)).value === AkitaDomain)
    box_get
    assert // Box must have value
    // utils/constants.ts:13
    // export const AkitaDomain: string = 'akita.community'
    pushbytes "akita.community"
    // contracts/arc58/abstracted_account.algo.ts:96
    // (this.domainKeys(new Address(Txn.sender)).exists && this.domainKeys(new Address(Txn.sender)).value === AkitaDomain)
    ==
    bz isAdmin_bool_false@4

isAdmin_bool_true@3:
    intc_1 // 1
    // contracts/arc58/abstracted_account.algo.ts:94-97
    // return (
    //     Txn.sender === this.admin.value ||
    //     (this.domainKeys(new Address(Txn.sender)).exists && this.domainKeys(new Address(Txn.sender)).value === AkitaDomain)
    // )
    retsub

isAdmin_bool_false@4:
    intc_0 // 0
    // contracts/arc58/abstracted_account.algo.ts:94-97
    // return (
    //     Txn.sender === this.admin.value ||
    //     (this.domainKeys(new Address(Txn.sender)).exists && this.domainKeys(new Address(Txn.sender)).value === AkitaDomain)
    // )
    retsub


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.canRevoke() -> uint64:
canRevoke:
    // contracts/arc58/abstracted_account.algo.ts:102
    // return Txn.sender === this.revocationApp.value.address
    txn Sender
    // contracts/constants.ts:4
    // export const GlobalStateKeyRevocationApp = 'revocation_app'
    intc_0 // 0
    bytec 9 // "revocation_app"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/arc58/abstracted_account.algo.ts:102
    // return Txn.sender === this.revocationApp.value.address
    app_params_get AppAddress
    assert // application exists
    ==
    retsub


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.pluginCallAllowed(key: bytes, method: bytes) -> uint64, bytes:
pluginCallAllowed:
    // contracts/arc58/abstracted_account.algo.ts:105
    // private pluginCallAllowed(key: arc4PluginsKey, method: StaticBytes<4>): boolean {
    proto 2 2
    intc_0 // 0
    dup
    bytec_3 // ""
    dupn 2
    // contracts/arc58/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig -2
    concat
    dup
    // contracts/arc58/abstracted_account.algo.ts:106
    // if (!this.plugins(key).exists) {
    box_len
    bury 1
    bnz pluginCallAllowed_after_if_else@2
    // contracts/arc58/abstracted_account.algo.ts:107
    // return false
    intc_0 // 0
    frame_dig -2
    frame_bury 1
    frame_bury 0
    retsub

pluginCallAllowed_after_if_else@2:
    // contracts/arc58/abstracted_account.algo.ts:110
    // const methods = this.plugins(key).value.methods.copy()
    frame_dig 5
    box_get
    assert // Box must have value
    dup
    pushint 25 // 25
    extract_uint16
    dig 1
    len
    substring3
    dup
    frame_bury 0
    // contracts/arc58/abstracted_account.algo.ts:111
    // let methodAllowed = !(methods.length > 0)
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 4
    intc_0 // 0
    >
    !
    frame_bury 3
    // contracts/arc58/abstracted_account.algo.ts:112
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0
    frame_bury 2

pluginCallAllowed_while_top@3:
    // contracts/arc58/abstracted_account.algo.ts:112
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig 2
    frame_dig 4
    <
    bz pluginCallAllowed_block@8
    // contracts/arc58/abstracted_account.algo.ts:113
    // if (methods[i].selector === method) {
    frame_dig 0
    extract 2 0
    frame_dig 2
    pushint 20 // 20
    *
    pushint 20 // 20
    extract3 // on error: Index access is out of bounds
    extract 0 4 // on error: Index access is out of bounds
    frame_dig -1
    ==
    bz pluginCallAllowed_after_if_else@6
    // contracts/arc58/abstracted_account.algo.ts:114
    // methodAllowed = true
    intc_1 // 1
    frame_bury 3

pluginCallAllowed_block@8:
    // contracts/arc58/abstracted_account.algo.ts:119
    // const p = this.plugins(key).value.copy()
    frame_dig 5
    box_get
    swap
    dup
    cover 2
    frame_bury 1
    assert // Box must have value
    // contracts/arc58/abstracted_account.algo.ts:121
    // p.lastValidRound.native >= Global.round &&
    intc_0 // 0
    extract_uint64
    global Round
    >=
    // contracts/arc58/abstracted_account.algo.ts:121-122
    // p.lastValidRound.native >= Global.round &&
    // Global.round - p.lastCalled.native >= p.cooldown.native &&
    bz pluginCallAllowed_bool_false@11
    // contracts/arc58/abstracted_account.algo.ts:122
    // Global.round - p.lastCalled.native >= p.cooldown.native &&
    global Round
    frame_dig 1
    dup
    cover 2
    pushint 16 // 16
    extract_uint64
    -
    swap
    intc_2 // 8
    extract_uint64
    >=
    // contracts/arc58/abstracted_account.algo.ts:121-122
    // p.lastValidRound.native >= Global.round &&
    // Global.round - p.lastCalled.native >= p.cooldown.native &&
    bz pluginCallAllowed_bool_false@11
    intc_1 // 1

pluginCallAllowed_bool_merge@12:
    // contracts/arc58/abstracted_account.algo.ts:121-123
    // p.lastValidRound.native >= Global.round &&
    // Global.round - p.lastCalled.native >= p.cooldown.native &&
    // methodAllowed
    frame_dig 3
    &&
    // contracts/arc58/abstracted_account.algo.ts:120-124
    // return (
    //     p.lastValidRound.native >= Global.round &&
    //     Global.round - p.lastCalled.native >= p.cooldown.native &&
    //     methodAllowed
    // )
    frame_dig -2
    frame_bury 1
    frame_bury 0
    retsub

pluginCallAllowed_bool_false@11:
    intc_0 // 0
    b pluginCallAllowed_bool_merge@12

pluginCallAllowed_after_if_else@6:
    // contracts/arc58/abstracted_account.algo.ts:112
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig 2
    intc_1 // 1
    +
    frame_bury 2
    b pluginCallAllowed_while_top@3


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.txnRekeysBack(txn: uint64) -> uint64:
txnRekeysBack:
    // contracts/arc58/abstracted_account.algo.ts:127
    // private txnRekeysBack(txn: gtxn.Transaction): boolean {
    proto 1 1
    // contracts/arc58/abstracted_account.algo.ts:128
    // if (txn.sender === Global.currentApplicationAddress && txn.rekeyTo === Global.currentApplicationAddress) {
    frame_dig -1
    gtxns Sender
    global CurrentApplicationAddress
    ==
    bz txnRekeysBack_after_if_else@3
    frame_dig -1
    gtxns RekeyTo
    global CurrentApplicationAddress
    ==
    bz txnRekeysBack_after_if_else@3
    // contracts/arc58/abstracted_account.algo.ts:129
    // return true
    intc_1 // 1
    retsub

txnRekeysBack_after_if_else@3:
    // contracts/arc58/abstracted_account.algo.ts:133
    // txn.type === TransactionType.ApplicationCall &&
    frame_dig -1
    gtxns TypeEnum
    pushint 6 // 6
    ==
    // contracts/arc58/abstracted_account.algo.ts:133-134
    // txn.type === TransactionType.ApplicationCall &&
    // txn.appId === Global.currentApplicationId &&
    bz txnRekeysBack_bool_false@9
    // contracts/arc58/abstracted_account.algo.ts:134
    // txn.appId === Global.currentApplicationId &&
    frame_dig -1
    gtxns ApplicationID
    global CurrentApplicationID
    ==
    // contracts/arc58/abstracted_account.algo.ts:133-134
    // txn.type === TransactionType.ApplicationCall &&
    // txn.appId === Global.currentApplicationId &&
    bz txnRekeysBack_bool_false@9
    // contracts/arc58/abstracted_account.algo.ts:135
    // txn.numAppArgs === 1 &&
    frame_dig -1
    gtxns NumAppArgs
    intc_1 // 1
    ==
    // contracts/arc58/abstracted_account.algo.ts:133-135
    // txn.type === TransactionType.ApplicationCall &&
    // txn.appId === Global.currentApplicationId &&
    // txn.numAppArgs === 1 &&
    bz txnRekeysBack_bool_false@9
    // contracts/arc58/abstracted_account.algo.ts:136
    // txn.onCompletion === OnCompleteAction.NoOp &&
    frame_dig -1
    gtxns OnCompletion
    // contracts/arc58/abstracted_account.algo.ts:133-136
    // txn.type === TransactionType.ApplicationCall &&
    // txn.appId === Global.currentApplicationId &&
    // txn.numAppArgs === 1 &&
    // txn.onCompletion === OnCompleteAction.NoOp &&
    bnz txnRekeysBack_bool_false@9
    // contracts/arc58/abstracted_account.algo.ts:137
    // txn.appArgs(0) === arc4.methodSelector('arc58_verifyAuthAddr()void')
    frame_dig -1
    intc_0 // 0
    gtxnsas ApplicationArgs
    bytec 13 // method "arc58_verifyAuthAddr()void"
    ==
    // contracts/arc58/abstracted_account.algo.ts:133-137
    // txn.type === TransactionType.ApplicationCall &&
    // txn.appId === Global.currentApplicationId &&
    // txn.numAppArgs === 1 &&
    // txn.onCompletion === OnCompleteAction.NoOp &&
    // txn.appArgs(0) === arc4.methodSelector('arc58_verifyAuthAddr()void')
    bz txnRekeysBack_bool_false@9
    intc_1 // 1
    // contracts/arc58/abstracted_account.algo.ts:132-138
    // return (
    //     txn.type === TransactionType.ApplicationCall &&
    //     txn.appId === Global.currentApplicationId &&
    //     txn.numAppArgs === 1 &&
    //     txn.onCompletion === OnCompleteAction.NoOp &&
    //     txn.appArgs(0) === arc4.methodSelector('arc58_verifyAuthAddr()void')
    // )
    retsub

txnRekeysBack_bool_false@9:
    intc_0 // 0
    // contracts/arc58/abstracted_account.algo.ts:132-138
    // return (
    //     txn.type === TransactionType.ApplicationCall &&
    //     txn.appId === Global.currentApplicationId &&
    //     txn.numAppArgs === 1 &&
    //     txn.onCompletion === OnCompleteAction.NoOp &&
    //     txn.appArgs(0) === arc4.methodSelector('arc58_verifyAuthAddr()void')
    // )
    retsub


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.pluginCheck(key: bytes) -> uint64, uint64, uint64, uint64, uint64, uint64, bytes:
pluginCheck:
    // contracts/arc58/abstracted_account.algo.ts:155
    // private pluginCheck(key: arc4PluginsKey): PluginValidation {
    proto 1 7
    bytec_3 // ""
    dupn 3
    // contracts/arc58/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig -1
    concat
    dup
    // contracts/arc58/abstracted_account.algo.ts:156
    // const exists = this.plugins(key).exists
    box_len
    dup
    uncover 2
    pop
    // contracts/arc58/abstracted_account.algo.ts:157
    // if (!exists) {
    bnz pluginCheck_after_if_else@2
    // contracts/arc58/abstracted_account.algo.ts:159
    // exists: false,
    intc_0 // 0
    // contracts/arc58/abstracted_account.algo.ts:160
    // expired: true,
    intc_1 // 1
    // contracts/arc58/abstracted_account.algo.ts:161-162
    // hasCooldown: true,
    // onCooldown: true,
    dupn 2
    // contracts/arc58/abstracted_account.algo.ts:163
    // hasMethodRestrictions: false,
    intc_0 // 0
    // contracts/arc58/abstracted_account.algo.ts:164
    // valid: false,
    dup
    // contracts/arc58/abstracted_account.algo.ts:158-165
    // return {
    //     exists: false,
    //     expired: true,
    //     hasCooldown: true,
    //     onCooldown: true,
    //     hasMethodRestrictions: false,
    //     valid: false,
    // }
    frame_dig -1
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    retsub

pluginCheck_after_if_else@2:
    // contracts/arc58/abstracted_account.algo.ts:168
    // const expired = Global.round > this.plugins(key).value.lastValidRound.native
    global Round
    frame_dig 4
    dup
    cover 2
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    >
    frame_bury 0
    // contracts/arc58/abstracted_account.algo.ts:169
    // const hasCooldown = this.plugins(key).value.cooldown.native > 0
    dup
    box_get
    assert // Box must have value
    intc_2 // 8
    extract_uint64
    intc_0 // 0
    >
    frame_bury 1
    // contracts/arc58/abstracted_account.algo.ts:171
    // Global.round - this.plugins(key).value.lastCalled.native < this.plugins(key).value.cooldown.native
    global Round
    dig 1
    box_get
    assert // Box must have value
    pushint 16 // 16
    extract_uint64
    -
    dig 1
    box_get
    assert // Box must have value
    intc_2 // 8
    extract_uint64
    <
    // contracts/arc58/abstracted_account.algo.ts:170-171
    // const onCooldown =
    //     Global.round - this.plugins(key).value.lastCalled.native < this.plugins(key).value.cooldown.native
    frame_bury 3
    // contracts/arc58/abstracted_account.algo.ts:172
    // const hasMethodRestrictions = this.plugins(key).value.methods.length > 0
    box_get
    assert // Box must have value
    dup
    pushint 25 // 25
    extract_uint16
    dig 1
    len
    substring3
    intc_0 // 0
    extract_uint16
    intc_0 // 0
    >
    frame_bury 2
    // contracts/arc58/abstracted_account.algo.ts:174
    // const valid = exists && !expired && !onCooldown
    frame_dig 5
    bz pluginCheck_bool_false@6
    frame_dig 0
    bnz pluginCheck_bool_false@6
    frame_dig 3
    bnz pluginCheck_bool_false@6
    intc_1 // 1

pluginCheck_bool_merge@7:
    // contracts/arc58/abstracted_account.algo.ts:176-183
    // return {
    //     exists,
    //     expired,
    //     hasCooldown,
    //     onCooldown,
    //     hasMethodRestrictions,
    //     valid,
    // }
    frame_dig 5
    frame_dig 0
    frame_dig 1
    frame_dig 3
    frame_dig 2
    uncover 5
    frame_dig -1
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    retsub

pluginCheck_bool_false@6:
    intc_0 // 0
    b pluginCheck_bool_merge@7


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.fullPluginCheck(key: bytes, txn: uint64, app: uint64, caller: bytes, methodOffsets: bytes, methodIndex: uint64) -> uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, bytes:
fullPluginCheck:
    // contracts/arc58/abstracted_account.algo.ts:186-193
    // private fullPluginCheck(
    //     key: arc4PluginsKey,
    //     txn: gtxn.ApplicationCallTxn,
    //     app: Application,
    //     caller: Account,
    //     methodOffsets: uint64[],
    //     methodIndex: uint64
    // ): FullPluginValidation {
    proto 6 10
    intc_0 // 0
    dupn 2
    bytec_3 // ""
    dupn 7
    // contracts/arc58/abstracted_account.algo.ts:194
    // const check = this.pluginCheck(key)
    frame_dig -6
    callsub pluginCheck
    frame_bury -6
    dup
    cover 6
    cover 6
    cover 5
    cover 4
    cover 3
    cover 2
    swap
    // contracts/arc58/abstracted_account.algo.ts:196
    // if (!check.valid) {
    bnz fullPluginCheck_after_if_else@4
    // contracts/arc58/abstracted_account.algo.ts:197-202
    // return {
    //     ...check,
    //     methodAllowed: false,
    //     methodHasCooldown: true,
    //     methodOnCooldown: true,
    // }
    frame_dig 16
    frame_dig 15
    frame_dig 14
    frame_dig 13
    frame_dig 12
    // contracts/arc58/abstracted_account.algo.ts:199
    // methodAllowed: false,
    intc_0 // 0
    // contracts/arc58/abstracted_account.algo.ts:200
    // methodHasCooldown: true,
    intc_1 // 1
    // contracts/arc58/abstracted_account.algo.ts:201
    // methodOnCooldown: true,
    dup
    // contracts/arc58/abstracted_account.algo.ts:197-202
    // return {
    //     ...check,
    //     methodAllowed: false,
    //     methodHasCooldown: true,
    //     methodOnCooldown: true,
    // }
    frame_dig 11
    frame_dig -6
    frame_bury 9
    frame_bury 8
    frame_bury 7
    frame_bury 6
    frame_bury 5
    frame_bury 4
    frame_bury 3
    frame_bury 2
    frame_bury 1
    frame_bury 0
    retsub

fullPluginCheck_after_if_else@4:
    // contracts/arc58/abstracted_account.algo.ts:206
    // methodAllowed: !check.hasMethodRestrictions,
    frame_dig 12
    dup
    !
    frame_bury 5
    // contracts/arc58/abstracted_account.algo.ts:207
    // methodHasCooldown: false,
    intc_0 // 0
    // contracts/arc58/abstracted_account.algo.ts:205-209
    // let methodCheck: MethodValidation = {
    //     methodAllowed: !check.hasMethodRestrictions,
    //     methodHasCooldown: false,
    //     methodOnCooldown: false,
    // }
    frame_bury 6
    // contracts/arc58/abstracted_account.algo.ts:208
    // methodOnCooldown: false,
    intc_0 // 0
    // contracts/arc58/abstracted_account.algo.ts:205-209
    // let methodCheck: MethodValidation = {
    //     methodAllowed: !check.hasMethodRestrictions,
    //     methodHasCooldown: false,
    //     methodOnCooldown: false,
    // }
    frame_bury 7
    // contracts/arc58/abstracted_account.algo.ts:211
    // if (check.hasMethodRestrictions) {
    bz fullPluginCheck_after_if_else@6
    // contracts/arc58/abstracted_account.algo.ts:212
    // assert(methodIndex < methodOffsets.length, 'malformed methodOffsets')
    frame_dig -2
    intc_0 // 0
    extract_uint16
    frame_dig -1
    >
    assert // malformed methodOffsets
    // contracts/arc58/abstracted_account.algo.ts:213
    // methodCheck = this.methodCheck(txn, app, caller, methodOffsets[methodIndex])
    frame_dig -2
    extract 2 0
    frame_dig -1
    intc_2 // 8
    *
    extract_uint64
    dup
    frame_bury 8
    // contracts/arc58/abstracted_account.algo.ts:323
    // assert(len(txn.appArgs(0)) === 4, 'invalid method signature length')
    frame_dig -5
    intc_0 // 0
    gtxnsas ApplicationArgs
    dup
    len
    dup
    intc_3 // 4
    ==
    assert // invalid method signature length
    // contracts/arc58/abstracted_account.algo.ts:324
    // const selectorArg = new arc4.StaticBytes<4>(txn.appArgs(0))
    intc_3 // 4
    ==
    assert // Length is 4
    // contracts/arc58/abstracted_account.algo.ts:326
    // const key = new arc4PluginsKey({ application: new UintN64(app.id), allowedCaller: new Address(caller) })
    frame_dig -4
    itob
    frame_dig -3
    concat
    // contracts/arc58/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    swap
    concat
    dup
    frame_bury 2
    // contracts/arc58/abstracted_account.algo.ts:328
    // const methods = this.plugins(key).value.methods.copy()
    box_get
    assert // Box must have value
    dup
    pushint 25 // 25
    extract_uint16
    dig 1
    len
    substring3
    dup
    frame_bury 1
    // contracts/arc58/abstracted_account.algo.ts:329
    // const allowedMethod = methods[offset].copy()
    extract 2 0
    uncover 2
    pushint 20 // 20
    *
    dup
    frame_bury 4
    pushint 20 // 20
    extract3 // on error: Index access is out of bounds
    dup
    frame_bury 0
    // contracts/arc58/abstracted_account.algo.ts:331
    // const hasCooldown = allowedMethod.cooldown.native > 0
    dup
    intc_3 // 4
    extract_uint64
    dup
    frame_bury 10
    dup
    intc_0 // 0
    >
    frame_bury 3
    // contracts/arc58/abstracted_account.algo.ts:332
    // const onCooldown = Global.round - allowedMethod.lastCalled.native < allowedMethod.cooldown.native
    global Round
    dig 2
    pushint 12 // 12
    extract_uint64
    -
    >
    frame_bury 9
    // contracts/arc58/abstracted_account.algo.ts:334
    // if (allowedMethod.selector === selectorArg && (!hasCooldown || !onCooldown)) {
    extract 0 4 // on error: Index access is out of bounds
    ==
    bz fullPluginCheck_after_if_else@17
    frame_dig 10
    bz fullPluginCheck_if_body@14
    frame_dig 9
    bnz fullPluginCheck_after_if_else@17

fullPluginCheck_if_body@14:
    // contracts/arc58/abstracted_account.algo.ts:336
    // if (hasCooldown) {
    frame_dig 10
    bz fullPluginCheck_after_if_else@16
    // contracts/arc58/abstracted_account.algo.ts:337
    // methods[offset].lastCalled = new UintN64(Global.round)
    global Round
    itob
    frame_dig 0
    swap
    replace2 12
    frame_dig 1
    dup
    intc_0 // 0
    extract_uint16
    frame_dig 8
    >
    assert // Index access is out of bounds
    frame_dig 4
    pushint 2 // 2
    +
    uncover 2
    replace3
    // contracts/arc58/abstracted_account.algo.ts:339
    // ...this.plugins(key).value,
    frame_dig 2
    dup
    box_get
    assert // Box must have value
    // contracts/arc58/abstracted_account.algo.ts:338-341
    // this.plugins(key).value = new arc4PluginInfo({
    //     ...this.plugins(key).value,
    //     methods: methods.copy(),
    // })
    extract 0 8 // on error: Index access is out of bounds
    // contracts/arc58/abstracted_account.algo.ts:339
    // ...this.plugins(key).value,
    dig 1
    box_get
    assert // Box must have value
    // contracts/arc58/abstracted_account.algo.ts:338-341
    // this.plugins(key).value = new arc4PluginInfo({
    //     ...this.plugins(key).value,
    //     methods: methods.copy(),
    // })
    extract 8 8 // on error: Index access is out of bounds
    // contracts/arc58/abstracted_account.algo.ts:339
    // ...this.plugins(key).value,
    dig 2
    box_get
    assert // Box must have value
    // contracts/arc58/abstracted_account.algo.ts:338-341
    // this.plugins(key).value = new arc4PluginInfo({
    //     ...this.plugins(key).value,
    //     methods: methods.copy(),
    // })
    extract 16 8 // on error: Index access is out of bounds
    // contracts/arc58/abstracted_account.algo.ts:339
    // ...this.plugins(key).value,
    dig 3
    box_get
    assert // Box must have value
    // contracts/arc58/abstracted_account.algo.ts:338-341
    // this.plugins(key).value = new arc4PluginInfo({
    //     ...this.plugins(key).value,
    //     methods: methods.copy(),
    // })
    intc 4 // 192
    getbit
    bytec_2 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    uncover 3
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec 5 // 0x001b
    concat
    uncover 2
    concat
    dig 1
    box_del
    pop
    box_put

fullPluginCheck_after_if_else@16:
    // contracts/arc58/abstracted_account.algo.ts:345
    // methodAllowed: true,
    intc_1 // 1
    frame_dig 9
    frame_bury 7
    frame_dig 3
    frame_bury 6
    frame_bury 5

fullPluginCheck_after_if_else@6:
    // contracts/arc58/abstracted_account.algo.ts:219
    // valid: check.valid && methodCheck.methodAllowed,
    frame_dig 11
    bz fullPluginCheck_bool_false@9
    frame_dig 5
    bz fullPluginCheck_bool_false@9
    intc_1 // 1

fullPluginCheck_bool_merge@10:
    // contracts/arc58/abstracted_account.algo.ts:216-220
    // return {
    //     ...check,
    //     ...methodCheck,
    //     valid: check.valid && methodCheck.methodAllowed,
    // }
    frame_dig 16
    frame_dig 15
    frame_dig 14
    frame_dig 13
    frame_dig 12
    frame_dig 5
    frame_dig 6
    frame_dig 7
    uncover 8
    frame_dig -6
    frame_bury 9
    frame_bury 8
    frame_bury 7
    frame_bury 6
    frame_bury 5
    frame_bury 4
    frame_bury 3
    frame_bury 2
    frame_bury 1
    frame_bury 0
    retsub

fullPluginCheck_bool_false@9:
    intc_0 // 0
    b fullPluginCheck_bool_merge@10

fullPluginCheck_after_if_else@17:
    // contracts/arc58/abstracted_account.algo.ts:352
    // methodAllowed: false,
    intc_0 // 0
    // contracts/arc58/abstracted_account.algo.ts:353
    // methodHasCooldown: true,
    intc_1 // 1
    // contracts/arc58/abstracted_account.algo.ts:354
    // methodOnCooldown: true,
    dup
    frame_bury 7
    frame_bury 6
    frame_bury 5
    // contracts/arc58/abstracted_account.algo.ts:213
    // methodCheck = this.methodCheck(txn, app, caller, methodOffsets[methodIndex])
    b fullPluginCheck_after_if_else@6


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.createApplication(version: bytes, controlledAddress: bytes, admin: bytes, revocationApp: uint64, nickname: bytes) -> void:
createApplication:
    // contracts/arc58/abstracted_account.algo.ts:379-386
    // @abimethod({ onCreate: 'require' })
    // createApplication(
    //     version: string,
    //     controlledAddress: Address,
    //     admin: Address,
    //     revocationApp: uint64,
    //     nickname: string
    // ) {
    proto 5 0
    // contracts/arc58/abstracted_account.algo.ts:387
    // assert(Global.callerApplicationId !== 0, ERR_BAD_DEPLOYER)
    global CallerApplicationID
    assert // This contract must be deployed from a factory
    // contracts/arc58/abstracted_account.algo.ts:388
    // assert(admin !== controlledAddress)
    frame_dig -3
    frame_dig -4
    !=
    assert
    // contracts/constants.ts:2
    // export const GlobalStateKeyVersion = 'version'
    bytec 14 // "version"
    // contracts/arc58/abstracted_account.algo.ts:390
    // this.version.value = version
    frame_dig -5
    app_global_put
    // contracts/arc58/abstracted_account.algo.ts:392
    // controlledAddress.native === Global.zeroAddress
    frame_dig -4
    global ZeroAddress
    ==
    // contracts/arc58/abstracted_account.algo.ts:392-394
    // controlledAddress.native === Global.zeroAddress
    //     ? Global.currentApplicationAddress
    //     : controlledAddress.native
    bz createApplication_ternary_false@2
    // contracts/arc58/abstracted_account.algo.ts:393
    // ? Global.currentApplicationAddress
    global CurrentApplicationAddress

createApplication_ternary_merge@3:
    // contracts/arc58/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    bytec_1 // "controlled_address"
    // contracts/arc58/abstracted_account.algo.ts:391-394
    // this.controlledAddress.value =
    //     controlledAddress.native === Global.zeroAddress
    //         ? Global.currentApplicationAddress
    //         : controlledAddress.native
    swap
    app_global_put
    // contracts/arc58/constants.ts:1
    // export const AbstractAccountGlobalStateKeysAdmin = 'admin'
    bytec 4 // "admin"
    // contracts/arc58/abstracted_account.algo.ts:395
    // this.admin.value = admin.native
    frame_dig -3
    app_global_put
    // contracts/constants.ts:4
    // export const GlobalStateKeyRevocationApp = 'revocation_app'
    bytec 9 // "revocation_app"
    // contracts/arc58/abstracted_account.algo.ts:396
    // this.revocationApp.value = Application(revocationApp)
    frame_dig -2
    app_global_put
    // contracts/arc58/constants.ts:4
    // export const AbstractAccountGlobalStateKeysNickname = 'nickname'
    bytec 15 // "nickname"
    // contracts/arc58/abstracted_account.algo.ts:397
    // this.nickname.value = nickname
    frame_dig -1
    app_global_put
    // contracts/arc58/constants.ts:3
    // export const AbstractAccountGlobalStateKeysFactoryApp = 'factory_app'
    pushbytes "factory_app"
    // contracts/arc58/abstracted_account.algo.ts:398
    // this.factoryApp.value = Application(Global.callerApplicationId)
    global CallerApplicationID
    app_global_put
    retsub

createApplication_ternary_false@2:
    frame_dig -4
    b createApplication_ternary_merge@3


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.updateApplication(version: bytes) -> void:
updateApplication:
    // contracts/arc58/abstracted_account.algo.ts:406-407
    // @abimethod({ allowActions: ['UpdateApplication'] })
    // updateApplication(version: string): void {
    proto 1 0
    // contracts/arc58/abstracted_account.algo.ts:408
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_UPDATE)
    callsub isAdmin
    assert // Only an admin can update the application
    // contracts/constants.ts:2
    // export const GlobalStateKeyVersion = 'version'
    bytec 14 // "version"
    // contracts/arc58/abstracted_account.algo.ts:409
    // this.version.value = version
    frame_dig -1
    app_global_put
    retsub


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.changeRevocationApp(newRevocationApp: uint64) -> void:
changeRevocationApp:
    // contracts/arc58/abstracted_account.algo.ts:417
    // changeRevocationApp(newRevocationApp: uint64): void {
    proto 1 0
    // contracts/arc58/abstracted_account.algo.ts:418
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_REVOKE)
    callsub isAdmin
    assert // Only an admin can change the revocation app
    // contracts/constants.ts:4
    // export const GlobalStateKeyRevocationApp = 'revocation_app'
    bytec 9 // "revocation_app"
    // contracts/arc58/abstracted_account.algo.ts:419
    // this.revocationApp.value = Application(newRevocationApp)
    frame_dig -1
    app_global_put
    retsub


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.setNickname(nickname: bytes) -> void:
setNickname:
    // contracts/arc58/abstracted_account.algo.ts:427
    // setNickname(nickname: string): void {
    proto 1 0
    // contracts/arc58/abstracted_account.algo.ts:428
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_NICKNAME)
    callsub isAdmin
    assert // Only an admin can change the nickname
    // contracts/arc58/constants.ts:4
    // export const AbstractAccountGlobalStateKeysNickname = 'nickname'
    bytec 15 // "nickname"
    // contracts/arc58/abstracted_account.algo.ts:429
    // this.nickname.value = nickname
    frame_dig -1
    app_global_put
    retsub


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.setAvatar(avatar: uint64) -> void:
setAvatar:
    // contracts/arc58/abstracted_account.algo.ts:437
    // setAvatar(avatar: uint64): void {
    proto 1 0
    // contracts/arc58/abstracted_account.algo.ts:438
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_NICKNAME)
    callsub isAdmin
    assert // Only an admin can change the nickname
    // contracts/arc58/abstracted_account.algo.ts:439
    // const amount = this.balance([avatar])
    frame_dig -1
    itob
    dup
    len
    intc_2 // 8
    /
    itob
    extract 6 2
    swap
    concat
    callsub balance
    pushint 2 // 2
    // contracts/arc58/abstracted_account.algo.ts:440
    // assert(amount[0] > 0, ERR_DOES_NOT_HOLD_ASSET)
    extract_uint64
    assert // The account does not hold the asset
    // contracts/arc58/constants.ts:5
    // export const AbstractAccountGlobalStateKeysAvatar = 'avatar'
    pushbytes "avatar"
    // contracts/arc58/abstracted_account.algo.ts:441
    // this.avatar.value = Asset(avatar)
    frame_dig -1
    app_global_put
    retsub


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.setBanner(banner: uint64) -> void:
setBanner:
    // contracts/arc58/abstracted_account.algo.ts:449
    // setBanner(banner: uint64): void {
    proto 1 0
    // contracts/arc58/abstracted_account.algo.ts:450
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_NICKNAME)
    callsub isAdmin
    assert // Only an admin can change the nickname
    // contracts/arc58/abstracted_account.algo.ts:451
    // const amount = this.balance([banner])
    frame_dig -1
    itob
    dup
    len
    intc_2 // 8
    /
    itob
    extract 6 2
    swap
    concat
    callsub balance
    pushint 2 // 2
    // contracts/arc58/abstracted_account.algo.ts:452
    // assert(amount[0] > 0, ERR_DOES_NOT_HOLD_ASSET)
    extract_uint64
    assert // The account does not hold the asset
    // contracts/arc58/constants.ts:6
    // export const AbstractAccountGlobalStateKeysBanner = 'banner'
    pushbytes "banner"
    // contracts/arc58/abstracted_account.algo.ts:453
    // this.banner.value = Asset(banner)
    frame_dig -1
    app_global_put
    retsub


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.setBio(bio: bytes) -> void:
setBio:
    // contracts/arc58/abstracted_account.algo.ts:461
    // setBio(bio: string): void {
    proto 1 0
    // contracts/arc58/abstracted_account.algo.ts:462
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_CHANGE_NICKNAME)
    callsub isAdmin
    assert // Only an admin can change the nickname
    // contracts/arc58/constants.ts:7
    // export const AbstractAccountGlobalStateKeysBio = 'bio'
    pushbytes "bio"
    // contracts/arc58/abstracted_account.algo.ts:463
    // this.bio.value = bio
    frame_dig -1
    app_global_put
    retsub


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.arc58_changeAdmin(newAdmin: bytes) -> void:
arc58_changeAdmin:
    // contracts/arc58/abstracted_account.algo.ts:471
    // arc58_changeAdmin(newAdmin: Address): void {
    proto 1 0
    // contracts/arc58/abstracted_account.algo.ts:473
    // assert(this.isAdmin(), 'Sender must be the admin')
    callsub isAdmin
    assert // Sender must be the admin
    // contracts/arc58/constants.ts:1
    // export const AbstractAccountGlobalStateKeysAdmin = 'admin'
    bytec 4 // "admin"
    // contracts/arc58/abstracted_account.algo.ts:474
    // this.admin.value = newAdmin.native
    frame_dig -1
    app_global_put
    retsub


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.arc58_pluginChangeAdmin(plugin: uint64, allowedCaller: bytes, newAdmin: bytes) -> void:
arc58_pluginChangeAdmin:
    // contracts/arc58/abstracted_account.algo.ts:485
    // arc58_pluginChangeAdmin(plugin: uint64, allowedCaller: Address, newAdmin: Address): void {
    proto 3 0
    // contracts/arc58/abstracted_account.algo.ts:487
    // assert(Txn.sender === Application(plugin).address, 'Sender must be the plugin')
    txn Sender
    frame_dig -3
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Sender must be the plugin
    // contracts/arc58/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/arc58/abstracted_account.algo.ts:489
    // this.controlledAddress.value.authAddress === Application(plugin).address,
    acct_params_get AcctAuthAddr
    assert // account funded
    frame_dig -3
    app_params_get AppAddress
    assert // application exists
    ==
    // contracts/arc58/abstracted_account.algo.ts:488-491
    // assert(
    //     this.controlledAddress.value.authAddress === Application(plugin).address,
    //     'This plugin is not in control of the account'
    // )
    assert // This plugin is not in control of the account
    // contracts/arc58/abstracted_account.algo.ts:46
    // return new arc4PluginsKey({ application: new UintN64(app), allowedCaller: caller })
    frame_dig -3
    itob
    frame_dig -2
    concat
    // contracts/arc58/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    swap
    concat
    dup
    // contracts/arc58/abstracted_account.algo.ts:496
    // this.plugins(key).exists && this.plugins(key).value.adminPrivileges.native,
    box_len
    bury 1
    bz arc58_pluginChangeAdmin_bool_false@3
    frame_dig 0
    box_get
    assert // Box must have value
    intc 4 // 192
    getbit
    bytec_2 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    bz arc58_pluginChangeAdmin_bool_false@3
    intc_1 // 1

arc58_pluginChangeAdmin_bool_merge@4:
    // contracts/arc58/abstracted_account.algo.ts:495-498
    // assert(
    //     this.plugins(key).exists && this.plugins(key).value.adminPrivileges.native,
    //     'This plugin does not have admin privileges'
    // )
    assert // This plugin does not have admin privileges
    // contracts/arc58/constants.ts:1
    // export const AbstractAccountGlobalStateKeysAdmin = 'admin'
    bytec 4 // "admin"
    // contracts/arc58/abstracted_account.algo.ts:500
    // this.admin.value = newAdmin.native
    frame_dig -1
    app_global_put
    retsub

arc58_pluginChangeAdmin_bool_false@3:
    intc_0 // 0
    b arc58_pluginChangeAdmin_bool_merge@4


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.arc58_getAdmin() -> bytes:
arc58_getAdmin:
    // contracts/arc58/constants.ts:1
    // export const AbstractAccountGlobalStateKeysAdmin = 'admin'
    intc_0 // 0
    bytec 4 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/arc58/abstracted_account.algo.ts:510
    // return new Address(this.admin.value)
    retsub


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.arc58_verifyAuthAddr() -> void:
arc58_verifyAuthAddr:
    // contracts/arc58/abstracted_account.algo.ts:516
    // arc58_verifyAuthAddr(): void {
    proto 0 0
    // contracts/arc58/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/arc58/abstracted_account.algo.ts:517
    // assert(this.controlledAddress.value.authAddress === this.getAuthAddr())
    acct_params_get AcctAuthAddr
    assert // account funded
    // contracts/arc58/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/arc58/abstracted_account.algo.ts:363
    // return this.controlledAddress.value === Global.currentApplicationAddress
    global CurrentApplicationAddress
    ==
    // contracts/arc58/abstracted_account.algo.ts:363-365
    // return this.controlledAddress.value === Global.currentApplicationAddress
    //     ? Global.zeroAddress // contract controls itself
    //     : Global.currentApplicationAddress // contract controls a different account
    bz arc58_verifyAuthAddr_ternary_false@3
    // contracts/arc58/abstracted_account.algo.ts:364
    // ? Global.zeroAddress // contract controls itself
    global ZeroAddress

arc58_verifyAuthAddr_ternary_merge@4:
    // contracts/arc58/abstracted_account.algo.ts:517
    // assert(this.controlledAddress.value.authAddress === this.getAuthAddr())
    frame_dig 0
    ==
    assert
    retsub

arc58_verifyAuthAddr_ternary_false@3:
    // contracts/arc58/abstracted_account.algo.ts:365
    // : Global.currentApplicationAddress // contract controls a different account
    global CurrentApplicationAddress
    b arc58_verifyAuthAddr_ternary_merge@4


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyTo(address: bytes, flash: uint64) -> void:
arc58_rekeyTo:
    // contracts/arc58/abstracted_account.algo.ts:526
    // arc58_rekeyTo(address: Address, flash: boolean): void {
    proto 2 0
    bytec_3 // ""
    dup
    // contracts/arc58/abstracted_account.algo.ts:528
    // assert(this.isAdmin(), 'Sender must be the admin')
    callsub isAdmin
    assert // Sender must be the admin
    // contracts/arc58/abstracted_account.algo.ts:530-536
    // itxn.payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address.native,
    //     rekeyTo: address.native,
    //     note: 'rekeying abstracted account',
    //     fee: 0,
    // }).submit()
    itxn_begin
    // contracts/arc58/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/arc58/abstracted_account.algo.ts:534
    // note: 'rekeying abstracted account',
    pushbytes "rekeying abstracted account"
    itxn_field Note
    frame_dig -2
    itxn_field RekeyTo
    frame_dig -2
    itxn_field Receiver
    itxn_field Sender
    // contracts/arc58/abstracted_account.algo.ts:530-536
    // itxn.payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address.native,
    //     rekeyTo: address.native,
    //     note: 'rekeying abstracted account',
    //     fee: 0,
    // }).submit()
    intc_1 // 1
    itxn_field TypeEnum
    // contracts/arc58/abstracted_account.algo.ts:535
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // contracts/arc58/abstracted_account.algo.ts:530-536
    // itxn.payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address.native,
    //     rekeyTo: address.native,
    //     note: 'rekeying abstracted account',
    //     fee: 0,
    // }).submit()
    itxn_submit
    // contracts/arc58/abstracted_account.algo.ts:538
    // if (flash) this.assertRekeysBack()
    frame_dig -1
    bz arc58_rekeyTo_after_if_else@3
    // contracts/arc58/abstracted_account.algo.ts:142
    // let rekeysBack = false
    intc_0 // 0
    frame_bury 1
    // contracts/arc58/abstracted_account.algo.ts:143
    // for (let i: uint64 = Txn.groupIndex + 1; i < Global.groupSize; i += 1) {
    txn GroupIndex
    intc_1 // 1
    +
    frame_bury 0

arc58_rekeyTo_while_top@5:
    // contracts/arc58/abstracted_account.algo.ts:143
    // for (let i: uint64 = Txn.groupIndex + 1; i < Global.groupSize; i += 1) {
    frame_dig 0
    global GroupSize
    <
    bz arc58_rekeyTo_block@10
    // contracts/arc58/abstracted_account.algo.ts:146
    // if (this.txnRekeysBack(txn)) {
    frame_dig 0
    callsub txnRekeysBack
    bz arc58_rekeyTo_after_if_else@8
    // contracts/arc58/abstracted_account.algo.ts:147
    // rekeysBack = true
    intc_1 // 1
    frame_bury 1

arc58_rekeyTo_block@10:
    // contracts/arc58/abstracted_account.algo.ts:152
    // assert(rekeysBack, 'rekey back not found')
    frame_dig 1
    assert // rekey back not found

arc58_rekeyTo_after_if_else@3:
    retsub

arc58_rekeyTo_after_if_else@8:
    // contracts/arc58/abstracted_account.algo.ts:143
    // for (let i: uint64 = Txn.groupIndex + 1; i < Global.groupSize; i += 1) {
    frame_dig 0
    intc_1 // 1
    +
    frame_bury 0
    b arc58_rekeyTo_while_top@5


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.arc58_canCall(plugin: uint64, caller: bytes, method: bytes) -> uint64:
arc58_canCall:
    // contracts/arc58/abstracted_account.algo.ts:549-550
    // @abimethod({ readonly: true })
    // arc58_canCall(plugin: uint64, caller: Address, method: StaticBytes<4>): boolean {
    proto 3 1
    // contracts/arc58/abstracted_account.algo.ts:46
    // return new arc4PluginsKey({ application: new UintN64(app), allowedCaller: caller })
    frame_dig -3
    itob
    frame_dig -2
    concat
    dup
    // contracts/arc58/abstracted_account.algo.ts:551
    // const globalAllowed = this.pluginCallAllowed(pluginsKey(plugin, caller), method)
    frame_dig -1
    callsub pluginCallAllowed
    pop
    // contracts/arc58/abstracted_account.algo.ts:552
    // if (globalAllowed) return true
    bz arc58_canCall_after_if_else@2
    intc_1 // 1
    swap
    retsub

arc58_canCall_after_if_else@2:
    // contracts/arc58/abstracted_account.algo.ts:554
    // return this.pluginCallAllowed(pluginsKey(plugin, caller), method)
    frame_dig 0
    frame_dig -1
    callsub pluginCallAllowed
    pop
    swap
    retsub


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyToPlugin(plugin: uint64, methodOffsets: bytes) -> void:
arc58_rekeyToPlugin:
    // contracts/arc58/abstracted_account.algo.ts:566
    // arc58_rekeyToPlugin(plugin: uint64, methodOffsets: uint64[]): void {
    proto 2 0
    bytec_3 // ""
    dupn 7
    // contracts/arc58/abstracted_account.algo.ts:231
    // application: new UintN64(plugin.id),
    frame_dig -2
    itob
    // contracts/arc58/abstracted_account.algo.ts:230-233
    // const gKey = new arc4PluginsKey({
    //     application: new UintN64(plugin.id),
    //     allowedCaller: new Address(Global.zeroAddress),
    // })
    dup
    // contracts/arc58/abstracted_account.algo.ts:232
    // allowedCaller: new Address(Global.zeroAddress),
    global ZeroAddress
    // contracts/arc58/abstracted_account.algo.ts:230-233
    // const gKey = new arc4PluginsKey({
    //     application: new UintN64(plugin.id),
    //     allowedCaller: new Address(Global.zeroAddress),
    // })
    concat
    // contracts/arc58/abstracted_account.algo.ts:235
    // const globalCheck = this.pluginCheck(gKey)
    callsub pluginCheck
    cover 7
    cover 6
    pop
    cover 4
    pop
    cover 2
    swap
    // contracts/arc58/abstracted_account.algo.ts:239
    // allowedCaller: new Address(Txn.sender),
    txn Sender
    // contracts/arc58/abstracted_account.algo.ts:237-240
    // const lKey = new arc4PluginsKey({
    //     application: new UintN64(plugin.id),
    //     allowedCaller: new Address(Txn.sender),
    // })
    concat
    // contracts/arc58/abstracted_account.algo.ts:242
    // const localCheck = this.pluginCheck(lKey)
    callsub pluginCheck
    cover 7
    cover 6
    pop
    cover 4
    pop
    cover 2
    swap
    // contracts/arc58/abstracted_account.algo.ts:244
    // assert(globalCheck.exists || localCheck.exists, 'plugin not found')
    bnz arc58_rekeyToPlugin_bool_true@4
    frame_dig 16
    bz arc58_rekeyToPlugin_bool_false@5

arc58_rekeyToPlugin_bool_true@4:
    intc_1 // 1

arc58_rekeyToPlugin_bool_merge@6:
    // contracts/arc58/abstracted_account.algo.ts:244
    // assert(globalCheck.exists || localCheck.exists, 'plugin not found')
    assert // plugin not found
    // contracts/arc58/abstracted_account.algo.ts:245
    // assert(!globalCheck.expired || !localCheck.expired, 'plugin expired')
    frame_dig 11
    bz arc58_rekeyToPlugin_bool_true@8
    frame_dig 15
    bnz arc58_rekeyToPlugin_bool_false@9

arc58_rekeyToPlugin_bool_true@8:
    intc_1 // 1

arc58_rekeyToPlugin_bool_merge@10:
    // contracts/arc58/abstracted_account.algo.ts:245
    // assert(!globalCheck.expired || !localCheck.expired, 'plugin expired')
    assert // plugin expired
    // contracts/arc58/abstracted_account.algo.ts:246
    // assert(!globalCheck.onCooldown || !localCheck.onCooldown, 'plugin on cooldown')
    frame_dig 10
    bz arc58_rekeyToPlugin_bool_true@12
    frame_dig 14
    bnz arc58_rekeyToPlugin_bool_false@13

arc58_rekeyToPlugin_bool_true@12:
    intc_1 // 1

arc58_rekeyToPlugin_bool_merge@14:
    // contracts/arc58/abstracted_account.algo.ts:246
    // assert(!globalCheck.onCooldown || !localCheck.onCooldown, 'plugin on cooldown')
    assert // plugin on cooldown
    // contracts/arc58/abstracted_account.algo.ts:251
    // assert(globalCheck.valid || localCheck.valid, 'invalid plugin call')
    frame_dig 9
    bnz arc58_rekeyToPlugin_bool_true@16
    frame_dig 13
    bz arc58_rekeyToPlugin_bool_false@17

arc58_rekeyToPlugin_bool_true@16:
    intc_1 // 1

arc58_rekeyToPlugin_bool_merge@18:
    // contracts/arc58/abstracted_account.algo.ts:251
    // assert(globalCheck.valid || localCheck.valid, 'invalid plugin call')
    assert // invalid plugin call
    // contracts/arc58/abstracted_account.algo.ts:253
    // let rekeysBack = false
    intc_0 // 0
    frame_bury 7
    // contracts/arc58/abstracted_account.algo.ts:254
    // let methodIndex: uint64 = 0
    intc_0 // 0
    frame_bury 6
    // contracts/arc58/abstracted_account.algo.ts:256
    // for (let i: uint64 = Txn.groupIndex + 1; i < Global.groupSize; i += 1) {
    txn GroupIndex
    intc_1 // 1
    +
    frame_bury 2

arc58_rekeyToPlugin_while_top@19:
    // contracts/arc58/abstracted_account.algo.ts:256
    // for (let i: uint64 = Txn.groupIndex + 1; i < Global.groupSize; i += 1) {
    frame_dig 2
    global GroupSize
    <
    bz arc58_rekeyToPlugin_block@41
    // contracts/arc58/abstracted_account.algo.ts:259
    // if (this.txnRekeysBack(txn)) {
    frame_dig 2
    callsub txnRekeysBack
    bz arc58_rekeyToPlugin_after_if_else@22
    // contracts/arc58/abstracted_account.algo.ts:260
    // rekeysBack = true
    intc_1 // 1
    frame_bury 7

arc58_rekeyToPlugin_block@41:
    // contracts/arc58/abstracted_account.algo.ts:310
    // assert(rekeysBack, 'no rekey back found')
    frame_dig 7
    assert // no rekey back found
    // contracts/arc58/abstracted_account.algo.ts:569-575
    // itxn.payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.controlledAddress.value,
    //     rekeyTo: Application(plugin).address,
    //     note: 'rekeying to plugin app',
    //     fee: 0,
    // }).submit()
    itxn_begin
    // contracts/arc58/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/arc58/abstracted_account.algo.ts:572
    // rekeyTo: Application(plugin).address,
    frame_dig -2
    app_params_get AppAddress
    assert // application exists
    // contracts/arc58/abstracted_account.algo.ts:573
    // note: 'rekeying to plugin app',
    pushbytes "rekeying to plugin app"
    itxn_field Note
    itxn_field RekeyTo
    itxn_field Receiver
    itxn_field Sender
    // contracts/arc58/abstracted_account.algo.ts:569-575
    // itxn.payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.controlledAddress.value,
    //     rekeyTo: Application(plugin).address,
    //     note: 'rekeying to plugin app',
    //     fee: 0,
    // }).submit()
    intc_1 // 1
    itxn_field TypeEnum
    // contracts/arc58/abstracted_account.algo.ts:574
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // contracts/arc58/abstracted_account.algo.ts:569-575
    // itxn.payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.controlledAddress.value,
    //     rekeyTo: Application(plugin).address,
    //     note: 'rekeying to plugin app',
    //     fee: 0,
    // }).submit()
    itxn_submit
    retsub

arc58_rekeyToPlugin_after_if_else@22:
    // contracts/arc58/abstracted_account.algo.ts:264
    // if (txn.type !== TransactionType.ApplicationCall) {
    frame_dig 2
    gtxns TypeEnum
    pushint 6 // 6
    !=
    bnz arc58_rekeyToPlugin_block@39
    // contracts/arc58/abstracted_account.algo.ts:268
    // assert(txn.appId.id === plugin.id, 'cannot call other apps during plugin rekey')
    frame_dig 2
    dup
    gtxns ApplicationID
    frame_dig -2
    ==
    assert // cannot call other apps during plugin rekey
    // contracts/arc58/abstracted_account.algo.ts:269
    // assert(txn.onCompletion === OnCompleteAction.NoOp, 'invalid onComplete')
    dup
    gtxns OnCompletion
    !
    assert // invalid onComplete
    // contracts/arc58/abstracted_account.algo.ts:272
    // assert(txn.numAppArgs > 1, 'no app id provided')
    dup
    gtxns NumAppArgs
    intc_1 // 1
    >
    assert // no app id provided
    // contracts/arc58/abstracted_account.algo.ts:273
    // assert(Application(btoi(txn.appArgs(1))) === Global.currentApplicationId, 'wrong app id')
    dup
    intc_1 // 1
    gtxnsas ApplicationArgs
    btoi
    global CurrentApplicationID
    ==
    assert // wrong app id
    // contracts/arc58/abstracted_account.algo.ts:279
    // Global.zeroAddress,
    global ZeroAddress
    // contracts/arc58/abstracted_account.algo.ts:275-282
    // const globalLoopCheck = this.fullPluginCheck(
    //     gKey,
    //     txn,
    //     plugin,
    //     Global.zeroAddress,
    //     methodOffsets,
    //     methodIndex
    // )
    frame_dig 8
    dig 2
    frame_dig -2
    uncover 3
    frame_dig -1
    frame_dig 6
    dup
    cover 7
    callsub fullPluginCheck
    frame_bury 8
    frame_bury 1
    cover 9
    popn 4
    frame_bury 0
    popn 2
    // contracts/arc58/abstracted_account.algo.ts:284
    // const localLoopCheck = this.fullPluginCheck(lKey, txn, plugin, Txn.sender, methodOffsets, methodIndex)
    txn Sender
    frame_dig 12
    uncover 2
    frame_dig -2
    uncover 3
    frame_dig -1
    uncover 5
    callsub fullPluginCheck
    frame_bury 12
    frame_bury 5
    frame_bury 4
    popn 4
    frame_bury 3
    popn 2
    // contracts/arc58/abstracted_account.algo.ts:286
    // assert(!globalLoopCheck.methodOnCooldown || !localLoopCheck.methodOnCooldown, 'method on cooldown')
    bz arc58_rekeyToPlugin_bool_true@26
    frame_dig 4
    bnz arc58_rekeyToPlugin_bool_false@27

arc58_rekeyToPlugin_bool_true@26:
    intc_1 // 1

arc58_rekeyToPlugin_bool_merge@28:
    // contracts/arc58/abstracted_account.algo.ts:286
    // assert(!globalLoopCheck.methodOnCooldown || !localLoopCheck.methodOnCooldown, 'method on cooldown')
    assert // method on cooldown
    // contracts/arc58/abstracted_account.algo.ts:287
    // assert(globalLoopCheck.valid || localLoopCheck.valid, 'not allowed')
    frame_dig 1
    bnz arc58_rekeyToPlugin_bool_true@30
    frame_dig 5
    bz arc58_rekeyToPlugin_bool_false@31

arc58_rekeyToPlugin_bool_true@30:
    intc_1 // 1

arc58_rekeyToPlugin_bool_merge@32:
    // contracts/arc58/abstracted_account.algo.ts:287
    // assert(globalLoopCheck.valid || localLoopCheck.valid, 'not allowed')
    assert // not allowed
    // contracts/arc58/abstracted_account.algo.ts:293
    // if (globalLoopCheck.valid && globalLoopCheck.hasCooldown) {
    frame_dig 1
    bz arc58_rekeyToPlugin_else_body@35
    frame_dig 0
    bz arc58_rekeyToPlugin_else_body@35
    // contracts/arc58/abstracted_account.algo.ts:296
    // lastCalled: new UintN64(Global.round),
    global Round
    itob
    // contracts/arc58/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig 8
    concat
    // contracts/arc58/abstracted_account.algo.ts:297
    // methods: this.plugins(gKey).value.methods.copy(),
    dup
    box_get
    assert // Box must have value
    dup
    pushint 25 // 25
    extract_uint16
    dig 1
    len
    substring3
    // contracts/arc58/abstracted_account.algo.ts:295
    // ...this.plugins(gKey).value,
    dig 1
    box_get
    assert // Box must have value
    // contracts/arc58/abstracted_account.algo.ts:294-298
    // this.plugins(gKey).value = new arc4PluginInfo({
    //     ...this.plugins(gKey).value,
    //     lastCalled: new UintN64(Global.round),
    //     methods: this.plugins(gKey).value.methods.copy(),
    // })
    extract 0 8 // on error: Index access is out of bounds
    // contracts/arc58/abstracted_account.algo.ts:295
    // ...this.plugins(gKey).value,
    dig 2
    box_get
    assert // Box must have value
    // contracts/arc58/abstracted_account.algo.ts:294-298
    // this.plugins(gKey).value = new arc4PluginInfo({
    //     ...this.plugins(gKey).value,
    //     lastCalled: new UintN64(Global.round),
    //     methods: this.plugins(gKey).value.methods.copy(),
    // })
    extract 8 8 // on error: Index access is out of bounds
    // contracts/arc58/abstracted_account.algo.ts:295
    // ...this.plugins(gKey).value,
    dig 3
    box_get
    assert // Box must have value
    // contracts/arc58/abstracted_account.algo.ts:294-298
    // this.plugins(gKey).value = new arc4PluginInfo({
    //     ...this.plugins(gKey).value,
    //     lastCalled: new UintN64(Global.round),
    //     methods: this.plugins(gKey).value.methods.copy(),
    // })
    intc 4 // 192
    getbit
    bytec_2 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    cover 2
    concat
    uncover 4
    concat
    swap
    concat
    bytec 5 // 0x001b
    concat
    swap
    concat
    dig 1
    box_del
    pop
    box_put

arc58_rekeyToPlugin_after_if_else@38:
    // contracts/arc58/abstracted_account.algo.ts:307
    // methodIndex += 1
    frame_dig 6
    intc_1 // 1
    +
    frame_bury 6

arc58_rekeyToPlugin_block@39:
    // contracts/arc58/abstracted_account.algo.ts:256
    // for (let i: uint64 = Txn.groupIndex + 1; i < Global.groupSize; i += 1) {
    frame_dig 2
    intc_1 // 1
    +
    frame_bury 2
    b arc58_rekeyToPlugin_while_top@19

arc58_rekeyToPlugin_else_body@35:
    // contracts/arc58/abstracted_account.algo.ts:299
    // } else if (localLoopCheck.valid && localLoopCheck.hasCooldown) {
    frame_dig 5
    bz arc58_rekeyToPlugin_after_if_else@38
    frame_dig 3
    bz arc58_rekeyToPlugin_after_if_else@38
    // contracts/arc58/abstracted_account.algo.ts:302
    // lastCalled: new UintN64(Global.round),
    global Round
    itob
    // contracts/arc58/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig 12
    concat
    // contracts/arc58/abstracted_account.algo.ts:303
    // methods: this.plugins(lKey).value.methods.copy(),
    dup
    box_get
    assert // Box must have value
    dup
    pushint 25 // 25
    extract_uint16
    dig 1
    len
    substring3
    // contracts/arc58/abstracted_account.algo.ts:301
    // ...this.plugins(lKey).value,
    dig 1
    box_get
    assert // Box must have value
    // contracts/arc58/abstracted_account.algo.ts:300-304
    // this.plugins(lKey).value = new arc4PluginInfo({
    //     ...this.plugins(lKey).value,
    //     lastCalled: new UintN64(Global.round),
    //     methods: this.plugins(lKey).value.methods.copy(),
    // })
    extract 0 8 // on error: Index access is out of bounds
    // contracts/arc58/abstracted_account.algo.ts:301
    // ...this.plugins(lKey).value,
    dig 2
    box_get
    assert // Box must have value
    // contracts/arc58/abstracted_account.algo.ts:300-304
    // this.plugins(lKey).value = new arc4PluginInfo({
    //     ...this.plugins(lKey).value,
    //     lastCalled: new UintN64(Global.round),
    //     methods: this.plugins(lKey).value.methods.copy(),
    // })
    extract 8 8 // on error: Index access is out of bounds
    // contracts/arc58/abstracted_account.algo.ts:301
    // ...this.plugins(lKey).value,
    dig 3
    box_get
    assert // Box must have value
    // contracts/arc58/abstracted_account.algo.ts:300-304
    // this.plugins(lKey).value = new arc4PluginInfo({
    //     ...this.plugins(lKey).value,
    //     lastCalled: new UintN64(Global.round),
    //     methods: this.plugins(lKey).value.methods.copy(),
    // })
    intc 4 // 192
    getbit
    bytec_2 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    cover 2
    concat
    uncover 4
    concat
    swap
    concat
    bytec 5 // 0x001b
    concat
    swap
    concat
    dig 1
    box_del
    pop
    box_put
    b arc58_rekeyToPlugin_after_if_else@38

arc58_rekeyToPlugin_bool_false@31:
    intc_0 // 0
    b arc58_rekeyToPlugin_bool_merge@32

arc58_rekeyToPlugin_bool_false@27:
    intc_0 // 0
    b arc58_rekeyToPlugin_bool_merge@28

arc58_rekeyToPlugin_bool_false@17:
    intc_0 // 0
    b arc58_rekeyToPlugin_bool_merge@18

arc58_rekeyToPlugin_bool_false@13:
    intc_0 // 0
    b arc58_rekeyToPlugin_bool_merge@14

arc58_rekeyToPlugin_bool_false@9:
    intc_0 // 0
    b arc58_rekeyToPlugin_bool_merge@10

arc58_rekeyToPlugin_bool_false@5:
    intc_0 // 0
    b arc58_rekeyToPlugin_bool_merge@6


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyToNamedPlugin(name: bytes, methodOffsets: bytes) -> void:
arc58_rekeyToNamedPlugin:
    // contracts/arc58/abstracted_account.algo.ts:587
    // arc58_rekeyToNamedPlugin(name: string, methodOffsets: uint64[]): void {
    proto 2 0
    // contracts/arc58/constants.ts:10
    // export const AbstractAccountBoxPrefixNamedPlugins = 'n'
    bytec 10 // "n"
    frame_dig -2
    concat
    // contracts/arc58/abstracted_account.algo.ts:588
    // this.arc58_rekeyToPlugin(this.namedPlugins(name).value.application.native, methodOffsets)
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    frame_dig -1
    callsub arc58_rekeyToPlugin
    retsub


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.arc58_addPlugin(app: uint64, allowedCaller: bytes, lastValidRound: uint64, cooldown: uint64, adminPrivileges: uint64, methods: bytes) -> void:
arc58_addPlugin:
    // contracts/arc58/abstracted_account.algo.ts:603-610
    // arc58_addPlugin(
    //     app: uint64,
    //     allowedCaller: Address,
    //     lastValidRound: uint64,
    //     cooldown: uint64,
    //     adminPrivileges: boolean,
    //     methods: MethodRestriction[]
    // ): void {
    proto 6 0
    // contracts/arc58/abstracted_account.algo.ts:611
    // assert(this.isAdmin(), 'Sender must be the admin')
    callsub isAdmin
    assert // Sender must be the admin
    // contracts/arc58/abstracted_account.algo.ts:46
    // return new arc4PluginsKey({ application: new UintN64(app), allowedCaller: caller })
    frame_dig -6
    itob
    frame_dig -5
    concat
    // contracts/arc58/abstracted_account.algo.ts:614
    // const methodInfos = new arc4.DynamicArray<arc4MethodInfo>()
    bytec 11 // 0x0000
    // contracts/arc58/abstracted_account.algo.ts:615
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0

arc58_addPlugin_while_top@1:
    // contracts/arc58/abstracted_account.algo.ts:615
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 2
    >
    bz arc58_addPlugin_after_while@3
    // contracts/arc58/abstracted_account.algo.ts:616-622
    // methodInfos.push(
    //     new arc4MethodInfo({
    //         selector: methods[i].selector,
    //         cooldown: new UintN64(methods[i].cooldown),
    //         lastCalled: new UintN64(),
    //     })
    // )
    frame_dig 1
    extract 2 0
    // contracts/arc58/abstracted_account.algo.ts:618
    // selector: methods[i].selector,
    frame_dig -1
    extract 2 0
    frame_dig 2
    dup
    cover 3
    pushint 12 // 12
    *
    pushint 12 // 12
    extract3 // on error: Index access is out of bounds
    dup
    extract 0 4 // on error: Index access is out of bounds
    // contracts/arc58/abstracted_account.algo.ts:619
    // cooldown: new UintN64(methods[i].cooldown),
    swap
    intc_3 // 4
    extract_uint64
    itob
    // contracts/arc58/abstracted_account.algo.ts:617-621
    // new arc4MethodInfo({
    //     selector: methods[i].selector,
    //     cooldown: new UintN64(methods[i].cooldown),
    //     lastCalled: new UintN64(),
    // })
    concat
    // contracts/arc58/abstracted_account.algo.ts:620
    // lastCalled: new UintN64(),
    bytec 7 // 0x0000000000000000
    // contracts/arc58/abstracted_account.algo.ts:617-621
    // new arc4MethodInfo({
    //     selector: methods[i].selector,
    //     cooldown: new UintN64(methods[i].cooldown),
    //     lastCalled: new UintN64(),
    // })
    concat
    // contracts/arc58/abstracted_account.algo.ts:616-622
    // methodInfos.push(
    //     new arc4MethodInfo({
    //         selector: methods[i].selector,
    //         cooldown: new UintN64(methods[i].cooldown),
    //         lastCalled: new UintN64(),
    //     })
    // )
    concat
    dup
    len
    pushint 20 // 20
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 1
    // contracts/arc58/abstracted_account.algo.ts:615
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_1 // 1
    +
    frame_bury 2
    b arc58_addPlugin_while_top@1

arc58_addPlugin_after_while@3:
    // contracts/arc58/abstracted_account.algo.ts:626
    // lastValidRound: new UintN64(lastValidRound),
    frame_dig -4
    itob
    // contracts/arc58/abstracted_account.algo.ts:627
    // cooldown: new UintN64(cooldown),
    frame_dig -3
    itob
    // contracts/arc58/abstracted_account.algo.ts:629
    // adminPrivileges: new arc4.Bool(adminPrivileges),
    bytec_2 // 0x00
    intc_0 // 0
    frame_dig -2
    setbit
    // contracts/arc58/abstracted_account.algo.ts:625-631
    // this.plugins(key).value = new arc4PluginInfo({
    //     lastValidRound: new UintN64(lastValidRound),
    //     cooldown: new UintN64(cooldown),
    //     lastCalled: new UintN64(),
    //     adminPrivileges: new arc4.Bool(adminPrivileges),
    //     methods: methodInfos.copy(),
    // })
    cover 2
    concat
    // contracts/arc58/abstracted_account.algo.ts:628
    // lastCalled: new UintN64(),
    bytec 7 // 0x0000000000000000
    // contracts/arc58/abstracted_account.algo.ts:625-631
    // this.plugins(key).value = new arc4PluginInfo({
    //     lastValidRound: new UintN64(lastValidRound),
    //     cooldown: new UintN64(cooldown),
    //     lastCalled: new UintN64(),
    //     adminPrivileges: new arc4.Bool(adminPrivileges),
    //     methods: methodInfos.copy(),
    // })
    concat
    swap
    concat
    bytec 5 // 0x001b
    concat
    frame_dig 1
    concat
    // contracts/arc58/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig 0
    concat
    // contracts/arc58/abstracted_account.algo.ts:625-631
    // this.plugins(key).value = new arc4PluginInfo({
    //     lastValidRound: new UintN64(lastValidRound),
    //     cooldown: new UintN64(cooldown),
    //     lastCalled: new UintN64(),
    //     adminPrivileges: new arc4.Bool(adminPrivileges),
    //     methods: methodInfos.copy(),
    // })
    dup
    box_del
    pop
    swap
    box_put
    retsub


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.assignDomain(caller: bytes, domain: bytes) -> void:
assignDomain:
    // contracts/arc58/abstracted_account.algo.ts:640
    // assignDomain(caller: Address, domain: string): void {
    proto 2 0
    // contracts/arc58/abstracted_account.algo.ts:641
    // assert(this.isAdmin(), ERR_ONLY_ADMIN_CAN_ADD_PLUGIN)
    callsub isAdmin
    assert // Only an admin can add a plugin
    // contracts/arc58/constants.ts:11
    // export const AbstractAccountBoxPrefixDomainKeys = 'd'
    bytec 8 // "d"
    frame_dig -2
    concat
    // contracts/arc58/abstracted_account.algo.ts:642
    // this.domainKeys(new Address(caller.native)).value = domain
    dup
    box_del
    pop
    frame_dig -1
    box_put
    retsub


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.arc58_removePlugin(app: uint64, allowedCaller: bytes) -> void:
arc58_removePlugin:
    // contracts/arc58/abstracted_account.algo.ts:653
    // arc58_removePlugin(app: uint64, allowedCaller: Address): void {
    proto 2 0
    // contracts/arc58/abstracted_account.algo.ts:654
    // assert(this.isAdmin() || this.canRevoke(), 'Sender must be the admin')
    callsub isAdmin
    bnz arc58_removePlugin_bool_true@2
    callsub canRevoke
    bz arc58_removePlugin_bool_false@3

arc58_removePlugin_bool_true@2:
    intc_1 // 1

arc58_removePlugin_bool_merge@4:
    // contracts/arc58/abstracted_account.algo.ts:654
    // assert(this.isAdmin() || this.canRevoke(), 'Sender must be the admin')
    assert // Sender must be the admin
    // contracts/arc58/abstracted_account.algo.ts:46
    // return new arc4PluginsKey({ application: new UintN64(app), allowedCaller: caller })
    frame_dig -2
    itob
    frame_dig -1
    concat
    // contracts/arc58/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    swap
    concat
    // contracts/arc58/abstracted_account.algo.ts:657
    // assert(this.plugins(key).exists, 'plugin does not exist')
    dup
    box_len
    bury 1
    assert // plugin does not exist
    // contracts/arc58/abstracted_account.algo.ts:658
    // this.plugins(key).delete()
    box_del
    pop
    retsub

arc58_removePlugin_bool_false@3:
    intc_0 // 0
    b arc58_removePlugin_bool_merge@4


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.arc58_addNamedPlugin(name: bytes, app: uint64, allowedCaller: bytes, lastValidRound: uint64, cooldown: uint64, adminPrivileges: uint64, methods: bytes) -> void:
arc58_addNamedPlugin:
    // contracts/arc58/abstracted_account.algo.ts:674-682
    // arc58_addNamedPlugin(
    //     name: string,
    //     app: uint64,
    //     allowedCaller: Address,
    //     lastValidRound: uint64,
    //     cooldown: uint64,
    //     adminPrivileges: boolean,
    //     methods: MethodRestriction[]
    // ): void {
    proto 7 0
    // contracts/arc58/abstracted_account.algo.ts:683
    // assert(this.isAdmin(), 'Sender must be the admin')
    callsub isAdmin
    assert // Sender must be the admin
    // contracts/arc58/constants.ts:10
    // export const AbstractAccountBoxPrefixNamedPlugins = 'n'
    bytec 10 // "n"
    frame_dig -7
    concat
    // contracts/arc58/abstracted_account.algo.ts:684
    // assert(!this.namedPlugins(name).exists)
    dup
    box_len
    bury 1
    !
    assert
    // contracts/arc58/abstracted_account.algo.ts:46
    // return new arc4PluginsKey({ application: new UintN64(app), allowedCaller: caller })
    frame_dig -6
    itob
    frame_dig -5
    concat
    dup
    cover 2
    // contracts/arc58/abstracted_account.algo.ts:687
    // this.namedPlugins(name).value = key.copy()
    box_put
    // contracts/arc58/abstracted_account.algo.ts:689
    // const methodInfos = new arc4.DynamicArray<arc4MethodInfo>()
    bytec 11 // 0x0000
    // contracts/arc58/abstracted_account.algo.ts:690
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0

arc58_addNamedPlugin_while_top@1:
    // contracts/arc58/abstracted_account.algo.ts:690
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 2
    >
    bz arc58_addNamedPlugin_after_while@3
    // contracts/arc58/abstracted_account.algo.ts:691-697
    // methodInfos.push(
    //     new arc4MethodInfo({
    //         selector: methods[i].selector,
    //         cooldown: new UintN64(methods[i].cooldown),
    //         lastCalled: new UintN64(),
    //     })
    // )
    frame_dig 1
    extract 2 0
    // contracts/arc58/abstracted_account.algo.ts:693
    // selector: methods[i].selector,
    frame_dig -1
    extract 2 0
    frame_dig 2
    dup
    cover 3
    pushint 12 // 12
    *
    pushint 12 // 12
    extract3 // on error: Index access is out of bounds
    dup
    extract 0 4 // on error: Index access is out of bounds
    // contracts/arc58/abstracted_account.algo.ts:694
    // cooldown: new UintN64(methods[i].cooldown),
    swap
    intc_3 // 4
    extract_uint64
    itob
    // contracts/arc58/abstracted_account.algo.ts:692-696
    // new arc4MethodInfo({
    //     selector: methods[i].selector,
    //     cooldown: new UintN64(methods[i].cooldown),
    //     lastCalled: new UintN64(),
    // })
    concat
    // contracts/arc58/abstracted_account.algo.ts:695
    // lastCalled: new UintN64(),
    bytec 7 // 0x0000000000000000
    // contracts/arc58/abstracted_account.algo.ts:692-696
    // new arc4MethodInfo({
    //     selector: methods[i].selector,
    //     cooldown: new UintN64(methods[i].cooldown),
    //     lastCalled: new UintN64(),
    // })
    concat
    // contracts/arc58/abstracted_account.algo.ts:691-697
    // methodInfos.push(
    //     new arc4MethodInfo({
    //         selector: methods[i].selector,
    //         cooldown: new UintN64(methods[i].cooldown),
    //         lastCalled: new UintN64(),
    //     })
    // )
    concat
    dup
    len
    pushint 20 // 20
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 1
    // contracts/arc58/abstracted_account.algo.ts:690
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_1 // 1
    +
    frame_bury 2
    b arc58_addNamedPlugin_while_top@1

arc58_addNamedPlugin_after_while@3:
    // contracts/arc58/abstracted_account.algo.ts:701
    // lastValidRound: new UintN64(lastValidRound),
    frame_dig -4
    itob
    // contracts/arc58/abstracted_account.algo.ts:702
    // cooldown: new UintN64(cooldown),
    frame_dig -3
    itob
    // contracts/arc58/abstracted_account.algo.ts:704
    // adminPrivileges: new arc4.Bool(adminPrivileges),
    bytec_2 // 0x00
    intc_0 // 0
    frame_dig -2
    setbit
    // contracts/arc58/abstracted_account.algo.ts:700-706
    // this.plugins(key).value = new arc4PluginInfo({
    //     lastValidRound: new UintN64(lastValidRound),
    //     cooldown: new UintN64(cooldown),
    //     lastCalled: new UintN64(),
    //     adminPrivileges: new arc4.Bool(adminPrivileges),
    //     methods: methodInfos.copy(),
    // })
    cover 2
    concat
    // contracts/arc58/abstracted_account.algo.ts:703
    // lastCalled: new UintN64(),
    bytec 7 // 0x0000000000000000
    // contracts/arc58/abstracted_account.algo.ts:700-706
    // this.plugins(key).value = new arc4PluginInfo({
    //     lastValidRound: new UintN64(lastValidRound),
    //     cooldown: new UintN64(cooldown),
    //     lastCalled: new UintN64(),
    //     adminPrivileges: new arc4.Bool(adminPrivileges),
    //     methods: methodInfos.copy(),
    // })
    concat
    swap
    concat
    bytec 5 // 0x001b
    concat
    frame_dig 1
    concat
    // contracts/arc58/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    frame_dig 0
    concat
    // contracts/arc58/abstracted_account.algo.ts:700-706
    // this.plugins(key).value = new arc4PluginInfo({
    //     lastValidRound: new UintN64(lastValidRound),
    //     cooldown: new UintN64(cooldown),
    //     lastCalled: new UintN64(),
    //     adminPrivileges: new arc4.Bool(adminPrivileges),
    //     methods: methodInfos.copy(),
    // })
    dup
    box_del
    pop
    swap
    box_put
    retsub


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.arc58_removeNamedPlugin(name: bytes) -> void:
arc58_removeNamedPlugin:
    // contracts/arc58/abstracted_account.algo.ts:715
    // arc58_removeNamedPlugin(name: string): void {
    proto 1 0
    // contracts/arc58/abstracted_account.algo.ts:717
    // assert(this.isAdmin() || this.canRevoke(), 'Sender must be the admin')
    callsub isAdmin
    bnz arc58_removeNamedPlugin_bool_true@2
    callsub canRevoke
    bz arc58_removeNamedPlugin_bool_false@3

arc58_removeNamedPlugin_bool_true@2:
    intc_1 // 1

arc58_removeNamedPlugin_bool_merge@4:
    // contracts/arc58/abstracted_account.algo.ts:717
    // assert(this.isAdmin() || this.canRevoke(), 'Sender must be the admin')
    assert // Sender must be the admin
    // contracts/arc58/constants.ts:10
    // export const AbstractAccountBoxPrefixNamedPlugins = 'n'
    bytec 10 // "n"
    frame_dig -1
    concat
    // contracts/arc58/abstracted_account.algo.ts:718
    // assert(this.namedPlugins(name).exists, 'plugin does not exist')
    dup
    box_len
    bury 1
    assert // plugin does not exist
    // contracts/arc58/abstracted_account.algo.ts:719
    // const app = this.namedPlugins(name).value.copy()
    dup
    box_get
    assert // Box must have value
    // contracts/arc58/constants.ts:9
    // export const AbstractAccountBoxPrefixPlugins = 'p'
    bytec_0 // "p"
    swap
    concat
    // contracts/arc58/abstracted_account.algo.ts:720
    // assert(this.plugins(app).exists, 'plugin does not exist')
    dup
    box_len
    bury 1
    assert // plugin does not exist
    // contracts/arc58/abstracted_account.algo.ts:722
    // this.namedPlugins(name).delete()
    swap
    box_del
    pop
    // contracts/arc58/abstracted_account.algo.ts:723
    // this.plugins(app).delete()
    box_del
    pop
    retsub

arc58_removeNamedPlugin_bool_false@3:
    intc_0 // 0
    b arc58_removeNamedPlugin_bool_merge@4


// contracts/arc58/abstracted_account.algo.ts::AbstractedAccount.balance(assets: bytes) -> bytes:
balance:
    // contracts/arc58/abstracted_account.algo.ts:730
    // balance(assets: uint64[]): uint64[] {
    proto 1 1
    bytec_3 // ""
    dupn 2
    // contracts/arc58/abstracted_account.algo.ts:731
    // let amounts: uint64[] = []
    bytec 11 // 0x0000
    // contracts/arc58/abstracted_account.algo.ts:732
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    intc_0 // 0

balance_while_top@1:
    // contracts/arc58/abstracted_account.algo.ts:732
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 4
    >
    bz balance_after_while@9
    // contracts/arc58/abstracted_account.algo.ts:733
    // let amount: uint64 = 0
    intc_0 // 0
    frame_bury 0
    // contracts/arc58/abstracted_account.algo.ts:734
    // const asset = Asset(assets[i])
    frame_dig -1
    extract 2 0
    frame_dig 4
    intc_2 // 8
    *
    extract_uint64
    dup
    frame_bury 1
    // contracts/arc58/abstracted_account.algo.ts:736
    // if (asset.id === 0) {
    bnz balance_else_body@4
    // contracts/arc58/abstracted_account.algo.ts:737
    // amount = Global.currentApplicationAddress.balance
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    swap
    frame_bury 0
    assert // account funded

balance_after_if_else@7:
    // contracts/arc58/abstracted_account.algo.ts:745-752
    // const escrowInfo = abiCall(Staking.prototype.getEscrowInfo, {
    //     appId: super.getAppList().staking,
    //     args: [
    //         new Address(this.controlledAddress.value),
    //         new UintN64(asset.id)
    //     ],
    //     fee: 0
    // }).returnValue
    itxn_begin
    // contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec 12 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/dao/constants.ts:6
    // export const AkitaDAOGlobalStateKeysAppList = 'app_list'
    pushbytes "app_list"
    // utils/base_contracts/base.algo.ts:33
    // const [appListBytes] = op.AppGlobal.getExBytes(this.akitaDAO.value, Bytes(AkitaDAOGlobalStateKeysAppList))
    app_global_get_ex
    pop
    // utils/base_contracts/base.algo.ts:34
    // return decodeArc4<AppList>(appListBytes)
    pushint 24 // 24
    extract_uint64
    // contracts/arc58/constants.ts:2
    // export const AbstractAccountGlobalStateKeysControlledAddress = 'controlled_address'
    intc_0 // 0
    bytec_1 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/arc58/abstracted_account.algo.ts:749
    // new UintN64(asset.id)
    frame_dig 1
    itob
    // contracts/arc58/abstracted_account.algo.ts:745-752
    // const escrowInfo = abiCall(Staking.prototype.getEscrowInfo, {
    //     appId: super.getAppList().staking,
    //     args: [
    //         new Address(this.controlledAddress.value),
    //         new UintN64(asset.id)
    //     ],
    //     fee: 0
    // }).returnValue
    pushbytes 0x4c88eace // method "getEscrowInfo(address,uint64)(uint64,uint64)"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    // contracts/arc58/abstracted_account.algo.ts:751
    // fee: 0
    intc_0 // 0
    itxn_field Fee
    // contracts/arc58/abstracted_account.algo.ts:745-752
    // const escrowInfo = abiCall(Staking.prototype.getEscrowInfo, {
    //     appId: super.getAppList().staking,
    //     args: [
    //         new Address(this.controlledAddress.value),
    //         new UintN64(asset.id)
    //     ],
    //     fee: 0
    // }).returnValue
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 6 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    intc_3 // 4
    extract_uint64
    swap
    pushint 12 // 12
    extract_uint64
    // contracts/arc58/abstracted_account.algo.ts:754
    // amounts = [...amounts, (amount + escrowInfo.hard + escrowInfo.lock)]
    frame_dig 3
    extract 2 0
    frame_dig 0
    uncover 3
    +
    uncover 2
    +
    itob
    dup
    len
    intc_2 // 8
    /
    itob
    extract 6 2
    swap
    concat
    extract 2 0
    concat
    dup
    len
    intc_2 // 8
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 3
    // contracts/arc58/abstracted_account.algo.ts:732
    // for (let i: uint64 = 0; i < assets.length; i += 1) {
    frame_dig 4
    intc_1 // 1
    +
    frame_bury 4
    b balance_while_top@1

balance_else_body@4:
    // contracts/arc58/abstracted_account.algo.ts:739
    // const [holdingAmount, optedIn] = AssetHolding.assetBalance(Global.currentApplicationAddress, asset)
    global CurrentApplicationAddress
    frame_dig 1
    asset_holding_get AssetBalance
    swap
    frame_bury 2
    // contracts/arc58/abstracted_account.algo.ts:740
    // if (optedIn) {
    bz balance_after_if_else@7
    frame_dig 2
    frame_bury 0
    b balance_after_if_else@7

balance_after_while@9:
    // contracts/arc58/abstracted_account.algo.ts:757
    // return amounts
    frame_dig 3
    frame_bury 0
    retsub


// utils/base_contracts/base.algo.ts::AkitaBaseContract.updateAkitaDAO(app: uint64) -> void:
updateAkitaDAO:
    // utils/base_contracts/base.algo.ts:27
    // updateAkitaDAO(app: uint64): void {
    proto 1 0
    // utils/base_contracts/base.algo.ts:28
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    txn Sender
    // contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    intc_0 // 0
    bytec 12 // "akita_dao"
    app_global_get_ex
    assert // check GlobalState exists
    // utils/base_contracts/base.algo.ts:28
    // assert(Txn.sender === this.akitaDAO.value.address, ERR_NOT_AKITA_DAO)
    app_params_get AppAddress
    assert // application exists
    ==
    assert // Only the Akita DAO can call this function
    // contracts/constants.ts:1
    // export const GlobalStateKeyAkitaDAO = 'akita_dao'
    bytec 12 // "akita_dao"
    // utils/base_contracts/base.algo.ts:29
    // this.akitaDAO.value = Application(app)
    frame_dig -1
    app_global_put
    retsub
