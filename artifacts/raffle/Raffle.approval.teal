#pragma version 10
intcblock 0 1 8 4096 4 6 37800 16 10 64 18446744073709551615 1442695040888963409 1442695040888963407 13113300 700 2 5 32
bytecblock 0x 0x7469636b65745f636f756e74 0x7469636b65745f6173736574 0x775f746f74616c73 0x656e7472795f636f756e74 0x726166666c655f77696e6e6572 0x68 0x7072697a65 0x61 0x776569676874735f626f785f636f756e74 0x726566756e645f6d62725f637572736f72 0x77696e6e696e675f7469636b6574 0x73656c6c6572 0x6d696e5f7469636b657473 0x6d61785f7469636b657473 0x67617465 0x726166666c655f7072697a655f636c61696d6564 0x656e64696e675f726f756e64 0x65 0x7672665f6765745f6661696c7572655f636f756e74 0x0a8101 0x00 0x7672665f626561636f6e5f6170705f6964 0x7374617274696e675f726f756e64 0x151f7c75 0x206f7020757020697465726174696f6e20616d6f756e743a20 0x656e7472795f6964 0x08531ed7

// This TEAL was generated by TEALScript v0.106.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 5 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_DeleteApplication *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// gate(caller: Address, index: uint64, args: bytes[]): boolean
gate:
	proto 3 1

	// *if0_condition
	// utils/base_contracts/gate.algo.ts:10
	// index === 0
	frame_dig -2 // index: uint64
	intc 0 // 0
	==
	bz *if0_end

	// *if0_consequent
	// utils/base_contracts/gate.algo.ts:11
	// return true;
	intc 1 // 1
	retsub

*if0_end:
	// utils/base_contracts/gate.algo.ts:14
	// return sendMethodCall<typeof Gate.prototype.check, boolean>({
	//             applicationID: AppID.fromUint64(AkitaAppIDsGate),
	//             methodArgs: [caller, index, args],
	//             fee: 0
	//         });
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	pushbytes 0x200f7421 // method "check(address,uint64,byte[][])bool"
	itxn_field ApplicationArgs

	// utils/base_contracts/gate.algo.ts:15
	// applicationID: AppID.fromUint64(AkitaAppIDsGate)
	intc 0 // 0
	itxn_field ApplicationID

	// utils/base_contracts/gate.algo.ts:16
	// methodArgs: [caller, index, args]
	frame_dig -1 // caller: Address
	itxn_field ApplicationArgs
	frame_dig -2 // index: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -3 // args: bytes[]
	itxn_field ApplicationArgs

	// utils/base_contracts/gate.algo.ts:17
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	retsub

// optin(pay,uint64)void
*abi_route_optin:
	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// payment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 1 (payment) for optin must be a pay transaction
	assert

	// execute optin(pay,uint64)void
	callsub optin
	intc 1 // 1
	return

// optin(payment: PayTxn, asset: AssetID): void
//
// optin tells the contract to opt into an asa
// @param payment The payment transaction
// @param asset The asset to be opted into
optin:
	proto 2 0

	// utils/base_contracts/optin.algo.ts:40
	// assert(this.txn.sender === this.app.creator)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==
	assert

	// utils/base_contracts/optin.algo.ts:42
	// verifyPayTxn(payment, {
	//             receiver: this.app.address,
	//             amount: globals.assetOptInMinBalance,
	//         })
	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	global AssetOptInMinBalance
	==

	// transaction verification failed: {"txn":"payment","field":"amount","expected":"globals.assetOptInMinBalance"}
	assert

	// utils/base_contracts/optin.algo.ts:47
	// sendAssetTransfer({
	//             sender: this.app.address,
	//             assetReceiver: this.app.address,
	//             assetAmount: 0,
	//             xferAsset: asset,
	//             fee: 0,
	//         })
	itxn_begin
	intc 4 //  axfer
	itxn_field TypeEnum

	// utils/base_contracts/optin.algo.ts:48
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// utils/base_contracts/optin.algo.ts:49
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// utils/base_contracts/optin.algo.ts:50
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// utils/base_contracts/optin.algo.ts:51
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// utils/base_contracts/optin.algo.ts:52
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// arc59OptInAndSend(recipient: Address, asset: AssetID, amount: uint64, closeOut: boolean): void
arc59OptInAndSend:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// utils/base_contracts/optin.algo.ts:61
	// assetInboxAppID = AppID.fromUint64(OtherAppIDsAssetInbox)
	intc 0 // 0
	frame_bury 0 // assetInboxAppID: uint64

	// utils/base_contracts/optin.algo.ts:62
	// canCallData = sendMethodCall<typeof AssetInbox.prototype.arc59_getSendAssetInfo, arc59GetSendAssetInfoResponse>({
	//             applicationID: assetInboxAppID,
	//             methodArgs: [
	//                 recipient,
	//                 asset.id,
	//             ],
	//             fee: 0,
	//         })
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	pushbytes 0xcaa8daa5 // method "arc59_getSendAssetInfo(address,uint64)(uint64,uint64,bool,bool,uint64)"
	itxn_field ApplicationArgs

	// utils/base_contracts/optin.algo.ts:63
	// applicationID: assetInboxAppID
	intc 0 //  assetInboxAppID: uint64
	itxn_field ApplicationID

	// utils/base_contracts/optin.algo.ts:64
	// methodArgs: [
	//                 recipient,
	//                 asset.id,
	//             ]
	frame_dig -1 // recipient: Address
	itxn_field ApplicationArgs
	frame_dig -2 // asset: AssetID
	itob
	itxn_field ApplicationArgs

	// utils/base_contracts/optin.algo.ts:68
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 1 // canCallData: (uint64,uint64,bool,bool,uint64)

	// utils/base_contracts/optin.algo.ts:71
	// mbr = canCallData.mbr
	frame_dig 1 // canCallData: (uint64,uint64,bool,bool,uint64)
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	frame_bury 2 // mbr: uint64

	// utils/base_contracts/optin.algo.ts:72
	// routerOptedIn = canCallData.routerOptedIn
	frame_dig 1 // canCallData: (uint64,uint64,bool,bool,uint64)
	store 255 // full array
	load 255 // full array
	pushint 128
	getbit
	frame_bury 3 // routerOptedIn: bool

	// utils/base_contracts/optin.algo.ts:73
	// receiverAlgoNeededForClaim = canCallData.receiverAlgoNeededForClaim
	frame_dig 1 // canCallData: (uint64,uint64,bool,bool,uint64)
	store 255 // full array
	load 255 // full array
	extract 17 8
	btoi
	frame_bury 4 // receiverAlgoNeededForClaim: uint64

	// *if1_condition
	// utils/base_contracts/optin.algo.ts:75
	// mbr || receiverAlgoNeededForClaim
	frame_dig 2 // mbr: uint64
	dup
	bnz *skip_or0
	frame_dig 4 // receiverAlgoNeededForClaim: uint64
	||

*skip_or0:
	bz *if1_end

	// *if1_consequent
	// utils/base_contracts/optin.algo.ts:76
	// this.pendingGroup.addPayment({
	//                 receiver: assetInboxAppID.address,
	//                 amount: (mbr + receiverAlgoNeededForClaim),
	//                 fee: 0,
	//             })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// utils/base_contracts/optin.algo.ts:77
	// receiver: assetInboxAppID.address
	intc 0 //  assetInboxAppID: uint64
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// utils/base_contracts/optin.algo.ts:78
	// amount: (mbr + receiverAlgoNeededForClaim)
	frame_dig 2 // mbr: uint64
	frame_dig 4 // receiverAlgoNeededForClaim: uint64
	+
	itxn_field Amount

	// utils/base_contracts/optin.algo.ts:79
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if1_end:
	// *if2_condition
	// utils/base_contracts/optin.algo.ts:83
	// !routerOptedIn
	frame_dig 3 // routerOptedIn: bool
	!
	bz *if2_end

	// *if2_consequent
	// utils/base_contracts/optin.algo.ts:84
	// this.pendingGroup.addMethodCall<typeof AssetInbox.prototype.arc59_optRouterIn, void>({
	//                 applicationID: assetInboxAppID,
	//                 methodArgs: [asset.id],
	//                 fee: 0
	//             })
	itxn_next
	intc 5 //  appl
	itxn_field TypeEnum
	pushbytes 0xe8540810 // method "arc59_optRouterIn(uint64)void"
	itxn_field ApplicationArgs

	// utils/base_contracts/optin.algo.ts:85
	// applicationID: assetInboxAppID
	intc 0 //  assetInboxAppID: uint64
	itxn_field ApplicationID

	// utils/base_contracts/optin.algo.ts:86
	// methodArgs: [asset.id]
	frame_dig -2 // asset: AssetID
	itob
	itxn_field ApplicationArgs

	// utils/base_contracts/optin.algo.ts:87
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if2_end:
	// *if3_condition
	// utils/base_contracts/optin.algo.ts:91
	// closeOut
	frame_dig -4 // closeOut: boolean
	bz *if3_else

	// *if3_consequent
	// utils/base_contracts/optin.algo.ts:92
	// this.pendingGroup.addMethodCall<typeof AssetInbox.prototype.arc59_sendAsset, Address>({
	//                 applicationID: assetInboxAppID,
	//                 methodArgs: [
	//                     {
	//                         assetCloseTo: assetInboxAppID.address,
	//                         assetReceiver: assetInboxAppID.address,
	//                         assetAmount: amount,
	//                         xferAsset: asset,
	//                         fee: 0,
	//                     },
	//                     recipient,
	//                     receiverAlgoNeededForClaim,
	//                 ],
	//                 fee: 0
	//             })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// utils/base_contracts/optin.algo.ts:96
	// assetCloseTo: assetInboxAppID.address
	intc 0 //  assetInboxAppID: uint64
	app_params_get AppAddress
	pop
	itxn_field AssetCloseTo

	// utils/base_contracts/optin.algo.ts:97
	// assetReceiver: assetInboxAppID.address
	intc 0 //  assetInboxAppID: uint64
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// utils/base_contracts/optin.algo.ts:98
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// utils/base_contracts/optin.algo.ts:99
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// utils/base_contracts/optin.algo.ts:100
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 5 //  appl
	itxn_field TypeEnum
	bytec 27 //  method "arc59_sendAsset(axfer,address,uint64)address"
	itxn_field ApplicationArgs

	// utils/base_contracts/optin.algo.ts:93
	// applicationID: assetInboxAppID
	intc 0 //  assetInboxAppID: uint64
	itxn_field ApplicationID

	// utils/base_contracts/optin.algo.ts:94
	// methodArgs: [
	//                     {
	//                         assetCloseTo: assetInboxAppID.address,
	//                         assetReceiver: assetInboxAppID.address,
	//                         assetAmount: amount,
	//                         xferAsset: asset,
	//                         fee: 0,
	//                     },
	//                     recipient,
	//                     receiverAlgoNeededForClaim,
	//                 ]
	frame_dig -1 // recipient: Address
	itxn_field ApplicationArgs
	frame_dig 4 // receiverAlgoNeededForClaim: uint64
	itob
	itxn_field ApplicationArgs

	// utils/base_contracts/optin.algo.ts:105
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	b *if3_end

*if3_else:
	// utils/base_contracts/optin.algo.ts:108
	// this.pendingGroup.addMethodCall<typeof AssetInbox.prototype.arc59_sendAsset, Address>({
	//                 applicationID: assetInboxAppID,
	//                 methodArgs: [
	//                     {
	//                         assetReceiver: assetInboxAppID.address,
	//                         assetAmount: amount,
	//                         xferAsset: asset,
	//                         fee: 0,
	//                     },
	//                     recipient,
	//                     receiverAlgoNeededForClaim,
	//                 ],
	//                 fee: 0
	//             })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// utils/base_contracts/optin.algo.ts:112
	// assetReceiver: assetInboxAppID.address
	intc 0 //  assetInboxAppID: uint64
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// utils/base_contracts/optin.algo.ts:113
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// utils/base_contracts/optin.algo.ts:114
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// utils/base_contracts/optin.algo.ts:115
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 5 //  appl
	itxn_field TypeEnum
	bytec 27 //  method "arc59_sendAsset(axfer,address,uint64)address"
	itxn_field ApplicationArgs

	// utils/base_contracts/optin.algo.ts:109
	// applicationID: assetInboxAppID
	intc 0 //  assetInboxAppID: uint64
	itxn_field ApplicationID

	// utils/base_contracts/optin.algo.ts:110
	// methodArgs: [
	//                     {
	//                         assetReceiver: assetInboxAppID.address,
	//                         assetAmount: amount,
	//                         xferAsset: asset,
	//                         fee: 0,
	//                     },
	//                     recipient,
	//                     receiverAlgoNeededForClaim,
	//                 ]
	frame_dig -1 // recipient: Address
	itxn_field ApplicationArgs
	frame_dig 4 // receiverAlgoNeededForClaim: uint64
	itob
	itxn_field ApplicationArgs

	// utils/base_contracts/optin.algo.ts:120
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if3_end:
	// utils/base_contracts/optin.algo.ts:124
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// isLive()bool
*abi_route_isLive:
	// The ABI return prefix
	bytec 24 // 0x151f7c75

	// execute isLive()bool
	callsub isLive
	bytec 21 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	concat
	log
	intc 1 // 1
	return

// isLive(): boolean
//
//
// @returns a boolean of whether the auction is live
isLive:
	proto 0 1

	// contracts/raffle/raffle.algo.ts:152
	// return (
	//             globals.round <= this.startingRound.value
	//             && globals.round >= this.endingRound.value
	//         )
	global Round
	bytec 23 //  "starting_round"
	app_global_get
	<=
	dup
	bz *skip_and0
	global Round
	bytec 17 //  "ending_round"
	app_global_get
	>=
	&&

*skip_and0:
	retsub

// createApplication(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64)void
*abi_route_createApplication:
	// vrfBeaconAppID: uint64
	txna ApplicationArgs 9
	btoi

	// gateID: uint64
	txna ApplicationArgs 8
	btoi

	// maxTickets: uint64
	txna ApplicationArgs 7
	btoi

	// minTickets: uint64
	txna ApplicationArgs 6
	btoi

	// seller: address
	txna ApplicationArgs 5
	dup
	len
	intc 17 // 32
	==

	// argument 4 (seller) for createApplication must be a address
	assert

	// endingRound: uint64
	txna ApplicationArgs 4
	btoi

	// startingRound: uint64
	txna ApplicationArgs 3
	btoi

	// ticketAsset: uint64
	txna ApplicationArgs 2
	btoi

	// prize: uint64
	txna ApplicationArgs 1
	btoi

	// execute createApplication(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64)void
	callsub createApplication
	intc 1 // 1
	return

// createApplication(prize: AssetID, ticketAsset: AssetID, startingRound: uint64, endingRound: uint64, seller: Address, minTickets: uint64, maxTickets: uint64, gateID: uint64, vrfBeaconAppID: AppID): void
createApplication:
	proto 9 0

	// contracts/raffle/raffle.algo.ts:169
	// this.prize.value = prize
	bytec 7 //  "prize"
	frame_dig -1 // prize: AssetID
	app_global_put

	// contracts/raffle/raffle.algo.ts:170
	// this.ticketAsset.value = ticketAsset
	bytec 2 //  "ticket_asset"
	frame_dig -2 // ticketAsset: AssetID
	app_global_put

	// contracts/raffle/raffle.algo.ts:171
	// this.startingRound.value = startingRound
	bytec 23 //  "starting_round"
	frame_dig -3 // startingRound: uint64
	app_global_put

	// contracts/raffle/raffle.algo.ts:172
	// assert(
	//             endingRound > startingRound
	//             && endingRound > (globals.round + roundsPerHour),
	//             errs.TOO_SHORT
	//         )
	frame_dig -4 // endingRound: uint64
	frame_dig -3 // startingRound: uint64
	>
	dup
	bz *skip_and1
	frame_dig -4 // endingRound: uint64
	global Round
	pushint 1285
	+
	>
	&&

*skip_and1:
	assert

	// contracts/raffle/raffle.algo.ts:177
	// this.endingRound.value = endingRound
	bytec 17 //  "ending_round"
	frame_dig -4 // endingRound: uint64
	app_global_put

	// contracts/raffle/raffle.algo.ts:178
	// this.seller.value = seller
	bytec 12 //  "seller"
	frame_dig -5 // seller: Address
	app_global_put

	// contracts/raffle/raffle.algo.ts:179
	// this.minTickets.value = minTickets
	bytec 13 //  "min_tickets"
	frame_dig -6 // minTickets: uint64
	app_global_put

	// contracts/raffle/raffle.algo.ts:180
	// this.maxTickets.value = maxTickets
	bytec 14 //  "max_tickets"
	frame_dig -7 // maxTickets: uint64
	app_global_put

	// contracts/raffle/raffle.algo.ts:181
	// this.entryCount.value = 0
	bytec 4 //  "entry_count"
	intc 0 // 0
	app_global_put

	// contracts/raffle/raffle.algo.ts:182
	// this.ticketCount.value = 0
	bytec 1 //  "ticket_count"
	intc 0 // 0
	app_global_put

	// contracts/raffle/raffle.algo.ts:183
	// this.winningTicket.value = 0
	bytec 11 //  "winning_ticket"
	intc 0 // 0
	app_global_put

	// contracts/raffle/raffle.algo.ts:184
	// this.raffleWinner.value = Address.zeroAddress
	bytec 5 //  "raffle_winner"
	global ZeroAddress
	app_global_put

	// contracts/raffle/raffle.algo.ts:185
	// this.rafflePrizeClaimed.value = false
	bytec 16 //  "raffle_prize_claimed"
	intc 0 // 0
	bytec 21 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put

	// contracts/raffle/raffle.algo.ts:186
	// this.gateID.value = gateID
	bytec 15 //  "gate"
	frame_dig -8 // gateID: uint64
	app_global_put

	// contracts/raffle/raffle.algo.ts:187
	// this.vrfBeaconAppID.value = vrfBeaconAppID
	bytec 22 //  "vrf_beacon_app_id"
	frame_dig -9 // vrfBeaconAppID: AppID
	app_global_put

	// contracts/raffle/raffle.algo.ts:188
	// this.entryID.value = 0
	bytec 26 //  "entry_id"
	intc 0 // 0
	app_global_put

	// contracts/raffle/raffle.algo.ts:189
	// this.weightsBoxCount.value = 0
	bytec 9 //  "weights_box_count"
	intc 0 // 0
	app_global_put

	// contracts/raffle/raffle.algo.ts:190
	// this.weightTotals.value = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
	bytec 3 //  "w_totals"
	pushbytes 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
	app_global_put

	// contracts/raffle/raffle.algo.ts:191
	// this.refundMBRCursor.value = 0
	bytec 10 //  "refund_mbr_cursor"
	intc 0 // 0
	app_global_put
	retsub

// init(pay,uint64)void
*abi_route_init:
	// weightListLength: uint64
	txna ApplicationArgs 1
	btoi

	// payment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 1 (payment) for init must be a pay transaction
	assert

	// execute init(pay,uint64)void
	callsub init
	intc 1 // 1
	return

// init(payment: PayTxn, weightListLength: uint64): void
init:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/raffle/raffle.algo.ts:195
	// assert(this.txn.sender === this.app.creator, errs.MUST_BE_CALLED_FROM_FACTORY)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==
	assert

	// contracts/raffle/raffle.algo.ts:196
	// assert(weightListLength >= 4, errs.MUST_ALLOCATE_AT_LEAST_FOUR_HIGHEST_BIDS_CHUNKS)
	frame_dig -2 // weightListLength: uint64
	intc 4 // 4
	>=
	assert

	// contracts/raffle/raffle.algo.ts:197
	// assert(weightListLength < 16, errs.MUST_ALLOCATE_AT_MOST_FIFTEEN_HIGHEST_BIDS_CHUNKS)
	frame_dig -2 // weightListLength: uint64
	intc 7 // 16
	<
	assert

	// contracts/raffle/raffle.algo.ts:198
	// verifyPayTxn(payment, {
	//             receiver: this.app.address,
	//             amount: (weightListLength * weightsListMBR)
	//         })
	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	frame_dig -2 // weightListLength: uint64
	intc 13 // 13113300
	*
	==

	// transaction verification failed: {"txn":"payment","field":"amount","expected":"(weightListLength * weightsListMBR)"}
	assert

	// contracts/raffle/raffle.algo.ts:203
	// this.weightsBoxCount.value = weightListLength
	bytec 9 //  "weights_box_count"
	frame_dig -2 // weightListLength: uint64
	app_global_put

	// contracts/raffle/raffle.algo.ts:204
	// for (let i = 0; i < weightListLength; i += 1)
	intc 0 // 0
	frame_bury 0 // i: uint64

*for_0:
	// contracts/raffle/raffle.algo.ts:204
	// i < weightListLength
	frame_dig 0 // i: uint64
	frame_dig -2 // weightListLength: uint64
	<
	bz *for_0_end

	// contracts/raffle/raffle.algo.ts:205
	// this.weights(i).create()
	bytec 6 //  "h"
	frame_dig 0 // i: uint64
	itob
	concat
	pushint 32768
	box_create
	pop

*for_0_continue:
	// contracts/raffle/raffle.algo.ts:204
	// i += 1
	frame_dig 0 // i: uint64
	intc 1 // 1
	+
	frame_bury 0 // i: uint64
	b *for_0

*for_0_end:
	retsub

// enter(pay,byte[][])void
*abi_route_enter:
	// args: byte[][]
	txna ApplicationArgs 1

	// payment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 1 (payment) for enter must be a pay transaction
	assert

	// execute enter(pay,byte[][])void
	callsub enter
	intc 1 // 1
	return

// enter(payment: PayTxn, args: bytes[]): void
enter:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/raffle/raffle.algo.ts:210
	// assert(this.isLive(), errs.NOT_LIVE)
	callsub isLive
	assert

	// contracts/raffle/raffle.algo.ts:211
	// assert(this.ticketAsset.value.id === 0, errs.TICKET_ASSET_NOT_ALGO)
	bytec 2 //  "ticket_asset"
	app_global_get
	intc 0 // 0
	==
	assert

	// contracts/raffle/raffle.algo.ts:212
	// assert(this.gate(this.txn.sender, this.gateID.value, args), errs.FAILED_GATE)
	frame_dig -2 // args: bytes[]
	bytec 15 //  "gate"
	app_global_get
	txn Sender
	callsub gate
	assert

	// contracts/raffle/raffle.algo.ts:213
	// assert(!this.entriesByAddress(this.txn.sender).exists, errs.ALREADY_ENTERED)
	bytec 8 //  "a"
	txn Sender
	concat
	box_len
	swap
	pop
	!
	assert

	// contracts/raffle/raffle.algo.ts:215
	// verifyPayTxn(payment, {
	//             amount: {
	//                 greaterThanEqualTo: this.minTickets.value + entryTotalMBR,
	//                 lessThanEqualTo: this.maxTickets.value + entryTotalMBR,
	//             },
	//             receiver: this.app.address,
	//         })
	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	bytec 13 //  "min_tickets"
	app_global_get
	intc 6 // 37800
	+
	>=

	// transaction verification failed: {"txn":"payment","field":"amount","condition":"greaterThanEqualTo","expected":">=this.minTickets.value + entryTotalMBR"}
	assert
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	bytec 14 //  "max_tickets"
	app_global_get
	intc 6 // 37800
	+
	<=

	// transaction verification failed: {"txn":"payment","field":"amount","condition":"lessThanEqualTo","expected":"<=this.maxTickets.value + entryTotalMBR"}
	assert

	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// contracts/raffle/raffle.algo.ts:223
	// loc = this.entryCount.value
	bytec 4 //  "entry_count"
	app_global_get
	frame_bury 0 // loc: uint64

	// contracts/raffle/raffle.algo.ts:224
	// this.entries(loc).value = this.txn.sender
	bytec 18 //  "e"
	frame_dig 0 // loc: uint64
	itob
	concat
	txn Sender
	box_put

	// contracts/raffle/raffle.algo.ts:225
	// this.entriesByAddress(this.txn.sender).value = this.entryCount.value
	bytec 8 //  "a"
	txn Sender
	concat
	bytec 4 //  "entry_count"
	app_global_get
	itob
	box_put

	// contracts/raffle/raffle.algo.ts:227
	// amount = payment.amount - entryTotalMBR
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	intc 6 // 37800
	-
	frame_bury 1 // amount: uint64

	// contracts/raffle/raffle.algo.ts:228
	// this.weights(loc / ChunkSize).value[loc % ChunkSize] = { amount: amount }
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	%
	intc 2 // 8
	* // acc * typeLength
	frame_dig 1 // amount: uint64
	itob
	bytec 6 //  "h"
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	/
	itob
	concat
	cover 2
	box_replace

	// contracts/raffle/raffle.algo.ts:229
	// this.weightTotals.value[loc / ChunkSize] += amount
	bytec 3 //  "w_totals"
	app_global_get
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	/
	intc 2 // 8
	* // acc * typeLength
	bytec 3 //  "w_totals"
	app_global_get
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	/
	intc 2 // 8
	* // acc * typeLength
	intc 2 // 8
	extract3
	btoi
	frame_dig 1 // amount: uint64
	+
	itob
	replace3
	bytec 3 //  "w_totals"
	swap
	app_global_put

	// contracts/raffle/raffle.algo.ts:231
	// this.entryCount.value += 1
	bytec 4 //  "entry_count"
	app_global_get
	intc 1 // 1
	+
	bytec 4 //  "entry_count"
	swap
	app_global_put

	// contracts/raffle/raffle.algo.ts:232
	// this.ticketCount.value += amount
	bytec 1 //  "ticket_count"
	app_global_get
	frame_dig 1 // amount: uint64
	+
	bytec 1 //  "ticket_count"
	swap
	app_global_put
	retsub

// enterAsa(pay,axfer,byte[][])void
*abi_route_enterAsa:
	// args: byte[][]
	txna ApplicationArgs 1

	// assetXfer: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 4 //  axfer
	==

	// argument 1 (assetXfer) for enterAsa must be a axfer transaction
	assert

	// payment: pay
	txn GroupIndex
	intc 15 // 2
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 2 (payment) for enterAsa must be a pay transaction
	assert

	// execute enterAsa(pay,axfer,byte[][])void
	callsub enterAsa
	intc 1 // 1
	return

// enterAsa(payment: PayTxn, assetXfer: AssetTransferTxn, args: bytes[]): void
enterAsa:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/raffle/raffle.algo.ts:236
	// assert(this.isLive(), errs.NOT_LIVE)
	callsub isLive
	assert

	// contracts/raffle/raffle.algo.ts:237
	// assert(this.ticketAsset.value.id !== 0, errs.TICKET_ASSET_ALGO)
	bytec 2 //  "ticket_asset"
	app_global_get
	intc 0 // 0
	!=
	assert

	// contracts/raffle/raffle.algo.ts:238
	// assert(this.gate(this.txn.sender, this.gateID.value, args), errs.FAILED_GATE)
	frame_dig -3 // args: bytes[]
	bytec 15 //  "gate"
	app_global_get
	txn Sender
	callsub gate
	assert

	// contracts/raffle/raffle.algo.ts:239
	// assert(!this.entriesByAddress(this.txn.sender).exists, errs.ALREADY_ENTERED)
	bytec 8 //  "a"
	txn Sender
	concat
	box_len
	swap
	pop
	!
	assert

	// contracts/raffle/raffle.algo.ts:241
	// verifyPayTxn(payment, {
	//             amount: entryTotalMBR,
	//             receiver: this.app.address,
	//         })
	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	intc 6 // 37800
	==

	// transaction verification failed: {"txn":"payment","field":"amount","expected":"entryTotalMBR"}
	assert

	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// contracts/raffle/raffle.algo.ts:246
	// verifyAssetTransferTxn(assetXfer, {
	//             xferAsset: this.ticketAsset.value,
	//             assetAmount: {
	//                 greaterThanEqualTo: this.minTickets.value,
	//                 lessThanEqualTo: this.maxTickets.value,
	//             },
	//             assetReceiver: this.app.address,
	//         })
	// verify xferAsset
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns XferAsset
	bytec 2 //  "ticket_asset"
	app_global_get
	==

	// transaction verification failed: {"txn":"assetXfer","field":"xferAsset","expected":"this.ticketAsset.value"}
	assert

	// verify assetAmount
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns AssetAmount
	bytec 13 //  "min_tickets"
	app_global_get
	>=

	// transaction verification failed: {"txn":"assetXfer","field":"assetAmount","condition":"greaterThanEqualTo","expected":">=this.minTickets.value"}
	assert
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns AssetAmount
	bytec 14 //  "max_tickets"
	app_global_get
	<=

	// transaction verification failed: {"txn":"assetXfer","field":"assetAmount","condition":"lessThanEqualTo","expected":"<=this.maxTickets.value"}
	assert

	// verify assetReceiver
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"assetXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// contracts/raffle/raffle.algo.ts:255
	// loc = this.entryCount.value
	bytec 4 //  "entry_count"
	app_global_get
	frame_bury 0 // loc: uint64

	// contracts/raffle/raffle.algo.ts:256
	// this.entries(loc).value = this.txn.sender
	bytec 18 //  "e"
	frame_dig 0 // loc: uint64
	itob
	concat
	txn Sender
	box_put

	// contracts/raffle/raffle.algo.ts:257
	// this.entriesByAddress(this.txn.sender).value = this.entryCount.value
	bytec 8 //  "a"
	txn Sender
	concat
	bytec 4 //  "entry_count"
	app_global_get
	itob
	box_put

	// contracts/raffle/raffle.algo.ts:259
	// amount = assetXfer.assetAmount
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns AssetAmount
	frame_bury 1 // amount: uint64

	// contracts/raffle/raffle.algo.ts:260
	// this.weights(loc / ChunkSize).value[loc % ChunkSize] = { amount: amount }
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	%
	intc 2 // 8
	* // acc * typeLength
	frame_dig 1 // amount: uint64
	itob
	bytec 6 //  "h"
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	/
	itob
	concat
	cover 2
	box_replace

	// contracts/raffle/raffle.algo.ts:261
	// this.weightTotals.value[loc / ChunkSize] += amount
	bytec 3 //  "w_totals"
	app_global_get
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	/
	intc 2 // 8
	* // acc * typeLength
	bytec 3 //  "w_totals"
	app_global_get
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	/
	intc 2 // 8
	* // acc * typeLength
	intc 2 // 8
	extract3
	btoi
	frame_dig 1 // amount: uint64
	+
	itob
	replace3
	bytec 3 //  "w_totals"
	swap
	app_global_put

	// contracts/raffle/raffle.algo.ts:263
	// this.entryCount.value += 1
	bytec 4 //  "entry_count"
	app_global_get
	intc 1 // 1
	+
	bytec 4 //  "entry_count"
	swap
	app_global_put

	// contracts/raffle/raffle.algo.ts:264
	// this.ticketCount.value += amount
	bytec 1 //  "ticket_count"
	app_global_get
	frame_dig 1 // amount: uint64
	+
	bytec 1 //  "ticket_count"
	swap
	app_global_put
	retsub

// add(pay,byte[][])void
*abi_route_add:
	// args: byte[][]
	txna ApplicationArgs 1

	// payment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 1 (payment) for add must be a pay transaction
	assert

	// execute add(pay,byte[][])void
	callsub add
	intc 1 // 1
	return

// add(payment: PayTxn, args: bytes[]): void
add:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/raffle/raffle.algo.ts:268
	// assert(this.isLive(), errs.NOT_LIVE)
	callsub isLive
	assert

	// contracts/raffle/raffle.algo.ts:269
	// assert(this.ticketAsset.value.id === 0, errs.TICKET_ASSET_NOT_ALGO)
	bytec 2 //  "ticket_asset"
	app_global_get
	intc 0 // 0
	==
	assert

	// contracts/raffle/raffle.algo.ts:270
	// assert(this.gate(this.txn.sender, this.gateID.value, args), errs.FAILED_GATE)
	frame_dig -2 // args: bytes[]
	bytec 15 //  "gate"
	app_global_get
	txn Sender
	callsub gate
	assert

	// contracts/raffle/raffle.algo.ts:271
	// assert(this.entriesByAddress(this.txn.sender).exists, errs.ENTRY_DOES_NOT_EXIST)
	bytec 8 //  "a"
	txn Sender
	concat
	box_len
	swap
	pop
	assert

	// contracts/raffle/raffle.algo.ts:273
	// loc = this.entriesByAddress(this.txn.sender).value
	bytec 8 //  "a"
	txn Sender
	concat
	box_get

	// box value does not exist: this.entriesByAddress(this.txn.sender).value
	assert
	btoi
	frame_bury 0 // loc: uint64

	// contracts/raffle/raffle.algo.ts:274
	// amount = this.weights(loc / ChunkSize).value[loc % ChunkSize].amount
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	%
	intc 2 // 8
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	bytec 6 //  "h"
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	/
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 1 // amount: uint64

	// contracts/raffle/raffle.algo.ts:276
	// verifyPayTxn(payment, {
	//             amount: {
	//                 greaterThanEqualTo: this.minTickets.value,
	//                 lessThanEqualTo: (this.maxTickets.value - amount),
	//             },
	//             receiver: this.app.address,
	//         })
	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	bytec 13 //  "min_tickets"
	app_global_get
	>=

	// transaction verification failed: {"txn":"payment","field":"amount","condition":"greaterThanEqualTo","expected":">=this.minTickets.value"}
	assert
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	bytec 14 //  "max_tickets"
	app_global_get
	frame_dig 1 // amount: uint64
	-
	<=

	// transaction verification failed: {"txn":"payment","field":"amount","condition":"lessThanEqualTo","expected":"<=(this.maxTickets.value - amount)"}
	assert

	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// contracts/raffle/raffle.algo.ts:284
	// this.weights(loc / ChunkSize).value[loc % ChunkSize].amount += payment.amount
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	%
	intc 2 // 8
	* // acc * typeLength
	intc 0 // 0
	+
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	%
	intc 2 // 8
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	bytec 6 //  "h"
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	/
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	+
	itob
	bytec 6 //  "h"
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	/
	itob
	concat
	cover 2
	box_replace

	// contracts/raffle/raffle.algo.ts:285
	// this.weightTotals.value[loc / ChunkSize] += payment.amount
	bytec 3 //  "w_totals"
	app_global_get
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	/
	intc 2 // 8
	* // acc * typeLength
	bytec 3 //  "w_totals"
	app_global_get
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	/
	intc 2 // 8
	* // acc * typeLength
	intc 2 // 8
	extract3
	btoi
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	+
	itob
	replace3
	bytec 3 //  "w_totals"
	swap
	app_global_put

	// contracts/raffle/raffle.algo.ts:286
	// this.ticketCount.value += amount
	bytec 1 //  "ticket_count"
	app_global_get
	frame_dig 1 // amount: uint64
	+
	bytec 1 //  "ticket_count"
	swap
	app_global_put
	retsub

// addAsa(axfer,byte[][])void
*abi_route_addAsa:
	// args: byte[][]
	txna ApplicationArgs 1

	// assetXfer: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 4 //  axfer
	==

	// argument 1 (assetXfer) for addAsa must be a axfer transaction
	assert

	// execute addAsa(axfer,byte[][])void
	callsub addAsa
	intc 1 // 1
	return

// addAsa(assetXfer: AssetTransferTxn, args: bytes[]): void
addAsa:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/raffle/raffle.algo.ts:290
	// assert(this.isLive(), errs.NOT_LIVE)
	callsub isLive
	assert

	// contracts/raffle/raffle.algo.ts:291
	// assert(this.ticketAsset.value.id !== 0, errs.TICKET_ASSET_ALGO)
	bytec 2 //  "ticket_asset"
	app_global_get
	intc 0 // 0
	!=
	assert

	// contracts/raffle/raffle.algo.ts:292
	// assert(this.gate(this.txn.sender, this.gateID.value, args), errs.FAILED_GATE)
	frame_dig -2 // args: bytes[]
	bytec 15 //  "gate"
	app_global_get
	txn Sender
	callsub gate
	assert

	// contracts/raffle/raffle.algo.ts:293
	// assert(this.entriesByAddress(this.txn.sender).exists, errs.ENTRY_DOES_NOT_EXIST)
	bytec 8 //  "a"
	txn Sender
	concat
	box_len
	swap
	pop
	assert

	// contracts/raffle/raffle.algo.ts:295
	// loc = this.entriesByAddress(this.txn.sender).value
	bytec 8 //  "a"
	txn Sender
	concat
	box_get

	// box value does not exist: this.entriesByAddress(this.txn.sender).value
	assert
	btoi
	frame_bury 0 // loc: uint64

	// contracts/raffle/raffle.algo.ts:296
	// amount = this.weights(loc / ChunkSize).value[loc % ChunkSize].amount
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	%
	intc 2 // 8
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	bytec 6 //  "h"
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	/
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 1 // amount: uint64

	// contracts/raffle/raffle.algo.ts:298
	// verifyAssetTransferTxn(assetXfer, {
	//             xferAsset: this.ticketAsset.value,
	//             assetAmount: {
	//                 greaterThanEqualTo: this.minTickets.value,
	//                 lessThanEqualTo: (this.maxTickets.value - amount),
	//             },
	//             assetReceiver: this.app.address,
	//         })
	// verify xferAsset
	frame_dig -1 // assetXfer: AssetTransferTxn
	gtxns XferAsset
	bytec 2 //  "ticket_asset"
	app_global_get
	==

	// transaction verification failed: {"txn":"assetXfer","field":"xferAsset","expected":"this.ticketAsset.value"}
	assert

	// verify assetAmount
	frame_dig -1 // assetXfer: AssetTransferTxn
	gtxns AssetAmount
	bytec 13 //  "min_tickets"
	app_global_get
	>=

	// transaction verification failed: {"txn":"assetXfer","field":"assetAmount","condition":"greaterThanEqualTo","expected":">=this.minTickets.value"}
	assert
	frame_dig -1 // assetXfer: AssetTransferTxn
	gtxns AssetAmount
	bytec 14 //  "max_tickets"
	app_global_get
	frame_dig 1 // amount: uint64
	-
	<=

	// transaction verification failed: {"txn":"assetXfer","field":"assetAmount","condition":"lessThanEqualTo","expected":"<=(this.maxTickets.value - amount)"}
	assert

	// verify assetReceiver
	frame_dig -1 // assetXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"assetXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// contracts/raffle/raffle.algo.ts:307
	// this.weights(loc / ChunkSize).value[loc % ChunkSize].amount += assetXfer.assetAmount
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	%
	intc 2 // 8
	* // acc * typeLength
	intc 0 // 0
	+
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	%
	intc 2 // 8
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	bytec 6 //  "h"
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	/
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_dig -1 // assetXfer: AssetTransferTxn
	gtxns AssetAmount
	+
	itob
	bytec 6 //  "h"
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	/
	itob
	concat
	cover 2
	box_replace

	// contracts/raffle/raffle.algo.ts:308
	// this.weightTotals.value[loc / ChunkSize] += assetXfer.assetAmount
	bytec 3 //  "w_totals"
	app_global_get
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	/
	intc 2 // 8
	* // acc * typeLength
	bytec 3 //  "w_totals"
	app_global_get
	frame_dig 0 // loc: uint64
	intc 3 // 4096
	/
	intc 2 // 8
	* // acc * typeLength
	intc 2 // 8
	extract3
	btoi
	frame_dig -1 // assetXfer: AssetTransferTxn
	gtxns AssetAmount
	+
	itob
	replace3
	bytec 3 //  "w_totals"
	swap
	app_global_put

	// contracts/raffle/raffle.algo.ts:309
	// this.ticketCount.value += amount
	bytec 1 //  "ticket_count"
	app_global_get
	frame_dig 1 // amount: uint64
	+
	bytec 1 //  "ticket_count"
	swap
	app_global_put
	retsub

// raffle()void
*abi_route_raffle:
	// execute raffle()void
	callsub raffle
	intc 1 // 1
	return

// raffle(): void
raffle:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// contracts/raffle/raffle.algo.ts:313
	// roundToUse = (this.endingRound.value + 1) + (4 * this.vrfGetFailureCount.value)
	bytec 17 //  "ending_round"
	app_global_get
	intc 1 // 1
	+
	intc 4 // 4
	bytec 19 //  "vrf_get_failure_count"
	app_global_get
	*
	+
	frame_bury 0 // roundToUse: uint64

	// contracts/raffle/raffle.algo.ts:314
	// assert(globals.round >= (roundToUse + 8), errs.NOT_ENOUGH_TIME)
	global Round
	frame_dig 0 // roundToUse: uint64
	intc 2 // 8
	+
	>=
	assert

	// contracts/raffle/raffle.algo.ts:315
	// assert(this.winningTicket.value === 0, errs.WINNER_ALREADY_DRAWN)
	bytec 11 //  "winning_ticket"
	app_global_get
	intc 0 // 0
	==
	assert

	// contracts/raffle/raffle.algo.ts:317
	// seed = sendMethodCall<typeof RandomnessBeacon.prototype.get, bytes>({
	//             applicationID: this.vrfBeaconAppID.value,
	//             methodArgs: [roundToUse, this.txn.txID],
	//             fee: 0,
	//         })
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	pushbytes 0x189392c5 // method "get(uint64,byte[])byte[]"
	itxn_field ApplicationArgs

	// contracts/raffle/raffle.algo.ts:318
	// applicationID: this.vrfBeaconAppID.value
	bytec 22 //  "vrf_beacon_app_id"
	app_global_get
	itxn_field ApplicationID

	// contracts/raffle/raffle.algo.ts:319
	// methodArgs: [roundToUse, this.txn.txID]
	frame_dig 0 // roundToUse: uint64
	itob
	itxn_field ApplicationArgs
	txn TxID
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs

	// contracts/raffle/raffle.algo.ts:320
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	extract 2 0
	frame_bury 1 // seed: byte[]

	// *if4_condition
	// contracts/raffle/raffle.algo.ts:323
	// seed.length === 0
	frame_dig 1 // seed: byte[]
	len
	intc 0 // 0
	==
	bz *if4_end

	// *if4_consequent
	// contracts/raffle/raffle.algo.ts:324
	// this.vrfGetFailureCount.value += 1
	bytec 19 //  "vrf_get_failure_count"
	app_global_get
	intc 1 // 1
	+
	bytec 19 //  "vrf_get_failure_count"
	swap
	app_global_put

	// contracts/raffle/raffle.algo.ts:325
	// return;
	retsub

*if4_end:
	// contracts/raffle/raffle.algo.ts:328
	// rngState = pcg64Init(substring3(seed, 0, 16) as bytes<16>)
	frame_dig 1 // seed: byte[]
	substring 0 16
	pushbytes 0x00000000000000000000000000000000
	concat
	dup
	extract 16 0
	bytec 0 // 0x
	b==
	assert
	extract 0 16
	callsub pcg64Init
	frame_bury 2 // rngState: (uint64,uint64)

	// contracts/raffle/raffle.algo.ts:331
	// upperBound = this.ticketCount.value
	bytec 1 //  "ticket_count"
	app_global_get
	frame_bury 3 // upperBound: uint64

	// *if5_condition
	// contracts/raffle/raffle.algo.ts:332
	// upperBound < MAX_UINT64
	frame_dig 3 // upperBound: uint64

	// utils/constants.ts:3
	// Uint<64>('18446744073709551615')
	intc 10 // 18446744073709551615
	<
	bz *if5_end

	// *if5_consequent
	// contracts/raffle/raffle.algo.ts:333
	// upperBound = upperBound += 1
	frame_dig 3 // upperBound: uint64
	intc 1 // 1
	+
	dup
	store 245 // assignment value
	frame_bury 3 // upperBound: uint64
	load 245 // assignment value
	frame_bury 3 // upperBound: uint64

*if5_end:
	// contracts/raffle/raffle.algo.ts:336
	// rngResult = pcg64Random(rngState, 1, upperBound, 1)
	intc 1 // 1
	frame_dig 3 // upperBound: uint64
	intc 1 // 1
	frame_dig 2 // rngState: (uint64,uint64)
	callsub pcg64Random
	frame_bury 4 // rngResult: ((uint64,uint64),uint64[])

	// contracts/raffle/raffle.algo.ts:337
	// this.winningTicket.value = rngResult[1][0]
	bytec 11 //  "winning_ticket"
	frame_dig 4 // rngResult: ((uint64,uint64),uint64[])
	store 255 // full array
	load 255 // full array
	intc 7 // 16
	extract_uint16
	intc 0 //  acc * typeLength
	+
	intc 15 // 2
	+ // add two for length
	load 255 // full array
	swap
	intc 2 // 8
	extract3
	btoi
	app_global_put
	retsub

// getWinnerWeightBoxInfo(): [uint64, uint64, uint64]
getWinnerWeightBoxInfo:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// contracts/raffle/raffle.algo.ts:341
	// startingIndex = 0
	intc 0 // 0
	frame_bury 0 // startingIndex: uint64

	// contracts/raffle/raffle.algo.ts:342
	// currentRangeStart = 1
	intc 1 // 1
	frame_bury 1 // currentRangeStart: uint64

	// contracts/raffle/raffle.algo.ts:343
	// currentRangeEnd = 0
	intc 0 // 0
	frame_bury 2 // currentRangeEnd: uint64

	// contracts/raffle/raffle.algo.ts:345
	// for (let i = 0; i < this.weightsBoxCount.value; i += 1)
	intc 0 // 0
	frame_bury 3 // i: uint64

*for_1:
	// contracts/raffle/raffle.algo.ts:345
	// i < this.weightsBoxCount.value
	frame_dig 3 // i: uint64
	bytec 9 //  "weights_box_count"
	app_global_get
	<
	bz *for_1_end

	// contracts/raffle/raffle.algo.ts:346
	// boxStake = this.weightTotals.value[i]
	bytec 3 //  "w_totals"
	app_global_get
	frame_dig 3 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	intc 2 // 8
	extract3
	btoi
	frame_bury 4 // boxStake: uint64

	// *if6_condition
	// contracts/raffle/raffle.algo.ts:347
	// this.winningTicket.value <= (currentRangeEnd + boxStake)
	bytec 11 //  "winning_ticket"
	app_global_get
	frame_dig 2 // currentRangeEnd: uint64
	frame_dig 4 // boxStake: uint64
	+
	<=
	bz *if6_end

	// *if6_consequent
	// contracts/raffle/raffle.algo.ts:348
	// return [startingIndex, currentRangeStart, currentRangeEnd];
	frame_dig 0 // startingIndex: uint64
	itob
	frame_dig 1 // currentRangeStart: uint64
	itob
	concat
	frame_dig 2 // currentRangeEnd: uint64
	itob
	concat
	b *getWinnerWeightBoxInfo*return

*if6_end:
	// contracts/raffle/raffle.algo.ts:351
	// startingIndex += ChunkSize
	frame_dig 0 // startingIndex: uint64
	intc 3 // 4096
	+
	frame_bury 0 // startingIndex: uint64

	// contracts/raffle/raffle.algo.ts:352
	// currentRangeEnd = currentRangeStart + boxStake
	frame_dig 1 // currentRangeStart: uint64
	frame_dig 4 // boxStake: uint64
	+
	frame_bury 2 // currentRangeEnd: uint64

	// contracts/raffle/raffle.algo.ts:353
	// currentRangeStart = currentRangeEnd + 1
	frame_dig 2 // currentRangeEnd: uint64
	intc 1 // 1
	+
	frame_bury 1 // currentRangeStart: uint64

*for_1_continue:
	// contracts/raffle/raffle.algo.ts:345
	// i += 1
	frame_dig 3 // i: uint64
	intc 1 // 1
	+
	frame_bury 3 // i: uint64
	b *for_1

*for_1_end:
	// contracts/raffle/raffle.algo.ts:356
	// return [startingIndex, currentRangeStart, currentRangeEnd];
	frame_dig 0 // startingIndex: uint64
	itob
	frame_dig 1 // currentRangeStart: uint64
	itob
	concat
	frame_dig 2 // currentRangeEnd: uint64
	itob
	concat

*getWinnerWeightBoxInfo*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// findWinner()void
*abi_route_findWinner:
	// execute findWinner()void
	callsub findWinner
	intc 1 // 1
	return

// findWinner(): void
findWinner:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 9

	// contracts/raffle/raffle.algo.ts:360
	// assert(globals.round < this.endingRound.value, errs.RAFFLE_HAS_NOT_ENDED)
	global Round
	bytec 17 //  "ending_round"
	app_global_get
	<
	assert

	// contracts/raffle/raffle.algo.ts:361
	// assert(this.winningTicket.value !== 0, errs.NO_WINNING_TICKET_YET)
	bytec 11 //  "winning_ticket"
	app_global_get
	intc 0 // 0
	!=
	assert

	// contracts/raffle/raffle.algo.ts:362
	// assert(this.raffleWinner.value === Address.zeroAddress, errs.WINNER_ALREADY_FOUND)
	bytec 5 //  "raffle_winner"
	app_global_get
	global ZeroAddress
	==
	assert

	// contracts/raffle/raffle.algo.ts:364
	// winningBoxInfo = this.getWinnerWeightBoxInfo()
	callsub getWinnerWeightBoxInfo
	frame_bury 0 // winningBoxInfo: (uint64,uint64,uint64)

	// contracts/raffle/raffle.algo.ts:367
	// startingIndex = winningBoxInfo[0]
	frame_dig 0 // winningBoxInfo: (uint64,uint64,uint64)
	extract 0 8
	btoi
	frame_bury 1 // startingIndex: uint64

	// contracts/raffle/raffle.algo.ts:368
	// currentRangeStart = winningBoxInfo[1]
	frame_dig 0 // winningBoxInfo: (uint64,uint64,uint64)
	extract 8 8
	btoi
	frame_bury 2 // currentRangeStart: uint64

	// contracts/raffle/raffle.algo.ts:369
	// currentRangeEnd = winningBoxInfo[2]
	frame_dig 0 // winningBoxInfo: (uint64,uint64,uint64)
	extract 16 8
	btoi
	frame_bury 3 // currentRangeEnd: uint64

	// contracts/raffle/raffle.algo.ts:371
	// remainder = this.entryCount.value - startingIndex
	bytec 4 //  "entry_count"
	app_global_get
	frame_dig 1 // startingIndex: uint64
	-
	frame_bury 4 // remainder: uint64

	// contracts/raffle/raffle.algo.ts:372
	// iterationAmount = (remainder > ChunkSize)
	//             ? ChunkSize
	//             : remainder
	frame_dig 4 // remainder: uint64
	intc 3 // 4096
	>
	bz *ternary0_false
	intc 3 // 4096
	b *ternary0_end

*ternary0_false:
	frame_dig 4 // remainder: uint64

*ternary0_end:
	frame_bury 5 // iterationAmount: uint64

	// contracts/raffle/raffle.algo.ts:376
	// weight = this.weights(startingIndex / ChunkSize).value
	bytec 6 //  "h"
	frame_dig 1 // startingIndex: uint64
	intc 3 // 4096
	/
	itob
	concat
	frame_bury 6 // storage key//weight

	// contracts/raffle/raffle.algo.ts:378
	// opUpIterationAmount = ((iterationAmount * 40) / 700)
	frame_dig 5 // iterationAmount: uint64
	pushint 40
	*
	intc 14 // 700
	/
	frame_bury 7 // opUpIterationAmount: uint64

	// contracts/raffle/raffle.algo.ts:379
	// log(' op up iteration amount: ' + opUpIterationAmount.toString())
	bytec 25 //  " op up iteration amount: "
	frame_dig 7 // opUpIterationAmount: uint64
	callsub *itoa
	concat
	log

	// contracts/raffle/raffle.algo.ts:380
	// for (let i = 0; i <= opUpIterationAmount; i += 1)
	intc 0 // 0
	frame_bury 8 // i: uint64

*for_2:
	// contracts/raffle/raffle.algo.ts:380
	// i <= opUpIterationAmount
	frame_dig 8 // i: uint64
	frame_dig 7 // opUpIterationAmount: uint64
	<=
	bz *for_2_end

	// contracts/raffle/raffle.algo.ts:381
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 20 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 16 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*for_2_continue:
	// contracts/raffle/raffle.algo.ts:380
	// i += 1
	frame_dig 8 // i: uint64
	intc 1 // 1
	+
	frame_bury 8 // i: uint64
	b *for_2

*for_2_end:
	// contracts/raffle/raffle.algo.ts:384
	// for (let i = 0; i < iterationAmount; i += 1)
	intc 0 // 0
	frame_bury 9 // i: uint64

*for_3:
	// contracts/raffle/raffle.algo.ts:384
	// i < iterationAmount
	frame_dig 9 // i: uint64
	frame_dig 5 // iterationAmount: uint64
	<
	bz *for_3_end

	// contracts/raffle/raffle.algo.ts:385
	// currentRangeEnd = currentRangeStart + weight[i].amount
	frame_dig 2 // currentRangeStart: uint64
	frame_dig 9 // i: uint64
	intc 2 // 8
	* // acc * typeLength
	intc 0 // 0
	+
	intc 2 // 8
	bytec 6 //  "h"
	frame_dig 1 // startingIndex: uint64
	intc 3 // 4096
	/
	itob
	concat
	cover 2
	box_extract
	btoi
	+
	frame_bury 3 // currentRangeEnd: uint64

	// *if7_condition
	// contracts/raffle/raffle.algo.ts:386
	// this.winningTicket.value >= currentRangeStart && this.winningTicket.value <= currentRangeEnd
	bytec 11 //  "winning_ticket"
	app_global_get
	frame_dig 2 // currentRangeStart: uint64
	>=
	dup
	bz *skip_and2
	bytec 11 //  "winning_ticket"
	app_global_get
	frame_dig 3 // currentRangeEnd: uint64
	<=
	&&

*skip_and2:
	bz *if7_end

	// *if7_consequent
	// contracts/raffle/raffle.algo.ts:387
	// this.raffleWinner.value = this.entries((startingIndex + i + 1)).value
	bytec 5 //  "raffle_winner"
	bytec 18 //  "e"
	frame_dig 1 // startingIndex: uint64
	frame_dig 9 // i: uint64
	+
	intc 1 // 1
	+
	itob
	concat
	box_get

	// box value does not exist: this.entries((startingIndex + i + 1)).value
	assert
	app_global_put

*if7_end:
	// contracts/raffle/raffle.algo.ts:389
	// currentRangeStart = currentRangeEnd + 1
	frame_dig 3 // currentRangeEnd: uint64
	intc 1 // 1
	+
	frame_bury 2 // currentRangeStart: uint64

*for_3_continue:
	// contracts/raffle/raffle.algo.ts:384
	// i += 1
	frame_dig 9 // i: uint64
	intc 1 // 1
	+
	frame_bury 9 // i: uint64
	b *for_3

*for_3_end:
	retsub

// refundMBR()void
*abi_route_refundMBR:
	// execute refundMBR()void
	callsub refundMBR
	intc 1 // 1
	return

// refundMBR(): void
refundMBR:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 7

	// contracts/raffle/raffle.algo.ts:394
	// totalCap = (this.entryCount.value - 1)
	bytec 4 //  "entry_count"
	app_global_get
	intc 1 // 1
	-
	frame_bury 0 // totalCap: uint64

	// contracts/raffle/raffle.algo.ts:396
	// assert(this.raffleWinner.value !== Address.zeroAddress, errs.WINNER_NOT_FOUND)
	bytec 5 //  "raffle_winner"
	app_global_get
	global ZeroAddress
	!=
	assert

	// contracts/raffle/raffle.algo.ts:398
	// assert(totalCap !== this.refundMBRCursor.value, errs.ALL_REFUNDS_COMPLETE)
	frame_dig 0 // totalCap: uint64
	bytec 10 //  "refund_mbr_cursor"
	app_global_get
	!=
	assert

	// contracts/raffle/raffle.algo.ts:400
	// startingIndex = this.refundMBRCursor.value
	bytec 10 //  "refund_mbr_cursor"
	app_global_get
	frame_bury 1 // startingIndex: uint64

	// contracts/raffle/raffle.algo.ts:401
	// remainder = totalCap - this.refundMBRCursor.value
	frame_dig 0 // totalCap: uint64
	bytec 10 //  "refund_mbr_cursor"
	app_global_get
	-
	frame_bury 2 // remainder: uint64

	// contracts/raffle/raffle.algo.ts:403
	// iterationAmount = (remainder > MaxRefundIterationsPerGroup)
	//             ? MaxRefundIterationsPerGroup
	//             : remainder
	frame_dig 2 // remainder: uint64
	intc 9 // 64
	>
	bz *ternary1_false
	intc 9 // 64
	b *ternary1_end

*ternary1_false:
	frame_dig 2 // remainder: uint64

*ternary1_end:
	frame_bury 3 // iterationAmount: uint64

	// contracts/raffle/raffle.algo.ts:407
	// opUpIterationAmount = ((iterationAmount * 100) / 700)
	frame_dig 3 // iterationAmount: uint64
	pushint 100
	*
	intc 14 // 700
	/
	frame_bury 4 // opUpIterationAmount: uint64

	// contracts/raffle/raffle.algo.ts:408
	// log(' op up iteration amount: ' + opUpIterationAmount.toString())
	bytec 25 //  " op up iteration amount: "
	frame_dig 4 // opUpIterationAmount: uint64
	callsub *itoa
	concat
	log

	// contracts/raffle/raffle.algo.ts:409
	// for (let i = 0; i <= opUpIterationAmount; i += 1)
	intc 0 // 0
	frame_bury 5 // i: uint64

*for_4:
	// contracts/raffle/raffle.algo.ts:409
	// i <= opUpIterationAmount
	frame_dig 5 // i: uint64
	frame_dig 4 // opUpIterationAmount: uint64
	<=
	bz *for_4_end

	// contracts/raffle/raffle.algo.ts:410
	// increaseOpcodeBudget()
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 20 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 16 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*for_4_continue:
	// contracts/raffle/raffle.algo.ts:409
	// i += 1
	frame_dig 5 // i: uint64
	intc 1 // 1
	+
	frame_bury 5 // i: uint64
	b *for_4

*for_4_end:
	// contracts/raffle/raffle.algo.ts:413
	// for (let i = startingIndex; i < iterationAmount; i += 1)
	frame_dig 1 // startingIndex: uint64
	frame_bury 6 // i: uint64

*for_5:
	// contracts/raffle/raffle.algo.ts:413
	// i < iterationAmount
	frame_dig 6 // i: uint64
	frame_dig 3 // iterationAmount: uint64
	<
	bz *for_5_end

	// contracts/raffle/raffle.algo.ts:414
	// entry = this.entries(i).value
	bytec 18 //  "e"
	frame_dig 6 // i: uint64
	itob
	concat
	box_get

	// box value does not exist: this.entries(i).value
	assert
	frame_bury 7 // entry: address

	// contracts/raffle/raffle.algo.ts:415
	// this.entries(i).delete()
	bytec 18 //  "e"
	frame_dig 6 // i: uint64
	itob
	concat
	box_del

	// contracts/raffle/raffle.algo.ts:416
	// this.entriesByAddress(entry).delete()
	bytec 8 //  "a"
	frame_dig 7 // entry: address
	concat
	box_del

	// contracts/raffle/raffle.algo.ts:417
	// sendPayment({
	//                 receiver: entry,
	//                 amount: entryTotalMBR,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:418
	// receiver: entry
	frame_dig 7 // entry: address
	itxn_field Receiver

	// contracts/raffle/raffle.algo.ts:419
	// amount: entryTotalMBR
	intc 6 // 37800
	itxn_field Amount

	// contracts/raffle/raffle.algo.ts:420
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*for_5_continue:
	// contracts/raffle/raffle.algo.ts:413
	// i += 1
	frame_dig 6 // i: uint64
	intc 1 // 1
	+
	frame_bury 6 // i: uint64
	b *for_5

*for_5_end:
	// contracts/raffle/raffle.algo.ts:424
	// this.refundMBRCursor.value += iterationAmount
	bytec 10 //  "refund_mbr_cursor"
	app_global_get
	frame_dig 3 // iterationAmount: uint64
	+
	bytec 10 //  "refund_mbr_cursor"
	swap
	app_global_put
	retsub

// claimRafflePrize()void
*abi_route_claimRafflePrize:
	// execute claimRafflePrize()void
	callsub claimRafflePrize
	intc 1 // 1
	return

// claimRafflePrize(): void
claimRafflePrize:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/raffle/raffle.algo.ts:428
	// assert(this.raffleWinner.value !== globals.zeroAddress, errs.WINNER_NOT_FOUND)
	bytec 5 //  "raffle_winner"
	app_global_get
	global ZeroAddress
	!=
	assert

	// contracts/raffle/raffle.algo.ts:429
	// assert(!this.rafflePrizeClaimed.value, errs.PRIZE_ALREADY_CLAIMED)
	bytec 16 //  "raffle_prize_claimed"
	app_global_get
	intc 0 // 0
	getbit
	!
	assert

	// contracts/raffle/raffle.algo.ts:431
	// winnerAmount = 0
	intc 0 // 0
	frame_bury 0 // winnerAmount: uint64

	// *if8_condition
	// contracts/raffle/raffle.algo.ts:432
	// this.prize.value.id === 0
	bytec 7 //  "prize"
	app_global_get
	intc 0 // 0
	==
	bz *if8_else

	// *if8_consequent
	// contracts/raffle/raffle.algo.ts:433
	// winnerAmount = (this.app.address.balance - this.app.address.minBalance)
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	-
	frame_bury 0 // winnerAmount: uint64

	// *if9_condition
	// contracts/raffle/raffle.algo.ts:434
	// this.prize.value === this.ticketAsset.value
	bytec 7 //  "prize"
	app_global_get
	bytec 2 //  "ticket_asset"
	app_global_get
	==
	bz *if9_end

	// *if9_consequent
	// contracts/raffle/raffle.algo.ts:435
	// winnerAmount -= this.ticketCount.value
	frame_dig 0 // winnerAmount: uint64
	bytec 1 //  "ticket_count"
	app_global_get
	-
	frame_bury 0 // winnerAmount: uint64

*if9_end:
	// contracts/raffle/raffle.algo.ts:438
	// sendPayment({
	//                 receiver: this.raffleWinner.value,
	//                 amount: winnerAmount,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:439
	// receiver: this.raffleWinner.value
	bytec 5 //  "raffle_winner"
	app_global_get
	itxn_field Receiver

	// contracts/raffle/raffle.algo.ts:440
	// amount: winnerAmount
	frame_dig 0 // winnerAmount: uint64
	itxn_field Amount

	// contracts/raffle/raffle.algo.ts:441
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if8_end

*if8_else:
	// contracts/raffle/raffle.algo.ts:444
	// shouldCloseTo = true
	intc 1 // 1
	frame_bury 1 // shouldCloseTo: bool

	// contracts/raffle/raffle.algo.ts:445
	// winnerAmount = this.app.address.assetBalance(this.prize.value)
	global CurrentApplicationAddress
	bytec 7 //  "prize"
	app_global_get
	asset_holding_get AssetBalance
	pop
	frame_bury 0 // winnerAmount: uint64

	// *if10_condition
	// contracts/raffle/raffle.algo.ts:446
	// this.prize.value === this.ticketAsset.value
	bytec 7 //  "prize"
	app_global_get
	bytec 2 //  "ticket_asset"
	app_global_get
	==
	bz *if10_end

	// *if10_consequent
	// contracts/raffle/raffle.algo.ts:447
	// winnerAmount -= this.ticketCount.value
	frame_dig 0 // winnerAmount: uint64
	bytec 1 //  "ticket_count"
	app_global_get
	-
	frame_bury 0 // winnerAmount: uint64

	// contracts/raffle/raffle.algo.ts:448
	// shouldCloseTo = false
	intc 0 // 0
	frame_bury 1 // shouldCloseTo: bool

*if10_end:
	// *if11_condition
	// contracts/raffle/raffle.algo.ts:451
	// this.raffleWinner.value.isOptedInToAsset(this.prize.value)
	bytec 5 //  "raffle_winner"
	app_global_get
	bytec 7 //  "prize"
	app_global_get
	asset_holding_get AssetBalance
	swap
	pop
	bz *if11_else

	// *if11_consequent
	// *if12_condition
	// contracts/raffle/raffle.algo.ts:452
	// shouldCloseTo
	frame_dig 1 // shouldCloseTo: bool
	bz *if12_else

	// *if12_consequent
	// contracts/raffle/raffle.algo.ts:453
	// sendAssetTransfer({
	//                         assetReceiver: this.raffleWinner.value,
	//                         assetCloseTo: this.raffleWinner.value,
	//                         assetAmount: winnerAmount,
	//                         xferAsset: this.prize.value,
	//                         fee: 0,
	//                     })
	itxn_begin
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:454
	// assetReceiver: this.raffleWinner.value
	bytec 5 //  "raffle_winner"
	app_global_get
	itxn_field AssetReceiver

	// contracts/raffle/raffle.algo.ts:455
	// assetCloseTo: this.raffleWinner.value
	bytec 5 //  "raffle_winner"
	app_global_get
	itxn_field AssetCloseTo

	// contracts/raffle/raffle.algo.ts:456
	// assetAmount: winnerAmount
	frame_dig 0 // winnerAmount: uint64
	itxn_field AssetAmount

	// contracts/raffle/raffle.algo.ts:457
	// xferAsset: this.prize.value
	bytec 7 //  "prize"
	app_global_get
	itxn_field XferAsset

	// contracts/raffle/raffle.algo.ts:458
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if12_end

*if12_else:
	// contracts/raffle/raffle.algo.ts:461
	// sendAssetTransfer({
	//                         assetReceiver: this.raffleWinner.value,
	//                         assetAmount: winnerAmount,
	//                         xferAsset: this.prize.value,
	//                         fee: 0,
	//                     })
	itxn_begin
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:462
	// assetReceiver: this.raffleWinner.value
	bytec 5 //  "raffle_winner"
	app_global_get
	itxn_field AssetReceiver

	// contracts/raffle/raffle.algo.ts:463
	// assetAmount: winnerAmount
	frame_dig 0 // winnerAmount: uint64
	itxn_field AssetAmount

	// contracts/raffle/raffle.algo.ts:464
	// xferAsset: this.prize.value
	bytec 7 //  "prize"
	app_global_get
	itxn_field XferAsset

	// contracts/raffle/raffle.algo.ts:465
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if12_end:
	b *if11_end

*if11_else:
	// contracts/raffle/raffle.algo.ts:469
	// this.arc59OptInAndSend(
	//                     this.raffleWinner.value,
	//                     this.prize.value,
	//                     winnerAmount,
	//                     shouldCloseTo
	//                 )
	frame_dig 1 // shouldCloseTo: bool
	frame_dig 0 // winnerAmount: uint64
	bytec 7 //  "prize"
	app_global_get
	bytec 5 //  "raffle_winner"
	app_global_get
	callsub arc59OptInAndSend

*if11_end:

*if8_end:
	// *if13_condition
	// contracts/raffle/raffle.algo.ts:478
	// this.ticketAsset.value.id === 0
	bytec 2 //  "ticket_asset"
	app_global_get
	intc 0 // 0
	==
	bz *if13_else

	// *if13_consequent
	// contracts/raffle/raffle.algo.ts:479
	// sendPayment({
	//                 receiver: this.seller.value,
	//                 amount: this.ticketCount.value,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:480
	// receiver: this.seller.value
	bytec 12 //  "seller"
	app_global_get
	itxn_field Receiver

	// contracts/raffle/raffle.algo.ts:481
	// amount: this.ticketCount.value
	bytec 1 //  "ticket_count"
	app_global_get
	itxn_field Amount

	// contracts/raffle/raffle.algo.ts:482
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if13_end

*if13_else:
	// *if14_condition
	// contracts/raffle/raffle.algo.ts:485
	// this.seller.value.isOptedInToAsset(this.ticketAsset.value)
	bytec 12 //  "seller"
	app_global_get
	bytec 2 //  "ticket_asset"
	app_global_get
	asset_holding_get AssetBalance
	swap
	pop
	bz *if14_else

	// *if14_consequent
	// contracts/raffle/raffle.algo.ts:486
	// sendAssetTransfer({
	//                     assetReceiver: this.seller.value,
	//                     assetCloseTo: this.seller.value,
	//                     assetAmount: this.ticketCount.value,
	//                     xferAsset: this.ticketAsset.value,
	//                     fee: 0,
	//                 })
	itxn_begin
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:487
	// assetReceiver: this.seller.value
	bytec 12 //  "seller"
	app_global_get
	itxn_field AssetReceiver

	// contracts/raffle/raffle.algo.ts:488
	// assetCloseTo: this.seller.value
	bytec 12 //  "seller"
	app_global_get
	itxn_field AssetCloseTo

	// contracts/raffle/raffle.algo.ts:489
	// assetAmount: this.ticketCount.value
	bytec 1 //  "ticket_count"
	app_global_get
	itxn_field AssetAmount

	// contracts/raffle/raffle.algo.ts:490
	// xferAsset: this.ticketAsset.value
	bytec 2 //  "ticket_asset"
	app_global_get
	itxn_field XferAsset

	// contracts/raffle/raffle.algo.ts:491
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if14_end

*if14_else:
	// contracts/raffle/raffle.algo.ts:494
	// this.arc59OptInAndSend(
	//                     this.seller.value,
	//                     this.ticketAsset.value,
	//                     this.ticketCount.value,
	//                     true
	//                 )
	intc 1 // 1
	bytec 1 //  "ticket_count"
	app_global_get
	bytec 2 //  "ticket_asset"
	app_global_get
	bytec 12 //  "seller"
	app_global_get
	callsub arc59OptInAndSend

*if14_end:

*if13_end:
	// contracts/raffle/raffle.algo.ts:503
	// this.rafflePrizeClaimed.value = true
	bytec 16 //  "raffle_prize_claimed"
	intc 1 // 1
	bytec 21 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// clearWeightsBoxes()uint64
*abi_route_clearWeightsBoxes:
	// The ABI return prefix
	bytec 24 // 0x151f7c75

	// execute clearWeightsBoxes()uint64
	callsub clearWeightsBoxes
	itob
	concat
	log
	intc 1 // 1
	return

// clearWeightsBoxes(): uint64
clearWeightsBoxes:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/raffle/raffle.algo.ts:507
	// assert(this.txn.sender === this.app.creator, errs.MUST_BE_CALLED_FROM_FACTORY)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==
	assert

	// contracts/raffle/raffle.algo.ts:509
	// for (let i = 0; i < this.weightsBoxCount.value; i += 1)
	intc 0 // 0
	frame_bury 0 // i: uint64

*for_6:
	// contracts/raffle/raffle.algo.ts:509
	// i < this.weightsBoxCount.value
	frame_dig 0 // i: uint64
	bytec 9 //  "weights_box_count"
	app_global_get
	<
	bz *for_6_end

	// contracts/raffle/raffle.algo.ts:510
	// ri = (this.weightsBoxCount.value - 1) - i
	bytec 9 //  "weights_box_count"
	app_global_get
	intc 1 // 1
	-
	frame_dig 0 // i: uint64
	-
	frame_bury 1 // ri: uint64

	// contracts/raffle/raffle.algo.ts:511
	// this.weights(ri).delete()
	bytec 6 //  "h"
	frame_dig 1 // ri: uint64
	itob
	concat
	box_del

*for_6_continue:
	// contracts/raffle/raffle.algo.ts:509
	// i += 1
	frame_dig 0 // i: uint64
	intc 1 // 1
	+
	frame_bury 0 // i: uint64
	b *for_6

*for_6_end:
	// contracts/raffle/raffle.algo.ts:514
	// returnAmount = this.weightsBoxCount.value * weightsListMBR
	bytec 9 //  "weights_box_count"
	app_global_get
	intc 13 // 13113300
	*
	frame_bury 2 // returnAmount: uint64

	// contracts/raffle/raffle.algo.ts:516
	// sendPayment({
	//             receiver: this.app.creator,
	//             amount: returnAmount,
	//             fee: 0,
	//         })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:517
	// receiver: this.app.creator
	txna Applications 0
	app_params_get AppCreator
	pop
	itxn_field Receiver

	// contracts/raffle/raffle.algo.ts:518
	// amount: returnAmount
	frame_dig 2 // returnAmount: uint64
	itxn_field Amount

	// contracts/raffle/raffle.algo.ts:519
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/raffle/raffle.algo.ts:522
	// this.weightsBoxCount.value = 0
	bytec 9 //  "weights_box_count"
	intc 0 // 0
	app_global_put

	// contracts/raffle/raffle.algo.ts:523
	// return returnAmount;
	frame_dig 2 // returnAmount: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// deleteApplication()void
*abi_route_deleteApplication:
	// execute deleteApplication()void
	callsub deleteApplication
	intc 1 // 1
	return

// deleteApplication(): void
deleteApplication:
	proto 0 0

	// contracts/raffle/raffle.algo.ts:527
	// assert(this.txn.sender === this.app.creator, errs.MUST_BE_CALLED_FROM_FACTORY)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==
	assert

	// contracts/raffle/raffle.algo.ts:528
	// assert(this.rafflePrizeClaimed.value, errs.PRIZE_NOT_CLAIMED)
	bytec 16 //  "raffle_prize_claimed"
	app_global_get
	intc 0 // 0
	getbit
	assert

	// contracts/raffle/raffle.algo.ts:529
	// assert((this.entryCount.value - 1) !== this.refundMBRCursor.value, errs.ALL_REFUNDS_COMPLETE)
	bytec 4 //  "entry_count"
	app_global_get
	intc 1 // 1
	-
	bytec 10 //  "refund_mbr_cursor"
	app_global_get
	!=
	assert

	// contracts/raffle/raffle.algo.ts:530
	// assert(this.weightsBoxCount.value === 0, errs.STILL_HAS_WEIGHTS_BOXES)
	bytec 9 //  "weights_box_count"
	app_global_get
	intc 0 // 0
	==
	assert
	retsub

// getState()(uint64,uint64,uint64,address,uint64,uint64,uint64,uint64,uint64,address,uint64,bool,uint64,uint64,uint64,uint64,uint64)
*abi_route_getState:
	// The ABI return prefix
	bytec 24 // 0x151f7c75

	// execute getState()(uint64,uint64,uint64,address,uint64,uint64,uint64,uint64,uint64,address,uint64,bool,uint64,uint64,uint64,uint64,uint64)
	callsub getState
	concat
	log
	intc 1 // 1
	return

// getState(): RaffleState
getState:
	proto 0 1

	// contracts/raffle/raffle.algo.ts:534
	// return {
	//             ticketAsset: this.ticketAsset.value,
	//             startingRound: this.startingRound.value,
	//             endingRound: this.endingRound.value,
	//             seller: this.seller.value,
	//             minTickets: this.minTickets.value,
	//             maxTickets: this.maxTickets.value,
	//             entryCount: this.entryCount.value,
	//             ticketCount: this.ticketCount.value,
	//             winningTicket: this.winningTicket.value,
	//             raffleWinner: this.raffleWinner.value,
	//             prize: this.prize.value,
	//             rafflePrizeClaimed: this.rafflePrizeClaimed.value,
	//             gateID: this.gateID.value,
	//             vrfBeaconAppID: this.vrfBeaconAppID.value,
	//             vrfGetFailureCount: this.vrfGetFailureCount.value,
	//             entryID: this.entryID.value,
	//             refundMBRCursor: this.refundMBRCursor.value,
	//         }
	bytec 2 //  "ticket_asset"
	app_global_get
	itob
	bytec 23 //  "starting_round"
	app_global_get
	itob
	concat
	bytec 17 //  "ending_round"
	app_global_get
	itob
	concat
	bytec 12 //  "seller"
	app_global_get
	concat
	bytec 13 //  "min_tickets"
	app_global_get
	itob
	concat
	bytec 14 //  "max_tickets"
	app_global_get
	itob
	concat
	bytec 4 //  "entry_count"
	app_global_get
	itob
	concat
	bytec 1 //  "ticket_count"
	app_global_get
	itob
	concat
	bytec 11 //  "winning_ticket"
	app_global_get
	itob
	concat
	bytec 5 //  "raffle_winner"
	app_global_get
	concat
	bytec 7 //  "prize"
	app_global_get
	itob
	concat
	bytec 21 // 0x00
	intc 0 // 0
	bytec 16 //  "raffle_prize_claimed"
	app_global_get
	intc 0 // 0
	getbit
	setbit
	concat // 12
	bytec 15 //  "gate"
	app_global_get
	itob
	concat
	bytec 22 //  "vrf_beacon_app_id"
	app_global_get
	itob
	concat
	bytec 19 //  "vrf_get_failure_count"
	app_global_get
	itob
	concat
	bytec 26 //  "entry_id"
	app_global_get
	itob
	concat
	bytec 10 //  "refund_mbr_cursor"
	app_global_get
	itob
	concat
	retsub

*create_NoOp:
	pushbytes 0xf36dbd7a // method "createApplication(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x3ea11832 // method "optin(pay,uint64)void"
	pushbytes 0x8fa4a160 // method "isLive()bool"
	pushbytes 0xbd7148d0 // method "init(pay,uint64)void"
	pushbytes 0x75eb7702 // method "enter(pay,byte[][])void"
	pushbytes 0x2f71c24c // method "enterAsa(pay,axfer,byte[][])void"
	pushbytes 0x054a3020 // method "add(pay,byte[][])void"
	pushbytes 0x482121c3 // method "addAsa(axfer,byte[][])void"
	pushbytes 0x696501de // method "raffle()void"
	pushbytes 0xb733d519 // method "findWinner()void"
	pushbytes 0x1eb82564 // method "refundMBR()void"
	pushbytes 0x65fca98b // method "claimRafflePrize()void"
	pushbytes 0x2c942514 // method "clearWeightsBoxes()uint64"
	pushbytes 0x58f6730e // method "getState()(uint64,uint64,uint64,address,uint64,uint64,uint64,uint64,uint64,address,uint64,bool,uint64,uint64,uint64,uint64,uint64)"
	txna ApplicationArgs 0
	match *abi_route_optin *abi_route_isLive *abi_route_init *abi_route_enter *abi_route_enterAsa *abi_route_add *abi_route_addAsa *abi_route_raffle *abi_route_findWinner *abi_route_refundMBR *abi_route_claimRafflePrize *abi_route_clearWeightsBoxes *abi_route_getState

	// this contract does not implement the given ABI method for call NoOp
	err

*call_DeleteApplication:
	pushbytes 0x2487c32c // method "deleteApplication()void"
	txna ApplicationArgs 0
	match *abi_route_deleteApplication

	// this contract does not implement the given ABI method for call DeleteApplication
	err

// pcg64Random(state: PCG64STATE, lowerBound: uint64, upperBound: uint64, length: uint64): [PCG64STATE, uint64[]]
pcg64Random:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 7

	// utils/types/lib_pcg/pcg64.algo.ts:29
	// result: uint64[] = []
	bytec 0 // 0x
	frame_bury 0 // result: uint64[]

	// utils/types/lib_pcg/pcg64.algo.ts:33
	// newState = clone(state)
	frame_dig -1 // state: PCG64STATE
	frame_bury 3 // newState: (uint64,uint64)

	// *if15_condition
	// utils/types/lib_pcg/pcg64.algo.ts:35
	// lowerBound === 0 && upperBound === 0
	frame_dig -2 // lowerBound: uint64
	intc 0 // 0
	==
	dup
	bz *skip_and3
	frame_dig -3 // upperBound: uint64
	intc 0 // 0
	==
	&&

*skip_and3:
	bz *if15_else

	// *if15_consequent
	// utils/types/lib_pcg/pcg64.algo.ts:36
	// for (let i = 0; i < length; i = i + 1)
	intc 0 // 0
	frame_bury 4 // i: uint64

*for_7:
	// utils/types/lib_pcg/pcg64.algo.ts:36
	// i < length
	frame_dig 4 // i: uint64
	frame_dig -4 // length: uint64
	<
	bz *for_7_end

	// utils/types/lib_pcg/pcg64.algo.ts:37
	// stepResult = __pcg64Random(newState)
	frame_dig 3 // newState: (uint64,uint64)
	callsub __pcg64Random
	frame_bury 5 // stepResult: ((uint64,uint64),uint64)

	// utils/types/lib_pcg/pcg64.algo.ts:38
	// newState = stepResult[0]
	frame_dig 5 // stepResult: ((uint64,uint64),uint64)
	extract 0 16
	frame_bury 3 // newState: (uint64,uint64)

	// utils/types/lib_pcg/pcg64.algo.ts:39
	// result.push(stepResult[1])
	frame_dig 0 // result: uint64[]
	frame_dig 5 // stepResult: ((uint64,uint64),uint64)
	extract 16 8
	btoi
	itob
	concat
	frame_bury 0 // result: uint64[]

*for_7_continue:
	// utils/types/lib_pcg/pcg64.algo.ts:36
	// i = i + 1
	frame_dig 4 // i: uint64
	intc 1 // 1
	+
	frame_bury 4 // i: uint64
	b *for_7

*for_7_end:
	b *if15_end

*if15_else:
	// *if16_condition
	// utils/types/lib_pcg/pcg64.algo.ts:42
	// upperBound !== 0
	frame_dig -3 // upperBound: uint64
	intc 0 // 0
	!=
	bz *if16_else

	// *if16_consequent
	// utils/types/lib_pcg/pcg64.algo.ts:43
	// assert(upperBound > 1)
	frame_dig -3 // upperBound: uint64
	intc 1 // 1
	>
	assert

	// utils/types/lib_pcg/pcg64.algo.ts:44
	// assert(lowerBound < upperBound - 1)
	frame_dig -2 // lowerBound: uint64
	frame_dig -3 // upperBound: uint64
	intc 1 // 1
	-
	<
	assert

	// utils/types/lib_pcg/pcg64.algo.ts:46
	// absoluteBound = upperBound - lowerBound
	frame_dig -3 // upperBound: uint64
	frame_dig -2 // lowerBound: uint64
	-
	frame_bury 1 // absoluteBound: uint64
	b *if16_end

*if16_else:
	// utils/types/lib_pcg/pcg64.algo.ts:49
	// assert(lowerBound < Uint<64>('18446744073709551615'))
	frame_dig -2 // lowerBound: uint64
	intc 10 // 18446744073709551615
	<
	assert

	// utils/types/lib_pcg/pcg64.algo.ts:54
	// absoluteBound = (Uint<128>('18446744073709551616') - (lowerBound as uint128)) as uint64
	pushbytes 0x00000000000000010000000000000000
	frame_dig -2 // lowerBound: uint64
	itob
	b-
	dup
	bitlen
	intc 9 // 64
	<=

	// (Uint<128>('18446744073709551616') - (lowerBound as uint128)) as uint64 overflowed 64 bits
	assert
	pushbytes 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 2 // 8
	-
	swap
	substring3
	btoi
	frame_bury 1 // absoluteBound: uint64

*if16_end:
	// utils/types/lib_pcg/pcg64.algo.ts:57
	// threshold = __uint64Twos(absoluteBound) % absoluteBound
	frame_dig 1 // absoluteBound: uint64
	callsub __uint64Twos
	frame_dig 1 // absoluteBound: uint64
	%
	frame_bury 2 // threshold: uint64

	// utils/types/lib_pcg/pcg64.algo.ts:59
	// for (let i = 0; i < length; i = i + 1)
	intc 0 // 0
	frame_bury 6 // i: uint64

*for_8:
	// utils/types/lib_pcg/pcg64.algo.ts:59
	// i < length
	frame_dig 6 // i: uint64
	frame_dig -4 // length: uint64
	<
	bz *for_8_end

*while_0:

*while_0_continue:
	// utils/types/lib_pcg/pcg64.algo.ts:61
	// true
	intc 1 // 1
	bz *while_0_end

	// utils/types/lib_pcg/pcg64.algo.ts:62
	// stepResult = __pcg64Random(newState)
	frame_dig 3 // newState: (uint64,uint64)
	callsub __pcg64Random
	frame_bury 7 // stepResult: ((uint64,uint64),uint64)

	// utils/types/lib_pcg/pcg64.algo.ts:63
	// newState = stepResult[0]
	frame_dig 7 // stepResult: ((uint64,uint64),uint64)
	extract 0 16
	frame_bury 3 // newState: (uint64,uint64)

	// *if17_condition
	// utils/types/lib_pcg/pcg64.algo.ts:64
	// stepResult[1] >= threshold
	frame_dig 7 // stepResult: ((uint64,uint64),uint64)
	extract 16 8
	btoi
	frame_dig 2 // threshold: uint64
	>=
	bz *if17_end

	// *if17_consequent
	// utils/types/lib_pcg/pcg64.algo.ts:65
	// result.push((stepResult[1] % absoluteBound) + lowerBound)
	frame_dig 0 // result: uint64[]
	frame_dig 7 // stepResult: ((uint64,uint64),uint64)
	extract 16 8
	btoi
	frame_dig 1 // absoluteBound: uint64
	%
	frame_dig -2 // lowerBound: uint64
	+
	itob
	concat
	frame_bury 0 // result: uint64[]
	b *while_0_end

*if17_end:
	b *while_0

*while_0_end:

*for_8_continue:
	// utils/types/lib_pcg/pcg64.algo.ts:59
	// i = i + 1
	frame_dig 6 // i: uint64
	intc 1 // 1
	+
	frame_bury 6 // i: uint64
	b *for_8

*for_8_end:

*if15_end:
	// utils/types/lib_pcg/pcg64.algo.ts:72
	// return [newState, result];
	bytec 0 //  initial head
	bytec 0 //  initial tail
	pushbytes 0x0012 // initial head offset
	frame_dig 3 // newState: (uint64,uint64)
	callsub *process_static_tuple_element
	frame_dig 0 // result: uint64[]
	dup
	len
	intc 2 // 8
	/
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

// __uint64Twos(value: uint64): uint64
__uint64Twos:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// utils/types/lib_pcg/pcg32.algo.ts:6
	// addwResult = addw(~value, 1)
	frame_dig -1 // value: uint64
	~
	intc 1 // 1
	addw
	frame_bury 0 // addwResult low: uint64
	frame_bury 1 // addwResult high: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:7
	// return addwResult.low;
	frame_dig 0 // addwResult low: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// __pcg64Random(state: PCG64STATE): [PCG64STATE, uint64]
__pcg64Random:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// utils/types/lib_pcg/pcg64.algo.ts:7
	// highResult = __pcg32UnboundedRandom(state[0])
	frame_dig -1 // state: PCG64STATE
	extract 0 8
	btoi
	callsub __pcg32UnboundedRandom
	frame_bury 0 // highResult: (uint64,uint64)

	// utils/types/lib_pcg/pcg64.algo.ts:9
	// lowState = __pcg32Step(state[1], pcgSecondIncrement << (highResult[0] === 0 ? 1 : 0))
	// utils/types/lib_pcg/consts.algo.ts:5
	// Uint<64>('1442695040888963409')
	intc 11 // 1442695040888963409

	// utils/types/lib_pcg/pcg64.algo.ts:9
	// highResult[0] === 0
	frame_dig 0 // highResult: (uint64,uint64)
	extract 0 8
	btoi
	intc 0 // 0
	==
	bz *ternary3_false
	intc 1 // 1
	b *ternary3_end

*ternary3_false:
	intc 0 // 0

*ternary3_end:
	shl

	// utils/types/lib_pcg/pcg64.algo.ts:9
	// state[1]
	frame_dig -1 // state: PCG64STATE
	extract 8 8
	btoi
	callsub __pcg32Step
	frame_bury 1 // lowState: uint64

	// utils/types/lib_pcg/pcg64.algo.ts:11
	// return [[highResult[0], lowState], (highResult[1] << 32) | __pcg32Output(state[1])];
	frame_dig 0 // highResult: (uint64,uint64)
	extract 0 8
	btoi
	itob
	frame_dig 1 // lowState: uint64
	itob
	concat
	frame_dig 0 // highResult: (uint64,uint64)
	extract 8 8
	btoi
	intc 17 // 32
	shl
	frame_dig -1 // state: PCG64STATE
	extract 8 8
	btoi
	callsub __pcg32Output
	|
	itob
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// __pcg32Output(state: PCG32STATE): uint64
__pcg32Output:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// utils/types/lib_pcg/pcg32.algo.ts:23
	// xorshifted = __maskToUint32(((state >> 18) ^ state) >> 27)
	frame_dig -1 // state: PCG32STATE
	pushint 18
	shr
	frame_dig -1 // state: PCG32STATE
	^
	pushint 27
	shr
	callsub __maskToUint32
	frame_bury 0 // xorshifted: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:24
	// rot = state >> 59
	frame_dig -1 // state: PCG32STATE
	pushint 59
	shr
	frame_bury 1 // rot: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:25
	// return (xorshifted >> rot) | __maskToUint32(xorshifted << (__uint64Twos(rot) & 31));
	frame_dig 0 // xorshifted: uint64
	frame_dig 1 // rot: uint64
	shr
	frame_dig 0 // xorshifted: uint64
	frame_dig 1 // rot: uint64
	callsub __uint64Twos
	pushint 31
	&
	shl
	callsub __maskToUint32
	|

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// __maskToUint32(value: uint64): uint64
__maskToUint32:
	proto 1 1

	// utils/types/lib_pcg/pcg32.algo.ts:12
	// return value & 4294967295;
	frame_dig -1 // value: uint64
	pushint 4294967295
	&
	retsub

// __pcg32Step(state: PCG32STATE, incr: uint64): uint64
__pcg32Step:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// utils/types/lib_pcg/pcg32.algo.ts:16
	// mulwResult = mulw(state, pcgMultiplier)
	frame_dig -1 // state: PCG32STATE

	// utils/types/lib_pcg/consts.algo.ts:1
	// Uint<64>('6364136223846793005')
	pushint 6364136223846793005
	mulw
	frame_bury 0 // mulwResult low: uint64
	frame_bury 1 // mulwResult high: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:17
	// addwResult = addw(mulwResult.low, incr)
	frame_dig 0 // mulwResult low: uint64
	frame_dig -2 // incr: uint64
	addw
	frame_bury 2 // addwResult low: uint64
	frame_bury 3 // addwResult high: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:19
	// return addwResult.low;
	frame_dig 2 // addwResult low: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// __pcg32UnboundedRandom(state: PCG32STATE): [PCG32STATE, uint64]
__pcg32UnboundedRandom:
	proto 1 1

	// utils/types/lib_pcg/pcg32.algo.ts:29
	// return [__pcg32Step(state, pcgFirstIncrement), __pcg32Output(state)];
	// utils/types/lib_pcg/consts.algo.ts:3
	// Uint<64>('1442695040888963407')
	intc 12 // 1442695040888963407
	frame_dig -1 // state: PCG32STATE
	callsub __pcg32Step
	itob

	// utils/types/lib_pcg/pcg32.algo.ts:29
	// __pcg32Output(state)
	frame_dig -1 // state: PCG32STATE
	callsub __pcg32Output
	itob
	concat
	retsub

// pcg64Init(seed: bytes<16>): PCG64STATE
pcg64Init:
	proto 1 1

	// utils/types/lib_pcg/pcg64.algo.ts:15
	// assert(seed.length === 16)
	intc 7 // 16
	dup
	==
	assert

	// utils/types/lib_pcg/pcg64.algo.ts:17
	// return [
	//     __pcg32Init(extractUint64(seed, 0), pcgFirstIncrement),
	//     __pcg32Init(extractUint64(seed, 8), pcgSecondIncrement),
	//   ];
	// utils/types/lib_pcg/consts.algo.ts:3
	// Uint<64>('1442695040888963407')
	intc 12 // 1442695040888963407

	// utils/types/lib_pcg/pcg64.algo.ts:18
	// extractUint64(seed, 0)
	frame_dig -1 // seed: bytes<16>
	intc 0 // 0
	extract_uint64
	callsub __pcg32Init
	itob

	// utils/types/lib_pcg/pcg64.algo.ts:19
	// __pcg32Init(extractUint64(seed, 8), pcgSecondIncrement)
	// utils/types/lib_pcg/consts.algo.ts:5
	// Uint<64>('1442695040888963409')
	intc 11 // 1442695040888963409

	// utils/types/lib_pcg/pcg64.algo.ts:19
	// extractUint64(seed, 8)
	frame_dig -1 // seed: bytes<16>
	intc 2 // 8
	extract_uint64
	callsub __pcg32Init
	itob
	concat
	retsub

// __pcg32Init(initialState: PCG32STATE, incr: uint64): PCG32STATE
__pcg32Init:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// utils/types/lib_pcg/pcg32.algo.ts:90
	// state = __pcg32Step(0, incr)
	frame_dig -2 // incr: uint64
	intc 0 // 0
	callsub __pcg32Step
	frame_bury 0 // state: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:91
	// addwResult = addw(state, initialState)
	frame_dig 0 // state: uint64
	frame_dig -1 // initialState: PCG32STATE
	addw
	frame_bury 1 // addwResult low: uint64
	frame_bury 2 // addwResult high: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:93
	// return __pcg32Step(addwResult.low, incr);
	frame_dig -2 // incr: uint64
	frame_dig 1 // addwResult low: uint64
	callsub __pcg32Step

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

*intToAscii:
	proto 1 1
	pushbytes 0x30313233343536373839 // "0123456789"
	frame_dig -1 // i: uint64
	intc 1 // 1
	extract3
	retsub
	

*itoa:
	proto 1 1
	frame_dig -1 // i: uint64
	intc 0 // 0
	==
	bz *itoa_if_end
	pushbytes 0x30
	retsub

*itoa_if_end:
	frame_dig -1 // i: uint64
	intc 8 // 10
	/
	intc 0 // 0
	>
	bz *itoa_ternary_false
	frame_dig -1 // i: uint64
	intc 8 // 10
	/
	callsub *itoa
	b *itoa_ternary_end

*itoa_ternary_false:
	bytec 0 //  ""

*itoa_ternary_end:
	frame_dig -1 // i: uint64
	intc 8 // 10
	%
	callsub *intToAscii
	concat
	retsub

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub