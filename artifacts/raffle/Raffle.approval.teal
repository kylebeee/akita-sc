#pragma version 10
intcblock 0 1 4 8 37000 16 18446744073709551615 1442695040888963409 1442695040888963407 1285 2 6 15
bytecblock 0x 0x656e7472795f636f756e74 0x7469636b65745f6173736574 0x656e7472795f637572736f72 0x656e7472795f637572736f725f746f74616c 0x77696e6e696e675f7469636b6574 0x7072697a65 0x7072697a655f636c61696d6564 0x77696e6e696e675f61646472657373 0x656e64696e675f726f756e64 0x7469636b65745f636f756e74 0x7072697a655f616d6f756e74 0x7374617274696e675f726f756e64 0x6d696e5f7469636b657473 0x6d61785f7469636b657473 0x00 0x656e7472795f696473

// This TEAL was generated by TEALScript v0.106.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 11 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_DeleteApplication *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(uint64,uint64,uint64,uint64,uint64,uint64,uint64)void
*abi_route_createApplication:
	// prizeAmount: uint64
	txna ApplicationArgs 7
	btoi

	// prize: uint64
	txna ApplicationArgs 6
	btoi

	// maxTickets: uint64
	txna ApplicationArgs 5
	btoi

	// minTickets: uint64
	txna ApplicationArgs 4
	btoi

	// endingRound: uint64
	txna ApplicationArgs 3
	btoi

	// startingRound: uint64
	txna ApplicationArgs 2
	btoi

	// ticketAsset: uint64
	txna ApplicationArgs 1
	btoi

	// execute createApplication(uint64,uint64,uint64,uint64,uint64,uint64,uint64)void
	callsub createApplication
	intc 1 // 1
	return

// createApplication(ticketAsset: AssetID, startingRound: uint64, endingRound: uint64, minTickets: uint64, maxTickets: uint64, prize: AssetID, prizeAmount: uint64): void
createApplication:
	proto 7 0

	// contracts/raffle/raffle.algo.ts:111
	// this._entryID.value = 0
	bytec 16 //  "entry_ids"
	intc 0 // 0
	app_global_put

	// contracts/raffle/raffle.algo.ts:112
	// this._entryCursor.value = 0
	bytec 3 //  "entry_cursor"
	intc 0 // 0
	app_global_put

	// contracts/raffle/raffle.algo.ts:113
	// this._entryCursorTotal.value = 0
	bytec 4 //  "entry_cursor_total"
	intc 0 // 0
	app_global_put

	// contracts/raffle/raffle.algo.ts:114
	// this.ticketAsset.value = ticketAsset
	bytec 2 //  "ticket_asset"
	frame_dig -1 // ticketAsset: AssetID
	app_global_put

	// contracts/raffle/raffle.algo.ts:115
	// this.startingRound.value = startingRound
	bytec 12 //  "starting_round"
	frame_dig -2 // startingRound: uint64
	app_global_put

	// contracts/raffle/raffle.algo.ts:116
	// assert(
	//             endingRound > startingRound
	//             && endingRound > (globals.round + APPROX_ROUNDS_IN_ONE_HOUR),
	//             errs.TOO_SHORT
	//         )
	frame_dig -3 // endingRound: uint64
	frame_dig -2 // startingRound: uint64
	>
	dup
	bz *skip_and0
	frame_dig -3 // endingRound: uint64
	global Round
	intc 9 // 1285
	+
	>
	&&

*skip_and0:
	assert

	// contracts/raffle/raffle.algo.ts:121
	// this.endingRound.value = endingRound
	bytec 9 //  "ending_round"
	frame_dig -3 // endingRound: uint64
	app_global_put

	// contracts/raffle/raffle.algo.ts:122
	// this.minTickets.value = minTickets
	bytec 13 //  "min_tickets"
	frame_dig -4 // minTickets: uint64
	app_global_put

	// contracts/raffle/raffle.algo.ts:123
	// this.maxTickets.value = maxTickets
	bytec 14 //  "max_tickets"
	frame_dig -5 // maxTickets: uint64
	app_global_put

	// contracts/raffle/raffle.algo.ts:124
	// this.entryCount.value = 0
	bytec 1 //  "entry_count"
	intc 0 // 0
	app_global_put

	// contracts/raffle/raffle.algo.ts:125
	// this.ticketCount.value = 0
	bytec 10 //  "ticket_count"
	intc 0 // 0
	app_global_put

	// contracts/raffle/raffle.algo.ts:126
	// this.winningTicket.value = 0
	bytec 5 //  "winning_ticket"
	intc 0 // 0
	app_global_put

	// contracts/raffle/raffle.algo.ts:127
	// this.winningAddress.value = Address.zeroAddress
	bytec 8 //  "winning_address"
	global ZeroAddress
	app_global_put

	// contracts/raffle/raffle.algo.ts:128
	// this.prize.value = prize
	bytec 6 //  "prize"
	frame_dig -6 // prize: AssetID
	app_global_put

	// contracts/raffle/raffle.algo.ts:129
	// this.prizeAmount.value = prizeAmount
	bytec 11 //  "prize_amount"
	frame_dig -7 // prizeAmount: uint64
	app_global_put

	// contracts/raffle/raffle.algo.ts:130
	// this.prizeClaimed.value = false
	bytec 7 //  "prize_claimed"
	intc 0 // 0
	bytec 15 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// init()void
*abi_route_init:
	// execute init()void
	callsub init
	intc 1 // 1
	return

// init(): void
init:
	proto 0 0

	// contracts/raffle/raffle.algo.ts:134
	// assert(this.txn.sender === this.app.creator, errs.CREATOR_ONLY)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==
	assert

	// contracts/raffle/raffle.algo.ts:136
	// this.pendingGroup.addAssetTransfer({
	//             assetSender: this.app.address,
	//             assetReceiver: this.app.address,
	//             assetAmount: 0,
	//             xferAsset: this.ticketAsset.value,
	//         })
	itxn_next
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:137
	// assetSender: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetSender

	// contracts/raffle/raffle.algo.ts:138
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/raffle/raffle.algo.ts:139
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/raffle/raffle.algo.ts:140
	// xferAsset: this.ticketAsset.value
	bytec 2 //  "ticket_asset"
	app_global_get
	itxn_field XferAsset

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// contracts/raffle/raffle.algo.ts:143
	// this.pendingGroup.addAssetTransfer({
	//             assetSender: this.app.address,
	//             assetReceiver: this.app.address,
	//             assetAmount: 0,
	//             xferAsset: this.prize.value,
	//         })
	itxn_next
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:144
	// assetSender: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetSender

	// contracts/raffle/raffle.algo.ts:145
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/raffle/raffle.algo.ts:146
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/raffle/raffle.algo.ts:147
	// xferAsset: this.prize.value
	bytec 6 //  "prize"
	app_global_get
	itxn_field XferAsset

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// contracts/raffle/raffle.algo.ts:150
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// enter(pay,axfer)void
*abi_route_enter:
	// xfer: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 2 //  axfer
	==

	// argument 0 (xfer) for enter must be a axfer transaction
	assert

	// pmt: pay
	txn GroupIndex
	intc 10 // 2
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 1 (pmt) for enter must be a pay transaction
	assert

	// execute enter(pay,axfer)void
	callsub enter
	intc 1 // 1
	return

// enter(pmt: PayTxn, xfer: AssetTransferTxn): void
enter:
	proto 2 0

	// contracts/raffle/raffle.algo.ts:154
	// assert(globals.round >= this.startingRound.value, errs.NOT_STARTED)
	global Round
	bytec 12 //  "starting_round"
	app_global_get
	>=
	assert

	// contracts/raffle/raffle.algo.ts:155
	// assert(globals.round <= this.endingRound.value, errs.ENDED)
	global Round
	bytec 9 //  "ending_round"
	app_global_get
	<=
	assert

	// contracts/raffle/raffle.algo.ts:157
	// assert(pmt.amount === ENTRY_MBR, errs.INVALID_MBR_AMOUNT)
	frame_dig -1 // pmt: PayTxn
	gtxns Amount
	intc 4 // 37000
	==
	assert

	// contracts/raffle/raffle.algo.ts:158
	// assert(pmt.receiver === this.app.address, errs.INVALID_MBR_RECIPIENT)
	frame_dig -1 // pmt: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// contracts/raffle/raffle.algo.ts:160
	// assert(xfer.xferAsset === this.ticketAsset.value, errs.INVALID_ASSET)
	frame_dig -2 // xfer: AssetTransferTxn
	gtxns XferAsset
	bytec 2 //  "ticket_asset"
	app_global_get
	==
	assert

	// contracts/raffle/raffle.algo.ts:161
	// assert(xfer.assetAmount >= this.minTickets.value, errs.BELOW_MIN)
	frame_dig -2 // xfer: AssetTransferTxn
	gtxns AssetAmount
	bytec 13 //  "min_tickets"
	app_global_get
	>=
	assert

	// contracts/raffle/raffle.algo.ts:162
	// assert(xfer.assetAmount <= this.maxTickets.value, errs.ABOVE_MAX)
	frame_dig -2 // xfer: AssetTransferTxn
	gtxns AssetAmount
	bytec 14 //  "max_tickets"
	app_global_get
	<=
	assert

	// contracts/raffle/raffle.algo.ts:163
	// assert(xfer.assetReceiver === this.app.address, errs.INVALID_RECEIVER)
	frame_dig -2 // xfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert

	// contracts/raffle/raffle.algo.ts:165
	// assert(!this.entriesByAddress(this.txn.sender).exists, errs.ALREADY_ENTERED)
	txn Sender
	box_len
	swap
	pop
	!
	assert

	// contracts/raffle/raffle.algo.ts:167
	// this.entries(this.entryCount.value).value = this.txn.sender
	bytec 1 //  "entry_count"
	app_global_get
	itob
	txn Sender
	box_put

	// contracts/raffle/raffle.algo.ts:168
	// this.entriesByAddress(this.txn.sender).value = this.entryCount.value
	txn Sender
	bytec 1 //  "entry_count"
	app_global_get
	itob
	box_put

	// contracts/raffle/raffle.algo.ts:169
	// this.entryCount.value += 1
	bytec 1 //  "entry_count"
	app_global_get
	intc 1 // 1
	+
	bytec 1 //  "entry_count"
	swap
	app_global_put

	// contracts/raffle/raffle.algo.ts:170
	// this.ticketCount.value += xfer.assetAmount
	bytec 10 //  "ticket_count"
	app_global_get
	frame_dig -2 // xfer: AssetTransferTxn
	gtxns AssetAmount
	+
	bytec 10 //  "ticket_count"
	swap
	app_global_put
	retsub

// raffle()void
*abi_route_raffle:
	// execute raffle()void
	callsub raffle
	intc 1 // 1
	return

// raffle(): void
raffle:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 5

	// contracts/raffle/raffle.algo.ts:174
	// roundToUse = (this.endingRound.value + 1)
	bytec 9 //  "ending_round"
	app_global_get
	intc 1 // 1
	+
	frame_bury 0 // roundToUse: uint64

	// contracts/raffle/raffle.algo.ts:175
	// assert(globals.round >= (roundToUse + 8), errs.NOT_ENOUGH_TIME)
	global Round
	frame_dig 0 // roundToUse: uint64
	intc 3 // 8
	+
	>=
	assert

	// contracts/raffle/raffle.algo.ts:176
	// assert(this.winningTicket.value === 0, errs.ENDED)
	bytec 5 //  "winning_ticket"
	app_global_get
	intc 0 // 0
	==
	assert

	// contracts/raffle/raffle.algo.ts:178
	// seed = sendMethodCall<typeof RandomnessBeacon.prototype.get, bytes>({
	//             applicationID: RANDOMNESS_BEACON_APPID_TESTNET,
	//             methodArgs: [ roundToUse, this.txn.txID ],
	//             fee: 0,
	//         })
	itxn_begin
	intc 11 //  appl
	itxn_field TypeEnum
	pushbytes 0x189392c5 // method "get(uint64,byte[])byte[]"
	itxn_field ApplicationArgs

	// contracts/raffle/raffle.algo.ts:179
	// applicationID: RANDOMNESS_BEACON_APPID_TESTNET
	// contracts/raffle/raffle.algo.ts:28
	// AppID.fromUint64(600011887)
	pushint 600011887
	itxn_field ApplicationID

	// contracts/raffle/raffle.algo.ts:180
	// methodArgs: [ roundToUse, this.txn.txID ]
	frame_dig 0 // roundToUse: uint64
	itob
	itxn_field ApplicationArgs
	txn TxID
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs

	// contracts/raffle/raffle.algo.ts:181
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	extract 2 0
	frame_bury 1 // seed: byte[]

	// contracts/raffle/raffle.algo.ts:184
	// assert(seed.length > 0, errs.FAILED_TO_GET_SEED)
	frame_dig 1 // seed: byte[]
	len
	intc 0 // 0
	>
	assert

	// contracts/raffle/raffle.algo.ts:186
	// rngState = pcg64Init(substring3(seed, 0, 16) as bytes<16>)
	frame_dig 1 // seed: byte[]
	substring 0 16
	pushbytes 0x00000000000000000000000000000000
	concat
	dup
	extract 16 0
	bytec 0 // 0x
	b==
	assert
	extract 0 16
	callsub pcg64Init
	frame_bury 2 // rngState: (uint64,uint64)

	// contracts/raffle/raffle.algo.ts:188
	// upperBound = this.ticketCount.value
	bytec 10 //  "ticket_count"
	app_global_get
	frame_bury 3 // upperBound: uint64

	// *if0_condition
	// contracts/raffle/raffle.algo.ts:189
	// upperBound < MAX_UINT64
	frame_dig 3 // upperBound: uint64

	// contracts/raffle/raffle.algo.ts:33
	// Uint<64>('18446744073709551615')
	intc 6 // 18446744073709551615
	<
	bz *if0_end

	// *if0_consequent
	// contracts/raffle/raffle.algo.ts:190
	// upperBound = upperBound += 1
	frame_dig 3 // upperBound: uint64
	intc 1 // 1
	+
	dup
	store 245 // assignment value
	frame_bury 3 // upperBound: uint64
	load 245 // assignment value
	frame_bury 3 // upperBound: uint64

*if0_end:
	// contracts/raffle/raffle.algo.ts:193
	// rngResult = pcg64Random(rngState, 1, upperBound, 1)
	intc 1 // 1
	frame_dig 3 // upperBound: uint64
	intc 1 // 1
	frame_dig 2 // rngState: (uint64,uint64)
	callsub pcg64Random
	frame_bury 4 // rngResult: ((uint64,uint64),uint64[])

	// contracts/raffle/raffle.algo.ts:194
	// winningTicket = rngResult[1][0]
	frame_dig 4 // rngResult: ((uint64,uint64),uint64[])
	store 255 // full array
	load 255 // full array
	intc 5 // 16
	extract_uint16
	intc 0 //  acc * typeLength
	+
	intc 10 // 2
	+ // add two for length
	load 255 // full array
	swap
	intc 3 // 8
	extract3
	btoi
	frame_bury 5 // winningTicket: uint64

	// contracts/raffle/raffle.algo.ts:196
	// this.winningTicket.value = winningTicket
	bytec 5 //  "winning_ticket"
	frame_dig 5 // winningTicket: uint64
	app_global_put
	retsub

// findWinner()void
*abi_route_findWinner:
	// execute findWinner()void
	callsub findWinner
	intc 1 // 1
	return

// findWinner(): void
findWinner:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts/raffle/raffle.algo.ts:200
	// assert(this.winningTicket.value > 0, errs.NO_WINNING_TICKET_YET)
	bytec 5 //  "winning_ticket"
	app_global_get
	intc 0 // 0
	>
	assert

	// contracts/raffle/raffle.algo.ts:202
	// groupIndex = 0
	intc 0 // 0
	frame_bury 0 // groupIndex: uint64

	// contracts/raffle/raffle.algo.ts:203
	// for (
	//             let i = this._entryCursor.value;
	//             i < this.entryCount.value || groupIndex === 15;
	//             i += 1
	//         )
	bytec 3 //  "entry_cursor"
	app_global_get
	frame_bury 1 // i: uint64

*for_0:
	// contracts/raffle/raffle.algo.ts:205
	// i < this.entryCount.value || groupIndex === 15
	frame_dig 1 // i: uint64
	bytec 1 //  "entry_count"
	app_global_get
	<
	dup
	bnz *skip_or0
	frame_dig 0 // groupIndex: uint64
	intc 12 // 15
	==
	||

*skip_or0:
	bz *for_0_end

	// contracts/raffle/raffle.algo.ts:208
	// assert(this.entries(i).exists, errs.ENTRY_DOES_NOT_EXIST)
	frame_dig 1 // i: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/raffle/raffle.algo.ts:209
	// groupIndex += 1
	frame_dig 0 // groupIndex: uint64
	intc 1 // 1
	+
	frame_bury 0 // groupIndex: uint64

	// contracts/raffle/raffle.algo.ts:211
	// entryAmount = this.entriesByAddress(this.entries(i).value).value
	frame_dig 1 // i: uint64
	itob
	box_get

	// box value does not exist: this.entries(i).value
	assert
	box_get

	// box value does not exist: this.entriesByAddress(this.entries(i).value).value
	assert
	btoi
	frame_bury 2 // entryAmount: uint64

	// contracts/raffle/raffle.algo.ts:212
	// isWinner = this._entryCursorTotal.value + entryAmount >= this.winningTicket.value
	bytec 4 //  "entry_cursor_total"
	app_global_get
	frame_dig 2 // entryAmount: uint64
	+
	bytec 5 //  "winning_ticket"
	app_global_get
	>=
	frame_bury 3 // isWinner: bool

	// *if1_condition
	// contracts/raffle/raffle.algo.ts:214
	// isWinner
	frame_dig 3 // isWinner: bool
	bz *if1_end

	// *if1_consequent
	// contracts/raffle/raffle.algo.ts:215
	// this.winningAddress.value = this.entries(i).value
	bytec 8 //  "winning_address"
	frame_dig 1 // i: uint64
	itob
	box_get

	// box value does not exist: this.entries(i).value
	assert
	app_global_put

*if1_end:
	// contracts/raffle/raffle.algo.ts:218
	// this.entriesByAddress(this.entries(i).value).delete()
	frame_dig 1 // i: uint64
	itob
	box_get

	// box value does not exist: this.entries(i).value
	assert
	box_del

	// contracts/raffle/raffle.algo.ts:219
	// this.entries(i).delete()
	frame_dig 1 // i: uint64
	itob
	box_del

	// contracts/raffle/raffle.algo.ts:222
	// sendPayment({
	//                 receiver: this.entries(i).value,
	//                 amount: ENTRY_MBR,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:223
	// receiver: this.entries(i).value
	frame_dig 1 // i: uint64
	itob
	box_get

	// box value does not exist: this.entries(i).value
	assert
	itxn_field Receiver

	// contracts/raffle/raffle.algo.ts:224
	// amount: ENTRY_MBR
	intc 4 // 37000
	itxn_field Amount

	// contracts/raffle/raffle.algo.ts:225
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/raffle/raffle.algo.ts:228
	// this._entryCursor.value = i
	bytec 3 //  "entry_cursor"
	frame_dig 1 // i: uint64
	app_global_put

	// contracts/raffle/raffle.algo.ts:229
	// this._entryCursorTotal.value += entryAmount
	bytec 4 //  "entry_cursor_total"
	app_global_get
	frame_dig 2 // entryAmount: uint64
	+
	bytec 4 //  "entry_cursor_total"
	swap
	app_global_put

*for_0_continue:
	// contracts/raffle/raffle.algo.ts:206
	// i += 1
	frame_dig 1 // i: uint64
	intc 1 // 1
	+
	frame_bury 1 // i: uint64
	b *for_0

*for_0_end:
	retsub

// claimPrize()void
*abi_route_claimPrize:
	// execute claimPrize()void
	callsub claimPrize
	intc 1 // 1
	return

// claimPrize(): void
claimPrize:
	proto 0 0

	// contracts/raffle/raffle.algo.ts:234
	// assert(!this.prizeClaimed.value, errs.PRIZE_ALREADY_CLAIMED)
	bytec 7 //  "prize_claimed"
	app_global_get
	intc 0 // 0
	getbit
	!
	assert

	// *if2_condition
	// contracts/raffle/raffle.algo.ts:236
	// this.prize.value.id === 0
	bytec 6 //  "prize"
	app_global_get
	intc 0 // 0
	==
	bz *if2_else

	// *if2_consequent
	// contracts/raffle/raffle.algo.ts:237
	// sendPayment({
	//                 receiver: this.winningAddress.value,
	//                 amount: this.prizeAmount.value,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:238
	// receiver: this.winningAddress.value
	bytec 8 //  "winning_address"
	app_global_get
	itxn_field Receiver

	// contracts/raffle/raffle.algo.ts:239
	// amount: this.prizeAmount.value
	bytec 11 //  "prize_amount"
	app_global_get
	itxn_field Amount

	// contracts/raffle/raffle.algo.ts:240
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if2_end

*if2_else:
	// contracts/raffle/raffle.algo.ts:243
	// sendAssetTransfer({
	//                 assetSender: this.app.address,
	//                 assetReceiver: this.winningAddress.value,
	//                 assetAmount: this.prizeAmount.value,
	//                 xferAsset: this.prize.value,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:244
	// assetSender: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetSender

	// contracts/raffle/raffle.algo.ts:245
	// assetReceiver: this.winningAddress.value
	bytec 8 //  "winning_address"
	app_global_get
	itxn_field AssetReceiver

	// contracts/raffle/raffle.algo.ts:246
	// assetAmount: this.prizeAmount.value
	bytec 11 //  "prize_amount"
	app_global_get
	itxn_field AssetAmount

	// contracts/raffle/raffle.algo.ts:247
	// xferAsset: this.prize.value
	bytec 6 //  "prize"
	app_global_get
	itxn_field XferAsset

	// contracts/raffle/raffle.algo.ts:248
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if2_end:
	// contracts/raffle/raffle.algo.ts:252
	// this.prizeClaimed.value = true
	bytec 7 //  "prize_claimed"
	intc 1 // 1
	bytec 15 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// claimTickets()void
*abi_route_claimTickets:
	// execute claimTickets()void
	callsub claimTickets
	intc 1 // 1
	return

// claimTickets(): void
claimTickets:
	proto 0 0

	// contracts/raffle/raffle.algo.ts:256
	// assert(this.txn.sender === this.app.creator, errs.CREATOR_ONLY)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==
	assert

	// contracts/raffle/raffle.algo.ts:257
	// assert(this.prizeClaimed.value, errs.PRIZE_NOT_CLAIMED)
	bytec 7 //  "prize_claimed"
	app_global_get
	intc 0 // 0
	getbit
	assert

	// contracts/raffle/raffle.algo.ts:259
	// sendAssetTransfer({
	//             assetSender: this.app.address,
	//             assetReceiver: this.app.creator,
	//             assetAmount: this.app.address.assetBalance(this.ticketAsset.value),
	//             assetCloseTo: this.app.creator,
	//             xferAsset: this.ticketAsset.value,
	//             fee: 0,
	//         })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:260
	// assetSender: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetSender

	// contracts/raffle/raffle.algo.ts:261
	// assetReceiver: this.app.creator
	txna Applications 0
	app_params_get AppCreator
	pop
	itxn_field AssetReceiver

	// contracts/raffle/raffle.algo.ts:262
	// assetAmount: this.app.address.assetBalance(this.ticketAsset.value)
	global CurrentApplicationAddress
	bytec 2 //  "ticket_asset"
	app_global_get
	asset_holding_get AssetBalance
	pop
	itxn_field AssetAmount

	// contracts/raffle/raffle.algo.ts:263
	// assetCloseTo: this.app.creator
	txna Applications 0
	app_params_get AppCreator
	pop
	itxn_field AssetCloseTo

	// contracts/raffle/raffle.algo.ts:264
	// xferAsset: this.ticketAsset.value
	bytec 2 //  "ticket_asset"
	app_global_get
	itxn_field XferAsset

	// contracts/raffle/raffle.algo.ts:265
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// refund()void
*abi_route_refund:
	// execute refund()void
	callsub refund
	intc 1 // 1
	return

// refund(): void
refund:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/raffle/raffle.algo.ts:270
	// assert(this.winningTicket.value === 0, errs.NO_WINNING_TICKET_YET)
	bytec 5 //  "winning_ticket"
	app_global_get
	intc 0 // 0
	==
	assert

	// contracts/raffle/raffle.algo.ts:271
	// assert(globals.round > this.endingRound.value + 1285, errs.NOT_ENOUGH_TIME)
	global Round
	bytec 9 //  "ending_round"
	app_global_get
	intc 9 // 1285
	+
	>
	assert

	// contracts/raffle/raffle.algo.ts:273
	// groupIndex = 0
	intc 0 // 0
	frame_bury 0 // groupIndex: uint64

	// contracts/raffle/raffle.algo.ts:274
	// for (
	//             let i = this._entryCursor.value;
	//             i < this.entryCount.value || groupIndex === 15;
	//             i += 1
	//         )
	bytec 3 //  "entry_cursor"
	app_global_get
	frame_bury 1 // i: uint64

*for_1:
	// contracts/raffle/raffle.algo.ts:276
	// i < this.entryCount.value || groupIndex === 15
	frame_dig 1 // i: uint64
	bytec 1 //  "entry_count"
	app_global_get
	<
	dup
	bnz *skip_or1
	frame_dig 0 // groupIndex: uint64
	intc 12 // 15
	==
	||

*skip_or1:
	bz *for_1_end

	// contracts/raffle/raffle.algo.ts:279
	// assert(this.entries(i).exists, errs.ENTRY_DOES_NOT_EXIST)
	frame_dig 1 // i: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/raffle/raffle.algo.ts:280
	// groupIndex += 1
	frame_dig 0 // groupIndex: uint64
	intc 1 // 1
	+
	frame_bury 0 // groupIndex: uint64

	// contracts/raffle/raffle.algo.ts:282
	// entryAmount = this.entriesByAddress(this.entries(i).value).value
	frame_dig 1 // i: uint64
	itob
	box_get

	// box value does not exist: this.entries(i).value
	assert
	box_get

	// box value does not exist: this.entriesByAddress(this.entries(i).value).value
	assert
	btoi
	frame_bury 2 // entryAmount: uint64

	// *if3_condition
	// contracts/raffle/raffle.algo.ts:284
	// this.ticketAsset.value.id === 0
	bytec 2 //  "ticket_asset"
	app_global_get
	intc 0 // 0
	==
	bz *if3_else

	// *if3_consequent
	// contracts/raffle/raffle.algo.ts:285
	// sendPayment({
	//                     receiver: this.entries(i).value,
	//                     amount: ENTRY_MBR + entryAmount,
	//                     fee: 0,
	//                 })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:286
	// receiver: this.entries(i).value
	frame_dig 1 // i: uint64
	itob
	box_get

	// box value does not exist: this.entries(i).value
	assert
	itxn_field Receiver

	// contracts/raffle/raffle.algo.ts:287
	// amount: ENTRY_MBR + entryAmount
	intc 4 // 37000
	frame_dig 2 // entryAmount: uint64
	+
	itxn_field Amount

	// contracts/raffle/raffle.algo.ts:288
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if3_end

*if3_else:
	// contracts/raffle/raffle.algo.ts:291
	// this.pendingGroup.addAssetTransfer({
	//                     assetSender: this.app.address,
	//                     assetReceiver: this.entries(i).value,
	//                     assetAmount: entryAmount,
	//                     xferAsset: this.ticketAsset.value,
	//                     fee: 0,
	//                 })
	itxn_next
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:292
	// assetSender: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetSender

	// contracts/raffle/raffle.algo.ts:293
	// assetReceiver: this.entries(i).value
	frame_dig 1 // i: uint64
	itob
	box_get

	// box value does not exist: this.entries(i).value
	assert
	itxn_field AssetReceiver

	// contracts/raffle/raffle.algo.ts:294
	// assetAmount: entryAmount
	frame_dig 2 // entryAmount: uint64
	itxn_field AssetAmount

	// contracts/raffle/raffle.algo.ts:295
	// xferAsset: this.ticketAsset.value
	bytec 2 //  "ticket_asset"
	app_global_get
	itxn_field XferAsset

	// contracts/raffle/raffle.algo.ts:296
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/raffle/raffle.algo.ts:299
	// this.pendingGroup.addPayment({
	//                     receiver: this.entries(i).value,
	//                     amount: ENTRY_MBR,
	//                     fee: 0,
	//                 })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:300
	// receiver: this.entries(i).value
	frame_dig 1 // i: uint64
	itob
	box_get

	// box value does not exist: this.entries(i).value
	assert
	itxn_field Receiver

	// contracts/raffle/raffle.algo.ts:301
	// amount: ENTRY_MBR
	intc 4 // 37000
	itxn_field Amount

	// contracts/raffle/raffle.algo.ts:302
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/raffle/raffle.algo.ts:305
	// this.pendingGroup.submit()
	itxn_submit

*if3_end:
	// contracts/raffle/raffle.algo.ts:308
	// this.entriesByAddress(this.entries(i).value).delete()
	frame_dig 1 // i: uint64
	itob
	box_get

	// box value does not exist: this.entries(i).value
	assert
	box_del

	// contracts/raffle/raffle.algo.ts:309
	// this.entries(i).delete()
	frame_dig 1 // i: uint64
	itob
	box_del

	// contracts/raffle/raffle.algo.ts:311
	// this._entryCursor.value = i
	bytec 3 //  "entry_cursor"
	frame_dig 1 // i: uint64
	app_global_put

	// contracts/raffle/raffle.algo.ts:312
	// this._entryCursorTotal.value += entryAmount
	bytec 4 //  "entry_cursor_total"
	app_global_get
	frame_dig 2 // entryAmount: uint64
	+
	bytec 4 //  "entry_cursor_total"
	swap
	app_global_put

*for_1_continue:
	// contracts/raffle/raffle.algo.ts:277
	// i += 1
	frame_dig 1 // i: uint64
	intc 1 // 1
	+
	frame_bury 1 // i: uint64
	b *for_1

*for_1_end:
	// *if4_condition
	// contracts/raffle/raffle.algo.ts:315
	// this._entryCursor.value === this.entryCount.value
	bytec 3 //  "entry_cursor"
	app_global_get
	bytec 1 //  "entry_count"
	app_global_get
	==
	bz *if4_end

	// *if4_consequent
	// contracts/raffle/raffle.algo.ts:316
	// this.pendingGroup.addAssetTransfer({
	//                 assetSender: this.app.address,
	//                 assetReceiver: this.app.creator,
	//                 assetAmount: this.app.address.assetBalance(this.prize.value),
	//                 assetCloseTo: this.app.creator,
	//                 xferAsset: this.prize.value,
	//                 fee: 0,
	//             })
	itxn_next
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:317
	// assetSender: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetSender

	// contracts/raffle/raffle.algo.ts:318
	// assetReceiver: this.app.creator
	txna Applications 0
	app_params_get AppCreator
	pop
	itxn_field AssetReceiver

	// contracts/raffle/raffle.algo.ts:319
	// assetAmount: this.app.address.assetBalance(this.prize.value)
	global CurrentApplicationAddress
	bytec 6 //  "prize"
	app_global_get
	asset_holding_get AssetBalance
	pop
	itxn_field AssetAmount

	// contracts/raffle/raffle.algo.ts:320
	// assetCloseTo: this.app.creator
	txna Applications 0
	app_params_get AppCreator
	pop
	itxn_field AssetCloseTo

	// contracts/raffle/raffle.algo.ts:321
	// xferAsset: this.prize.value
	bytec 6 //  "prize"
	app_global_get
	itxn_field XferAsset

	// contracts/raffle/raffle.algo.ts:322
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/raffle/raffle.algo.ts:325
	// this.pendingGroup.addPayment({
	//                 receiver: this.app.creator,
	//                 amount: this.app.address.balance,
	//                 closeRemainderTo: this.app.creator,
	//                 fee: 0,
	//             })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:326
	// receiver: this.app.creator
	txna Applications 0
	app_params_get AppCreator
	pop
	itxn_field Receiver

	// contracts/raffle/raffle.algo.ts:327
	// amount: this.app.address.balance
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	itxn_field Amount

	// contracts/raffle/raffle.algo.ts:328
	// closeRemainderTo: this.app.creator
	txna Applications 0
	app_params_get AppCreator
	pop
	itxn_field CloseRemainderTo

	// contracts/raffle/raffle.algo.ts:329
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if4_end:
	retsub

// deleteApplication()void
*abi_route_deleteApplication:
	// execute deleteApplication()void
	callsub deleteApplication
	intc 1 // 1
	return

// deleteApplication(): void
deleteApplication:
	proto 0 0

	// contracts/raffle/raffle.algo.ts:335
	// assert(this.txn.sender === this.app.creator, errs.CREATOR_ONLY)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==
	assert

	// contracts/raffle/raffle.algo.ts:336
	// assert(this._entryCursor.value === this.entryCount.value, errs.BOXES_ARENT_CLEARED)
	bytec 3 //  "entry_cursor"
	app_global_get
	bytec 1 //  "entry_count"
	app_global_get
	==
	assert

	// contracts/raffle/raffle.algo.ts:337
	// assert(this.prizeClaimed.value, errs.PRIZE_NOT_CLAIMED)
	bytec 7 //  "prize_claimed"
	app_global_get
	intc 0 // 0
	getbit
	assert

	// contracts/raffle/raffle.algo.ts:338
	// assert(this.app.address.assetBalance(this.ticketAsset.value) === 0, errs.TICKETS_NOT_RECLAIMED)
	global CurrentApplicationAddress
	bytec 2 //  "ticket_asset"
	app_global_get
	asset_holding_get AssetBalance
	pop
	intc 0 // 0
	==
	assert
	retsub

// getState()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,uint64,uint64,bool)
*abi_route_getState:
	// The ABI return prefix
	pushbytes 0x151f7c75

	// execute getState()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,uint64,uint64,bool)
	callsub getState
	concat
	log
	intc 1 // 1
	return

// getState(): RaffleState
getState:
	proto 0 1

	// contracts/raffle/raffle.algo.ts:342
	// return {
	//             entryID: this._entryID.value,
	//             entryCursor: this._entryCursor.value,
	//             entryCursorTotal: this._entryCursorTotal.value,
	//             ticketAsset: this.ticketAsset.value,
	//             startingRound: this.startingRound.value,
	//             endingRound: this.endingRound.value,
	//             minTickets: this.minTickets.value,
	//             maxTickets: this.maxTickets.value,
	//             entryCount: this.entryCount.value,
	//             ticketCount: this.ticketCount.value,
	//             winningTicket: this.winningTicket.value,
	//             winningAddress: this.winningAddress.value,
	//             prize: this.prize.value,
	//             prizeAmount: this.prizeAmount.value,
	//             prizeClaimed: this.prizeClaimed.value,
	//         }
	bytec 16 //  "entry_ids"
	app_global_get
	itob
	bytec 3 //  "entry_cursor"
	app_global_get
	itob
	concat
	bytec 4 //  "entry_cursor_total"
	app_global_get
	itob
	concat
	bytec 2 //  "ticket_asset"
	app_global_get
	itob
	concat
	bytec 12 //  "starting_round"
	app_global_get
	itob
	concat
	bytec 9 //  "ending_round"
	app_global_get
	itob
	concat
	bytec 13 //  "min_tickets"
	app_global_get
	itob
	concat
	bytec 14 //  "max_tickets"
	app_global_get
	itob
	concat
	bytec 1 //  "entry_count"
	app_global_get
	itob
	concat
	bytec 10 //  "ticket_count"
	app_global_get
	itob
	concat
	bytec 5 //  "winning_ticket"
	app_global_get
	itob
	concat
	bytec 8 //  "winning_address"
	app_global_get
	concat
	bytec 6 //  "prize"
	app_global_get
	itob
	concat
	bytec 11 //  "prize_amount"
	app_global_get
	itob
	concat
	bytec 15 // 0x00
	intc 0 // 0
	bytec 7 //  "prize_claimed"
	app_global_get
	intc 0 // 0
	getbit
	setbit
	concat
	retsub

*create_NoOp:
	pushbytes 0x81e5f8d4 // method "createApplication(uint64,uint64,uint64,uint64,uint64,uint64,uint64)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x83f14748 // method "init()void"
	pushbytes 0x8cd14e92 // method "enter(pay,axfer)void"
	pushbytes 0x696501de // method "raffle()void"
	pushbytes 0xb733d519 // method "findWinner()void"
	pushbytes 0x9daf050a // method "claimPrize()void"
	pushbytes 0x866e37c2 // method "claimTickets()void"
	pushbytes 0x23e629f7 // method "refund()void"
	pushbytes 0xb86bcfbd // method "getState()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address,uint64,uint64,bool)"
	txna ApplicationArgs 0
	match *abi_route_init *abi_route_enter *abi_route_raffle *abi_route_findWinner *abi_route_claimPrize *abi_route_claimTickets *abi_route_refund *abi_route_getState

	// this contract does not implement the given ABI method for call NoOp
	err

*call_DeleteApplication:
	pushbytes 0x2487c32c // method "deleteApplication()void"
	txna ApplicationArgs 0
	match *abi_route_deleteApplication

	// this contract does not implement the given ABI method for call DeleteApplication
	err

// pcg64Random(state: PCG64STATE, lowerBound: uint64, upperBound: uint64, length: uint64): [PCG64STATE, uint64[]]
pcg64Random:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 7

	// utils/types/lib_pcg/pcg64.algo.ts:29
	// result: uint64[] = []
	bytec 0 // 0x
	frame_bury 0 // result: uint64[]

	// utils/types/lib_pcg/pcg64.algo.ts:33
	// newState = clone(state)
	frame_dig -1 // state: PCG64STATE
	frame_bury 3 // newState: (uint64,uint64)

	// *if5_condition
	// utils/types/lib_pcg/pcg64.algo.ts:35
	// lowerBound === 0 && upperBound === 0
	frame_dig -2 // lowerBound: uint64
	intc 0 // 0
	==
	dup
	bz *skip_and1
	frame_dig -3 // upperBound: uint64
	intc 0 // 0
	==
	&&

*skip_and1:
	bz *if5_else

	// *if5_consequent
	// utils/types/lib_pcg/pcg64.algo.ts:36
	// for (let i = 0; i < length; i = i + 1)
	intc 0 // 0
	frame_bury 4 // i: uint64

*for_2:
	// utils/types/lib_pcg/pcg64.algo.ts:36
	// i < length
	frame_dig 4 // i: uint64
	frame_dig -4 // length: uint64
	<
	bz *for_2_end

	// utils/types/lib_pcg/pcg64.algo.ts:37
	// stepResult = __pcg64Random(newState)
	frame_dig 3 // newState: (uint64,uint64)
	callsub __pcg64Random
	frame_bury 5 // stepResult: ((uint64,uint64),uint64)

	// utils/types/lib_pcg/pcg64.algo.ts:38
	// newState = stepResult[0]
	frame_dig 5 // stepResult: ((uint64,uint64),uint64)
	extract 0 16
	frame_bury 3 // newState: (uint64,uint64)

	// utils/types/lib_pcg/pcg64.algo.ts:39
	// result.push(stepResult[1])
	frame_dig 0 // result: uint64[]
	frame_dig 5 // stepResult: ((uint64,uint64),uint64)
	extract 16 8
	btoi
	itob
	concat
	frame_bury 0 // result: uint64[]

*for_2_continue:
	// utils/types/lib_pcg/pcg64.algo.ts:36
	// i = i + 1
	frame_dig 4 // i: uint64
	intc 1 // 1
	+
	frame_bury 4 // i: uint64
	b *for_2

*for_2_end:
	b *if5_end

*if5_else:
	// *if6_condition
	// utils/types/lib_pcg/pcg64.algo.ts:42
	// upperBound !== 0
	frame_dig -3 // upperBound: uint64
	intc 0 // 0
	!=
	bz *if6_else

	// *if6_consequent
	// utils/types/lib_pcg/pcg64.algo.ts:43
	// assert(upperBound > 1)
	frame_dig -3 // upperBound: uint64
	intc 1 // 1
	>
	assert

	// utils/types/lib_pcg/pcg64.algo.ts:44
	// assert(lowerBound < upperBound - 1)
	frame_dig -2 // lowerBound: uint64
	frame_dig -3 // upperBound: uint64
	intc 1 // 1
	-
	<
	assert

	// utils/types/lib_pcg/pcg64.algo.ts:46
	// absoluteBound = upperBound - lowerBound
	frame_dig -3 // upperBound: uint64
	frame_dig -2 // lowerBound: uint64
	-
	frame_bury 1 // absoluteBound: uint64
	b *if6_end

*if6_else:
	// utils/types/lib_pcg/pcg64.algo.ts:49
	// assert(lowerBound < Uint<64>('18446744073709551615'))
	frame_dig -2 // lowerBound: uint64
	intc 6 // 18446744073709551615
	<
	assert

	// utils/types/lib_pcg/pcg64.algo.ts:54
	// absoluteBound = (Uint<128>('18446744073709551616') - (lowerBound as uint128)) as uint64
	pushbytes 0x00000000000000010000000000000000
	frame_dig -2 // lowerBound: uint64
	itob
	b-
	dup
	bitlen
	pushint 64
	<=

	// (Uint<128>('18446744073709551616') - (lowerBound as uint128)) as uint64 overflowed 64 bits
	assert
	pushbytes 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 3 // 8
	-
	swap
	substring3
	btoi
	frame_bury 1 // absoluteBound: uint64

*if6_end:
	// utils/types/lib_pcg/pcg64.algo.ts:57
	// threshold = __uint64Twos(absoluteBound) % absoluteBound
	frame_dig 1 // absoluteBound: uint64
	callsub __uint64Twos
	frame_dig 1 // absoluteBound: uint64
	%
	frame_bury 2 // threshold: uint64

	// utils/types/lib_pcg/pcg64.algo.ts:59
	// for (let i = 0; i < length; i = i + 1)
	intc 0 // 0
	frame_bury 6 // i: uint64

*for_3:
	// utils/types/lib_pcg/pcg64.algo.ts:59
	// i < length
	frame_dig 6 // i: uint64
	frame_dig -4 // length: uint64
	<
	bz *for_3_end

*while_0:

*while_0_continue:
	// utils/types/lib_pcg/pcg64.algo.ts:61
	// true
	intc 1 // 1
	bz *while_0_end

	// utils/types/lib_pcg/pcg64.algo.ts:62
	// stepResult = __pcg64Random(newState)
	frame_dig 3 // newState: (uint64,uint64)
	callsub __pcg64Random
	frame_bury 7 // stepResult: ((uint64,uint64),uint64)

	// utils/types/lib_pcg/pcg64.algo.ts:63
	// newState = stepResult[0]
	frame_dig 7 // stepResult: ((uint64,uint64),uint64)
	extract 0 16
	frame_bury 3 // newState: (uint64,uint64)

	// *if7_condition
	// utils/types/lib_pcg/pcg64.algo.ts:64
	// stepResult[1] >= threshold
	frame_dig 7 // stepResult: ((uint64,uint64),uint64)
	extract 16 8
	btoi
	frame_dig 2 // threshold: uint64
	>=
	bz *if7_end

	// *if7_consequent
	// utils/types/lib_pcg/pcg64.algo.ts:65
	// result.push((stepResult[1] % absoluteBound) + lowerBound)
	frame_dig 0 // result: uint64[]
	frame_dig 7 // stepResult: ((uint64,uint64),uint64)
	extract 16 8
	btoi
	frame_dig 1 // absoluteBound: uint64
	%
	frame_dig -2 // lowerBound: uint64
	+
	itob
	concat
	frame_bury 0 // result: uint64[]
	b *while_0_end

*if7_end:
	b *while_0

*while_0_end:

*for_3_continue:
	// utils/types/lib_pcg/pcg64.algo.ts:59
	// i = i + 1
	frame_dig 6 // i: uint64
	intc 1 // 1
	+
	frame_bury 6 // i: uint64
	b *for_3

*for_3_end:

*if5_end:
	// utils/types/lib_pcg/pcg64.algo.ts:72
	// return [newState, result];
	bytec 0 //  initial head
	bytec 0 //  initial tail
	pushbytes 0x0012 // initial head offset
	frame_dig 3 // newState: (uint64,uint64)
	callsub *process_static_tuple_element
	frame_dig 0 // result: uint64[]
	dup
	len
	intc 3 // 8
	/
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

// __uint64Twos(value: uint64): uint64
__uint64Twos:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// utils/types/lib_pcg/pcg32.algo.ts:6
	// addwResult = addw(~value, 1)
	frame_dig -1 // value: uint64
	~
	intc 1 // 1
	addw
	frame_bury 0 // addwResult low: uint64
	frame_bury 1 // addwResult high: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:7
	// return addwResult.low;
	frame_dig 0 // addwResult low: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// __pcg64Random(state: PCG64STATE): [PCG64STATE, uint64]
__pcg64Random:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// utils/types/lib_pcg/pcg64.algo.ts:7
	// highResult = __pcg32UnboundedRandom(state[0])
	frame_dig -1 // state: PCG64STATE
	extract 0 8
	btoi
	callsub __pcg32UnboundedRandom
	frame_bury 0 // highResult: (uint64,uint64)

	// utils/types/lib_pcg/pcg64.algo.ts:9
	// lowState = __pcg32Step(state[1], pcgSecondIncrement << (highResult[0] === 0 ? 1 : 0))
	// utils/types/lib_pcg/consts.algo.ts:5
	// Uint<64>('1442695040888963409')
	intc 7 // 1442695040888963409

	// utils/types/lib_pcg/pcg64.algo.ts:9
	// highResult[0] === 0
	frame_dig 0 // highResult: (uint64,uint64)
	extract 0 8
	btoi
	intc 0 // 0
	==
	bz *ternary1_false
	intc 1 // 1
	b *ternary1_end

*ternary1_false:
	intc 0 // 0

*ternary1_end:
	shl

	// utils/types/lib_pcg/pcg64.algo.ts:9
	// state[1]
	frame_dig -1 // state: PCG64STATE
	extract 8 8
	btoi
	callsub __pcg32Step
	frame_bury 1 // lowState: uint64

	// utils/types/lib_pcg/pcg64.algo.ts:11
	// return [[highResult[0], lowState], (highResult[1] << 32) | __pcg32Output(state[1])];
	frame_dig 0 // highResult: (uint64,uint64)
	extract 0 8
	btoi
	itob
	frame_dig 1 // lowState: uint64
	itob
	concat
	frame_dig 0 // highResult: (uint64,uint64)
	extract 8 8
	btoi
	pushint 32
	shl
	frame_dig -1 // state: PCG64STATE
	extract 8 8
	btoi
	callsub __pcg32Output
	|
	itob
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// __pcg32Output(state: PCG32STATE): uint64
__pcg32Output:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// utils/types/lib_pcg/pcg32.algo.ts:23
	// xorshifted = __maskToUint32(((state >> 18) ^ state) >> 27)
	frame_dig -1 // state: PCG32STATE
	pushint 18
	shr
	frame_dig -1 // state: PCG32STATE
	^
	pushint 27
	shr
	callsub __maskToUint32
	frame_bury 0 // xorshifted: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:24
	// rot = state >> 59
	frame_dig -1 // state: PCG32STATE
	pushint 59
	shr
	frame_bury 1 // rot: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:25
	// return (xorshifted >> rot) | __maskToUint32(xorshifted << (__uint64Twos(rot) & 31));
	frame_dig 0 // xorshifted: uint64
	frame_dig 1 // rot: uint64
	shr
	frame_dig 0 // xorshifted: uint64
	frame_dig 1 // rot: uint64
	callsub __uint64Twos
	pushint 31
	&
	shl
	callsub __maskToUint32
	|

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// __maskToUint32(value: uint64): uint64
__maskToUint32:
	proto 1 1

	// utils/types/lib_pcg/pcg32.algo.ts:12
	// return value & 4294967295;
	frame_dig -1 // value: uint64
	pushint 4294967295
	&
	retsub

// __pcg32Step(state: PCG32STATE, incr: uint64): uint64
__pcg32Step:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// utils/types/lib_pcg/pcg32.algo.ts:16
	// mulwResult = mulw(state, pcgMultiplier)
	frame_dig -1 // state: PCG32STATE

	// utils/types/lib_pcg/consts.algo.ts:1
	// Uint<64>('6364136223846793005')
	pushint 6364136223846793005
	mulw
	frame_bury 0 // mulwResult low: uint64
	frame_bury 1 // mulwResult high: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:17
	// addwResult = addw(mulwResult.low, incr)
	frame_dig 0 // mulwResult low: uint64
	frame_dig -2 // incr: uint64
	addw
	frame_bury 2 // addwResult low: uint64
	frame_bury 3 // addwResult high: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:19
	// return addwResult.low;
	frame_dig 2 // addwResult low: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// __pcg32UnboundedRandom(state: PCG32STATE): [PCG32STATE, uint64]
__pcg32UnboundedRandom:
	proto 1 1

	// utils/types/lib_pcg/pcg32.algo.ts:29
	// return [__pcg32Step(state, pcgFirstIncrement), __pcg32Output(state)];
	// utils/types/lib_pcg/consts.algo.ts:3
	// Uint<64>('1442695040888963407')
	intc 8 // 1442695040888963407
	frame_dig -1 // state: PCG32STATE
	callsub __pcg32Step
	itob

	// utils/types/lib_pcg/pcg32.algo.ts:29
	// __pcg32Output(state)
	frame_dig -1 // state: PCG32STATE
	callsub __pcg32Output
	itob
	concat
	retsub

// pcg64Init(seed: bytes<16>): PCG64STATE
pcg64Init:
	proto 1 1

	// utils/types/lib_pcg/pcg64.algo.ts:15
	// assert(seed.length === 16)
	intc 5 // 16
	dup
	==
	assert

	// utils/types/lib_pcg/pcg64.algo.ts:17
	// return [
	//     __pcg32Init(extractUint64(seed, 0), pcgFirstIncrement),
	//     __pcg32Init(extractUint64(seed, 8), pcgSecondIncrement),
	//   ];
	// utils/types/lib_pcg/consts.algo.ts:3
	// Uint<64>('1442695040888963407')
	intc 8 // 1442695040888963407

	// utils/types/lib_pcg/pcg64.algo.ts:18
	// extractUint64(seed, 0)
	frame_dig -1 // seed: bytes<16>
	intc 0 // 0
	extract_uint64
	callsub __pcg32Init
	itob

	// utils/types/lib_pcg/pcg64.algo.ts:19
	// __pcg32Init(extractUint64(seed, 8), pcgSecondIncrement)
	// utils/types/lib_pcg/consts.algo.ts:5
	// Uint<64>('1442695040888963409')
	intc 7 // 1442695040888963409

	// utils/types/lib_pcg/pcg64.algo.ts:19
	// extractUint64(seed, 8)
	frame_dig -1 // seed: bytes<16>
	intc 3 // 8
	extract_uint64
	callsub __pcg32Init
	itob
	concat
	retsub

// __pcg32Init(initialState: PCG32STATE, incr: uint64): PCG32STATE
__pcg32Init:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// utils/types/lib_pcg/pcg32.algo.ts:90
	// state = __pcg32Step(0, incr)
	frame_dig -2 // incr: uint64
	intc 0 // 0
	callsub __pcg32Step
	frame_bury 0 // state: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:91
	// addwResult = addw(state, initialState)
	frame_dig 0 // state: uint64
	frame_dig -1 // initialState: PCG32STATE
	addw
	frame_bury 1 // addwResult low: uint64
	frame_bury 2 // addwResult high: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:93
	// return __pcg32Step(addwResult.low, incr);
	frame_dig -2 // incr: uint64
	frame_dig 1 // addwResult low: uint64
	callsub __pcg32Step

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub