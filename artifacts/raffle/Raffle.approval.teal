#pragma version 10
intcblock 0 1 4 6 37000 8 16 18446744073709551615 1442695040888963409 1442695040888963407 2 30 32
bytecblock 0x 0x7469636b65745f636f756e74 0x7469636b65745f6173736574 0x726166666c655f77696e6e6572 0x656e7472795f636f756e74 0x7072697a65 0x73656c6c6572 0x66696e645f77696e6e65725f637572736f72 0x77696e6e696e675f7469636b6574 0x66696e645f77696e6e65725f746f74616c5f637572736f72 0x726166666c655f7072697a655f636c61696d6564 0x656e64696e675f726f756e64 0x7672665f6765745f6661696c7572655f636f756e74 0x6d696e5f7469636b657473 0x6d61785f7469636b657473 0x656e7472795f6964 0x67617465 0x00 0x7672665f626561636f6e5f6170705f6964 0x7374617274696e675f726f756e64 0x08531ed7 0x151f7c75

// This TEAL was generated by TEALScript v0.106.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 3 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_DeleteApplication *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// gate(caller: Address, index: uint64, args: bytes[]): boolean
gate:
	proto 3 1

	// *if0_condition
	// utils/base_contracts/gate.algo.ts:10
	// index === 0
	frame_dig -2 // index: uint64
	intc 0 // 0
	==
	bz *if0_end

	// *if0_consequent
	// utils/base_contracts/gate.algo.ts:11
	// return true;
	intc 1 // 1
	retsub

*if0_end:
	// utils/base_contracts/gate.algo.ts:14
	// return sendMethodCall<typeof Gate.prototype.check, boolean>({
	//             applicationID: AppID.fromUint64(AkitaAppIDsGate),
	//             methodArgs: [caller, index, args],
	//             fee: 0
	//         });
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0x200f7421 // method "check(address,uint64,byte[][])bool"
	itxn_field ApplicationArgs

	// utils/base_contracts/gate.algo.ts:15
	// applicationID: AppID.fromUint64(AkitaAppIDsGate)
	intc 0 // 0
	itxn_field ApplicationID

	// utils/base_contracts/gate.algo.ts:16
	// methodArgs: [caller, index, args]
	frame_dig -1 // caller: Address
	itxn_field ApplicationArgs
	frame_dig -2 // index: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -3 // args: bytes[]
	itxn_field ApplicationArgs

	// utils/base_contracts/gate.algo.ts:17
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	retsub

// optin(pay,uint64)void
*abi_route_optin:
	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// payment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 1 (payment) for optin must be a pay transaction
	assert

	// execute optin(pay,uint64)void
	callsub optin
	intc 1 // 1
	return

// optin(payment: PayTxn, asset: AssetID): void
//
// optin tells the contract to opt into an asa
// @param payment The payment transaction
// @param asset The asset to be opted into
optin:
	proto 2 0

	// utils/base_contracts/optin.algo.ts:40
	// assert(this.txn.sender === this.app.creator)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==
	assert

	// utils/base_contracts/optin.algo.ts:42
	// verifyPayTxn(payment, {
	//             receiver: this.app.address,
	//             amount: globals.assetOptInMinBalance,
	//         })
	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	global AssetOptInMinBalance
	==

	// transaction verification failed: {"txn":"payment","field":"amount","expected":"globals.assetOptInMinBalance"}
	assert

	// utils/base_contracts/optin.algo.ts:47
	// sendAssetTransfer({
	//             sender: this.app.address,
	//             assetReceiver: this.app.address,
	//             assetAmount: 0,
	//             xferAsset: asset,
	//             fee: 0,
	//         })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// utils/base_contracts/optin.algo.ts:48
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// utils/base_contracts/optin.algo.ts:49
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// utils/base_contracts/optin.algo.ts:50
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// utils/base_contracts/optin.algo.ts:51
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// utils/base_contracts/optin.algo.ts:52
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// arc59OptInAndSend(recipient: Address, asset: AssetID, amount: uint64, closeOut: boolean): void
arc59OptInAndSend:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// utils/base_contracts/optin.algo.ts:61
	// assetInboxAppID = AppID.fromUint64(OtherAppIDsAssetInbox)
	intc 0 // 0
	frame_bury 0 // assetInboxAppID: uint64

	// utils/base_contracts/optin.algo.ts:62
	// canCallData = sendMethodCall<typeof AssetInbox.prototype.arc59_getSendAssetInfo, arc59GetSendAssetInfoResponse>({
	//             applicationID: assetInboxAppID,
	//             methodArgs: [
	//                 recipient,
	//                 asset.id,
	//             ],
	//             fee: 0,
	//         })
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0xcaa8daa5 // method "arc59_getSendAssetInfo(address,uint64)(uint64,uint64,bool,bool,uint64)"
	itxn_field ApplicationArgs

	// utils/base_contracts/optin.algo.ts:63
	// applicationID: assetInboxAppID
	intc 0 //  assetInboxAppID: uint64
	itxn_field ApplicationID

	// utils/base_contracts/optin.algo.ts:64
	// methodArgs: [
	//                 recipient,
	//                 asset.id,
	//             ]
	frame_dig -1 // recipient: Address
	itxn_field ApplicationArgs
	frame_dig -2 // asset: AssetID
	itob
	itxn_field ApplicationArgs

	// utils/base_contracts/optin.algo.ts:68
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 1 // canCallData: (uint64,uint64,bool,bool,uint64)

	// utils/base_contracts/optin.algo.ts:71
	// mbr = canCallData.mbr
	frame_dig 1 // canCallData: (uint64,uint64,bool,bool,uint64)
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	frame_bury 2 // mbr: uint64

	// utils/base_contracts/optin.algo.ts:72
	// routerOptedIn = canCallData.routerOptedIn
	frame_dig 1 // canCallData: (uint64,uint64,bool,bool,uint64)
	store 255 // full array
	load 255 // full array
	pushint 128
	getbit
	frame_bury 3 // routerOptedIn: bool

	// utils/base_contracts/optin.algo.ts:73
	// receiverAlgoNeededForClaim = canCallData.receiverAlgoNeededForClaim
	frame_dig 1 // canCallData: (uint64,uint64,bool,bool,uint64)
	store 255 // full array
	load 255 // full array
	extract 17 8
	btoi
	frame_bury 4 // receiverAlgoNeededForClaim: uint64

	// *if1_condition
	// utils/base_contracts/optin.algo.ts:75
	// mbr || receiverAlgoNeededForClaim
	frame_dig 2 // mbr: uint64
	dup
	bnz *skip_or0
	frame_dig 4 // receiverAlgoNeededForClaim: uint64
	||

*skip_or0:
	bz *if1_end

	// *if1_consequent
	// utils/base_contracts/optin.algo.ts:76
	// this.pendingGroup.addPayment({
	//                 receiver: assetInboxAppID.address,
	//                 amount: (mbr + receiverAlgoNeededForClaim),
	//                 fee: 0,
	//             })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// utils/base_contracts/optin.algo.ts:77
	// receiver: assetInboxAppID.address
	intc 0 //  assetInboxAppID: uint64
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// utils/base_contracts/optin.algo.ts:78
	// amount: (mbr + receiverAlgoNeededForClaim)
	frame_dig 2 // mbr: uint64
	frame_dig 4 // receiverAlgoNeededForClaim: uint64
	+
	itxn_field Amount

	// utils/base_contracts/optin.algo.ts:79
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if1_end:
	// *if2_condition
	// utils/base_contracts/optin.algo.ts:83
	// !routerOptedIn
	frame_dig 3 // routerOptedIn: bool
	!
	bz *if2_end

	// *if2_consequent
	// utils/base_contracts/optin.algo.ts:84
	// this.pendingGroup.addMethodCall<typeof AssetInbox.prototype.arc59_optRouterIn, void>({
	//                 applicationID: assetInboxAppID,
	//                 methodArgs: [asset.id],
	//                 fee: 0
	//             })
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0xe8540810 // method "arc59_optRouterIn(uint64)void"
	itxn_field ApplicationArgs

	// utils/base_contracts/optin.algo.ts:85
	// applicationID: assetInboxAppID
	intc 0 //  assetInboxAppID: uint64
	itxn_field ApplicationID

	// utils/base_contracts/optin.algo.ts:86
	// methodArgs: [asset.id]
	frame_dig -2 // asset: AssetID
	itob
	itxn_field ApplicationArgs

	// utils/base_contracts/optin.algo.ts:87
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if2_end:
	// *if3_condition
	// utils/base_contracts/optin.algo.ts:91
	// closeOut
	frame_dig -4 // closeOut: boolean
	bz *if3_else

	// *if3_consequent
	// utils/base_contracts/optin.algo.ts:92
	// this.pendingGroup.addMethodCall<typeof AssetInbox.prototype.arc59_sendAsset, Address>({
	//                 applicationID: assetInboxAppID,
	//                 methodArgs: [
	//                     {
	//                         assetCloseTo: assetInboxAppID.address,
	//                         assetReceiver: assetInboxAppID.address,
	//                         assetAmount: amount,
	//                         xferAsset: asset,
	//                         fee: 0,
	//                     },
	//                     recipient,
	//                     receiverAlgoNeededForClaim,
	//                 ],
	//                 fee: 0
	//             })
	itxn_next
	intc 2 //  axfer
	itxn_field TypeEnum

	// utils/base_contracts/optin.algo.ts:96
	// assetCloseTo: assetInboxAppID.address
	intc 0 //  assetInboxAppID: uint64
	app_params_get AppAddress
	pop
	itxn_field AssetCloseTo

	// utils/base_contracts/optin.algo.ts:97
	// assetReceiver: assetInboxAppID.address
	intc 0 //  assetInboxAppID: uint64
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// utils/base_contracts/optin.algo.ts:98
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// utils/base_contracts/optin.algo.ts:99
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// utils/base_contracts/optin.algo.ts:100
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 20 //  method "arc59_sendAsset(axfer,address,uint64)address"
	itxn_field ApplicationArgs

	// utils/base_contracts/optin.algo.ts:93
	// applicationID: assetInboxAppID
	intc 0 //  assetInboxAppID: uint64
	itxn_field ApplicationID

	// utils/base_contracts/optin.algo.ts:94
	// methodArgs: [
	//                     {
	//                         assetCloseTo: assetInboxAppID.address,
	//                         assetReceiver: assetInboxAppID.address,
	//                         assetAmount: amount,
	//                         xferAsset: asset,
	//                         fee: 0,
	//                     },
	//                     recipient,
	//                     receiverAlgoNeededForClaim,
	//                 ]
	frame_dig -1 // recipient: Address
	itxn_field ApplicationArgs
	frame_dig 4 // receiverAlgoNeededForClaim: uint64
	itob
	itxn_field ApplicationArgs

	// utils/base_contracts/optin.algo.ts:105
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	b *if3_end

*if3_else:
	// utils/base_contracts/optin.algo.ts:108
	// this.pendingGroup.addMethodCall<typeof AssetInbox.prototype.arc59_sendAsset, Address>({
	//                 applicationID: assetInboxAppID,
	//                 methodArgs: [
	//                     {
	//                         assetReceiver: assetInboxAppID.address,
	//                         assetAmount: amount,
	//                         xferAsset: asset,
	//                         fee: 0,
	//                     },
	//                     recipient,
	//                     receiverAlgoNeededForClaim,
	//                 ],
	//                 fee: 0
	//             })
	itxn_next
	intc 2 //  axfer
	itxn_field TypeEnum

	// utils/base_contracts/optin.algo.ts:112
	// assetReceiver: assetInboxAppID.address
	intc 0 //  assetInboxAppID: uint64
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// utils/base_contracts/optin.algo.ts:113
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// utils/base_contracts/optin.algo.ts:114
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// utils/base_contracts/optin.algo.ts:115
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 3 //  appl
	itxn_field TypeEnum
	bytec 20 //  method "arc59_sendAsset(axfer,address,uint64)address"
	itxn_field ApplicationArgs

	// utils/base_contracts/optin.algo.ts:109
	// applicationID: assetInboxAppID
	intc 0 //  assetInboxAppID: uint64
	itxn_field ApplicationID

	// utils/base_contracts/optin.algo.ts:110
	// methodArgs: [
	//                     {
	//                         assetReceiver: assetInboxAppID.address,
	//                         assetAmount: amount,
	//                         xferAsset: asset,
	//                         fee: 0,
	//                     },
	//                     recipient,
	//                     receiverAlgoNeededForClaim,
	//                 ]
	frame_dig -1 // recipient: Address
	itxn_field ApplicationArgs
	frame_dig 4 // receiverAlgoNeededForClaim: uint64
	itob
	itxn_field ApplicationArgs

	// utils/base_contracts/optin.algo.ts:120
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if3_end:
	// utils/base_contracts/optin.algo.ts:124
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// createApplication(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64)void
*abi_route_createApplication:
	// vrfBeaconAppID: uint64
	txna ApplicationArgs 9
	btoi

	// gateID: uint64
	txna ApplicationArgs 8
	btoi

	// maxTickets: uint64
	txna ApplicationArgs 7
	btoi

	// minTickets: uint64
	txna ApplicationArgs 6
	btoi

	// seller: address
	txna ApplicationArgs 5
	dup
	len
	intc 12 // 32
	==

	// argument 4 (seller) for createApplication must be a address
	assert

	// endingRound: uint64
	txna ApplicationArgs 4
	btoi

	// startingRound: uint64
	txna ApplicationArgs 3
	btoi

	// ticketAsset: uint64
	txna ApplicationArgs 2
	btoi

	// prize: uint64
	txna ApplicationArgs 1
	btoi

	// execute createApplication(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64)void
	callsub createApplication
	intc 1 // 1
	return

// createApplication(prize: AssetID, ticketAsset: AssetID, startingRound: uint64, endingRound: uint64, seller: Address, minTickets: uint64, maxTickets: uint64, gateID: uint64, vrfBeaconAppID: AppID): void
createApplication:
	proto 9 0

	// contracts/raffle/raffle.algo.ts:130
	// this.prize.value = prize
	bytec 5 //  "prize"
	frame_dig -1 // prize: AssetID
	app_global_put

	// contracts/raffle/raffle.algo.ts:131
	// this.ticketAsset.value = ticketAsset
	bytec 2 //  "ticket_asset"
	frame_dig -2 // ticketAsset: AssetID
	app_global_put

	// contracts/raffle/raffle.algo.ts:132
	// this.startingRound.value = startingRound
	bytec 19 //  "starting_round"
	frame_dig -3 // startingRound: uint64
	app_global_put

	// contracts/raffle/raffle.algo.ts:133
	// assert(
	//             endingRound > startingRound
	//             && endingRound > (globals.round + roundsPerHour),
	//             errs.TOO_SHORT
	//         )
	frame_dig -4 // endingRound: uint64
	frame_dig -3 // startingRound: uint64
	>
	dup
	bz *skip_and0
	frame_dig -4 // endingRound: uint64
	global Round
	pushint 1285
	+
	>
	&&

*skip_and0:
	assert

	// contracts/raffle/raffle.algo.ts:138
	// this.endingRound.value = endingRound
	bytec 11 //  "ending_round"
	frame_dig -4 // endingRound: uint64
	app_global_put

	// contracts/raffle/raffle.algo.ts:139
	// this.seller.value = seller
	bytec 6 //  "seller"
	frame_dig -5 // seller: Address
	app_global_put

	// contracts/raffle/raffle.algo.ts:140
	// this.minTickets.value = minTickets
	bytec 13 //  "min_tickets"
	frame_dig -6 // minTickets: uint64
	app_global_put

	// contracts/raffle/raffle.algo.ts:141
	// this.maxTickets.value = maxTickets
	bytec 14 //  "max_tickets"
	frame_dig -7 // maxTickets: uint64
	app_global_put

	// contracts/raffle/raffle.algo.ts:142
	// this.entryCount.value = 0
	bytec 4 //  "entry_count"
	intc 0 // 0
	app_global_put

	// contracts/raffle/raffle.algo.ts:143
	// this.ticketCount.value = 0
	bytec 1 //  "ticket_count"
	intc 0 // 0
	app_global_put

	// contracts/raffle/raffle.algo.ts:144
	// this.winningTicket.value = 0
	bytec 8 //  "winning_ticket"
	intc 0 // 0
	app_global_put

	// contracts/raffle/raffle.algo.ts:145
	// this.raffleWinner.value = Address.zeroAddress
	bytec 3 //  "raffle_winner"
	global ZeroAddress
	app_global_put

	// contracts/raffle/raffle.algo.ts:146
	// this.rafflePrizeClaimed.value = false
	bytec 10 //  "raffle_prize_claimed"
	intc 0 // 0
	bytec 17 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put

	// contracts/raffle/raffle.algo.ts:147
	// this.gateID.value = gateID
	bytec 16 //  "gate"
	frame_dig -8 // gateID: uint64
	app_global_put

	// contracts/raffle/raffle.algo.ts:148
	// this.vrfBeaconAppID.value = vrfBeaconAppID
	bytec 18 //  "vrf_beacon_app_id"
	frame_dig -9 // vrfBeaconAppID: AppID
	app_global_put

	// contracts/raffle/raffle.algo.ts:149
	// this.entryID.value = 0
	bytec 15 //  "entry_id"
	intc 0 // 0
	app_global_put

	// contracts/raffle/raffle.algo.ts:150
	// this.findWinnerCursor.value = 0
	bytec 7 //  "find_winner_cursor"
	intc 0 // 0
	app_global_put

	// contracts/raffle/raffle.algo.ts:151
	// this.findWinnerTotalCursor.value = 0
	bytec 9 //  "find_winner_total_cursor"
	intc 0 // 0
	app_global_put
	retsub

// isLive()bool
*abi_route_isLive:
	// The ABI return prefix
	bytec 21 // 0x151f7c75

	// execute isLive()bool
	callsub isLive
	bytec 17 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	concat
	log
	intc 1 // 1
	return

// isLive(): boolean
//
//
// @returns a boolean of whether the auction is live
isLive:
	proto 0 1

	// contracts/raffle/raffle.algo.ts:159
	// return (
	//             globals.round <= this.startingRound.value
	//             && globals.round >= this.endingRound.value
	//         )
	global Round
	bytec 19 //  "starting_round"
	app_global_get
	<=
	dup
	bz *skip_and1
	global Round
	bytec 11 //  "ending_round"
	app_global_get
	>=
	&&

*skip_and1:
	retsub

// enter(pay,byte[][])void
*abi_route_enter:
	// args: byte[][]
	txna ApplicationArgs 1

	// payment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 1 (payment) for enter must be a pay transaction
	assert

	// execute enter(pay,byte[][])void
	callsub enter
	intc 1 // 1
	return

// enter(payment: PayTxn, args: bytes[]): void
enter:
	proto 2 0

	// contracts/raffle/raffle.algo.ts:166
	// assert(this.isLive(), errs.NOT_LIVE)
	callsub isLive
	assert

	// contracts/raffle/raffle.algo.ts:167
	// assert(this.ticketAsset.value.id === 0, errs.TICKET_ASSET_NOT_ALGO)
	bytec 2 //  "ticket_asset"
	app_global_get
	intc 0 // 0
	==
	assert

	// contracts/raffle/raffle.algo.ts:168
	// assert(this.gate(this.txn.sender, this.gateID.value, args), errs.FAILED_GATE)
	frame_dig -2 // args: bytes[]
	bytec 16 //  "gate"
	app_global_get
	txn Sender
	callsub gate
	assert

	// contracts/raffle/raffle.algo.ts:170
	// verifyPayTxn(payment, {
	//             amount: {
	//                 greaterThanEqualTo: this.minTickets.value + entryMBR,
	//                 lessThanEqualTo: this.maxTickets.value + entryMBR,
	//             },
	//             receiver: this.app.address,
	//         })
	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	bytec 13 //  "min_tickets"
	app_global_get
	intc 4 // 37000
	+
	>=

	// transaction verification failed: {"txn":"payment","field":"amount","condition":"greaterThanEqualTo","expected":">=this.minTickets.value + entryMBR"}
	assert
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	bytec 14 //  "max_tickets"
	app_global_get
	intc 4 // 37000
	+
	<=

	// transaction verification failed: {"txn":"payment","field":"amount","condition":"lessThanEqualTo","expected":"<=this.maxTickets.value + entryMBR"}
	assert

	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// contracts/raffle/raffle.algo.ts:178
	// assert(!this.entriesByAddress(this.txn.sender).exists, errs.ALREADY_ENTERED)
	txn Sender
	box_len
	swap
	pop
	!
	assert

	// contracts/raffle/raffle.algo.ts:180
	// this.entries(this.entryCount.value).value = this.txn.sender
	bytec 4 //  "entry_count"
	app_global_get
	itob
	txn Sender
	box_put

	// contracts/raffle/raffle.algo.ts:181
	// this.entriesByAddress(this.txn.sender).value = this.entryCount.value
	txn Sender
	bytec 4 //  "entry_count"
	app_global_get
	itob
	box_put

	// contracts/raffle/raffle.algo.ts:182
	// this.entryCount.value += 1
	bytec 4 //  "entry_count"
	app_global_get
	intc 1 // 1
	+
	bytec 4 //  "entry_count"
	swap
	app_global_put

	// contracts/raffle/raffle.algo.ts:183
	// this.ticketCount.value += payment.amount - entryMBR
	bytec 1 //  "ticket_count"
	app_global_get
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	intc 4 // 37000
	-
	+
	bytec 1 //  "ticket_count"
	swap
	app_global_put
	retsub

// enterAsa(pay,axfer,byte[][])void
*abi_route_enterAsa:
	// args: byte[][]
	txna ApplicationArgs 1

	// assetXfer: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 2 //  axfer
	==

	// argument 1 (assetXfer) for enterAsa must be a axfer transaction
	assert

	// payment: pay
	txn GroupIndex
	intc 10 // 2
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 2 (payment) for enterAsa must be a pay transaction
	assert

	// execute enterAsa(pay,axfer,byte[][])void
	callsub enterAsa
	intc 1 // 1
	return

// enterAsa(payment: PayTxn, assetXfer: AssetTransferTxn, args: bytes[]): void
enterAsa:
	proto 3 0

	// contracts/raffle/raffle.algo.ts:187
	// assert(this.isLive(), errs.NOT_LIVE)
	callsub isLive
	assert

	// contracts/raffle/raffle.algo.ts:188
	// assert(this.ticketAsset.value.id !== 0, errs.TICKET_ASSET_ALGO)
	bytec 2 //  "ticket_asset"
	app_global_get
	intc 0 // 0
	!=
	assert

	// contracts/raffle/raffle.algo.ts:189
	// assert(this.gate(this.txn.sender, this.gateID.value, args), errs.FAILED_GATE)
	frame_dig -3 // args: bytes[]
	bytec 16 //  "gate"
	app_global_get
	txn Sender
	callsub gate
	assert

	// contracts/raffle/raffle.algo.ts:191
	// verifyPayTxn(payment, {
	//             amount: entryMBR,
	//             receiver: this.app.address,
	//         })
	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	intc 4 // 37000
	==

	// transaction verification failed: {"txn":"payment","field":"amount","expected":"entryMBR"}
	assert

	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// contracts/raffle/raffle.algo.ts:196
	// verifyAssetTransferTxn(assetXfer, {
	//             xferAsset: this.ticketAsset.value,
	//             assetAmount: {
	//                 greaterThanEqualTo: this.minTickets.value,
	//                 lessThanEqualTo: this.maxTickets.value,
	//             },
	//             assetReceiver: this.app.address,
	//         })
	// verify xferAsset
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns XferAsset
	bytec 2 //  "ticket_asset"
	app_global_get
	==

	// transaction verification failed: {"txn":"assetXfer","field":"xferAsset","expected":"this.ticketAsset.value"}
	assert

	// verify assetAmount
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns AssetAmount
	bytec 13 //  "min_tickets"
	app_global_get
	>=

	// transaction verification failed: {"txn":"assetXfer","field":"assetAmount","condition":"greaterThanEqualTo","expected":">=this.minTickets.value"}
	assert
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns AssetAmount
	bytec 14 //  "max_tickets"
	app_global_get
	<=

	// transaction verification failed: {"txn":"assetXfer","field":"assetAmount","condition":"lessThanEqualTo","expected":"<=this.maxTickets.value"}
	assert

	// verify assetReceiver
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"assetXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// contracts/raffle/raffle.algo.ts:205
	// assert(!this.entriesByAddress(this.txn.sender).exists, errs.ALREADY_ENTERED)
	txn Sender
	box_len
	swap
	pop
	!
	assert

	// contracts/raffle/raffle.algo.ts:207
	// this.entries(this.entryCount.value).value = this.txn.sender
	bytec 4 //  "entry_count"
	app_global_get
	itob
	txn Sender
	box_put

	// contracts/raffle/raffle.algo.ts:208
	// this.entriesByAddress(this.txn.sender).value = this.entryCount.value
	txn Sender
	bytec 4 //  "entry_count"
	app_global_get
	itob
	box_put

	// contracts/raffle/raffle.algo.ts:209
	// this.entryCount.value += 1
	bytec 4 //  "entry_count"
	app_global_get
	intc 1 // 1
	+
	bytec 4 //  "entry_count"
	swap
	app_global_put

	// contracts/raffle/raffle.algo.ts:210
	// this.ticketCount.value += assetXfer.assetAmount
	bytec 1 //  "ticket_count"
	app_global_get
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns AssetAmount
	+
	bytec 1 //  "ticket_count"
	swap
	app_global_put
	retsub

// raffle()void
*abi_route_raffle:
	// execute raffle()void
	callsub raffle
	intc 1 // 1
	return

// raffle(): void
raffle:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 5

	// contracts/raffle/raffle.algo.ts:214
	// roundToUse = (this.endingRound.value + 1) + (4 * this.vrfGetFailureCount.value)
	bytec 11 //  "ending_round"
	app_global_get
	intc 1 // 1
	+
	intc 2 // 4
	bytec 12 //  "vrf_get_failure_count"
	app_global_get
	*
	+
	frame_bury 0 // roundToUse: uint64

	// contracts/raffle/raffle.algo.ts:215
	// assert(globals.round >= (roundToUse + 8), errs.NOT_ENOUGH_TIME)
	global Round
	frame_dig 0 // roundToUse: uint64
	intc 5 // 8
	+
	>=
	assert

	// contracts/raffle/raffle.algo.ts:216
	// assert(this.winningTicket.value === 0, errs.WINNER_ALREADY_DRAWN)
	bytec 8 //  "winning_ticket"
	app_global_get
	intc 0 // 0
	==
	assert

	// contracts/raffle/raffle.algo.ts:218
	// seed = sendMethodCall<typeof RandomnessBeacon.prototype.get, bytes>({
	//             applicationID: this.vrfBeaconAppID.value,
	//             methodArgs: [ roundToUse, this.txn.txID ],
	//             fee: 0,
	//         })
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum
	pushbytes 0x189392c5 // method "get(uint64,byte[])byte[]"
	itxn_field ApplicationArgs

	// contracts/raffle/raffle.algo.ts:219
	// applicationID: this.vrfBeaconAppID.value
	bytec 18 //  "vrf_beacon_app_id"
	app_global_get
	itxn_field ApplicationID

	// contracts/raffle/raffle.algo.ts:220
	// methodArgs: [ roundToUse, this.txn.txID ]
	frame_dig 0 // roundToUse: uint64
	itob
	itxn_field ApplicationArgs
	txn TxID
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs

	// contracts/raffle/raffle.algo.ts:221
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	extract 2 0
	frame_bury 1 // seed: byte[]

	// *if4_condition
	// contracts/raffle/raffle.algo.ts:224
	// seed.length === 0
	frame_dig 1 // seed: byte[]
	len
	intc 0 // 0
	==
	bz *if4_end

	// *if4_consequent
	// contracts/raffle/raffle.algo.ts:225
	// this.vrfGetFailureCount.value += 1
	bytec 12 //  "vrf_get_failure_count"
	app_global_get
	intc 1 // 1
	+
	bytec 12 //  "vrf_get_failure_count"
	swap
	app_global_put

	// contracts/raffle/raffle.algo.ts:226
	// return;
	retsub

*if4_end:
	// contracts/raffle/raffle.algo.ts:229
	// rngState = pcg64Init(substring3(seed, 0, 16) as bytes<16>)
	frame_dig 1 // seed: byte[]
	substring 0 16
	pushbytes 0x00000000000000000000000000000000
	concat
	dup
	extract 16 0
	bytec 0 // 0x
	b==
	assert
	extract 0 16
	callsub pcg64Init
	frame_bury 2 // rngState: (uint64,uint64)

	// contracts/raffle/raffle.algo.ts:231
	// upperBound = this.ticketCount.value
	bytec 1 //  "ticket_count"
	app_global_get
	frame_bury 3 // upperBound: uint64

	// *if5_condition
	// contracts/raffle/raffle.algo.ts:232
	// upperBound < MAX_UINT64
	frame_dig 3 // upperBound: uint64

	// utils/constants.ts:3
	// Uint<64>('18446744073709551615')
	intc 7 // 18446744073709551615
	<
	bz *if5_end

	// *if5_consequent
	// contracts/raffle/raffle.algo.ts:233
	// upperBound = upperBound += 1
	frame_dig 3 // upperBound: uint64
	intc 1 // 1
	+
	dup
	store 245 // assignment value
	frame_bury 3 // upperBound: uint64
	load 245 // assignment value
	frame_bury 3 // upperBound: uint64

*if5_end:
	// contracts/raffle/raffle.algo.ts:236
	// rngResult = pcg64Random(rngState, 1, upperBound, 1)
	intc 1 // 1
	frame_dig 3 // upperBound: uint64
	intc 1 // 1
	frame_dig 2 // rngState: (uint64,uint64)
	callsub pcg64Random
	frame_bury 4 // rngResult: ((uint64,uint64),uint64[])

	// contracts/raffle/raffle.algo.ts:237
	// winningTicket = rngResult[1][0]
	frame_dig 4 // rngResult: ((uint64,uint64),uint64[])
	store 255 // full array
	load 255 // full array
	intc 6 // 16
	extract_uint16
	intc 0 //  acc * typeLength
	+
	intc 10 // 2
	+ // add two for length
	load 255 // full array
	swap
	intc 5 // 8
	extract3
	btoi
	frame_bury 5 // winningTicket: uint64

	// contracts/raffle/raffle.algo.ts:239
	// this.winningTicket.value = winningTicket
	bytec 8 //  "winning_ticket"
	frame_dig 5 // winningTicket: uint64
	app_global_put
	retsub

// findWinner()void
*abi_route_findWinner:
	// execute findWinner()void
	callsub findWinner
	intc 1 // 1
	return

// findWinner(): void
findWinner:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 7

	// contracts/raffle/raffle.algo.ts:243
	// assert(globals.round < this.endingRound.value, errs.RAFFLE_HAS_NOT_ENDED)
	global Round
	bytec 11 //  "ending_round"
	app_global_get
	<
	assert

	// contracts/raffle/raffle.algo.ts:244
	// assert(this.winningTicket.value > 0, errs.NO_WINNING_TICKET_YET)
	bytec 8 //  "winning_ticket"
	app_global_get
	intc 0 // 0
	>
	assert

	// contracts/raffle/raffle.algo.ts:245
	// complete = this.entryID.value === this.findWinnerCursor.value
	bytec 15 //  "entry_id"
	app_global_get
	bytec 7 //  "find_winner_cursor"
	app_global_get
	==
	frame_bury 0 // complete: bool

	// contracts/raffle/raffle.algo.ts:246
	// assert(!complete, errs.WINNER_ALREADY_FOUND)
	frame_dig 0 // complete: bool
	!
	assert

	// contracts/raffle/raffle.algo.ts:249
	// startingIndex = this.findWinnerCursor.value
	bytec 7 //  "find_winner_cursor"
	app_global_get
	frame_bury 1 // startingIndex: uint64

	// contracts/raffle/raffle.algo.ts:250
	// remainder = this.entryID.value - this.findWinnerCursor.value
	bytec 15 //  "entry_id"
	app_global_get
	bytec 7 //  "find_winner_cursor"
	app_global_get
	-
	frame_bury 2 // remainder: uint64

	// contracts/raffle/raffle.algo.ts:252
	// iterationAmount = (remainder > 30) ? 30 : remainder
	frame_dig 2 // remainder: uint64
	intc 11 // 30
	>
	bz *ternary0_false
	intc 11 // 30
	b *ternary0_end

*ternary0_false:
	frame_dig 2 // remainder: uint64

*ternary0_end:
	frame_bury 3 // iterationAmount: uint64

	// contracts/raffle/raffle.algo.ts:254
	// for (let i = startingIndex; i < iterationAmount; i += 1)
	frame_dig 1 // startingIndex: uint64
	frame_bury 4 // i: uint64

*for_0:
	// contracts/raffle/raffle.algo.ts:254
	// i < iterationAmount
	frame_dig 4 // i: uint64
	frame_dig 3 // iterationAmount: uint64
	<
	bz *for_0_end

	// contracts/raffle/raffle.algo.ts:255
	// address = this.entries(i).value
	frame_dig 4 // i: uint64
	itob
	box_get

	// box value does not exist: this.entries(i).value
	assert
	frame_bury 5 // address: address

	// contracts/raffle/raffle.algo.ts:256
	// amt = this.entriesByAddress(address).value
	frame_dig 5 // address: address
	box_get

	// box value does not exist: this.entriesByAddress(address).value
	assert
	btoi
	frame_bury 6 // amt: uint64

	// contracts/raffle/raffle.algo.ts:258
	// this.entries(i).delete()
	frame_dig 4 // i: uint64
	itob
	box_del

	// contracts/raffle/raffle.algo.ts:259
	// this.entriesByAddress(address).delete()
	frame_dig 5 // address: address
	box_del

	// contracts/raffle/raffle.algo.ts:262
	// sendPayment({
	//                 receiver: address,
	//                 amount: entryMBR,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:263
	// receiver: address
	frame_dig 5 // address: address
	itxn_field Receiver

	// contracts/raffle/raffle.algo.ts:264
	// amount: entryMBR
	intc 4 // 37000
	itxn_field Amount

	// contracts/raffle/raffle.algo.ts:265
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/raffle/raffle.algo.ts:268
	// isWinner = this.findWinnerTotalCursor.value + amt >= this.winningTicket.value
	bytec 9 //  "find_winner_total_cursor"
	app_global_get
	frame_dig 6 // amt: uint64
	+
	bytec 8 //  "winning_ticket"
	app_global_get
	>=
	frame_bury 7 // isWinner: bool

	// *if6_condition
	// contracts/raffle/raffle.algo.ts:269
	// isWinner
	frame_dig 7 // isWinner: bool
	bz *if6_end

	// *if6_consequent
	// contracts/raffle/raffle.algo.ts:270
	// this.raffleWinner.value = address
	bytec 3 //  "raffle_winner"
	frame_dig 5 // address: address
	app_global_put

*if6_end:
	// contracts/raffle/raffle.algo.ts:273
	// this.findWinnerTotalCursor.value += amt
	bytec 9 //  "find_winner_total_cursor"
	app_global_get
	frame_dig 6 // amt: uint64
	+
	bytec 9 //  "find_winner_total_cursor"
	swap
	app_global_put

*for_0_continue:
	// contracts/raffle/raffle.algo.ts:254
	// i += 1
	frame_dig 4 // i: uint64
	intc 1 // 1
	+
	frame_bury 4 // i: uint64
	b *for_0

*for_0_end:
	// contracts/raffle/raffle.algo.ts:276
	// this.findWinnerCursor.value = iterationAmount
	bytec 7 //  "find_winner_cursor"
	frame_dig 3 // iterationAmount: uint64
	app_global_put
	retsub

// claimRafflePrize()void
*abi_route_claimRafflePrize:
	// execute claimRafflePrize()void
	callsub claimRafflePrize
	intc 1 // 1
	return

// claimRafflePrize(): void
claimRafflePrize:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/raffle/raffle.algo.ts:280
	// assert(this.raffleWinner.value !== globals.zeroAddress, errs.WINNER_NOT_FOUND)
	bytec 3 //  "raffle_winner"
	app_global_get
	global ZeroAddress
	!=
	assert

	// contracts/raffle/raffle.algo.ts:281
	// assert(!this.rafflePrizeClaimed.value, errs.PRIZE_ALREADY_CLAIMED)
	bytec 10 //  "raffle_prize_claimed"
	app_global_get
	intc 0 // 0
	getbit
	!
	assert

	// contracts/raffle/raffle.algo.ts:283
	// winnerAmount = 0
	intc 0 // 0
	frame_bury 0 // winnerAmount: uint64

	// *if7_condition
	// contracts/raffle/raffle.algo.ts:284
	// this.prize.value.id === 0
	bytec 5 //  "prize"
	app_global_get
	intc 0 // 0
	==
	bz *if7_else

	// *if7_consequent
	// contracts/raffle/raffle.algo.ts:285
	// winnerAmount = (this.app.address.balance - this.app.address.minBalance)
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	-
	frame_bury 0 // winnerAmount: uint64

	// *if8_condition
	// contracts/raffle/raffle.algo.ts:286
	// this.prize.value === this.ticketAsset.value
	bytec 5 //  "prize"
	app_global_get
	bytec 2 //  "ticket_asset"
	app_global_get
	==
	bz *if8_end

	// *if8_consequent
	// contracts/raffle/raffle.algo.ts:287
	// winnerAmount -= this.ticketCount.value
	frame_dig 0 // winnerAmount: uint64
	bytec 1 //  "ticket_count"
	app_global_get
	-
	frame_bury 0 // winnerAmount: uint64

*if8_end:
	// contracts/raffle/raffle.algo.ts:290
	// sendPayment({
	//                 receiver: this.raffleWinner.value,
	//                 amount: winnerAmount,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:291
	// receiver: this.raffleWinner.value
	bytec 3 //  "raffle_winner"
	app_global_get
	itxn_field Receiver

	// contracts/raffle/raffle.algo.ts:292
	// amount: winnerAmount
	frame_dig 0 // winnerAmount: uint64
	itxn_field Amount

	// contracts/raffle/raffle.algo.ts:293
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if7_end

*if7_else:
	// contracts/raffle/raffle.algo.ts:296
	// shouldCloseTo = true
	intc 1 // 1
	frame_bury 1 // shouldCloseTo: bool

	// contracts/raffle/raffle.algo.ts:297
	// winnerAmount = this.app.address.assetBalance(this.prize.value)
	global CurrentApplicationAddress
	bytec 5 //  "prize"
	app_global_get
	asset_holding_get AssetBalance
	pop
	frame_bury 0 // winnerAmount: uint64

	// *if9_condition
	// contracts/raffle/raffle.algo.ts:298
	// this.prize.value === this.ticketAsset.value
	bytec 5 //  "prize"
	app_global_get
	bytec 2 //  "ticket_asset"
	app_global_get
	==
	bz *if9_end

	// *if9_consequent
	// contracts/raffle/raffle.algo.ts:299
	// winnerAmount -= this.ticketCount.value
	frame_dig 0 // winnerAmount: uint64
	bytec 1 //  "ticket_count"
	app_global_get
	-
	frame_bury 0 // winnerAmount: uint64

	// contracts/raffle/raffle.algo.ts:300
	// shouldCloseTo = false
	intc 0 // 0
	frame_bury 1 // shouldCloseTo: bool

*if9_end:
	// *if10_condition
	// contracts/raffle/raffle.algo.ts:303
	// this.raffleWinner.value.isOptedInToAsset(this.prize.value)
	bytec 3 //  "raffle_winner"
	app_global_get
	bytec 5 //  "prize"
	app_global_get
	asset_holding_get AssetBalance
	swap
	pop
	bz *if10_else

	// *if10_consequent
	// *if11_condition
	// contracts/raffle/raffle.algo.ts:304
	// shouldCloseTo
	frame_dig 1 // shouldCloseTo: bool
	bz *if11_else

	// *if11_consequent
	// contracts/raffle/raffle.algo.ts:305
	// sendAssetTransfer({
	//                         assetReceiver: this.raffleWinner.value,
	//                         assetCloseTo: this.raffleWinner.value,
	//                         assetAmount: winnerAmount,
	//                         xferAsset: this.prize.value,
	//                         fee: 0,
	//                     })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:306
	// assetReceiver: this.raffleWinner.value
	bytec 3 //  "raffle_winner"
	app_global_get
	itxn_field AssetReceiver

	// contracts/raffle/raffle.algo.ts:307
	// assetCloseTo: this.raffleWinner.value
	bytec 3 //  "raffle_winner"
	app_global_get
	itxn_field AssetCloseTo

	// contracts/raffle/raffle.algo.ts:308
	// assetAmount: winnerAmount
	frame_dig 0 // winnerAmount: uint64
	itxn_field AssetAmount

	// contracts/raffle/raffle.algo.ts:309
	// xferAsset: this.prize.value
	bytec 5 //  "prize"
	app_global_get
	itxn_field XferAsset

	// contracts/raffle/raffle.algo.ts:310
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if11_end

*if11_else:
	// contracts/raffle/raffle.algo.ts:313
	// sendAssetTransfer({
	//                         assetReceiver: this.raffleWinner.value,
	//                         assetAmount: winnerAmount,
	//                         xferAsset: this.prize.value,
	//                         fee: 0,
	//                     })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:314
	// assetReceiver: this.raffleWinner.value
	bytec 3 //  "raffle_winner"
	app_global_get
	itxn_field AssetReceiver

	// contracts/raffle/raffle.algo.ts:315
	// assetAmount: winnerAmount
	frame_dig 0 // winnerAmount: uint64
	itxn_field AssetAmount

	// contracts/raffle/raffle.algo.ts:316
	// xferAsset: this.prize.value
	bytec 5 //  "prize"
	app_global_get
	itxn_field XferAsset

	// contracts/raffle/raffle.algo.ts:317
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if11_end:
	b *if10_end

*if10_else:
	// contracts/raffle/raffle.algo.ts:321
	// this.arc59OptInAndSend(
	//                     this.raffleWinner.value,
	//                     this.prize.value,
	//                     winnerAmount,
	//                     shouldCloseTo
	//                 )
	frame_dig 1 // shouldCloseTo: bool
	frame_dig 0 // winnerAmount: uint64
	bytec 5 //  "prize"
	app_global_get
	bytec 3 //  "raffle_winner"
	app_global_get
	callsub arc59OptInAndSend

*if10_end:

*if7_end:
	// *if12_condition
	// contracts/raffle/raffle.algo.ts:330
	// this.ticketAsset.value.id === 0
	bytec 2 //  "ticket_asset"
	app_global_get
	intc 0 // 0
	==
	bz *if12_else

	// *if12_consequent
	// contracts/raffle/raffle.algo.ts:331
	// sendPayment({
	//                 receiver: this.seller.value,
	//                 amount: this.ticketCount.value,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:332
	// receiver: this.seller.value
	bytec 6 //  "seller"
	app_global_get
	itxn_field Receiver

	// contracts/raffle/raffle.algo.ts:333
	// amount: this.ticketCount.value
	bytec 1 //  "ticket_count"
	app_global_get
	itxn_field Amount

	// contracts/raffle/raffle.algo.ts:334
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if12_end

*if12_else:
	// *if13_condition
	// contracts/raffle/raffle.algo.ts:337
	// this.seller.value.isOptedInToAsset(this.ticketAsset.value)
	bytec 6 //  "seller"
	app_global_get
	bytec 2 //  "ticket_asset"
	app_global_get
	asset_holding_get AssetBalance
	swap
	pop
	bz *if13_else

	// *if13_consequent
	// contracts/raffle/raffle.algo.ts:338
	// sendAssetTransfer({
	//                     assetReceiver: this.seller.value,
	//                     assetCloseTo: this.seller.value,
	//                     assetAmount: this.ticketCount.value,
	//                     xferAsset: this.ticketAsset.value,
	//                     fee: 0,
	//                 })
	itxn_begin
	intc 2 //  axfer
	itxn_field TypeEnum

	// contracts/raffle/raffle.algo.ts:339
	// assetReceiver: this.seller.value
	bytec 6 //  "seller"
	app_global_get
	itxn_field AssetReceiver

	// contracts/raffle/raffle.algo.ts:340
	// assetCloseTo: this.seller.value
	bytec 6 //  "seller"
	app_global_get
	itxn_field AssetCloseTo

	// contracts/raffle/raffle.algo.ts:341
	// assetAmount: this.ticketCount.value
	bytec 1 //  "ticket_count"
	app_global_get
	itxn_field AssetAmount

	// contracts/raffle/raffle.algo.ts:342
	// xferAsset: this.ticketAsset.value
	bytec 2 //  "ticket_asset"
	app_global_get
	itxn_field XferAsset

	// contracts/raffle/raffle.algo.ts:343
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if13_end

*if13_else:
	// contracts/raffle/raffle.algo.ts:346
	// this.arc59OptInAndSend(
	//                     this.seller.value,
	//                     this.ticketAsset.value,
	//                     this.ticketCount.value,
	//                     true
	//                 )
	intc 1 // 1
	bytec 1 //  "ticket_count"
	app_global_get
	bytec 2 //  "ticket_asset"
	app_global_get
	bytec 6 //  "seller"
	app_global_get
	callsub arc59OptInAndSend

*if13_end:

*if12_end:
	// contracts/raffle/raffle.algo.ts:355
	// this.rafflePrizeClaimed.value = true
	bytec 10 //  "raffle_prize_claimed"
	intc 1 // 1
	bytec 17 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	app_global_put
	retsub

// deleteApplication()void
*abi_route_deleteApplication:
	// execute deleteApplication()void
	callsub deleteApplication
	intc 1 // 1
	return

// deleteApplication(): void
deleteApplication:
	proto 0 0

	// contracts/raffle/raffle.algo.ts:359
	// assert(this.txn.sender === this.app.creator, errs.CREATOR_ONLY)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==
	assert

	// contracts/raffle/raffle.algo.ts:360
	// assert(this.rafflePrizeClaimed.value, errs.PRIZE_NOT_CLAIMED)
	bytec 10 //  "raffle_prize_claimed"
	app_global_get
	intc 0 // 0
	getbit
	assert
	retsub

// getState()(uint64,uint64,uint64,address,uint64,uint64,uint64,uint64,uint64,address,uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64)
*abi_route_getState:
	// The ABI return prefix
	bytec 21 // 0x151f7c75

	// execute getState()(uint64,uint64,uint64,address,uint64,uint64,uint64,uint64,uint64,address,uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64)
	callsub getState
	concat
	log
	intc 1 // 1
	return

// getState(): RaffleState
getState:
	proto 0 1

	// contracts/raffle/raffle.algo.ts:364
	// return {
	//             ticketAsset: this.ticketAsset.value,
	//             startingRound: this.startingRound.value,
	//             endingRound: this.endingRound.value,
	//             seller: this.seller.value,
	//             minTickets: this.minTickets.value,
	//             maxTickets: this.maxTickets.value,
	//             entryCount: this.entryCount.value,
	//             ticketCount: this.ticketCount.value,
	//             winningTicket: this.winningTicket.value,
	//             raffleWinner: this.raffleWinner.value,
	//             prize: this.prize.value,
	//             rafflePrizeClaimed: this.rafflePrizeClaimed.value,
	//             gateID: this.gateID.value,
	//             vrfBeaconAppID: this.vrfBeaconAppID.value,
	//             vrfGetFailureCount: this.vrfGetFailureCount.value,
	//             entryID: this.entryID.value,
	//             findWinnerCursor: this.findWinnerCursor.value,
	//             findWinnerTotalCursor: this.findWinnerTotalCursor.value
	//         }
	bytec 2 //  "ticket_asset"
	app_global_get
	itob
	bytec 19 //  "starting_round"
	app_global_get
	itob
	concat
	bytec 11 //  "ending_round"
	app_global_get
	itob
	concat
	bytec 6 //  "seller"
	app_global_get
	concat
	bytec 13 //  "min_tickets"
	app_global_get
	itob
	concat
	bytec 14 //  "max_tickets"
	app_global_get
	itob
	concat
	bytec 4 //  "entry_count"
	app_global_get
	itob
	concat
	bytec 1 //  "ticket_count"
	app_global_get
	itob
	concat
	bytec 8 //  "winning_ticket"
	app_global_get
	itob
	concat
	bytec 3 //  "raffle_winner"
	app_global_get
	concat
	bytec 5 //  "prize"
	app_global_get
	itob
	concat
	bytec 17 // 0x00
	intc 0 // 0
	bytec 10 //  "raffle_prize_claimed"
	app_global_get
	intc 0 // 0
	getbit
	setbit
	concat // 12
	bytec 16 //  "gate"
	app_global_get
	itob
	concat
	bytec 18 //  "vrf_beacon_app_id"
	app_global_get
	itob
	concat
	bytec 12 //  "vrf_get_failure_count"
	app_global_get
	itob
	concat
	bytec 15 //  "entry_id"
	app_global_get
	itob
	concat
	bytec 7 //  "find_winner_cursor"
	app_global_get
	itob
	concat
	bytec 9 //  "find_winner_total_cursor"
	app_global_get
	itob
	concat
	retsub

*create_NoOp:
	pushbytes 0xf36dbd7a // method "createApplication(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x3ea11832 // method "optin(pay,uint64)void"
	pushbytes 0x8fa4a160 // method "isLive()bool"
	pushbytes 0x75eb7702 // method "enter(pay,byte[][])void"
	pushbytes 0x2f71c24c // method "enterAsa(pay,axfer,byte[][])void"
	pushbytes 0x696501de // method "raffle()void"
	pushbytes 0xb733d519 // method "findWinner()void"
	pushbytes 0x65fca98b // method "claimRafflePrize()void"
	pushbytes 0xf3c8db16 // method "getState()(uint64,uint64,uint64,address,uint64,uint64,uint64,uint64,uint64,address,uint64,bool,uint64,uint64,uint64,uint64,uint64,uint64)"
	txna ApplicationArgs 0
	match *abi_route_optin *abi_route_isLive *abi_route_enter *abi_route_enterAsa *abi_route_raffle *abi_route_findWinner *abi_route_claimRafflePrize *abi_route_getState

	// this contract does not implement the given ABI method for call NoOp
	err

*call_DeleteApplication:
	pushbytes 0x2487c32c // method "deleteApplication()void"
	txna ApplicationArgs 0
	match *abi_route_deleteApplication

	// this contract does not implement the given ABI method for call DeleteApplication
	err

// pcg64Random(state: PCG64STATE, lowerBound: uint64, upperBound: uint64, length: uint64): [PCG64STATE, uint64[]]
pcg64Random:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 7

	// utils/types/lib_pcg/pcg64.algo.ts:29
	// result: uint64[] = []
	bytec 0 // 0x
	frame_bury 0 // result: uint64[]

	// utils/types/lib_pcg/pcg64.algo.ts:33
	// newState = clone(state)
	frame_dig -1 // state: PCG64STATE
	frame_bury 3 // newState: (uint64,uint64)

	// *if14_condition
	// utils/types/lib_pcg/pcg64.algo.ts:35
	// lowerBound === 0 && upperBound === 0
	frame_dig -2 // lowerBound: uint64
	intc 0 // 0
	==
	dup
	bz *skip_and2
	frame_dig -3 // upperBound: uint64
	intc 0 // 0
	==
	&&

*skip_and2:
	bz *if14_else

	// *if14_consequent
	// utils/types/lib_pcg/pcg64.algo.ts:36
	// for (let i = 0; i < length; i = i + 1)
	intc 0 // 0
	frame_bury 4 // i: uint64

*for_1:
	// utils/types/lib_pcg/pcg64.algo.ts:36
	// i < length
	frame_dig 4 // i: uint64
	frame_dig -4 // length: uint64
	<
	bz *for_1_end

	// utils/types/lib_pcg/pcg64.algo.ts:37
	// stepResult = __pcg64Random(newState)
	frame_dig 3 // newState: (uint64,uint64)
	callsub __pcg64Random
	frame_bury 5 // stepResult: ((uint64,uint64),uint64)

	// utils/types/lib_pcg/pcg64.algo.ts:38
	// newState = stepResult[0]
	frame_dig 5 // stepResult: ((uint64,uint64),uint64)
	extract 0 16
	frame_bury 3 // newState: (uint64,uint64)

	// utils/types/lib_pcg/pcg64.algo.ts:39
	// result.push(stepResult[1])
	frame_dig 0 // result: uint64[]
	frame_dig 5 // stepResult: ((uint64,uint64),uint64)
	extract 16 8
	btoi
	itob
	concat
	frame_bury 0 // result: uint64[]

*for_1_continue:
	// utils/types/lib_pcg/pcg64.algo.ts:36
	// i = i + 1
	frame_dig 4 // i: uint64
	intc 1 // 1
	+
	frame_bury 4 // i: uint64
	b *for_1

*for_1_end:
	b *if14_end

*if14_else:
	// *if15_condition
	// utils/types/lib_pcg/pcg64.algo.ts:42
	// upperBound !== 0
	frame_dig -3 // upperBound: uint64
	intc 0 // 0
	!=
	bz *if15_else

	// *if15_consequent
	// utils/types/lib_pcg/pcg64.algo.ts:43
	// assert(upperBound > 1)
	frame_dig -3 // upperBound: uint64
	intc 1 // 1
	>
	assert

	// utils/types/lib_pcg/pcg64.algo.ts:44
	// assert(lowerBound < upperBound - 1)
	frame_dig -2 // lowerBound: uint64
	frame_dig -3 // upperBound: uint64
	intc 1 // 1
	-
	<
	assert

	// utils/types/lib_pcg/pcg64.algo.ts:46
	// absoluteBound = upperBound - lowerBound
	frame_dig -3 // upperBound: uint64
	frame_dig -2 // lowerBound: uint64
	-
	frame_bury 1 // absoluteBound: uint64
	b *if15_end

*if15_else:
	// utils/types/lib_pcg/pcg64.algo.ts:49
	// assert(lowerBound < Uint<64>('18446744073709551615'))
	frame_dig -2 // lowerBound: uint64
	intc 7 // 18446744073709551615
	<
	assert

	// utils/types/lib_pcg/pcg64.algo.ts:54
	// absoluteBound = (Uint<128>('18446744073709551616') - (lowerBound as uint128)) as uint64
	pushbytes 0x00000000000000010000000000000000
	frame_dig -2 // lowerBound: uint64
	itob
	b-
	dup
	bitlen
	pushint 64
	<=

	// (Uint<128>('18446744073709551616') - (lowerBound as uint128)) as uint64 overflowed 64 bits
	assert
	pushbytes 0xFFFFFFFFFFFFFFFF
	b&
	dup
	len
	dup
	intc 5 // 8
	-
	swap
	substring3
	btoi
	frame_bury 1 // absoluteBound: uint64

*if15_end:
	// utils/types/lib_pcg/pcg64.algo.ts:57
	// threshold = __uint64Twos(absoluteBound) % absoluteBound
	frame_dig 1 // absoluteBound: uint64
	callsub __uint64Twos
	frame_dig 1 // absoluteBound: uint64
	%
	frame_bury 2 // threshold: uint64

	// utils/types/lib_pcg/pcg64.algo.ts:59
	// for (let i = 0; i < length; i = i + 1)
	intc 0 // 0
	frame_bury 6 // i: uint64

*for_2:
	// utils/types/lib_pcg/pcg64.algo.ts:59
	// i < length
	frame_dig 6 // i: uint64
	frame_dig -4 // length: uint64
	<
	bz *for_2_end

*while_0:

*while_0_continue:
	// utils/types/lib_pcg/pcg64.algo.ts:61
	// true
	intc 1 // 1
	bz *while_0_end

	// utils/types/lib_pcg/pcg64.algo.ts:62
	// stepResult = __pcg64Random(newState)
	frame_dig 3 // newState: (uint64,uint64)
	callsub __pcg64Random
	frame_bury 7 // stepResult: ((uint64,uint64),uint64)

	// utils/types/lib_pcg/pcg64.algo.ts:63
	// newState = stepResult[0]
	frame_dig 7 // stepResult: ((uint64,uint64),uint64)
	extract 0 16
	frame_bury 3 // newState: (uint64,uint64)

	// *if16_condition
	// utils/types/lib_pcg/pcg64.algo.ts:64
	// stepResult[1] >= threshold
	frame_dig 7 // stepResult: ((uint64,uint64),uint64)
	extract 16 8
	btoi
	frame_dig 2 // threshold: uint64
	>=
	bz *if16_end

	// *if16_consequent
	// utils/types/lib_pcg/pcg64.algo.ts:65
	// result.push((stepResult[1] % absoluteBound) + lowerBound)
	frame_dig 0 // result: uint64[]
	frame_dig 7 // stepResult: ((uint64,uint64),uint64)
	extract 16 8
	btoi
	frame_dig 1 // absoluteBound: uint64
	%
	frame_dig -2 // lowerBound: uint64
	+
	itob
	concat
	frame_bury 0 // result: uint64[]
	b *while_0_end

*if16_end:
	b *while_0

*while_0_end:

*for_2_continue:
	// utils/types/lib_pcg/pcg64.algo.ts:59
	// i = i + 1
	frame_dig 6 // i: uint64
	intc 1 // 1
	+
	frame_bury 6 // i: uint64
	b *for_2

*for_2_end:

*if14_end:
	// utils/types/lib_pcg/pcg64.algo.ts:72
	// return [newState, result];
	bytec 0 //  initial head
	bytec 0 //  initial tail
	pushbytes 0x0012 // initial head offset
	frame_dig 3 // newState: (uint64,uint64)
	callsub *process_static_tuple_element
	frame_dig 0 // result: uint64[]
	dup
	len
	intc 5 // 8
	/
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 7
	retsub

// __uint64Twos(value: uint64): uint64
__uint64Twos:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// utils/types/lib_pcg/pcg32.algo.ts:6
	// addwResult = addw(~value, 1)
	frame_dig -1 // value: uint64
	~
	intc 1 // 1
	addw
	frame_bury 0 // addwResult low: uint64
	frame_bury 1 // addwResult high: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:7
	// return addwResult.low;
	frame_dig 0 // addwResult low: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// __pcg64Random(state: PCG64STATE): [PCG64STATE, uint64]
__pcg64Random:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// utils/types/lib_pcg/pcg64.algo.ts:7
	// highResult = __pcg32UnboundedRandom(state[0])
	frame_dig -1 // state: PCG64STATE
	extract 0 8
	btoi
	callsub __pcg32UnboundedRandom
	frame_bury 0 // highResult: (uint64,uint64)

	// utils/types/lib_pcg/pcg64.algo.ts:9
	// lowState = __pcg32Step(state[1], pcgSecondIncrement << (highResult[0] === 0 ? 1 : 0))
	// utils/types/lib_pcg/consts.algo.ts:5
	// Uint<64>('1442695040888963409')
	intc 8 // 1442695040888963409

	// utils/types/lib_pcg/pcg64.algo.ts:9
	// highResult[0] === 0
	frame_dig 0 // highResult: (uint64,uint64)
	extract 0 8
	btoi
	intc 0 // 0
	==
	bz *ternary2_false
	intc 1 // 1
	b *ternary2_end

*ternary2_false:
	intc 0 // 0

*ternary2_end:
	shl

	// utils/types/lib_pcg/pcg64.algo.ts:9
	// state[1]
	frame_dig -1 // state: PCG64STATE
	extract 8 8
	btoi
	callsub __pcg32Step
	frame_bury 1 // lowState: uint64

	// utils/types/lib_pcg/pcg64.algo.ts:11
	// return [[highResult[0], lowState], (highResult[1] << 32) | __pcg32Output(state[1])];
	frame_dig 0 // highResult: (uint64,uint64)
	extract 0 8
	btoi
	itob
	frame_dig 1 // lowState: uint64
	itob
	concat
	frame_dig 0 // highResult: (uint64,uint64)
	extract 8 8
	btoi
	intc 12 // 32
	shl
	frame_dig -1 // state: PCG64STATE
	extract 8 8
	btoi
	callsub __pcg32Output
	|
	itob
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// __pcg32Output(state: PCG32STATE): uint64
__pcg32Output:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// utils/types/lib_pcg/pcg32.algo.ts:23
	// xorshifted = __maskToUint32(((state >> 18) ^ state) >> 27)
	frame_dig -1 // state: PCG32STATE
	pushint 18
	shr
	frame_dig -1 // state: PCG32STATE
	^
	pushint 27
	shr
	callsub __maskToUint32
	frame_bury 0 // xorshifted: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:24
	// rot = state >> 59
	frame_dig -1 // state: PCG32STATE
	pushint 59
	shr
	frame_bury 1 // rot: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:25
	// return (xorshifted >> rot) | __maskToUint32(xorshifted << (__uint64Twos(rot) & 31));
	frame_dig 0 // xorshifted: uint64
	frame_dig 1 // rot: uint64
	shr
	frame_dig 0 // xorshifted: uint64
	frame_dig 1 // rot: uint64
	callsub __uint64Twos
	pushint 31
	&
	shl
	callsub __maskToUint32
	|

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// __maskToUint32(value: uint64): uint64
__maskToUint32:
	proto 1 1

	// utils/types/lib_pcg/pcg32.algo.ts:12
	// return value & 4294967295;
	frame_dig -1 // value: uint64
	pushint 4294967295
	&
	retsub

// __pcg32Step(state: PCG32STATE, incr: uint64): uint64
__pcg32Step:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// utils/types/lib_pcg/pcg32.algo.ts:16
	// mulwResult = mulw(state, pcgMultiplier)
	frame_dig -1 // state: PCG32STATE

	// utils/types/lib_pcg/consts.algo.ts:1
	// Uint<64>('6364136223846793005')
	pushint 6364136223846793005
	mulw
	frame_bury 0 // mulwResult low: uint64
	frame_bury 1 // mulwResult high: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:17
	// addwResult = addw(mulwResult.low, incr)
	frame_dig 0 // mulwResult low: uint64
	frame_dig -2 // incr: uint64
	addw
	frame_bury 2 // addwResult low: uint64
	frame_bury 3 // addwResult high: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:19
	// return addwResult.low;
	frame_dig 2 // addwResult low: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// __pcg32UnboundedRandom(state: PCG32STATE): [PCG32STATE, uint64]
__pcg32UnboundedRandom:
	proto 1 1

	// utils/types/lib_pcg/pcg32.algo.ts:29
	// return [__pcg32Step(state, pcgFirstIncrement), __pcg32Output(state)];
	// utils/types/lib_pcg/consts.algo.ts:3
	// Uint<64>('1442695040888963407')
	intc 9 // 1442695040888963407
	frame_dig -1 // state: PCG32STATE
	callsub __pcg32Step
	itob

	// utils/types/lib_pcg/pcg32.algo.ts:29
	// __pcg32Output(state)
	frame_dig -1 // state: PCG32STATE
	callsub __pcg32Output
	itob
	concat
	retsub

// pcg64Init(seed: bytes<16>): PCG64STATE
pcg64Init:
	proto 1 1

	// utils/types/lib_pcg/pcg64.algo.ts:15
	// assert(seed.length === 16)
	intc 6 // 16
	dup
	==
	assert

	// utils/types/lib_pcg/pcg64.algo.ts:17
	// return [
	//     __pcg32Init(extractUint64(seed, 0), pcgFirstIncrement),
	//     __pcg32Init(extractUint64(seed, 8), pcgSecondIncrement),
	//   ];
	// utils/types/lib_pcg/consts.algo.ts:3
	// Uint<64>('1442695040888963407')
	intc 9 // 1442695040888963407

	// utils/types/lib_pcg/pcg64.algo.ts:18
	// extractUint64(seed, 0)
	frame_dig -1 // seed: bytes<16>
	intc 0 // 0
	extract_uint64
	callsub __pcg32Init
	itob

	// utils/types/lib_pcg/pcg64.algo.ts:19
	// __pcg32Init(extractUint64(seed, 8), pcgSecondIncrement)
	// utils/types/lib_pcg/consts.algo.ts:5
	// Uint<64>('1442695040888963409')
	intc 8 // 1442695040888963409

	// utils/types/lib_pcg/pcg64.algo.ts:19
	// extractUint64(seed, 8)
	frame_dig -1 // seed: bytes<16>
	intc 5 // 8
	extract_uint64
	callsub __pcg32Init
	itob
	concat
	retsub

// __pcg32Init(initialState: PCG32STATE, incr: uint64): PCG32STATE
__pcg32Init:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// utils/types/lib_pcg/pcg32.algo.ts:90
	// state = __pcg32Step(0, incr)
	frame_dig -2 // incr: uint64
	intc 0 // 0
	callsub __pcg32Step
	frame_bury 0 // state: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:91
	// addwResult = addw(state, initialState)
	frame_dig 0 // state: uint64
	frame_dig -1 // initialState: PCG32STATE
	addw
	frame_bury 1 // addwResult low: uint64
	frame_bury 2 // addwResult high: uint64

	// utils/types/lib_pcg/pcg32.algo.ts:93
	// return __pcg32Step(addwResult.low, incr);
	frame_dig -2 // incr: uint64
	frame_dig 1 // addwResult low: uint64
	callsub __pcg32Step

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub