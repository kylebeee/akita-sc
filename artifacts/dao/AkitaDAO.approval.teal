#pragma version 10
intcblock 0 1 4 8 6 2 24 32 3 5 16
bytecblock 0x 0x70 0x70726f706f73616c5f6964 0x0000000000000000000000000000000000000000000000000000000000000000 0x626f6e65735f6964 0x76657273696f6e 0x737562736372697074696f6e5f736572766963655f6372656174696f6e5f666565 0x737562736372697074696f6e5f7061796d656e745f70657263656e74616765 0x737562736372697074696f6e5f747269676765725f70657263656e74616765 0x6d696e696d756d5f70726f706f73616c5f7468726573686f6c64 0x7374616b696e675f706f6f6c5f6372656174696f6e5f666565 0x6e66745f6c697374696e675f6372656174696f6e5f666565 0x6e66745f73687566666c655f6372656174696f6e5f666565 0x6d696e696d756d5f726577617264735f696d70616374 0x6d696e696d756d5f766f74655f7468726573686f6c64 0x61756374696f6e5f6372656174696f6e5f666565 0x68797065725f737761705f6f666665725f666565 0x6d6f64657261746f725f70657263656e74616765 0x7265766f636174696f6e5f61646472657373 0x736f6369616c5f72656163745f666565 0x6f6d6e6967656d5f73616c655f666565 0x736f6369616c5f706f73745f666565 0x6b7262795f70657263656e74616765 0x636f6e74656e745f706f6c696379 0x737461747573 0x0f885493 0x0a8101 0x31 0x30

// This TEAL was generated by TEALScript v0.106.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 4 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// newProposalID(): uint64
//
newProposalID:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/dao/dao.algo.ts:297
	// id = this.proposalID.value
	bytec 2 //  "proposal_id"
	app_global_get
	frame_bury 0 // id: uint64

	// contracts/dao/dao.algo.ts:298
	// this.proposalID.value += 1
	bytec 2 //  "proposal_id"
	app_global_get
	intc 1 // 1
	+
	bytec 2 //  "proposal_id"
	swap
	app_global_put

	// contracts/dao/dao.algo.ts:299
	// return id;
	frame_dig 0 // id: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// assertPluginCallAllowed(app: AppID, caller: Address): void
assertPluginCallAllowed:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/dao/dao.algo.ts:303
	// key: PluginsKey = { application: app, allowedCaller: caller }
	frame_dig -1 // app: AppID
	itob
	frame_dig -2 // caller: Address
	concat
	frame_bury 0 // key: PluginsKey

	// contracts/dao/dao.algo.ts:305
	// assert(this.plugins(key).exists, errs.PLUGIN_DOES_NOT_EXIST)
	bytec 1 //  "p"
	frame_dig 0 // key: PluginsKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/dao/dao.algo.ts:306
	// assert(this.plugins(key).value.lastValidRound >= globals.round, errs.PLUGIN_EXPIRED)
	bytec 1 //  "p"
	frame_dig 0 // key: PluginsKey
	concat
	box_get

	// box value does not exist: this.plugins(key).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	global Round
	>=
	assert

	// contracts/dao/dao.algo.ts:307
	// assert(
	//             (globals.round - this.plugins(key).value.lastCalled) >= this.plugins(key).value.cooldown,
	//             errs.PLUGIN_ON_COOLDOWN
	//         )
	global Round
	bytec 1 //  "p"
	frame_dig 0 // key: PluginsKey
	concat
	box_get

	// box value does not exist: this.plugins(key).value
	assert
	store 255 // full array
	load 255 // full array
	extract 16 8
	btoi
	-
	bytec 1 //  "p"
	frame_dig 0 // key: PluginsKey
	concat
	box_get

	// box value does not exist: this.plugins(key).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	>=
	assert
	retsub

// pluginCallAllowed(app: AppID, caller: Address): boolean
pluginCallAllowed:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/dao/dao.algo.ts:314
	// key: PluginsKey = { application: app, allowedCaller: caller }
	frame_dig -1 // app: AppID
	itob
	frame_dig -2 // caller: Address
	concat
	frame_bury 0 // key: PluginsKey

	// contracts/dao/dao.algo.ts:316
	// return (
	//             this.plugins(key).exists &&
	//             this.plugins(key).value.lastValidRound >= globals.round &&
	//             (globals.round - this.plugins(key).value.lastCalled) >= this.plugins(key).value.cooldown
	//         );
	bytec 1 //  "p"
	frame_dig 0 // key: PluginsKey
	concat
	box_len
	swap
	pop
	dup
	bz *skip_and0
	bytec 1 //  "p"
	frame_dig 0 // key: PluginsKey
	concat
	box_get

	// box value does not exist: this.plugins(key).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 8
	btoi
	global Round
	>=
	&&

*skip_and0:
	dup
	bz *skip_and1
	global Round
	bytec 1 //  "p"
	frame_dig 0 // key: PluginsKey
	concat
	box_get

	// box value does not exist: this.plugins(key).value
	assert
	store 255 // full array
	load 255 // full array
	extract 16 8
	btoi
	-
	bytec 1 //  "p"
	frame_dig 0 // key: PluginsKey
	concat
	box_get

	// box value does not exist: this.plugins(key).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	>=
	&&

*skip_and1:
	// set the subroutine return value
	frame_bury 0
	retsub

// ensuresRekeyBack(txn: Txn): boolean
ensuresRekeyBack:
	proto 1 1

	// *if0_condition
	// contracts/dao/dao.algo.ts:324
	// txn.sender === this.app.address && txn.rekeyTo === this.app.address
	frame_dig -1 // txn: Txn
	gtxns Sender
	global CurrentApplicationAddress
	==
	dup
	bz *skip_and2
	frame_dig -1 // txn: Txn
	gtxns RekeyTo
	global CurrentApplicationAddress
	==
	&&

*skip_and2:
	bz *if0_end

	// *if0_consequent
	// contracts/dao/dao.algo.ts:325
	// return true;
	intc 1 // 1
	retsub

*if0_end:
	// contracts/dao/dao.algo.ts:328
	// return (
	//             txn.typeEnum === TransactionType.ApplicationCall &&
	//             txn.applicationID === this.app &&
	//             txn.numAppArgs === 1 &&
	//             txn.onCompletion === 0 &&
	//             txn.applicationArgs[0] === method('arc58_verifyAuthAddr()void')
	//         )
	frame_dig -1 // txn: Txn
	gtxns TypeEnum
	intc 4 //  appl
	==
	dup
	bz *skip_and3
	frame_dig -1 // txn: Txn
	gtxns ApplicationID
	txna Applications 0
	==
	&&

*skip_and3:
	dup
	bz *skip_and4
	frame_dig -1 // txn: Txn
	gtxns NumAppArgs
	intc 1 // 1
	==
	&&

*skip_and4:
	dup
	bz *skip_and5
	frame_dig -1 // txn: Txn
	gtxns OnCompletion
	intc 0 // 0
	==
	&&

*skip_and5:
	dup
	bz *skip_and6
	frame_dig -1 // txn: Txn
	gtxns ApplicationArgs 0
	bytec 25 //  method "arc58_verifyAuthAddr()void"
	==
	&&

*skip_and6:
	retsub

// assertValidGroup(app: AppID, methodOffsets: uint64[], checkGlobal: boolean, checkLocal: boolean, executionKey: ExecutionKey): CallerUsed
//
// Guarantee that our txn group is valid in a single loop over all txns in the group
//
// @param app the plugin app id being validated
// @param methodOffsets the indices of the methods being used in the group
// @param checkGlobal whether to check the global caller for method restrictions
// @param checkLocal whether to check the local caller for method restrictions
// @param executionKey the execution key required for the txn group
assertValidGroup:
	proto 5 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 12

	// contracts/dao/dao.algo.ts:354
	// globalKey: PluginsKey = { application: app, allowedCaller: Address.zeroAddress }
	frame_dig -1 // app: AppID
	itob
	global ZeroAddress
	concat
	frame_bury 0 // globalKey: PluginsKey

	// contracts/dao/dao.algo.ts:355
	// key: PluginsKey = { application: app, allowedCaller: this.txn.sender }
	frame_dig -1 // app: AppID
	itob
	txn Sender
	concat
	frame_bury 1 // key: PluginsKey

	// contracts/dao/dao.algo.ts:357
	// rekeysBack = false
	intc 0 // 0
	frame_bury 2 // rekeysBack: bool

	// contracts/dao/dao.algo.ts:358
	// executionKeyRequired = this.plugins(key).value.executionKeyRequired
	bytec 1 //  "p"
	frame_dig 1 // key: PluginsKey
	concat
	box_get

	// box value does not exist: this.plugins(key).value
	assert
	store 255 // full array
	load 255 // full array
	pushint 208
	getbit
	frame_bury 3 // executionKeyRequired: bool

	// contracts/dao/dao.algo.ts:359
	// globalRestrictions = checkGlobal && this.plugins(globalKey).value.methods.length > 0
	frame_dig -3 // checkGlobal: boolean
	dup
	bz *skip_and7
	bytec 1 //  "p"
	frame_dig 0 // globalKey: PluginsKey
	concat
	box_get

	// box value does not exist: this.plugins(globalKey).value
	assert
	store 255 // full array
	intc 6 // 24
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	intc 2 //  get type length
	* // multiply by type length
	intc 5 // 2
	+ // add two for length
	extract3
	extract 2 0
	len
	intc 2 // 4
	/
	intc 0 // 0
	>
	&&

*skip_and7:
	frame_bury 4 // globalRestrictions: bool

	// contracts/dao/dao.algo.ts:360
	// localRestrictions = checkLocal && this.plugins(key).value.methods.length > 0
	frame_dig -4 // checkLocal: boolean
	dup
	bz *skip_and8
	bytec 1 //  "p"
	frame_dig 1 // key: PluginsKey
	concat
	box_get

	// box value does not exist: this.plugins(key).value
	assert
	store 255 // full array
	intc 6 // 24
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	intc 2 //  get type length
	* // multiply by type length
	intc 5 // 2
	+ // add two for length
	extract3
	extract 2 0
	len
	intc 2 // 4
	/
	intc 0 // 0
	>
	&&

*skip_and8:
	frame_bury 5 // localRestrictions: bool

	// contracts/dao/dao.algo.ts:361
	// methodIndex = 0
	intc 0 // 0
	frame_bury 6 // methodIndex: uint64

	// contracts/dao/dao.algo.ts:362
	// hash: string = ''
	bytec 0 //  ""
	frame_bury 7 // hash: string

	// contracts/dao/dao.algo.ts:363
	// callerUsed: CallerUsed = {
	//             global: checkGlobal && !globalRestrictions,
	//             local: checkLocal && !localRestrictions,
	//         }
	pushbytes 0x00
	intc 0 // 0
	frame_dig -3 // checkGlobal: boolean
	dup
	bz *skip_and9
	frame_dig 4 // globalRestrictions: bool
	!
	&&

*skip_and9:
	setbit
	intc 1 // 1
	frame_dig -4 // checkLocal: boolean
	dup
	bz *skip_and10
	frame_dig 5 // localRestrictions: bool
	!
	&&

*skip_and10:
	setbit
	frame_bury 8 // callerUsed: CallerUsed

	// contracts/dao/dao.algo.ts:368
	// for (let i = (this.txn.groupIndex + 1); i < this.txnGroup.length; i += 1)
	txn GroupIndex
	intc 1 // 1
	+
	frame_bury 9 // i: uint64

*for_0:
	// contracts/dao/dao.algo.ts:368
	// i < this.txnGroup.length
	frame_dig 9 // i: uint64
	global GroupSize
	<
	bz *for_0_end

	// contracts/dao/dao.algo.ts:369
	// txn = this.txnGroup[i]
	frame_dig 9 // i: uint64
	frame_bury 10 // txn: txn

	// *if1_condition
	// contracts/dao/dao.algo.ts:371
	// this.ensuresRekeyBack(txn)
	frame_dig 10 // txn: txn
	callsub ensuresRekeyBack
	bz *if1_end

	// *if1_consequent
	// contracts/dao/dao.algo.ts:372
	// rekeysBack = true
	intc 1 // 1
	frame_bury 2 // rekeysBack: bool

*if1_end:
	// *if2_condition
	// contracts/dao/dao.algo.ts:377
	// (!globalRestrictions && !localRestrictions) || this.shouldSkipMethodCheck(txn, app)
	frame_dig 4 // globalRestrictions: bool
	!
	dup
	bz *skip_and11
	frame_dig 5 // localRestrictions: bool
	!
	&&

*skip_and11:
	dup
	bnz *skip_or0
	frame_dig -1 // app: AppID
	frame_dig 10 // txn: txn
	callsub shouldSkipMethodCheck
	||

*skip_or0:
	bz *if2_end

	// *if2_consequent
	b *for_0_continue

*if2_end:
	// contracts/dao/dao.algo.ts:381
	// globalValid = (
	//                 checkGlobal && (
	//                     !globalRestrictions
	//                     || (
	//                         methodIndex < methodOffsets.length
	//                         && this.methodCallAllowed(txn, app, Address.zeroAddress, methodOffsets[methodIndex])
	//                     )
	//                 )
	//             )
	frame_dig -3 // checkGlobal: boolean
	dup
	bz *skip_and12
	frame_dig 4 // globalRestrictions: bool
	!
	dup
	bnz *skip_or1
	frame_dig 6 // methodIndex: uint64
	frame_dig -2 // methodOffsets: uint64[]
	len
	intc 3 // 8
	/
	<
	dup
	bz *skip_and13
	frame_dig -2 // methodOffsets: uint64[]
	store 255 // full array
	intc 0 //  initial offset
	frame_dig 6 // methodIndex: uint64
	intc 3 // 8
	* // acc * typeLength
	+
	load 255 // full array
	swap
	intc 3 // 8
	extract3
	btoi
	global ZeroAddress
	frame_dig -1 // app: AppID
	frame_dig 10 // txn: txn
	callsub methodCallAllowed
	&&

*skip_and13:
	||

*skip_or1:
	&&

*skip_and12:
	frame_bury 11 // globalValid: bool

	// contracts/dao/dao.algo.ts:391
	// localValid = (
	//                 checkLocal && (
	//                     !localRestrictions
	//                     || (
	//                         methodIndex < methodOffsets.length
	//                         && this.methodCallAllowed(txn, app, this.txn.sender, methodOffsets[methodIndex])
	//                     )
	//                 )
	//             )
	frame_dig -4 // checkLocal: boolean
	dup
	bz *skip_and14
	frame_dig 5 // localRestrictions: bool
	!
	dup
	bnz *skip_or2
	frame_dig 6 // methodIndex: uint64
	frame_dig -2 // methodOffsets: uint64[]
	len
	intc 3 // 8
	/
	<
	dup
	bz *skip_and15
	frame_dig -2 // methodOffsets: uint64[]
	store 255 // full array
	intc 0 //  initial offset
	frame_dig 6 // methodIndex: uint64
	intc 3 // 8
	* // acc * typeLength
	+
	load 255 // full array
	swap
	intc 3 // 8
	extract3
	btoi
	txn Sender
	frame_dig -1 // app: AppID
	frame_dig 10 // txn: txn
	callsub methodCallAllowed
	&&

*skip_and15:
	||

*skip_or2:
	&&

*skip_and14:
	frame_bury 12 // localValid: bool

	// contracts/dao/dao.algo.ts:401
	// assert(globalValid || localValid, errs.METHOD_NOT_ALLOWED)
	frame_dig 11 // globalValid: bool
	dup
	bnz *skip_or3
	frame_dig 12 // localValid: bool
	||

*skip_or3:
	assert

	// *if3_condition
	// contracts/dao/dao.algo.ts:407
	// globalValid
	frame_dig 11 // globalValid: bool
	bz *if3_elseif1_condition

	// *if3_consequent
	// contracts/dao/dao.algo.ts:408
	// callerUsed.global = true
	frame_dig 8 // callerUsed: CallerUsed
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	intc 1 // 1
	setbit
	frame_bury 8 // callerUsed: CallerUsed
	b *if3_end

*if3_elseif1_condition:
	// contracts/dao/dao.algo.ts:409
	// localValid
	frame_dig 12 // localValid: bool
	bz *if3_end

	// *if3_elseif1_consequent
	// contracts/dao/dao.algo.ts:410
	// callerUsed.local = true
	frame_dig 8 // callerUsed: CallerUsed
	store 255 // full array
	load 255 // full array
	intc 1 // 1
	dup
	setbit
	frame_bury 8 // callerUsed: CallerUsed

*if3_end:
	// contracts/dao/dao.algo.ts:413
	// methodIndex += 1
	frame_dig 6 // methodIndex: uint64
	intc 1 // 1
	+
	frame_bury 6 // methodIndex: uint64

	// *if4_condition
	// contracts/dao/dao.algo.ts:417
	// !rekeysBack && executionKeyRequired
	frame_dig 2 // rekeysBack: bool
	!
	dup
	bz *skip_and16
	frame_dig 3 // executionKeyRequired: bool
	&&

*skip_and16:
	bz *if4_end

	// *if4_consequent
	// *if5_condition
	// contracts/dao/dao.algo.ts:418
	// globals.opcodeBudget < 50
	global OpcodeBudget
	pushint 50
	<
	bz *if5_end

	// *if5_consequent
	// contracts/dao/dao.algo.ts:419
	// increaseOpcodeBudget()
	itxn_begin
	intc 4 //  appl
	itxn_field TypeEnum
	intc 0 // 0
	itxn_field Fee
	bytec 26 //  #pragma version 10; int 1
	dup
	itxn_field ApprovalProgram
	itxn_field ClearStateProgram
	intc 9 //  DeleteApplication
	itxn_field OnCompletion
	itxn_submit

*if5_end:
	// contracts/dao/dao.algo.ts:421
	// hash = this.txnHash(txn, hash)
	frame_dig 7 // hash: string
	frame_dig 10 // txn: txn
	callsub txnHash
	frame_bury 7 // hash: string

*if4_end:

*for_0_continue:
	// contracts/dao/dao.algo.ts:368
	// i += 1
	frame_dig 9 // i: uint64
	intc 1 // 1
	+
	frame_bury 9 // i: uint64
	b *for_0

*for_0_end:
	// *if6_condition
	// contracts/dao/dao.algo.ts:425
	// executionKeyRequired
	frame_dig 3 // executionKeyRequired: bool
	bz *if6_end

	// *if6_consequent
	// contracts/dao/dao.algo.ts:426
	// assert(executionKey === (hash as bytes32), errs.INVALID_EXECUTION_KEY)
	frame_dig -5 // executionKey: ExecutionKey
	frame_dig 7 // hash: string
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	bytec 0 // 0x
	b==
	assert
	extract 0 32
	==
	assert

*if6_end:
	// contracts/dao/dao.algo.ts:429
	// assert(rekeysBack, errs.DOES_NOT_REKEY_BACK)
	frame_dig 2 // rekeysBack: bool
	assert

	// contracts/dao/dao.algo.ts:431
	// return callerUsed;
	frame_dig 8 // callerUsed: CallerUsed

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 12
	retsub

// shouldSkipMethodCheck(txn: Txn, app: AppID): boolean
shouldSkipMethodCheck:
	proto 2 1

	// *if7_condition
	// contracts/dao/dao.algo.ts:437
	// txn.typeEnum !== TransactionType.ApplicationCall ||
	//             // ignore calls to other applications
	//             (txn.applicationID !== app && txn.applicationID !== this.app) ||
	//             // ignore rekey back assert app call
	//             this.ensuresRekeyBack(txn)
	frame_dig -1 // txn: Txn
	gtxns TypeEnum
	intc 4 //  appl
	!=
	dup
	bnz *skip_or4
	frame_dig -1 // txn: Txn
	gtxns ApplicationID
	frame_dig -2 // app: AppID
	!=
	dup
	bz *skip_and17
	frame_dig -1 // txn: Txn
	gtxns ApplicationID
	txna Applications 0
	!=
	&&

*skip_and17:
	||

*skip_or4:
	dup
	bnz *skip_or5
	frame_dig -1 // txn: Txn
	callsub ensuresRekeyBack
	||

*skip_or5:
	bz *if7_end

	// *if7_consequent
	// contracts/dao/dao.algo.ts:443
	// return true;
	intc 1 // 1
	retsub

*if7_end:
	// contracts/dao/dao.algo.ts:446
	// return false;
	intc 0 // 0
	retsub

// methodCallAllowed(txn: Txn, app: AppID, caller: Address, offset: uint64): boolean
//
// Checks if the method call is allowed
//
// @param txn the transaction being validated
// @param app the plugin app id being validated
// @param caller the address that triggered the plugin or global address
// @returns whether the method call is allowed
methodCallAllowed:
	proto 4 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/dao/dao.algo.ts:460
	// assert(txn.numAppArgs > 0, errs.NO_METHOD_SIGNATURE)
	frame_dig -1 // txn: Txn
	gtxns NumAppArgs
	intc 0 // 0
	>
	assert

	// contracts/dao/dao.algo.ts:461
	// assert(len(txn.applicationArgs[0]) === 4, errs.INVALID_METHOD_SIGNATURE_LENGTH)
	frame_dig -1 // txn: Txn
	gtxns ApplicationArgs 0
	len
	intc 2 // 4
	==
	assert

	// contracts/dao/dao.algo.ts:463
	// key: PluginsKey = {
	//             application: app,
	//             allowedCaller: caller,
	//         }
	frame_dig -2 // app: AppID
	itob
	frame_dig -3 // caller: Address
	concat
	frame_bury 0 // key: PluginsKey

	// contracts/dao/dao.algo.ts:468
	// methods = this.plugins(key).value.methods
	bytec 1 //  "p"
	frame_dig 0 // key: PluginsKey
	concat
	frame_bury 1 // storage key//methods
	frame_dig -4 // offset: uint64
	frame_bury 2 // accessor: accessor//0//allowedMethod

	// *if8_condition
	// contracts/dao/dao.algo.ts:471
	// allowedMethod === txn.applicationArgs[0] as bytes<4>
	frame_dig 1 // storage key//methods
	box_get

	// box value does not exist: this.plugins(key).value
	assert
	store 255 // full array
	load 255 // full array
	intc 6 // 24
	extract_uint16
	frame_dig 2 // saved accessor: accessor//0//allowedMethod
	intc 2 // 4
	* // acc * typeLength
	+
	load 255 // full array
	swap
	intc 2 // 4
	extract3
	frame_dig -1 // txn: Txn
	gtxns ApplicationArgs 0
	pushbytes 0x00000000
	concat
	dup
	extract 4 0
	bytec 0 // 0x
	b==
	assert
	extract 0 4
	==
	bz *if8_end

	// *if8_consequent
	// contracts/dao/dao.algo.ts:472
	// return false;
	intc 0 // 0
	b *methodCallAllowed*return

*if8_end:
	// contracts/dao/dao.algo.ts:475
	// return true;
	intc 1 // 1

*methodCallAllowed*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// txnHash(txn: Txn, hash: string): bytes32
txnHash:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 6

	// contracts/dao/dao.algo.ts:479
	// common = (
	//             hash
	//             + txn.sender
	//             + itob(txn.typeEnum)
	//             + txn.note
	//             + txn.rekeyTo
	//             + itob(txn.fee)
	//         )
	frame_dig -2 // hash: string
	frame_dig -1 // txn: Txn
	gtxns Sender
	concat
	frame_dig -1 // txn: Txn
	gtxns TypeEnum
	itob
	concat
	frame_dig -1 // txn: Txn
	gtxns Note
	concat
	frame_dig -1 // txn: Txn
	gtxns RekeyTo
	concat
	frame_dig -1 // txn: Txn
	gtxns Fee
	itob
	concat
	frame_bury 0 // common: byte[]

	// *if9_condition
	// contracts/dao/dao.algo.ts:488
	// txn.typeEnum === TransactionType.Payment
	frame_dig -1 // txn: Txn
	gtxns TypeEnum
	intc 1 //  pay
	==
	bz *if9_elseif1_condition

	// *if9_consequent
	// contracts/dao/dao.algo.ts:489
	// return sha256(
	//                 common
	//                 + txn.receiver
	//                 + itob(txn.amount)
	//                 + txn.closeRemainderTo
	//             );
	frame_dig 0 // common: byte[]
	frame_dig -1 // txn: Txn
	gtxns Receiver
	concat
	frame_dig -1 // txn: Txn
	gtxns Amount
	itob
	concat
	frame_dig -1 // txn: Txn
	gtxns CloseRemainderTo
	concat
	sha256
	b *txnHash*return
	b *if9_end

*if9_elseif1_condition:
	// contracts/dao/dao.algo.ts:495
	// txn.typeEnum === TransactionType.KeyRegistration
	frame_dig -1 // txn: Txn
	gtxns TypeEnum
	intc 5 //  keyreg
	==
	bz *if9_elseif2_condition

	// *if9_elseif1_consequent
	// contracts/dao/dao.algo.ts:496
	// assert(false, errs.KEY_REGISTRATION_NOT_SUPPORTED)
	intc 0 // 0
	assert

	// contracts/dao/dao.algo.ts:497
	// return hash as bytes32;
	frame_dig -2 // hash: string
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	bytec 0 // 0x
	b==
	assert
	extract 0 32
	b *txnHash*return
	b *if9_end

*if9_elseif2_condition:
	// contracts/dao/dao.algo.ts:508
	// txn.typeEnum === TransactionType.AssetConfig
	frame_dig -1 // txn: Txn
	gtxns TypeEnum
	intc 8 //  acfg
	==
	bz *if9_elseif3_condition

	// *if9_elseif2_consequent
	// contracts/dao/dao.algo.ts:509
	// assert(txn.configAsset.metadataHash.length <= 32, errs.METADATA_HASH_TOO_LONG)
	frame_dig -1 // txn: Txn
	gtxns ConfigAsset
	asset_params_get AssetMetadataHash
	pop
	len
	intc 7 // 32
	<=
	assert

	// contracts/dao/dao.algo.ts:513
	// return sha256(
	//                 common
	//                 + itob(txn.configAsset.id)
	//                 + itob(txn.configAsset.total)
	//                 + itob(txn.configAsset.decimals)
	//                 + (txn.configAsset.defaultFrozen ? '1' : '0')
	//                 + txn.configAsset.unitName
	//                 + txn.configAsset.name
	//                 + txn.configAsset.metadataHash
	//                 + txn.configAsset.manager
	//                 + txn.configAsset.reserve
	//                 + txn.configAsset.freeze
	//                 + txn.configAsset.clawback
	//             );
	frame_dig 0 // common: byte[]
	frame_dig -1 // txn: Txn
	gtxns ConfigAsset
	itob
	concat
	frame_dig -1 // txn: Txn
	gtxns ConfigAsset
	asset_params_get AssetTotal
	pop
	itob
	concat
	frame_dig -1 // txn: Txn
	gtxns ConfigAsset
	asset_params_get AssetDecimals
	pop
	itob
	concat
	frame_dig -1 // txn: Txn
	gtxns ConfigAsset
	asset_params_get AssetDefaultFrozen
	pop
	bz *ternary255_false
	bytec 27 //  "1"
	b *ternary255_end

*ternary255_false:
	bytec 28 //  "0"

*ternary255_end:
	concat
	frame_dig -1 // txn: Txn
	gtxns ConfigAsset
	asset_params_get AssetUnitName
	pop
	concat
	frame_dig -1 // txn: Txn
	gtxns ConfigAsset
	asset_params_get AssetName
	pop
	concat
	frame_dig -1 // txn: Txn
	gtxns ConfigAsset
	asset_params_get AssetMetadataHash
	pop
	concat
	frame_dig -1 // txn: Txn
	gtxns ConfigAsset
	asset_params_get AssetManager
	pop
	concat
	frame_dig -1 // txn: Txn
	gtxns ConfigAsset
	asset_params_get AssetReserve
	pop
	concat
	frame_dig -1 // txn: Txn
	gtxns ConfigAsset
	asset_params_get AssetFreeze
	pop
	concat
	frame_dig -1 // txn: Txn
	gtxns ConfigAsset
	asset_params_get AssetClawback
	pop
	concat
	sha256
	b *txnHash*return
	b *if9_end

*if9_elseif3_condition:
	// contracts/dao/dao.algo.ts:527
	// txn.typeEnum === TransactionType.AssetTransfer
	frame_dig -1 // txn: Txn
	gtxns TypeEnum
	intc 2 //  axfer
	==
	bz *if9_elseif4_condition

	// *if9_elseif3_consequent
	// contracts/dao/dao.algo.ts:528
	// return sha256(
	//                 common
	//                 + itob(txn.xferAsset)
	//                 + itob(txn.assetAmount)
	//                 + txn.assetSender
	//                 + txn.assetReceiver
	//                 + txn.assetCloseTo
	//             );
	frame_dig 0 // common: byte[]
	frame_dig -1 // txn: Txn
	gtxns XferAsset
	itob
	concat
	frame_dig -1 // txn: Txn
	gtxns AssetAmount
	itob
	concat
	frame_dig -1 // txn: Txn
	gtxns AssetSender
	concat
	frame_dig -1 // txn: Txn
	gtxns AssetReceiver
	concat
	frame_dig -1 // txn: Txn
	gtxns AssetCloseTo
	concat
	sha256
	b *txnHash*return
	b *if9_end

*if9_elseif4_condition:
	// contracts/dao/dao.algo.ts:536
	// txn.typeEnum === TransactionType.AssetFreeze
	frame_dig -1 // txn: Txn
	gtxns TypeEnum
	intc 9 //  afrz
	==
	bz *if9_elseif5_condition

	// *if9_elseif4_consequent
	// contracts/dao/dao.algo.ts:537
	// return sha256(
	//                 common
	//                 + txn.freezeAssetAccount
	//                 + itob(txn.freezeAsset)
	//                 + (txn.freezeAssetFrozen ? '1' : '0')
	//             );
	frame_dig 0 // common: byte[]
	frame_dig -1 // txn: Txn
	gtxns FreezeAssetAccount
	concat
	frame_dig -1 // txn: Txn
	gtxns FreezeAsset
	itob
	concat
	frame_dig -1 // txn: Txn
	gtxns FreezeAssetFrozen
	bz *ternary257_false
	bytec 27 //  "1"
	b *ternary257_end

*ternary257_false:
	bytec 28 //  "0"

*ternary257_end:
	concat
	sha256
	b *txnHash*return
	b *if9_end

*if9_elseif5_condition:
	// contracts/dao/dao.algo.ts:543
	// txn.typeEnum === TransactionType.ApplicationCall
	frame_dig -1 // txn: Txn
	gtxns TypeEnum
	intc 4 //  appl
	==
	bz *if9_else

	// *if9_elseif5_consequent
	// contracts/dao/dao.algo.ts:545
	// max = 0
	intc 0 // 0
	frame_bury 1 // max: uint64

	// contracts/dao/dao.algo.ts:546
	// accountHash = ''
	bytec 0 //  ""
	frame_bury 2 // accountHash: byte[]

	// contracts/dao/dao.algo.ts:547
	// appArgHash = ''
	bytec 0 //  ""
	frame_bury 3 // appArgHash: byte[]

	// contracts/dao/dao.algo.ts:548
	// assetHash = ''
	bytec 0 //  ""
	frame_bury 4 // assetHash: byte[]

	// contracts/dao/dao.algo.ts:549
	// applicationHash = ''
	bytec 0 //  ""
	frame_bury 5 // applicationHash: byte[]

	// *if10_condition
	// contracts/dao/dao.algo.ts:551
	// txn.numAccounts > max
	frame_dig -1 // txn: Txn
	gtxns NumAccounts
	frame_dig 1 // max: uint64
	>
	bz *if10_end

	// *if10_consequent
	// contracts/dao/dao.algo.ts:552
	// max = txn.numAccounts
	frame_dig -1 // txn: Txn
	gtxns NumAccounts
	frame_bury 1 // max: uint64

*if10_end:
	// *if11_condition
	// contracts/dao/dao.algo.ts:555
	// txn.numAppArgs > max
	frame_dig -1 // txn: Txn
	gtxns NumAppArgs
	frame_dig 1 // max: uint64
	>
	bz *if11_end

	// *if11_consequent
	// contracts/dao/dao.algo.ts:556
	// max = txn.numAppArgs
	frame_dig -1 // txn: Txn
	gtxns NumAppArgs
	frame_bury 1 // max: uint64

*if11_end:
	// *if12_condition
	// contracts/dao/dao.algo.ts:559
	// txn.numAssets > max
	frame_dig -1 // txn: Txn
	gtxns NumAssets
	frame_dig 1 // max: uint64
	>
	bz *if12_end

	// *if12_consequent
	// contracts/dao/dao.algo.ts:560
	// max = txn.numAssets
	frame_dig -1 // txn: Txn
	gtxns NumAssets
	frame_bury 1 // max: uint64

*if12_end:
	// *if13_condition
	// contracts/dao/dao.algo.ts:564
	// txn.numApplications > max
	frame_dig -1 // txn: Txn
	gtxns NumApplications
	frame_dig 1 // max: uint64
	>
	bz *if13_end

	// *if13_consequent
	// contracts/dao/dao.algo.ts:566
	// max = txn.numApplications
	frame_dig -1 // txn: Txn
	gtxns NumApplications
	frame_bury 1 // max: uint64

*if13_end:
	// contracts/dao/dao.algo.ts:569
	// for (let i = 0; i < max; i += 1)
	intc 0 // 0
	frame_bury 6 // i: uint64

*for_1:
	// contracts/dao/dao.algo.ts:569
	// i < max
	frame_dig 6 // i: uint64
	frame_dig 1 // max: uint64
	<
	bz *for_1_end

	// *if14_condition
	// contracts/dao/dao.algo.ts:570
	// txn.numAccounts > i
	frame_dig -1 // txn: Txn
	gtxns NumAccounts
	frame_dig 6 // i: uint64
	>
	bz *if14_end

	// *if14_consequent
	// contracts/dao/dao.algo.ts:571
	// accountHash = accountHash + txn.accounts[i]
	frame_dig 2 // accountHash: byte[]
	frame_dig -1 // txn: Txn
	frame_dig 6 // i: uint64
	gtxnsas Accounts
	concat
	frame_bury 2 // accountHash: byte[]

*if14_end:
	// *if15_condition
	// contracts/dao/dao.algo.ts:574
	// txn.numAppArgs > i
	frame_dig -1 // txn: Txn
	gtxns NumAppArgs
	frame_dig 6 // i: uint64
	>
	bz *if15_end

	// *if15_consequent
	// contracts/dao/dao.algo.ts:575
	// appArgHash = appArgHash + txn.applicationArgs[i]
	frame_dig 3 // appArgHash: byte[]
	frame_dig -1 // txn: Txn
	frame_dig 6 // i: uint64
	gtxnsas ApplicationArgs
	concat
	frame_bury 3 // appArgHash: byte[]

*if15_end:
	// *if16_condition
	// contracts/dao/dao.algo.ts:578
	// txn.numAssets > i
	frame_dig -1 // txn: Txn
	gtxns NumAssets
	frame_dig 6 // i: uint64
	>
	bz *if16_end

	// *if16_consequent
	// contracts/dao/dao.algo.ts:579
	// assetHash = assetHash + itob(txn.assets[i])
	frame_dig 4 // assetHash: byte[]
	frame_dig -1 // txn: Txn
	frame_dig 6 // i: uint64
	gtxnsas Assets
	itob
	concat
	frame_bury 4 // assetHash: byte[]

*if16_end:
	// *if17_condition
	// contracts/dao/dao.algo.ts:583
	// txn.numApplications > i
	frame_dig -1 // txn: Txn
	gtxns NumApplications
	frame_dig 6 // i: uint64
	>
	bz *if17_end

	// *if17_consequent
	// contracts/dao/dao.algo.ts:584
	// applicationHash = applicationHash + itob(txn.applications[i])
	frame_dig 5 // applicationHash: byte[]
	frame_dig -1 // txn: Txn
	frame_dig 6 // i: uint64
	gtxnsas Applications
	itob
	concat
	frame_bury 5 // applicationHash: byte[]

*if17_end:

*for_1_continue:
	// contracts/dao/dao.algo.ts:569
	// i += 1
	frame_dig 6 // i: uint64
	intc 1 // 1
	+
	frame_bury 6 // i: uint64
	b *for_1

*for_1_end:
	// *if18_condition
	// contracts/dao/dao.algo.ts:588
	// accountHash.length > 0
	frame_dig 2 // accountHash: byte[]
	len
	intc 0 // 0
	>
	bz *if18_end

	// *if18_consequent
	// contracts/dao/dao.algo.ts:589
	// accountHash = sha256(accountHash)
	frame_dig 2 // accountHash: byte[]
	sha256
	frame_bury 2 // accountHash: byte[]

*if18_end:
	// *if19_condition
	// contracts/dao/dao.algo.ts:592
	// appArgHash.length > 0
	frame_dig 3 // appArgHash: byte[]
	len
	intc 0 // 0
	>
	bz *if19_end

	// *if19_consequent
	// contracts/dao/dao.algo.ts:593
	// appArgHash = sha256(appArgHash)
	frame_dig 3 // appArgHash: byte[]
	sha256
	frame_bury 3 // appArgHash: byte[]

*if19_end:
	// *if20_condition
	// contracts/dao/dao.algo.ts:596
	// assetHash.length > 0
	frame_dig 4 // assetHash: byte[]
	len
	intc 0 // 0
	>
	bz *if20_end

	// *if20_consequent
	// contracts/dao/dao.algo.ts:597
	// assetHash = sha256(assetHash)
	frame_dig 4 // assetHash: byte[]
	sha256
	frame_bury 4 // assetHash: byte[]

*if20_end:
	// *if21_condition
	// contracts/dao/dao.algo.ts:600
	// applicationHash.length > 0
	frame_dig 5 // applicationHash: byte[]
	len
	intc 0 // 0
	>
	bz *if21_end

	// *if21_consequent
	// contracts/dao/dao.algo.ts:601
	// applicationHash = sha256(applicationHash)
	frame_dig 5 // applicationHash: byte[]
	sha256
	frame_bury 5 // applicationHash: byte[]

*if21_end:
	// contracts/dao/dao.algo.ts:604
	// return sha256(
	//                 common
	//                 + itob(txn.applicationID)
	//                 + itob(txn.onCompletion)
	//                 + txn.approvalProgram
	//                 + txn.clearStateProgram
	//                 + accountHash
	//                 + appArgHash
	//                 + assetHash
	//                 + applicationHash
	//                 + itob(txn.globalNumUint)
	//                 + itob(txn.globalNumByteSlice)
	//                 + itob(txn.localNumUint)
	//                 + itob(txn.localNumByteSlice)
	//                 + itob(txn.extraProgramPages)
	//             );
	frame_dig 0 // common: byte[]
	frame_dig -1 // txn: Txn
	gtxns ApplicationID
	itob
	concat
	frame_dig -1 // txn: Txn
	gtxns OnCompletion
	itob
	concat
	frame_dig -1 // txn: Txn
	gtxns ApprovalProgram
	concat
	frame_dig -1 // txn: Txn
	gtxns ClearStateProgram
	concat
	frame_dig 2 // accountHash: byte[]
	concat
	frame_dig 3 // appArgHash: byte[]
	concat
	frame_dig 4 // assetHash: byte[]
	concat
	frame_dig 5 // applicationHash: byte[]
	concat
	frame_dig -1 // txn: Txn
	gtxns GlobalNumUint
	itob
	concat
	frame_dig -1 // txn: Txn
	gtxns GlobalNumByteSlice
	itob
	concat
	frame_dig -1 // txn: Txn
	gtxns LocalNumUint
	itob
	concat
	frame_dig -1 // txn: Txn
	gtxns LocalNumByteSlice
	itob
	concat
	frame_dig -1 // txn: Txn
	gtxns ExtraProgramPages
	itob
	concat
	sha256
	b *txnHash*return
	b *if9_end

*if9_else:
	// contracts/dao/dao.algo.ts:621
	// assert(false, errs.UNKNOWN_TRANSACTION_TYPE)
	intc 0 // 0
	assert

	// contracts/dao/dao.algo.ts:622
	// return hash as bytes32;
	frame_dig -2 // hash: string
	bytec 3 // 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	bytec 0 // 0x
	b==
	assert
	extract 0 32
	b *txnHash*return

*if9_end:

*txnHash*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 6
	retsub

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	intc 1 // 1
	return

// createApplication(): void
createApplication:
	proto 0 0
	retsub

// init(string,byte[59],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),uint64,uint64,address)void
*abi_route_init:
	// revocationAddress: address
	txna ApplicationArgs 7
	dup
	len
	intc 7 // 32
	==

	// argument 0 (revocationAddress) for init must be a address
	assert

	// minimumVoteThreshold: uint64
	txna ApplicationArgs 6
	btoi

	// minimumProposalThreshold: uint64
	txna ApplicationArgs 5
	btoi

	// fees: (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	txna ApplicationArgs 4
	dup
	len
	pushint 104
	==

	// argument 3 (fees) for init must be a (uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)
	assert

	// minimumRewardsImpact: uint64
	txna ApplicationArgs 3
	btoi

	// contentPolicy: byte[59]
	txna ApplicationArgs 2
	dup
	len
	pushint 59
	==

	// argument 5 (contentPolicy) for init must be a byte[59]
	assert

	// version: string
	txna ApplicationArgs 1
	extract 2 0

	// execute init(string,byte[59],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),uint64,uint64,address)void
	callsub init
	intc 1 // 1
	return

// init(version: string, contentPolicy: bytes<59>, minimumRewardsImpact: uint64, fees: DAOInitFeeArgs, minimumProposalThreshold: uint64, minimumVoteThreshold: uint64, revocationAddress: Address): void
init:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/dao/dao.algo.ts:643
	// assert(this.version.value.length === 0, errs.ALREADY_INITIALIZED)
	bytec 5 //  "version"
	app_global_get
	extract 2 0
	len
	intc 0 // 0
	==
	assert

	// contracts/dao/dao.algo.ts:644
	// assert(version !== '', errs.VERSION_CANNOT_BE_EMPTY)
	frame_dig -1 // version: string
	bytec 0 //  ""
	!=
	assert

	// contracts/dao/dao.algo.ts:646
	// bones = sendAssetCreation({
	//             configAssetName: 'Bones',
	//             configAssetUnitName: 'BONES',
	//             configAssetTotal: 100_000_000_000_000,
	//             configAssetDecimals: 2,
	//             configAssetManager: this.app.address,
	//             configAssetReserve: this.app.address,
	//             configAssetFreeze: globals.zeroAddress,
	//             configAssetClawback: globals.zeroAddress,
	//             configAssetDefaultFrozen: 0,
	//             configAssetURL: '',
	//             configAssetMetadataHash: '',
	//         })
	itxn_begin
	intc 8 //  acfg
	itxn_field TypeEnum

	// contracts/dao/dao.algo.ts:647
	// configAssetName: 'Bones'
	pushbytes 0x426f6e6573 // "Bones"
	itxn_field ConfigAssetName

	// contracts/dao/dao.algo.ts:648
	// configAssetUnitName: 'BONES'
	pushbytes 0x424f4e4553 // "BONES"
	itxn_field ConfigAssetUnitName

	// contracts/dao/dao.algo.ts:649
	// configAssetTotal: 100_000_000_000_000
	pushint 100_000_000_000_000
	itxn_field ConfigAssetTotal

	// contracts/dao/dao.algo.ts:650
	// configAssetDecimals: 2
	intc 5 // 2
	itxn_field ConfigAssetDecimals

	// contracts/dao/dao.algo.ts:651
	// configAssetManager: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetManager

	// contracts/dao/dao.algo.ts:652
	// configAssetReserve: this.app.address
	global CurrentApplicationAddress
	itxn_field ConfigAssetReserve

	// contracts/dao/dao.algo.ts:653
	// configAssetFreeze: globals.zeroAddress
	global ZeroAddress
	itxn_field ConfigAssetFreeze

	// contracts/dao/dao.algo.ts:654
	// configAssetClawback: globals.zeroAddress
	global ZeroAddress
	itxn_field ConfigAssetClawback

	// contracts/dao/dao.algo.ts:655
	// configAssetDefaultFrozen: 0
	intc 0 // 0
	itxn_field ConfigAssetDefaultFrozen

	// contracts/dao/dao.algo.ts:656
	// configAssetURL: ''
	bytec 0 //  ""
	itxn_field ConfigAssetURL

	// contracts/dao/dao.algo.ts:657
	// configAssetMetadataHash: ''
	bytec 0 //  ""
	itxn_field ConfigAssetMetadataHash

	// Fee field not set, defaulting to 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn CreatedAssetID
	frame_bury 0 // bones: uint64

	// contracts/dao/dao.algo.ts:660
	// this.status.value = STATUS_INIT
	bytec 24 //  "status"
	intc 0 // 0
	app_global_put

	// contracts/dao/dao.algo.ts:661
	// this.version.value = version
	bytec 5 //  "version"
	frame_dig -1 // version: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	app_global_put

	// contracts/dao/dao.algo.ts:662
	// this.contentPolicy.value = contentPolicy
	bytec 23 //  "content_policy"
	frame_dig -2 // contentPolicy: bytes<59>
	app_global_put

	// contracts/dao/dao.algo.ts:663
	// this.minimumRewardsImpact.value = minimumRewardsImpact
	bytec 13 //  "minimum_rewards_impact"
	frame_dig -3 // minimumRewardsImpact: uint64
	app_global_put

	// contracts/dao/dao.algo.ts:664
	// this.socialPostFee.value = fees.socialPostFee
	bytec 21 //  "social_post_fee"
	frame_dig -4 // fees: DAOInitFeeArgs
	extract 0 8
	btoi
	app_global_put

	// contracts/dao/dao.algo.ts:665
	// this.socialReactFee.value = fees.socialReactFee
	bytec 19 //  "social_react_fee"
	frame_dig -4 // fees: DAOInitFeeArgs
	extract 8 8
	btoi
	app_global_put

	// contracts/dao/dao.algo.ts:666
	// this.stakingPoolCreationFee.value = fees.stakingPoolCreationFee
	bytec 10 //  "staking_pool_creation_fee"
	frame_dig -4 // fees: DAOInitFeeArgs
	extract 16 8
	btoi
	app_global_put

	// contracts/dao/dao.algo.ts:667
	// this.subscriptionServiceCreationFee.value = fees.subscriptionServiceCreationFee
	bytec 6 //  "subscription_service_creation_fee"
	frame_dig -4 // fees: DAOInitFeeArgs
	extract 24 8
	btoi
	app_global_put

	// contracts/dao/dao.algo.ts:668
	// this.subscriptionPaymentPercentage.value = fees.subscriptionPaymentPercentage
	bytec 7 //  "subscription_payment_percentage"
	frame_dig -4 // fees: DAOInitFeeArgs
	extract 32 8
	btoi
	app_global_put

	// contracts/dao/dao.algo.ts:669
	// this.subscriptionTriggerPercentage.value = fees.subscriptionTriggerPercentage
	bytec 8 //  "subscription_trigger_percentage"
	frame_dig -4 // fees: DAOInitFeeArgs
	extract 40 8
	btoi
	app_global_put

	// contracts/dao/dao.algo.ts:670
	// this.omnigemSaleFee.value = fees.omnigemSaleFee
	bytec 20 //  "omnigem_sale_fee"
	frame_dig -4 // fees: DAOInitFeeArgs
	extract 48 8
	btoi
	app_global_put

	// contracts/dao/dao.algo.ts:671
	// this.nftListingCreationFee.value = fees.nftListingCreationFee
	bytec 11 //  "nft_listing_creation_fee"
	frame_dig -4 // fees: DAOInitFeeArgs
	extract 56 8
	btoi
	app_global_put

	// contracts/dao/dao.algo.ts:672
	// this.nftShuffleCreationFee.value = fees.nftShuffleCreationFee
	bytec 12 //  "nft_shuffle_creation_fee"
	frame_dig -4 // fees: DAOInitFeeArgs
	extract 64 8
	btoi
	app_global_put

	// contracts/dao/dao.algo.ts:673
	// this.auctionCreationFee.value = fees.auctionCreationFee
	bytec 15 //  "auction_creation_fee"
	frame_dig -4 // fees: DAOInitFeeArgs
	extract 72 8
	btoi
	app_global_put

	// contracts/dao/dao.algo.ts:674
	// this.hyperSwapOfferFee.value = fees.hyperSwapOfferFee
	bytec 16 //  "hyper_swap_offer_fee"
	frame_dig -4 // fees: DAOInitFeeArgs
	extract 80 8
	btoi
	app_global_put

	// contracts/dao/dao.algo.ts:675
	// this.krbyPercentage.value = fees.krbyPercentage
	bytec 22 //  "krby_percentage"
	frame_dig -4 // fees: DAOInitFeeArgs
	extract 88 8
	btoi
	app_global_put

	// contracts/dao/dao.algo.ts:676
	// this.moderatorPercentage.value = fees.moderatorPercentage
	bytec 17 //  "moderator_percentage"
	frame_dig -4 // fees: DAOInitFeeArgs
	extract 96 8
	btoi
	app_global_put

	// contracts/dao/dao.algo.ts:677
	// this.minimumProposalThreshold.value = minimumProposalThreshold
	bytec 9 //  "minimum_proposal_threshold"
	frame_dig -5 // minimumProposalThreshold: uint64
	app_global_put

	// contracts/dao/dao.algo.ts:678
	// this.minimumVoteThreshold.value = minimumVoteThreshold
	bytec 14 //  "minimum_vote_threshold"
	frame_dig -6 // minimumVoteThreshold: uint64
	app_global_put

	// contracts/dao/dao.algo.ts:679
	// this.bonesID.value = bones
	bytec 4 //  "bones_id"
	frame_dig 0 // bones: uint64
	app_global_put

	// contracts/dao/dao.algo.ts:680
	// this.revocationAddress.value = revocationAddress
	bytec 18 //  "revocation_address"
	frame_dig -7 // revocationAddress: Address
	app_global_put

	// contracts/dao/dao.algo.ts:681
	// this.proposalID.value = 0
	bytec 2 //  "proposal_id"
	intc 0 // 0
	app_global_put
	retsub

// arc58_verifyAuthAddr()void
*abi_route_arc58_verifyAuthAddr:
	// execute arc58_verifyAuthAddr()void
	callsub arc58_verifyAuthAddr
	intc 1 // 1
	return

// arc58_verifyAuthAddr(): void
//
// Verify the abstracted account is rekeyed to this app
arc58_verifyAuthAddr:
	proto 0 0

	// contracts/dao/dao.algo.ts:688
	// assert(this.app.address.authAddr === globals.zeroAddress)
	global CurrentApplicationAddress
	acct_params_get AcctAuthAddr
	pop
	global ZeroAddress
	==
	assert
	retsub

// arc58_rekeyToPlugin(uint64,uint64[],byte[32])void
*abi_route_arc58_rekeyToPlugin:
	// executionKey: byte[32]
	txna ApplicationArgs 3
	dup
	len
	intc 7 // 32
	==

	// argument 0 (executionKey) for arc58_rekeyToPlugin must be a byte[32]
	assert

	// methodOffsets: uint64[]
	txna ApplicationArgs 2
	extract 2 0

	// plugin: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc58_rekeyToPlugin(uint64,uint64[],byte[32])void
	callsub arc58_rekeyToPlugin
	intc 1 // 1
	return

// arc58_rekeyToPlugin(plugin: AppID, methodOffsets: uint64[], executionKey: bytes<32>): void
//
// Temporarily rekey to an approved plugin app address
//
// @param plugin The app to rekey to
// @param methodOffsets The indices of the methods being used in the group
// if the plugin has method restrictions these indices are required to match
// the methods used on each subsequent call to the plugin within the group
// @param executionKey The execution key required for the txn group
// TODO: ask joe about method overloading for ABI & ARCs to see if we can leave this as is
arc58_rekeyToPlugin:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// contracts/dao/dao.algo.ts:702
	// globalExists = this.plugins({ application: plugin, allowedCaller: Address.zeroAddress }).exists
	bytec 1 //  "p"
	frame_dig -1 // plugin: AppID
	itob
	global ZeroAddress
	concat
	concat
	box_len
	swap
	pop
	frame_bury 0 // globalExists: bool

	// contracts/dao/dao.algo.ts:703
	// localExists = this.plugins({ application: plugin, allowedCaller: this.txn.sender }).exists
	bytec 1 //  "p"
	frame_dig -1 // plugin: AppID
	itob
	txn Sender
	concat
	concat
	box_len
	swap
	pop
	frame_bury 1 // localExists: bool

	// contracts/dao/dao.algo.ts:705
	// globalAllowed = false
	intc 0 // 0
	frame_bury 2 // globalAllowed: bool

	// contracts/dao/dao.algo.ts:706
	// locallyAllowed = false
	intc 0 // 0
	frame_bury 3 // locallyAllowed: bool

	// *if22_condition
	// contracts/dao/dao.algo.ts:708
	// globalExists
	frame_dig 0 // globalExists: bool
	bz *if22_end

	// *if22_consequent
	// contracts/dao/dao.algo.ts:709
	// globalAllowed = this.pluginCallAllowed(plugin, Address.zeroAddress)
	global ZeroAddress
	frame_dig -1 // plugin: AppID
	callsub pluginCallAllowed
	frame_bury 2 // globalAllowed: bool

*if22_end:
	// *if23_condition
	// contracts/dao/dao.algo.ts:712
	// localExists
	frame_dig 1 // localExists: bool
	bz *if23_end

	// *if23_consequent
	// contracts/dao/dao.algo.ts:713
	// locallyAllowed = this.pluginCallAllowed(plugin, this.txn.sender)
	txn Sender
	frame_dig -1 // plugin: AppID
	callsub pluginCallAllowed
	frame_bury 3 // locallyAllowed: bool

*if23_end:
	// *if24_condition
	// contracts/dao/dao.algo.ts:719
	// (!globalExists && !localExists)
	//             || (globalExists && !globalAllowed && !locallyAllowed)
	frame_dig 0 // globalExists: bool
	!
	dup
	bz *skip_and18
	frame_dig 1 // localExists: bool
	!
	&&

*skip_and18:
	dup
	bnz *skip_or6
	frame_dig 0 // globalExists: bool
	dup
	bz *skip_and19
	frame_dig 2 // globalAllowed: bool
	!
	&&

*skip_and19:
	dup
	bz *skip_and20
	frame_dig 3 // locallyAllowed: bool
	!
	&&

*skip_and20:
	||

*skip_or6:
	bz *if24_elseif1_condition

	// *if24_consequent
	// contracts/dao/dao.algo.ts:722
	// this.assertPluginCallAllowed(plugin, Address.zeroAddress)
	global ZeroAddress
	frame_dig -1 // plugin: AppID
	callsub assertPluginCallAllowed
	b *if24_end

*if24_elseif1_condition:
	// contracts/dao/dao.algo.ts:723
	// localExists && !locallyAllowed && !globalAllowed
	frame_dig 1 // localExists: bool
	dup
	bz *skip_and21
	frame_dig 3 // locallyAllowed: bool
	!
	&&

*skip_and21:
	dup
	bz *skip_and22
	frame_dig 2 // globalAllowed: bool
	!
	&&

*skip_and22:
	bz *if24_end

	// *if24_elseif1_consequent
	// contracts/dao/dao.algo.ts:724
	// this.assertPluginCallAllowed(plugin, this.txn.sender)
	txn Sender
	frame_dig -1 // plugin: AppID
	callsub assertPluginCallAllowed

*if24_end:
	// contracts/dao/dao.algo.ts:727
	// used = this.assertValidGroup(plugin, methodOffsets, globalAllowed, locallyAllowed, executionKey)
	frame_dig -3 // executionKey: bytes<32>
	frame_dig 3 // locallyAllowed: bool
	frame_dig 2 // globalAllowed: bool
	frame_dig -2 // methodOffsets: uint64[]
	frame_dig -1 // plugin: AppID
	callsub assertValidGroup
	frame_bury 4 // used: (bool,bool)

	// contracts/dao/dao.algo.ts:729
	// sendPayment({
	//             receiver: this.app.address,
	//             rekeyTo: plugin.address,
	//             note: 'rekeying to plugin app',
	//             fee: 0,
	//         })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/dao/dao.algo.ts:730
	// receiver: this.app.address
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/dao/dao.algo.ts:731
	// rekeyTo: plugin.address
	frame_dig -1 // plugin: AppID
	app_params_get AppAddress
	pop
	itxn_field RekeyTo

	// contracts/dao/dao.algo.ts:732
	// note: 'rekeying to plugin app'
	pushbytes 0x72656b6579696e6720746f20706c7567696e20617070 // "rekeying to plugin app"
	itxn_field Note

	// contracts/dao/dao.algo.ts:733
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// *if25_condition
	// contracts/dao/dao.algo.ts:736
	// used.global
	frame_dig 4 // used: (bool,bool)
	store 255 // full array
	load 255 // full array
	intc 0 // 0
	getbit
	bz *if25_end

	// *if25_consequent
	// contracts/dao/dao.algo.ts:737
	// this.plugins({
	//                 application: plugin,
	//                 allowedCaller: Address.zeroAddress
	//             }).value.lastCalled = globals.round
	bytec 1 //  "p"
	frame_dig -1 // plugin: AppID
	itob
	global ZeroAddress
	concat
	concat
	box_get

	// box value does not exist: this.plugins({ application: plugin, allowedCaller: Address.zeroAddress }).value
	assert
	store 255 // full array
	load 255 // full array
	intc 10 // 16
	global Round
	itob
	replace3
	bytec 1 //  "p"
	frame_dig -1 // plugin: AppID
	itob
	global ZeroAddress
	concat
	concat
	dup
	box_del
	pop
	swap
	box_put

*if25_end:
	// *if26_condition
	// contracts/dao/dao.algo.ts:743
	// used.local
	frame_dig 4 // used: (bool,bool)
	store 255 // full array
	load 255 // full array
	intc 1 // 1
	getbit
	bz *if26_end

	// *if26_consequent
	// contracts/dao/dao.algo.ts:744
	// this.plugins({
	//                 application: plugin,
	//                 allowedCaller: this.txn.sender
	//             }).value.lastCalled = globals.round
	bytec 1 //  "p"
	frame_dig -1 // plugin: AppID
	itob
	txn Sender
	concat
	concat
	box_get

	// box value does not exist: this.plugins({ application: plugin, allowedCaller: this.txn.sender }).value
	assert
	store 255 // full array
	load 255 // full array
	intc 10 // 16
	global Round
	itob
	replace3
	bytec 1 //  "p"
	frame_dig -1 // plugin: AppID
	itob
	txn Sender
	concat
	concat
	dup
	box_del
	pop
	swap
	box_put

*if26_end:
	retsub

// newProposal(uint64)void
*abi_route_newProposal:
	// proposalType: uint64
	txna ApplicationArgs 1
	btoi

	// execute newProposal(uint64)void
	callsub newProposal
	intc 1 // 1
	return

// newProposal(proposalType: uint64): void
newProposal:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/dao/dao.algo.ts:752
	// id = this.newProposalID()
	callsub newProposalID
	frame_bury 0 // id: uint64
	retsub

// createDailyDisbursement()void
*abi_route_createDailyDisbursement:
	// execute createDailyDisbursement()void
	callsub createDailyDisbursement
	intc 1 // 1
	return

// createDailyDisbursement(): void
createDailyDisbursement:
	proto 0 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/dao/dao.algo.ts:760
	// bonesAmount = this.app.address.assetBalance(this.bonesID.value)
	global CurrentApplicationAddress
	bytec 4 //  "bones_id"
	app_global_get
	asset_holding_get AssetBalance
	pop
	frame_bury 0 // bonesAmount: uint64
	retsub

// getState()(uint64,string,byte[59],uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address)
*abi_route_getState:
	// The ABI return prefix
	pushbytes 0x151f7c75

	// execute getState()(uint64,string,byte[59],uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address)
	callsub getState
	concat
	log
	intc 1 // 1
	return

// getState(): AkitaDAOState
getState:
	proto 0 1

	// contracts/dao/dao.algo.ts:774
	// return {
	//             status: this.status.value,
	//             version: this.version.value,
	//             contentPolicy: this.contentPolicy.value,
	//             minimumRewardsImpact: this.minimumRewardsImpact.value,
	//             socialPostFee: this.socialPostFee.value,
	//             socialReactFee: this.socialReactFee.value,
	//             stakingPoolCreationFee: this.stakingPoolCreationFee.value,
	//             subscriptionServiceCreationFee: this.subscriptionServiceCreationFee.value,
	//             subscriptionPaymentPercentage: this.subscriptionPaymentPercentage.value,
	//             subscriptionTriggerPercentage: this.subscriptionTriggerPercentage.value,
	//             omnigemSaleFee: this.omnigemSaleFee.value,
	//             nftListingCreationFee: this.nftListingCreationFee.value,
	//             nftShuffleCreationFee: this.nftShuffleCreationFee.value,
	//             auctionCreationFee: this.auctionCreationFee.value,
	//             hyperSwapOfferFee: this.hyperSwapOfferFee.value,
	//             krbyPercentage: this.krbyPercentage.value,
	//             moderatorPercentage: this.moderatorPercentage.value,
	//             minimumProposalThreshold: this.minimumProposalThreshold.value,
	//             minimumVoteThreshold: this.minimumVoteThreshold.value,
	//             bonesID: this.bonesID.value,
	//             revocationAddress: this.revocationAddress.value,
	//         }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	pushbytes 0x00ed // initial head offset
	bytec 24 //  "status"
	app_global_get
	itob
	callsub *process_static_tuple_element
	bytec 5 //  "version"
	app_global_get
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	bytec 23 //  "content_policy"
	app_global_get
	callsub *process_static_tuple_element
	bytec 13 //  "minimum_rewards_impact"
	app_global_get
	itob
	callsub *process_static_tuple_element
	bytec 21 //  "social_post_fee"
	app_global_get
	itob
	callsub *process_static_tuple_element
	bytec 19 //  "social_react_fee"
	app_global_get
	itob
	callsub *process_static_tuple_element
	bytec 10 //  "staking_pool_creation_fee"
	app_global_get
	itob
	callsub *process_static_tuple_element
	bytec 6 //  "subscription_service_creation_fee"
	app_global_get
	itob
	callsub *process_static_tuple_element
	bytec 7 //  "subscription_payment_percentage"
	app_global_get
	itob
	callsub *process_static_tuple_element
	bytec 8 //  "subscription_trigger_percentage"
	app_global_get
	itob
	callsub *process_static_tuple_element
	bytec 20 //  "omnigem_sale_fee"
	app_global_get
	itob
	callsub *process_static_tuple_element
	bytec 11 //  "nft_listing_creation_fee"
	app_global_get
	itob
	callsub *process_static_tuple_element
	bytec 12 //  "nft_shuffle_creation_fee"
	app_global_get
	itob
	callsub *process_static_tuple_element
	bytec 15 //  "auction_creation_fee"
	app_global_get
	itob
	callsub *process_static_tuple_element
	bytec 16 //  "hyper_swap_offer_fee"
	app_global_get
	itob
	callsub *process_static_tuple_element
	bytec 22 //  "krby_percentage"
	app_global_get
	itob
	callsub *process_static_tuple_element
	bytec 17 //  "moderator_percentage"
	app_global_get
	itob
	callsub *process_static_tuple_element
	bytec 9 //  "minimum_proposal_threshold"
	app_global_get
	itob
	callsub *process_static_tuple_element
	bytec 14 //  "minimum_vote_threshold"
	app_global_get
	itob
	callsub *process_static_tuple_element
	bytec 4 //  "bones_id"
	app_global_get
	itob
	callsub *process_static_tuple_element
	bytec 18 //  "revocation_address"
	app_global_get
	callsub *process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x17383bb4 // method "init(string,byte[59],uint64,(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64),uint64,uint64,address)void"
	bytec 25 //  method "arc58_verifyAuthAddr()void"
	pushbytes 0x42089fbe // method "arc58_rekeyToPlugin(uint64,uint64[],byte[32])void"
	pushbytes 0x9023b90f // method "newProposal(uint64)void"
	pushbytes 0x56fd2375 // method "createDailyDisbursement()void"
	pushbytes 0xb5b23aa3 // method "getState()(uint64,string,byte[59],uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address)"
	txna ApplicationArgs 0
	match *abi_route_init *abi_route_arc58_verifyAuthAddr *abi_route_arc58_rekeyToPlugin *abi_route_newProposal *abi_route_createDailyDisbursement *abi_route_getState

	// this contract does not implement the given ABI method for call NoOp
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub