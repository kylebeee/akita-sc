#pragma version 10
intcblock 0 8 1 32 4 40 48 64 96 80 2 6 56 88 3 60 10000 18500 28100 53700 16 24
bytecblock 0x 0x73 0x64616f5f6170705f6964 0x0000000000000000 0x0000000000000001 0x151f7c75 0x6c 0x00 0x70

// This TEAL was generated by TEALScript v0.106.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 11 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// gate(caller: Address, index: uint64, args: bytes[]): boolean
gate:
	proto 3 1

	// *if0_condition
	// utils/base_contracts/gate.algo.ts:10
	// index === 0
	frame_dig -2 // index: uint64
	intc 0 // 0
	==
	bz *if0_end

	// *if0_consequent
	// utils/base_contracts/gate.algo.ts:11
	// return true;
	intc 2 // 1
	retsub

*if0_end:
	// utils/base_contracts/gate.algo.ts:14
	// return sendMethodCall<typeof Gate.prototype.check, boolean>({
	//             applicationID: AppID.fromUint64(AkitaAppIDsGate),
	//             methodArgs: [caller, index, args],
	//             fee: 0
	//         });
	itxn_begin
	intc 11 //  appl
	itxn_field TypeEnum
	pushbytes 0x200f7421 // method "check(address,uint64,byte[][])bool"
	itxn_field ApplicationArgs

	// utils/base_contracts/gate.algo.ts:15
	// applicationID: AppID.fromUint64(AkitaAppIDsGate)
	intc 0 // 0
	itxn_field ApplicationID

	// utils/base_contracts/gate.algo.ts:16
	// methodArgs: [caller, index, args]
	frame_dig -1 // caller: Address
	itxn_field ApplicationArgs
	frame_dig -2 // index: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -3 // args: bytes[]
	itxn_field ApplicationArgs

	// utils/base_contracts/gate.algo.ts:17
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 2 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	retsub

// getLatestWindowStart(startDate: uint64, interval: uint64): uint64
getLatestWindowStart:
	proto 2 1

	// contracts/subscriptions/subscriptions.algo.ts:154
	// return globals.latestTimestamp - ((globals.latestTimestamp - startDate) % interval);
	global LatestTimestamp
	global LatestTimestamp
	frame_dig -1 // startDate: uint64
	-
	frame_dig -2 // interval: uint64
	%
	-
	retsub

// updateStreak(sender: Address, index: uint64, elseStreak: uint64): void
updateStreak:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts/subscriptions/subscriptions.algo.ts:158
	// subKey: SubscriptionKey = { address: sender, index: index }
	frame_dig -1 // sender: Address
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // subKey: SubscriptionKey

	// contracts/subscriptions/subscriptions.algo.ts:159
	// sub = this.subscriptions(subKey).value
	frame_dig 0 // subKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/subscriptions/subscriptions.algo.ts:161
	// currentWindowStart = this.getLatestWindowStart(sub.startDate, sub.interval)
	frame_dig 0 // subKey: SubscriptionKey
	intc 12 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	frame_dig 0 // subKey: SubscriptionKey
	intc 5 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	callsub getLatestWindowStart
	frame_bury 2 // currentWindowStart: uint64

	// contracts/subscriptions/subscriptions.algo.ts:162
	// lastWindowStart = (currentWindowStart - sub.interval)
	frame_dig 2 // currentWindowStart: uint64
	frame_dig 0 // subKey: SubscriptionKey
	intc 12 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	-
	frame_bury 3 // lastWindowStart: uint64

	// *if1_condition
	// contracts/subscriptions/subscriptions.algo.ts:164
	// sub.lastPayment < lastWindowStart
	frame_dig 0 // subKey: SubscriptionKey
	intc 9 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	frame_dig 3 // lastWindowStart: uint64
	<
	bz *if1_end

	// *if1_consequent
	// contracts/subscriptions/subscriptions.algo.ts:166
	// this.subscriptions(subKey).value.streak = elseStreak
	intc 13 //  headOffset
	frame_dig -3 // elseStreak: uint64
	itob
	frame_dig 0 // subKey: SubscriptionKey
	cover 2
	box_replace

	// contracts/subscriptions/subscriptions.algo.ts:167
	// return;
	retsub

*if1_end:
	// *if2_condition
	// contracts/subscriptions/subscriptions.algo.ts:173
	// sub.lastPayment >= lastWindowStart && !(sub.lastPayment >= currentWindowStart)
	frame_dig 0 // subKey: SubscriptionKey
	intc 9 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	frame_dig 3 // lastWindowStart: uint64
	>=
	dup
	bz *skip_and0
	frame_dig 0 // subKey: SubscriptionKey
	intc 9 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	frame_dig 2 // currentWindowStart: uint64
	>=
	!
	&&

*skip_and0:
	bz *if2_end

	// *if2_consequent
	// contracts/subscriptions/subscriptions.algo.ts:174
	// this.subscriptions(subKey).value.streak += 1
	intc 13 //  headOffset
	frame_dig 0 // subKey: SubscriptionKey
	intc 13 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	intc 2 // 1
	+
	itob
	frame_dig 0 // subKey: SubscriptionKey
	cover 2
	box_replace

*if2_end:
	retsub

// getAmounts(amount: uint64): Amounts
getAmounts:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// contracts/subscriptions/subscriptions.algo.ts:179
	// akitaPercentage = this.daoAppID.value.globalState(SUBSCRIPTION_PAYMENT_PERCENTAGE_KEY) as uint64
	bytec 2 //  "dao_app_id"
	app_global_get
	pushbytes "subscription_payment_percentage"
	app_global_get_ex

	// global state value does not exist: this.daoAppID.value.globalState(SUBSCRIPTION_PAYMENT_PERCENTAGE_KEY)
	assert
	frame_bury 0 // akitaPercentage: uint64

	// contracts/subscriptions/subscriptions.algo.ts:180
	// akitaFee = wideRatio([amount, akitaPercentage], [10000])
	frame_dig -1 // amount: uint64
	frame_dig 0 // akitaPercentage: uint64
	mulw
	intc 0 // 0
	intc 16 // 10000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 1 // akitaFee: uint64

	// *if3_condition
	// contracts/subscriptions/subscriptions.algo.ts:181
	// akitaFee === 0 && amount > 0
	frame_dig 1 // akitaFee: uint64
	intc 0 // 0
	==
	dup
	bz *skip_and1
	frame_dig -1 // amount: uint64
	intc 0 // 0
	>
	&&

*skip_and1:
	bz *if3_end

	// *if3_consequent
	// contracts/subscriptions/subscriptions.algo.ts:182
	// akitaFee = 1
	intc 2 // 1
	frame_bury 1 // akitaFee: uint64

*if3_end:
	// contracts/subscriptions/subscriptions.algo.ts:185
	// triggerPercentage = this.daoAppID.value.globalState(SUBSCRIPTION_TRIGGER_PERCENTAGE_KEY) as uint64
	bytec 2 //  "dao_app_id"
	app_global_get
	pushbytes "subscription_trigger_percentage"
	app_global_get_ex

	// global state value does not exist: this.daoAppID.value.globalState(SUBSCRIPTION_TRIGGER_PERCENTAGE_KEY)
	assert
	frame_bury 2 // triggerPercentage: uint64

	// contracts/subscriptions/subscriptions.algo.ts:186
	// triggerFee = wideRatio([amount, triggerPercentage], [10000])
	frame_dig -1 // amount: uint64
	frame_dig 2 // triggerPercentage: uint64
	mulw
	intc 0 // 0
	intc 16 // 10000
	divmodw
	pop
	pop
	swap
	!

	// wideRatio failed
	assert
	frame_bury 3 // triggerFee: uint64

	// *if4_condition
	// contracts/subscriptions/subscriptions.algo.ts:187
	// triggerFee === 0 && amount > 0
	frame_dig 3 // triggerFee: uint64
	intc 0 // 0
	==
	dup
	bz *skip_and2
	frame_dig -1 // amount: uint64
	intc 0 // 0
	>
	&&

*skip_and2:
	bz *if4_end

	// *if4_consequent
	// contracts/subscriptions/subscriptions.algo.ts:188
	// triggerFee = 1
	intc 2 // 1
	frame_bury 3 // triggerFee: uint64

*if4_end:
	// contracts/subscriptions/subscriptions.algo.ts:191
	// leftOver = amount - (akitaFee + triggerFee)
	frame_dig -1 // amount: uint64
	frame_dig 1 // akitaFee: uint64
	frame_dig 3 // triggerFee: uint64
	+
	-
	frame_bury 4 // leftOver: uint64

	// contracts/subscriptions/subscriptions.algo.ts:193
	// return {
	//             akitaFee: akitaFee,
	//             triggerFee: triggerFee,
	//             leftOver: leftOver,
	//         }
	frame_dig 1 // akitaFee: uint64
	itob
	frame_dig 3 // triggerFee: uint64
	itob
	concat
	frame_dig 4 // leftOver: uint64
	itob
	concat

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 4
	retsub

// arc58OptInAkitaDAO(asset: AssetID): void
arc58OptInAkitaDAO:
	proto 1 0

	// contracts/subscriptions/subscriptions.algo.ts:201
	// this.pendingGroup.addPayment({
	//             amount: globals.assetOptInMinBalance,
	//             receiver: this.app.address,
	//             fee: 0,
	//         })
	itxn_next
	intc 2 //  pay
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:202
	// amount: globals.assetOptInMinBalance
	global AssetOptInMinBalance
	itxn_field Amount

	// contracts/subscriptions/subscriptions.algo.ts:203
	// receiver: this.app.address
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/subscriptions/subscriptions.algo.ts:204
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:207
	// this.pendingGroup.addMethodCall<typeof AkitaDAO.prototype.arc58_rekeyToPlugin, void>({
	//             applicationID: this.daoAppID.value,
	//             methodArgs: [
	//                 AppID.fromUint64(AkitaAppIDsOptinPlugin),
	//                 [],
	//                 EMPTY_BYTES_32,
	//             ],
	//             fee: 0,
	//         })
	itxn_next
	intc 11 //  appl
	itxn_field TypeEnum
	pushbytes 0x42089fbe // method "arc58_rekeyToPlugin(uint64,uint64[],byte[32])void"
	itxn_field ApplicationArgs

	// contracts/subscriptions/subscriptions.algo.ts:208
	// applicationID: this.daoAppID.value
	bytec 2 //  "dao_app_id"
	app_global_get
	itxn_field ApplicationID

	// contracts/subscriptions/subscriptions.algo.ts:209
	// methodArgs: [
	//                 AppID.fromUint64(AkitaAppIDsOptinPlugin),
	//                 [],
	//                 EMPTY_BYTES_32,
	//             ]
	bytec 3 // 0x0000000000000000
	itxn_field ApplicationArgs
	pushbytes 0x0000
	itxn_field ApplicationArgs
	pushbytes 0x4141414141414141414141414141414141414141414141414141414141414141 // "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
	itxn_field ApplicationArgs

	// contracts/subscriptions/subscriptions.algo.ts:214
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:217
	// this.pendingGroup.addMethodCall<typeof OptInPlugin.prototype.optInToAsset, void>({
	//             applicationID: AppID.fromUint64(AkitaAppIDsOptinPlugin),
	//             methodArgs: [
	//                 this.daoAppID.value,
	//                 true,
	//                 asset,
	//                 {
	//                     receiver: this.daoAppID.value.address,
	//                     amount: globals.assetOptInMinBalance,
	//                     fee: 0,
	//                 }
	//             ],
	//             fee: 0,
	//         })
	itxn_next
	intc 2 //  pay
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:224
	// receiver: this.daoAppID.value.address
	bytec 2 //  "dao_app_id"
	app_global_get
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/subscriptions/subscriptions.algo.ts:225
	// amount: globals.assetOptInMinBalance
	global AssetOptInMinBalance
	itxn_field Amount

	// contracts/subscriptions/subscriptions.algo.ts:226
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 11 //  appl
	itxn_field TypeEnum
	pushbytes 0xbfcbeee9 // method "optInToAsset(uint64,bool,uint64,pay)void"
	itxn_field ApplicationArgs

	// contracts/subscriptions/subscriptions.algo.ts:218
	// applicationID: AppID.fromUint64(AkitaAppIDsOptinPlugin)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/subscriptions/subscriptions.algo.ts:219
	// methodArgs: [
	//                 this.daoAppID.value,
	//                 true,
	//                 asset,
	//                 {
	//                     receiver: this.daoAppID.value.address,
	//                     amount: globals.assetOptInMinBalance,
	//                     fee: 0,
	//                 }
	//             ]
	bytec 2 //  "dao_app_id"
	app_global_get
	itob
	itxn_field ApplicationArgs
	intc 2 // 1
	bytec 7 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	itxn_field ApplicationArgs
	frame_dig -1 // asset: AssetID
	itob
	itxn_field ApplicationArgs

	// contracts/subscriptions/subscriptions.algo.ts:229
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:232
	// this.pendingGroup.addMethodCall<typeof AbstractedAccount.prototype.arc58_verifyAuthAddr, void>({
	//             applicationID: this.daoAppID.value,
	//             fee: 0,
	//         })
	itxn_next
	intc 11 //  appl
	itxn_field TypeEnum
	pushbytes 0x0f885493 // method "arc58_verifyAuthAddr()void"
	itxn_field ApplicationArgs

	// contracts/subscriptions/subscriptions.algo.ts:233
	// applicationID: this.daoAppID.value
	bytec 2 //  "dao_app_id"
	app_global_get
	itxn_field ApplicationID

	// contracts/subscriptions/subscriptions.algo.ts:234
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:237
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// isBlocked(address,address)bool
*abi_route_isBlocked:
	// The ABI return prefix
	bytec 5 // 0x151f7c75

	// address: address
	txna ApplicationArgs 2
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for isBlocked must be a address
	assert

	// merchant: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 1 (merchant) for isBlocked must be a address
	assert

	// execute isBlocked(address,address)bool
	callsub isBlocked
	bytec 7 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	concat
	log
	intc 2 // 1
	return

// isBlocked(merchant: Address, address: Address): boolean
//
// isBlocked checks if an address is blocked for a merchant
// @param merchant The merchant address to be checked
// @param address The address to be checked
isBlocked:
	proto 2 1

	// contracts/subscriptions/subscriptions.algo.ts:247
	// return this.blocks({ address: merchant, blocked: address }).exists;
	frame_dig -1 // merchant: Address
	frame_dig -2 // address: Address
	concat
	box_len
	swap
	pop
	retsub

// isShutdown(address,uint64)bool
*abi_route_isShutdown:
	// The ABI return prefix
	bytec 5 // 0x151f7c75

	// boxIndex: uint64
	txna ApplicationArgs 2
	btoi

	// merchant: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 1 (merchant) for isShutdown must be a address
	assert

	// execute isShutdown(address,uint64)bool
	callsub isShutdown
	bytec 7 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	concat
	log
	intc 2 // 1
	return

// isShutdown(merchant: Address, boxIndex: uint64): boolean
//
// serviceIsActive checks if an service is shutdown
isShutdown:
	proto 2 1

	// contracts/subscriptions/subscriptions.algo.ts:255
	// return this.services({ address: merchant, index: boxIndex }).value.status === ServiceStatusShutdown;
	intc 0 // 0
	intc 1 // 8
	bytec 1 //  "s"
	frame_dig -1 // merchant: Address
	frame_dig -2 // boxIndex: uint64
	itob
	concat
	concat
	cover 2
	box_extract
	btoi
	intc 10 // 2
	==
	retsub

// getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])
*abi_route_getSubsriptionInfo:
	// The ABI return prefix
	bytec 5 // 0x151f7c75

	// index: uint64
	txna ApplicationArgs 2
	btoi

	// address: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 1 (address) for getSubsriptionInfo must be a address
	assert

	// execute getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])
	callsub getSubsriptionInfo
	concat
	log
	intc 2 // 1
	return

// getSubsriptionInfo(address: Address, index: uint64): SubscriptionInfoWithPasses
getSubsriptionInfo:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/subscriptions/subscriptions.algo.ts:260
	// key: SubscriptionKey = { address: address, index: index }
	frame_dig -1 // address: Address
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // key: SubscriptionKey

	// contracts/subscriptions/subscriptions.algo.ts:262
	// assert(this.subscriptions(key).exists, errs.SUBSCRIPTION_DOES_NOT_EXIST)
	frame_dig 0 // key: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:264
	// subInfo = this.subscriptions(key).value
	frame_dig 0 // key: SubscriptionKey
	frame_bury 1 // storage key//subInfo

	// contracts/subscriptions/subscriptions.algo.ts:266
	// passes: Address[] = []
	bytec 0 // 0x
	frame_bury 2 // passes: Address[]

	// *if5_condition
	// contracts/subscriptions/subscriptions.algo.ts:267
	// this.passes(key).exists
	bytec 8 //  "p"
	frame_dig 0 // key: SubscriptionKey
	concat
	box_len
	swap
	pop
	bz *if5_end

	// *if5_consequent
	// contracts/subscriptions/subscriptions.algo.ts:268
	// passes = this.passes(key).value
	bytec 8 //  "p"
	frame_dig 0 // key: SubscriptionKey
	concat
	box_get

	// box value does not exist: this.passes(key).value
	assert
	extract 2 0
	frame_bury 2 // passes: Address[]

*if5_end:
	// contracts/subscriptions/subscriptions.algo.ts:271
	// return {
	//             recipient: subInfo.recipient,
	//             index: subInfo.index,
	//             startDate: subInfo.startDate,
	//             amount: subInfo.amount,
	//             interval: subInfo.interval,
	//             asset: subInfo.asset,
	//             gate: subInfo.gate,
	//             lastPayment: subInfo.lastPayment,
	//             streak: subInfo.streak,
	//             passes: passes,
	//         };
	bytec 0 //  initial head
	bytec 0 //  initial tail
	pushbytes 0x0062 // initial head offset
	frame_dig 0 // key: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 3 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 5 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 6 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 12 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 7 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	pushint 72 // headOffset
	intc 1 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 9 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 13 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 2 // passes: Address[]
	dup
	len
	intc 3 // 32
	/
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// isFirstSubscription(address)bool
*abi_route_isFirstSubscription:
	// The ABI return prefix
	bytec 5 // 0x151f7c75

	// address: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for isFirstSubscription must be a address
	assert

	// execute isFirstSubscription(address)bool
	callsub isFirstSubscription
	bytec 7 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	concat
	log
	intc 2 // 1
	return

// isFirstSubscription(address: Address): boolean
isFirstSubscription:
	proto 1 1

	// contracts/subscriptions/subscriptions.algo.ts:287
	// return !this.subscriptionslist(address).exists;
	frame_dig -1 // address: Address
	box_len
	swap
	pop
	!
	retsub

// newService(pay,uint64,uint64,uint64,uint64,uint64,byte[59])uint64
*abi_route_newService:
	// The ABI return prefix
	bytec 5 // 0x151f7c75

	// cid: byte[59]
	txna ApplicationArgs 6
	dup
	len
	pushint 59
	==

	// argument 0 (cid) for newService must be a byte[59]
	assert

	// gate: uint64
	txna ApplicationArgs 5
	btoi

	// passes: uint64
	txna ApplicationArgs 4
	btoi

	// amount: uint64
	txna ApplicationArgs 3
	btoi

	// asset: uint64
	txna ApplicationArgs 2
	btoi

	// interval: uint64
	txna ApplicationArgs 1
	btoi

	// payment: pay
	txn GroupIndex
	intc 2 // 1
	-
	dup
	gtxns TypeEnum
	intc 2 //  pay
	==

	// argument 6 (payment) for newService must be a pay transaction
	assert

	// execute newService(pay,uint64,uint64,uint64,uint64,uint64,byte[59])uint64
	callsub newService
	itob
	concat
	log
	intc 2 // 1
	return

// newService(payment: PayTxn, interval: uint64, asset: AssetID, amount: uint64, passes: uint64, gate: uint64, cid: bytes<59>): uint64
//
// newService creates a new service for a merchant
// @param payment The payment for the service creation
// @param interval The interval in seconds
// @param asset The asa to be used for the subscription
// @param amount The amount of the asa to be used for the subscription
// @param passes The number of accounts the subscription can be shared with
// @param gate The gate to be used for the subscription
// @param cid The ipfs cid of the subscription contract
// or upgrade the subscription to a different service from the user without losing their streak
newService:
	proto 7 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts/subscriptions/subscriptions.algo.ts:310
	// index: uint64 = 0
	intc 0 // 0
	frame_bury 0 // index: uint64

	// *if6_condition
	// contracts/subscriptions/subscriptions.algo.ts:311
	// this.serviceslist(this.txn.sender).exists
	bytec 6 //  "l"
	txn Sender
	concat
	box_len
	swap
	pop
	bz *if6_else

	// *if6_consequent
	// contracts/subscriptions/subscriptions.algo.ts:312
	// index = this.serviceslist(this.txn.sender).value
	bytec 6 //  "l"
	txn Sender
	concat
	box_get

	// box value does not exist: this.serviceslist(this.txn.sender).value
	assert
	btoi
	frame_bury 0 // index: uint64

	// contracts/subscriptions/subscriptions.algo.ts:313
	// this.serviceslist(this.txn.sender).value += 1
	bytec 6 //  "l"
	txn Sender
	concat
	box_get

	// box value does not exist: this.serviceslist(this.txn.sender).value
	assert
	btoi
	intc 2 // 1
	+
	bytec 6 //  "l"
	txn Sender
	concat
	swap
	itob
	box_put
	b *if6_end

*if6_else:
	// contracts/subscriptions/subscriptions.algo.ts:315
	// index = 1
	intc 2 // 1
	frame_bury 0 // index: uint64

	// contracts/subscriptions/subscriptions.algo.ts:316
	// this.serviceslist(this.txn.sender).value = 1
	bytec 6 //  "l"
	txn Sender
	concat
	bytec 4 // 0x0000000000000001
	box_put

*if6_end:
	// contracts/subscriptions/subscriptions.algo.ts:319
	// boxKey: ServicesKey = { address: this.txn.sender, index: index }
	txn Sender
	frame_dig 0 // index: uint64
	itob
	concat
	frame_bury 1 // boxKey: ServicesKey

	// contracts/subscriptions/subscriptions.algo.ts:322
	// assert(amount > 3, errs.MIN_AMOUNT_IS_THREE)
	frame_dig -4 // amount: uint64
	intc 14 // 3
	>
	assert

	// contracts/subscriptions/subscriptions.algo.ts:324
	// assert(interval >= 60, errs.MIN_INTERVAL_IS_SIXTY)
	frame_dig -2 // interval: uint64
	intc 15 // 60
	>=
	assert

	// contracts/subscriptions/subscriptions.algo.ts:326
	// assert(passes <= 5, errs.MAX_PASSES_IS_FIVE)
	frame_dig -5 // passes: uint64
	pushint 5
	<=
	assert

	// contracts/subscriptions/subscriptions.algo.ts:328
	// serviceCreationFee = this.daoAppID.value.globalState(SUBSCRIPTION_SERVICE_CREATION_FEE) as uint64
	bytec 2 //  "dao_app_id"
	app_global_get
	pushbytes "subscription_service_creation_fee"
	app_global_get_ex

	// global state value does not exist: this.daoAppID.value.globalState(SUBSCRIPTION_SERVICE_CREATION_FEE)
	assert
	frame_bury 2 // serviceCreationFee: uint64

	// contracts/subscriptions/subscriptions.algo.ts:330
	// requiredAmount = serviceCreationFee
	frame_dig 2 // serviceCreationFee: uint64
	frame_bury 3 // requiredAmount: uint64

	// *if7_condition
	// contracts/subscriptions/subscriptions.algo.ts:331
	// asset.id !== 0
	frame_dig -3 // asset: AssetID
	intc 0 // 0
	!=
	bz *if7_end

	// *if7_consequent
	// contracts/subscriptions/subscriptions.algo.ts:332
	// requiredAmount += globals.assetOptInMinBalance
	frame_dig 3 // requiredAmount: uint64
	global AssetOptInMinBalance
	+
	frame_bury 3 // requiredAmount: uint64

*if7_end:
	// contracts/subscriptions/subscriptions.algo.ts:335
	// verifyPayTxn(payment, {
	//             amount: requiredAmount,
	//             receiver: this.app.address,
	//         })
	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	frame_dig 3 // requiredAmount: uint64
	==

	// transaction verification failed: {"txn":"payment","field":"amount","expected":"requiredAmount"}
	assert

	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// contracts/subscriptions/subscriptions.algo.ts:340
	// this.services(boxKey).value = {
	//             status: ServiceStatusPaused,
	//             interval: interval,
	//             asset: asset,
	//             amount: amount,
	//             passes: passes,
	//             gate: gate,
	//             cid: cid,
	//         }
	bytec 1 //  "s"
	frame_dig 1 // boxKey: ServicesKey
	concat
	bytec 4 // 0x0000000000000001
	frame_dig -2 // interval: uint64
	itob
	concat
	frame_dig -3 // asset: AssetID
	itob
	concat
	frame_dig -4 // amount: uint64
	itob
	concat
	frame_dig -5 // passes: uint64
	itob
	concat
	frame_dig -6 // gate: uint64
	itob
	concat
	frame_dig -7 // cid: bytes<59>
	concat
	box_put

	// contracts/subscriptions/subscriptions.algo.ts:350
	// return index;
	frame_dig 0 // index: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// pauseService(uint64)void
*abi_route_pauseService:
	// index: uint64
	txna ApplicationArgs 1
	btoi

	// execute pauseService(uint64)void
	callsub pauseService
	intc 2 // 1
	return

// pauseService(index: uint64): void
//
// pauseService pauses a service for a merchant
// it does not shutdown pre-existing subscriptions
// it simply prevents new subscriptions from being created
// for a specific service
// @param index The index of the box to be used for the subscription
pauseService:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/subscriptions/subscriptions.algo.ts:361
	// boxKey: ServicesKey = { address: this.txn.sender, index: index }
	txn Sender
	frame_dig -1 // index: uint64
	itob
	concat
	frame_bury 0 // boxKey: ServicesKey

	// contracts/subscriptions/subscriptions.algo.ts:364
	// assert(index > 0, errs.SERVICE_INDEX_MUST_BE_ABOVE_ZERO)
	frame_dig -1 // index: uint64
	intc 0 // 0
	>
	assert

	// contracts/subscriptions/subscriptions.algo.ts:366
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:368
	// assert(this.services(boxKey).value.status === ServiceStatusActive, errs.SERVICE_IS_NOT_ACTIVE)
	intc 0 // 0
	intc 1 // 8
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	intc 0 // 0
	==
	assert

	// contracts/subscriptions/subscriptions.algo.ts:370
	// this.services(boxKey).value.status = ServiceStatusPaused
	intc 0 // 0
	bytec 4 // 0x0000000000000001
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_replace
	retsub

// activateService(uint64)void
*abi_route_activateService:
	// index: uint64
	txna ApplicationArgs 1
	btoi

	// execute activateService(uint64)void
	callsub activateService
	intc 2 // 1
	return

// activateService(index: uint64): void
//
// activateService activates an service for a merchant
//
// @param index The index of the box to be used for the subscription
activateService:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/subscriptions/subscriptions.algo.ts:379
	// boxKey: ServicesKey = { address: this.txn.sender, index: index }
	txn Sender
	frame_dig -1 // index: uint64
	itob
	concat
	frame_bury 0 // boxKey: ServicesKey

	// contracts/subscriptions/subscriptions.algo.ts:382
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:384
	// assert(this.services(boxKey).value.status === ServiceStatusPaused, errs.SERVICE_IS_NOT_PAUSED)
	intc 0 // 0
	intc 1 // 8
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	intc 2 // 1
	==
	assert

	// contracts/subscriptions/subscriptions.algo.ts:386
	// this.services(boxKey).value.status = ServiceStatusActive
	intc 0 // 0
	bytec 3 // 0x0000000000000000
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_replace
	retsub

// shutdownService(uint64)void
*abi_route_shutdownService:
	// index: uint64
	txna ApplicationArgs 1
	btoi

	// execute shutdownService(uint64)void
	callsub shutdownService
	intc 2 // 1
	return

// shutdownService(index: uint64): void
//
// shutdownService permanently shuts down an service for a merchant
// it also shutsdown pre-existing subscriptions
// @param index The index of the box to be used for the subscription
shutdownService:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/subscriptions/subscriptions.algo.ts:395
	// boxKey: ServicesKey = { address: this.txn.sender, index: index }
	txn Sender
	frame_dig -1 // index: uint64
	itob
	concat
	frame_bury 0 // boxKey: ServicesKey

	// contracts/subscriptions/subscriptions.algo.ts:397
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:399
	// assert(this.services(boxKey).value.status !== ServiceStatusShutdown, errs.SERVICE_IS_SHUTDOWN)
	intc 0 // 0
	intc 1 // 8
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	intc 10 // 2
	!=
	assert

	// contracts/subscriptions/subscriptions.algo.ts:401
	// this.services(boxKey).value.status = ServiceStatusShutdown
	intc 0 // 0
	pushbytes 0x0000000000000002
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_replace
	retsub

// block(pay,address)void
*abi_route_block:
	// address: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for block must be a address
	assert

	// payment: pay
	txn GroupIndex
	intc 2 // 1
	-
	dup
	gtxns TypeEnum
	intc 2 //  pay
	==

	// argument 1 (payment) for block must be a pay transaction
	assert

	// execute block(pay,address)void
	callsub block
	intc 2 // 1
	return

// block(payment: PayTxn, address: Address): void
//
// block blacklists an address for a merchant
// @param payment The payment to cover mbr for blocking
// @param address The address to be blocked
block:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/subscriptions/subscriptions.algo.ts:410
	// boxKey: BlockListKey = { address: this.txn.sender, blocked: address }
	txn Sender
	frame_dig -2 // address: Address
	concat
	frame_bury 0 // boxKey: BlockListKey

	// contracts/subscriptions/subscriptions.algo.ts:413
	// assert(!this.blocks(boxKey).exists, errs.USER_ALREADY_BLOCKED)
	frame_dig 0 // boxKey: BlockListKey
	box_len
	swap
	pop
	!
	assert

	// contracts/subscriptions/subscriptions.algo.ts:416
	// verifyPayTxn(payment, {
	//             receiver: this.app.address,
	//             amount: blockMBR,
	//         })
	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	intc 18 // 28100
	==

	// transaction verification failed: {"txn":"payment","field":"amount","expected":"blockMBR"}
	assert

	// contracts/subscriptions/subscriptions.algo.ts:421
	// this.blocks(boxKey).create(0)
	frame_dig 0 // boxKey: BlockListKey
	intc 0 // 0
	box_create
	pop
	retsub

// unblock(address)void
*abi_route_unblock:
	// address: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for unblock must be a address
	assert

	// execute unblock(address)void
	callsub unblock
	intc 2 // 1
	return

// unblock(address: Address): void
//
// unblock removes an address from a merchants blocks
// @param address The address to be unblocked
unblock:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/subscriptions/subscriptions.algo.ts:429
	// boxKey: BlockListKey = { address: this.txn.sender, blocked: address }
	txn Sender
	frame_dig -1 // address: Address
	concat
	frame_bury 0 // boxKey: BlockListKey

	// contracts/subscriptions/subscriptions.algo.ts:432
	// assert(this.blocks(boxKey).exists, errs.USER_NOT_BLOCKED)
	frame_dig 0 // boxKey: BlockListKey
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:434
	// this.blocks(boxKey).delete()
	frame_dig 0 // boxKey: BlockListKey
	box_del

	// contracts/subscriptions/subscriptions.algo.ts:436
	// sendPayment({
	//             receiver: this.txn.sender,
	//             amount: blockMBR,
	//             fee: 0,
	//         })
	itxn_begin
	intc 2 //  pay
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:437
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/subscriptions/subscriptions.algo.ts:438
	// amount: blockMBR
	intc 18 // 28100
	itxn_field Amount

	// contracts/subscriptions/subscriptions.algo.ts:439
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// subscribe(pay,address,uint64,uint64,uint64,byte[][])void
*abi_route_subscribe:
	// args: byte[][]
	txna ApplicationArgs 5

	// index: uint64
	txna ApplicationArgs 4
	btoi

	// interval: uint64
	txna ApplicationArgs 3
	btoi

	// amount: uint64
	txna ApplicationArgs 2
	btoi

	// recipient: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 4 (recipient) for subscribe must be a address
	assert

	// payment: pay
	txn GroupIndex
	intc 2 // 1
	-
	dup
	gtxns TypeEnum
	intc 2 //  pay
	==

	// argument 5 (payment) for subscribe must be a pay transaction
	assert

	// execute subscribe(pay,address,uint64,uint64,uint64,byte[][])void
	callsub subscribe
	intc 2 // 1
	return

// subscribe(payment: PayTxn, recipient: Address, amount: uint64, interval: uint64, index: uint64, args: bytes[]): void
subscribe:
	proto 6 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 9

	// contracts/subscriptions/subscriptions.algo.ts:452
	// assert(amount >= 3, errs.MIN_AMOUNT_IS_THREE)
	frame_dig -3 // amount: uint64
	intc 14 // 3
	>=
	assert

	// contracts/subscriptions/subscriptions.algo.ts:454
	// assert(interval >= 60, errs.MIN_INTERVAL_IS_SIXTY)
	frame_dig -4 // interval: uint64
	intc 15 // 60
	>=
	assert

	// contracts/subscriptions/subscriptions.algo.ts:456
	// blocksKey: BlockListKey = { address: recipient, blocked: this.txn.sender }
	frame_dig -2 // recipient: Address
	txn Sender
	concat
	frame_bury 0 // blocksKey: BlockListKey

	// contracts/subscriptions/subscriptions.algo.ts:458
	// assert(!this.blocks(blocksKey).exists, errs.BLOCKED)
	frame_dig 0 // blocksKey: BlockListKey
	box_len
	swap
	pop
	!
	assert

	// contracts/subscriptions/subscriptions.algo.ts:460
	// gate = 0
	intc 0 // 0
	frame_bury 1 // gate: uint64

	// contracts/subscriptions/subscriptions.algo.ts:462
	// isDonation = index === 0
	frame_dig -5 // index: uint64
	intc 0 // 0
	==
	frame_bury 2 // isDonation: bool

	// *if8_condition
	// contracts/subscriptions/subscriptions.algo.ts:463
	// !isDonation
	frame_dig 2 // isDonation: bool
	!
	bz *if8_end

	// *if8_consequent
	// contracts/subscriptions/subscriptions.algo.ts:464
	// boxKey: ServicesKey = { address: recipient, index: index }
	frame_dig -2 // recipient: Address
	frame_dig -5 // index: uint64
	itob
	concat
	frame_bury 3 // boxKey: ServicesKey

	// contracts/subscriptions/subscriptions.algo.ts:466
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:468
	// service = this.services(boxKey).value
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	frame_bury 4 // storage key//service

	// contracts/subscriptions/subscriptions.algo.ts:470
	// assert(service.status === ServiceStatusActive, errs.SERVICE_IS_NOT_ACTIVE)
	intc 0 // 0
	intc 1 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	intc 0 // 0
	==
	assert

	// contracts/subscriptions/subscriptions.algo.ts:472
	// assert(service.asset.id === 0, errs.ASA_MISMATCH)
	intc 20 //  headOffset
	intc 1 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	intc 0 // 0
	==
	assert

	// contracts/subscriptions/subscriptions.algo.ts:474
	// assert(this.gate(this.txn.sender, service.gate, args), errs.FAILED_GATE)
	frame_dig -6 // args: bytes[]
	intc 5 //  headOffset
	intc 1 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	txn Sender
	callsub gate
	assert

	// contracts/subscriptions/subscriptions.algo.ts:476
	// amount = service.amount
	intc 21 //  headOffset
	intc 1 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	frame_bury -3 // amount: uint64

	// contracts/subscriptions/subscriptions.algo.ts:477
	// interval = service.interval
	intc 1 //  headOffset
	intc 1 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	frame_bury -4 // interval: uint64

	// contracts/subscriptions/subscriptions.algo.ts:478
	// gate = service.gate
	intc 5 //  headOffset
	intc 1 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	frame_bury 1 // gate: uint64

*if8_end:
	// contracts/subscriptions/subscriptions.algo.ts:481
	// algoMBRFee = subscriptionsMBR
	intc 19 // 53700
	frame_bury 5 // algoMBRFee: uint64

	// contracts/subscriptions/subscriptions.algo.ts:482
	// subIndex = 0
	intc 0 // 0
	frame_bury 6 // subIndex: uint64

	// contracts/subscriptions/subscriptions.algo.ts:484
	// firstSubscription = this.subscriptionslist(this.txn.sender).exists
	txn Sender
	box_len
	swap
	pop
	frame_bury 7 // firstSubscription: bool

	// *if9_condition
	// contracts/subscriptions/subscriptions.algo.ts:485
	// firstSubscription
	frame_dig 7 // firstSubscription: bool
	bz *if9_else

	// *if9_consequent
	// contracts/subscriptions/subscriptions.algo.ts:486
	// this.subscriptionslist(this.txn.sender).value = 0
	txn Sender
	bytec 3 // 0x0000000000000000
	box_put

	// contracts/subscriptions/subscriptions.algo.ts:487
	// algoMBRFee += subscriptionsListMBR
	frame_dig 5 // algoMBRFee: uint64
	intc 17 // 18500
	+
	frame_bury 5 // algoMBRFee: uint64
	b *if9_end

*if9_else:
	// contracts/subscriptions/subscriptions.algo.ts:489
	// this.subscriptionslist(this.txn.sender).value += 1
	txn Sender
	box_get

	// box value does not exist: this.subscriptionslist(this.txn.sender).value
	assert
	btoi
	intc 2 // 1
	+
	txn Sender
	swap
	itob
	box_put

	// contracts/subscriptions/subscriptions.algo.ts:490
	// subIndex = this.subscriptionslist(this.txn.sender).value
	txn Sender
	box_get

	// box value does not exist: this.subscriptionslist(this.txn.sender).value
	assert
	btoi
	frame_bury 6 // subIndex: uint64

*if9_end:
	// contracts/subscriptions/subscriptions.algo.ts:493
	// subscriptionKey: SubscriptionKey = { address: this.txn.sender, index: subIndex }
	txn Sender
	frame_dig 6 // subIndex: uint64
	itob
	concat
	frame_bury 8 // subscriptionKey: SubscriptionKey

	// contracts/subscriptions/subscriptions.algo.ts:495
	// this.subscriptions(subscriptionKey).value = {
	//             recipient: recipient,
	//             index: index,
	//             startDate: globals.latestTimestamp,
	//             amount: amount,
	//             interval: interval,
	//             asset: AssetID.fromUint64(0),
	//             gate: gate,
	//             lastPayment: globals.latestTimestamp,
	//             streak: 1,
	//             escrowed: 0,
	//         }
	frame_dig 8 // subscriptionKey: SubscriptionKey
	frame_dig -2 // recipient: Address
	frame_dig -5 // index: uint64
	itob
	concat
	global LatestTimestamp
	itob
	concat
	frame_dig -3 // amount: uint64
	itob
	concat
	frame_dig -4 // interval: uint64
	itob
	concat
	bytec 3 // 0x0000000000000000
	concat
	frame_dig 1 // gate: uint64
	itob
	concat
	global LatestTimestamp
	itob
	concat
	bytec 4 // 0x0000000000000001
	concat
	bytec 3 // 0x0000000000000000
	concat
	box_put

	// contracts/subscriptions/subscriptions.algo.ts:508
	// amounts = this.getAmounts(amount)
	frame_dig -3 // amount: uint64
	callsub getAmounts
	frame_bury 9 // amounts: (uint64,uint64,uint64)

	// contracts/subscriptions/subscriptions.algo.ts:510
	// verifyPayTxn(payment, {
	//             receiver: this.app.address,
	//             amount: {
	//                 greaterThanEqualTo: (amount + algoMBRFee),
	//             },
	//         })
	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	frame_dig -3 // amount: uint64
	frame_dig 5 // algoMBRFee: uint64
	+
	>=

	// transaction verification failed: {"txn":"payment","field":"amount","condition":"greaterThanEqualTo","expected":">=(amount + algoMBRFee)"}
	assert

	// contracts/subscriptions/subscriptions.algo.ts:517
	// this.pendingGroup.addPayment({
	//             receiver: this.daoAppID.value.address,
	//             amount: (amounts.akitaFee + amounts.triggerFee),
	//             fee: 0,
	//         })
	itxn_next
	intc 2 //  pay
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:518
	// receiver: this.daoAppID.value.address
	bytec 2 //  "dao_app_id"
	app_global_get
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/subscriptions/subscriptions.algo.ts:519
	// amount: (amounts.akitaFee + amounts.triggerFee)
	frame_dig 9 // amounts: (uint64,uint64,uint64)
	extract 0 8
	btoi
	frame_dig 9 // amounts: (uint64,uint64,uint64)
	extract 8 8
	btoi
	+
	itxn_field Amount

	// contracts/subscriptions/subscriptions.algo.ts:520
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:523
	// this.pendingGroup.addPayment({
	//             receiver: recipient,
	//             amount: amounts.leftOver,
	//             fee: 0,
	//         })
	itxn_next
	intc 2 //  pay
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:524
	// receiver: recipient
	frame_dig -2 // recipient: Address
	itxn_field Receiver

	// contracts/subscriptions/subscriptions.algo.ts:525
	// amount: amounts.leftOver
	frame_dig 9 // amounts: (uint64,uint64,uint64)
	extract 16 8
	btoi
	itxn_field Amount

	// contracts/subscriptions/subscriptions.algo.ts:526
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:529
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// optin(pay,uint64)void
*abi_route_optin:
	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// payment: pay
	txn GroupIndex
	intc 2 // 1
	-
	dup
	gtxns TypeEnum
	intc 2 //  pay
	==

	// argument 1 (payment) for optin must be a pay transaction
	assert

	// execute optin(pay,uint64)void
	callsub optin
	intc 2 // 1
	return

// optin(payment: PayTxn, asset: AssetID): void
optin:
	proto 2 0

	// contracts/subscriptions/subscriptions.algo.ts:534
	// assert(!this.app.address.isOptedInToAsset(asset), errs.ALREADY_OPTED_IN)
	global CurrentApplicationAddress
	frame_dig -2 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	assert

	// contracts/subscriptions/subscriptions.algo.ts:536
	// verifyPayTxn(payment, {
	//             receiver: this.app.address,
	//             amount: globals.assetOptInMinBalance,
	//         })
	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	global AssetOptInMinBalance
	==

	// transaction verification failed: {"txn":"payment","field":"amount","expected":"globals.assetOptInMinBalance"}
	assert

	// contracts/subscriptions/subscriptions.algo.ts:541
	// sendAssetTransfer({
	//             assetReceiver: this.app.address,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//             fee: 0,
	//         })
	itxn_begin
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:542
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/subscriptions/subscriptions.algo.ts:543
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// contracts/subscriptions/subscriptions.algo.ts:544
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/subscriptions/subscriptions.algo.ts:545
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// subscribeAsa(pay,axfer,address,uint64,uint64,uint64,byte[][])void
*abi_route_subscribeAsa:
	// args: byte[][]
	txna ApplicationArgs 5

	// index: uint64
	txna ApplicationArgs 4
	btoi

	// interval: uint64
	txna ApplicationArgs 3
	btoi

	// amount: uint64
	txna ApplicationArgs 2
	btoi

	// recipient: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 4 (recipient) for subscribeAsa must be a address
	assert

	// assetXfer: axfer
	txn GroupIndex
	intc 2 // 1
	-
	dup
	gtxns TypeEnum
	intc 4 //  axfer
	==

	// argument 5 (assetXfer) for subscribeAsa must be a axfer transaction
	assert

	// payment: pay
	txn GroupIndex
	intc 10 // 2
	-
	dup
	gtxns TypeEnum
	intc 2 //  pay
	==

	// argument 6 (payment) for subscribeAsa must be a pay transaction
	assert

	// execute subscribeAsa(pay,axfer,address,uint64,uint64,uint64,byte[][])void
	callsub subscribeAsa
	intc 2 // 1
	return

// subscribeAsa(payment: PayTxn, assetXfer: AssetTransferTxn, recipient: Address, amount: uint64, interval: uint64, index: uint64, args: bytes[]): void
subscribeAsa:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 9

	// contracts/subscriptions/subscriptions.algo.ts:559
	// assert(amount > 3, errs.MIN_AMOUNT_IS_THREE)
	frame_dig -4 // amount: uint64
	intc 14 // 3
	>
	assert

	// contracts/subscriptions/subscriptions.algo.ts:561
	// assert(interval >= 60, errs.MIN_INTERVAL_IS_SIXTY)
	frame_dig -5 // interval: uint64
	intc 15 // 60
	>=
	assert

	// contracts/subscriptions/subscriptions.algo.ts:563
	// blocksKey: BlockListKey = { address: recipient, blocked: this.txn.sender }
	frame_dig -3 // recipient: Address
	txn Sender
	concat
	frame_bury 0 // blocksKey: BlockListKey

	// contracts/subscriptions/subscriptions.algo.ts:565
	// assert(!this.blocks(blocksKey).exists, errs.BLOCKED)
	frame_dig 0 // blocksKey: BlockListKey
	box_len
	swap
	pop
	!
	assert

	// contracts/subscriptions/subscriptions.algo.ts:567
	// gate = 0
	intc 0 // 0
	frame_bury 1 // gate: uint64

	// contracts/subscriptions/subscriptions.algo.ts:569
	// isDonation = index === 0
	frame_dig -6 // index: uint64
	intc 0 // 0
	==
	frame_bury 2 // isDonation: bool

	// *if10_condition
	// contracts/subscriptions/subscriptions.algo.ts:570
	// !isDonation
	frame_dig 2 // isDonation: bool
	!
	bz *if10_end

	// *if10_consequent
	// contracts/subscriptions/subscriptions.algo.ts:571
	// boxKey: ServicesKey = { address: recipient, index: index }
	frame_dig -3 // recipient: Address
	frame_dig -6 // index: uint64
	itob
	concat
	frame_bury 3 // boxKey: ServicesKey

	// contracts/subscriptions/subscriptions.algo.ts:573
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:575
	// service = this.services(boxKey).value
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	frame_bury 4 // storage key//service

	// contracts/subscriptions/subscriptions.algo.ts:577
	// assert(service.status === ServiceStatusActive, errs.SERVICE_IS_NOT_ACTIVE)
	intc 0 // 0
	intc 1 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	intc 0 // 0
	==
	assert

	// contracts/subscriptions/subscriptions.algo.ts:579
	// assert(service.asset === assetXfer.xferAsset, errs.ASA_MISMATCH)
	intc 20 //  headOffset
	intc 1 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns XferAsset
	==
	assert

	// contracts/subscriptions/subscriptions.algo.ts:581
	// assert(this.gate(this.txn.sender, service.gate, args), errs.FAILED_GATE)
	frame_dig -7 // args: bytes[]
	intc 5 //  headOffset
	intc 1 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	txn Sender
	callsub gate
	assert

	// contracts/subscriptions/subscriptions.algo.ts:583
	// amount = service.amount
	intc 21 //  headOffset
	intc 1 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	frame_bury -4 // amount: uint64

	// contracts/subscriptions/subscriptions.algo.ts:584
	// interval = service.interval
	intc 1 //  headOffset
	intc 1 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	frame_bury -5 // interval: uint64

	// contracts/subscriptions/subscriptions.algo.ts:585
	// gate = service.gate
	intc 5 //  headOffset
	intc 1 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	frame_bury 1 // gate: uint64

*if10_end:
	// contracts/subscriptions/subscriptions.algo.ts:588
	// algoMBRFee = subscriptionsMBR
	intc 19 // 53700
	frame_bury 5 // algoMBRFee: uint64

	// contracts/subscriptions/subscriptions.algo.ts:589
	// subIndex = 0
	intc 0 // 0
	frame_bury 6 // subIndex: uint64

	// contracts/subscriptions/subscriptions.algo.ts:591
	// firstSubscription = this.subscriptionslist(this.txn.sender).exists
	txn Sender
	box_len
	swap
	pop
	frame_bury 7 // firstSubscription: bool

	// *if11_condition
	// contracts/subscriptions/subscriptions.algo.ts:592
	// firstSubscription
	frame_dig 7 // firstSubscription: bool
	bz *if11_else

	// *if11_consequent
	// contracts/subscriptions/subscriptions.algo.ts:593
	// this.subscriptionslist(this.txn.sender).value = 0
	txn Sender
	bytec 3 // 0x0000000000000000
	box_put

	// contracts/subscriptions/subscriptions.algo.ts:594
	// algoMBRFee += subscriptionsListMBR
	frame_dig 5 // algoMBRFee: uint64
	intc 17 // 18500
	+
	frame_bury 5 // algoMBRFee: uint64
	b *if11_end

*if11_else:
	// contracts/subscriptions/subscriptions.algo.ts:596
	// this.subscriptionslist(this.txn.sender).value += 1
	txn Sender
	box_get

	// box value does not exist: this.subscriptionslist(this.txn.sender).value
	assert
	btoi
	intc 2 // 1
	+
	txn Sender
	swap
	itob
	box_put

	// contracts/subscriptions/subscriptions.algo.ts:597
	// subIndex = this.subscriptionslist(this.txn.sender).value
	txn Sender
	box_get

	// box value does not exist: this.subscriptionslist(this.txn.sender).value
	assert
	btoi
	frame_bury 6 // subIndex: uint64

*if11_end:
	// *if12_condition
	// contracts/subscriptions/subscriptions.algo.ts:600
	// !this.daoAppID.value.address.isOptedInToAsset(assetXfer.xferAsset)
	bytec 2 //  "dao_app_id"
	app_global_get
	app_params_get AppAddress
	pop
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns XferAsset
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if12_end

	// *if12_consequent
	// contracts/subscriptions/subscriptions.algo.ts:601
	// this.arc58OptInAkitaDAO(assetXfer.xferAsset)
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns XferAsset
	callsub arc58OptInAkitaDAO

	// contracts/subscriptions/subscriptions.algo.ts:602
	// algoMBRFee += globals.assetOptInMinBalance
	frame_dig 5 // algoMBRFee: uint64
	global AssetOptInMinBalance
	+
	frame_bury 5 // algoMBRFee: uint64

*if12_end:
	// contracts/subscriptions/subscriptions.algo.ts:605
	// subscriptionKey: SubscriptionKey = { address: this.txn.sender, index: subIndex }
	txn Sender
	frame_dig 6 // subIndex: uint64
	itob
	concat
	frame_bury 8 // subscriptionKey: SubscriptionKey

	// contracts/subscriptions/subscriptions.algo.ts:607
	// this.subscriptions(subscriptionKey).value = {
	//             recipient: recipient,
	//             index: index,
	//             startDate: globals.latestTimestamp,
	//             amount: amount,
	//             interval: interval,
	//             asset: assetXfer.xferAsset,
	//             gate: gate,
	//             lastPayment: globals.latestTimestamp,
	//             streak: 1,
	//             escrowed: 0,
	//         }
	frame_dig 8 // subscriptionKey: SubscriptionKey
	frame_dig -3 // recipient: Address
	frame_dig -6 // index: uint64
	itob
	concat
	global LatestTimestamp
	itob
	concat
	frame_dig -4 // amount: uint64
	itob
	concat
	frame_dig -5 // interval: uint64
	itob
	concat
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns XferAsset
	itob
	concat
	frame_dig 1 // gate: uint64
	itob
	concat
	global LatestTimestamp
	itob
	concat
	bytec 4 // 0x0000000000000001
	concat
	bytec 3 // 0x0000000000000000
	concat
	box_put

	// contracts/subscriptions/subscriptions.algo.ts:620
	// amounts = this.getAmounts(amount)
	frame_dig -4 // amount: uint64
	callsub getAmounts
	frame_bury 9 // amounts: (uint64,uint64,uint64)

	// contracts/subscriptions/subscriptions.algo.ts:622
	// verifyPayTxn(payment, {
	//             receiver: this.app.address,
	//             amount: {
	//                 greaterThanEqualTo: algoMBRFee,
	//             },
	//         })
	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	frame_dig 5 // algoMBRFee: uint64
	>=

	// transaction verification failed: {"txn":"payment","field":"amount","condition":"greaterThanEqualTo","expected":">=algoMBRFee"}
	assert

	// contracts/subscriptions/subscriptions.algo.ts:629
	// verifyAssetTransferTxn(assetXfer, {
	//             assetReceiver: this.app.address,
	//             assetAmount: amount,
	//         })
	// verify assetReceiver
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"assetXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify assetAmount
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -4 // amount: uint64
	==

	// transaction verification failed: {"txn":"assetXfer","field":"assetAmount","expected":"amount"}
	assert

	// contracts/subscriptions/subscriptions.algo.ts:634
	// this.pendingGroup.addAssetTransfer({
	//             assetReceiver: this.daoAppID.value.address,
	//             xferAsset: assetXfer.xferAsset,
	//             assetAmount: (amounts.akitaFee + amounts.triggerFee),
	//             fee: 0,
	//         })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:635
	// assetReceiver: this.daoAppID.value.address
	bytec 2 //  "dao_app_id"
	app_global_get
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts/subscriptions/subscriptions.algo.ts:636
	// xferAsset: assetXfer.xferAsset
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns XferAsset
	itxn_field XferAsset

	// contracts/subscriptions/subscriptions.algo.ts:637
	// assetAmount: (amounts.akitaFee + amounts.triggerFee)
	frame_dig 9 // amounts: (uint64,uint64,uint64)
	extract 0 8
	btoi
	frame_dig 9 // amounts: (uint64,uint64,uint64)
	extract 8 8
	btoi
	+
	itxn_field AssetAmount

	// contracts/subscriptions/subscriptions.algo.ts:638
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:641
	// this.pendingGroup.addAssetTransfer({
	//             assetReceiver: recipient,
	//             xferAsset: assetXfer.xferAsset,
	//             assetAmount: amounts.leftOver,
	//             fee: 0,
	//         })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:642
	// assetReceiver: recipient
	frame_dig -3 // recipient: Address
	itxn_field AssetReceiver

	// contracts/subscriptions/subscriptions.algo.ts:643
	// xferAsset: assetXfer.xferAsset
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns XferAsset
	itxn_field XferAsset

	// contracts/subscriptions/subscriptions.algo.ts:644
	// assetAmount: amounts.leftOver
	frame_dig 9 // amounts: (uint64,uint64,uint64)
	extract 16 8
	btoi
	itxn_field AssetAmount

	// contracts/subscriptions/subscriptions.algo.ts:645
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:648
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// deposit(pay,uint64)void
*abi_route_deposit:
	// index: uint64
	txna ApplicationArgs 1
	btoi

	// payment: pay
	txn GroupIndex
	intc 2 // 1
	-
	dup
	gtxns TypeEnum
	intc 2 //  pay
	==

	// argument 1 (payment) for deposit must be a pay transaction
	assert

	// execute deposit(pay,uint64)void
	callsub deposit
	intc 2 // 1
	return

// deposit(payment: PayTxn, index: uint64): void
deposit:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/subscriptions/subscriptions.algo.ts:652
	// subKey: SubscriptionKey = { address: this.txn.sender, index: index }
	txn Sender
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // subKey: SubscriptionKey

	// contracts/subscriptions/subscriptions.algo.ts:654
	// assert(this.subscriptions(subKey).exists, errs.SUBSCRIPTION_DOES_NOT_EXIST)
	frame_dig 0 // subKey: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:656
	// sub = this.subscriptions(subKey).value
	frame_dig 0 // subKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/subscriptions/subscriptions.algo.ts:658
	// verifyPayTxn(payment, {
	//             receiver: this.app.address,
	//             amount: sub.amount,
	//         })
	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	frame_dig 0 // subKey: SubscriptionKey
	intc 6 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	==

	// transaction verification failed: {"txn":"payment","field":"amount","expected":"sub.amount"}
	assert

	// contracts/subscriptions/subscriptions.algo.ts:663
	// this.subscriptions(subKey).value.escrowed += sub.amount
	intc 8 //  headOffset
	frame_dig 0 // subKey: SubscriptionKey
	intc 8 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	frame_dig 0 // subKey: SubscriptionKey
	intc 6 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	+
	itob
	frame_dig 0 // subKey: SubscriptionKey
	cover 2
	box_replace
	retsub

// depositAsa(axfer,uint64)void
*abi_route_depositAsa:
	// index: uint64
	txna ApplicationArgs 1
	btoi

	// assetXfer: axfer
	txn GroupIndex
	intc 2 // 1
	-
	dup
	gtxns TypeEnum
	intc 4 //  axfer
	==

	// argument 1 (assetXfer) for depositAsa must be a axfer transaction
	assert

	// execute depositAsa(axfer,uint64)void
	callsub depositAsa
	intc 2 // 1
	return

// depositAsa(assetXfer: AssetTransferTxn, index: uint64): void
depositAsa:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/subscriptions/subscriptions.algo.ts:667
	// subKey: SubscriptionKey = { address: this.txn.sender, index: index }
	txn Sender
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // subKey: SubscriptionKey

	// contracts/subscriptions/subscriptions.algo.ts:669
	// assert(this.subscriptions(subKey).exists, errs.SUBSCRIPTION_DOES_NOT_EXIST)
	frame_dig 0 // subKey: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:671
	// sub = this.subscriptions(subKey).value
	frame_dig 0 // subKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/subscriptions/subscriptions.algo.ts:673
	// verifyAssetTransferTxn(assetXfer, {
	//             assetReceiver: this.app.address,
	//             assetAmount: sub.amount,
	//         })
	// verify assetReceiver
	frame_dig -1 // assetXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"assetXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify assetAmount
	frame_dig -1 // assetXfer: AssetTransferTxn
	gtxns AssetAmount
	frame_dig 0 // subKey: SubscriptionKey
	intc 6 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	==

	// transaction verification failed: {"txn":"assetXfer","field":"assetAmount","expected":"sub.amount"}
	assert

	// contracts/subscriptions/subscriptions.algo.ts:678
	// this.subscriptions(subKey).value.escrowed += sub.amount
	intc 8 //  headOffset
	frame_dig 0 // subKey: SubscriptionKey
	intc 8 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	frame_dig 0 // subKey: SubscriptionKey
	intc 6 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	+
	itob
	frame_dig 0 // subKey: SubscriptionKey
	cover 2
	box_replace
	retsub

// withdraw(uint64,uint64)void
*abi_route_withdraw:
	// amount: uint64
	txna ApplicationArgs 2
	btoi

	// index: uint64
	txna ApplicationArgs 1
	btoi

	// execute withdraw(uint64,uint64)void
	callsub withdraw
	intc 2 // 1
	return

// withdraw(index: uint64, amount: uint64): void
withdraw:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/subscriptions/subscriptions.algo.ts:682
	// subKey: SubscriptionKey = { address: this.txn.sender, index: index }
	txn Sender
	frame_dig -1 // index: uint64
	itob
	concat
	frame_bury 0 // subKey: SubscriptionKey

	// contracts/subscriptions/subscriptions.algo.ts:684
	// assert(this.subscriptions(subKey).exists, errs.SUBSCRIPTION_DOES_NOT_EXIST)
	frame_dig 0 // subKey: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:686
	// sub = this.subscriptions(subKey).value
	frame_dig 0 // subKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/subscriptions/subscriptions.algo.ts:688
	// assert(sub.escrowed > amount, errs.NOT_ENOUGH_FUNDS)
	frame_dig 0 // subKey: SubscriptionKey
	intc 8 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	frame_dig -2 // amount: uint64
	>
	assert

	// *if13_condition
	// contracts/subscriptions/subscriptions.algo.ts:690
	// sub.asset.id !== 0
	frame_dig 0 // subKey: SubscriptionKey
	intc 7 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	intc 0 // 0
	!=
	bz *if13_else

	// *if13_consequent
	// contracts/subscriptions/subscriptions.algo.ts:691
	// sendAssetTransfer({
	//                 assetReceiver: this.txn.sender,
	//                 xferAsset: sub.asset,
	//                 assetAmount: amount,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:692
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/subscriptions/subscriptions.algo.ts:693
	// xferAsset: sub.asset
	frame_dig 0 // subKey: SubscriptionKey
	intc 7 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/subscriptions/subscriptions.algo.ts:694
	// assetAmount: amount
	frame_dig -2 // amount: uint64
	itxn_field AssetAmount

	// contracts/subscriptions/subscriptions.algo.ts:695
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if13_end

*if13_else:
	// contracts/subscriptions/subscriptions.algo.ts:698
	// sendPayment({
	//                 receiver: this.txn.sender,
	//                 amount: amount,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 2 //  pay
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:699
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/subscriptions/subscriptions.algo.ts:700
	// amount: amount
	frame_dig -2 // amount: uint64
	itxn_field Amount

	// contracts/subscriptions/subscriptions.algo.ts:701
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if13_end:
	// contracts/subscriptions/subscriptions.algo.ts:705
	// this.subscriptions(subKey).value.escrowed = 0
	frame_dig 0 // subKey: SubscriptionKey
	intc 8 //  headOffset
	bytec 3 // 0x0000000000000000
	box_replace
	retsub

// triggerPayment(address,uint64,byte[][])void
*abi_route_triggerPayment:
	// args: byte[][]
	txna ApplicationArgs 3

	// index: uint64
	txna ApplicationArgs 2
	btoi

	// address: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 2 (address) for triggerPayment must be a address
	assert

	// execute triggerPayment(address,uint64,byte[][])void
	callsub triggerPayment
	intc 2 // 1
	return

// triggerPayment(address: Address, index: uint64, args: bytes[]): void
triggerPayment:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 5

	// contracts/subscriptions/subscriptions.algo.ts:709
	// subscriptionsKey: SubscriptionKey = { address: address, index: index }
	frame_dig -1 // address: Address
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // subscriptionsKey: SubscriptionKey

	// contracts/subscriptions/subscriptions.algo.ts:712
	// assert(this.subscriptions(subscriptionsKey).exists)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:714
	// sub = this.subscriptions(subscriptionsKey).value
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/subscriptions/subscriptions.algo.ts:716
	// blocksKey: BlockListKey = { address: sub.recipient, blocked: address }
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	frame_dig -1 // address: Address
	concat
	frame_bury 2 // blocksKey: BlockListKey

	// contracts/subscriptions/subscriptions.algo.ts:719
	// assert(!this.blocks(blocksKey).exists, errs.BLOCKED)
	frame_dig 2 // blocksKey: BlockListKey
	box_len
	swap
	pop
	!
	assert

	// *if14_condition
	// contracts/subscriptions/subscriptions.algo.ts:721
	// index > 0
	frame_dig -2 // index: uint64
	intc 0 // 0
	>
	bz *if14_end

	// *if14_consequent
	// contracts/subscriptions/subscriptions.algo.ts:722
	// servicesKey: ServicesKey = { address: sub.recipient, index: sub.index }
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 3 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	itob
	concat
	frame_bury 3 // servicesKey: ServicesKey

	// contracts/subscriptions/subscriptions.algo.ts:724
	// assert(this.services(servicesKey).value.status !== ServiceStatusShutdown, errs.SERVICE_IS_SHUTDOWN)
	intc 0 // 0
	intc 1 // 8
	bytec 1 //  "s"
	frame_dig 3 // servicesKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	intc 10 // 2
	!=
	assert

*if14_end:
	// contracts/subscriptions/subscriptions.algo.ts:728
	// assert(sub.lastPayment < this.getLatestWindowStart(sub.startDate, sub.interval), errs.BAD_WINDOW)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 9 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 12 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 5 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	callsub getLatestWindowStart
	<
	assert

	// contracts/subscriptions/subscriptions.algo.ts:730
	// assert(sub.escrowed > sub.amount, errs.NOT_ENOUGH_FUNDS)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 8 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 6 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	>
	assert

	// contracts/subscriptions/subscriptions.algo.ts:732
	// isAsa = sub.asset.id !== 0
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 7 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	intc 0 // 0
	!=
	frame_bury 4 // isAsa: bool

	// contracts/subscriptions/subscriptions.algo.ts:733
	// amounts = this.getAmounts(sub.amount)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 6 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	callsub getAmounts
	frame_bury 5 // amounts: (uint64,uint64,uint64)

	// *if15_condition
	// contracts/subscriptions/subscriptions.algo.ts:735
	// isAsa
	frame_dig 4 // isAsa: bool
	bz *if15_else

	// *if15_consequent
	// contracts/subscriptions/subscriptions.algo.ts:736
	// this.pendingGroup.addAssetTransfer({
	//                 assetReceiver: this.daoAppID.value.address,
	//                 xferAsset: sub.asset,
	//                 assetAmount: amounts.akitaFee,
	//                 fee: 0,
	//             })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:737
	// assetReceiver: this.daoAppID.value.address
	bytec 2 //  "dao_app_id"
	app_global_get
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts/subscriptions/subscriptions.algo.ts:738
	// xferAsset: sub.asset
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 7 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/subscriptions/subscriptions.algo.ts:739
	// assetAmount: amounts.akitaFee
	frame_dig 5 // amounts: (uint64,uint64,uint64)
	extract 0 8
	btoi
	itxn_field AssetAmount

	// contracts/subscriptions/subscriptions.algo.ts:740
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:743
	// this.pendingGroup.addAssetTransfer({
	//                 assetReceiver: this.txn.sender,
	//                 xferAsset: sub.asset,
	//                 assetAmount: amounts.triggerFee,
	//                 fee: 0,
	//             })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:744
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/subscriptions/subscriptions.algo.ts:745
	// xferAsset: sub.asset
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 7 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/subscriptions/subscriptions.algo.ts:746
	// assetAmount: amounts.triggerFee
	frame_dig 5 // amounts: (uint64,uint64,uint64)
	extract 8 8
	btoi
	itxn_field AssetAmount

	// contracts/subscriptions/subscriptions.algo.ts:747
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:750
	// this.pendingGroup.addAssetTransfer({
	//                 assetReceiver: sub.recipient,
	//                 xferAsset: sub.asset,
	//                 assetAmount: amounts.leftOver,
	//                 fee: 0,
	//             })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:751
	// assetReceiver: sub.recipient
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	itxn_field AssetReceiver

	// contracts/subscriptions/subscriptions.algo.ts:752
	// xferAsset: sub.asset
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 7 //  headOffset
	intc 1 // 8
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/subscriptions/subscriptions.algo.ts:753
	// assetAmount: amounts.leftOver
	frame_dig 5 // amounts: (uint64,uint64,uint64)
	extract 16 8
	btoi
	itxn_field AssetAmount

	// contracts/subscriptions/subscriptions.algo.ts:754
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	b *if15_end

*if15_else:
	// contracts/subscriptions/subscriptions.algo.ts:758
	// this.pendingGroup.addPayment({
	//                 receiver: this.app.address,
	//                 amount: amounts.akitaFee,
	//                 fee: 0,
	//             })
	itxn_next
	intc 2 //  pay
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:759
	// receiver: this.app.address
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/subscriptions/subscriptions.algo.ts:760
	// amount: amounts.akitaFee
	frame_dig 5 // amounts: (uint64,uint64,uint64)
	extract 0 8
	btoi
	itxn_field Amount

	// contracts/subscriptions/subscriptions.algo.ts:761
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:764
	// this.pendingGroup.addPayment({
	//                 receiver: this.txn.sender,
	//                 amount: amounts.triggerFee,
	//                 fee: 0,
	//             })
	itxn_next
	intc 2 //  pay
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:765
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/subscriptions/subscriptions.algo.ts:766
	// amount: amounts.triggerFee
	frame_dig 5 // amounts: (uint64,uint64,uint64)
	extract 8 8
	btoi
	itxn_field Amount

	// contracts/subscriptions/subscriptions.algo.ts:767
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:770
	// this.pendingGroup.addPayment({
	//                 receiver: sub.recipient,
	//                 amount: amounts.leftOver,
	//                 fee: 0,
	//             })
	itxn_next
	intc 2 //  pay
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:771
	// receiver: sub.recipient
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	itxn_field Receiver

	// contracts/subscriptions/subscriptions.algo.ts:772
	// amount: amounts.leftOver
	frame_dig 5 // amounts: (uint64,uint64,uint64)
	extract 16 8
	btoi
	itxn_field Amount

	// contracts/subscriptions/subscriptions.algo.ts:773
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if15_end:
	// contracts/subscriptions/subscriptions.algo.ts:777
	// this.pendingGroup.submit()
	itxn_submit

	// contracts/subscriptions/subscriptions.algo.ts:778
	// this.updateStreak(address, index, 1)
	intc 2 // 1
	frame_dig -2 // index: uint64
	frame_dig -1 // address: Address
	callsub updateStreak

	// contracts/subscriptions/subscriptions.algo.ts:779
	// this.subscriptions(subscriptionsKey).value.lastPayment = globals.latestTimestamp
	intc 9 //  headOffset
	global LatestTimestamp
	itob
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	cover 2
	box_replace
	retsub

// streakCheck(address,uint64)void
*abi_route_streakCheck:
	// index: uint64
	txna ApplicationArgs 2
	btoi

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 1 (sender) for streakCheck must be a address
	assert

	// execute streakCheck(address,uint64)void
	callsub streakCheck
	intc 2 // 1
	return

// streakCheck(sender: Address, index: uint64): void
streakCheck:
	proto 2 0

	// contracts/subscriptions/subscriptions.algo.ts:783
	// this.updateStreak(sender, index, 0)
	intc 0 // 0
	frame_dig -2 // index: uint64
	frame_dig -1 // sender: Address
	callsub updateStreak
	retsub

// setPasses(uint64,address[])void
*abi_route_setPasses:
	// addresses: address[]
	txna ApplicationArgs 2
	extract 2 0

	// index: uint64
	txna ApplicationArgs 1
	btoi

	// execute setPasses(uint64,address[])void
	callsub setPasses
	intc 2 // 1
	return

// setPasses(index: uint64, addresses: Address[]): void
setPasses:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// contracts/subscriptions/subscriptions.algo.ts:787
	// assert(index > 0, errs.NO_DONATIONS)
	frame_dig -1 // index: uint64
	intc 0 // 0
	>
	assert

	// contracts/subscriptions/subscriptions.algo.ts:788
	// subscriptionsKey: SubscriptionKey = { address: this.txn.sender, index: index }
	txn Sender
	frame_dig -1 // index: uint64
	itob
	concat
	frame_bury 0 // subscriptionsKey: SubscriptionKey

	// contracts/subscriptions/subscriptions.algo.ts:790
	// assert(this.subscriptions(subscriptionsKey).exists, errs.SUBSCRIPTION_DOES_NOT_EXIST)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:792
	// sub = this.subscriptions(subscriptionsKey).value
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/subscriptions/subscriptions.algo.ts:794
	// serviceKey: ServicesKey = { address: sub.recipient, index: index }
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	frame_dig -1 // index: uint64
	itob
	concat
	frame_bury 2 // serviceKey: ServicesKey

	// contracts/subscriptions/subscriptions.algo.ts:795
	// service = this.services(serviceKey).value
	bytec 1 //  "s"
	frame_dig 2 // serviceKey: ServicesKey
	concat
	frame_bury 3 // storage key//service

	// contracts/subscriptions/subscriptions.algo.ts:797
	// assert(service.status !== ServiceStatusShutdown, errs.SERVICE_IS_SHUTDOWN)
	intc 0 // 0
	intc 1 // 8
	bytec 1 //  "s"
	frame_dig 2 // serviceKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	intc 10 // 2
	!=
	assert

	// contracts/subscriptions/subscriptions.algo.ts:798
	// assert(service.passes >= addresses.length, errs.PASS_COUNT_OVERFLOW)
	intc 3 //  headOffset
	intc 1 // 8
	bytec 1 //  "s"
	frame_dig 2 // serviceKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	frame_dig -2 // addresses: Address[]
	len
	intc 3 // 32
	/
	>=
	assert

	// contracts/subscriptions/subscriptions.algo.ts:800
	// for (let i = 0; i < addresses.length; i += 1)
	intc 0 // 0
	frame_bury 4 // i: uint64

*for_0:
	// contracts/subscriptions/subscriptions.algo.ts:800
	// i < addresses.length
	frame_dig 4 // i: uint64
	frame_dig -2 // addresses: Address[]
	len
	intc 3 // 32
	/
	<
	bz *for_0_end

	// contracts/subscriptions/subscriptions.algo.ts:801
	// assert(!this.blocks({ address: sub.recipient, blocked: addresses[i] }).exists, errs.BLOCKED)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	frame_dig -2 // addresses: Address[]
	store 255 // full array
	intc 0 //  initial offset
	frame_dig 4 // i: uint64
	intc 3 // 32
	* // acc * typeLength
	+
	load 255 // full array
	swap
	intc 3 // 32
	extract3
	concat
	box_len
	swap
	pop
	!
	assert

*for_0_continue:
	// contracts/subscriptions/subscriptions.algo.ts:800
	// i += 1
	frame_dig 4 // i: uint64
	intc 2 // 1
	+
	frame_bury 4 // i: uint64
	b *for_0

*for_0_end:
	// contracts/subscriptions/subscriptions.algo.ts:804
	// this.passes(subscriptionsKey).value = addresses
	bytec 8 //  "p"
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	concat
	dup
	box_del
	pop
	frame_dig -2 // addresses: Address[]
	dup
	len
	intc 3 // 32
	/
	itob
	extract 6 2
	swap
	concat
	box_put
	retsub

*abi_route_createApplication:
	intc 2 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x4303668e // method "isBlocked(address,address)bool"
	pushbytes 0x0d6a47a3 // method "isShutdown(address,uint64)bool"
	pushbytes 0x3362f0b0 // method "getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])"
	pushbytes 0x603d7297 // method "isFirstSubscription(address)bool"
	pushbytes 0xc07fd4c8 // method "newService(pay,uint64,uint64,uint64,uint64,uint64,byte[59])uint64"
	pushbytes 0x17c8730b // method "pauseService(uint64)void"
	pushbytes 0x8c5e86d5 // method "activateService(uint64)void"
	pushbytes 0x87e055c6 // method "shutdownService(uint64)void"
	pushbytes 0xb59c8a54 // method "block(pay,address)void"
	pushbytes 0xaeebb378 // method "unblock(address)void"
	pushbytes 0xaaf5a3a1 // method "subscribe(pay,address,uint64,uint64,uint64,byte[][])void"
	pushbytes 0x3ea11832 // method "optin(pay,uint64)void"
	pushbytes 0x47b8fced // method "subscribeAsa(pay,axfer,address,uint64,uint64,uint64,byte[][])void"
	pushbytes 0xf2355b55 // method "deposit(pay,uint64)void"
	pushbytes 0x1ac4a758 // method "depositAsa(axfer,uint64)void"
	pushbytes 0xe3aeb25c // method "withdraw(uint64,uint64)void"
	pushbytes 0x12daa571 // method "triggerPayment(address,uint64,byte[][])void"
	pushbytes 0xadb2c60e // method "streakCheck(address,uint64)void"
	pushbytes 0x275203af // method "setPasses(uint64,address[])void"
	txna ApplicationArgs 0
	match *abi_route_isBlocked *abi_route_isShutdown *abi_route_getSubsriptionInfo *abi_route_isFirstSubscription *abi_route_newService *abi_route_pauseService *abi_route_activateService *abi_route_shutdownService *abi_route_block *abi_route_unblock *abi_route_subscribe *abi_route_optin *abi_route_subscribeAsa *abi_route_deposit *abi_route_depositAsa *abi_route_withdraw *abi_route_triggerPayment *abi_route_streakCheck *abi_route_setPasses

	// this contract does not implement the given ABI method for call NoOp
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub