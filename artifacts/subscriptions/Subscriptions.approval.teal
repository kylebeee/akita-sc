#pragma version 10
intcblock 0 1 8 32 4 48 40 64 96 80 2 6 1000 56 88 3 60 18500 28100 53700 16 24
bytecblock 0x 0x73 0x64616f5f6170705f6964 0x0000000000000000 0x0000000000000001 0x151f7c75 0x6c 0x00 "subscription_payment_percentage" "subscription_trigger_percentage" 0x70

// This TEAL was generated by TEALScript v0.106.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 11 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// gate(index: uint64, args: bytes[]): boolean
gate:
	proto 2 1

	// *if0_condition
	// contracts/subscriptions/subscriptions.algo.ts:149
	// index === 0
	frame_dig -1 // index: uint64
	intc 0 // 0
	==
	bz *if0_end

	// *if0_consequent
	// contracts/subscriptions/subscriptions.algo.ts:150
	// return true;
	intc 1 // 1
	retsub

*if0_end:
	// contracts/subscriptions/subscriptions.algo.ts:153
	// return sendMethodCall<typeof Gate.prototype.check, boolean>({
	//             applicationID: AppID.fromUint64(AkitaAppIDsGate),
	//             methodArgs: [index, args],
	//             fee: 0
	//         });
	itxn_begin
	intc 11 //  appl
	itxn_field TypeEnum
	pushbytes 0xb5feb87b // method "check(uint64,byte[][])bool"
	itxn_field ApplicationArgs

	// contracts/subscriptions/subscriptions.algo.ts:154
	// applicationID: AppID.fromUint64(AkitaAppIDsGate)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/subscriptions/subscriptions.algo.ts:155
	// methodArgs: [index, args]
	frame_dig -1 // index: uint64
	itob
	itxn_field ApplicationArgs
	frame_dig -2 // args: bytes[]
	itxn_field ApplicationArgs

	// contracts/subscriptions/subscriptions.algo.ts:156
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	retsub

// getLatestWindowStart(startDate: uint64, interval: uint64): uint64
getLatestWindowStart:
	proto 2 1

	// contracts/subscriptions/subscriptions.algo.ts:161
	// return globals.latestTimestamp - ((globals.latestTimestamp - startDate) % interval);
	global LatestTimestamp
	global LatestTimestamp
	frame_dig -1 // startDate: uint64
	-
	frame_dig -2 // interval: uint64
	%
	-
	retsub

// updateStreak(sender: Address, index: uint64, elseStreak: uint64): void
updateStreak:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts/subscriptions/subscriptions.algo.ts:165
	// subKey: SubscriptionKey = { address: sender, index: index }
	frame_dig -1 // sender: Address
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // subKey: SubscriptionKey

	// contracts/subscriptions/subscriptions.algo.ts:166
	// sub = this.subscriptions(subKey).value
	frame_dig 0 // subKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/subscriptions/subscriptions.algo.ts:168
	// currentWindowStart = this.getLatestWindowStart(sub.startDate, sub.interval)
	frame_dig 0 // subKey: SubscriptionKey
	intc 13 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 0 // subKey: SubscriptionKey
	intc 6 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	callsub getLatestWindowStart
	frame_bury 2 // currentWindowStart: uint64

	// contracts/subscriptions/subscriptions.algo.ts:169
	// lastWindowStart = (currentWindowStart - sub.interval)
	frame_dig 2 // currentWindowStart: uint64
	frame_dig 0 // subKey: SubscriptionKey
	intc 13 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	-
	frame_bury 3 // lastWindowStart: uint64

	// *if1_condition
	// contracts/subscriptions/subscriptions.algo.ts:171
	// sub.lastPayment < lastWindowStart
	frame_dig 0 // subKey: SubscriptionKey
	intc 9 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 3 // lastWindowStart: uint64
	<
	bz *if1_end

	// *if1_consequent
	// contracts/subscriptions/subscriptions.algo.ts:173
	// this.subscriptions(subKey).value.streak = elseStreak
	intc 14 //  headOffset
	frame_dig -3 // elseStreak: uint64
	itob
	frame_dig 0 // subKey: SubscriptionKey
	cover 2
	box_replace

	// contracts/subscriptions/subscriptions.algo.ts:174
	// return;
	retsub

*if1_end:
	// *if2_condition
	// contracts/subscriptions/subscriptions.algo.ts:180
	// sub.lastPayment >= lastWindowStart && !(sub.lastPayment >= currentWindowStart)
	frame_dig 0 // subKey: SubscriptionKey
	intc 9 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 3 // lastWindowStart: uint64
	>=
	dup
	bz *skip_and0
	frame_dig 0 // subKey: SubscriptionKey
	intc 9 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 2 // currentWindowStart: uint64
	>=
	!
	&&

*skip_and0:
	bz *if2_end

	// *if2_consequent
	// contracts/subscriptions/subscriptions.algo.ts:181
	// this.subscriptions(subKey).value.streak += 1
	intc 14 //  headOffset
	frame_dig 0 // subKey: SubscriptionKey
	intc 14 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	intc 1 // 1
	+
	itob
	frame_dig 0 // subKey: SubscriptionKey
	cover 2
	box_replace

*if2_end:
	retsub

// arc58OptIn(recipientAppID: AppID, asset: AssetID): void
arc58OptIn:
	proto 2 0

	// contracts/subscriptions/subscriptions.algo.ts:186
	// this.pendingGroup.addPayment({
	//             amount: globals.assetOptInMinBalance,
	//             receiver: this.app.address,
	//             fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:187
	// amount: globals.assetOptInMinBalance
	global AssetOptInMinBalance
	itxn_field Amount

	// contracts/subscriptions/subscriptions.algo.ts:188
	// receiver: this.app.address
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/subscriptions/subscriptions.algo.ts:189
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:192
	// this.pendingGroup.addMethodCall<typeof AkitaDAO.prototype.arc58_rekeyToPlugin, void>({
	//             applicationID: recipientAppID,
	//             methodArgs: [
	//                 AppID.fromUint64(AkitaAppIDsOptinPlugin),
	//                 [],
	//                 EMPTY_BYTES_32,
	//             ],
	//             fee: 0,
	//         })
	itxn_next
	intc 11 //  appl
	itxn_field TypeEnum
	pushbytes 0x42089fbe // method "arc58_rekeyToPlugin(uint64,uint64[],byte[32])void"
	itxn_field ApplicationArgs

	// contracts/subscriptions/subscriptions.algo.ts:193
	// applicationID: recipientAppID
	frame_dig -1 // recipientAppID: AppID
	itxn_field ApplicationID

	// contracts/subscriptions/subscriptions.algo.ts:194
	// methodArgs: [
	//                 AppID.fromUint64(AkitaAppIDsOptinPlugin),
	//                 [],
	//                 EMPTY_BYTES_32,
	//             ]
	bytec 3 // 0x0000000000000000
	itxn_field ApplicationArgs
	pushbytes 0x0000
	itxn_field ApplicationArgs
	pushbytes 0x4141414141414141414141414141414141414141414141414141414141414141 // "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
	itxn_field ApplicationArgs

	// contracts/subscriptions/subscriptions.algo.ts:199
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:202
	// this.pendingGroup.addMethodCall<typeof OptInPlugin.prototype.optInToAsset, void>({
	//             applicationID: AppID.fromUint64(AkitaAppIDsOptinPlugin),
	//             methodArgs: [
	//                 recipientAppID,
	//                 true,
	//                 asset,
	//                 {
	//                     receiver: recipientAppID.address,
	//                     amount: globals.assetOptInMinBalance,
	//                     fee: 0,
	//                 }
	//             ],
	//             fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:209
	// receiver: recipientAppID.address
	frame_dig -1 // recipientAppID: AppID
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/subscriptions/subscriptions.algo.ts:210
	// amount: globals.assetOptInMinBalance
	global AssetOptInMinBalance
	itxn_field Amount

	// contracts/subscriptions/subscriptions.algo.ts:211
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 11 //  appl
	itxn_field TypeEnum
	pushbytes 0xbfcbeee9 // method "optInToAsset(uint64,bool,uint64,pay)void"
	itxn_field ApplicationArgs

	// contracts/subscriptions/subscriptions.algo.ts:203
	// applicationID: AppID.fromUint64(AkitaAppIDsOptinPlugin)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/subscriptions/subscriptions.algo.ts:204
	// methodArgs: [
	//                 recipientAppID,
	//                 true,
	//                 asset,
	//                 {
	//                     receiver: recipientAppID.address,
	//                     amount: globals.assetOptInMinBalance,
	//                     fee: 0,
	//                 }
	//             ]
	frame_dig -1 // recipientAppID: AppID
	itob
	itxn_field ApplicationArgs
	intc 1 // 1
	bytec 7 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	itxn_field ApplicationArgs
	frame_dig -2 // asset: AssetID
	itob
	itxn_field ApplicationArgs

	// contracts/subscriptions/subscriptions.algo.ts:214
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:217
	// this.pendingGroup.addMethodCall<typeof AbstractedAccount.prototype.arc58_verifyAuthAddr, void>({
	//             applicationID: recipientAppID,
	//             fee: 0,
	//         })
	itxn_next
	intc 11 //  appl
	itxn_field TypeEnum
	pushbytes 0x0f885493 // method "arc58_verifyAuthAddr()void"
	itxn_field ApplicationArgs

	// contracts/subscriptions/subscriptions.algo.ts:218
	// applicationID: recipientAppID
	frame_dig -1 // recipientAppID: AppID
	itxn_field ApplicationID

	// contracts/subscriptions/subscriptions.algo.ts:219
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:222
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// isBlocked(address,address)bool
*abi_route_isBlocked:
	// The ABI return prefix
	bytec 5 // 0x151f7c75

	// address: address
	txna ApplicationArgs 2
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for isBlocked must be a address
	assert

	// merchant: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 1 (merchant) for isBlocked must be a address
	assert

	// execute isBlocked(address,address)bool
	callsub isBlocked
	bytec 7 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	concat
	log
	intc 1 // 1
	return

// isBlocked(merchant: Address, address: Address): boolean
//
// isBlocked checks if an address is blocked for a merchant
// @param merchant The merchant address to be checked
// @param address The address to be checked
isBlocked:
	proto 2 1

	// contracts/subscriptions/subscriptions.algo.ts:232
	// return this.blocks({ address: merchant, blocked: address }).exists;
	frame_dig -1 // merchant: Address
	frame_dig -2 // address: Address
	concat
	box_len
	swap
	pop
	retsub

// isShutdown(address,uint64)bool
*abi_route_isShutdown:
	// The ABI return prefix
	bytec 5 // 0x151f7c75

	// boxIndex: uint64
	txna ApplicationArgs 2
	btoi

	// merchant: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 1 (merchant) for isShutdown must be a address
	assert

	// execute isShutdown(address,uint64)bool
	callsub isShutdown
	bytec 7 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	concat
	log
	intc 1 // 1
	return

// isShutdown(merchant: Address, boxIndex: uint64): boolean
//
// serviceIsActive checks if an service is shutdown
isShutdown:
	proto 2 1

	// contracts/subscriptions/subscriptions.algo.ts:240
	// return this.services({ address: merchant, index: boxIndex }).value.status === ServiceStatusShutdown;
	intc 0 // 0
	intc 2 // 8
	bytec 1 //  "s"
	frame_dig -1 // merchant: Address
	frame_dig -2 // boxIndex: uint64
	itob
	concat
	concat
	cover 2
	box_extract
	btoi
	intc 10 // 2
	==
	retsub

// getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])
*abi_route_getSubsriptionInfo:
	// The ABI return prefix
	bytec 5 // 0x151f7c75

	// index: uint64
	txna ApplicationArgs 2
	btoi

	// address: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 1 (address) for getSubsriptionInfo must be a address
	assert

	// execute getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])
	callsub getSubsriptionInfo
	concat
	log
	intc 1 // 1
	return

// getSubsriptionInfo(address: Address, index: uint64): SubscriptionInfoWithPasses
getSubsriptionInfo:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/subscriptions/subscriptions.algo.ts:245
	// key: SubscriptionKey = { address: address, index: index }
	frame_dig -1 // address: Address
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // key: SubscriptionKey

	// contracts/subscriptions/subscriptions.algo.ts:247
	// assert(this.subscriptions(key).exists, errs.SUBSCRIPTION_DOES_NOT_EXIST)
	frame_dig 0 // key: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:249
	// subInfo = this.subscriptions(key).value
	frame_dig 0 // key: SubscriptionKey
	frame_bury 1 // storage key//subInfo

	// contracts/subscriptions/subscriptions.algo.ts:251
	// passes: Address[] = []
	bytec 0 // 0x
	frame_bury 2 // passes: Address[]

	// *if3_condition
	// contracts/subscriptions/subscriptions.algo.ts:252
	// this.passes(key).exists
	bytec 10 //  "p"
	frame_dig 0 // key: SubscriptionKey
	concat
	box_len
	swap
	pop
	bz *if3_end

	// *if3_consequent
	// contracts/subscriptions/subscriptions.algo.ts:253
	// passes = this.passes(key).value
	bytec 10 //  "p"
	frame_dig 0 // key: SubscriptionKey
	concat
	box_get

	// box value does not exist: this.passes(key).value
	assert
	extract 2 0
	frame_bury 2 // passes: Address[]

*if3_end:
	// contracts/subscriptions/subscriptions.algo.ts:256
	// return {
	//             recipient: subInfo.recipient,
	//             index: subInfo.index,
	//             startDate: subInfo.startDate,
	//             amount: subInfo.amount,
	//             interval: subInfo.interval,
	//             asset: subInfo.asset,
	//             gate: subInfo.gate,
	//             lastPayment: subInfo.lastPayment,
	//             streak: subInfo.streak,
	//             passes: passes,
	//         };
	bytec 0 //  initial head
	bytec 0 //  initial tail
	pushbytes 0x0062 // initial head offset
	frame_dig 0 // key: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 3 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 6 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 13 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 7 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	pushint 72 // headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 9 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // key: SubscriptionKey
	intc 14 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 2 // passes: Address[]
	dup
	len
	intc 3 // 32
	/
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// isFirstSubscription(address)bool
*abi_route_isFirstSubscription:
	// The ABI return prefix
	bytec 5 // 0x151f7c75

	// address: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for isFirstSubscription must be a address
	assert

	// execute isFirstSubscription(address)bool
	callsub isFirstSubscription
	bytec 7 // 0x00
	intc 0 // 0
	uncover 2
	setbit
	concat
	log
	intc 1 // 1
	return

// isFirstSubscription(address: Address): boolean
isFirstSubscription:
	proto 1 1

	// contracts/subscriptions/subscriptions.algo.ts:272
	// return !this.subscriptionslist(address).exists;
	frame_dig -1 // address: Address
	box_len
	swap
	pop
	!
	retsub

// newService(pay,uint64,uint64,uint64,uint64,uint64,byte[59])uint64
*abi_route_newService:
	// The ABI return prefix
	bytec 5 // 0x151f7c75

	// cid: byte[59]
	txna ApplicationArgs 6
	dup
	len
	pushint 59
	==

	// argument 0 (cid) for newService must be a byte[59]
	assert

	// gate: uint64
	txna ApplicationArgs 5
	btoi

	// passes: uint64
	txna ApplicationArgs 4
	btoi

	// amount: uint64
	txna ApplicationArgs 3
	btoi

	// asset: uint64
	txna ApplicationArgs 2
	btoi

	// interval: uint64
	txna ApplicationArgs 1
	btoi

	// payment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 6 (payment) for newService must be a pay transaction
	assert

	// execute newService(pay,uint64,uint64,uint64,uint64,uint64,byte[59])uint64
	callsub newService
	itob
	concat
	log
	intc 1 // 1
	return

// newService(payment: PayTxn, interval: uint64, asset: AssetID, amount: uint64, passes: uint64, gate: uint64, cid: bytes<59>): uint64
//
// newService creates a new service for a merchant
// @param payment The payment for the service creation
// @param interval The interval in seconds
// @param asset The asa to be used for the subscription
// @param amount The amount of the asa to be used for the subscription
// @param passes The number of accounts the subscription can be shared with
// @param gate The gate to be used for the subscription
// @param cid The ipfs cid of the subscription contract
// or upgrade the subscription to a different service from the user without losing their streak
newService:
	proto 7 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts/subscriptions/subscriptions.algo.ts:295
	// index: uint64 = 0
	intc 0 // 0
	frame_bury 0 // index: uint64

	// *if4_condition
	// contracts/subscriptions/subscriptions.algo.ts:296
	// this.serviceslist(this.txn.sender).exists
	bytec 6 //  "l"
	txn Sender
	concat
	box_len
	swap
	pop
	bz *if4_else

	// *if4_consequent
	// contracts/subscriptions/subscriptions.algo.ts:297
	// index = this.serviceslist(this.txn.sender).value
	bytec 6 //  "l"
	txn Sender
	concat
	box_get

	// box value does not exist: this.serviceslist(this.txn.sender).value
	assert
	btoi
	frame_bury 0 // index: uint64

	// contracts/subscriptions/subscriptions.algo.ts:298
	// this.serviceslist(this.txn.sender).value += 1
	bytec 6 //  "l"
	txn Sender
	concat
	box_get

	// box value does not exist: this.serviceslist(this.txn.sender).value
	assert
	btoi
	intc 1 // 1
	+
	bytec 6 //  "l"
	txn Sender
	concat
	swap
	itob
	box_put
	b *if4_end

*if4_else:
	// contracts/subscriptions/subscriptions.algo.ts:300
	// index = 1
	intc 1 // 1
	frame_bury 0 // index: uint64

	// contracts/subscriptions/subscriptions.algo.ts:301
	// this.serviceslist(this.txn.sender).value = 1
	bytec 6 //  "l"
	txn Sender
	concat
	bytec 4 // 0x0000000000000001
	box_put

*if4_end:
	// contracts/subscriptions/subscriptions.algo.ts:304
	// boxKey: ServicesKey = { address: this.txn.sender, index: index }
	txn Sender
	frame_dig 0 // index: uint64
	itob
	concat
	frame_bury 1 // boxKey: ServicesKey

	// contracts/subscriptions/subscriptions.algo.ts:307
	// assert(amount > 3, errs.MIN_AMOUNT_IS_THREE)
	frame_dig -4 // amount: uint64
	intc 15 // 3
	>
	assert

	// contracts/subscriptions/subscriptions.algo.ts:309
	// assert(interval >= 60, errs.MIN_INTERVAL_IS_SIXTY)
	frame_dig -2 // interval: uint64
	intc 16 // 60
	>=
	assert

	// contracts/subscriptions/subscriptions.algo.ts:311
	// assert(passes <= 5, errs.MAX_PASSES_IS_FIVE)
	frame_dig -5 // passes: uint64
	pushint 5
	<=
	assert

	// contracts/subscriptions/subscriptions.algo.ts:313
	// serviceCreationFee = this.daoAppID.value.globalState(SUBSCRIPTION_SERVICE_CREATION_FEE) as uint64
	bytec 2 //  "dao_app_id"
	app_global_get
	pushbytes "subscription_service_creation_fee"
	app_global_get_ex

	// global state value does not exist: this.daoAppID.value.globalState(SUBSCRIPTION_SERVICE_CREATION_FEE)
	assert
	frame_bury 2 // serviceCreationFee: uint64

	// contracts/subscriptions/subscriptions.algo.ts:315
	// requiredAmount = serviceCreationFee
	frame_dig 2 // serviceCreationFee: uint64
	frame_bury 3 // requiredAmount: uint64

	// *if5_condition
	// contracts/subscriptions/subscriptions.algo.ts:316
	// asset.id !== 0
	frame_dig -3 // asset: AssetID
	intc 0 // 0
	!=
	bz *if5_end

	// *if5_consequent
	// contracts/subscriptions/subscriptions.algo.ts:317
	// requiredAmount += globals.assetOptInMinBalance
	frame_dig 3 // requiredAmount: uint64
	global AssetOptInMinBalance
	+
	frame_bury 3 // requiredAmount: uint64

*if5_end:
	// contracts/subscriptions/subscriptions.algo.ts:320
	// verifyPayTxn(payment, {
	//             amount: requiredAmount,
	//             receiver: this.app.address,
	//         })
	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	frame_dig 3 // requiredAmount: uint64
	==

	// transaction verification failed: {"txn":"payment","field":"amount","expected":"requiredAmount"}
	assert

	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// contracts/subscriptions/subscriptions.algo.ts:325
	// this.services(boxKey).value = {
	//             status: ServiceStatusPaused,
	//             interval: interval,
	//             asset: asset,
	//             amount: amount,
	//             passes: passes,
	//             gate: gate,
	//             cid: cid,
	//         }
	bytec 1 //  "s"
	frame_dig 1 // boxKey: ServicesKey
	concat
	bytec 4 // 0x0000000000000001
	frame_dig -2 // interval: uint64
	itob
	concat
	frame_dig -3 // asset: AssetID
	itob
	concat
	frame_dig -4 // amount: uint64
	itob
	concat
	frame_dig -5 // passes: uint64
	itob
	concat
	frame_dig -6 // gate: uint64
	itob
	concat
	frame_dig -7 // cid: bytes<59>
	concat
	box_put

	// contracts/subscriptions/subscriptions.algo.ts:335
	// return index;
	frame_dig 0 // index: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// pauseService(uint64)void
*abi_route_pauseService:
	// index: uint64
	txna ApplicationArgs 1
	btoi

	// execute pauseService(uint64)void
	callsub pauseService
	intc 1 // 1
	return

// pauseService(index: uint64): void
//
// pauseService pauses a service for a merchant
// it does not shutdown pre-existing subscriptions
// it simply prevents new subscriptions from being created
// for a specific service
// @param index The index of the box to be used for the subscription
pauseService:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/subscriptions/subscriptions.algo.ts:346
	// boxKey: ServicesKey = { address: this.txn.sender, index: index }
	txn Sender
	frame_dig -1 // index: uint64
	itob
	concat
	frame_bury 0 // boxKey: ServicesKey

	// contracts/subscriptions/subscriptions.algo.ts:349
	// assert(index > 0, errs.SERVICE_INDEX_MUST_BE_ABOVE_ZERO)
	frame_dig -1 // index: uint64
	intc 0 // 0
	>
	assert

	// contracts/subscriptions/subscriptions.algo.ts:351
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:353
	// assert(this.services(boxKey).value.status === ServiceStatusActive, errs.SERVICE_IS_NOT_ACTIVE)
	intc 0 // 0
	intc 2 // 8
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	intc 0 // 0
	==
	assert

	// contracts/subscriptions/subscriptions.algo.ts:355
	// this.services(boxKey).value.status = ServiceStatusPaused
	intc 0 // 0
	bytec 4 // 0x0000000000000001
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_replace
	retsub

// activateService(uint64)void
*abi_route_activateService:
	// index: uint64
	txna ApplicationArgs 1
	btoi

	// execute activateService(uint64)void
	callsub activateService
	intc 1 // 1
	return

// activateService(index: uint64): void
//
// activateService activates an service for a merchant
//
// @param index The index of the box to be used for the subscription
activateService:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/subscriptions/subscriptions.algo.ts:364
	// boxKey: ServicesKey = { address: this.txn.sender, index: index }
	txn Sender
	frame_dig -1 // index: uint64
	itob
	concat
	frame_bury 0 // boxKey: ServicesKey

	// contracts/subscriptions/subscriptions.algo.ts:367
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:369
	// assert(this.services(boxKey).value.status === ServiceStatusPaused, errs.SERVICE_IS_NOT_PAUSED)
	intc 0 // 0
	intc 2 // 8
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	intc 1 // 1
	==
	assert

	// contracts/subscriptions/subscriptions.algo.ts:371
	// this.services(boxKey).value.status = ServiceStatusActive
	intc 0 // 0
	bytec 3 // 0x0000000000000000
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_replace
	retsub

// shutdownService(uint64)void
*abi_route_shutdownService:
	// index: uint64
	txna ApplicationArgs 1
	btoi

	// execute shutdownService(uint64)void
	callsub shutdownService
	intc 1 // 1
	return

// shutdownService(index: uint64): void
//
// shutdownService permanently shuts down an service for a merchant
// it also shutsdown pre-existing subscriptions
// @param index The index of the box to be used for the subscription
shutdownService:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/subscriptions/subscriptions.algo.ts:380
	// boxKey: ServicesKey = { address: this.txn.sender, index: index }
	txn Sender
	frame_dig -1 // index: uint64
	itob
	concat
	frame_bury 0 // boxKey: ServicesKey

	// contracts/subscriptions/subscriptions.algo.ts:382
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:384
	// assert(this.services(boxKey).value.status !== ServiceStatusShutdown, errs.SERVICE_IS_SHUTDOWN)
	intc 0 // 0
	intc 2 // 8
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	intc 10 // 2
	!=
	assert

	// contracts/subscriptions/subscriptions.algo.ts:386
	// this.services(boxKey).value.status = ServiceStatusShutdown
	intc 0 // 0
	pushbytes 0x0000000000000002
	bytec 1 //  "s"
	frame_dig 0 // boxKey: ServicesKey
	concat
	cover 2
	box_replace
	retsub

// block(pay,address)void
*abi_route_block:
	// address: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for block must be a address
	assert

	// payment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 1 (payment) for block must be a pay transaction
	assert

	// execute block(pay,address)void
	callsub block
	intc 1 // 1
	return

// block(payment: PayTxn, address: Address): void
//
// block blacklists an address for a merchant
// @param payment The payment to cover mbr for blocking
// @param address The address to be blocked
block:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/subscriptions/subscriptions.algo.ts:395
	// boxKey: BlockListKey = { address: this.txn.sender, blocked: address }
	txn Sender
	frame_dig -2 // address: Address
	concat
	frame_bury 0 // boxKey: BlockListKey

	// contracts/subscriptions/subscriptions.algo.ts:398
	// assert(!this.blocks(boxKey).exists, errs.USER_ALREADY_BLOCKED)
	frame_dig 0 // boxKey: BlockListKey
	box_len
	swap
	pop
	!
	assert

	// contracts/subscriptions/subscriptions.algo.ts:401
	// verifyPayTxn(payment, {
	//             receiver: this.app.address,
	//             amount: blockMBR,
	//         })
	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	intc 18 // 28100
	==

	// transaction verification failed: {"txn":"payment","field":"amount","expected":"blockMBR"}
	assert

	// contracts/subscriptions/subscriptions.algo.ts:406
	// this.blocks(boxKey).create(0)
	frame_dig 0 // boxKey: BlockListKey
	intc 0 // 0
	box_create
	pop
	retsub

// unblock(address)void
*abi_route_unblock:
	// address: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 0 (address) for unblock must be a address
	assert

	// execute unblock(address)void
	callsub unblock
	intc 1 // 1
	return

// unblock(address: Address): void
//
// unblock removes an address from a merchants blocks
// @param address The address to be unblocked
unblock:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/subscriptions/subscriptions.algo.ts:414
	// boxKey: BlockListKey = { address: this.txn.sender, blocked: address }
	txn Sender
	frame_dig -1 // address: Address
	concat
	frame_bury 0 // boxKey: BlockListKey

	// contracts/subscriptions/subscriptions.algo.ts:417
	// assert(this.blocks(boxKey).exists, errs.USER_NOT_BLOCKED)
	frame_dig 0 // boxKey: BlockListKey
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:419
	// this.blocks(boxKey).delete()
	frame_dig 0 // boxKey: BlockListKey
	box_del

	// contracts/subscriptions/subscriptions.algo.ts:421
	// sendPayment({
	//             receiver: this.txn.sender,
	//             amount: blockMBR,
	//             fee: 0,
	//         })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:422
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/subscriptions/subscriptions.algo.ts:423
	// amount: blockMBR
	intc 18 // 28100
	itxn_field Amount

	// contracts/subscriptions/subscriptions.algo.ts:424
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// subscribe(pay,address,uint64,uint64,uint64,byte[][])void
*abi_route_subscribe:
	// args: byte[][]
	txna ApplicationArgs 5

	// index: uint64
	txna ApplicationArgs 4
	btoi

	// interval: uint64
	txna ApplicationArgs 3
	btoi

	// amount: uint64
	txna ApplicationArgs 2
	btoi

	// recipient: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 4 (recipient) for subscribe must be a address
	assert

	// payment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 5 (payment) for subscribe must be a pay transaction
	assert

	// execute subscribe(pay,address,uint64,uint64,uint64,byte[][])void
	callsub subscribe
	intc 1 // 1
	return

// subscribe(payment: PayTxn, recipient: Address, amount: uint64, interval: uint64, index: uint64, args: bytes[]): void
subscribe:
	proto 6 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 12

	// contracts/subscriptions/subscriptions.algo.ts:437
	// assert(amount > 3, errs.MIN_AMOUNT_IS_THREE)
	frame_dig -3 // amount: uint64
	intc 15 // 3
	>
	assert

	// contracts/subscriptions/subscriptions.algo.ts:439
	// assert(interval >= 60, errs.MIN_INTERVAL_IS_SIXTY)
	frame_dig -4 // interval: uint64
	intc 16 // 60
	>=
	assert

	// contracts/subscriptions/subscriptions.algo.ts:441
	// blocksKey: BlockListKey = { address: recipient, blocked: this.txn.sender }
	frame_dig -2 // recipient: Address
	txn Sender
	concat
	frame_bury 0 // blocksKey: BlockListKey

	// contracts/subscriptions/subscriptions.algo.ts:443
	// assert(!this.blocks(blocksKey).exists, errs.BLOCKED)
	frame_dig 0 // blocksKey: BlockListKey
	box_len
	swap
	pop
	!
	assert

	// contracts/subscriptions/subscriptions.algo.ts:445
	// gate = 0
	intc 0 // 0
	frame_bury 1 // gate: uint64

	// contracts/subscriptions/subscriptions.algo.ts:447
	// isDonation = index === 0
	frame_dig -5 // index: uint64
	intc 0 // 0
	==
	frame_bury 2 // isDonation: bool

	// *if6_condition
	// contracts/subscriptions/subscriptions.algo.ts:448
	// !isDonation
	frame_dig 2 // isDonation: bool
	!
	bz *if6_end

	// *if6_consequent
	// contracts/subscriptions/subscriptions.algo.ts:449
	// boxKey: ServicesKey = { address: recipient, index: index }
	frame_dig -2 // recipient: Address
	frame_dig -5 // index: uint64
	itob
	concat
	frame_bury 3 // boxKey: ServicesKey

	// contracts/subscriptions/subscriptions.algo.ts:451
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:453
	// service = this.services(boxKey).value
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	frame_bury 4 // storage key//service

	// contracts/subscriptions/subscriptions.algo.ts:455
	// assert(service.status === ServiceStatusActive, errs.SERVICE_IS_NOT_ACTIVE)
	intc 0 // 0
	intc 2 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	intc 0 // 0
	==
	assert

	// contracts/subscriptions/subscriptions.algo.ts:457
	// assert(service.asset.id === 0, errs.ASA_MISMATCH)
	intc 20 //  headOffset
	intc 2 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	intc 0 // 0
	==
	assert

	// contracts/subscriptions/subscriptions.algo.ts:459
	// assert(this.gate(service.gate, args), errs.FAILED_GATE)
	frame_dig -6 // args: bytes[]
	intc 6 //  headOffset
	intc 2 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	callsub gate
	assert

	// contracts/subscriptions/subscriptions.algo.ts:461
	// amount = service.amount
	intc 21 //  headOffset
	intc 2 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	frame_bury -3 // amount: uint64

	// contracts/subscriptions/subscriptions.algo.ts:462
	// interval = service.interval
	intc 2 //  headOffset
	intc 2 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	frame_bury -4 // interval: uint64

	// contracts/subscriptions/subscriptions.algo.ts:463
	// gate = service.gate
	intc 6 //  headOffset
	intc 2 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	frame_bury 1 // gate: uint64

*if6_end:
	// contracts/subscriptions/subscriptions.algo.ts:466
	// algoMBRFee = subscriptionsMBR
	intc 19 // 53700
	frame_bury 5 // algoMBRFee: uint64

	// contracts/subscriptions/subscriptions.algo.ts:467
	// subIndex = 0
	intc 0 // 0
	frame_bury 6 // subIndex: uint64

	// contracts/subscriptions/subscriptions.algo.ts:469
	// firstSubscription = this.subscriptionslist(this.txn.sender).exists
	txn Sender
	box_len
	swap
	pop
	frame_bury 7 // firstSubscription: bool

	// *if7_condition
	// contracts/subscriptions/subscriptions.algo.ts:470
	// firstSubscription
	frame_dig 7 // firstSubscription: bool
	bz *if7_else

	// *if7_consequent
	// contracts/subscriptions/subscriptions.algo.ts:471
	// this.subscriptionslist(this.txn.sender).value = 0
	txn Sender
	bytec 3 // 0x0000000000000000
	box_put

	// contracts/subscriptions/subscriptions.algo.ts:472
	// algoMBRFee += subscriptionsListMBR
	frame_dig 5 // algoMBRFee: uint64
	intc 17 // 18500
	+
	frame_bury 5 // algoMBRFee: uint64
	b *if7_end

*if7_else:
	// contracts/subscriptions/subscriptions.algo.ts:474
	// this.subscriptionslist(this.txn.sender).value += 1
	txn Sender
	box_get

	// box value does not exist: this.subscriptionslist(this.txn.sender).value
	assert
	btoi
	intc 1 // 1
	+
	txn Sender
	swap
	itob
	box_put

	// contracts/subscriptions/subscriptions.algo.ts:475
	// subIndex = this.subscriptionslist(this.txn.sender).value
	txn Sender
	box_get

	// box value does not exist: this.subscriptionslist(this.txn.sender).value
	assert
	btoi
	frame_bury 6 // subIndex: uint64

*if7_end:
	// contracts/subscriptions/subscriptions.algo.ts:478
	// subscriptionKey: SubscriptionKey = { address: this.txn.sender, index: subIndex }
	txn Sender
	frame_dig 6 // subIndex: uint64
	itob
	concat
	frame_bury 8 // subscriptionKey: SubscriptionKey

	// contracts/subscriptions/subscriptions.algo.ts:480
	// this.subscriptions(subscriptionKey).value = {
	//             recipient: recipient,
	//             index: index,
	//             startDate: globals.latestTimestamp,
	//             amount: amount,
	//             interval: interval,
	//             asset: AssetID.fromUint64(0),
	//             gate: gate,
	//             lastPayment: globals.latestTimestamp,
	//             streak: 1,
	//             escrowed: 0,
	//         }
	frame_dig 8 // subscriptionKey: SubscriptionKey
	frame_dig -2 // recipient: Address
	frame_dig -5 // index: uint64
	itob
	concat
	global LatestTimestamp
	itob
	concat
	frame_dig -3 // amount: uint64
	itob
	concat
	frame_dig -4 // interval: uint64
	itob
	concat
	bytec 3 // 0x0000000000000000
	concat
	frame_dig 1 // gate: uint64
	itob
	concat
	global LatestTimestamp
	itob
	concat
	bytec 4 // 0x0000000000000001
	concat
	bytec 3 // 0x0000000000000000
	concat
	box_put

	// contracts/subscriptions/subscriptions.algo.ts:493
	// akitaPercentage = this.daoAppID.value.globalState(SUBSCRIPTION_PAYMENT_PERCENTAGE_KEY) as uint64
	bytec 2 //  "dao_app_id"
	app_global_get
	bytec 8 // "subscription_payment_percentage"
	app_global_get_ex

	// global state value does not exist: this.daoAppID.value.globalState(SUBSCRIPTION_PAYMENT_PERCENTAGE_KEY)
	assert
	frame_bury 9 // akitaPercentage: uint64

	// contracts/subscriptions/subscriptions.algo.ts:494
	// triggerPercentage = this.daoAppID.value.globalState(SUBSCRIPTION_TRIGGER_PERCENTAGE_KEY) as uint64
	bytec 2 //  "dao_app_id"
	app_global_get
	bytec 9 // "subscription_trigger_percentage"
	app_global_get_ex

	// global state value does not exist: this.daoAppID.value.globalState(SUBSCRIPTION_TRIGGER_PERCENTAGE_KEY)
	assert
	frame_bury 10 // triggerPercentage: uint64

	// contracts/subscriptions/subscriptions.algo.ts:495
	// initialFee = (amount * (akitaPercentage + triggerPercentage) - 1) / 1000 + 1
	frame_dig -3 // amount: uint64
	frame_dig 9 // akitaPercentage: uint64
	frame_dig 10 // triggerPercentage: uint64
	+
	*
	intc 1 // 1
	-
	intc 12 // 1000
	/
	intc 1 // 1
	+
	frame_bury 11 // initialFee: uint64

	// contracts/subscriptions/subscriptions.algo.ts:496
	// leftOver = amount - (initialFee)
	frame_dig -3 // amount: uint64
	frame_dig 11 // initialFee: uint64
	-
	frame_bury 12 // leftOver: uint64

	// contracts/subscriptions/subscriptions.algo.ts:498
	// verifyPayTxn(payment, {
	//             receiver: this.app.address,
	//             amount: {
	//                 greaterThanEqualTo: (amount + algoMBRFee),
	//             },
	//         })
	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	frame_dig -3 // amount: uint64
	frame_dig 5 // algoMBRFee: uint64
	+
	>=

	// transaction verification failed: {"txn":"payment","field":"amount","condition":"greaterThanEqualTo","expected":">=(amount + algoMBRFee)"}
	assert

	// contracts/subscriptions/subscriptions.algo.ts:505
	// this.pendingGroup.addPayment({
	//             receiver: this.daoAppID.value.address,
	//             amount: initialFee,
	//             fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:506
	// receiver: this.daoAppID.value.address
	bytec 2 //  "dao_app_id"
	app_global_get
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/subscriptions/subscriptions.algo.ts:507
	// amount: initialFee
	frame_dig 11 // initialFee: uint64
	itxn_field Amount

	// contracts/subscriptions/subscriptions.algo.ts:508
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:511
	// this.pendingGroup.addPayment({
	//             receiver: recipient,
	//             amount: leftOver,
	//             fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:512
	// receiver: recipient
	frame_dig -2 // recipient: Address
	itxn_field Receiver

	// contracts/subscriptions/subscriptions.algo.ts:513
	// amount: leftOver
	frame_dig 12 // leftOver: uint64
	itxn_field Amount

	// contracts/subscriptions/subscriptions.algo.ts:514
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:517
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// optin(pay,uint64)void
*abi_route_optin:
	// asset: uint64
	txna ApplicationArgs 1
	btoi

	// payment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 1 (payment) for optin must be a pay transaction
	assert

	// execute optin(pay,uint64)void
	callsub optin
	intc 1 // 1
	return

// optin(payment: PayTxn, asset: AssetID): void
optin:
	proto 2 0

	// contracts/subscriptions/subscriptions.algo.ts:522
	// assert(!this.app.address.isOptedInToAsset(asset), errs.ALREADY_OPTED_IN)
	global CurrentApplicationAddress
	frame_dig -2 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	assert

	// contracts/subscriptions/subscriptions.algo.ts:524
	// verifyPayTxn(payment, {
	//             receiver: this.app.address,
	//             amount: globals.assetOptInMinBalance,
	//         })
	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	global AssetOptInMinBalance
	==

	// transaction verification failed: {"txn":"payment","field":"amount","expected":"globals.assetOptInMinBalance"}
	assert

	// contracts/subscriptions/subscriptions.algo.ts:529
	// sendAssetTransfer({
	//             assetReceiver: this.app.address,
	//             xferAsset: asset,
	//             assetAmount: 0,
	//             fee: 0,
	//         })
	itxn_begin
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:530
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/subscriptions/subscriptions.algo.ts:531
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// contracts/subscriptions/subscriptions.algo.ts:532
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/subscriptions/subscriptions.algo.ts:533
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// subscribeAsa(pay,axfer,address,uint64,uint64,uint64,byte[][])void
*abi_route_subscribeAsa:
	// args: byte[][]
	txna ApplicationArgs 5

	// index: uint64
	txna ApplicationArgs 4
	btoi

	// interval: uint64
	txna ApplicationArgs 3
	btoi

	// amount: uint64
	txna ApplicationArgs 2
	btoi

	// recipient: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 4 (recipient) for subscribeAsa must be a address
	assert

	// assetXfer: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 4 //  axfer
	==

	// argument 5 (assetXfer) for subscribeAsa must be a axfer transaction
	assert

	// payment: pay
	txn GroupIndex
	intc 10 // 2
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 6 (payment) for subscribeAsa must be a pay transaction
	assert

	// execute subscribeAsa(pay,axfer,address,uint64,uint64,uint64,byte[][])void
	callsub subscribeAsa
	intc 1 // 1
	return

// subscribeAsa(payment: PayTxn, assetXfer: AssetTransferTxn, recipient: Address, amount: uint64, interval: uint64, index: uint64, args: bytes[]): void
subscribeAsa:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 12

	// contracts/subscriptions/subscriptions.algo.ts:547
	// assert(amount > 3, errs.MIN_AMOUNT_IS_THREE)
	frame_dig -4 // amount: uint64
	intc 15 // 3
	>
	assert

	// contracts/subscriptions/subscriptions.algo.ts:549
	// assert(interval >= 60, errs.MIN_INTERVAL_IS_SIXTY)
	frame_dig -5 // interval: uint64
	intc 16 // 60
	>=
	assert

	// contracts/subscriptions/subscriptions.algo.ts:551
	// blocksKey: BlockListKey = { address: recipient, blocked: this.txn.sender }
	frame_dig -3 // recipient: Address
	txn Sender
	concat
	frame_bury 0 // blocksKey: BlockListKey

	// contracts/subscriptions/subscriptions.algo.ts:553
	// assert(!this.blocks(blocksKey).exists, errs.BLOCKED)
	frame_dig 0 // blocksKey: BlockListKey
	box_len
	swap
	pop
	!
	assert

	// contracts/subscriptions/subscriptions.algo.ts:555
	// gate = 0
	intc 0 // 0
	frame_bury 1 // gate: uint64

	// contracts/subscriptions/subscriptions.algo.ts:557
	// isDonation = index === 0
	frame_dig -6 // index: uint64
	intc 0 // 0
	==
	frame_bury 2 // isDonation: bool

	// *if8_condition
	// contracts/subscriptions/subscriptions.algo.ts:558
	// !isDonation
	frame_dig 2 // isDonation: bool
	!
	bz *if8_end

	// *if8_consequent
	// contracts/subscriptions/subscriptions.algo.ts:559
	// boxKey: ServicesKey = { address: recipient, index: index }
	frame_dig -3 // recipient: Address
	frame_dig -6 // index: uint64
	itob
	concat
	frame_bury 3 // boxKey: ServicesKey

	// contracts/subscriptions/subscriptions.algo.ts:561
	// assert(this.services(boxKey).exists, errs.SERVICE_DOES_NOT_EXIST)
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:563
	// service = this.services(boxKey).value
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	frame_bury 4 // storage key//service

	// contracts/subscriptions/subscriptions.algo.ts:565
	// assert(service.status === ServiceStatusActive, errs.SERVICE_IS_NOT_ACTIVE)
	intc 0 // 0
	intc 2 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	intc 0 // 0
	==
	assert

	// contracts/subscriptions/subscriptions.algo.ts:567
	// assert(service.asset === assetXfer.xferAsset, errs.ASA_MISMATCH)
	intc 20 //  headOffset
	intc 2 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns XferAsset
	==
	assert

	// contracts/subscriptions/subscriptions.algo.ts:569
	// assert(this.gate(service.gate, args), errs.FAILED_GATE)
	frame_dig -7 // args: bytes[]
	intc 6 //  headOffset
	intc 2 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	callsub gate
	assert

	// contracts/subscriptions/subscriptions.algo.ts:571
	// amount = service.amount
	intc 21 //  headOffset
	intc 2 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	frame_bury -4 // amount: uint64

	// contracts/subscriptions/subscriptions.algo.ts:572
	// interval = service.interval
	intc 2 //  headOffset
	intc 2 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	frame_bury -5 // interval: uint64

	// contracts/subscriptions/subscriptions.algo.ts:573
	// gate = service.gate
	intc 6 //  headOffset
	intc 2 // 8
	bytec 1 //  "s"
	frame_dig 3 // boxKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	frame_bury 1 // gate: uint64

*if8_end:
	// contracts/subscriptions/subscriptions.algo.ts:576
	// algoMBRFee = subscriptionsMBR
	intc 19 // 53700
	frame_bury 5 // algoMBRFee: uint64

	// contracts/subscriptions/subscriptions.algo.ts:577
	// subIndex = 0
	intc 0 // 0
	frame_bury 6 // subIndex: uint64

	// contracts/subscriptions/subscriptions.algo.ts:579
	// firstSubscription = this.subscriptionslist(this.txn.sender).exists
	txn Sender
	box_len
	swap
	pop
	frame_bury 7 // firstSubscription: bool

	// *if9_condition
	// contracts/subscriptions/subscriptions.algo.ts:580
	// firstSubscription
	frame_dig 7 // firstSubscription: bool
	bz *if9_else

	// *if9_consequent
	// contracts/subscriptions/subscriptions.algo.ts:581
	// this.subscriptionslist(this.txn.sender).value = 0
	txn Sender
	bytec 3 // 0x0000000000000000
	box_put

	// contracts/subscriptions/subscriptions.algo.ts:582
	// algoMBRFee += subscriptionsListMBR
	frame_dig 5 // algoMBRFee: uint64
	intc 17 // 18500
	+
	frame_bury 5 // algoMBRFee: uint64
	b *if9_end

*if9_else:
	// contracts/subscriptions/subscriptions.algo.ts:584
	// this.subscriptionslist(this.txn.sender).value += 1
	txn Sender
	box_get

	// box value does not exist: this.subscriptionslist(this.txn.sender).value
	assert
	btoi
	intc 1 // 1
	+
	txn Sender
	swap
	itob
	box_put

	// contracts/subscriptions/subscriptions.algo.ts:585
	// subIndex = this.subscriptionslist(this.txn.sender).value
	txn Sender
	box_get

	// box value does not exist: this.subscriptionslist(this.txn.sender).value
	assert
	btoi
	frame_bury 6 // subIndex: uint64

*if9_end:
	// *if10_condition
	// contracts/subscriptions/subscriptions.algo.ts:588
	// !this.daoAppID.value.address.isOptedInToAsset(assetXfer.xferAsset)
	bytec 2 //  "dao_app_id"
	app_global_get
	app_params_get AppAddress
	pop
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns XferAsset
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if10_end

	// *if10_consequent
	// contracts/subscriptions/subscriptions.algo.ts:589
	// this.arc58OptIn(this.daoAppID.value, assetXfer.xferAsset)
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns XferAsset
	bytec 2 //  "dao_app_id"
	app_global_get
	callsub arc58OptIn

	// contracts/subscriptions/subscriptions.algo.ts:590
	// algoMBRFee += globals.assetOptInMinBalance
	frame_dig 5 // algoMBRFee: uint64
	global AssetOptInMinBalance
	+
	frame_bury 5 // algoMBRFee: uint64

*if10_end:
	// contracts/subscriptions/subscriptions.algo.ts:593
	// subscriptionKey: SubscriptionKey = { address: this.txn.sender, index: subIndex }
	txn Sender
	frame_dig 6 // subIndex: uint64
	itob
	concat
	frame_bury 8 // subscriptionKey: SubscriptionKey

	// contracts/subscriptions/subscriptions.algo.ts:595
	// this.subscriptions(subscriptionKey).value = {
	//             recipient: recipient,
	//             index: index,
	//             startDate: globals.latestTimestamp,
	//             amount: amount,
	//             interval: interval,
	//             asset: assetXfer.xferAsset,
	//             gate: gate,
	//             lastPayment: globals.latestTimestamp,
	//             streak: 1,
	//             escrowed: 0,
	//         }
	frame_dig 8 // subscriptionKey: SubscriptionKey
	frame_dig -3 // recipient: Address
	frame_dig -6 // index: uint64
	itob
	concat
	global LatestTimestamp
	itob
	concat
	frame_dig -4 // amount: uint64
	itob
	concat
	frame_dig -5 // interval: uint64
	itob
	concat
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns XferAsset
	itob
	concat
	frame_dig 1 // gate: uint64
	itob
	concat
	global LatestTimestamp
	itob
	concat
	bytec 4 // 0x0000000000000001
	concat
	bytec 3 // 0x0000000000000000
	concat
	box_put

	// contracts/subscriptions/subscriptions.algo.ts:608
	// akitaPercentage = this.daoAppID.value.globalState(SUBSCRIPTION_PAYMENT_PERCENTAGE_KEY) as uint64
	bytec 2 //  "dao_app_id"
	app_global_get
	bytec 8 // "subscription_payment_percentage"
	app_global_get_ex

	// global state value does not exist: this.daoAppID.value.globalState(SUBSCRIPTION_PAYMENT_PERCENTAGE_KEY)
	assert
	frame_bury 9 // akitaPercentage: uint64

	// contracts/subscriptions/subscriptions.algo.ts:609
	// triggerPercentage = this.daoAppID.value.globalState(SUBSCRIPTION_TRIGGER_PERCENTAGE_KEY) as uint64
	bytec 2 //  "dao_app_id"
	app_global_get
	bytec 9 // "subscription_trigger_percentage"
	app_global_get_ex

	// global state value does not exist: this.daoAppID.value.globalState(SUBSCRIPTION_TRIGGER_PERCENTAGE_KEY)
	assert
	frame_bury 10 // triggerPercentage: uint64

	// contracts/subscriptions/subscriptions.algo.ts:610
	// initialFee = (amount * (akitaPercentage + triggerPercentage) - 1) / 1000 + 1
	frame_dig -4 // amount: uint64
	frame_dig 9 // akitaPercentage: uint64
	frame_dig 10 // triggerPercentage: uint64
	+
	*
	intc 1 // 1
	-
	intc 12 // 1000
	/
	intc 1 // 1
	+
	frame_bury 11 // initialFee: uint64

	// contracts/subscriptions/subscriptions.algo.ts:611
	// leftOver = amount - initialFee
	frame_dig -4 // amount: uint64
	frame_dig 11 // initialFee: uint64
	-
	frame_bury 12 // leftOver: uint64

	// contracts/subscriptions/subscriptions.algo.ts:613
	// verifyPayTxn(payment, {
	//             receiver: this.app.address,
	//             amount: {
	//                 greaterThanEqualTo: algoMBRFee,
	//             },
	//         })
	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	frame_dig 5 // algoMBRFee: uint64
	>=

	// transaction verification failed: {"txn":"payment","field":"amount","condition":"greaterThanEqualTo","expected":">=algoMBRFee"}
	assert

	// contracts/subscriptions/subscriptions.algo.ts:620
	// verifyAssetTransferTxn(assetXfer, {
	//             assetReceiver: this.app.address,
	//             assetAmount: amount,
	//         })
	// verify assetReceiver
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"assetXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify assetAmount
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -4 // amount: uint64
	==

	// transaction verification failed: {"txn":"assetXfer","field":"assetAmount","expected":"amount"}
	assert

	// contracts/subscriptions/subscriptions.algo.ts:625
	// this.pendingGroup.addAssetTransfer({
	//             assetReceiver: this.daoAppID.value.address,
	//             xferAsset: assetXfer.xferAsset,
	//             assetAmount: initialFee,
	//             fee: 0,
	//         })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:626
	// assetReceiver: this.daoAppID.value.address
	bytec 2 //  "dao_app_id"
	app_global_get
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts/subscriptions/subscriptions.algo.ts:627
	// xferAsset: assetXfer.xferAsset
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns XferAsset
	itxn_field XferAsset

	// contracts/subscriptions/subscriptions.algo.ts:628
	// assetAmount: initialFee
	frame_dig 11 // initialFee: uint64
	itxn_field AssetAmount

	// contracts/subscriptions/subscriptions.algo.ts:629
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:632
	// this.pendingGroup.addAssetTransfer({
	//             assetReceiver: recipient,
	//             xferAsset: assetXfer.xferAsset,
	//             assetAmount: leftOver,
	//             fee: 0,
	//         })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:633
	// assetReceiver: recipient
	frame_dig -3 // recipient: Address
	itxn_field AssetReceiver

	// contracts/subscriptions/subscriptions.algo.ts:634
	// xferAsset: assetXfer.xferAsset
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns XferAsset
	itxn_field XferAsset

	// contracts/subscriptions/subscriptions.algo.ts:635
	// assetAmount: leftOver
	frame_dig 12 // leftOver: uint64
	itxn_field AssetAmount

	// contracts/subscriptions/subscriptions.algo.ts:636
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:639
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// deposit(pay,uint64)void
*abi_route_deposit:
	// index: uint64
	txna ApplicationArgs 1
	btoi

	// payment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 1 (payment) for deposit must be a pay transaction
	assert

	// execute deposit(pay,uint64)void
	callsub deposit
	intc 1 // 1
	return

// deposit(payment: PayTxn, index: uint64): void
deposit:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/subscriptions/subscriptions.algo.ts:643
	// subKey: SubscriptionKey = { address: this.txn.sender, index: index }
	txn Sender
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // subKey: SubscriptionKey

	// contracts/subscriptions/subscriptions.algo.ts:645
	// assert(this.subscriptions(subKey).exists, errs.SUBSCRIPTION_DOES_NOT_EXIST)
	frame_dig 0 // subKey: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:647
	// sub = this.subscriptions(subKey).value
	frame_dig 0 // subKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/subscriptions/subscriptions.algo.ts:649
	// verifyPayTxn(payment, {
	//             receiver: this.app.address,
	//             amount: sub.amount,
	//         })
	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	frame_dig 0 // subKey: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	==

	// transaction verification failed: {"txn":"payment","field":"amount","expected":"sub.amount"}
	assert

	// contracts/subscriptions/subscriptions.algo.ts:654
	// this.subscriptions(subKey).value.escrowed += sub.amount
	intc 8 //  headOffset
	frame_dig 0 // subKey: SubscriptionKey
	intc 8 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 0 // subKey: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	+
	itob
	frame_dig 0 // subKey: SubscriptionKey
	cover 2
	box_replace
	retsub

// depositAsa(axfer,uint64)void
*abi_route_depositAsa:
	// index: uint64
	txna ApplicationArgs 1
	btoi

	// assetXfer: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 4 //  axfer
	==

	// argument 1 (assetXfer) for depositAsa must be a axfer transaction
	assert

	// execute depositAsa(axfer,uint64)void
	callsub depositAsa
	intc 1 // 1
	return

// depositAsa(assetXfer: AssetTransferTxn, index: uint64): void
depositAsa:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/subscriptions/subscriptions.algo.ts:658
	// subKey: SubscriptionKey = { address: this.txn.sender, index: index }
	txn Sender
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // subKey: SubscriptionKey

	// contracts/subscriptions/subscriptions.algo.ts:660
	// assert(this.subscriptions(subKey).exists, errs.SUBSCRIPTION_DOES_NOT_EXIST)
	frame_dig 0 // subKey: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:662
	// sub = this.subscriptions(subKey).value
	frame_dig 0 // subKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/subscriptions/subscriptions.algo.ts:664
	// verifyAssetTransferTxn(assetXfer, {
	//             assetReceiver: this.app.address,
	//             assetAmount: sub.amount,
	//         })
	// verify assetReceiver
	frame_dig -1 // assetXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"assetXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// verify assetAmount
	frame_dig -1 // assetXfer: AssetTransferTxn
	gtxns AssetAmount
	frame_dig 0 // subKey: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	==

	// transaction verification failed: {"txn":"assetXfer","field":"assetAmount","expected":"sub.amount"}
	assert

	// contracts/subscriptions/subscriptions.algo.ts:669
	// this.subscriptions(subKey).value.escrowed += sub.amount
	intc 8 //  headOffset
	frame_dig 0 // subKey: SubscriptionKey
	intc 8 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 0 // subKey: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	+
	itob
	frame_dig 0 // subKey: SubscriptionKey
	cover 2
	box_replace
	retsub

// withdraw(uint64,uint64)void
*abi_route_withdraw:
	// amount: uint64
	txna ApplicationArgs 2
	btoi

	// index: uint64
	txna ApplicationArgs 1
	btoi

	// execute withdraw(uint64,uint64)void
	callsub withdraw
	intc 1 // 1
	return

// withdraw(index: uint64, amount: uint64): void
withdraw:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/subscriptions/subscriptions.algo.ts:673
	// subKey: SubscriptionKey = { address: this.txn.sender, index: index }
	txn Sender
	frame_dig -1 // index: uint64
	itob
	concat
	frame_bury 0 // subKey: SubscriptionKey

	// contracts/subscriptions/subscriptions.algo.ts:675
	// assert(this.subscriptions(subKey).exists, errs.SUBSCRIPTION_DOES_NOT_EXIST)
	frame_dig 0 // subKey: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:677
	// sub = this.subscriptions(subKey).value
	frame_dig 0 // subKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/subscriptions/subscriptions.algo.ts:679
	// assert(sub.escrowed > amount, errs.NOT_ENOUGH_FUNDS)
	frame_dig 0 // subKey: SubscriptionKey
	intc 8 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig -2 // amount: uint64
	>
	assert

	// *if11_condition
	// contracts/subscriptions/subscriptions.algo.ts:681
	// sub.asset.id !== 0
	frame_dig 0 // subKey: SubscriptionKey
	intc 7 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	intc 0 // 0
	!=
	bz *if11_else

	// *if11_consequent
	// contracts/subscriptions/subscriptions.algo.ts:682
	// sendAssetTransfer({
	//                 assetReceiver: this.txn.sender,
	//                 xferAsset: sub.asset,
	//                 assetAmount: amount,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:683
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/subscriptions/subscriptions.algo.ts:684
	// xferAsset: sub.asset
	frame_dig 0 // subKey: SubscriptionKey
	intc 7 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/subscriptions/subscriptions.algo.ts:685
	// assetAmount: amount
	frame_dig -2 // amount: uint64
	itxn_field AssetAmount

	// contracts/subscriptions/subscriptions.algo.ts:686
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if11_end

*if11_else:
	// contracts/subscriptions/subscriptions.algo.ts:689
	// sendPayment({
	//                 receiver: this.txn.sender,
	//                 amount: amount,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:690
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/subscriptions/subscriptions.algo.ts:691
	// amount: amount
	frame_dig -2 // amount: uint64
	itxn_field Amount

	// contracts/subscriptions/subscriptions.algo.ts:692
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if11_end:
	// contracts/subscriptions/subscriptions.algo.ts:696
	// this.subscriptions(subKey).value.escrowed = 0
	frame_dig 0 // subKey: SubscriptionKey
	intc 8 //  headOffset
	bytec 3 // 0x0000000000000000
	box_replace
	retsub

// triggerPayment(address,uint64,byte[][])void
*abi_route_triggerPayment:
	// args: byte[][]
	txna ApplicationArgs 3

	// index: uint64
	txna ApplicationArgs 2
	btoi

	// address: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 2 (address) for triggerPayment must be a address
	assert

	// execute triggerPayment(address,uint64,byte[][])void
	callsub triggerPayment
	intc 1 // 1
	return

// triggerPayment(address: Address, index: uint64, args: bytes[]): void
triggerPayment:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 9

	// contracts/subscriptions/subscriptions.algo.ts:700
	// subscriptionsKey: SubscriptionKey = { address: address, index: index }
	frame_dig -1 // address: Address
	frame_dig -2 // index: uint64
	itob
	concat
	frame_bury 0 // subscriptionsKey: SubscriptionKey

	// contracts/subscriptions/subscriptions.algo.ts:703
	// assert(this.subscriptions(subscriptionsKey).exists)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:705
	// sub = this.subscriptions(subscriptionsKey).value
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/subscriptions/subscriptions.algo.ts:707
	// blocksKey: BlockListKey = { address: sub.recipient, blocked: address }
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	frame_dig -1 // address: Address
	concat
	frame_bury 2 // blocksKey: BlockListKey

	// contracts/subscriptions/subscriptions.algo.ts:710
	// assert(!this.blocks(blocksKey).exists, errs.BLOCKED)
	frame_dig 2 // blocksKey: BlockListKey
	box_len
	swap
	pop
	!
	assert

	// *if12_condition
	// contracts/subscriptions/subscriptions.algo.ts:712
	// index > 0
	frame_dig -2 // index: uint64
	intc 0 // 0
	>
	bz *if12_end

	// *if12_consequent
	// contracts/subscriptions/subscriptions.algo.ts:713
	// servicesKey: ServicesKey = { address: sub.recipient, index: sub.index }
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 3 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itob
	concat
	frame_bury 3 // servicesKey: ServicesKey

	// contracts/subscriptions/subscriptions.algo.ts:715
	// assert(this.services(servicesKey).value.status !== ServiceStatusShutdown, errs.SERVICE_IS_SHUTDOWN)
	intc 0 // 0
	intc 2 // 8
	bytec 1 //  "s"
	frame_dig 3 // servicesKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	intc 10 // 2
	!=
	assert

*if12_end:
	// contracts/subscriptions/subscriptions.algo.ts:719
	// assert(sub.lastPayment < this.getLatestWindowStart(sub.startDate, sub.interval), errs.BAD_WINDOW)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 9 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 13 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 6 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	callsub getLatestWindowStart
	<
	assert

	// contracts/subscriptions/subscriptions.algo.ts:721
	// assert(sub.escrowed > sub.amount, errs.NOT_ENOUGH_FUNDS)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 8 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	>
	assert

	// contracts/subscriptions/subscriptions.algo.ts:723
	// isAsa = sub.asset.id !== 0
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 7 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	intc 0 // 0
	!=
	frame_bury 4 // isAsa: bool

	// contracts/subscriptions/subscriptions.algo.ts:725
	// akitaPercentage = this.daoAppID.value.globalState(SUBSCRIPTION_PAYMENT_PERCENTAGE_KEY) as uint64
	bytec 2 //  "dao_app_id"
	app_global_get
	bytec 8 // "subscription_payment_percentage"
	app_global_get_ex

	// global state value does not exist: this.daoAppID.value.globalState(SUBSCRIPTION_PAYMENT_PERCENTAGE_KEY)
	assert
	frame_bury 5 // akitaPercentage: uint64

	// contracts/subscriptions/subscriptions.algo.ts:726
	// akitaFee = (sub.amount * akitaPercentage - 1) / 1000 + 1
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 5 // akitaPercentage: uint64
	*
	intc 1 // 1
	-
	intc 12 // 1000
	/
	intc 1 // 1
	+
	frame_bury 6 // akitaFee: uint64

	// contracts/subscriptions/subscriptions.algo.ts:727
	// triggerPercentage = this.daoAppID.value.globalState(SUBSCRIPTION_TRIGGER_PERCENTAGE_KEY) as uint64
	bytec 2 //  "dao_app_id"
	app_global_get
	bytec 9 // "subscription_trigger_percentage"
	app_global_get_ex

	// global state value does not exist: this.daoAppID.value.globalState(SUBSCRIPTION_TRIGGER_PERCENTAGE_KEY)
	assert
	frame_bury 7 // triggerPercentage: uint64

	// contracts/subscriptions/subscriptions.algo.ts:728
	// triggerFee = (sub.amount * triggerPercentage - 1) / 1000 + 1
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 7 // triggerPercentage: uint64
	*
	intc 1 // 1
	-
	intc 12 // 1000
	/
	intc 1 // 1
	+
	frame_bury 8 // triggerFee: uint64

	// contracts/subscriptions/subscriptions.algo.ts:729
	// leftOver = sub.amount - (akitaFee + triggerFee)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 5 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	frame_dig 6 // akitaFee: uint64
	frame_dig 8 // triggerFee: uint64
	+
	-
	frame_bury 9 // leftOver: uint64

	// *if13_condition
	// contracts/subscriptions/subscriptions.algo.ts:731
	// isAsa
	frame_dig 4 // isAsa: bool
	bz *if13_else

	// *if13_consequent
	// contracts/subscriptions/subscriptions.algo.ts:732
	// this.pendingGroup.addAssetTransfer({
	//                 assetReceiver: this.daoAppID.value.address,
	//                 xferAsset: sub.asset,
	//                 assetAmount: akitaFee,
	//                 fee: 0,
	//             })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:733
	// assetReceiver: this.daoAppID.value.address
	bytec 2 //  "dao_app_id"
	app_global_get
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts/subscriptions/subscriptions.algo.ts:734
	// xferAsset: sub.asset
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 7 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/subscriptions/subscriptions.algo.ts:735
	// assetAmount: akitaFee
	frame_dig 6 // akitaFee: uint64
	itxn_field AssetAmount

	// contracts/subscriptions/subscriptions.algo.ts:736
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:739
	// this.pendingGroup.addAssetTransfer({
	//                 assetReceiver: this.txn.sender,
	//                 xferAsset: sub.asset,
	//                 assetAmount: triggerFee,
	//                 fee: 0,
	//             })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:740
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/subscriptions/subscriptions.algo.ts:741
	// xferAsset: sub.asset
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 7 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/subscriptions/subscriptions.algo.ts:742
	// assetAmount: triggerFee
	frame_dig 8 // triggerFee: uint64
	itxn_field AssetAmount

	// contracts/subscriptions/subscriptions.algo.ts:743
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:746
	// this.pendingGroup.addAssetTransfer({
	//                 assetReceiver: sub.recipient,
	//                 xferAsset: sub.asset,
	//                 assetAmount: leftOver,
	//                 fee: 0,
	//             })
	itxn_next
	intc 4 //  axfer
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:747
	// assetReceiver: sub.recipient
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	itxn_field AssetReceiver

	// contracts/subscriptions/subscriptions.algo.ts:748
	// xferAsset: sub.asset
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 7 //  headOffset
	intc 2 // 8
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/subscriptions/subscriptions.algo.ts:749
	// assetAmount: leftOver
	frame_dig 9 // leftOver: uint64
	itxn_field AssetAmount

	// contracts/subscriptions/subscriptions.algo.ts:750
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	b *if13_end

*if13_else:
	// contracts/subscriptions/subscriptions.algo.ts:754
	// this.pendingGroup.addPayment({
	//                 receiver: globals.currentApplicationAddress,
	//                 amount: akitaFee,
	//                 fee: 0,
	//             })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:755
	// receiver: globals.currentApplicationAddress
	global CurrentApplicationAddress
	itxn_field Receiver

	// contracts/subscriptions/subscriptions.algo.ts:756
	// amount: akitaFee
	frame_dig 6 // akitaFee: uint64
	itxn_field Amount

	// contracts/subscriptions/subscriptions.algo.ts:757
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:760
	// this.pendingGroup.addPayment({
	//                 receiver: this.txn.sender,
	//                 amount: triggerFee,
	//                 fee: 0,
	//             })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:761
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/subscriptions/subscriptions.algo.ts:762
	// amount: triggerFee
	frame_dig 8 // triggerFee: uint64
	itxn_field Amount

	// contracts/subscriptions/subscriptions.algo.ts:763
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/subscriptions/subscriptions.algo.ts:766
	// this.pendingGroup.addPayment({
	//                 receiver: sub.recipient,
	//                 amount: leftOver,
	//                 fee: 0,
	//             })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/subscriptions/subscriptions.algo.ts:767
	// receiver: sub.recipient
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	itxn_field Receiver

	// contracts/subscriptions/subscriptions.algo.ts:768
	// amount: leftOver
	frame_dig 9 // leftOver: uint64
	itxn_field Amount

	// contracts/subscriptions/subscriptions.algo.ts:769
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if13_end:
	// contracts/subscriptions/subscriptions.algo.ts:773
	// this.pendingGroup.submit()
	itxn_submit

	// contracts/subscriptions/subscriptions.algo.ts:774
	// this.updateStreak(address, index, 1)
	intc 1 // 1
	frame_dig -2 // index: uint64
	frame_dig -1 // address: Address
	callsub updateStreak

	// contracts/subscriptions/subscriptions.algo.ts:775
	// this.subscriptions(subscriptionsKey).value.lastPayment = globals.latestTimestamp
	intc 9 //  headOffset
	global LatestTimestamp
	itob
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	cover 2
	box_replace
	retsub

// streakCheck(address,uint64)void
*abi_route_streakCheck:
	// index: uint64
	txna ApplicationArgs 2
	btoi

	// sender: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 1 (sender) for streakCheck must be a address
	assert

	// execute streakCheck(address,uint64)void
	callsub streakCheck
	intc 1 // 1
	return

// streakCheck(sender: Address, index: uint64): void
streakCheck:
	proto 2 0

	// contracts/subscriptions/subscriptions.algo.ts:779
	// this.updateStreak(sender, index, 0)
	intc 0 // 0
	frame_dig -2 // index: uint64
	frame_dig -1 // sender: Address
	callsub updateStreak
	retsub

// setPasses(uint64,address[])void
*abi_route_setPasses:
	// addresses: address[]
	txna ApplicationArgs 2
	extract 2 0

	// index: uint64
	txna ApplicationArgs 1
	btoi

	// execute setPasses(uint64,address[])void
	callsub setPasses
	intc 1 // 1
	return

// setPasses(index: uint64, addresses: Address[]): void
setPasses:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 4

	// contracts/subscriptions/subscriptions.algo.ts:783
	// assert(index > 0, errs.NO_DONATIONS)
	frame_dig -1 // index: uint64
	intc 0 // 0
	>
	assert

	// contracts/subscriptions/subscriptions.algo.ts:784
	// subscriptionsKey: SubscriptionKey = { address: this.txn.sender, index: index }
	txn Sender
	frame_dig -1 // index: uint64
	itob
	concat
	frame_bury 0 // subscriptionsKey: SubscriptionKey

	// contracts/subscriptions/subscriptions.algo.ts:786
	// assert(this.subscriptions(subscriptionsKey).exists, errs.SUBSCRIPTION_DOES_NOT_EXIST)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	box_len
	swap
	pop
	assert

	// contracts/subscriptions/subscriptions.algo.ts:788
	// sub = this.subscriptions(subscriptionsKey).value
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	frame_bury 1 // storage key//sub

	// contracts/subscriptions/subscriptions.algo.ts:790
	// serviceKey: ServicesKey = { address: sub.recipient, index: index }
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	frame_dig -1 // index: uint64
	itob
	concat
	frame_bury 2 // serviceKey: ServicesKey

	// contracts/subscriptions/subscriptions.algo.ts:791
	// service = this.services(serviceKey).value
	bytec 1 //  "s"
	frame_dig 2 // serviceKey: ServicesKey
	concat
	frame_bury 3 // storage key//service

	// contracts/subscriptions/subscriptions.algo.ts:793
	// assert(service.status !== ServiceStatusShutdown, errs.SERVICE_IS_SHUTDOWN)
	intc 0 // 0
	intc 2 // 8
	bytec 1 //  "s"
	frame_dig 2 // serviceKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	intc 10 // 2
	!=
	assert

	// contracts/subscriptions/subscriptions.algo.ts:794
	// assert(service.passes >= addresses.length, errs.PASS_COUNT_OVERFLOW)
	intc 3 //  headOffset
	intc 2 // 8
	bytec 1 //  "s"
	frame_dig 2 // serviceKey: ServicesKey
	concat
	cover 2
	box_extract
	btoi
	frame_dig -2 // addresses: Address[]
	len
	intc 3 // 32
	/
	>=
	assert

	// contracts/subscriptions/subscriptions.algo.ts:796
	// for (let i = 0; i < addresses.length; i += 1)
	intc 0 // 0
	frame_bury 4 // i: uint64

*for_0:
	// contracts/subscriptions/subscriptions.algo.ts:796
	// i < addresses.length
	frame_dig 4 // i: uint64
	frame_dig -2 // addresses: Address[]
	len
	intc 3 // 32
	/
	<
	bz *for_0_end

	// contracts/subscriptions/subscriptions.algo.ts:797
	// assert(!this.blocks({ address: sub.recipient, blocked: addresses[i] }).exists, errs.BLOCKED)
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	intc 0 // 0
	intc 3 // 32
	box_extract
	frame_dig -2 // addresses: Address[]
	store 255 // full array
	intc 0 //  initial offset
	frame_dig 4 // i: uint64
	intc 3 // 32
	* // acc * typeLength
	+
	load 255 // full array
	swap
	intc 3 // 32
	extract3
	concat
	box_len
	swap
	pop
	!
	assert

*for_0_continue:
	// contracts/subscriptions/subscriptions.algo.ts:796
	// i += 1
	frame_dig 4 // i: uint64
	intc 1 // 1
	+
	frame_bury 4 // i: uint64
	b *for_0

*for_0_end:
	// contracts/subscriptions/subscriptions.algo.ts:800
	// this.passes(subscriptionsKey).value = addresses
	bytec 10 //  "p"
	frame_dig 0 // subscriptionsKey: SubscriptionKey
	concat
	dup
	box_del
	pop
	frame_dig -2 // addresses: Address[]
	dup
	len
	intc 3 // 32
	/
	itob
	extract 6 2
	swap
	concat
	box_put
	retsub

*abi_route_createApplication:
	intc 1 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x4303668e // method "isBlocked(address,address)bool"
	pushbytes 0x0d6a47a3 // method "isShutdown(address,uint64)bool"
	pushbytes 0x3362f0b0 // method "getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])"
	pushbytes 0x603d7297 // method "isFirstSubscription(address)bool"
	pushbytes 0xc07fd4c8 // method "newService(pay,uint64,uint64,uint64,uint64,uint64,byte[59])uint64"
	pushbytes 0x17c8730b // method "pauseService(uint64)void"
	pushbytes 0x8c5e86d5 // method "activateService(uint64)void"
	pushbytes 0x87e055c6 // method "shutdownService(uint64)void"
	pushbytes 0xb59c8a54 // method "block(pay,address)void"
	pushbytes 0xaeebb378 // method "unblock(address)void"
	pushbytes 0xaaf5a3a1 // method "subscribe(pay,address,uint64,uint64,uint64,byte[][])void"
	pushbytes 0x3ea11832 // method "optin(pay,uint64)void"
	pushbytes 0x47b8fced // method "subscribeAsa(pay,axfer,address,uint64,uint64,uint64,byte[][])void"
	pushbytes 0xf2355b55 // method "deposit(pay,uint64)void"
	pushbytes 0x1ac4a758 // method "depositAsa(axfer,uint64)void"
	pushbytes 0xe3aeb25c // method "withdraw(uint64,uint64)void"
	pushbytes 0x12daa571 // method "triggerPayment(address,uint64,byte[][])void"
	pushbytes 0xadb2c60e // method "streakCheck(address,uint64)void"
	pushbytes 0x275203af // method "setPasses(uint64,address[])void"
	txna ApplicationArgs 0
	match *abi_route_isBlocked *abi_route_isShutdown *abi_route_getSubsriptionInfo *abi_route_isFirstSubscription *abi_route_newService *abi_route_pauseService *abi_route_activateService *abi_route_shutdownService *abi_route_block *abi_route_unblock *abi_route_subscribe *abi_route_optin *abi_route_subscribeAsa *abi_route_deposit *abi_route_depositAsa *abi_route_withdraw *abi_route_triggerPayment *abi_route_streakCheck *abi_route_setPasses

	// this contract does not implement the given ABI method for call NoOp
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub