#pragma version 10
intcblock 0 1 8 32 48 6 4 2 96 83500 22100 40 56
bytecblock 0x 0x68 0x0000000000000003 0x2bf3cc5a 0x0000000000000000 0x6f666665725f637572736f72 0x0000000000000001 0x0000000000000004 0x0000000000000002 0x64ccf1d3

// This TEAL was generated by TEALScript v0.106.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 5 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// newOfferID(): uint64
newOfferID:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/hyper_swap/hyper_swap.algo.ts:104
	// id = this._offerCursor.value
	bytec 5 //  "offer_cursor"
	app_global_get
	frame_bury 0 // id: uint64

	// contracts/hyper_swap/hyper_swap.algo.ts:105
	// this._offerCursor.value += 1
	bytec 5 //  "offer_cursor"
	app_global_get
	intc 1 // 1
	+
	bytec 5 //  "offer_cursor"
	swap
	app_global_put

	// contracts/hyper_swap/hyper_swap.algo.ts:106
	// return id
	frame_dig 0 // id: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// arc59OptInAndSend(recipient: Address, asset: AssetID, amount: uint64): void
arc59OptInAndSend:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts/hyper_swap/hyper_swap.algo.ts:110
	// canCallData = sendMethodCall<typeof AssetInbox.prototype.arc59_getSendAssetInfo, arc59GetSendAssetInfoResponse>({
	//             applicationID: AppID.fromUint64(OtherAppIDsAssetInbox),
	//             methodArgs: [
	//                 recipient,
	//                 asset.id,
	//             ],
	//             fee: 0,
	//         })
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	pushbytes 0xcaa8daa5 // method "arc59_getSendAssetInfo(address,uint64)(uint64,uint64,bool,bool,uint64)"
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:111
	// applicationID: AppID.fromUint64(OtherAppIDsAssetInbox)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/hyper_swap/hyper_swap.algo.ts:112
	// methodArgs: [
	//                 recipient,
	//                 asset.id,
	//             ]
	frame_dig -1 // recipient: Address
	itxn_field ApplicationArgs
	frame_dig -2 // asset: AssetID
	itob
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:116
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	frame_bury 0 // canCallData: (uint64,uint64,bool,bool,uint64)

	// contracts/hyper_swap/hyper_swap.algo.ts:119
	// mbr = canCallData.mbr
	frame_dig 0 // canCallData: (uint64,uint64,bool,bool,uint64)
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	frame_bury 1 // mbr: uint64

	// contracts/hyper_swap/hyper_swap.algo.ts:120
	// routerOptedIn = canCallData.routerOptedIn
	frame_dig 0 // canCallData: (uint64,uint64,bool,bool,uint64)
	store 255 // full array
	load 255 // full array
	pushint 128
	getbit
	frame_bury 2 // routerOptedIn: bool

	// contracts/hyper_swap/hyper_swap.algo.ts:121
	// receiverAlgoNeededForClaim = canCallData.receiverAlgoNeededForClaim
	frame_dig 0 // canCallData: (uint64,uint64,bool,bool,uint64)
	store 255 // full array
	load 255 // full array
	extract 17 8
	btoi
	frame_bury 3 // receiverAlgoNeededForClaim: uint64

	// *if0_condition
	// contracts/hyper_swap/hyper_swap.algo.ts:123
	// mbr || receiverAlgoNeededForClaim
	frame_dig 1 // mbr: uint64
	dup
	bnz *skip_or0
	frame_dig 3 // receiverAlgoNeededForClaim: uint64
	||

*skip_or0:
	bz *if0_end

	// *if0_consequent
	// contracts/hyper_swap/hyper_swap.algo.ts:124
	// this.pendingGroup.addPayment({
	//                 receiver: AppID.fromUint64(OtherAppIDsAssetInbox).address,
	//                 amount: (mbr + receiverAlgoNeededForClaim),
	//                 fee: 0,
	//             })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/hyper_swap/hyper_swap.algo.ts:125
	// receiver: AppID.fromUint64(OtherAppIDsAssetInbox).address
	intc 0 // 0
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/hyper_swap/hyper_swap.algo.ts:126
	// amount: (mbr + receiverAlgoNeededForClaim)
	frame_dig 1 // mbr: uint64
	frame_dig 3 // receiverAlgoNeededForClaim: uint64
	+
	itxn_field Amount

	// contracts/hyper_swap/hyper_swap.algo.ts:127
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if0_end:
	// *if1_condition
	// contracts/hyper_swap/hyper_swap.algo.ts:131
	// !routerOptedIn
	frame_dig 2 // routerOptedIn: bool
	!
	bz *if1_end

	// *if1_consequent
	// contracts/hyper_swap/hyper_swap.algo.ts:132
	// this.pendingGroup.addMethodCall<typeof AssetInbox.prototype.arc59_optRouterIn, void>({
	//                 applicationID: AppID.fromUint64(OtherAppIDsAssetInbox),
	//                 methodArgs: [asset.id],
	//                 fee: 0
	//             })
	itxn_next
	intc 5 //  appl
	itxn_field TypeEnum
	pushbytes 0xe8540810 // method "arc59_optRouterIn(uint64)void"
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:133
	// applicationID: AppID.fromUint64(OtherAppIDsAssetInbox)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/hyper_swap/hyper_swap.algo.ts:134
	// methodArgs: [asset.id]
	frame_dig -2 // asset: AssetID
	itob
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:135
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if1_end:
	// contracts/hyper_swap/hyper_swap.algo.ts:139
	// this.pendingGroup.addMethodCall<typeof AssetInbox.prototype.arc59_sendAsset, Address>({
	//             applicationID: AppID.fromUint64(OtherAppIDsAssetInbox),
	//             methodArgs: [
	//                 {
	//                     assetReceiver: AppID.fromUint64(OtherAppIDsAssetInbox).address,
	//                     assetAmount: amount,
	//                     xferAsset: asset,
	//                     fee: 0,
	//                 },
	//                 recipient,
	//                 receiverAlgoNeededForClaim,
	//             ],
	//             fee: 0
	//         })
	itxn_next
	intc 6 //  axfer
	itxn_field TypeEnum

	// contracts/hyper_swap/hyper_swap.algo.ts:143
	// assetReceiver: AppID.fromUint64(OtherAppIDsAssetInbox).address
	intc 0 // 0
	app_params_get AppAddress
	pop
	itxn_field AssetReceiver

	// contracts/hyper_swap/hyper_swap.algo.ts:144
	// assetAmount: amount
	frame_dig -3 // amount: uint64
	itxn_field AssetAmount

	// contracts/hyper_swap/hyper_swap.algo.ts:145
	// xferAsset: asset
	frame_dig -2 // asset: AssetID
	itxn_field XferAsset

	// contracts/hyper_swap/hyper_swap.algo.ts:146
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 5 //  appl
	itxn_field TypeEnum
	pushbytes 0x08531ed7 // method "arc59_sendAsset(axfer,address,uint64)address"
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:140
	// applicationID: AppID.fromUint64(OtherAppIDsAssetInbox)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/hyper_swap/hyper_swap.algo.ts:141
	// methodArgs: [
	//                 {
	//                     assetReceiver: AppID.fromUint64(OtherAppIDsAssetInbox).address,
	//                     assetAmount: amount,
	//                     xferAsset: asset,
	//                     fee: 0,
	//                 },
	//                 recipient,
	//                 receiverAlgoNeededForClaim,
	//             ]
	frame_dig -1 // recipient: Address
	itxn_field ApplicationArgs
	frame_dig 3 // receiverAlgoNeededForClaim: uint64
	itob
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:151
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/hyper_swap/hyper_swap.algo.ts:154
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// offer(pay,pay,byte[32],uint64,byte[32],uint64,uint64)void
*abi_route_offer:
	// expiration: uint64
	txna ApplicationArgs 5
	btoi

	// participantLeaves: uint64
	txna ApplicationArgs 4
	btoi

	// participantsRoot: byte[32]
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 32
	==

	// argument 2 (participantsRoot) for offer must be a byte[32]
	assert

	// leaves: uint64
	txna ApplicationArgs 2
	btoi

	// root: byte[32]
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 4 (root) for offer must be a byte[32]
	assert

	// feePayment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 5 (feePayment) for offer must be a pay transaction
	assert

	// mbrPayment: pay
	txn GroupIndex
	intc 7 // 2
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 6 (mbrPayment) for offer must be a pay transaction
	assert

	// execute offer(pay,pay,byte[32],uint64,byte[32],uint64,uint64)void
	callsub offer
	intc 1 // 1
	return

// offer(mbrPayment: PayTxn, feePayment: PayTxn, root: bytes32, leaves: uint64, participantsRoot: bytes32, participantLeaves: uint64, expiration: uint64): void
//
// Creates a merkle tree based atomic payment/xfer group
//
// @param sender the account creating the offering
// @param root the merkle tree root of trades consisting of from address, recipient address, asset id & amount
// @param leaves the number of leaves in the tree
// @param participantsRoot the merkle tree root of participating addresses
// @param participantLeaves the number of leaves in the participant tree
// @param expiration the unix timestamp that the offer auto-expires at if it has not been accepted by all participants
// @param marketplace the address of the marketplace to pay the fee to
// @param marketFee the fee to pay the marketplace for facilitating the offer
offer:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/hyper_swap/hyper_swap.algo.ts:178
	// assert(root !== participantsRoot, errs.BAD_ROOTS)
	frame_dig -3 // root: bytes32
	frame_dig -5 // participantsRoot: bytes32
	!=
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:180
	// verifyPayTxn(mbrPayment, {
	//             amount: HYPER_SWAP_OFFER_MBR_AMOUNT,
	//             receiver: this.app.address,
	//         })
	// verify amount
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Amount
	pushint 236000
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"amount","expected":"HYPER_SWAP_OFFER_MBR_AMOUNT"}
	assert

	// verify receiver
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"receiver","expected":"this.app.address"}
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:185
	// akitaFee = AppID.fromUint64(AkitaAppIDsDAO).globalState(AKITA_DAO_HYPER_SWAP_OFFER_FEE_KEY) as uint64
	intc 0 // 0
	pushbytes "hyper_swap_offer_fee"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(AkitaAppIDsDAO).globalState(AKITA_DAO_HYPER_SWAP_OFFER_FEE_KEY)
	assert
	frame_bury 0 // akitaFee: uint64

	// contracts/hyper_swap/hyper_swap.algo.ts:186
	// verifyPayTxn(feePayment, {
	//             amount: akitaFee,
	//             receiver: AppID.fromUint64(AkitaAppIDsDAO).address,
	//         })
	// verify amount
	frame_dig -2 // feePayment: PayTxn
	gtxns Amount
	frame_dig 0 // akitaFee: uint64
	==

	// transaction verification failed: {"txn":"feePayment","field":"amount","expected":"akitaFee"}
	assert

	// verify receiver
	frame_dig -2 // feePayment: PayTxn
	gtxns Receiver
	intc 0 // 0
	app_params_get AppAddress
	pop
	==

	// transaction verification failed: {"txn":"feePayment","field":"receiver","expected":"AppID.fromUint64(AkitaAppIDsDAO).address"}
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:199
	// this.pendingGroup.addMethodCall<typeof MetaMerkles.prototype.addRoot, boolean>({
	//             applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles),
	//             methodArgs: [
	//                 {
	//                     amount: (MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR),
	//                     receiver: AppID.fromUint64(AkitaAppIDsMetaMerkles).address,
	//                     fee: 0,
	//                 },
	//                 root,
	//                 root,
	//                 META_MERKLE_TRADE_SCHEMA,
	//                 META_MERKLE_TRADE_TYPE
	//             ],
	//             fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/hyper_swap/hyper_swap.algo.ts:203
	// amount: (MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR)
	intc 9 // 83500
	itxn_field Amount

	// contracts/hyper_swap/hyper_swap.algo.ts:204
	// receiver: AppID.fromUint64(AkitaAppIDsMetaMerkles).address
	intc 0 // 0
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/hyper_swap/hyper_swap.algo.ts:205
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 5 //  appl
	itxn_field TypeEnum
	bytec 9 //  method "addRoot(pay,string,byte[32],uint64,uint64)void"
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:200
	// applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/hyper_swap/hyper_swap.algo.ts:201
	// methodArgs: [
	//                 {
	//                     amount: (MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR),
	//                     receiver: AppID.fromUint64(AkitaAppIDsMetaMerkles).address,
	//                     fee: 0,
	//                 },
	//                 root,
	//                 root,
	//                 META_MERKLE_TRADE_SCHEMA,
	//                 META_MERKLE_TRADE_TYPE
	//             ]
	frame_dig -3 // root: bytes32
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -3 // root: bytes32
	itxn_field ApplicationArgs
	bytec 7 // 0x0000000000000004
	itxn_field ApplicationArgs
	bytec 2 // 0x0000000000000003
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:212
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/hyper_swap/hyper_swap.algo.ts:216
	// this.pendingGroup.addMethodCall<typeof MetaMerkles.prototype.addRoot, boolean>({
	//             applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles),
	//             methodArgs: [
	//                 {
	//                     amount: (MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR),
	//                     receiver: AppID.fromUint64(AkitaAppIDsMetaMerkles).address,
	//                     fee: 0,
	//                 },
	//                 participantsRoot,
	//                 participantsRoot,
	//                 META_MERKLE_ADDRESS_SCHEMA,
	//                 META_MERKLE_TRADE_TYPE
	//             ],
	//             fee: 0,
	//         })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/hyper_swap/hyper_swap.algo.ts:220
	// amount: (MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR)
	intc 9 // 83500
	itxn_field Amount

	// contracts/hyper_swap/hyper_swap.algo.ts:221
	// receiver: AppID.fromUint64(AkitaAppIDsMetaMerkles).address
	intc 0 // 0
	app_params_get AppAddress
	pop
	itxn_field Receiver

	// contracts/hyper_swap/hyper_swap.algo.ts:222
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	itxn_next
	intc 5 //  appl
	itxn_field TypeEnum
	bytec 9 //  method "addRoot(pay,string,byte[32],uint64,uint64)void"
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:217
	// applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/hyper_swap/hyper_swap.algo.ts:218
	// methodArgs: [
	//                 {
	//                     amount: (MAX_ROOT_BOX_MBR + MAX_SCHEMA_BOX_MBR + MAX_TYPE_BOX_MBR),
	//                     receiver: AppID.fromUint64(AkitaAppIDsMetaMerkles).address,
	//                     fee: 0,
	//                 },
	//                 participantsRoot,
	//                 participantsRoot,
	//                 META_MERKLE_ADDRESS_SCHEMA,
	//                 META_MERKLE_TRADE_TYPE
	//             ]
	frame_dig -5 // participantsRoot: bytes32
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -5 // participantsRoot: bytes32
	itxn_field ApplicationArgs
	bytec 6 // 0x0000000000000001
	itxn_field ApplicationArgs
	bytec 2 // 0x0000000000000003
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:229
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/hyper_swap/hyper_swap.algo.ts:232
	// id = this.newOfferID()
	callsub newOfferID
	frame_bury 1 // id: uint64

	// contracts/hyper_swap/hyper_swap.algo.ts:235
	// this.participants({ id: id, address: this.txn.sender }).create(0)
	frame_dig 1 // id: uint64
	itob
	txn Sender
	concat
	intc 0 // 0
	box_create
	pop

	// contracts/hyper_swap/hyper_swap.algo.ts:238
	// this.offers(id).value = {
	//             state: STATE_OFFERED,
	//             root: root,
	//             leaves: leaves,
	//             escrowed: 0,
	//             participantRoot: participantsRoot,
	//             participantLeaves: participantLeaves,
	//             acceptances: 1,
	//             expiration: expiration
	//         }
	frame_dig 1 // id: uint64
	itob
	bytec 4 // 0x0000000000000000
	frame_dig -3 // root: bytes32
	concat
	frame_dig -4 // leaves: uint64
	itob
	concat
	bytec 4 // 0x0000000000000000
	concat
	frame_dig -5 // participantsRoot: bytes32
	concat
	frame_dig -6 // participantLeaves: uint64
	itob
	concat
	bytec 6 // 0x0000000000000001
	concat
	frame_dig -7 // expiration: uint64
	itob
	concat
	box_put

	// contracts/hyper_swap/hyper_swap.algo.ts:250
	// this.pendingGroup.submit()
	itxn_submit
	retsub

// accept(pay,uint64,byte[32][])void
*abi_route_accept:
	// proof: byte[32][]
	txna ApplicationArgs 2
	extract 2 0

	// id: uint64
	txna ApplicationArgs 1
	btoi

	// mbrPayment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 2 (mbrPayment) for accept must be a pay transaction
	assert

	// execute accept(pay,uint64,byte[32][])void
	callsub accept
	intc 1 // 1
	return

// accept(mbrPayment: PayTxn, id: uint64, proof: bytes32[]): void
//
// Accepts an offer
//
// @param sender the account accepting the offering
// @param id the id of the offer being accepted
// @param proof the bytes32 array proof of inclusion in the participants list
accept:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/hyper_swap/hyper_swap.algo.ts:268
	// assert(this.offers(id).exists)
	frame_dig -2 // id: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:269
	// offer = this.offers(id).value
	frame_dig -2 // id: uint64
	itob
	frame_bury 0 // storage key//offer

	// contracts/hyper_swap/hyper_swap.algo.ts:271
	// assert(offer.state === STATE_OFFERED)
	intc 0 // 0
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 0 // 0
	==
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:273
	// assert(
	//             sendMethodCall<typeof MetaMerkles.prototype.verify, boolean>({
	//                 applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles),
	//                 methodArgs: [
	//                     this.app.address,
	//                     offer.participantRoot,
	//                     sha256(sha256(this.txn.sender)),
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ],
	//                 fee: 0,
	//             })
	//         )
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	bytec 3 //  method "verify(address,string,byte[32],byte[32][],uint64)bool"
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:275
	// applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/hyper_swap/hyper_swap.algo.ts:276
	// methodArgs: [
	//                     this.app.address,
	//                     offer.participantRoot,
	//                     sha256(sha256(this.txn.sender)),
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ]
	global CurrentApplicationAddress
	itxn_field ApplicationArgs
	intc 12 //  headOffset
	intc 3 // 32
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	txn Sender
	sha256
	sha256
	itxn_field ApplicationArgs
	frame_dig -3 // proof: bytes32[]
	dup
	len
	intc 3 // 32
	/
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	bytec 2 // 0x0000000000000003
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:283
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:287
	// assert(!this.participants({ id: id, address: this.txn.sender }).exists)
	frame_dig -2 // id: uint64
	itob
	txn Sender
	concat
	box_len
	swap
	pop
	!
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:289
	// this.offers(id).value.acceptances += 1
	intc 8 //  headOffset
	dup
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	+
	itob
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_replace

	// contracts/hyper_swap/hyper_swap.algo.ts:291
	// verifyPayTxn(mbrPayment, {
	//             amount: HYPER_SWAP_PARTICIPANT_MBR_AMOUNT,
	//             receiver: this.app.address,
	//         })
	// verify amount
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Amount
	pushint 18500
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"amount","expected":"HYPER_SWAP_PARTICIPANT_MBR_AMOUNT"}
	assert

	// verify receiver
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"receiver","expected":"this.app.address"}
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:304
	// this.participants({ id: id, address: this.txn.sender }).create(0)
	frame_dig -2 // id: uint64
	itob
	txn Sender
	concat
	intc 0 // 0
	box_create
	pop

	// *if2_condition
	// contracts/hyper_swap/hyper_swap.algo.ts:306
	// offer.participantLeaves === (offer.acceptances + 1)
	pushint 88 // headOffset
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 8 //  headOffset
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	+
	==
	bz *if2_end

	// *if2_consequent
	// contracts/hyper_swap/hyper_swap.algo.ts:307
	// this.offers(id).value.state = STATE_ESCROWING
	intc 0 // 0
	bytec 6 // 0x0000000000000001
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_replace

*if2_end:
	retsub

// escrow(pay,uint64,address,uint64,byte[32][])void
*abi_route_escrow:
	// proof: byte[32][]
	txna ApplicationArgs 4
	extract 2 0

	// amount: uint64
	txna ApplicationArgs 3
	btoi

	// receiver: address
	txna ApplicationArgs 2
	dup
	len
	intc 3 // 32
	==

	// argument 2 (receiver) for escrow must be a address
	assert

	// id: uint64
	txna ApplicationArgs 1
	btoi

	// payment: pay
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 4 (payment) for escrow must be a pay transaction
	assert

	// execute escrow(pay,uint64,address,uint64,byte[32][])void
	callsub escrow
	intc 1 // 1
	return

// escrow(payment: PayTxn, id: uint64, receiver: Address, amount: uint64, proof: bytes32[]): void
//
// Escrows the assets in the trade for a given leaf in the tree
//
// @param sender the sender in the offer leaf
// @param id the id of the offer
// @param receiver the recipient in the offer leaf
// @param asset the asset in the offer leaf
// @param amount the amount in the offer leaf
// @param proof the proof to verify the details are part of the tree
escrow:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/hyper_swap/hyper_swap.algo.ts:335
	// assert(this.offers(id).exists)
	frame_dig -2 // id: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:336
	// offer = this.offers(id).value
	frame_dig -2 // id: uint64
	itob
	frame_bury 0 // storage key//offer

	// contracts/hyper_swap/hyper_swap.algo.ts:338
	// assert(offer.state === STATE_ESCROWING)
	intc 0 // 0
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	==
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:340
	// assert(this.participants({ id: id, address: this.txn.sender }).exists)
	frame_dig -2 // id: uint64
	itob
	txn Sender
	concat
	box_len
	swap
	pop
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:342
	// hash = sha256(sha256(concat(this.txn.sender, concat(receiver, itob(0) + itob(amount)))))
	txn Sender
	frame_dig -3 // receiver: Address
	bytec 4 // 0x0000000000000000
	frame_dig -4 // amount: uint64
	itob
	concat
	concat
	concat
	sha256
	sha256
	frame_bury 1 // hash: byte[32]

	// contracts/hyper_swap/hyper_swap.algo.ts:343
	// assert(!this.hashes({ id: id, hash: hash }).exists)
	bytec 1 //  "h"
	frame_dig -2 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_len
	swap
	pop
	!
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:345
	// assert(
	//             sendMethodCall<typeof MetaMerkles.prototype.verify, boolean>({
	//                 applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles),
	//                 methodArgs: [
	//                     this.app.address,
	//                     offer.root,
	//                     hash,
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ],
	//                 fee: 0,
	//             })
	//         )
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	bytec 3 //  method "verify(address,string,byte[32],byte[32][],uint64)bool"
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:347
	// applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/hyper_swap/hyper_swap.algo.ts:348
	// methodArgs: [
	//                     this.app.address,
	//                     offer.root,
	//                     hash,
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ]
	global CurrentApplicationAddress
	itxn_field ApplicationArgs
	intc 2 //  headOffset
	intc 3 // 32
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig 1 // hash: byte[32]
	itxn_field ApplicationArgs
	frame_dig -5 // proof: bytes32[]
	dup
	len
	intc 3 // 32
	/
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	bytec 2 // 0x0000000000000003
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:355
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:359
	// verifyPayTxn(payment, {
	//             amount: amount + HYPER_SWAP_HASH_MBR_AMOUNT,
	//             receiver: this.app.address,
	//         })
	// verify amount
	frame_dig -1 // payment: PayTxn
	gtxns Amount
	frame_dig -4 // amount: uint64
	intc 10 // 22100
	+
	==

	// transaction verification failed: {"txn":"payment","field":"amount","expected":"amount + HYPER_SWAP_HASH_MBR_AMOUNT"}
	assert

	// verify receiver
	frame_dig -1 // payment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"payment","field":"receiver","expected":"this.app.address"}
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:365
	// this.hashes({ id: id, hash: hash }).value = 0
	bytec 1 //  "h"
	frame_dig -2 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	bytec 4 // 0x0000000000000000
	box_put

	// contracts/hyper_swap/hyper_swap.algo.ts:367
	// this.offers(id).value.escrowed += 1
	intc 4 //  headOffset
	dup
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	+
	itob
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_replace

	// *if3_condition
	// contracts/hyper_swap/hyper_swap.algo.ts:369
	// offer.leaves === (offer.escrowed + 1)
	intc 11 //  headOffset
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 4 //  headOffset
	intc 2 // 8
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	+
	==
	bz *if3_end

	// *if3_consequent
	// contracts/hyper_swap/hyper_swap.algo.ts:370
	// this.offers(id).value.state = STATE_DISBURSING
	intc 0 // 0
	bytec 8 // 0x0000000000000002
	frame_dig -2 // id: uint64
	itob
	cover 2
	box_replace

*if3_end:
	retsub

// escrowAsa(pay,axfer,uint64,address,uint64,uint64,byte[32][])void
*abi_route_escrowAsa:
	// proof: byte[32][]
	txna ApplicationArgs 5
	extract 2 0

	// amount: uint64
	txna ApplicationArgs 4
	btoi

	// asset: uint64
	txna ApplicationArgs 3
	btoi

	// receiver: address
	txna ApplicationArgs 2
	dup
	len
	intc 3 // 32
	==

	// argument 3 (receiver) for escrowAsa must be a address
	assert

	// id: uint64
	txna ApplicationArgs 1
	btoi

	// assetXfer: axfer
	txn GroupIndex
	intc 1 // 1
	-
	dup
	gtxns TypeEnum
	intc 6 //  axfer
	==

	// argument 5 (assetXfer) for escrowAsa must be a axfer transaction
	assert

	// mbrPayment: pay
	txn GroupIndex
	intc 7 // 2
	-
	dup
	gtxns TypeEnum
	intc 1 //  pay
	==

	// argument 6 (mbrPayment) for escrowAsa must be a pay transaction
	assert

	// execute escrowAsa(pay,axfer,uint64,address,uint64,uint64,byte[32][])void
	callsub escrowAsa
	intc 1 // 1
	return

// escrowAsa(mbrPayment: PayTxn, assetXfer: AssetTransferTxn, id: uint64, receiver: Address, asset: AssetID, amount: uint64, proof: bytes32[]): void
//
// Escrows the assets in the trade for a given leaf in the tree
//
// @param sender the sender in the offer leaf
// @param id the id of the offer
// @param receiver the recipient in the offer leaf
// @param asset the asset in the offer leaf
// @param amount the amount in the offer leaf
// @param proof the proof to verify the details are part of the tree
escrowAsa:
	proto 7 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/hyper_swap/hyper_swap.algo.ts:396
	// assert(this.offers(id).exists)
	frame_dig -3 // id: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:397
	// offer = this.offers(id).value
	frame_dig -3 // id: uint64
	itob
	frame_bury 0 // storage key//offer

	// contracts/hyper_swap/hyper_swap.algo.ts:399
	// assert(offer.state === STATE_ESCROWING)
	intc 0 // 0
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	==
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:401
	// assert(this.participants({ id: id, address: this.txn.sender }).exists)
	frame_dig -3 // id: uint64
	itob
	txn Sender
	concat
	box_len
	swap
	pop
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:403
	// hash = sha256(sha256(concat(this.txn.sender, concat(receiver, itob(asset) + itob(amount)))))
	txn Sender
	frame_dig -4 // receiver: Address
	frame_dig -5 // asset: AssetID
	itob
	frame_dig -6 // amount: uint64
	itob
	concat
	concat
	concat
	sha256
	sha256
	frame_bury 1 // hash: byte[32]

	// contracts/hyper_swap/hyper_swap.algo.ts:404
	// assert(!this.hashes({ id: id, hash: hash }).exists)
	bytec 1 //  "h"
	frame_dig -3 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_len
	swap
	pop
	!
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:406
	// assert(
	//             sendMethodCall<typeof MetaMerkles.prototype.verify, boolean>({
	//                 applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles),
	//                 methodArgs: [
	//                     this.app.address,
	//                     offer.root,
	//                     hash,
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ],
	//                 fee: 0,
	//             })
	//         )
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	bytec 3 //  method "verify(address,string,byte[32],byte[32][],uint64)bool"
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:408
	// applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/hyper_swap/hyper_swap.algo.ts:409
	// methodArgs: [
	//                     this.app.address,
	//                     offer.root,
	//                     hash,
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ]
	global CurrentApplicationAddress
	itxn_field ApplicationArgs
	intc 2 //  headOffset
	intc 3 // 32
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig 1 // hash: byte[32]
	itxn_field ApplicationArgs
	frame_dig -7 // proof: bytes32[]
	dup
	len
	intc 3 // 32
	/
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	bytec 2 // 0x0000000000000003
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:416
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:421
	// mbrAmount = HYPER_SWAP_HASH_MBR_AMOUNT
	intc 10 // 22100
	frame_bury 2 // mbrAmount: uint64

	// *if4_condition
	// contracts/hyper_swap/hyper_swap.algo.ts:424
	// !receiver.isOptedInToAsset(asset)
	frame_dig -4 // receiver: Address
	frame_dig -5 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if4_end

	// *if4_consequent
	// contracts/hyper_swap/hyper_swap.algo.ts:425
	// mbrAmount += globals.minBalance + globals.assetOptInMinBalance + globals.minTxnFee
	frame_dig 2 // mbrAmount: uint64
	global MinBalance
	global AssetOptInMinBalance
	+
	global MinTxnFee
	+
	+
	frame_bury 2 // mbrAmount: uint64

*if4_end:
	// *if5_condition
	// contracts/hyper_swap/hyper_swap.algo.ts:428
	// !this.app.address.isOptedInToAsset(asset)
	global CurrentApplicationAddress
	frame_dig -5 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if5_end

	// *if5_consequent
	// contracts/hyper_swap/hyper_swap.algo.ts:429
	// sendAssetTransfer({
	//                 xferAsset: asset,
	//                 assetAmount: 0,
	//                 assetReceiver: this.app.address,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 6 //  axfer
	itxn_field TypeEnum

	// contracts/hyper_swap/hyper_swap.algo.ts:430
	// xferAsset: asset
	frame_dig -5 // asset: AssetID
	itxn_field XferAsset

	// contracts/hyper_swap/hyper_swap.algo.ts:431
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/hyper_swap/hyper_swap.algo.ts:432
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/hyper_swap/hyper_swap.algo.ts:433
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/hyper_swap/hyper_swap.algo.ts:435
	// mbrAmount += globals.assetOptInMinBalance
	frame_dig 2 // mbrAmount: uint64
	global AssetOptInMinBalance
	+
	frame_bury 2 // mbrAmount: uint64

*if5_end:
	// contracts/hyper_swap/hyper_swap.algo.ts:438
	// verifyPayTxn(mbrPayment, {
	//             amount: mbrAmount,
	//             receiver: this.app.address,
	//         })
	// verify amount
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Amount
	frame_dig 2 // mbrAmount: uint64
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"amount","expected":"mbrAmount"}
	assert

	// verify receiver
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"receiver","expected":"this.app.address"}
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:443
	// verifyAssetTransferTxn(assetXfer, {
	//             xferAsset: asset,
	//             assetAmount: amount,
	//             assetReceiver: this.app.address,
	//         })
	// verify xferAsset
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns XferAsset
	frame_dig -5 // asset: AssetID
	==

	// transaction verification failed: {"txn":"assetXfer","field":"xferAsset","expected":"asset"}
	assert

	// verify assetAmount
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -6 // amount: uint64
	==

	// transaction verification failed: {"txn":"assetXfer","field":"assetAmount","expected":"amount"}
	assert

	// verify assetReceiver
	frame_dig -2 // assetXfer: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"assetXfer","field":"assetReceiver","expected":"this.app.address"}
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:450
	// this.hashes({ id: id, hash: hash }).value = mbrAmount
	bytec 1 //  "h"
	frame_dig -3 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	frame_dig 2 // mbrAmount: uint64
	itob
	box_put

	// contracts/hyper_swap/hyper_swap.algo.ts:452
	// this.offers(id).value.escrowed += 1
	intc 4 //  headOffset
	dup
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	+
	itob
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_replace

	// *if6_condition
	// contracts/hyper_swap/hyper_swap.algo.ts:454
	// offer.leaves === (offer.escrowed + 1)
	intc 11 //  headOffset
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 4 //  headOffset
	intc 2 // 8
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	+
	==
	bz *if6_end

	// *if6_consequent
	// contracts/hyper_swap/hyper_swap.algo.ts:455
	// this.offers(id).value.state = STATE_DISBURSING
	intc 0 // 0
	bytec 8 // 0x0000000000000002
	frame_dig -3 // id: uint64
	itob
	cover 2
	box_replace

*if6_end:
	retsub

// disburse(uint64,address,uint64,uint64)void
*abi_route_disburse:
	// amount: uint64
	txna ApplicationArgs 4
	btoi

	// asset: uint64
	txna ApplicationArgs 3
	btoi

	// receiver: address
	txna ApplicationArgs 2
	dup
	len
	intc 3 // 32
	==

	// argument 2 (receiver) for disburse must be a address
	assert

	// id: uint64
	txna ApplicationArgs 1
	btoi

	// execute disburse(uint64,address,uint64,uint64)void
	callsub disburse
	intc 1 // 1
	return

// disburse(id: uint64, receiver: Address, asset: AssetID, amount: uint64): void
//
// Disburses assets for a leaf in the tree, ensuring ordered processing
//
// @param sender the sender abstracted account app id in the leaf
// @param id the id of the offer
// @param receiver the recipient abstracted account app id for the address in the leaf
// @param asset the asset being transferred
// @param amount the amount being transferred
disburse:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/hyper_swap/hyper_swap.algo.ts:475
	// assert(this.offers(id).exists)
	frame_dig -1 // id: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:476
	// offer = this.offers(id).value
	frame_dig -1 // id: uint64
	itob
	frame_bury 0 // storage key//offer

	// contracts/hyper_swap/hyper_swap.algo.ts:478
	// assert(offer.state === STATE_DISBURSING)
	intc 0 // 0
	intc 2 // 8
	frame_dig -1 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 7 // 2
	==
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:481
	// hash = sha256(sha256(concat(this.txn.sender, concat(receiver, itob(asset) + itob(amount)))))
	txn Sender
	frame_dig -2 // receiver: Address
	frame_dig -3 // asset: AssetID
	itob
	frame_dig -4 // amount: uint64
	itob
	concat
	concat
	concat
	sha256
	sha256
	frame_bury 1 // hash: byte[32]

	// contracts/hyper_swap/hyper_swap.algo.ts:482
	// assert(this.hashes({ id: id, hash: hash }).exists)
	bytec 1 //  "h"
	frame_dig -1 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_len
	swap
	pop
	assert

	// *if7_condition
	// contracts/hyper_swap/hyper_swap.algo.ts:485
	// asset.id === 0
	frame_dig -3 // asset: AssetID
	intc 0 // 0
	==
	bz *if7_else

	// *if7_consequent
	// contracts/hyper_swap/hyper_swap.algo.ts:486
	// sendPayment({
	//                 amount: amount,
	//                 receiver: receiver,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/hyper_swap/hyper_swap.algo.ts:487
	// amount: amount
	frame_dig -4 // amount: uint64
	itxn_field Amount

	// contracts/hyper_swap/hyper_swap.algo.ts:488
	// receiver: receiver
	frame_dig -2 // receiver: Address
	itxn_field Receiver

	// contracts/hyper_swap/hyper_swap.algo.ts:489
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if7_end

*if7_else:
	// *if8_condition
	// contracts/hyper_swap/hyper_swap.algo.ts:492
	// !receiver.isOptedInToAsset(asset)
	frame_dig -2 // receiver: Address
	frame_dig -3 // asset: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	!
	bz *if8_else

	// *if8_consequent
	// contracts/hyper_swap/hyper_swap.algo.ts:493
	// this.arc59OptInAndSend(receiver, asset, amount)
	frame_dig -4 // amount: uint64
	frame_dig -3 // asset: AssetID
	frame_dig -2 // receiver: Address
	callsub arc59OptInAndSend
	b *if8_end

*if8_else:
	// contracts/hyper_swap/hyper_swap.algo.ts:495
	// this.pendingGroup.addAssetTransfer({
	//                     xferAsset: asset,
	//                     assetAmount: amount,
	//                     assetReceiver: receiver,
	//                     fee: 0,
	//                 })
	itxn_next
	intc 6 //  axfer
	itxn_field TypeEnum

	// contracts/hyper_swap/hyper_swap.algo.ts:496
	// xferAsset: asset
	frame_dig -3 // asset: AssetID
	itxn_field XferAsset

	// contracts/hyper_swap/hyper_swap.algo.ts:497
	// assetAmount: amount
	frame_dig -4 // amount: uint64
	itxn_field AssetAmount

	// contracts/hyper_swap/hyper_swap.algo.ts:498
	// assetReceiver: receiver
	frame_dig -2 // receiver: Address
	itxn_field AssetReceiver

	// contracts/hyper_swap/hyper_swap.algo.ts:499
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/hyper_swap/hyper_swap.algo.ts:502
	// refundAmount = this.hashes({ id: id, hash: hash }).value
	bytec 1 //  "h"
	frame_dig -1 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_get

	// box value does not exist: this.hashes({ id: id, hash: hash }).value
	assert
	btoi
	frame_bury 2 // refundAmount: uint64

	// *if9_condition
	// contracts/hyper_swap/hyper_swap.algo.ts:503
	// (this.app.address.assetBalance(asset) - amount) === 0
	global CurrentApplicationAddress
	frame_dig -3 // asset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -4 // amount: uint64
	-
	intc 0 // 0
	==
	bz *if9_else

	// *if9_consequent
	// contracts/hyper_swap/hyper_swap.algo.ts:504
	// this.pendingGroup.addAssetTransfer({
	//                         xferAsset: asset,
	//                         assetAmount: 0,
	//                         assetReceiver: asset.creator,
	//                         assetCloseTo: asset.creator,
	//                         fee: 0,
	//                     })
	itxn_next
	intc 6 //  axfer
	itxn_field TypeEnum

	// contracts/hyper_swap/hyper_swap.algo.ts:505
	// xferAsset: asset
	frame_dig -3 // asset: AssetID
	itxn_field XferAsset

	// contracts/hyper_swap/hyper_swap.algo.ts:506
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/hyper_swap/hyper_swap.algo.ts:507
	// assetReceiver: asset.creator
	frame_dig -3 // asset: AssetID
	asset_params_get AssetCreator
	pop
	itxn_field AssetReceiver

	// contracts/hyper_swap/hyper_swap.algo.ts:508
	// assetCloseTo: asset.creator
	frame_dig -3 // asset: AssetID
	asset_params_get AssetCreator
	pop
	itxn_field AssetCloseTo

	// contracts/hyper_swap/hyper_swap.algo.ts:509
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	b *if9_end

*if9_else:
	// contracts/hyper_swap/hyper_swap.algo.ts:512
	// refundAmount -= globals.assetOptInMinBalance
	frame_dig 2 // refundAmount: uint64
	global AssetOptInMinBalance
	-
	frame_bury 2 // refundAmount: uint64

*if9_end:
	// contracts/hyper_swap/hyper_swap.algo.ts:520
	// this.pendingGroup.addPayment({
	//                     amount: refundAmount,
	//                     receiver: this.txn.sender,
	//                     fee: 0,
	//                 })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/hyper_swap/hyper_swap.algo.ts:521
	// amount: refundAmount
	frame_dig 2 // refundAmount: uint64
	itxn_field Amount

	// contracts/hyper_swap/hyper_swap.algo.ts:522
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/hyper_swap/hyper_swap.algo.ts:523
	// fee: 0
	intc 0 // 0
	itxn_field Fee

*if8_end:

*if7_end:
	// contracts/hyper_swap/hyper_swap.algo.ts:528
	// this.hashes({ id: id, hash: hash }).delete()
	bytec 1 //  "h"
	frame_dig -1 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_del

	// contracts/hyper_swap/hyper_swap.algo.ts:529
	// this.offers(id).value.escrowed -= 1
	intc 4 //  headOffset
	dup
	intc 2 // 8
	frame_dig -1 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	-
	itob
	frame_dig -1 // id: uint64
	itob
	cover 2
	box_replace

	// *if10_condition
	// contracts/hyper_swap/hyper_swap.algo.ts:532
	// (offer.escrowed - 1) === 0
	intc 4 //  headOffset
	intc 2 // 8
	frame_dig -1 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	-
	intc 0 // 0
	==
	bz *if10_end

	// *if10_consequent
	// contracts/hyper_swap/hyper_swap.algo.ts:533
	// this.offers(id).value.state = STATE_COMPLETED
	intc 0 // 0
	bytec 2 // 0x0000000000000003
	frame_dig -1 // id: uint64
	itob
	cover 2
	box_replace

*if10_end:
	retsub

// cancel(uint64,byte[32][])void
*abi_route_cancel:
	// proof: byte[32][]
	txna ApplicationArgs 2
	extract 2 0

	// id: uint64
	txna ApplicationArgs 1
	btoi

	// execute cancel(uint64,byte[32][])void
	callsub cancel
	intc 1 // 1
	return

// cancel(id: uint64, proof: bytes32[]): void
//
//
// @param sender the abstracted account of the user cancelling the swap
// @param id the id of the offer being cancelled
// @param proof a proof of inclusion in the participants list
cancel:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/hyper_swap/hyper_swap.algo.ts:546
	// assert(this.offers(id).exists)
	frame_dig -1 // id: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:547
	// offer = this.offers(id).value
	frame_dig -1 // id: uint64
	itob
	frame_bury 0 // storage key//offer

	// contracts/hyper_swap/hyper_swap.algo.ts:549
	// assert(offer.state === STATE_OFFERED || offer.state === STATE_ESCROWING)
	intc 0 // 0
	intc 2 // 8
	frame_dig -1 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 0 // 0
	==
	dup
	bnz *skip_or1
	intc 0 // 0
	intc 2 // 8
	frame_dig -1 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	==
	||

*skip_or1:
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:551
	// assert(
	//             sendMethodCall<typeof MetaMerkles.prototype.verify, boolean>({
	//                 applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles),
	//                 methodArgs: [
	//                     this.app.address,
	//                     offer.participantRoot,
	//                     sha256(sha256(this.txn.sender)),
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ],
	//                 fee: 0,
	//             })
	//         )
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	bytec 3 //  method "verify(address,string,byte[32],byte[32][],uint64)bool"
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:553
	// applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/hyper_swap/hyper_swap.algo.ts:554
	// methodArgs: [
	//                     this.app.address,
	//                     offer.participantRoot,
	//                     sha256(sha256(this.txn.sender)),
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ]
	global CurrentApplicationAddress
	itxn_field ApplicationArgs
	intc 12 //  headOffset
	intc 3 // 32
	frame_dig -1 // id: uint64
	itob
	cover 2
	box_extract
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	txn Sender
	sha256
	sha256
	itxn_field ApplicationArgs
	frame_dig -2 // proof: bytes32[]
	dup
	len
	intc 3 // 32
	/
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	bytec 2 // 0x0000000000000003
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:561
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:565
	// this.offers(id).value.state = STATE_CANCELLED
	intc 0 // 0
	bytec 7 // 0x0000000000000004
	frame_dig -1 // id: uint64
	itob
	cover 2
	box_replace
	retsub

// withdraw(uint64,address,uint64,uint64,byte[32][])void
*abi_route_withdraw:
	// proof: byte[32][]
	txna ApplicationArgs 5
	extract 2 0

	// amount: uint64
	txna ApplicationArgs 4
	btoi

	// asset: uint64
	txna ApplicationArgs 3
	btoi

	// receiver: address
	txna ApplicationArgs 2
	dup
	len
	intc 3 // 32
	==

	// argument 3 (receiver) for withdraw must be a address
	assert

	// id: uint64
	txna ApplicationArgs 1
	btoi

	// execute withdraw(uint64,address,uint64,uint64,byte[32][])void
	callsub withdraw
	intc 1 // 1
	return

// withdraw(id: uint64, receiver: Address, asset: AssetID, amount: uint64, proof: bytes32[]): void
//
// Withdraws your assets from a cancelled swap if they're escrowed
//
// @param sender the abstracted account of the user reclaiming their assets
// @param id the id of the cancelled offer
// @param receiver the receiver of the leaf's swap
// @param asset the asset of the leaf's swap
// @param amount the amount of the leaf's swap
// @param proof the proof that the leaf is in the tree
// @param rekeyBack whether the abstracted account should be rekeyed back at the end
withdraw:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/hyper_swap/hyper_swap.algo.ts:591
	// assert(this.offers(id).exists)
	frame_dig -1 // id: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:592
	// offer = this.offers(id).value
	frame_dig -1 // id: uint64
	itob
	frame_bury 0 // storage key//offer

	// contracts/hyper_swap/hyper_swap.algo.ts:594
	// assert(offer.state === STATE_CANCELLED)
	intc 0 // 0
	intc 2 // 8
	frame_dig -1 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 6 // 4
	==
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:596
	// assert(offer.escrowed > 0)
	intc 4 //  headOffset
	intc 2 // 8
	frame_dig -1 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 0 // 0
	>
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:598
	// hash = sha256(sha256(concat(this.txn.sender, concat(receiver, itob(asset) + itob(amount)))))
	txn Sender
	frame_dig -2 // receiver: Address
	frame_dig -3 // asset: AssetID
	itob
	frame_dig -4 // amount: uint64
	itob
	concat
	concat
	concat
	sha256
	sha256
	frame_bury 1 // hash: byte[32]

	// contracts/hyper_swap/hyper_swap.algo.ts:599
	// assert(this.hashes({ id: id, hash: hash }).exists)
	bytec 1 //  "h"
	frame_dig -1 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_len
	swap
	pop
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:601
	// assert(
	//             sendMethodCall<typeof MetaMerkles.prototype.verify, boolean>({
	//                 applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles),
	//                 methodArgs: [
	//                     this.app.address,
	//                     offer.root,
	//                     hash,
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ],
	//                 fee: 0,
	//             })
	//         )
	itxn_begin
	intc 5 //  appl
	itxn_field TypeEnum
	bytec 3 //  method "verify(address,string,byte[32],byte[32][],uint64)bool"
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:603
	// applicationID: AppID.fromUint64(AkitaAppIDsMetaMerkles)
	intc 0 // 0
	itxn_field ApplicationID

	// contracts/hyper_swap/hyper_swap.algo.ts:604
	// methodArgs: [
	//                     this.app.address,
	//                     offer.root,
	//                     hash,
	//                     proof,
	//                     META_MERKLE_TRADE_TYPE
	//                 ]
	global CurrentApplicationAddress
	itxn_field ApplicationArgs
	intc 2 //  headOffset
	intc 3 // 32
	frame_dig -1 // id: uint64
	itob
	cover 2
	box_extract
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig 1 // hash: byte[32]
	itxn_field ApplicationArgs
	frame_dig -5 // proof: bytes32[]
	dup
	len
	intc 3 // 32
	/
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	bytec 2 // 0x0000000000000003
	itxn_field ApplicationArgs

	// contracts/hyper_swap/hyper_swap.algo.ts:611
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 1 // 1
	-
	itxnas Logs
	extract 4 0
	intc 0 // 0
	getbit
	assert

	// contracts/hyper_swap/hyper_swap.algo.ts:615
	// refundAmount = this.hashes({ id: id, hash: hash }).value
	bytec 1 //  "h"
	frame_dig -1 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_get

	// box value does not exist: this.hashes({ id: id, hash: hash }).value
	assert
	btoi
	frame_bury 2 // refundAmount: uint64

	// *if11_condition
	// contracts/hyper_swap/hyper_swap.algo.ts:616
	// asset.id !== 0 && (this.app.address.assetBalance(asset) - amount) === 0
	frame_dig -3 // asset: AssetID
	intc 0 // 0
	!=
	dup
	bz *skip_and0
	global CurrentApplicationAddress
	frame_dig -3 // asset: AssetID
	asset_holding_get AssetBalance
	pop
	frame_dig -4 // amount: uint64
	-
	intc 0 // 0
	==
	&&

*skip_and0:
	bz *if11_else

	// *if11_consequent
	// contracts/hyper_swap/hyper_swap.algo.ts:617
	// this.pendingGroup.addAssetTransfer({
	//                 xferAsset: asset,
	//                 assetAmount: 0,
	//                 assetReceiver: asset.creator,
	//                 assetCloseTo: asset.creator,
	//                 fee: 0,
	//             })
	itxn_next
	intc 6 //  axfer
	itxn_field TypeEnum

	// contracts/hyper_swap/hyper_swap.algo.ts:618
	// xferAsset: asset
	frame_dig -3 // asset: AssetID
	itxn_field XferAsset

	// contracts/hyper_swap/hyper_swap.algo.ts:619
	// assetAmount: 0
	intc 0 // 0
	itxn_field AssetAmount

	// contracts/hyper_swap/hyper_swap.algo.ts:620
	// assetReceiver: asset.creator
	frame_dig -3 // asset: AssetID
	asset_params_get AssetCreator
	pop
	itxn_field AssetReceiver

	// contracts/hyper_swap/hyper_swap.algo.ts:621
	// assetCloseTo: asset.creator
	frame_dig -3 // asset: AssetID
	asset_params_get AssetCreator
	pop
	itxn_field AssetCloseTo

	// contracts/hyper_swap/hyper_swap.algo.ts:622
	// fee: 0
	intc 0 // 0
	itxn_field Fee
	b *if11_end

*if11_else:
	// contracts/hyper_swap/hyper_swap.algo.ts:625
	// refundAmount -= globals.assetOptInMinBalance
	frame_dig 2 // refundAmount: uint64
	global AssetOptInMinBalance
	-
	frame_bury 2 // refundAmount: uint64

*if11_end:
	// *if12_condition
	// contracts/hyper_swap/hyper_swap.algo.ts:628
	// asset.id === 0
	frame_dig -3 // asset: AssetID
	intc 0 // 0
	==
	bz *if12_else

	// *if12_consequent
	// contracts/hyper_swap/hyper_swap.algo.ts:629
	// sendPayment({
	//                 amount: amount + refundAmount,
	//                 receiver: this.txn.sender,
	//                 fee: 0,
	//             })
	itxn_begin
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/hyper_swap/hyper_swap.algo.ts:630
	// amount: amount + refundAmount
	frame_dig -4 // amount: uint64
	frame_dig 2 // refundAmount: uint64
	+
	itxn_field Amount

	// contracts/hyper_swap/hyper_swap.algo.ts:631
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/hyper_swap/hyper_swap.algo.ts:632
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	b *if12_end

*if12_else:
	// contracts/hyper_swap/hyper_swap.algo.ts:659
	// this.pendingGroup.addAssetTransfer({
	//                 xferAsset: asset,
	//                 assetAmount: amount,
	//                 assetReceiver: this.txn.sender,
	//                 fee: 0,
	//             })
	itxn_next
	intc 6 //  axfer
	itxn_field TypeEnum

	// contracts/hyper_swap/hyper_swap.algo.ts:660
	// xferAsset: asset
	frame_dig -3 // asset: AssetID
	itxn_field XferAsset

	// contracts/hyper_swap/hyper_swap.algo.ts:661
	// assetAmount: amount
	frame_dig -4 // amount: uint64
	itxn_field AssetAmount

	// contracts/hyper_swap/hyper_swap.algo.ts:662
	// assetReceiver: this.txn.sender
	txn Sender
	itxn_field AssetReceiver

	// contracts/hyper_swap/hyper_swap.algo.ts:663
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/hyper_swap/hyper_swap.algo.ts:671
	// this.pendingGroup.addPayment({
	//                 amount: refundAmount,
	//                 receiver: this.txn.sender,
	//                 fee: 0,
	//             })
	itxn_next
	intc 1 //  pay
	itxn_field TypeEnum

	// contracts/hyper_swap/hyper_swap.algo.ts:672
	// amount: refundAmount
	frame_dig 2 // refundAmount: uint64
	itxn_field Amount

	// contracts/hyper_swap/hyper_swap.algo.ts:673
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/hyper_swap/hyper_swap.algo.ts:674
	// fee: 0
	intc 0 // 0
	itxn_field Fee

	// contracts/hyper_swap/hyper_swap.algo.ts:677
	// this.pendingGroup.submit()
	itxn_submit

*if12_end:
	// contracts/hyper_swap/hyper_swap.algo.ts:681
	// this.hashes({ id: id, hash: hash }).delete()
	bytec 1 //  "h"
	frame_dig -1 // id: uint64
	itob
	frame_dig 1 // hash: byte[32]
	concat
	concat
	box_del

	// contracts/hyper_swap/hyper_swap.algo.ts:683
	// this.offers(id).value.escrowed -= 1
	intc 4 //  headOffset
	dup
	intc 2 // 8
	frame_dig -1 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	-
	itob
	frame_dig -1 // id: uint64
	itob
	cover 2
	box_replace

	// *if13_condition
	// contracts/hyper_swap/hyper_swap.algo.ts:685
	// (offer.escrowed - 1) === 0
	intc 4 //  headOffset
	intc 2 // 8
	frame_dig -1 // id: uint64
	itob
	cover 2
	box_extract
	btoi
	intc 1 // 1
	-
	intc 0 // 0
	==
	bz *if13_end

	// *if13_consequent
	// contracts/hyper_swap/hyper_swap.algo.ts:686
	// this.offers(id).value.state = STATE_CANCEL_COMPLETED
	intc 0 // 0
	pushbytes 0x0000000000000005
	frame_dig -1 // id: uint64
	itob
	cover 2
	box_replace

*if13_end:
	retsub

*abi_route_createApplication:
	intc 1 // 1
	return

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x3dc09a5e // method "offer(pay,pay,byte[32],uint64,byte[32],uint64,uint64)void"
	pushbytes 0xbde1a11e // method "accept(pay,uint64,byte[32][])void"
	pushbytes 0xd85febdd // method "escrow(pay,uint64,address,uint64,byte[32][])void"
	pushbytes 0x466f871a // method "escrowAsa(pay,axfer,uint64,address,uint64,uint64,byte[32][])void"
	pushbytes 0x5bac4ce3 // method "disburse(uint64,address,uint64,uint64)void"
	pushbytes 0x0c7ab42e // method "cancel(uint64,byte[32][])void"
	pushbytes 0x0631868b // method "withdraw(uint64,address,uint64,uint64,byte[32][])void"
	txna ApplicationArgs 0
	match *abi_route_offer *abi_route_accept *abi_route_escrow *abi_route_escrowAsa *abi_route_disburse *abi_route_cancel *abi_route_withdraw

	// this contract does not implement the given ABI method for call NoOp
	err