/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils'
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from '@algorandfoundation/algokit-utils/types/app'
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'
import type { SendTransactionResult, TransactionToSign, SendTransactionFrom, SendTransactionParams } from '@algorandfoundation/algokit-utils/types/transaction'
import type { ABIResult, TransactionWithSigner } from 'algosdk'
import { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer, modelsv2 } from 'algosdk'
export const APP_SPEC: AppSpec = {
  "hints": {
    "getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "newService(uint64,bool,uint64,uint64,uint64,uint64,byte[59],bool)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "pauseService(uint64,bool,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "activateService(uint64,bool,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "shutdownService(uint64,bool,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "isShutdown(address,uint64)bool": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "block(uint64,bool,address)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "unblock(uint64,bool,address)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "isBlocked(address,address)bool": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "subscribe(uint64,bool,address,uint64,uint64,uint64,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "triggerPayment(uint64,bool,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "streakCheck(address,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "setPasses(uint64,bool,uint64,address[])void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE"
      }
    }
  },
  "bare_call_config": {
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "close_out": "NEVER",
    "update_application": "NEVER",
    "delete_application": "NEVER"
  },
  "schema": {
    "local": {
      "declared": {},
      "reserved": {}
    },
    "global": {
      "declared": {
        "version": {
          "type": "uint64",
          "key": "v"
        }
      },
      "reserved": {}
    }
  },
  "state": {
    "global": {
      "num_byte_slices": 0,
      "num_uints": 1
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0
    }
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCmludGNibG9jayAwIDEgOCAzMiA0IDY0IDcyIDQwIDQ4IDU2IDgwIDUwMDAwMDAgMTAwMCAyOF8xMDAgMyA1IDYwCmJ5dGVjYmxvY2sgMHggMHg3MyAweDZjIDB4MTUxZjdjNzUgMHgwMCAweDcwIDB4MDAwMDAwMDAwMDAwMDAwMQoKLy8gVGhpcyBURUFMIHdhcyBnZW5lcmF0ZWQgYnkgVEVBTFNjcmlwdCB2MC4xMDUuNQovLyBodHRwczovL2dpdGh1Yi5jb20vYWxnb3JhbmRmb3VuZGF0aW9uL1RFQUxTY3JpcHQKCi8vIFRoaXMgY29udHJhY3QgaXMgY29tcGxpYW50IHdpdGggYW5kL29yIGltcGxlbWVudHMgdGhlIGZvbGxvd2luZyBBUkNzOiBbIEFSQzQgXQoKLy8gVGhlIGZvbGxvd2luZyB0ZW4gbGluZXMgb2YgVEVBTCBoYW5kbGUgaW5pdGlhbCBwcm9ncmFtIGZsb3cKLy8gVGhpcyBwYXR0ZXJuIGlzIHVzZWQgdG8gbWFrZSBpdCBlYXN5IGZvciBhbnlvbmUgdG8gcGFyc2UgdGhlIHN0YXJ0IG9mIHRoZSBwcm9ncmFtIGFuZCBkZXRlcm1pbmUgaWYgYSBzcGVjaWZpYyBhY3Rpb24gaXMgYWxsb3dlZAovLyBIZXJlLCBhY3Rpb24gcmVmZXJzIHRvIHRoZSBPbkNvbXBsZXRlIGluIGNvbWJpbmF0aW9uIHdpdGggd2hldGhlciB0aGUgYXBwIGlzIGJlaW5nIGNyZWF0ZWQgb3IgY2FsbGVkCi8vIEV2ZXJ5IHBvc3NpYmxlIGFjdGlvbiBmb3IgdGhpcyBjb250cmFjdCBpcyByZXByZXNlbnRlZCBpbiB0aGUgc3dpdGNoIHN0YXRlbWVudAovLyBJZiB0aGUgYWN0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgY29udHJhY3QsIGl0cyByZXNwZWN0aXZlIGJyYW5jaCB3aWxsIGJlICIqTk9UX0lNUExFTUVOVEVEIiB3aGljaCBqdXN0IGNvbnRhaW5zICJlcnIiCnR4biBBcHBsaWNhdGlvbklECiEKcHVzaGludCA2CioKdHhuIE9uQ29tcGxldGlvbgorCnN3aXRjaCAqY2FsbF9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqY3JlYXRlX05vT3AgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVECgoqTk9UX0lNUExFTUVOVEVEOgoJLy8gVGhlIHJlcXVlc3RlZCBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgY29udHJhY3QuIEFyZSB5b3UgdXNpbmcgdGhlIGNvcnJlY3QgT25Db21wbGV0ZT8gRGlkIHlvdSBzZXQgeW91ciBhcHAgSUQ/CgllcnIKCi8vIGNvbnRyb2xzKGFkZHJlc3M6IEFkZHJlc3MpOiBib29sZWFuCmNvbnRyb2xzOgoJcHJvdG8gMSAxCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MTE0CgkvLyByZXR1cm4gYWRkcmVzcy5hdXRoQWRkciA9PT0gdGhpcy5hcHAuYWRkcmVzczsKCWZyYW1lX2RpZyAtMSAvLyBhZGRyZXNzOiBBZGRyZXNzCglhY2N0X3BhcmFtc19nZXQgQWNjdEF1dGhBZGRyCglwb3AKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoJcmV0c3ViCgovLyByZWtleUJhY2soYWRkcmVzczogQWRkcmVzcyk6IHZvaWQKcmVrZXlCYWNrOgoJcHJvdG8gMSAwCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MTE4CgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICBzZW5kZXI6IGFkZHJlc3MsCgkvLyAgICAgICBhbW91bnQ6IDAsCgkvLyAgICAgICByZWNlaXZlcjogYWRkcmVzcywKCS8vICAgICAgIHJla2V5VG86IGFkZHJlc3MsCgkvLyAgICAgICBmZWU6IDAsCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMSAvLyAgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MTE5CgkvLyBzZW5kZXI6IGFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBhZGRyZXNzOiBBZGRyZXNzCglpdHhuX2ZpZWxkIFNlbmRlcgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjEyMAoJLy8gYW1vdW50OiAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoxMjEKCS8vIHJlY2VpdmVyOiBhZGRyZXNzCglmcmFtZV9kaWcgLTEgLy8gYWRkcmVzczogQWRkcmVzcwoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjEyMgoJLy8gcmVrZXlUbzogYWRkcmVzcwoJZnJhbWVfZGlnIC0xIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWl0eG5fZmllbGQgUmVrZXlUbwoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjEyMwoJLy8gZmVlOiAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglyZXRzdWIKCi8vIGFkZFBlbmRpbmdPcHRpbihzZW5kZXI6IEFwcElELCByZWtleUJhY2s6IGJvb2xlYW4sIGFzc2V0OiBBc3NldElELCBhbW91bnQ6IHVpbnQ2NCk6IHZvaWQKYWRkUGVuZGluZ09wdGluOgoJcHJvdG8gNCAwCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MTI4CgkvLyB0aGlzLnBlbmRpbmdHcm91cC5hZGRBc3NldFRyYW5zZmVyKHsKCS8vICAgICAgIHNlbmRlcjogZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAoJLy8gICAgICAgYXNzZXRSZWNlaXZlcjogZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAoJLy8gICAgICAgYXNzZXRBbW91bnQ6IDAsCgkvLyAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAoJLy8gICAgICAgZmVlOiAwLAoJLy8gICAgIH0pCglpdHhuX25leHQKCWludGMgNCAvLyAgYXhmZXIKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoxMjkKCS8vIHNlbmRlcjogZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJaXR4bl9maWVsZCBTZW5kZXIKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoxMzAKCS8vIGFzc2V0UmVjZWl2ZXI6IGdsb2JhbHMuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjEzMQoJLy8gYXNzZXRBbW91bnQ6IDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MTMyCgkvLyB4ZmVyQXNzZXQ6IGFzc2V0CglmcmFtZV9kaWcgLTMgLy8gYXNzZXQ6IEFzc2V0SUQKCWl0eG5fZmllbGQgWGZlckFzc2V0CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MTMzCgkvLyBmZWU6IDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vICppZjBfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoxMzYKCS8vIHJla2V5QmFjawoJZnJhbWVfZGlnIC0yIC8vIHJla2V5QmFjazogYm9vbGVhbgoJYnogKmlmMF9lbHNlCgoJLy8gKmlmMF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoxMzcKCS8vIHRoaXMucGVuZGluZ0dyb3VwLmFkZFBheW1lbnQoewoJLy8gICAgICAgICBzZW5kZXI6IHNlbmRlci5hZGRyZXNzLAoJLy8gICAgICAgICByZWNlaXZlcjogZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAoJLy8gICAgICAgICBhbW91bnQ6IChnbG9iYWxzLmFzc2V0T3B0SW5NaW5CYWxhbmNlICsgYW1vdW50KSwKCS8vICAgICAgICAgcmVrZXlUbzogc2VuZGVyLmFkZHJlc3MsCgkvLyAgICAgICAgIGZlZTogMCwKCS8vICAgICAgIH0pCglpdHhuX25leHQKCWludGMgMSAvLyAgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MTM4CgkvLyBzZW5kZXI6IHNlbmRlci5hZGRyZXNzCglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCglpdHhuX2ZpZWxkIFNlbmRlcgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjEzOQoJLy8gcmVjZWl2ZXI6IGdsb2JhbHMuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoxNDAKCS8vIGFtb3VudDogKGdsb2JhbHMuYXNzZXRPcHRJbk1pbkJhbGFuY2UgKyBhbW91bnQpCglnbG9iYWwgQXNzZXRPcHRJbk1pbkJhbGFuY2UKCWZyYW1lX2RpZyAtNCAvLyBhbW91bnQ6IHVpbnQ2NAoJKwoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoxNDEKCS8vIHJla2V5VG86IHNlbmRlci5hZGRyZXNzCglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCglpdHhuX2ZpZWxkIFJla2V5VG8KCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoxNDIKCS8vIGZlZTogMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgliICppZjBfZW5kCgoqaWYwX2Vsc2U6CgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoxNDUKCS8vIHRoaXMucGVuZGluZ0dyb3VwLmFkZFBheW1lbnQoewoJLy8gICAgICAgICBzZW5kZXI6IHNlbmRlci5hZGRyZXNzLAoJLy8gICAgICAgICByZWNlaXZlcjogZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAoJLy8gICAgICAgICBhbW91bnQ6IChnbG9iYWxzLmFzc2V0T3B0SW5NaW5CYWxhbmNlICsgYW1vdW50KSwKCS8vICAgICAgICAgZmVlOiAwLAoJLy8gICAgICAgfSkKCWl0eG5fbmV4dAoJaW50YyAxIC8vICBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoxNDYKCS8vIHNlbmRlcjogc2VuZGVyLmFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWl0eG5fZmllbGQgU2VuZGVyCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MTQ3CgkvLyByZWNlaXZlcjogZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjE0OAoJLy8gYW1vdW50OiAoZ2xvYmFscy5hc3NldE9wdEluTWluQmFsYW5jZSArIGFtb3VudCkKCWdsb2JhbCBBc3NldE9wdEluTWluQmFsYW5jZQoJZnJhbWVfZGlnIC00IC8vIGFtb3VudDogdWludDY0CgkrCglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjE0OQoJLy8gZmVlOiAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCippZjBfZW5kOgoJcmV0c3ViCgovLyBnZXRMYXRlc3RXaW5kb3dTdGFydChzdGFydERhdGU6IHVpbnQ2NCwgaW50ZXJ2YWw6IHVpbnQ2NCk6IHVpbnQ2NApnZXRMYXRlc3RXaW5kb3dTdGFydDoKCXByb3RvIDIgMQoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjE1NQoJLy8gcmV0dXJuIGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wIC0gKChnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCAtIHN0YXJ0RGF0ZSkgJSBpbnRlcnZhbCk7CglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglmcmFtZV9kaWcgLTEgLy8gc3RhcnREYXRlOiB1aW50NjQKCS0KCWZyYW1lX2RpZyAtMiAvLyBpbnRlcnZhbDogdWludDY0CgklCgktCglyZXRzdWIKCi8vIHVwZGF0ZVN0cmVhayhzZW5kZXI6IEFkZHJlc3MsIGluZGV4OiB1aW50NjQsIGVsc2VTdHJlYWs6IHVpbnQ2NCk6IHZvaWQKdXBkYXRlU3RyZWFrOgoJcHJvdG8gMyAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cG4gMwoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjE1OQoJLy8gc3ViS2V5OiBTdWJzY3JpcHRpb25LZXkgPSB7IHVzZXI6IHNlbmRlciwgaW5kZXg6IGluZGV4IH0KCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFkZHJlc3MKCWZyYW1lX2RpZyAtMiAvLyBpbmRleDogdWludDY0CglpdG9iCgljb25jYXQKCWZyYW1lX2J1cnkgMCAvLyBzdWJLZXk6IFN1YnNjcmlwdGlvbktleQoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjE2MAoJLy8gc3ViID0gdGhpcy5zdWJzY3JpcHRpb25zKHN1YktleSkudmFsdWUKCWZyYW1lX2RpZyAwIC8vIHN1YktleTogU3Vic2NyaXB0aW9uS2V5CglmcmFtZV9idXJ5IDEgLy8gc3RvcmFnZSBrZXkvL3N1YgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjE2MgoJLy8gY3VycmVudFdpbmRvd1N0YXJ0ID0gdGhpcy5nZXRMYXRlc3RXaW5kb3dTdGFydChzdWIuc3RhcnREYXRlLCBzdWIuaW50ZXJ2YWwpCglmcmFtZV9kaWcgMCAvLyBzdWJLZXk6IFN1YnNjcmlwdGlvbktleQoJaW50YyA5IC8vICBoZWFkT2Zmc2V0CglpbnRjIDIgLy8gOAoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2RpZyAwIC8vIHN1YktleTogU3Vic2NyaXB0aW9uS2V5CglpbnRjIDcgLy8gIGhlYWRPZmZzZXQKCWludGMgMiAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJY2FsbHN1YiBnZXRMYXRlc3RXaW5kb3dTdGFydAoJZnJhbWVfYnVyeSAyIC8vIGN1cnJlbnRXaW5kb3dTdGFydDogdWludDY0CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MTYzCgkvLyBsYXN0V2luZG93U3RhcnQgPSAoY3VycmVudFdpbmRvd1N0YXJ0IC0gc3ViLmludGVydmFsKQoJZnJhbWVfZGlnIDIgLy8gY3VycmVudFdpbmRvd1N0YXJ0OiB1aW50NjQKCWZyYW1lX2RpZyAwIC8vIHN1YktleTogU3Vic2NyaXB0aW9uS2V5CglpbnRjIDkgLy8gIGhlYWRPZmZzZXQKCWludGMgMiAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJLQoJZnJhbWVfYnVyeSAzIC8vIGxhc3RXaW5kb3dTdGFydDogdWludDY0CgoJLy8gKmlmMV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjE2NQoJLy8gc3ViLmxhc3RQYXltZW50IDwgbGFzdFdpbmRvd1N0YXJ0CglmcmFtZV9kaWcgMCAvLyBzdWJLZXk6IFN1YnNjcmlwdGlvbktleQoJaW50YyA2IC8vICBoZWFkT2Zmc2V0CglpbnRjIDIgLy8gOAoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2RpZyAzIC8vIGxhc3RXaW5kb3dTdGFydDogdWludDY0Cgk8CglieiAqaWYxX2VuZAoKCS8vICppZjFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MTY3CgkvLyB0aGlzLnN1YnNjcmlwdGlvbnMoc3ViS2V5KS52YWx1ZS5zdHJlYWsgPSBlbHNlU3RyZWFrCglpbnRjIDEwIC8vICBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTMgLy8gZWxzZVN0cmVhazogdWludDY0CglpdG9iCglmcmFtZV9kaWcgMCAvLyBzdWJLZXk6IFN1YnNjcmlwdGlvbktleQoJY292ZXIgMgoJYm94X3JlcGxhY2UKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoxNjgKCS8vIHJldHVybjsKCXJldHN1YgoKKmlmMV9lbmQ6CgkvLyAqaWYyX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MTc0CgkvLyBzdWIubGFzdFBheW1lbnQgPj0gbGFzdFdpbmRvd1N0YXJ0ICYmICEoc3ViLmxhc3RQYXltZW50ID49IGN1cnJlbnRXaW5kb3dTdGFydCkKCWZyYW1lX2RpZyAwIC8vIHN1YktleTogU3Vic2NyaXB0aW9uS2V5CglpbnRjIDYgLy8gIGhlYWRPZmZzZXQKCWludGMgMiAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfZGlnIDMgLy8gbGFzdFdpbmRvd1N0YXJ0OiB1aW50NjQKCT49CglkdXAKCWJ6ICpza2lwX2FuZDAKCWZyYW1lX2RpZyAwIC8vIHN1YktleTogU3Vic2NyaXB0aW9uS2V5CglpbnRjIDYgLy8gIGhlYWRPZmZzZXQKCWludGMgMiAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfZGlnIDIgLy8gY3VycmVudFdpbmRvd1N0YXJ0OiB1aW50NjQKCT49CgkhCgkmJgoKKnNraXBfYW5kMDoKCWJ6ICppZjJfZW5kCgoJLy8gKmlmMl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoxNzUKCS8vIHRoaXMuc3Vic2NyaXB0aW9ucyhzdWJLZXkpLnZhbHVlLnN0cmVhayArPSAxCglpbnRjIDEwIC8vICBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgMCAvLyBzdWJLZXk6IFN1YnNjcmlwdGlvbktleQoJaW50YyAxMCAvLyAgaGVhZE9mZnNldAoJaW50YyAyIC8vIDgKCWJveF9leHRyYWN0CglidG9pCglpbnRjIDEgLy8gMQoJKwoJaXRvYgoJZnJhbWVfZGlnIDAgLy8gc3ViS2V5OiBTdWJzY3JpcHRpb25LZXkKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoqaWYyX2VuZDoKCXJldHN1YgoKLy8gZ2V0U3Vic3JpcHRpb25JbmZvKGFkZHJlc3MsdWludDY0KShhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzW10pCiphYmlfcm91dGVfZ2V0U3Vic3JpcHRpb25JbmZvOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAzIC8vIDB4MTUxZjdjNzUKCgkvLyBpbmRleDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gdXNlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludGMgMyAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCAxICh1c2VyKSBmb3IgZ2V0U3Vic3JpcHRpb25JbmZvIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIGdldFN1YnNyaXB0aW9uSW5mbyhhZGRyZXNzLHVpbnQ2NCkoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzc1tdKQoJY2FsbHN1YiBnZXRTdWJzcmlwdGlvbkluZm8KCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBnZXRTdWJzcmlwdGlvbkluZm8odXNlcjogQWRkcmVzcywgaW5kZXg6IHVpbnQ2NCk6IFN1YnNjcmlwdGlvbkluZm9XaXRoUGFzc2VzCmdldFN1YnNyaXB0aW9uSW5mbzoKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CglkdXBuIDIKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoxODAKCS8vIGtleTogU3Vic2NyaXB0aW9uS2V5ID0geyB1c2VyOiB1c2VyLCBpbmRleDogaW5kZXggfQoJZnJhbWVfZGlnIC0xIC8vIHVzZXI6IEFkZHJlc3MKCWZyYW1lX2RpZyAtMiAvLyBpbmRleDogdWludDY0CglpdG9iCgljb25jYXQKCWZyYW1lX2J1cnkgMCAvLyBrZXk6IFN1YnNjcmlwdGlvbktleQoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjE4MgoJLy8gYXNzZXJ0KHRoaXMuc3Vic2NyaXB0aW9ucyhrZXkpLmV4aXN0cywgZXJycy5TVUJTQ1JJUFRJT05fRE9FU19OT1RfRVhJU1QpCglmcmFtZV9kaWcgMCAvLyBrZXk6IFN1YnNjcmlwdGlvbktleQoJYm94X2xlbgoJc3dhcAoJcG9wCglhc3NlcnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoxODQKCS8vIHN1YkluZm8gPSB0aGlzLnN1YnNjcmlwdGlvbnMoa2V5KS52YWx1ZQoJZnJhbWVfZGlnIDAgLy8ga2V5OiBTdWJzY3JpcHRpb25LZXkKCWZyYW1lX2J1cnkgMSAvLyBzdG9yYWdlIGtleS8vc3ViSW5mbwoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjE4NgoJLy8gcGFzc2VzOiBBZGRyZXNzW10gPSBbXQoJYnl0ZWMgMCAvLyAweAoJZnJhbWVfYnVyeSAyIC8vIHBhc3NlczogQWRkcmVzc1tdCgoJLy8gKmlmM19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjE4NwoJLy8gdGhpcy5wYXNzZXMoa2V5KS5leGlzdHMKCWJ5dGVjIDUgLy8gICJwIgoJZnJhbWVfZGlnIDAgLy8ga2V5OiBTdWJzY3JpcHRpb25LZXkKCWNvbmNhdAoJYm94X2xlbgoJc3dhcAoJcG9wCglieiAqaWYzX2VuZAoKCS8vICppZjNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MTg4CgkvLyBwYXNzZXMgPSB0aGlzLnBhc3NlcyhrZXkpLnZhbHVlCglieXRlYyA1IC8vICAicCIKCWZyYW1lX2RpZyAwIC8vIGtleTogU3Vic2NyaXB0aW9uS2V5Cgljb25jYXQKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucGFzc2VzKGtleSkudmFsdWUKCWFzc2VydAoJZXh0cmFjdCAyIDAKCWZyYW1lX2J1cnkgMiAvLyBwYXNzZXM6IEFkZHJlc3NbXQoKKmlmM19lbmQ6CgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoxOTEKCS8vIHJldHVybiB7CgkvLyAgICAgICByZWNpcGllbnQ6IHN1YkluZm8ucmVjaXBpZW50LAoJLy8gICAgICAgaW5kZXg6IHN1YkluZm8uaW5kZXgsCgkvLyAgICAgICBzdGFydERhdGU6IHN1YkluZm8uc3RhcnREYXRlLAoJLy8gICAgICAgYW1vdW50OiBzdWJJbmZvLmFtb3VudCwKCS8vICAgICAgIGludGVydmFsOiBzdWJJbmZvLmludGVydmFsLAoJLy8gICAgICAgYXNzZXQ6IHN1YkluZm8uYXNzZXQsCgkvLyAgICAgICBsYXN0UGF5bWVudDogc3ViSW5mby5sYXN0UGF5bWVudCwKCS8vICAgICAgIHN0cmVhazogc3ViSW5mby5zdHJlYWssCgkvLyAgICAgICBwYXNzZXM6IHBhc3NlcywKCS8vICAgICB9OwoJYnl0ZWMgMCAvLyAgaW5pdGlhbCBoZWFkCglieXRlYyAwIC8vICBpbml0aWFsIHRhaWwKCXB1c2hieXRlcyAweDAwNWEgLy8gaW5pdGlhbCBoZWFkIG9mZnNldAoJZnJhbWVfZGlnIDAgLy8ga2V5OiBTdWJzY3JpcHRpb25LZXkKCWludGMgMCAvLyAwCglpbnRjIDMgLy8gMzIKCWJveF9leHRyYWN0CgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgMCAvLyBrZXk6IFN1YnNjcmlwdGlvbktleQoJaW50YyAzIC8vICBoZWFkT2Zmc2V0CglpbnRjIDIgLy8gOAoJYm94X2V4dHJhY3QKCWJ0b2kKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAwIC8vIGtleTogU3Vic2NyaXB0aW9uS2V5CglpbnRjIDcgLy8gIGhlYWRPZmZzZXQKCWludGMgMiAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJaXRvYgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIDAgLy8ga2V5OiBTdWJzY3JpcHRpb25LZXkKCWludGMgOCAvLyAgaGVhZE9mZnNldAoJaW50YyAyIC8vIDgKCWJveF9leHRyYWN0CglidG9pCglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgMCAvLyBrZXk6IFN1YnNjcmlwdGlvbktleQoJaW50YyA5IC8vICBoZWFkT2Zmc2V0CglpbnRjIDIgLy8gOAoJYm94X2V4dHJhY3QKCWJ0b2kKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAwIC8vIGtleTogU3Vic2NyaXB0aW9uS2V5CglpbnRjIDUgLy8gIGhlYWRPZmZzZXQKCWludGMgMiAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJaXRvYgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIDAgLy8ga2V5OiBTdWJzY3JpcHRpb25LZXkKCWludGMgNiAvLyAgaGVhZE9mZnNldAoJaW50YyAyIC8vIDgKCWJveF9leHRyYWN0CglidG9pCglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgMCAvLyBrZXk6IFN1YnNjcmlwdGlvbktleQoJaW50YyAxMCAvLyAgaGVhZE9mZnNldAoJaW50YyAyIC8vIDgKCWJveF9leHRyYWN0CglidG9pCglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgMiAvLyBwYXNzZXM6IEFkZHJlc3NbXQoJZHVwCglsZW4KCWludGMgMyAvLyAzMgoJLwoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY2FsbHN1YiAqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQKCXBvcCAvLyBwb3AgaGVhZCBvZmZzZXQKCWNvbmNhdCAvLyBjb25jYXQgaGVhZCBhbmQgdGFpbAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDIKCXJldHN1YgoKLy8gbmV3U2VydmljZSh1aW50NjQsYm9vbCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsYnl0ZVs1OV0sYm9vbCl1aW50NjQKKmFiaV9yb3V0ZV9uZXdTZXJ2aWNlOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAzIC8vIDB4MTUxZjdjNzUKCgkvLyBhbGxvd1RyYXZlcnNhbDogYm9vbAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgOAoJZHVwCglsZW4KCWludGMgMSAvLyAxCgk9PQoKCS8vIGFyZ3VtZW50IDAgKGFsbG93VHJhdmVyc2FsKSBmb3IgbmV3U2VydmljZSBtdXN0IGJlIGEgYm9vbAoJYXNzZXJ0CglpbnRjIDAgLy8gMAoJZ2V0Yml0CgoJLy8gY2lkOiBieXRlWzU5XQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNwoJZHVwCglsZW4KCXB1c2hpbnQgNTkKCT09CgoJLy8gYXJndW1lbnQgMSAoY2lkKSBmb3IgbmV3U2VydmljZSBtdXN0IGJlIGEgYnl0ZVs1OV0KCWFzc2VydAoKCS8vIHBhc3NlczogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA2CglidG9pCgoJLy8gYW1vdW50OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDUKCWJ0b2kKCgkvLyBhc3NldDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA0CglidG9pCgoJLy8gaW50ZXJ2YWw6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIHJla2V5QmFjazogYm9vbAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgMSAvLyAxCgk9PQoKCS8vIGFyZ3VtZW50IDYgKHJla2V5QmFjaykgZm9yIG5ld1NlcnZpY2UgbXVzdCBiZSBhIGJvb2wKCWFzc2VydAoJaW50YyAwIC8vIDAKCWdldGJpdAoKCS8vIHNlbmRlcjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBuZXdTZXJ2aWNlKHVpbnQ2NCxib29sLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCxieXRlWzU5XSxib29sKXVpbnQ2NAoJY2FsbHN1YiBuZXdTZXJ2aWNlCglpdG9iCgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gbmV3U2VydmljZShzZW5kZXI6IEFwcElELCByZWtleUJhY2s6IGJvb2xlYW4sIGludGVydmFsOiB1aW50NjQsIGFzc2V0OiBBc3NldElELCBhbW91bnQ6IHVpbnQ2NCwgcGFzc2VzOiB1aW50NjQsIGNpZDogYnl0ZXM8NTk+LCBhbGxvd1RyYXZlcnNhbDogYm9vbGVhbik6IHVpbnQ2NAovLwovLyBuZXdTZXJ2aWNlIGNyZWF0ZXMgYSBuZXcgc2VydmljZSBmb3IgYSBtZXJjaGFudAovLyBAcGFyYW0gc2VuZGVyIFRoZSBhZGRyZXNzIHRoZSBwbHVnaW4gY3VycmVudGx5IGNvbnRyb2xzCi8vIEBwYXJhbSByZWtleUJhY2sgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIgd2FudHMgdG8gcmVrZXkgYmFjayBhZnRlciB0aGUgdHJhbnNhY3Rpb24KLy8gQHBhcmFtIGludGVydmFsIFRoZSBpbnRlcnZhbCBpbiBzZWNvbmRzCi8vIEBwYXJhbSBhc3NldCBUaGUgYXNhIHRvIGJlIHVzZWQgZm9yIHRoZSBzdWJzY3JpcHRpb24KLy8gQHBhcmFtIGFtb3VudCBUaGUgYW1vdW50IG9mIHRoZSBhc2EgdG8gYmUgdXNlZCBmb3IgdGhlIHN1YnNjcmlwdGlvbgovLyBAcGFyYW0gcGFzc2VzIFRoZSBudW1iZXIgb2YgYWNjb3VudHMgdGhlIHN1YnNjcmlwdGlvbiBjYW4gYmUgc2hhcmVkIHdpdGgKLy8gQHBhcmFtIGNpZCBUaGUgaXBmcyBjaWQgb2YgdGhlIHN1YnNjcmlwdGlvbiBjb250cmFjdAovLyBAcGFyYW0gYWxsb3dUcmF2ZXJzYWwgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIgY2FuIGRvd25ncmFkZQovLyBvciB1cGdyYWRlIHRoZSBzdWJzY3JpcHRpb24gdG8gYSBkaWZmZXJlbnQgc2VydmljZSBmcm9tIHRoZSB1c2VyIHdpdGhvdXQgbG9zaW5nIHRoZWlyIHN0cmVhawpuZXdTZXJ2aWNlOgoJcHJvdG8gOCAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCWR1cAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjIyNgoJLy8gaW5kZXg6IHVpbnQ2NCA9IDAKCWludGMgMCAvLyAwCglmcmFtZV9idXJ5IDAgLy8gaW5kZXg6IHVpbnQ2NAoKCS8vICppZjRfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoyMjcKCS8vIHRoaXMuc2VydmljZXNsaXN0KHNlbmRlci5hZGRyZXNzKS5leGlzdHMKCWJ5dGVjIDIgLy8gICJsIgoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJY29uY2F0Cglib3hfbGVuCglzd2FwCglwb3AKCWJ6ICppZjRfZWxzZQoKCS8vICppZjRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MjI4CgkvLyBpbmRleCA9IHRoaXMuc2VydmljZXNsaXN0KHNlbmRlci5hZGRyZXNzKS52YWx1ZQoJYnl0ZWMgMiAvLyAgImwiCglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCgljb25jYXQKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuc2VydmljZXNsaXN0KHNlbmRlci5hZGRyZXNzKS52YWx1ZQoJYXNzZXJ0CglidG9pCglmcmFtZV9idXJ5IDAgLy8gaW5kZXg6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjIyOQoJLy8gdGhpcy5zZXJ2aWNlc2xpc3Qoc2VuZGVyLmFkZHJlc3MpLnZhbHVlICs9IDEKCWJ5dGVjIDIgLy8gICJsIgoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJY29uY2F0Cglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnNlcnZpY2VzbGlzdChzZW5kZXIuYWRkcmVzcykudmFsdWUKCWFzc2VydAoJYnRvaQoJaW50YyAxIC8vIDEKCSsKCWJ5dGVjIDIgLy8gICJsIgoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJY29uY2F0Cglzd2FwCglpdG9iCglib3hfcHV0CgliICppZjRfZW5kCgoqaWY0X2Vsc2U6CgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoyMzEKCS8vIGluZGV4ID0gMQoJaW50YyAxIC8vIDEKCWZyYW1lX2J1cnkgMCAvLyBpbmRleDogdWludDY0CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MjMyCgkvLyB0aGlzLnNlcnZpY2VzbGlzdChzZW5kZXIuYWRkcmVzcykudmFsdWUgPSAxCglieXRlYyAyIC8vICAibCIKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWNvbmNhdAoJYnl0ZWMgNiAvLyAweDAwMDAwMDAwMDAwMDAwMDEKCWJveF9wdXQKCippZjRfZW5kOgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MjM1CgkvLyBib3hLZXk6IFNlcnZpY2VzS2V5ID0geyB1c2VyOiBzZW5kZXIuYWRkcmVzcywgaW5kZXg6IGluZGV4IH0KCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWZyYW1lX2RpZyAwIC8vIGluZGV4OiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfYnVyeSAxIC8vIGJveEtleTogU2VydmljZXNLZXkKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoyMzgKCS8vIGFzc2VydChhbW91bnQgPiAzLCBlcnJzLk1JTl9BTU9VTlRfSVNfVEhSRUUpCglmcmFtZV9kaWcgLTUgLy8gYW1vdW50OiB1aW50NjQKCWludGMgMTQgLy8gMwoJPgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MjQwCgkvLyBhc3NlcnQoaW50ZXJ2YWwgPj0gNjAsIGVycnMuTUlOX0lOVEVSVkFMX0lTX1NJWFRZKQoJZnJhbWVfZGlnIC0zIC8vIGludGVydmFsOiB1aW50NjQKCWludGMgMTYgLy8gNjAKCT49Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoyNDIKCS8vIGFzc2VydChwYXNzZXMgPD0gNSwgZXJycy5NQVhfUEFTU0VTX0lTX0ZJVkUpCglmcmFtZV9kaWcgLTYgLy8gcGFzc2VzOiB1aW50NjQKCWludGMgMTUgLy8gNQoJPD0KCWFzc2VydAoKCS8vICppZjVfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoyNDUKCS8vIGFzc2V0LmlkICE9PSAwICYmICF0aGlzLmFwcC5hZGRyZXNzLmlzT3B0ZWRJblRvQXNzZXQoYXNzZXQpCglmcmFtZV9kaWcgLTQgLy8gYXNzZXQ6IEFzc2V0SUQKCWludGMgMCAvLyAwCgkhPQoJZHVwCglieiAqc2tpcF9hbmQxCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJZnJhbWVfZGlnIC00IC8vIGFzc2V0OiBBc3NldElECglhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKCXN3YXAKCXBvcAoJIQoJJiYKCipza2lwX2FuZDE6CglieiAqaWY1X2Vsc2VpZjFfY29uZGl0aW9uCgoJLy8gKmlmNV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoyNDYKCS8vIHRoaXMuYWRkUGVuZGluZ09wdGluKHNlbmRlciwgcmVrZXlCYWNrLCBhc3NldCwgRklWRV9BTEdPKQoJaW50YyAxMSAvLyA1MDAwMDAwCglmcmFtZV9kaWcgLTQgLy8gYXNzZXQ6IEFzc2V0SUQKCWZyYW1lX2RpZyAtMiAvLyByZWtleUJhY2s6IGJvb2xlYW4KCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECgljYWxsc3ViIGFkZFBlbmRpbmdPcHRpbgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjI0NwoJLy8gdGhpcy5wZW5kaW5nR3JvdXAuc3VibWl0KCkKCWl0eG5fc3VibWl0CgliICppZjVfZW5kCgoqaWY1X2Vsc2VpZjFfY29uZGl0aW9uOgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MjQ4CgkvLyByZWtleUJhY2sKCWZyYW1lX2RpZyAtMiAvLyByZWtleUJhY2s6IGJvb2xlYW4KCWJ6ICppZjVfZWxzZQoKCS8vICppZjVfZWxzZWlmMV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoyNDkKCS8vIHNlbmRQYXltZW50KHsKCS8vICAgICAgICAgc2VuZGVyOiBzZW5kZXIuYWRkcmVzcywKCS8vICAgICAgICAgcmVjZWl2ZXI6IGdsb2JhbHMuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKCS8vICAgICAgICAgYW1vdW50OiBGSVZFX0FMR08sCgkvLyAgICAgICAgIHJla2V5VG86IHNlbmRlci5hZGRyZXNzLAoJLy8gICAgICAgICBmZWU6IDAsCgkvLyAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAxIC8vICBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoyNTAKCS8vIHNlbmRlcjogc2VuZGVyLmFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWl0eG5fZmllbGQgU2VuZGVyCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MjUxCgkvLyByZWNlaXZlcjogZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjI1MgoJLy8gYW1vdW50OiBGSVZFX0FMR08KCWludGMgMTEgLy8gNTAwMDAwMAoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoyNTMKCS8vIHJla2V5VG86IHNlbmRlci5hZGRyZXNzCglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCglpdHhuX2ZpZWxkIFJla2V5VG8KCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoyNTQKCS8vIGZlZTogMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJYiAqaWY1X2VuZAoKKmlmNV9lbHNlOgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MjU3CgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgIHNlbmRlcjogc2VuZGVyLmFkZHJlc3MsCgkvLyAgICAgICAgIHJlY2VpdmVyOiBnbG9iYWxzLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCgkvLyAgICAgICAgIGFtb3VudDogRklWRV9BTEdPLAoJLy8gICAgICAgICBmZWU6IDAsCgkvLyAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAxIC8vICBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoyNTgKCS8vIHNlbmRlcjogc2VuZGVyLmFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWl0eG5fZmllbGQgU2VuZGVyCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MjU5CgkvLyByZWNlaXZlcjogZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjI2MAoJLy8gYW1vdW50OiBGSVZFX0FMR08KCWludGMgMTEgLy8gNTAwMDAwMAoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoyNjEKCS8vIGZlZTogMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKKmlmNV9lbmQ6CgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoyNjUKCS8vIHRoaXMuc2VydmljZXMoYm94S2V5KS52YWx1ZSA9IHsKCS8vICAgICAgIHNodXRkb3duOiBmYWxzZSwKCS8vICAgICAgIGFjdGl2ZTogdHJ1ZSwKCS8vICAgICAgIGludGVydmFsOiBpbnRlcnZhbCwKCS8vICAgICAgIGFzc2V0OiBhc3NldCwKCS8vICAgICAgIGFtb3VudDogYW1vdW50LAoJLy8gICAgICAgcGFzc2VzOiBwYXNzZXMsCgkvLyAgICAgICBjaWQ6IGNpZCwKCS8vICAgICAgIGFsbG93VHJhdmVyc2FsOiBhbGxvd1RyYXZlcnNhbCwKCS8vICAgICB9CglieXRlYyAxIC8vICAicyIKCWZyYW1lX2RpZyAxIC8vIGJveEtleTogU2VydmljZXNLZXkKCWNvbmNhdAoJYnl0ZWMgNCAvLyAweDAwCglpbnRjIDAgLy8gMAoJZHVwCglzZXRiaXQKCWludGMgMSAvLyAxCglkdXAKCXNldGJpdAoJZnJhbWVfZGlnIC0zIC8vIGludGVydmFsOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfZGlnIC00IC8vIGFzc2V0OiBBc3NldElECglpdG9iCgljb25jYXQKCWZyYW1lX2RpZyAtNSAvLyBhbW91bnQ6IHVpbnQ2NAoJaXRvYgoJY29uY2F0CglmcmFtZV9kaWcgLTYgLy8gcGFzc2VzOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfZGlnIC03IC8vIGNpZDogYnl0ZXM8NTk+Cgljb25jYXQKCWJ5dGVjIDQgLy8gMHgwMAoJaW50YyAwIC8vIDAKCWZyYW1lX2RpZyAtOCAvLyBhbGxvd1RyYXZlcnNhbDogYm9vbGVhbgoJc2V0Yml0Cgljb25jYXQKCWJveF9wdXQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoyNzYKCS8vIHJldHVybiBpbmRleDsKCWZyYW1lX2RpZyAwIC8vIGluZGV4OiB1aW50NjQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAxCglyZXRzdWIKCi8vIHBhdXNlU2VydmljZSh1aW50NjQsYm9vbCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX3BhdXNlU2VydmljZToKCS8vIGluZGV4OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWJ0b2kKCgkvLyByZWtleUJhY2s6IGJvb2wKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnRjIDEgLy8gMQoJPT0KCgkvLyBhcmd1bWVudCAxIChyZWtleUJhY2spIGZvciBwYXVzZVNlcnZpY2UgbXVzdCBiZSBhIGJvb2wKCWFzc2VydAoJaW50YyAwIC8vIDAKCWdldGJpdAoKCS8vIHNlbmRlcjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBwYXVzZVNlcnZpY2UodWludDY0LGJvb2wsdWludDY0KXZvaWQKCWNhbGxzdWIgcGF1c2VTZXJ2aWNlCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBwYXVzZVNlcnZpY2Uoc2VuZGVyOiBBcHBJRCwgcmVrZXlCYWNrOiBib29sZWFuLCBpbmRleDogdWludDY0KTogdm9pZAovLwovLyBwYXVzZVNlcnZpY2UgcGF1c2VzIGEgc2VydmljZSBmb3IgYSBtZXJjaGFudAovLyBpdCBkb2VzIG5vdCBzaHV0ZG93biBwcmUtZXhpc3Rpbmcgc3Vic2NyaXB0aW9ucwovLyBpdCBzaW1wbHkgcHJldmVudHMgbmV3IHN1YnNjcmlwdGlvbnMgZnJvbSBiZWluZyBjcmVhdGVkCi8vIGZvciBhIHNwZWNpZmljIHNlcnZpY2UKLy8gQHBhcmFtIHNlbmRlciBUaGUgYWRkcmVzcyB0aGUgcGx1Z2luIGN1cnJlbnRseSBjb250cm9scwovLyBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBib3ggdG8gYmUgdXNlZCBmb3IgdGhlIHN1YnNjcmlwdGlvbgpwYXVzZVNlcnZpY2U6Cglwcm90byAzIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjI4OAoJLy8gYm94S2V5OiBTZXJ2aWNlc0tleSA9IHsgdXNlcjogc2VuZGVyLmFkZHJlc3MsIGluZGV4OiBpbmRleCB9CglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCglmcmFtZV9kaWcgLTMgLy8gaW5kZXg6IHVpbnQ2NAoJaXRvYgoJY29uY2F0CglmcmFtZV9idXJ5IDAgLy8gYm94S2V5OiBTZXJ2aWNlc0tleQoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjI5MQoJLy8gYXNzZXJ0KHRoaXMuY29udHJvbHMoc2VuZGVyLmFkZHJlc3MpLCBlcnJzLlBMVUdJTl9OT1RfQVVUSF9BRERSKQoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJY2FsbHN1YiBjb250cm9scwoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6Mjk0CgkvLyBhc3NlcnQoaW5kZXggPiAwLCBlcnJzLlNFUlZJQ0VfSU5ERVhfTVVTVF9CRV9BQk9WRV9aRVJPKQoJZnJhbWVfZGlnIC0zIC8vIGluZGV4OiB1aW50NjQKCWludGMgMCAvLyAwCgk+Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoyOTYKCS8vIGFzc2VydCh0aGlzLnNlcnZpY2VzKGJveEtleSkuZXhpc3RzLCBlcnJzLlNFUlZJQ0VfRE9FU19OT1RfRVhJU1QpCglieXRlYyAxIC8vICAicyIKCWZyYW1lX2RpZyAwIC8vIGJveEtleTogU2VydmljZXNLZXkKCWNvbmNhdAoJYm94X2xlbgoJc3dhcAoJcG9wCglhc3NlcnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czoyOTgKCS8vIGFzc2VydCghdGhpcy5zZXJ2aWNlcyhib3hLZXkpLnZhbHVlLnNodXRkb3duLCBlcnJzLlNFUlZJQ0VfSVNfU0hVVERPV04pCglieXRlYyAxIC8vICAicyIKCWZyYW1lX2RpZyAwIC8vIGJveEtleTogU2VydmljZXNLZXkKCWNvbmNhdAoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5zZXJ2aWNlcyhib3hLZXkpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDAgLy8gMAoJZ2V0Yml0CgkhCglhc3NlcnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czozMDAKCS8vIHRoaXMuc2VydmljZXMoYm94S2V5KS52YWx1ZS5hY3RpdmUgPSBmYWxzZQoJYnl0ZWMgMSAvLyAgInMiCglmcmFtZV9kaWcgMCAvLyBib3hLZXk6IFNlcnZpY2VzS2V5Cgljb25jYXQKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuc2VydmljZXMoYm94S2V5KS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJaW50YyAxIC8vIDEKCWludGMgMCAvLyAwCglzZXRiaXQKCWJ5dGVjIDEgLy8gICJzIgoJZnJhbWVfZGlnIDAgLy8gYm94S2V5OiBTZXJ2aWNlc0tleQoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vICppZjZfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czozMDIKCS8vIHJla2V5QmFjawoJZnJhbWVfZGlnIC0yIC8vIHJla2V5QmFjazogYm9vbGVhbgoJYnogKmlmNl9lbmQKCgkvLyAqaWY2X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjMwMwoJLy8gdGhpcy5yZWtleUJhY2soc2VuZGVyLmFkZHJlc3MpCglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCgljYWxsc3ViIHJla2V5QmFjawoKKmlmNl9lbmQ6CglyZXRzdWIKCi8vIGFjdGl2YXRlU2VydmljZSh1aW50NjQsYm9vbCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX2FjdGl2YXRlU2VydmljZToKCS8vIGluZGV4OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWJ0b2kKCgkvLyByZWtleUJhY2s6IGJvb2wKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnRjIDEgLy8gMQoJPT0KCgkvLyBhcmd1bWVudCAxIChyZWtleUJhY2spIGZvciBhY3RpdmF0ZVNlcnZpY2UgbXVzdCBiZSBhIGJvb2wKCWFzc2VydAoJaW50YyAwIC8vIDAKCWdldGJpdAoKCS8vIHNlbmRlcjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBhY3RpdmF0ZVNlcnZpY2UodWludDY0LGJvb2wsdWludDY0KXZvaWQKCWNhbGxzdWIgYWN0aXZhdGVTZXJ2aWNlCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBhY3RpdmF0ZVNlcnZpY2Uoc2VuZGVyOiBBcHBJRCwgcmVrZXlCYWNrOiBib29sZWFuLCBpbmRleDogdWludDY0KTogdm9pZAovLwovLyBhY3RpdmF0ZVNlcnZpY2UgYWN0aXZhdGVzIGFuIHNlcnZpY2UgZm9yIGEgbWVyY2hhbnQKLy8KLy8gQHBhcmFtIHNlbmRlciBUaGUgYWRkcmVzcyB0aGUgcGx1Z2luIGN1cnJlbnRseSBjb250cm9scwovLyBAcGFyYW0gcmVrZXlCYWNrIEluZGljYXRlcyB3aGV0aGVyIHRoZSB1c2VyIHdhbnRzIHRvIHJla2V5IGJhY2sgYWZ0ZXIgdGhlIHRyYW5zYWN0aW9uCi8vIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGJveCB0byBiZSB1c2VkIGZvciB0aGUgc3Vic2NyaXB0aW9uCmFjdGl2YXRlU2VydmljZToKCXByb3RvIDMgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MzE1CgkvLyBib3hLZXk6IFNlcnZpY2VzS2V5ID0geyB1c2VyOiBzZW5kZXIuYWRkcmVzcywgaW5kZXg6IGluZGV4IH0KCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWZyYW1lX2RpZyAtMyAvLyBpbmRleDogdWludDY0CglpdG9iCgljb25jYXQKCWZyYW1lX2J1cnkgMCAvLyBib3hLZXk6IFNlcnZpY2VzS2V5CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MzE4CgkvLyBhc3NlcnQodGhpcy5jb250cm9scyhzZW5kZXIuYWRkcmVzcyksIGVycnMuUExVR0lOX05PVF9BVVRIX0FERFIpCglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCgljYWxsc3ViIGNvbnRyb2xzCglhc3NlcnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czozMjAKCS8vIGFzc2VydCh0aGlzLnNlcnZpY2VzKGJveEtleSkuZXhpc3RzLCBlcnJzLlNFUlZJQ0VfRE9FU19OT1RfRVhJU1QpCglieXRlYyAxIC8vICAicyIKCWZyYW1lX2RpZyAwIC8vIGJveEtleTogU2VydmljZXNLZXkKCWNvbmNhdAoJYm94X2xlbgoJc3dhcAoJcG9wCglhc3NlcnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czozMjIKCS8vIGFzc2VydCghdGhpcy5zZXJ2aWNlcyhib3hLZXkpLnZhbHVlLnNodXRkb3duLCBlcnJzLlNFUlZJQ0VfSVNfU0hVVERPV04pCglieXRlYyAxIC8vICAicyIKCWZyYW1lX2RpZyAwIC8vIGJveEtleTogU2VydmljZXNLZXkKCWNvbmNhdAoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5zZXJ2aWNlcyhib3hLZXkpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDAgLy8gMAoJZ2V0Yml0CgkhCglhc3NlcnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czozMjQKCS8vIHRoaXMuc2VydmljZXMoYm94S2V5KS52YWx1ZS5hY3RpdmUgPSB0cnVlCglieXRlYyAxIC8vICAicyIKCWZyYW1lX2RpZyAwIC8vIGJveEtleTogU2VydmljZXNLZXkKCWNvbmNhdAoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5zZXJ2aWNlcyhib3hLZXkpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDEgLy8gMQoJZHVwCglzZXRiaXQKCWJ5dGVjIDEgLy8gICJzIgoJZnJhbWVfZGlnIDAgLy8gYm94S2V5OiBTZXJ2aWNlc0tleQoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vICppZjdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czozMjYKCS8vIHJla2V5QmFjawoJZnJhbWVfZGlnIC0yIC8vIHJla2V5QmFjazogYm9vbGVhbgoJYnogKmlmN19lbmQKCgkvLyAqaWY3X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjMyNwoJLy8gdGhpcy5yZWtleUJhY2soc2VuZGVyLmFkZHJlc3MpCglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCgljYWxsc3ViIHJla2V5QmFjawoKKmlmN19lbmQ6CglyZXRzdWIKCi8vIHNodXRkb3duU2VydmljZSh1aW50NjQsYm9vbCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX3NodXRkb3duU2VydmljZToKCS8vIGluZGV4OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWJ0b2kKCgkvLyByZWtleUJhY2s6IGJvb2wKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnRjIDEgLy8gMQoJPT0KCgkvLyBhcmd1bWVudCAxIChyZWtleUJhY2spIGZvciBzaHV0ZG93blNlcnZpY2UgbXVzdCBiZSBhIGJvb2wKCWFzc2VydAoJaW50YyAwIC8vIDAKCWdldGJpdAoKCS8vIHNlbmRlcjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBzaHV0ZG93blNlcnZpY2UodWludDY0LGJvb2wsdWludDY0KXZvaWQKCWNhbGxzdWIgc2h1dGRvd25TZXJ2aWNlCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBzaHV0ZG93blNlcnZpY2Uoc2VuZGVyOiBBcHBJRCwgcmVrZXlCYWNrOiBib29sZWFuLCBpbmRleDogdWludDY0KTogdm9pZAovLwovLyBzaHV0ZG93blNlcnZpY2UgcGVybWFuZW50bHkgc2h1dHMgZG93biBhbiBzZXJ2aWNlIGZvciBhIG1lcmNoYW50Ci8vIGl0IGFsc28gc2h1dHNkb3duIHByZS1leGlzdGluZyBzdWJzY3JpcHRpb25zCi8vIEBwYXJhbSBzZW5kZXIgVGhlIGFkZHJlc3MgdGhlIHBsdWdpbiBjdXJyZW50bHkgY29udHJvbHMKLy8gQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgYm94IHRvIGJlIHVzZWQgZm9yIHRoZSBzdWJzY3JpcHRpb24Kc2h1dGRvd25TZXJ2aWNlOgoJcHJvdG8gMyAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGVjIDAgLy8gMHgKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czozMzgKCS8vIGJveEtleTogU2VydmljZXNLZXkgPSB7IHVzZXI6IHNlbmRlci5hZGRyZXNzLCBpbmRleDogaW5kZXggfQoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJZnJhbWVfZGlnIC0zIC8vIGluZGV4OiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfYnVyeSAwIC8vIGJveEtleTogU2VydmljZXNLZXkKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czozNDEKCS8vIGFzc2VydCh0aGlzLmNvbnRyb2xzKHNlbmRlci5hZGRyZXNzKSwgZXJycy5QTFVHSU5fTk9UX0FVVEhfQUREUikKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWNhbGxzdWIgY29udHJvbHMKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjM0MwoJLy8gYXNzZXJ0KHRoaXMuc2VydmljZXMoYm94S2V5KS5leGlzdHMsIGVycnMuU0VSVklDRV9ET0VTX05PVF9FWElTVCkKCWJ5dGVjIDEgLy8gICJzIgoJZnJhbWVfZGlnIDAgLy8gYm94S2V5OiBTZXJ2aWNlc0tleQoJY29uY2F0Cglib3hfbGVuCglzd2FwCglwb3AKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjM0NQoJLy8gYXNzZXJ0KCF0aGlzLnNlcnZpY2VzKGJveEtleSkudmFsdWUuc2h1dGRvd24sIGVycnMuU0VSVklDRV9JU19TSFVURE9XTikKCWJ5dGVjIDEgLy8gICJzIgoJZnJhbWVfZGlnIDAgLy8gYm94S2V5OiBTZXJ2aWNlc0tleQoJY29uY2F0Cglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnNlcnZpY2VzKGJveEtleSkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWludGMgMCAvLyAwCglnZXRiaXQKCSEKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjM0NwoJLy8gdGhpcy5zZXJ2aWNlcyhib3hLZXkpLnZhbHVlLnNodXRkb3duID0gdHJ1ZQoJYnl0ZWMgMSAvLyAgInMiCglmcmFtZV9kaWcgMCAvLyBib3hLZXk6IFNlcnZpY2VzS2V5Cgljb25jYXQKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuc2VydmljZXMoYm94S2V5KS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJaW50YyAwIC8vIDAKCWludGMgMSAvLyAxCglzZXRiaXQKCWJ5dGVjIDEgLy8gICJzIgoJZnJhbWVfZGlnIDAgLy8gYm94S2V5OiBTZXJ2aWNlc0tleQoJY29uY2F0Cgljb3ZlciAyCglib3hfcmVwbGFjZQoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjM0OAoJLy8gdGhpcy5zZXJ2aWNlcyhib3hLZXkpLnZhbHVlLmFjdGl2ZSA9IGZhbHNlCglieXRlYyAxIC8vICAicyIKCWZyYW1lX2RpZyAwIC8vIGJveEtleTogU2VydmljZXNLZXkKCWNvbmNhdAoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5zZXJ2aWNlcyhib3hLZXkpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDEgLy8gMQoJaW50YyAwIC8vIDAKCXNldGJpdAoJYnl0ZWMgMSAvLyAgInMiCglmcmFtZV9kaWcgMCAvLyBib3hLZXk6IFNlcnZpY2VzS2V5Cgljb25jYXQKCWNvdmVyIDIKCWJveF9yZXBsYWNlCgoJLy8gKmlmOF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjM1MAoJLy8gcmVrZXlCYWNrCglmcmFtZV9kaWcgLTIgLy8gcmVrZXlCYWNrOiBib29sZWFuCglieiAqaWY4X2VuZAoKCS8vICppZjhfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MzUxCgkvLyB0aGlzLnJla2V5QmFjayhzZW5kZXIuYWRkcmVzcykKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWNhbGxzdWIgcmVrZXlCYWNrCgoqaWY4X2VuZDoKCXJldHN1YgoKLy8gaXNTaHV0ZG93bihhZGRyZXNzLHVpbnQ2NClib29sCiphYmlfcm91dGVfaXNTaHV0ZG93bjoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZWMgMyAvLyAweDE1MWY3Yzc1CgoJLy8gYm94SW5kZXg6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIG1lcmNoYW50OiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50YyAzIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDEgKG1lcmNoYW50KSBmb3IgaXNTaHV0ZG93biBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBpc1NodXRkb3duKGFkZHJlc3MsdWludDY0KWJvb2wKCWNhbGxzdWIgaXNTaHV0ZG93bgoJYnl0ZWMgNCAvLyAweDAwCglpbnRjIDAgLy8gMAoJdW5jb3ZlciAyCglzZXRiaXQKCWNvbmNhdAoJbG9nCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyBpc1NodXRkb3duKG1lcmNoYW50OiBBZGRyZXNzLCBib3hJbmRleDogdWludDY0KTogYm9vbGVhbgovLwovLyBzZXJ2aWNlSXNBY3RpdmUgY2hlY2tzIGlmIGFuIHNlcnZpY2UgaXMgc2h1dGRvd24KaXNTaHV0ZG93bjoKCXByb3RvIDIgMQoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjM2MAoJLy8gcmV0dXJuIHRoaXMuc2VydmljZXMoeyB1c2VyOiBtZXJjaGFudCwgaW5kZXg6IGJveEluZGV4IH0pLnZhbHVlLnNodXRkb3duOwoJYnl0ZWMgMSAvLyAgInMiCglmcmFtZV9kaWcgLTEgLy8gbWVyY2hhbnQ6IEFkZHJlc3MKCWZyYW1lX2RpZyAtMiAvLyBib3hJbmRleDogdWludDY0CglpdG9iCgljb25jYXQKCWNvbmNhdAoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5zZXJ2aWNlcyh7IHVzZXI6IG1lcmNoYW50LCBpbmRleDogYm94SW5kZXggfSkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWludGMgMCAvLyAwCglnZXRiaXQKCXJldHN1YgoKLy8gYmxvY2sodWludDY0LGJvb2wsYWRkcmVzcyl2b2lkCiphYmlfcm91dGVfYmxvY2s6CgkvLyBhZGRyZXNzOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglkdXAKCWxlbgoJaW50YyAzIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKGFkZHJlc3MpIGZvciBibG9jayBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gcmVrZXlCYWNrOiBib29sCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyAxIC8vIDEKCT09CgoJLy8gYXJndW1lbnQgMSAocmVrZXlCYWNrKSBmb3IgYmxvY2sgbXVzdCBiZSBhIGJvb2wKCWFzc2VydAoJaW50YyAwIC8vIDAKCWdldGJpdAoKCS8vIHNlbmRlcjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBibG9jayh1aW50NjQsYm9vbCxhZGRyZXNzKXZvaWQKCWNhbGxzdWIgYmxvY2sKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIGJsb2NrKHNlbmRlcjogQXBwSUQsIHJla2V5QmFjazogYm9vbGVhbiwgYWRkcmVzczogQWRkcmVzcyk6IHZvaWQKLy8KLy8gYmxvY2sgYmxhY2tsaXN0cyBhbiBhZGRyZXNzIGZvciBhIG1lcmNoYW50Ci8vIEBwYXJhbSBzZW5kZXIgVGhlIGFkZHJlc3MgdGhlIHBsdWdpbiBjdXJyZW50bHkgY29udHJvbHMKLy8gQHBhcmFtIGFkZHJlc3MgVGhlIGFkZHJlc3MgdG8gYmUgYmxvY2tlZApibG9jazoKCXByb3RvIDMgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MzY5CgkvLyBib3hLZXk6IEJsb2NrTGlzdEtleSA9IHsgdXNlcjogc2VuZGVyLmFkZHJlc3MsIGJsb2NrZWQ6IGFkZHJlc3MgfQoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJZnJhbWVfZGlnIC0zIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWNvbmNhdAoJZnJhbWVfYnVyeSAwIC8vIGJveEtleTogQmxvY2tMaXN0S2V5CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6MzcyCgkvLyBhc3NlcnQodGhpcy5jb250cm9scyhzZW5kZXIuYWRkcmVzcyksIGVycnMuUExVR0lOX05PVF9BVVRIX0FERFIpCglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCgljYWxsc3ViIGNvbnRyb2xzCglhc3NlcnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czozNzQKCS8vIGFzc2VydCghdGhpcy5ibG9ja3MoYm94S2V5KS5leGlzdHMsIGVycnMuVVNFUl9BTFJFQURZX0JMT0NLRUQpCglmcmFtZV9kaWcgMCAvLyBib3hLZXk6IEJsb2NrTGlzdEtleQoJYm94X2xlbgoJc3dhcAoJcG9wCgkhCglhc3NlcnQKCgkvLyAqaWY5X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6Mzc3CgkvLyByZWtleUJhY2sKCWZyYW1lX2RpZyAtMiAvLyByZWtleUJhY2s6IGJvb2xlYW4KCWJ6ICppZjlfZWxzZQoKCS8vICppZjlfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6Mzc4CgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgIHNlbmRlcjogc2VuZGVyLmFkZHJlc3MsCgkvLyAgICAgICAgIHJlY2VpdmVyOiBnbG9iYWxzLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCgkvLyAgICAgICAgIGFtb3VudDogMjhfMTAwLAoJLy8gICAgICAgICByZWtleVRvOiBzZW5kZXIuYWRkcmVzcywKCS8vICAgICAgICAgZmVlOiAwLAoJLy8gICAgICAgfSkKCWl0eG5fYmVnaW4KCWludGMgMSAvLyAgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6Mzc5CgkvLyBzZW5kZXI6IHNlbmRlci5hZGRyZXNzCglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCglpdHhuX2ZpZWxkIFNlbmRlcgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjM4MAoJLy8gcmVjZWl2ZXI6IGdsb2JhbHMuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czozODEKCS8vIGFtb3VudDogMjhfMTAwCglpbnRjIDEzIC8vIDI4XzEwMAoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czozODIKCS8vIHJla2V5VG86IHNlbmRlci5hZGRyZXNzCglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCglpdHhuX2ZpZWxkIFJla2V5VG8KCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czozODMKCS8vIGZlZTogMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJYiAqaWY5X2VuZAoKKmlmOV9lbHNlOgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6Mzg2CgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgIHNlbmRlcjogc2VuZGVyLmFkZHJlc3MsCgkvLyAgICAgICAgIHJlY2VpdmVyOiBnbG9iYWxzLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCgkvLyAgICAgICAgIGFtb3VudDogMjhfMTAwLAoJLy8gICAgICAgICBmZWU6IDAsCgkvLyAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50YyAxIC8vICBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czozODcKCS8vIHNlbmRlcjogc2VuZGVyLmFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWl0eG5fZmllbGQgU2VuZGVyCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6Mzg4CgkvLyByZWNlaXZlcjogZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjM4OQoJLy8gYW1vdW50OiAyOF8xMDAKCWludGMgMTMgLy8gMjhfMTAwCglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjM5MAoJLy8gZmVlOiAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoqaWY5X2VuZDoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjM5NAoJLy8gdGhpcy5ibG9ja3MoYm94S2V5KS5jcmVhdGUoMCkKCWZyYW1lX2RpZyAwIC8vIGJveEtleTogQmxvY2tMaXN0S2V5CglpbnRjIDAgLy8gMAoJYm94X2NyZWF0ZQoJcG9wCglyZXRzdWIKCi8vIHVuYmxvY2sodWludDY0LGJvb2wsYWRkcmVzcyl2b2lkCiphYmlfcm91dGVfdW5ibG9jazoKCS8vIGFkZHJlc3M6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWR1cAoJbGVuCglpbnRjIDMgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgMCAoYWRkcmVzcykgZm9yIHVuYmxvY2sgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIHJla2V5QmFjazogYm9vbAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgMSAvLyAxCgk9PQoKCS8vIGFyZ3VtZW50IDEgKHJla2V5QmFjaykgZm9yIHVuYmxvY2sgbXVzdCBiZSBhIGJvb2wKCWFzc2VydAoJaW50YyAwIC8vIDAKCWdldGJpdAoKCS8vIHNlbmRlcjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSB1bmJsb2NrKHVpbnQ2NCxib29sLGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiB1bmJsb2NrCglpbnRjIDEgLy8gMQoJcmV0dXJuCgovLyB1bmJsb2NrKHNlbmRlcjogQXBwSUQsIHJla2V5QmFjazogYm9vbGVhbiwgYWRkcmVzczogQWRkcmVzcyk6IHZvaWQKLy8KLy8gdW5ibG9jayByZW1vdmVzIGFuIGFkZHJlc3MgZnJvbSBhIG1lcmNoYW50cyBibG9ja3MKLy8gQHBhcmFtIGFkZHJlc3MgVGhlIGFkZHJlc3MgdG8gYmUgdW5ibG9ja2VkCnVuYmxvY2s6Cglwcm90byAzIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjQwMgoJLy8gYm94S2V5OiBCbG9ja0xpc3RLZXkgPSB7IHVzZXI6IHNlbmRlci5hZGRyZXNzLCBibG9ja2VkOiBhZGRyZXNzIH0KCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWZyYW1lX2RpZyAtMyAvLyBhZGRyZXNzOiBBZGRyZXNzCgljb25jYXQKCWZyYW1lX2J1cnkgMCAvLyBib3hLZXk6IEJsb2NrTGlzdEtleQoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjQwNQoJLy8gYXNzZXJ0KHRoaXMuY29udHJvbHMoc2VuZGVyLmFkZHJlc3MpLCBlcnJzLlBMVUdJTl9OT1RfQVVUSF9BRERSKQoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJY2FsbHN1YiBjb250cm9scwoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NDA3CgkvLyBhc3NlcnQodGhpcy5ibG9ja3MoYm94S2V5KS5leGlzdHMsIGVycnMuVVNFUl9OT1RfQkxPQ0tFRCkKCWZyYW1lX2RpZyAwIC8vIGJveEtleTogQmxvY2tMaXN0S2V5Cglib3hfbGVuCglzd2FwCglwb3AKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjQwOQoJLy8gdGhpcy5ibG9ja3MoYm94S2V5KS5kZWxldGUoKQoJZnJhbWVfZGlnIDAgLy8gYm94S2V5OiBCbG9ja0xpc3RLZXkKCWJveF9kZWwKCgkvLyAqaWYxMF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjQxMQoJLy8gcmVrZXlCYWNrCglmcmFtZV9kaWcgLTIgLy8gcmVrZXlCYWNrOiBib29sZWFuCglieiAqaWYxMF9lbmQKCgkvLyAqaWYxMF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo0MTIKCS8vIHRoaXMucmVrZXlCYWNrKHNlbmRlci5hZGRyZXNzKQoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJY2FsbHN1YiByZWtleUJhY2sKCippZjEwX2VuZDoKCXJldHN1YgoKLy8gaXNCbG9ja2VkKGFkZHJlc3MsYWRkcmVzcylib29sCiphYmlfcm91dGVfaXNCbG9ja2VkOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlYyAzIC8vIDB4MTUxZjdjNzUKCgkvLyBhZGRyZXNzOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50YyAzIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKGFkZHJlc3MpIGZvciBpc0Jsb2NrZWQgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIG1lcmNoYW50OiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50YyAzIC8vIDMyCgk9PQoKCS8vIGFyZ3VtZW50IDEgKG1lcmNoYW50KSBmb3IgaXNCbG9ja2VkIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIGlzQmxvY2tlZChhZGRyZXNzLGFkZHJlc3MpYm9vbAoJY2FsbHN1YiBpc0Jsb2NrZWQKCWJ5dGVjIDQgLy8gMHgwMAoJaW50YyAwIC8vIDAKCXVuY292ZXIgMgoJc2V0Yml0Cgljb25jYXQKCWxvZwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gaXNCbG9ja2VkKG1lcmNoYW50OiBBZGRyZXNzLCBhZGRyZXNzOiBBZGRyZXNzKTogYm9vbGVhbgovLwovLyBpc0Jsb2NrZWQgY2hlY2tzIGlmIGFuIGFkZHJlc3MgaXMgYmxvY2tlZCBmb3IgYSBtZXJjaGFudAovLyBAcGFyYW0gbWVyY2hhbnQgVGhlIG1lcmNoYW50IGFkZHJlc3MgdG8gYmUgY2hlY2tlZAovLyBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcyB0byBiZSBjaGVja2VkCmlzQmxvY2tlZDoKCXByb3RvIDIgMQoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjQyMwoJLy8gcmV0dXJuIHRoaXMuYmxvY2tzKHsgdXNlcjogbWVyY2hhbnQsIGJsb2NrZWQ6IGFkZHJlc3MgfSkuZXhpc3RzOwoJZnJhbWVfZGlnIC0xIC8vIG1lcmNoYW50OiBBZGRyZXNzCglmcmFtZV9kaWcgLTIgLy8gYWRkcmVzczogQWRkcmVzcwoJY29uY2F0Cglib3hfbGVuCglzd2FwCglwb3AKCXJldHN1YgoKLy8gc3Vic2NyaWJlKHVpbnQ2NCxib29sLGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQKKmFiaV9yb3V0ZV9zdWJzY3JpYmU6CgkvLyBhc3NldDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA3CglidG9pCgoJLy8gaW50ZXJ2YWw6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgoJYnRvaQoKCS8vIGFtb3VudDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA1CglidG9pCgoJLy8gaW5kZXg6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJYnRvaQoKCS8vIHJlY2lwaWVudDogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZHVwCglsZW4KCWludGMgMyAvLyAzMgoJPT0KCgkvLyBhcmd1bWVudCA0IChyZWNpcGllbnQpIGZvciBzdWJzY3JpYmUgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIHJla2V5QmFjazogYm9vbAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgMSAvLyAxCgk9PQoKCS8vIGFyZ3VtZW50IDUgKHJla2V5QmFjaykgZm9yIHN1YnNjcmliZSBtdXN0IGJlIGEgYm9vbAoJYXNzZXJ0CglpbnRjIDAgLy8gMAoJZ2V0Yml0CgoJLy8gc2VuZGVyOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIHN1YnNjcmliZSh1aW50NjQsYm9vbCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkCgljYWxsc3ViIHN1YnNjcmliZQoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gc3Vic2NyaWJlKHNlbmRlcjogQXBwSUQsIHJla2V5QmFjazogYm9vbGVhbiwgcmVjaXBpZW50OiBBZGRyZXNzLCBpbmRleDogdWludDY0LCBhbW91bnQ6IHVpbnQ2NCwgaW50ZXJ2YWw6IHVpbnQ2NCwgYXNzZXQ6IEFzc2V0SUQpOiB2b2lkCnN1YnNjcmliZToKCXByb3RvIDcgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CglkdXBuIDEwCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NDM1CgkvLyBpc0RvbmF0aW9uID0gaW5kZXggPT09IDAKCWZyYW1lX2RpZyAtNCAvLyBpbmRleDogdWludDY0CglpbnRjIDAgLy8gMAoJPT0KCWZyYW1lX2J1cnkgMCAvLyBpc0RvbmF0aW9uOiBib29sCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NDM2CgkvLyBpc0FzYSA9IGFzc2V0LmlkICE9PSAwCglmcmFtZV9kaWcgLTcgLy8gYXNzZXQ6IEFzc2V0SUQKCWludGMgMCAvLyAwCgkhPQoJZnJhbWVfYnVyeSAxIC8vIGlzQXNhOiBib29sCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NDM5CgkvLyBhc3NlcnQodGhpcy5jb250cm9scyhzZW5kZXIuYWRkcmVzcyksIGVycnMuUExVR0lOX05PVF9BVVRIX0FERFIpCglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCgljYWxsc3ViIGNvbnRyb2xzCglhc3NlcnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo0NDEKCS8vIGFzc2VydChhbW91bnQgPiAzLCBlcnJzLk1JTl9BTU9VTlRfSVNfVEhSRUUpCglmcmFtZV9kaWcgLTUgLy8gYW1vdW50OiB1aW50NjQKCWludGMgMTQgLy8gMwoJPgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NDQzCgkvLyBhc3NlcnQoaW50ZXJ2YWwgPj0gNjAsIGVycnMuTUlOX0lOVEVSVkFMX0lTX1NJWFRZKQoJZnJhbWVfZGlnIC02IC8vIGludGVydmFsOiB1aW50NjQKCWludGMgMTYgLy8gNjAKCT49Cglhc3NlcnQKCgkvLyAqaWYxMV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjQ0NQoJLy8gIWlzRG9uYXRpb24KCWZyYW1lX2RpZyAwIC8vIGlzRG9uYXRpb246IGJvb2wKCSEKCWJ6ICppZjExX2VuZAoKCS8vICppZjExX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjQ0NgoJLy8gYm94S2V5OiBTZXJ2aWNlc0tleSA9IHsgdXNlcjogcmVjaXBpZW50LCBpbmRleDogaW5kZXggfQoJZnJhbWVfZGlnIC0zIC8vIHJlY2lwaWVudDogQWRkcmVzcwoJZnJhbWVfZGlnIC00IC8vIGluZGV4OiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfYnVyeSAyIC8vIGJveEtleTogU2VydmljZXNLZXkKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo0NDcKCS8vIGJsb2Nrc0tleTogQmxvY2tMaXN0S2V5ID0geyB1c2VyOiByZWNpcGllbnQsIGJsb2NrZWQ6IHNlbmRlci5hZGRyZXNzIH0KCWZyYW1lX2RpZyAtMyAvLyByZWNpcGllbnQ6IEFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWNvbmNhdAoJZnJhbWVfYnVyeSAzIC8vIGJsb2Nrc0tleTogQmxvY2tMaXN0S2V5CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NDUwCgkvLyBhc3NlcnQodGhpcy5zZXJ2aWNlcyhib3hLZXkpLmV4aXN0cywgZXJycy5TRVJWSUNFX0RPRVNfTk9UX0VYSVNUKQoJYnl0ZWMgMSAvLyAgInMiCglmcmFtZV9kaWcgMiAvLyBib3hLZXk6IFNlcnZpY2VzS2V5Cgljb25jYXQKCWJveF9sZW4KCXN3YXAKCXBvcAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NDUyCgkvLyBzZXJ2aWNlID0gdGhpcy5zZXJ2aWNlcyhib3hLZXkpLnZhbHVlCglieXRlYyAxIC8vICAicyIKCWZyYW1lX2RpZyAyIC8vIGJveEtleTogU2VydmljZXNLZXkKCWNvbmNhdAoJZnJhbWVfYnVyeSA0IC8vIHN0b3JhZ2Uga2V5Ly9zZXJ2aWNlCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NDU1CgkvLyBhc3NlcnQoIXRoaXMuYmxvY2tzKGJsb2Nrc0tleSkuZXhpc3RzLCBlcnJzLkJMT0NLRUQpCglmcmFtZV9kaWcgMyAvLyBibG9ja3NLZXk6IEJsb2NrTGlzdEtleQoJYm94X2xlbgoJc3dhcAoJcG9wCgkhCglhc3NlcnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo0NTcKCS8vIGFzc2VydCghc2VydmljZS5zaHV0ZG93biwgZXJycy5TRVJWSUNFX0lTX1NIVVRET1dOKQoJZnJhbWVfZGlnIDQgLy8gc3RvcmFnZSBrZXkvL3NlcnZpY2UKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuc2VydmljZXMoYm94S2V5KS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJaW50YyAwIC8vIDAKCWdldGJpdAoJIQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NDU5CgkvLyBhc3NlcnQoc2VydmljZS5hY3RpdmUsIGVycnMuU0VSVklDRV9JU19QQVVTRUQpCglmcmFtZV9kaWcgNCAvLyBzdG9yYWdlIGtleS8vc2VydmljZQoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5zZXJ2aWNlcyhib3hLZXkpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDEgLy8gMQoJZ2V0Yml0Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo0NjEKCS8vIGFtb3VudCA9IHNlcnZpY2UuYW1vdW50CglmcmFtZV9kaWcgNCAvLyBzdG9yYWdlIGtleS8vc2VydmljZQoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5zZXJ2aWNlcyhib3hLZXkpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDE3IDgKCWJ0b2kKCWZyYW1lX2J1cnkgLTUgLy8gYW1vdW50OiB1aW50NjQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo0NjIKCS8vIGludGVydmFsID0gc2VydmljZS5pbnRlcnZhbAoJZnJhbWVfZGlnIDQgLy8gc3RvcmFnZSBrZXkvL3NlcnZpY2UKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuc2VydmljZXMoYm94S2V5KS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAxIDgKCWJ0b2kKCWZyYW1lX2J1cnkgLTYgLy8gaW50ZXJ2YWw6IHVpbnQ2NAoKKmlmMTFfZW5kOgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NDY1CgkvLyBhbGdvTUJSRmVlOiB1aW50NjQgPSA1M183MDAKCXB1c2hpbnQgNTNfNzAwCglmcmFtZV9idXJ5IDUgLy8gYWxnb01CUkZlZTogdWludDY0CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NDY2CgkvLyBzdWJJbmRleDogdWludDY0ID0gMAoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgNiAvLyBzdWJJbmRleDogdWludDY0CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NDY3CgkvLyBzdWJzY3JpcHRpb25zTGlzdEV4aXN0czogYm9vbGVhbiA9IHRoaXMuc3Vic2NyaXB0aW9uc2xpc3Qoc2VuZGVyLmFkZHJlc3MpLmV4aXN0cwoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJYm94X2xlbgoJc3dhcAoJcG9wCglmcmFtZV9idXJ5IDcgLy8gc3Vic2NyaXB0aW9uc0xpc3RFeGlzdHM6IGJvb2xlYW4KCgkvLyAqaWYxMl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjQ2OAoJLy8gc3Vic2NyaXB0aW9uc0xpc3RFeGlzdHMKCWZyYW1lX2RpZyA3IC8vIHN1YnNjcmlwdGlvbnNMaXN0RXhpc3RzOiBib29sZWFuCglieiAqaWYxMl9lbHNlCgoJLy8gKmlmMTJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NDY5CgkvLyBzdWJJbmRleCA9IHRoaXMuc3Vic2NyaXB0aW9uc2xpc3Qoc2VuZGVyLmFkZHJlc3MpLnZhbHVlCglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnN1YnNjcmlwdGlvbnNsaXN0KHNlbmRlci5hZGRyZXNzKS52YWx1ZQoJYXNzZXJ0CglidG9pCglmcmFtZV9idXJ5IDYgLy8gc3ViSW5kZXg6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjQ3MAoJLy8gdGhpcy5zdWJzY3JpcHRpb25zbGlzdChzZW5kZXIuYWRkcmVzcykudmFsdWUgKz0gMQoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5zdWJzY3JpcHRpb25zbGlzdChzZW5kZXIuYWRkcmVzcykudmFsdWUKCWFzc2VydAoJYnRvaQoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCXN3YXAKCWl0b2IKCWJveF9wdXQKCWIgKmlmMTJfZW5kCgoqaWYxMl9lbHNlOgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NDcyCgkvLyBhbGdvTUJSRmVlICs9IDE4XzUwMAoJZnJhbWVfZGlnIDUgLy8gYWxnb01CUkZlZTogdWludDY0CglwdXNoaW50IDE4XzUwMAoJKwoJZnJhbWVfYnVyeSA1IC8vIGFsZ29NQlJGZWU6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjQ3MwoJLy8gc3ViSW5kZXggPSAwCglpbnRjIDAgLy8gMAoJZnJhbWVfYnVyeSA2IC8vIHN1YkluZGV4OiB1aW50NjQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo0NzQKCS8vIHRoaXMuc3Vic2NyaXB0aW9uc2xpc3Qoc2VuZGVyLmFkZHJlc3MpLnZhbHVlID0gMAoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJcHVzaGJ5dGVzIDB4MDAwMDAwMDAwMDAwMDAwMAoJYm94X3B1dAoKKmlmMTJfZW5kOgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NDc3CgkvLyBzdWJzY3JpcHRpb25LZXk6IFN1YnNjcmlwdGlvbktleSA9IHsgdXNlcjogc2VuZGVyLmFkZHJlc3MsIGluZGV4OiBzdWJJbmRleCB9CglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCglmcmFtZV9kaWcgNiAvLyBzdWJJbmRleDogdWludDY0CglpdG9iCgljb25jYXQKCWZyYW1lX2J1cnkgOCAvLyBzdWJzY3JpcHRpb25LZXk6IFN1YnNjcmlwdGlvbktleQoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjQ3OQoJLy8gdGhpcy5zdWJzY3JpcHRpb25zKHN1YnNjcmlwdGlvbktleSkudmFsdWUgPSB7CgkvLyAgICAgICByZWNpcGllbnQ6IHJlY2lwaWVudCwKCS8vICAgICAgIGluZGV4OiBpbmRleCwKCS8vICAgICAgIHN0YXJ0RGF0ZTogZ2xvYmFscy5sYXRlc3RUaW1lc3RhbXAsCgkvLyAgICAgICBhbW91bnQ6IGFtb3VudCwKCS8vICAgICAgIGludGVydmFsOiBpbnRlcnZhbCwKCS8vICAgICAgIGFzc2V0OiBhc3NldCwKCS8vICAgICAgIGxhc3RQYXltZW50OiBnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCwKCS8vICAgICAgIHN0cmVhazogMSwKCS8vICAgICB9CglmcmFtZV9kaWcgOCAvLyBzdWJzY3JpcHRpb25LZXk6IFN1YnNjcmlwdGlvbktleQoJZnJhbWVfZGlnIC0zIC8vIHJlY2lwaWVudDogQWRkcmVzcwoJZnJhbWVfZGlnIC00IC8vIGluZGV4OiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJaXRvYgoJY29uY2F0CglmcmFtZV9kaWcgLTUgLy8gYW1vdW50OiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfZGlnIC02IC8vIGludGVydmFsOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfZGlnIC03IC8vIGFzc2V0OiBBc3NldElECglpdG9iCgljb25jYXQKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWl0b2IKCWNvbmNhdAoJYnl0ZWMgNiAvLyAweDAwMDAwMDAwMDAwMDAwMDEKCWNvbmNhdAoJYm94X3B1dAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjQ5MAoJLy8gaW5pdGlhbEZlZSA9IChhbW91bnQgKiA0MCAtIDEpIC8gMTAwMCArIDEKCWZyYW1lX2RpZyAtNSAvLyBhbW91bnQ6IHVpbnQ2NAoJaW50YyA3IC8vIDQwCgkqCglpbnRjIDEgLy8gMQoJLQoJaW50YyAxMiAvLyAxMDAwCgkvCglpbnRjIDEgLy8gMQoJKwoJZnJhbWVfYnVyeSA5IC8vIGluaXRpYWxGZWU6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjQ5MQoJLy8gbGVmdE92ZXIgPSBhbW91bnQgLSBpbml0aWFsRmVlCglmcmFtZV9kaWcgLTUgLy8gYW1vdW50OiB1aW50NjQKCWZyYW1lX2RpZyA5IC8vIGluaXRpYWxGZWU6IHVpbnQ2NAoJLQoJZnJhbWVfYnVyeSAxMCAvLyBsZWZ0T3ZlcjogdWludDY0CgoJLy8gKmlmMTNfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo0OTMKCS8vIGlzQXNhCglmcmFtZV9kaWcgMSAvLyBpc0FzYTogYm9vbAoJYnogKmlmMTNfZWxzZQoKCS8vICppZjEzX2NvbnNlcXVlbnQKCS8vICppZjE0X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NDk0CgkvLyAhdGhpcy5hcHAuYWRkcmVzcy5pc09wdGVkSW5Ub0Fzc2V0KGFzc2V0KQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWZyYW1lX2RpZyAtNyAvLyBhc3NldDogQXNzZXRJRAoJYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCglzd2FwCglwb3AKCSEKCWJ6ICppZjE0X2Vsc2UKCgkvLyAqaWYxNF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo0OTYKCS8vIHRoaXMuYWRkUGVuZGluZ09wdGluKHNlbmRlciwgZmFsc2UsIGFzc2V0LCBhbGdvTUJSRmVlKQoJZnJhbWVfZGlnIDUgLy8gYWxnb01CUkZlZTogdWludDY0CglmcmFtZV9kaWcgLTcgLy8gYXNzZXQ6IEFzc2V0SUQKCWludGMgMCAvLyAwCglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJY2FsbHN1YiBhZGRQZW5kaW5nT3B0aW4KCWIgKmlmMTRfZW5kCgoqaWYxNF9lbHNlOgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NDk5CgkvLyB0aGlzLnBlbmRpbmdHcm91cC5hZGRQYXltZW50KHsKCS8vICAgICAgICAgICBzZW5kZXI6IHNlbmRlci5hZGRyZXNzLAoJLy8gICAgICAgICAgIHJlY2VpdmVyOiBnbG9iYWxzLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCgkvLyAgICAgICAgICAgYW1vdW50OiBhbGdvTUJSRmVlLAoJLy8gICAgICAgICAgIGZlZTogMCwKCS8vICAgICAgICAgfSkKCWl0eG5fbmV4dAoJaW50YyAxIC8vICBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo1MDAKCS8vIHNlbmRlcjogc2VuZGVyLmFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWl0eG5fZmllbGQgU2VuZGVyCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTAxCgkvLyByZWNlaXZlcjogZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjUwMgoJLy8gYW1vdW50OiBhbGdvTUJSRmVlCglmcmFtZV9kaWcgNSAvLyBhbGdvTUJSRmVlOiB1aW50NjQKCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTAzCgkvLyBmZWU6IDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoKKmlmMTRfZW5kOgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTA3CgkvLyB0aGlzLnBlbmRpbmdHcm91cC5hZGRBc3NldFRyYW5zZmVyKHsKCS8vICAgICAgICAgc2VuZGVyOiBzZW5kZXIuYWRkcmVzcywKCS8vICAgICAgICAgYXNzZXRSZWNlaXZlcjogZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAoJLy8gICAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAoJLy8gICAgICAgICBhc3NldEFtb3VudDogaW5pdGlhbEZlZSwKCS8vICAgICAgICAgZmVlOiAwLAoJLy8gICAgICAgfSkKCWl0eG5fbmV4dAoJaW50YyA0IC8vICBheGZlcgoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjUwOAoJLy8gc2VuZGVyOiBzZW5kZXIuYWRkcmVzcwoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJaXR4bl9maWVsZCBTZW5kZXIKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo1MDkKCS8vIGFzc2V0UmVjZWl2ZXI6IGdsb2JhbHMuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjUxMAoJLy8geGZlckFzc2V0OiBhc3NldAoJZnJhbWVfZGlnIC03IC8vIGFzc2V0OiBBc3NldElECglpdHhuX2ZpZWxkIFhmZXJBc3NldAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjUxMQoJLy8gYXNzZXRBbW91bnQ6IGluaXRpYWxGZWUKCWZyYW1lX2RpZyA5IC8vIGluaXRpYWxGZWU6IHVpbnQ2NAoJaXR4bl9maWVsZCBBc3NldEFtb3VudAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjUxMgoJLy8gZmVlOiAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyAqaWYxNV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjUxNQoJLy8gcmVrZXlCYWNrCglmcmFtZV9kaWcgLTIgLy8gcmVrZXlCYWNrOiBib29sZWFuCglieiAqaWYxNV9lbHNlCgoJLy8gKmlmMTVfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTE2CgkvLyB0aGlzLnBlbmRpbmdHcm91cC5hZGRBc3NldFRyYW5zZmVyKHsKCS8vICAgICAgICAgICBzZW5kZXI6IHNlbmRlci5hZGRyZXNzLAoJLy8gICAgICAgICAgIGFzc2V0UmVjZWl2ZXI6IHJlY2lwaWVudCwKCS8vICAgICAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAoJLy8gICAgICAgICAgIGFzc2V0QW1vdW50OiBsZWZ0T3ZlciwKCS8vICAgICAgICAgICByZWtleVRvOiBzZW5kZXIuYWRkcmVzcywKCS8vICAgICAgICAgICBmZWU6IDAsCgkvLyAgICAgICAgIH0pCglpdHhuX25leHQKCWludGMgNCAvLyAgYXhmZXIKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo1MTcKCS8vIHNlbmRlcjogc2VuZGVyLmFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWl0eG5fZmllbGQgU2VuZGVyCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTE4CgkvLyBhc3NldFJlY2VpdmVyOiByZWNpcGllbnQKCWZyYW1lX2RpZyAtMyAvLyByZWNpcGllbnQ6IEFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjUxOQoJLy8geGZlckFzc2V0OiBhc3NldAoJZnJhbWVfZGlnIC03IC8vIGFzc2V0OiBBc3NldElECglpdHhuX2ZpZWxkIFhmZXJBc3NldAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjUyMAoJLy8gYXNzZXRBbW91bnQ6IGxlZnRPdmVyCglmcmFtZV9kaWcgMTAgLy8gbGVmdE92ZXI6IHVpbnQ2NAoJaXR4bl9maWVsZCBBc3NldEFtb3VudAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjUyMQoJLy8gcmVrZXlUbzogc2VuZGVyLmFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWl0eG5fZmllbGQgUmVrZXlUbwoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjUyMgoJLy8gZmVlOiAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCWIgKmlmMTVfZW5kCgoqaWYxNV9lbHNlOgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTI1CgkvLyB0aGlzLnBlbmRpbmdHcm91cC5hZGRBc3NldFRyYW5zZmVyKHsKCS8vICAgICAgICAgICBzZW5kZXI6IHNlbmRlci5hZGRyZXNzLAoJLy8gICAgICAgICAgIGFzc2V0UmVjZWl2ZXI6IHJlY2lwaWVudCwKCS8vICAgICAgICAgICB4ZmVyQXNzZXQ6IGFzc2V0LAoJLy8gICAgICAgICAgIGFzc2V0QW1vdW50OiBsZWZ0T3ZlciwKCS8vICAgICAgICAgICByZWtleVRvOiBzZW5kZXIuYWRkcmVzcywKCS8vICAgICAgICAgICBmZWU6IDAsCgkvLyAgICAgICAgIH0pCglpdHhuX25leHQKCWludGMgNCAvLyAgYXhmZXIKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo1MjYKCS8vIHNlbmRlcjogc2VuZGVyLmFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWl0eG5fZmllbGQgU2VuZGVyCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTI3CgkvLyBhc3NldFJlY2VpdmVyOiByZWNpcGllbnQKCWZyYW1lX2RpZyAtMyAvLyByZWNpcGllbnQ6IEFkZHJlc3MKCWl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjUyOAoJLy8geGZlckFzc2V0OiBhc3NldAoJZnJhbWVfZGlnIC03IC8vIGFzc2V0OiBBc3NldElECglpdHhuX2ZpZWxkIFhmZXJBc3NldAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjUyOQoJLy8gYXNzZXRBbW91bnQ6IGxlZnRPdmVyCglmcmFtZV9kaWcgMTAgLy8gbGVmdE92ZXI6IHVpbnQ2NAoJaXR4bl9maWVsZCBBc3NldEFtb3VudAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjUzMAoJLy8gcmVrZXlUbzogc2VuZGVyLmFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWl0eG5fZmllbGQgUmVrZXlUbwoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjUzMQoJLy8gZmVlOiAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCippZjE1X2VuZDoKCWIgKmlmMTNfZW5kCgoqaWYxM19lbHNlOgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTM2CgkvLyB0aGlzLnBlbmRpbmdHcm91cC5hZGRQYXltZW50KHsKCS8vICAgICAgICAgc2VuZGVyOiBzZW5kZXIuYWRkcmVzcywKCS8vICAgICAgICAgcmVjZWl2ZXI6IGdsb2JhbHMuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKCS8vICAgICAgICAgYW1vdW50OiAoYWxnb01CUkZlZSArIGluaXRpYWxGZWUpLAoJLy8gICAgICAgICBmZWU6IDAsCgkvLyAgICAgICB9KQoJaXR4bl9uZXh0CglpbnRjIDEgLy8gIHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjUzNwoJLy8gc2VuZGVyOiBzZW5kZXIuYWRkcmVzcwoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJaXR4bl9maWVsZCBTZW5kZXIKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo1MzgKCS8vIHJlY2VpdmVyOiBnbG9iYWxzLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTM5CgkvLyBhbW91bnQ6IChhbGdvTUJSRmVlICsgaW5pdGlhbEZlZSkKCWZyYW1lX2RpZyA1IC8vIGFsZ29NQlJGZWU6IHVpbnQ2NAoJZnJhbWVfZGlnIDkgLy8gaW5pdGlhbEZlZTogdWludDY0CgkrCglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjU0MAoJLy8gZmVlOiAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyAqaWYxNl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjU0MwoJLy8gcmVrZXlCYWNrCglmcmFtZV9kaWcgLTIgLy8gcmVrZXlCYWNrOiBib29sZWFuCglieiAqaWYxNl9lbHNlCgoJLy8gKmlmMTZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTQ0CgkvLyB0aGlzLnBlbmRpbmdHcm91cC5hZGRQYXltZW50KHsKCS8vICAgICAgICAgICBzZW5kZXI6IHNlbmRlci5hZGRyZXNzLAoJLy8gICAgICAgICAgIHJlY2VpdmVyOiByZWNpcGllbnQsCgkvLyAgICAgICAgICAgYW1vdW50OiBsZWZ0T3ZlciwKCS8vICAgICAgICAgICByZWtleVRvOiBzZW5kZXIuYWRkcmVzcywKCS8vICAgICAgICAgICBmZWU6IDAsCgkvLyAgICAgICAgIH0pCglpdHhuX25leHQKCWludGMgMSAvLyAgcGF5CglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTQ1CgkvLyBzZW5kZXI6IHNlbmRlci5hZGRyZXNzCglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCglpdHhuX2ZpZWxkIFNlbmRlcgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjU0NgoJLy8gcmVjZWl2ZXI6IHJlY2lwaWVudAoJZnJhbWVfZGlnIC0zIC8vIHJlY2lwaWVudDogQWRkcmVzcwoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjU0NwoJLy8gYW1vdW50OiBsZWZ0T3ZlcgoJZnJhbWVfZGlnIDEwIC8vIGxlZnRPdmVyOiB1aW50NjQKCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTQ4CgkvLyByZWtleVRvOiBzZW5kZXIuYWRkcmVzcwoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJaXR4bl9maWVsZCBSZWtleVRvCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTQ5CgkvLyBmZWU6IDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoJYiAqaWYxNl9lbmQKCippZjE2X2Vsc2U6CgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo1NTIKCS8vIHRoaXMucGVuZGluZ0dyb3VwLmFkZFBheW1lbnQoewoJLy8gICAgICAgICAgIHNlbmRlcjogc2VuZGVyLmFkZHJlc3MsCgkvLyAgICAgICAgICAgcmVjZWl2ZXI6IHJlY2lwaWVudCwKCS8vICAgICAgICAgICBhbW91bnQ6IGxlZnRPdmVyLAoJLy8gICAgICAgICAgIGZlZTogMCwKCS8vICAgICAgICAgfSkKCWl0eG5fbmV4dAoJaW50YyAxIC8vICBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo1NTMKCS8vIHNlbmRlcjogc2VuZGVyLmFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWl0eG5fZmllbGQgU2VuZGVyCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTU0CgkvLyByZWNlaXZlcjogcmVjaXBpZW50CglmcmFtZV9kaWcgLTMgLy8gcmVjaXBpZW50OiBBZGRyZXNzCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTU1CgkvLyBhbW91bnQ6IGxlZnRPdmVyCglmcmFtZV9kaWcgMTAgLy8gbGVmdE92ZXI6IHVpbnQ2NAoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo1NTYKCS8vIGZlZTogMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoqaWYxNl9lbmQ6CgoqaWYxM19lbmQ6CgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo1NjEKCS8vIHRoaXMucGVuZGluZ0dyb3VwLnN1Ym1pdCgpCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgovLyB0cmlnZ2VyUGF5bWVudCh1aW50NjQsYm9vbCx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX3RyaWdnZXJQYXltZW50OgoJLy8gaW5kZXg6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIHJla2V5QmFjazogYm9vbAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludGMgMSAvLyAxCgk9PQoKCS8vIGFyZ3VtZW50IDEgKHJla2V5QmFjaykgZm9yIHRyaWdnZXJQYXltZW50IG11c3QgYmUgYSBib29sCglhc3NlcnQKCWludGMgMCAvLyAwCglnZXRiaXQKCgkvLyBzZW5kZXI6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgdHJpZ2dlclBheW1lbnQodWludDY0LGJvb2wsdWludDY0KXZvaWQKCWNhbGxzdWIgdHJpZ2dlclBheW1lbnQKCWludGMgMSAvLyAxCglyZXR1cm4KCi8vIHRyaWdnZXJQYXltZW50KHNlbmRlcjogQXBwSUQsIHJla2V5QmFjazogYm9vbGVhbiwgaW5kZXg6IHVpbnQ2NCk6IHZvaWQKdHJpZ2dlclBheW1lbnQ6Cglwcm90byAzIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZWMgMCAvLyAweAoJZHVwbiA3CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTY1CgkvLyBzdWJzY3JpcHRpb25zS2V5OiBTdWJzY3JpcHRpb25LZXkgPSB7IHVzZXI6IHNlbmRlci5hZGRyZXNzLCBpbmRleDogaW5kZXggfQoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJZnJhbWVfZGlnIC0zIC8vIGluZGV4OiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfYnVyeSAwIC8vIHN1YnNjcmlwdGlvbnNLZXk6IFN1YnNjcmlwdGlvbktleQoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjU2OAoJLy8gYXNzZXJ0KHRoaXMuc3Vic2NyaXB0aW9ucyhzdWJzY3JpcHRpb25zS2V5KS5leGlzdHMpCglmcmFtZV9kaWcgMCAvLyBzdWJzY3JpcHRpb25zS2V5OiBTdWJzY3JpcHRpb25LZXkKCWJveF9sZW4KCXN3YXAKCXBvcAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTcwCgkvLyBzdWIgPSB0aGlzLnN1YnNjcmlwdGlvbnMoc3Vic2NyaXB0aW9uc0tleSkudmFsdWUKCWZyYW1lX2RpZyAwIC8vIHN1YnNjcmlwdGlvbnNLZXk6IFN1YnNjcmlwdGlvbktleQoJZnJhbWVfYnVyeSAxIC8vIHN0b3JhZ2Uga2V5Ly9zdWIKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo1NzIKCS8vIGJsb2Nrc0tleTogQmxvY2tMaXN0S2V5ID0geyB1c2VyOiBzdWIucmVjaXBpZW50LCBibG9ja2VkOiBzZW5kZXIuYWRkcmVzcyB9CglmcmFtZV9kaWcgMCAvLyBzdWJzY3JpcHRpb25zS2V5OiBTdWJzY3JpcHRpb25LZXkKCWludGMgMCAvLyAwCglpbnRjIDMgLy8gMzIKCWJveF9leHRyYWN0CglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCgljb25jYXQKCWZyYW1lX2J1cnkgMiAvLyBibG9ja3NLZXk6IEJsb2NrTGlzdEtleQoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjU3NQoJLy8gYXNzZXJ0KCF0aGlzLmJsb2NrcyhibG9ja3NLZXkpLmV4aXN0cywgZXJycy5CTE9DS0VEKQoJZnJhbWVfZGlnIDIgLy8gYmxvY2tzS2V5OiBCbG9ja0xpc3RLZXkKCWJveF9sZW4KCXN3YXAKCXBvcAoJIQoJYXNzZXJ0CgoJLy8gKmlmMTdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo1NzcKCS8vIGluZGV4ID4gMAoJZnJhbWVfZGlnIC0zIC8vIGluZGV4OiB1aW50NjQKCWludGMgMCAvLyAwCgk+CglieiAqaWYxN19lbmQKCgkvLyAqaWYxN19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo1NzgKCS8vIHNlcnZpY2VzS2V5OiBTZXJ2aWNlc0tleSA9IHsgdXNlcjogc3ViLnJlY2lwaWVudCwgaW5kZXg6IHN1Yi5pbmRleCB9CglmcmFtZV9kaWcgMCAvLyBzdWJzY3JpcHRpb25zS2V5OiBTdWJzY3JpcHRpb25LZXkKCWludGMgMCAvLyAwCglpbnRjIDMgLy8gMzIKCWJveF9leHRyYWN0CglmcmFtZV9kaWcgMCAvLyBzdWJzY3JpcHRpb25zS2V5OiBTdWJzY3JpcHRpb25LZXkKCWludGMgMyAvLyAgaGVhZE9mZnNldAoJaW50YyAyIC8vIDgKCWJveF9leHRyYWN0CglidG9pCglpdG9iCgljb25jYXQKCWZyYW1lX2J1cnkgMyAvLyBzZXJ2aWNlc0tleTogU2VydmljZXNLZXkKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo1ODAKCS8vIGFzc2VydCghdGhpcy5zZXJ2aWNlcyhzZXJ2aWNlc0tleSkudmFsdWUuYWN0aXZlLCBlcnJzLlNFUlZJQ0VfSVNfUEFVU0VEKQoJYnl0ZWMgMSAvLyAgInMiCglmcmFtZV9kaWcgMyAvLyBzZXJ2aWNlc0tleTogU2VydmljZXNLZXkKCWNvbmNhdAoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5zZXJ2aWNlcyhzZXJ2aWNlc0tleSkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWludGMgMSAvLyAxCglnZXRiaXQKCSEKCWFzc2VydAoKKmlmMTdfZW5kOgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTg0CgkvLyBhc3NlcnQoc3ViLmxhc3RQYXltZW50IDwgdGhpcy5nZXRMYXRlc3RXaW5kb3dTdGFydChzdWIuc3RhcnREYXRlLCBzdWIuaW50ZXJ2YWwpLCBlcnJzLkJBRF9XSU5ET1cpCglmcmFtZV9kaWcgMCAvLyBzdWJzY3JpcHRpb25zS2V5OiBTdWJzY3JpcHRpb25LZXkKCWludGMgNiAvLyAgaGVhZE9mZnNldAoJaW50YyAyIC8vIDgKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9kaWcgMCAvLyBzdWJzY3JpcHRpb25zS2V5OiBTdWJzY3JpcHRpb25LZXkKCWludGMgOSAvLyAgaGVhZE9mZnNldAoJaW50YyAyIC8vIDgKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9kaWcgMCAvLyBzdWJzY3JpcHRpb25zS2V5OiBTdWJzY3JpcHRpb25LZXkKCWludGMgNyAvLyAgaGVhZE9mZnNldAoJaW50YyAyIC8vIDgKCWJveF9leHRyYWN0CglidG9pCgljYWxsc3ViIGdldExhdGVzdFdpbmRvd1N0YXJ0Cgk8Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo1ODYKCS8vIGlzQXNhID0gc3ViLmFzc2V0LmlkICE9PSAwCglmcmFtZV9kaWcgMCAvLyBzdWJzY3JpcHRpb25zS2V5OiBTdWJzY3JpcHRpb25LZXkKCWludGMgNSAvLyAgaGVhZE9mZnNldAoJaW50YyAyIC8vIDgKCWJveF9leHRyYWN0CglidG9pCglpbnRjIDAgLy8gMAoJIT0KCWZyYW1lX2J1cnkgNCAvLyBpc0FzYTogYm9vbAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjU4OAoJLy8gYWtpdGFGZWUgPSAoc3ViLmFtb3VudCAqIDM1IC0gMSkgLyAxMDAwICsgMQoJZnJhbWVfZGlnIDAgLy8gc3Vic2NyaXB0aW9uc0tleTogU3Vic2NyaXB0aW9uS2V5CglpbnRjIDggLy8gIGhlYWRPZmZzZXQKCWludGMgMiAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJcHVzaGludCAzNQoJKgoJaW50YyAxIC8vIDEKCS0KCWludGMgMTIgLy8gMTAwMAoJLwoJaW50YyAxIC8vIDEKCSsKCWZyYW1lX2J1cnkgNSAvLyBha2l0YUZlZTogdWludDY0CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTg5CgkvLyB0cmlnZ2VyRmVlID0gKHN1Yi5hbW91bnQgKiA1IC0gMSkgLyAxMDAwICsgMQoJZnJhbWVfZGlnIDAgLy8gc3Vic2NyaXB0aW9uc0tleTogU3Vic2NyaXB0aW9uS2V5CglpbnRjIDggLy8gIGhlYWRPZmZzZXQKCWludGMgMiAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJaW50YyAxNSAvLyA1CgkqCglpbnRjIDEgLy8gMQoJLQoJaW50YyAxMiAvLyAxMDAwCgkvCglpbnRjIDEgLy8gMQoJKwoJZnJhbWVfYnVyeSA2IC8vIHRyaWdnZXJGZWU6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjU5MAoJLy8gbGVmdE92ZXIgPSBzdWIuYW1vdW50IC0gKGFraXRhRmVlICsgdHJpZ2dlckZlZSkKCWZyYW1lX2RpZyAwIC8vIHN1YnNjcmlwdGlvbnNLZXk6IFN1YnNjcmlwdGlvbktleQoJaW50YyA4IC8vICBoZWFkT2Zmc2V0CglpbnRjIDIgLy8gOAoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2RpZyA1IC8vIGFraXRhRmVlOiB1aW50NjQKCWZyYW1lX2RpZyA2IC8vIHRyaWdnZXJGZWU6IHVpbnQ2NAoJKwoJLQoJZnJhbWVfYnVyeSA3IC8vIGxlZnRPdmVyOiB1aW50NjQKCgkvLyAqaWYxOF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjU5MgoJLy8gaXNBc2EKCWZyYW1lX2RpZyA0IC8vIGlzQXNhOiBib29sCglieiAqaWYxOF9lbHNlCgoJLy8gKmlmMThfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTkzCgkvLyB0aGlzLnBlbmRpbmdHcm91cC5hZGRBc3NldFRyYW5zZmVyKHsKCS8vICAgICAgICAgc2VuZGVyOiBzZW5kZXIuYWRkcmVzcywKCS8vICAgICAgICAgYXNzZXRSZWNlaXZlcjogZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAoJLy8gICAgICAgICB4ZmVyQXNzZXQ6IHN1Yi5hc3NldCwKCS8vICAgICAgICAgYXNzZXRBbW91bnQ6IGFraXRhRmVlLAoJLy8gICAgICAgICBmZWU6IDAsCgkvLyAgICAgICB9KQoJaXR4bl9uZXh0CglpbnRjIDQgLy8gIGF4ZmVyCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTk0CgkvLyBzZW5kZXI6IHNlbmRlci5hZGRyZXNzCglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCglpdHhuX2ZpZWxkIFNlbmRlcgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjU5NQoJLy8gYXNzZXRSZWNlaXZlcjogZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NTk2CgkvLyB4ZmVyQXNzZXQ6IHN1Yi5hc3NldAoJZnJhbWVfZGlnIDAgLy8gc3Vic2NyaXB0aW9uc0tleTogU3Vic2NyaXB0aW9uS2V5CglpbnRjIDUgLy8gIGhlYWRPZmZzZXQKCWludGMgMiAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJaXR4bl9maWVsZCBYZmVyQXNzZXQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo1OTcKCS8vIGFzc2V0QW1vdW50OiBha2l0YUZlZQoJZnJhbWVfZGlnIDUgLy8gYWtpdGFGZWU6IHVpbnQ2NAoJaXR4bl9maWVsZCBBc3NldEFtb3VudAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjU5OAoJLy8gZmVlOiAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2MDEKCS8vIHRoaXMucGVuZGluZ0dyb3VwLmFkZEFzc2V0VHJhbnNmZXIoewoJLy8gICAgICAgICBzZW5kZXI6IHNlbmRlci5hZGRyZXNzLAoJLy8gICAgICAgICBhc3NldFJlY2VpdmVyOiB0aGlzLnR4bi5zZW5kZXIsCgkvLyAgICAgICAgIHhmZXJBc3NldDogc3ViLmFzc2V0LAoJLy8gICAgICAgICBhc3NldEFtb3VudDogdHJpZ2dlckZlZSwKCS8vICAgICAgICAgZmVlOiAwLAoJLy8gICAgICAgfSkKCWl0eG5fbmV4dAoJaW50YyA0IC8vICBheGZlcgoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjYwMgoJLy8gc2VuZGVyOiBzZW5kZXIuYWRkcmVzcwoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJaXR4bl9maWVsZCBTZW5kZXIKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2MDMKCS8vIGFzc2V0UmVjZWl2ZXI6IHRoaXMudHhuLnNlbmRlcgoJdHhuIFNlbmRlcgoJaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NjA0CgkvLyB4ZmVyQXNzZXQ6IHN1Yi5hc3NldAoJZnJhbWVfZGlnIDAgLy8gc3Vic2NyaXB0aW9uc0tleTogU3Vic2NyaXB0aW9uS2V5CglpbnRjIDUgLy8gIGhlYWRPZmZzZXQKCWludGMgMiAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJaXR4bl9maWVsZCBYZmVyQXNzZXQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2MDUKCS8vIGFzc2V0QW1vdW50OiB0cmlnZ2VyRmVlCglmcmFtZV9kaWcgNiAvLyB0cmlnZ2VyRmVlOiB1aW50NjQKCWl0eG5fZmllbGQgQXNzZXRBbW91bnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2MDYKCS8vIGZlZTogMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gKmlmMTlfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2MDkKCS8vIHJla2V5QmFjawoJZnJhbWVfZGlnIC0yIC8vIHJla2V5QmFjazogYm9vbGVhbgoJYnogKmlmMTlfZWxzZQoKCS8vICppZjE5X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjYxMAoJLy8gdGhpcy5wZW5kaW5nR3JvdXAuYWRkQXNzZXRUcmFuc2Zlcih7CgkvLyAgICAgICAgICAgc2VuZGVyOiBzZW5kZXIuYWRkcmVzcywKCS8vICAgICAgICAgICBhc3NldFJlY2VpdmVyOiBzdWIucmVjaXBpZW50LAoJLy8gICAgICAgICAgIHhmZXJBc3NldDogc3ViLmFzc2V0LAoJLy8gICAgICAgICAgIGFzc2V0QW1vdW50OiBsZWZ0T3ZlciwKCS8vICAgICAgICAgICByZWtleVRvOiBzZW5kZXIuYWRkcmVzcywKCS8vICAgICAgICAgICBmZWU6IDAsCgkvLyAgICAgICAgIH0pCglpdHhuX25leHQKCWludGMgNCAvLyAgYXhmZXIKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2MTEKCS8vIHNlbmRlcjogc2VuZGVyLmFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWl0eG5fZmllbGQgU2VuZGVyCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NjEyCgkvLyBhc3NldFJlY2VpdmVyOiBzdWIucmVjaXBpZW50CglmcmFtZV9kaWcgMCAvLyBzdWJzY3JpcHRpb25zS2V5OiBTdWJzY3JpcHRpb25LZXkKCWludGMgMCAvLyAwCglpbnRjIDMgLy8gMzIKCWJveF9leHRyYWN0CglpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2MTMKCS8vIHhmZXJBc3NldDogc3ViLmFzc2V0CglmcmFtZV9kaWcgMCAvLyBzdWJzY3JpcHRpb25zS2V5OiBTdWJzY3JpcHRpb25LZXkKCWludGMgNSAvLyAgaGVhZE9mZnNldAoJaW50YyAyIC8vIDgKCWJveF9leHRyYWN0CglidG9pCglpdHhuX2ZpZWxkIFhmZXJBc3NldAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjYxNAoJLy8gYXNzZXRBbW91bnQ6IGxlZnRPdmVyCglmcmFtZV9kaWcgNyAvLyBsZWZ0T3ZlcjogdWludDY0CglpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NjE1CgkvLyByZWtleVRvOiBzZW5kZXIuYWRkcmVzcwoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJaXR4bl9maWVsZCBSZWtleVRvCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NjE2CgkvLyBmZWU6IDAKCWludGMgMCAvLyAwCglpdHhuX2ZpZWxkIEZlZQoJYiAqaWYxOV9lbmQKCippZjE5X2Vsc2U6CgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2MTkKCS8vIHRoaXMucGVuZGluZ0dyb3VwLmFkZEFzc2V0VHJhbnNmZXIoewoJLy8gICAgICAgICAgIHNlbmRlcjogc2VuZGVyLmFkZHJlc3MsCgkvLyAgICAgICAgICAgYXNzZXRSZWNlaXZlcjogc3ViLnJlY2lwaWVudCwKCS8vICAgICAgICAgICB4ZmVyQXNzZXQ6IHN1Yi5hc3NldCwKCS8vICAgICAgICAgICBhc3NldEFtb3VudDogbGVmdE92ZXIsCgkvLyAgICAgICAgICAgZmVlOiAwLAoJLy8gICAgICAgICB9KQoJaXR4bl9uZXh0CglpbnRjIDQgLy8gIGF4ZmVyCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NjIwCgkvLyBzZW5kZXI6IHNlbmRlci5hZGRyZXNzCglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCglpdHhuX2ZpZWxkIFNlbmRlcgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjYyMQoJLy8gYXNzZXRSZWNlaXZlcjogc3ViLnJlY2lwaWVudAoJZnJhbWVfZGlnIDAgLy8gc3Vic2NyaXB0aW9uc0tleTogU3Vic2NyaXB0aW9uS2V5CglpbnRjIDAgLy8gMAoJaW50YyAzIC8vIDMyCglib3hfZXh0cmFjdAoJaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NjIyCgkvLyB4ZmVyQXNzZXQ6IHN1Yi5hc3NldAoJZnJhbWVfZGlnIDAgLy8gc3Vic2NyaXB0aW9uc0tleTogU3Vic2NyaXB0aW9uS2V5CglpbnRjIDUgLy8gIGhlYWRPZmZzZXQKCWludGMgMiAvLyA4Cglib3hfZXh0cmFjdAoJYnRvaQoJaXR4bl9maWVsZCBYZmVyQXNzZXQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2MjMKCS8vIGFzc2V0QW1vdW50OiBsZWZ0T3ZlcgoJZnJhbWVfZGlnIDcgLy8gbGVmdE92ZXI6IHVpbnQ2NAoJaXR4bl9maWVsZCBBc3NldEFtb3VudAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjYyNAoJLy8gZmVlOiAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCippZjE5X2VuZDoKCWIgKmlmMThfZW5kCgoqaWYxOF9lbHNlOgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NjI5CgkvLyB0aGlzLnBlbmRpbmdHcm91cC5hZGRQYXltZW50KHsKCS8vICAgICAgICAgc2VuZGVyOiBzZW5kZXIuYWRkcmVzcywKCS8vICAgICAgICAgcmVjZWl2ZXI6IGdsb2JhbHMuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKCS8vICAgICAgICAgYW1vdW50OiBha2l0YUZlZSwKCS8vICAgICAgICAgZmVlOiAwLAoJLy8gICAgICAgfSkKCWl0eG5fbmV4dAoJaW50YyAxIC8vICBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2MzAKCS8vIHNlbmRlcjogc2VuZGVyLmFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWl0eG5fZmllbGQgU2VuZGVyCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NjMxCgkvLyByZWNlaXZlcjogZ2xvYmFscy5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjYzMgoJLy8gYW1vdW50OiBha2l0YUZlZQoJZnJhbWVfZGlnIDUgLy8gYWtpdGFGZWU6IHVpbnQ2NAoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2MzMKCS8vIGZlZTogMAoJaW50YyAwIC8vIDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NjM2CgkvLyB0aGlzLnBlbmRpbmdHcm91cC5hZGRQYXltZW50KHsKCS8vICAgICAgICAgc2VuZGVyOiBzZW5kZXIuYWRkcmVzcywKCS8vICAgICAgICAgcmVjZWl2ZXI6IHRoaXMudHhuLnNlbmRlciwKCS8vICAgICAgICAgYW1vdW50OiB0cmlnZ2VyRmVlLAoJLy8gICAgICAgICBmZWU6IDAsCgkvLyAgICAgICB9KQoJaXR4bl9uZXh0CglpbnRjIDEgLy8gIHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjYzNwoJLy8gc2VuZGVyOiBzZW5kZXIuYWRkcmVzcwoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJaXR4bl9maWVsZCBTZW5kZXIKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2MzgKCS8vIHJlY2VpdmVyOiB0aGlzLnR4bi5zZW5kZXIKCXR4biBTZW5kZXIKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2MzkKCS8vIGFtb3VudDogdHJpZ2dlckZlZQoJZnJhbWVfZGlnIDYgLy8gdHJpZ2dlckZlZTogdWludDY0CglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjY0MAoJLy8gZmVlOiAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCgkvLyAqaWYyMF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjY0MwoJLy8gcmVrZXlCYWNrCglmcmFtZV9kaWcgLTIgLy8gcmVrZXlCYWNrOiBib29sZWFuCglieiAqaWYyMF9lbHNlCgoJLy8gKmlmMjBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NjQ0CgkvLyB0aGlzLnBlbmRpbmdHcm91cC5hZGRQYXltZW50KHsKCS8vICAgICAgICAgICBzZW5kZXI6IHNlbmRlci5hZGRyZXNzLAoJLy8gICAgICAgICAgIHJlY2VpdmVyOiBzdWIucmVjaXBpZW50LAoJLy8gICAgICAgICAgIGFtb3VudDogbGVmdE92ZXIsCgkvLyAgICAgICAgICAgcmVrZXlUbzogc2VuZGVyLmFkZHJlc3MsCgkvLyAgICAgICAgICAgZmVlOiAwLAoJLy8gICAgICAgICB9KQoJaXR4bl9uZXh0CglpbnRjIDEgLy8gIHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjY0NQoJLy8gc2VuZGVyOiBzZW5kZXIuYWRkcmVzcwoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJaXR4bl9maWVsZCBTZW5kZXIKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2NDYKCS8vIHJlY2VpdmVyOiBzdWIucmVjaXBpZW50CglmcmFtZV9kaWcgMCAvLyBzdWJzY3JpcHRpb25zS2V5OiBTdWJzY3JpcHRpb25LZXkKCWludGMgMCAvLyAwCglpbnRjIDMgLy8gMzIKCWJveF9leHRyYWN0CglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NjQ3CgkvLyBhbW91bnQ6IGxlZnRPdmVyCglmcmFtZV9kaWcgNyAvLyBsZWZ0T3ZlcjogdWludDY0CglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjY0OAoJLy8gcmVrZXlUbzogc2VuZGVyLmFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWl0eG5fZmllbGQgUmVrZXlUbwoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjY0OQoJLy8gZmVlOiAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCWIgKmlmMjBfZW5kCgoqaWYyMF9lbHNlOgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NjUyCgkvLyB0aGlzLnBlbmRpbmdHcm91cC5hZGRQYXltZW50KHsKCS8vICAgICAgICAgICBzZW5kZXI6IHNlbmRlci5hZGRyZXNzLAoJLy8gICAgICAgICAgIHJlY2VpdmVyOiBzdWIucmVjaXBpZW50LAoJLy8gICAgICAgICAgIGFtb3VudDogbGVmdE92ZXIsCgkvLyAgICAgICAgICAgZmVlOiAwLAoJLy8gICAgICAgICB9KQoJaXR4bl9uZXh0CglpbnRjIDEgLy8gIHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjY1MwoJLy8gc2VuZGVyOiBzZW5kZXIuYWRkcmVzcwoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJaXR4bl9maWVsZCBTZW5kZXIKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2NTQKCS8vIHJlY2VpdmVyOiBzdWIucmVjaXBpZW50CglmcmFtZV9kaWcgMCAvLyBzdWJzY3JpcHRpb25zS2V5OiBTdWJzY3JpcHRpb25LZXkKCWludGMgMCAvLyAwCglpbnRjIDMgLy8gMzIKCWJveF9leHRyYWN0CglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NjU1CgkvLyBhbW91bnQ6IGxlZnRPdmVyCglmcmFtZV9kaWcgNyAvLyBsZWZ0T3ZlcjogdWludDY0CglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjY1NgoJLy8gZmVlOiAwCglpbnRjIDAgLy8gMAoJaXR4bl9maWVsZCBGZWUKCippZjIwX2VuZDoKCippZjE4X2VuZDoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjY2MQoJLy8gdGhpcy5wZW5kaW5nR3JvdXAuc3VibWl0KCkKCWl0eG5fc3VibWl0CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NjYyCgkvLyB0aGlzLnVwZGF0ZVN0cmVhayhzZW5kZXIuYWRkcmVzcywgaW5kZXgsIDEpCglpbnRjIDEgLy8gMQoJZnJhbWVfZGlnIC0zIC8vIGluZGV4OiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyBzZW5kZXI6IEFwcElECglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCWNhbGxzdWIgdXBkYXRlU3RyZWFrCgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6NjYzCgkvLyB0aGlzLnN1YnNjcmlwdGlvbnMoc3Vic2NyaXB0aW9uc0tleSkudmFsdWUubGFzdFBheW1lbnQgPSBnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcAoJaW50YyA2IC8vICBoZWFkT2Zmc2V0CglnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCglpdG9iCglmcmFtZV9kaWcgMCAvLyBzdWJzY3JpcHRpb25zS2V5OiBTdWJzY3JpcHRpb25LZXkKCWNvdmVyIDIKCWJveF9yZXBsYWNlCglyZXRzdWIKCi8vIHN0cmVha0NoZWNrKGFkZHJlc3MsdWludDY0KXZvaWQKKmFiaV9yb3V0ZV9zdHJlYWtDaGVjazoKCS8vIGluZGV4OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBzZW5kZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnRjIDMgLy8gMzIKCT09CgoJLy8gYXJndW1lbnQgMSAoc2VuZGVyKSBmb3Igc3RyZWFrQ2hlY2sgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIGV4ZWN1dGUgc3RyZWFrQ2hlY2soYWRkcmVzcyx1aW50NjQpdm9pZAoJY2FsbHN1YiBzdHJlYWtDaGVjawoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gc3RyZWFrQ2hlY2soc2VuZGVyOiBBZGRyZXNzLCBpbmRleDogdWludDY0KTogdm9pZApzdHJlYWtDaGVjazoKCXByb3RvIDIgMAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjY2NwoJLy8gdGhpcy51cGRhdGVTdHJlYWsoc2VuZGVyLCBpbmRleCwgMCkKCWludGMgMCAvLyAwCglmcmFtZV9kaWcgLTIgLy8gaW5kZXg6IHVpbnQ2NAoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQWRkcmVzcwoJY2FsbHN1YiB1cGRhdGVTdHJlYWsKCXJldHN1YgoKLy8gc2V0UGFzc2VzKHVpbnQ2NCxib29sLHVpbnQ2NCxhZGRyZXNzW10pdm9pZAoqYWJpX3JvdXRlX3NldFBhc3NlczoKCS8vIGFkZHJlc3NlczogYWRkcmVzc1tdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyA0CglleHRyYWN0IDIgMAoKCS8vIGluZGV4OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWJ0b2kKCgkvLyByZWtleUJhY2s6IGJvb2wKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnRjIDEgLy8gMQoJPT0KCgkvLyBhcmd1bWVudCAyIChyZWtleUJhY2spIGZvciBzZXRQYXNzZXMgbXVzdCBiZSBhIGJvb2wKCWFzc2VydAoJaW50YyAwIC8vIDAKCWdldGJpdAoKCS8vIHNlbmRlcjogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBzZXRQYXNzZXModWludDY0LGJvb2wsdWludDY0LGFkZHJlc3NbXSl2b2lkCgljYWxsc3ViIHNldFBhc3NlcwoJaW50YyAxIC8vIDEKCXJldHVybgoKLy8gc2V0UGFzc2VzKHNlbmRlcjogQXBwSUQsIHJla2V5QmFjazogYm9vbGVhbiwgaW5kZXg6IHVpbnQ2NCwgYWRkcmVzc2VzOiBBZGRyZXNzW10pOiB2b2lkCnNldFBhc3NlczoKCXByb3RvIDQgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlYyAwIC8vIDB4CglkdXBuIDQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2NzEKCS8vIGFzc2VydChpbmRleCA+IDAsIGVycnMuTk9fRE9OQVRJT05TKQoJZnJhbWVfZGlnIC0zIC8vIGluZGV4OiB1aW50NjQKCWludGMgMCAvLyAwCgk+Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2NzIKCS8vIHN1YnNjcmlwdGlvbnNLZXk6IFN1YnNjcmlwdGlvbktleSA9IHsgdXNlcjogc2VuZGVyLmFkZHJlc3MsIGluZGV4OiBpbmRleCB9CglmcmFtZV9kaWcgLTEgLy8gc2VuZGVyOiBBcHBJRAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCglmcmFtZV9kaWcgLTMgLy8gaW5kZXg6IHVpbnQ2NAoJaXRvYgoJY29uY2F0CglmcmFtZV9idXJ5IDAgLy8gc3Vic2NyaXB0aW9uc0tleTogU3Vic2NyaXB0aW9uS2V5CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6Njc0CgkvLyBhc3NlcnQodGhpcy5zdWJzY3JpcHRpb25zKHN1YnNjcmlwdGlvbnNLZXkpLmV4aXN0cywgZXJycy5TVUJTQ1JJUFRJT05fRE9FU19OT1RfRVhJU1QpCglmcmFtZV9kaWcgMCAvLyBzdWJzY3JpcHRpb25zS2V5OiBTdWJzY3JpcHRpb25LZXkKCWJveF9sZW4KCXN3YXAKCXBvcAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6Njc2CgkvLyBzdWIgPSB0aGlzLnN1YnNjcmlwdGlvbnMoc3Vic2NyaXB0aW9uc0tleSkudmFsdWUKCWZyYW1lX2RpZyAwIC8vIHN1YnNjcmlwdGlvbnNLZXk6IFN1YnNjcmlwdGlvbktleQoJZnJhbWVfYnVyeSAxIC8vIHN0b3JhZ2Uga2V5Ly9zdWIKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2NzgKCS8vIHNlcnZpY2VLZXk6IFNlcnZpY2VzS2V5ID0geyB1c2VyOiBzdWIucmVjaXBpZW50LCBpbmRleDogaW5kZXggfQoJZnJhbWVfZGlnIDAgLy8gc3Vic2NyaXB0aW9uc0tleTogU3Vic2NyaXB0aW9uS2V5CglpbnRjIDAgLy8gMAoJaW50YyAzIC8vIDMyCglib3hfZXh0cmFjdAoJZnJhbWVfZGlnIC0zIC8vIGluZGV4OiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJZnJhbWVfYnVyeSAyIC8vIHNlcnZpY2VLZXk6IFNlcnZpY2VzS2V5CgoJLy8gY29udHJhY3RzL2FyYzU4L3BsdWdpbnMvc3Vic2NyaXB0aW9uLmFsZ28udHM6Njc5CgkvLyBzZXJ2aWNlID0gdGhpcy5zZXJ2aWNlcyhzZXJ2aWNlS2V5KS52YWx1ZQoJYnl0ZWMgMSAvLyAgInMiCglmcmFtZV9kaWcgMiAvLyBzZXJ2aWNlS2V5OiBTZXJ2aWNlc0tleQoJY29uY2F0CglmcmFtZV9idXJ5IDMgLy8gc3RvcmFnZSBrZXkvL3NlcnZpY2UKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2ODEKCS8vIGFzc2VydChzZXJ2aWNlLmFjdGl2ZSwgZXJycy5TRVJWSUNFX0lTX1BBVVNFRCkKCWZyYW1lX2RpZyAzIC8vIHN0b3JhZ2Uga2V5Ly9zZXJ2aWNlCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnNlcnZpY2VzKHNlcnZpY2VLZXkpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnRjIDEgLy8gMQoJZ2V0Yml0Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2ODIKCS8vIGFzc2VydCghc2VydmljZS5zaHV0ZG93biwgZXJycy5TRVJWSUNFX0lTX1NIVVRET1dOKQoJZnJhbWVfZGlnIDMgLy8gc3RvcmFnZSBrZXkvL3NlcnZpY2UKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuc2VydmljZXMoc2VydmljZUtleSkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWludGMgMCAvLyAwCglnZXRiaXQKCSEKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjY4MwoJLy8gYXNzZXJ0KHNlcnZpY2UucGFzc2VzID49IGFkZHJlc3Nlcy5sZW5ndGgsIGVycnMuUEFTU19DT1VOVF9PVkVSRkxPVykKCWZyYW1lX2RpZyAzIC8vIHN0b3JhZ2Uga2V5Ly9zZXJ2aWNlCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnNlcnZpY2VzKHNlcnZpY2VLZXkpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDI1IDgKCWJ0b2kKCWZyYW1lX2RpZyAtNCAvLyBhZGRyZXNzZXM6IEFkZHJlc3NbXQoJbGVuCglpbnRjIDMgLy8gMzIKCS8KCT49Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2ODUKCS8vIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkcmVzc2VzLmxlbmd0aDsgaSArPSAxKQoJaW50YyAwIC8vIDAKCWZyYW1lX2J1cnkgNCAvLyBpOiB1aW50NjQKCipmb3JfMDoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjY4NQoJLy8gaSA8IGFkZHJlc3Nlcy5sZW5ndGgKCWZyYW1lX2RpZyA0IC8vIGk6IHVpbnQ2NAoJZnJhbWVfZGlnIC00IC8vIGFkZHJlc3NlczogQWRkcmVzc1tdCglsZW4KCWludGMgMyAvLyAzMgoJLwoJPAoJYnogKmZvcl8wX2VuZAoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjY4NgoJLy8gYXNzZXJ0KCF0aGlzLmJsb2Nrcyh7IHVzZXI6IHN1Yi5yZWNpcGllbnQsIGJsb2NrZWQ6IGFkZHJlc3Nlc1tpXSB9KS5leGlzdHMsIGVycnMuQkxPQ0tFRCkKCWZyYW1lX2RpZyAwIC8vIHN1YnNjcmlwdGlvbnNLZXk6IFN1YnNjcmlwdGlvbktleQoJaW50YyAwIC8vIDAKCWludGMgMyAvLyAzMgoJYm94X2V4dHJhY3QKCWZyYW1lX2RpZyAtNCAvLyBhZGRyZXNzZXM6IEFkZHJlc3NbXQoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWludGMgMCAvLyAgaW5pdGlhbCBvZmZzZXQKCWZyYW1lX2RpZyA0IC8vIGk6IHVpbnQ2NAoJaW50YyAzIC8vIDMyCgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCXN3YXAKCWludGMgMyAvLyAzMgoJZXh0cmFjdDMKCWNvbmNhdAoJYm94X2xlbgoJc3dhcAoJcG9wCgkhCglhc3NlcnQKCipmb3JfMF9jb250aW51ZToKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjY4NQoJLy8gaSArPSAxCglmcmFtZV9kaWcgNCAvLyBpOiB1aW50NjQKCWludGMgMSAvLyAxCgkrCglmcmFtZV9idXJ5IDQgLy8gaTogdWludDY0CgliICpmb3JfMAoKKmZvcl8wX2VuZDoKCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjY4OQoJLy8gdGhpcy5wYXNzZXMoc3Vic2NyaXB0aW9uc0tleSkudmFsdWUgPSBhZGRyZXNzZXMKCWJ5dGVjIDUgLy8gICJwIgoJZnJhbWVfZGlnIDAgLy8gc3Vic2NyaXB0aW9uc0tleTogU3Vic2NyaXB0aW9uS2V5Cgljb25jYXQKCWR1cAoJYm94X2RlbAoJcG9wCglmcmFtZV9kaWcgLTQgLy8gYWRkcmVzc2VzOiBBZGRyZXNzW10KCWR1cAoJbGVuCglpbnRjIDMgLy8gMzIKCS8KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWJveF9wdXQKCgkvLyAqaWYyMV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9hcmM1OC9wbHVnaW5zL3N1YnNjcmlwdGlvbi5hbGdvLnRzOjY5MQoJLy8gcmVrZXlCYWNrCglmcmFtZV9kaWcgLTIgLy8gcmVrZXlCYWNrOiBib29sZWFuCglieiAqaWYyMV9lbmQKCgkvLyAqaWYyMV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvYXJjNTgvcGx1Z2lucy9zdWJzY3JpcHRpb24uYWxnby50czo2OTIKCS8vIHRoaXMucmVrZXlCYWNrKHNlbmRlci5hZGRyZXNzKQoJZnJhbWVfZGlnIC0xIC8vIHNlbmRlcjogQXBwSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJY2FsbHN1YiByZWtleUJhY2sKCippZjIxX2VuZDoKCXJldHN1YgoKKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbjoKCWludGMgMSAvLyAxCglyZXR1cm4KCipjcmVhdGVfTm9PcDoKCXB1c2hieXRlcyAweGI4NDQ3YjM2IC8vIG1ldGhvZCAiY3JlYXRlQXBwbGljYXRpb24oKXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2NyZWF0ZUFwcGxpY2F0aW9uCgoJLy8gdGhpcyBjb250cmFjdCBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIGdpdmVuIEFCSSBtZXRob2QgZm9yIGNyZWF0ZSBOb09wCgllcnIKCipjYWxsX05vT3A6CglwdXNoYnl0ZXMgMHhkZWRmOTlmZCAvLyBtZXRob2QgImdldFN1YnNyaXB0aW9uSW5mbyhhZGRyZXNzLHVpbnQ2NCkoYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzc1tdKSIKCXB1c2hieXRlcyAweGQyNDgzODg0IC8vIG1ldGhvZCAibmV3U2VydmljZSh1aW50NjQsYm9vbCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsYnl0ZVs1OV0sYm9vbCl1aW50NjQiCglwdXNoYnl0ZXMgMHgzOWEzYWU0NyAvLyBtZXRob2QgInBhdXNlU2VydmljZSh1aW50NjQsYm9vbCx1aW50NjQpdm9pZCIKCXB1c2hieXRlcyAweDdjODhkZThmIC8vIG1ldGhvZCAiYWN0aXZhdGVTZXJ2aWNlKHVpbnQ2NCxib29sLHVpbnQ2NCl2b2lkIgoJcHVzaGJ5dGVzIDB4MTliMWZjMmIgLy8gbWV0aG9kICJzaHV0ZG93blNlcnZpY2UodWludDY0LGJvb2wsdWludDY0KXZvaWQiCglwdXNoYnl0ZXMgMHgwZDZhNDdhMyAvLyBtZXRob2QgImlzU2h1dGRvd24oYWRkcmVzcyx1aW50NjQpYm9vbCIKCXB1c2hieXRlcyAweGJlYzg2YzM0IC8vIG1ldGhvZCAiYmxvY2sodWludDY0LGJvb2wsYWRkcmVzcyl2b2lkIgoJcHVzaGJ5dGVzIDB4OWY1OWE5NzAgLy8gbWV0aG9kICJ1bmJsb2NrKHVpbnQ2NCxib29sLGFkZHJlc3Mpdm9pZCIKCXB1c2hieXRlcyAweDQzMDM2NjhlIC8vIG1ldGhvZCAiaXNCbG9ja2VkKGFkZHJlc3MsYWRkcmVzcylib29sIgoJcHVzaGJ5dGVzIDB4ZWU4MTFhNzYgLy8gbWV0aG9kICJzdWJzY3JpYmUodWludDY0LGJvb2wsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZCIKCXB1c2hieXRlcyAweDAxNzE1MzExIC8vIG1ldGhvZCAidHJpZ2dlclBheW1lbnQodWludDY0LGJvb2wsdWludDY0KXZvaWQiCglwdXNoYnl0ZXMgMHhhZGIyYzYwZSAvLyBtZXRob2QgInN0cmVha0NoZWNrKGFkZHJlc3MsdWludDY0KXZvaWQiCglwdXNoYnl0ZXMgMHgxYzQyNDYxYiAvLyBtZXRob2QgInNldFBhc3Nlcyh1aW50NjQsYm9vbCx1aW50NjQsYWRkcmVzc1tdKXZvaWQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2dldFN1YnNyaXB0aW9uSW5mbyAqYWJpX3JvdXRlX25ld1NlcnZpY2UgKmFiaV9yb3V0ZV9wYXVzZVNlcnZpY2UgKmFiaV9yb3V0ZV9hY3RpdmF0ZVNlcnZpY2UgKmFiaV9yb3V0ZV9zaHV0ZG93blNlcnZpY2UgKmFiaV9yb3V0ZV9pc1NodXRkb3duICphYmlfcm91dGVfYmxvY2sgKmFiaV9yb3V0ZV91bmJsb2NrICphYmlfcm91dGVfaXNCbG9ja2VkICphYmlfcm91dGVfc3Vic2NyaWJlICphYmlfcm91dGVfdHJpZ2dlclBheW1lbnQgKmFiaV9yb3V0ZV9zdHJlYWtDaGVjayAqYWJpX3JvdXRlX3NldFBhc3NlcwoKCS8vIHRoaXMgY29udHJhY3QgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBnaXZlbiBBQkkgbWV0aG9kIGZvciBjYWxsIE5vT3AKCWVycgoKKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQ6Cglwcm90byA0IDMKCWZyYW1lX2RpZyAtNCAvLyB0dXBsZSBoZWFkCglmcmFtZV9kaWcgLTEgLy8gZWxlbWVudAoJY29uY2F0CglmcmFtZV9kaWcgLTMgLy8gdHVwbGUgdGFpbAoJZnJhbWVfZGlnIC0yIC8vIGhlYWQgb2Zmc2V0CglyZXRzdWIKCipwcm9jZXNzX2R5bmFtaWNfdHVwbGVfZWxlbWVudDoKCXByb3RvIDQgMwoJZnJhbWVfZGlnIC00IC8vIHR1cGxlIGhlYWQKCWZyYW1lX2RpZyAtMiAvLyBoZWFkIG9mZnNldAoJY29uY2F0CglmcmFtZV9idXJ5IC00IC8vIHR1cGxlIGhlYWQKCWZyYW1lX2RpZyAtMSAvLyBlbGVtZW50CglkdXAKCWxlbgoJZnJhbWVfZGlnIC0yIC8vIGhlYWQgb2Zmc2V0CglidG9pCgkrCglpdG9iCglleHRyYWN0IDYgMgoJZnJhbWVfYnVyeSAtMiAvLyBoZWFkIG9mZnNldAoJZnJhbWVfZGlnIC0zIC8vIHR1cGxlIHRhaWwKCXN3YXAKCWNvbmNhdAoJZnJhbWVfYnVyeSAtMyAvLyB0dXBsZSB0YWlsCglmcmFtZV9kaWcgLTQgLy8gdHVwbGUgaGVhZAoJZnJhbWVfZGlnIC0zIC8vIHR1cGxlIHRhaWwKCWZyYW1lX2RpZyAtMiAvLyBoZWFkIG9mZnNldAoJcmV0c3Vi",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw"
  },
  "contract": {
    "name": "SubscriptionPlugin",
    "desc": "",
    "methods": [
      {
        "name": "getSubsriptionInfo",
        "args": [
          {
            "name": "user",
            "type": "address"
          },
          {
            "name": "index",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])"
        }
      },
      {
        "name": "newService",
        "desc": "newService creates a new service for a merchant",
        "args": [
          {
            "name": "sender",
            "type": "uint64",
            "desc": "The address the plugin currently controls"
          },
          {
            "name": "rekeyBack",
            "type": "bool",
            "desc": "Indicates whether the user wants to rekey back after the transaction"
          },
          {
            "name": "interval",
            "type": "uint64",
            "desc": "The interval in seconds"
          },
          {
            "name": "asset",
            "type": "uint64",
            "desc": "The asa to be used for the subscription"
          },
          {
            "name": "amount",
            "type": "uint64",
            "desc": "The amount of the asa to be used for the subscription"
          },
          {
            "name": "passes",
            "type": "uint64",
            "desc": "The number of accounts the subscription can be shared with"
          },
          {
            "name": "cid",
            "type": "byte[59]",
            "desc": "The ipfs cid of the subscription contract"
          },
          {
            "name": "allowTraversal",
            "type": "bool",
            "desc": "Indicates whether the user can downgrade\nor upgrade the subscription to a different service from the user without losing their streak"
          }
        ],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "pauseService",
        "desc": "pauseService pauses a service for a merchant\nit does not shutdown pre-existing subscriptions\nit simply prevents new subscriptions from being created\nfor a specific service",
        "args": [
          {
            "name": "sender",
            "type": "uint64",
            "desc": "The address the plugin currently controls"
          },
          {
            "name": "rekeyBack",
            "type": "bool"
          },
          {
            "name": "index",
            "type": "uint64",
            "desc": "The index of the box to be used for the subscription"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "activateService",
        "desc": "activateService activates an service for a merchant",
        "args": [
          {
            "name": "sender",
            "type": "uint64",
            "desc": "The address the plugin currently controls"
          },
          {
            "name": "rekeyBack",
            "type": "bool",
            "desc": "Indicates whether the user wants to rekey back after the transaction"
          },
          {
            "name": "index",
            "type": "uint64",
            "desc": "The index of the box to be used for the subscription"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "shutdownService",
        "desc": "shutdownService permanently shuts down an service for a merchant\nit also shutsdown pre-existing subscriptions",
        "args": [
          {
            "name": "sender",
            "type": "uint64",
            "desc": "The address the plugin currently controls"
          },
          {
            "name": "rekeyBack",
            "type": "bool"
          },
          {
            "name": "index",
            "type": "uint64",
            "desc": "The index of the box to be used for the subscription"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "isShutdown",
        "desc": "serviceIsActive checks if an service is shutdown",
        "readonly": true,
        "args": [
          {
            "name": "merchant",
            "type": "address"
          },
          {
            "name": "boxIndex",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "bool"
        }
      },
      {
        "name": "block",
        "desc": "block blacklists an address for a merchant",
        "args": [
          {
            "name": "sender",
            "type": "uint64",
            "desc": "The address the plugin currently controls"
          },
          {
            "name": "rekeyBack",
            "type": "bool"
          },
          {
            "name": "address",
            "type": "address",
            "desc": "The address to be blocked"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "unblock",
        "desc": "unblock removes an address from a merchants blocks",
        "args": [
          {
            "name": "sender",
            "type": "uint64"
          },
          {
            "name": "rekeyBack",
            "type": "bool"
          },
          {
            "name": "address",
            "type": "address",
            "desc": "The address to be unblocked"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "isBlocked",
        "desc": "isBlocked checks if an address is blocked for a merchant",
        "readonly": true,
        "args": [
          {
            "name": "merchant",
            "type": "address",
            "desc": "The merchant address to be checked"
          },
          {
            "name": "address",
            "type": "address",
            "desc": "The address to be checked"
          }
        ],
        "returns": {
          "type": "bool"
        }
      },
      {
        "name": "subscribe",
        "args": [
          {
            "name": "sender",
            "type": "uint64"
          },
          {
            "name": "rekeyBack",
            "type": "bool"
          },
          {
            "name": "recipient",
            "type": "address"
          },
          {
            "name": "index",
            "type": "uint64"
          },
          {
            "name": "amount",
            "type": "uint64"
          },
          {
            "name": "interval",
            "type": "uint64"
          },
          {
            "name": "asset",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "triggerPayment",
        "args": [
          {
            "name": "sender",
            "type": "uint64"
          },
          {
            "name": "rekeyBack",
            "type": "bool"
          },
          {
            "name": "index",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "streakCheck",
        "args": [
          {
            "name": "sender",
            "type": "address"
          },
          {
            "name": "index",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "setPasses",
        "args": [
          {
            "name": "sender",
            "type": "uint64"
          },
          {
            "name": "rekeyBack",
            "type": "bool"
          },
          {
            "name": "index",
            "type": "uint64"
          },
          {
            "name": "addresses",
            "type": "address[]"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "createApplication",
        "args": [],
        "returns": {
          "type": "void"
        }
      }
    ]
  }
}

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt.
   */
  asBigInt(): bigint
  /**
   * Gets the state value as a number.
   */
  asNumber(): number
}
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array
  /**
   * Gets the state value as a string
   */
  asString(): string
}

export type AppCreateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult> & AppReference
export type AppUpdateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult>

export type AppClientComposeCallCoreParams = Omit<AppClientCallCoreParams, 'sendParams'> & {
  sendParams?: Omit<SendTransactionParams, 'skipSending' | 'atc' | 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources'>
}
export type AppClientComposeExecuteParams = Pick<SendTransactionParams, 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources' | 'suppressLog'>

/**
 * Defines the types of available calls and state of the SubscriptionPlugin smart contract.
 */
export type SubscriptionPlugin = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])' | 'getSubsriptionInfo', {
      argsObj: {
        user: string
        index: bigint | number
      }
      argsTuple: [user: string, index: bigint | number]
      returns: [string, bigint, bigint, bigint, bigint, bigint, bigint, bigint, string[]]
    }>
    & Record<'newService(uint64,bool,uint64,uint64,uint64,uint64,byte[59],bool)uint64' | 'newService', {
      argsObj: {
        /**
         * The address the plugin currently controls
         */
        sender: bigint | number
        /**
         * Indicates whether the user wants to rekey back after the transaction
         */
        rekeyBack: boolean
        /**
         * The interval in seconds
         */
        interval: bigint | number
        /**
         * The asa to be used for the subscription
         */
        asset: bigint | number
        /**
         * The amount of the asa to be used for the subscription
         */
        amount: bigint | number
        /**
         * The number of accounts the subscription can be shared with
         */
        passes: bigint | number
        /**
         * The ipfs cid of the subscription contract
         */
        cid: Uint8Array
        /**
         * Indicates whether the user can downgrade
or upgrade the subscription to a different service from the user without losing their streak
         */
        allowTraversal: boolean
      }
      argsTuple: [sender: bigint | number, rekeyBack: boolean, interval: bigint | number, asset: bigint | number, amount: bigint | number, passes: bigint | number, cid: Uint8Array, allowTraversal: boolean]
      returns: bigint
    }>
    & Record<'pauseService(uint64,bool,uint64)void' | 'pauseService', {
      argsObj: {
        /**
         * The address the plugin currently controls
         */
        sender: bigint | number
        rekeyBack: boolean
        /**
         * The index of the box to be used for the subscription
         */
        index: bigint | number
      }
      argsTuple: [sender: bigint | number, rekeyBack: boolean, index: bigint | number]
      returns: void
    }>
    & Record<'activateService(uint64,bool,uint64)void' | 'activateService', {
      argsObj: {
        /**
         * The address the plugin currently controls
         */
        sender: bigint | number
        /**
         * Indicates whether the user wants to rekey back after the transaction
         */
        rekeyBack: boolean
        /**
         * The index of the box to be used for the subscription
         */
        index: bigint | number
      }
      argsTuple: [sender: bigint | number, rekeyBack: boolean, index: bigint | number]
      returns: void
    }>
    & Record<'shutdownService(uint64,bool,uint64)void' | 'shutdownService', {
      argsObj: {
        /**
         * The address the plugin currently controls
         */
        sender: bigint | number
        rekeyBack: boolean
        /**
         * The index of the box to be used for the subscription
         */
        index: bigint | number
      }
      argsTuple: [sender: bigint | number, rekeyBack: boolean, index: bigint | number]
      returns: void
    }>
    & Record<'isShutdown(address,uint64)bool' | 'isShutdown', {
      argsObj: {
        merchant: string
        boxIndex: bigint | number
      }
      argsTuple: [merchant: string, boxIndex: bigint | number]
      returns: boolean
    }>
    & Record<'block(uint64,bool,address)void' | 'block', {
      argsObj: {
        /**
         * The address the plugin currently controls
         */
        sender: bigint | number
        rekeyBack: boolean
        /**
         * The address to be blocked
         */
        address: string
      }
      argsTuple: [sender: bigint | number, rekeyBack: boolean, address: string]
      returns: void
    }>
    & Record<'unblock(uint64,bool,address)void' | 'unblock', {
      argsObj: {
        sender: bigint | number
        rekeyBack: boolean
        /**
         * The address to be unblocked
         */
        address: string
      }
      argsTuple: [sender: bigint | number, rekeyBack: boolean, address: string]
      returns: void
    }>
    & Record<'isBlocked(address,address)bool' | 'isBlocked', {
      argsObj: {
        /**
         * The merchant address to be checked
         */
        merchant: string
        /**
         * The address to be checked
         */
        address: string
      }
      argsTuple: [merchant: string, address: string]
      returns: boolean
    }>
    & Record<'subscribe(uint64,bool,address,uint64,uint64,uint64,uint64)void' | 'subscribe', {
      argsObj: {
        sender: bigint | number
        rekeyBack: boolean
        recipient: string
        index: bigint | number
        amount: bigint | number
        interval: bigint | number
        asset: bigint | number
      }
      argsTuple: [sender: bigint | number, rekeyBack: boolean, recipient: string, index: bigint | number, amount: bigint | number, interval: bigint | number, asset: bigint | number]
      returns: void
    }>
    & Record<'triggerPayment(uint64,bool,uint64)void' | 'triggerPayment', {
      argsObj: {
        sender: bigint | number
        rekeyBack: boolean
        index: bigint | number
      }
      argsTuple: [sender: bigint | number, rekeyBack: boolean, index: bigint | number]
      returns: void
    }>
    & Record<'streakCheck(address,uint64)void' | 'streakCheck', {
      argsObj: {
        sender: string
        index: bigint | number
      }
      argsTuple: [sender: string, index: bigint | number]
      returns: void
    }>
    & Record<'setPasses(uint64,bool,uint64,address[])void' | 'setPasses', {
      argsObj: {
        sender: bigint | number
        rekeyBack: boolean
        index: bigint | number
        addresses: string[]
      }
      argsTuple: [sender: bigint | number, rekeyBack: boolean, index: bigint | number, addresses: string[]]
      returns: void
    }>
    & Record<'createApplication()void' | 'createApplication', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      'v'?: IntegerState
    }
  }
}
/**
 * Defines the possible abi call signatures
 */
export type SubscriptionPluginSig = keyof SubscriptionPlugin['methods']
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends SubscriptionPluginSig | undefined> = {
  method: TSignature
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>
} & AppClientCallCoreParams & CoreAppCallArgs
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>
/**
 * Maps a method signature from the SubscriptionPlugin smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends SubscriptionPluginSig> = SubscriptionPlugin['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the SubscriptionPlugin smart contract to the method's return type
 */
export type MethodReturn<TSignature extends SubscriptionPluginSig> = SubscriptionPlugin['methods'][TSignature]['returns']

/**
 * A factory for available 'create' calls
 */
export type SubscriptionPluginCreateCalls = (typeof SubscriptionPluginCallFactory)['create']
/**
 * Defines supported create methods for this smart contract
 */
export type SubscriptionPluginCreateCallParams =
  | (TypedCallParams<'createApplication()void'> & (OnCompleteNoOp))
/**
 * Defines arguments required for the deploy method.
 */
export type SubscriptionPluginDeployArgs = {
  deployTimeParams?: TealTemplateParams
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: SubscriptionPluginCreateCalls) => SubscriptionPluginCreateCallParams
}


/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class SubscriptionPluginCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the SubscriptionPlugin smart contract using the createApplication()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      createApplication(args: MethodArgs<'createApplication()void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return {
          method: 'createApplication()void' as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        }
      },
    }
  }

  /**
   * Constructs a no op call for the getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[]) ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getSubsriptionInfo(args: MethodArgs<'getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])' as const,
      methodArgs: Array.isArray(args) ? args : [args.user, args.index],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the newService(uint64,bool,uint64,uint64,uint64,uint64,byte[59],bool)uint64 ABI method
   *
   * newService creates a new service for a merchant
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static newService(args: MethodArgs<'newService(uint64,bool,uint64,uint64,uint64,uint64,byte[59],bool)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'newService(uint64,bool,uint64,uint64,uint64,uint64,byte[59],bool)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.sender, args.rekeyBack, args.interval, args.asset, args.amount, args.passes, args.cid, args.allowTraversal],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the pauseService(uint64,bool,uint64)void ABI method
   *
   * pauseService pauses a service for a merchant
it does not shutdown pre-existing subscriptions
it simply prevents new subscriptions from being created
for a specific service
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static pauseService(args: MethodArgs<'pauseService(uint64,bool,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'pauseService(uint64,bool,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.sender, args.rekeyBack, args.index],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the activateService(uint64,bool,uint64)void ABI method
   *
   * activateService activates an service for a merchant
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static activateService(args: MethodArgs<'activateService(uint64,bool,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'activateService(uint64,bool,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.sender, args.rekeyBack, args.index],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the shutdownService(uint64,bool,uint64)void ABI method
   *
   * shutdownService permanently shuts down an service for a merchant
it also shutsdown pre-existing subscriptions
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static shutdownService(args: MethodArgs<'shutdownService(uint64,bool,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'shutdownService(uint64,bool,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.sender, args.rekeyBack, args.index],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the isShutdown(address,uint64)bool ABI method
   *
   * serviceIsActive checks if an service is shutdown
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static isShutdown(args: MethodArgs<'isShutdown(address,uint64)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'isShutdown(address,uint64)bool' as const,
      methodArgs: Array.isArray(args) ? args : [args.merchant, args.boxIndex],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the block(uint64,bool,address)void ABI method
   *
   * block blacklists an address for a merchant
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static block(args: MethodArgs<'block(uint64,bool,address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'block(uint64,bool,address)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.sender, args.rekeyBack, args.address],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the unblock(uint64,bool,address)void ABI method
   *
   * unblock removes an address from a merchants blocks
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static unblock(args: MethodArgs<'unblock(uint64,bool,address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'unblock(uint64,bool,address)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.sender, args.rekeyBack, args.address],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the isBlocked(address,address)bool ABI method
   *
   * isBlocked checks if an address is blocked for a merchant
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static isBlocked(args: MethodArgs<'isBlocked(address,address)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'isBlocked(address,address)bool' as const,
      methodArgs: Array.isArray(args) ? args : [args.merchant, args.address],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the subscribe(uint64,bool,address,uint64,uint64,uint64,uint64)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static subscribe(args: MethodArgs<'subscribe(uint64,bool,address,uint64,uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'subscribe(uint64,bool,address,uint64,uint64,uint64,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.sender, args.rekeyBack, args.recipient, args.index, args.amount, args.interval, args.asset],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the triggerPayment(uint64,bool,uint64)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static triggerPayment(args: MethodArgs<'triggerPayment(uint64,bool,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'triggerPayment(uint64,bool,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.sender, args.rekeyBack, args.index],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the streakCheck(address,uint64)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static streakCheck(args: MethodArgs<'streakCheck(address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'streakCheck(address,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.sender, args.index],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the setPasses(uint64,bool,uint64,address[])void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static setPasses(args: MethodArgs<'setPasses(uint64,bool,uint64,address[])void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'setPasses(uint64,bool,uint64,address[])void' as const,
      methodArgs: Array.isArray(args) ? args : [args.sender, args.rekeyBack, args.index, args.addresses],
      ...params,
    }
  }
}

/**
 * A client to make calls to the SubscriptionPlugin smart contract
 */
export class SubscriptionPluginClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient

  private readonly sender: SendTransactionFrom | undefined

  /**
   * Creates a new instance of `SubscriptionPluginClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender
    this.appClient = algokit.getAppClient({
      ...appDetails,
      app: APP_SPEC
    }, algod)
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn, TResult extends AppCallTransactionResult = AppCallTransactionResult>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> & TResult {
    if(result.return?.decodeError) {
      throw result.return.decodeError
    }
    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
      ? returnValueFormatter(result.return.returnValue)
      : result.return?.returnValue as TReturn | undefined
      return { ...result, return: returnValue } as AppCallTransactionResultOfType<TReturn> & TResult
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof SubscriptionPlugin['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {
    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)
  }

  /**
   * Idempotently deploys the SubscriptionPlugin smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(params: SubscriptionPluginDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(SubscriptionPluginCallFactory.create)
    return this.appClient.deploy({
      ...params,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    })
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this
    return {
      /**
       * Creates a new instance of the SubscriptionPlugin smart contract using the createApplication()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result
       */
      async createApplication(args: MethodArgs<'createApplication()void'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return $this.mapReturnValue<MethodReturn<'createApplication()void'>, AppCreateCallTransactionResult>(await $this.appClient.create(SubscriptionPluginCallFactory.create.createApplication(args, params)))
      },
    }
  }

  /**
   * Makes a clear_state call to an existing instance of the SubscriptionPlugin smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args)
  }

  /**
   * Calls the getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[]) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getSubsriptionInfo(args: MethodArgs<'getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(SubscriptionPluginCallFactory.getSubsriptionInfo(args, params))
  }

  /**
   * Calls the newService(uint64,bool,uint64,uint64,uint64,uint64,byte[59],bool)uint64 ABI method.
   *
   * newService creates a new service for a merchant
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public newService(args: MethodArgs<'newService(uint64,bool,uint64,uint64,uint64,uint64,byte[59],bool)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(SubscriptionPluginCallFactory.newService(args, params))
  }

  /**
   * Calls the pauseService(uint64,bool,uint64)void ABI method.
   *
   * pauseService pauses a service for a merchant
it does not shutdown pre-existing subscriptions
it simply prevents new subscriptions from being created
for a specific service
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public pauseService(args: MethodArgs<'pauseService(uint64,bool,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(SubscriptionPluginCallFactory.pauseService(args, params))
  }

  /**
   * Calls the activateService(uint64,bool,uint64)void ABI method.
   *
   * activateService activates an service for a merchant
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public activateService(args: MethodArgs<'activateService(uint64,bool,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(SubscriptionPluginCallFactory.activateService(args, params))
  }

  /**
   * Calls the shutdownService(uint64,bool,uint64)void ABI method.
   *
   * shutdownService permanently shuts down an service for a merchant
it also shutsdown pre-existing subscriptions
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public shutdownService(args: MethodArgs<'shutdownService(uint64,bool,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(SubscriptionPluginCallFactory.shutdownService(args, params))
  }

  /**
   * Calls the isShutdown(address,uint64)bool ABI method.
   *
   * serviceIsActive checks if an service is shutdown
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public isShutdown(args: MethodArgs<'isShutdown(address,uint64)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(SubscriptionPluginCallFactory.isShutdown(args, params))
  }

  /**
   * Calls the block(uint64,bool,address)void ABI method.
   *
   * block blacklists an address for a merchant
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public block(args: MethodArgs<'block(uint64,bool,address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(SubscriptionPluginCallFactory.block(args, params))
  }

  /**
   * Calls the unblock(uint64,bool,address)void ABI method.
   *
   * unblock removes an address from a merchants blocks
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public unblock(args: MethodArgs<'unblock(uint64,bool,address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(SubscriptionPluginCallFactory.unblock(args, params))
  }

  /**
   * Calls the isBlocked(address,address)bool ABI method.
   *
   * isBlocked checks if an address is blocked for a merchant
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public isBlocked(args: MethodArgs<'isBlocked(address,address)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(SubscriptionPluginCallFactory.isBlocked(args, params))
  }

  /**
   * Calls the subscribe(uint64,bool,address,uint64,uint64,uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public subscribe(args: MethodArgs<'subscribe(uint64,bool,address,uint64,uint64,uint64,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(SubscriptionPluginCallFactory.subscribe(args, params))
  }

  /**
   * Calls the triggerPayment(uint64,bool,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public triggerPayment(args: MethodArgs<'triggerPayment(uint64,bool,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(SubscriptionPluginCallFactory.triggerPayment(args, params))
  }

  /**
   * Calls the streakCheck(address,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public streakCheck(args: MethodArgs<'streakCheck(address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(SubscriptionPluginCallFactory.streakCheck(args, params))
  }

  /**
   * Calls the setPasses(uint64,bool,uint64,address[])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public setPasses(args: MethodArgs<'setPasses(uint64,bool,uint64,address[])void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(SubscriptionPluginCallFactory.setPasses(args, params))
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {
    const value = state[key]
    if (!value) return undefined
    if (!('valueRaw' in value))
      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)
    return {
      asString(): string {
        return value.value
      },
      asByteArray(): Uint8Array {
        return value.valueRaw
      }
    }
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {
    const value = state[key]
    if (!value) return undefined
    if ('valueRaw' in value)
      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)
    return {
      asBigInt() {
        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)
      },
      asNumber(): number {
        return typeof value.value === 'bigint' ? Number(value.value) : value.value
      },
    }
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<SubscriptionPlugin['state']['global']> {
    const state = await this.appClient.getGlobalState()
    return {
      get v() {
        return SubscriptionPluginClient.getIntegerState(state, 'v')
      },
    }
  }

  public compose(): SubscriptionPluginComposer {
    const client = this
    const atc = new AtomicTransactionComposer()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: any) => any)> = []
    return {
      getSubsriptionInfo(args: MethodArgs<'getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getSubsriptionInfo(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      newService(args: MethodArgs<'newService(uint64,bool,uint64,uint64,uint64,uint64,byte[59],bool)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.newService(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      pauseService(args: MethodArgs<'pauseService(uint64,bool,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.pauseService(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      activateService(args: MethodArgs<'activateService(uint64,bool,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.activateService(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      shutdownService(args: MethodArgs<'shutdownService(uint64,bool,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.shutdownService(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      isShutdown(args: MethodArgs<'isShutdown(address,uint64)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.isShutdown(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      block(args: MethodArgs<'block(uint64,bool,address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.block(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      unblock(args: MethodArgs<'unblock(uint64,bool,address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.unblock(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      isBlocked(args: MethodArgs<'isBlocked(address,address)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.isBlocked(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      subscribe(args: MethodArgs<'subscribe(uint64,bool,address,uint64,uint64,uint64,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.subscribe(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      triggerPayment(args: MethodArgs<'triggerPayment(uint64,bool,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.triggerPayment(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      streakCheck(args: MethodArgs<'streakCheck(address,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.streakCheck(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      setPasses(args: MethodArgs<'setPasses(uint64,bool,uint64,address[])void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.setPasses(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {
        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))
        return this
      },
      async atc() {
        await promiseChain
        return atc
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await atc.simulate(client.algod, new modelsv2.SimulateRequest({ txnGroups: [], ...options }))
        return {
          ...result,
          returns: result.methodResults?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      },
      async execute(sendParams?: AppClientComposeExecuteParams) {
        await promiseChain
        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams }, client.algod)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      }
    } as unknown as SubscriptionPluginComposer
  }
}
export type SubscriptionPluginComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[]) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getSubsriptionInfo(args: MethodArgs<'getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): SubscriptionPluginComposer<[...TReturns, MethodReturn<'getSubsriptionInfo(address,uint64)(address,uint64,uint64,uint64,uint64,uint64,uint64,uint64,address[])'>]>

  /**
   * Calls the newService(uint64,bool,uint64,uint64,uint64,uint64,byte[59],bool)uint64 ABI method.
   *
   * newService creates a new service for a merchant
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  newService(args: MethodArgs<'newService(uint64,bool,uint64,uint64,uint64,uint64,byte[59],bool)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): SubscriptionPluginComposer<[...TReturns, MethodReturn<'newService(uint64,bool,uint64,uint64,uint64,uint64,byte[59],bool)uint64'>]>

  /**
   * Calls the pauseService(uint64,bool,uint64)void ABI method.
   *
   * pauseService pauses a service for a merchant
it does not shutdown pre-existing subscriptions
it simply prevents new subscriptions from being created
for a specific service
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  pauseService(args: MethodArgs<'pauseService(uint64,bool,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): SubscriptionPluginComposer<[...TReturns, MethodReturn<'pauseService(uint64,bool,uint64)void'>]>

  /**
   * Calls the activateService(uint64,bool,uint64)void ABI method.
   *
   * activateService activates an service for a merchant
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  activateService(args: MethodArgs<'activateService(uint64,bool,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): SubscriptionPluginComposer<[...TReturns, MethodReturn<'activateService(uint64,bool,uint64)void'>]>

  /**
   * Calls the shutdownService(uint64,bool,uint64)void ABI method.
   *
   * shutdownService permanently shuts down an service for a merchant
it also shutsdown pre-existing subscriptions
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  shutdownService(args: MethodArgs<'shutdownService(uint64,bool,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): SubscriptionPluginComposer<[...TReturns, MethodReturn<'shutdownService(uint64,bool,uint64)void'>]>

  /**
   * Calls the isShutdown(address,uint64)bool ABI method.
   *
   * serviceIsActive checks if an service is shutdown
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  isShutdown(args: MethodArgs<'isShutdown(address,uint64)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): SubscriptionPluginComposer<[...TReturns, MethodReturn<'isShutdown(address,uint64)bool'>]>

  /**
   * Calls the block(uint64,bool,address)void ABI method.
   *
   * block blacklists an address for a merchant
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  block(args: MethodArgs<'block(uint64,bool,address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): SubscriptionPluginComposer<[...TReturns, MethodReturn<'block(uint64,bool,address)void'>]>

  /**
   * Calls the unblock(uint64,bool,address)void ABI method.
   *
   * unblock removes an address from a merchants blocks
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  unblock(args: MethodArgs<'unblock(uint64,bool,address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): SubscriptionPluginComposer<[...TReturns, MethodReturn<'unblock(uint64,bool,address)void'>]>

  /**
   * Calls the isBlocked(address,address)bool ABI method.
   *
   * isBlocked checks if an address is blocked for a merchant
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  isBlocked(args: MethodArgs<'isBlocked(address,address)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): SubscriptionPluginComposer<[...TReturns, MethodReturn<'isBlocked(address,address)bool'>]>

  /**
   * Calls the subscribe(uint64,bool,address,uint64,uint64,uint64,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  subscribe(args: MethodArgs<'subscribe(uint64,bool,address,uint64,uint64,uint64,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): SubscriptionPluginComposer<[...TReturns, MethodReturn<'subscribe(uint64,bool,address,uint64,uint64,uint64,uint64)void'>]>

  /**
   * Calls the triggerPayment(uint64,bool,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  triggerPayment(args: MethodArgs<'triggerPayment(uint64,bool,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): SubscriptionPluginComposer<[...TReturns, MethodReturn<'triggerPayment(uint64,bool,uint64)void'>]>

  /**
   * Calls the streakCheck(address,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  streakCheck(args: MethodArgs<'streakCheck(address,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): SubscriptionPluginComposer<[...TReturns, MethodReturn<'streakCheck(address,uint64)void'>]>

  /**
   * Calls the setPasses(uint64,bool,uint64,address[])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setPasses(args: MethodArgs<'setPasses(uint64,bool,uint64,address[])void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): SubscriptionPluginComposer<[...TReturns, MethodReturn<'setPasses(uint64,bool,uint64,address[])void'>]>

  /**
   * Makes a clear_state call to an existing instance of the SubscriptionPlugin smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs): SubscriptionPluginComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): SubscriptionPluginComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(options?: SimulateOptions): Promise<SubscriptionPluginComposerSimulateResult<TReturns>>
  /**
   * Executes the transaction group and returns the results
   */
  execute(sendParams?: AppClientComposeExecuteParams): Promise<SubscriptionPluginComposerResults<TReturns>>
}
export type SimulateOptions = Omit<ConstructorParameters<typeof modelsv2.SimulateRequest>[0], 'txnGroups'>
export type SubscriptionPluginComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns
  methodResults: ABIResult[]
  simulateResponse: modelsv2.SimulateResponse
}
export type SubscriptionPluginComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns
  groupId: string
  txIds: string[]
  transactions: Transaction[]
}
