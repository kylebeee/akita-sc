/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils'
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from '@algorandfoundation/algokit-utils/types/app'
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'
import type { SendTransactionResult, TransactionToSign, SendTransactionFrom, SendTransactionParams } from '@algorandfoundation/algokit-utils/types/transaction'
import type { ABIResult, TransactionWithSigner } from 'algosdk'
import { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer, modelsv2 } from 'algosdk'
export const APP_SPEC: AppSpec = {
  "hints": {
    "updateApplication()void": {
      "call_config": {
        "update_application": "CALL"
      }
    },
    "gas()void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getPrice(string,address)(uint64,uint64,bool,bool,bool)": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getConstraints()(uint64,uint64,uint64,address,uint64,uint64,uint64)": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getNfdMbrCost(string)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getNfdLinkOnMintExtraMbrCost(address)(uint64,uint64)": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "mintNfd(pay,string,address,bool)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "linkNfdAddress(string,uint64,address)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "unlinkNfdAddress(string,uint64,address)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "ownershipAssign(string,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "ownershipChanged(string,uint64,address,address)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "setAddressPrimaryNfd(string,uint64,address)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "upgradeNfd(string)string": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "isValidNfdAppId(string,uint64)bool": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getNameAppId(string)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getAddressAppIds(address)uint64[]": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "nfdContractInit(string,uint64,byte[])void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "nfdContractLoad(string,uint64,byte[])void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "nfdContractCommit(string)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "usdInMicroAlgo(uint64)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "costToAddToAddress(address)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "calcFuturePrice(uint64,uint64)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "createApplication()void": {
      "call_config": {
        "no_op": "CREATE"
      }
    }
  },
  "bare_call_config": {
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "close_out": "NEVER",
    "update_application": "NEVER",
    "delete_application": "NEVER"
  },
  "schema": {
    "local": {
      "declared": {},
      "reserved": {}
    },
    "global": {
      "declared": {},
      "reserved": {}
    }
  },
  "state": {
    "global": {
      "num_byte_slices": 0,
      "num_uints": 0
    },
    "local": {
      "num_byte_slices": 16,
      "num_uints": 0
    }
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCgovLyBUaGlzIFRFQUwgd2FzIGdlbmVyYXRlZCBieSBURUFMU2NyaXB0IHYwLjEwMC4yCi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvcmFuZGZvdW5kYXRpb24vVEVBTFNjcmlwdAoKLy8gISEhISBXQVJOSU5HOiBUaGlzIGNvbnRyYWN0IGlzICpOT1QqIEFSQzQgY29tcGxpYW50LiBJdCBtYXkgY29udGFpbiBBQkkgbWV0aG9kcywgYnV0IGl0IGFsc28gYWxsb3dzIGFwcCBjYWxscyB3aGVyZSB0aGUgZmlyc3QgYXJndW1lbnQgZG9lcyBOT1QgbWF0Y2ggYW4gQUJJIHNlbGVjdG9yCgovLyBUaGUgZm9sbG93aW5nIGxpbmVzIG9mIFRFQUwgYXJlIHVzZWQgdG8gaW5pdGlhbGl6ZSB0ZW1wbGF0ZSB2YXJpYWJsZXMgaW4gc2NyYXRjaCBzbG90cwpwdXNoYnl0ZXMgVE1QTF9hbGdvVXNkT3JhY2xlQXBwSWQKYnRvaQpzdG9yZSAyMDQKcHVzaGJ5dGVzIFRNUExfbmZkQ29tbWlzc2lvbjFSYXRlCmJ0b2kKc3RvcmUgMjAzCnB1c2hieXRlcyBUTVBMX25mZENvbW1pc3Npb24xQWRkcgpzdG9yZSAyMDIKcHVzaGJ5dGVzIFRNUExfbmZkVHJlYXN1cnlBZGRyCnN0b3JlIDIwMQpwdXNoYnl0ZXMgVE1QTF9hZG1pbkFzYUlkCmJ0b2kKc3RvcmUgMjAwCgovLyBUaGUgZm9sbG93aW5nIHRlbiBsaW5lcyBvZiBURUFMIGhhbmRsZSBpbml0aWFsIHByb2dyYW0gZmxvdwovLyBUaGlzIHBhdHRlcm4gaXMgdXNlZCB0byBtYWtlIGl0IGVhc3kgZm9yIGFueW9uZSB0byBwYXJzZSB0aGUgc3RhcnQgb2YgdGhlIHByb2dyYW0gYW5kIGRldGVybWluZSBpZiBhIHNwZWNpZmljIGFjdGlvbiBpcyBhbGxvd2VkCi8vIEhlcmUsIGFjdGlvbiByZWZlcnMgdG8gdGhlIE9uQ29tcGxldGUgaW4gY29tYmluYXRpb24gd2l0aCB3aGV0aGVyIHRoZSBhcHAgaXMgYmVpbmcgY3JlYXRlZCBvciBjYWxsZWQKLy8gRXZlcnkgcG9zc2libGUgYWN0aW9uIGZvciB0aGlzIGNvbnRyYWN0IGlzIHJlcHJlc2VudGVkIGluIHRoZSBzd2l0Y2ggc3RhdGVtZW50Ci8vIElmIHRoZSBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoZSBjb250cmFjdCwgaXRzIHJlc3BlY3RpdmUgYnJhbmNoIHdpbGwgYmUgIipOT1RfSU1QTEVNRU5URUQiIHdoaWNoIGp1c3QgY29udGFpbnMgImVyciIKdHhuIEFwcGxpY2F0aW9uSUQKIQppbnQgNgoqCnR4biBPbkNvbXBsZXRpb24KKwpzd2l0Y2ggKmNhbGxfTm9PcCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqY2FsbF9VcGRhdGVBcHBsaWNhdGlvbiAqTk9UX0lNUExFTUVOVEVEICpjcmVhdGVfTm9PcCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQKCipOT1RfSU1QTEVNRU5URUQ6CgkvLyBUaGUgcmVxdWVzdGVkIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBjb250cmFjdC4gQXJlIHlvdSB1c2luZyB0aGUgY29ycmVjdCBPbkNvbXBsZXRlPyBEaWQgeW91IHNldCB5b3VyIGFwcCBJRD8KCWVycgoKLy8gdXBkYXRlQXBwbGljYXRpb24oKXZvaWQKKmFiaV9yb3V0ZV91cGRhdGVBcHBsaWNhdGlvbjoKCS8vIGV4ZWN1dGUgdXBkYXRlQXBwbGljYXRpb24oKXZvaWQKCWNhbGxzdWIgdXBkYXRlQXBwbGljYXRpb24KCWludCAxCglyZXR1cm4KCi8vIHVwZGF0ZUFwcGxpY2F0aW9uKCk6IHZvaWQKdXBkYXRlQXBwbGljYXRpb246Cglwcm90byAwIDAKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo2NwoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gdGhpcy5hcHAuY3JlYXRvcikKCXR4biBTZW5kZXIKCXR4bmEgQXBwbGljYXRpb25zIDAKCWFwcF9wYXJhbXNfZ2V0IEFwcENyZWF0b3IKCXBvcAoJPT0KCWFzc2VydAoJcmV0c3ViCgovLyBvbkNhbGwoKTogdm9pZApvbkNhbGw6Cglwcm90byAwIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoKCS8vICppZjBfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo3MwoJLy8gdGhpcy50eG4ub25Db21wbGV0aW9uID09PSA0Cgl0eG4gT25Db21wbGV0aW9uCglpbnQgNAoJPT0KCWJ6ICppZjBfZW5kCgoJLy8gKmlmMF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo3NAoJLy8gdGhpcy51cGRhdGVBcHBsaWNhdGlvbigpCgljYWxsc3ViIHVwZGF0ZUFwcGxpY2F0aW9uCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NzUKCS8vIHJldHVybgoJcmV0c3ViCgoqaWYwX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjc3CgkvLyBhc3NlcnQodGhpcy50eG4ucmVrZXlUbyA9PT0gZ2xvYmFscy56ZXJvQWRkcmVzcykKCXR4biBSZWtleVRvCglnbG9iYWwgWmVyb0FkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyAqaWYxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NzkKCS8vIHRoaXMudHhuLmFwcGxpY2F0aW9uQXJncyFbMF0gPT09ICdnYXMnCgl0eG4gQXBwbGljYXRpb25BcmdzIDAKCWJ5dGUgMHg2NzYxNzMgLy8gImdhcyIKCT09CglieiAqaWYxX2VuZAoKCS8vICppZjFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6ODAKCS8vIHJldHVybgoJcmV0c3ViCgoqaWYxX2VuZDoKCS8vICppZjJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo4MwoJLy8gdGhpcy50eG4ubnVtQXBwQXJncyA9PT0gMyAmJiB0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhWzBdID09PSBSRUdJU1RSWV9DQUxMX0lTX1ZBTElEX05GREFQUElECgl0eG4gTnVtQXBwQXJncwoJaW50IDMKCT09CglkdXAKCWJ6ICpza2lwX2FuZDAKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMAoJYnl0ZSAiaXNfdmFsaWRfbmZkX2FwcGlkIgoJPT0KCSYmCgoqc2tpcF9hbmQwOgoJYnogKmlmMl9lbmQKCgkvLyAqaWYyX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjg4CgkvLyBsb2coCgkvLyAgICAgICAgICAgICAgICAgaXRvYigKCS8vICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1ZhbGlkTmZkQXBwSWQodGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVsxXSBhcyBieXRlcywgYnRvaSh0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhWzJdKSkKCS8vICAgICAgICAgICAgICAgICAgICAgICAgID8gMQoJLy8gICAgICAgICAgICAgICAgICAgICAgICAgOiAwLAoJLy8gICAgICAgICAgICAgICAgICksCgkvLyAgICAgICAgICAgICApCgl0eG4gQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMQoJY2FsbHN1YiBpc1ZhbGlkTmZkQXBwSWQKCWJ6ICp0ZXJuYXJ5MF9mYWxzZQoJaW50IDEKCWIgKnRlcm5hcnkwX2VuZAoKKnRlcm5hcnkwX2ZhbHNlOgoJaW50IDAKCip0ZXJuYXJ5MF9lbmQ6CglpdG9iCglsb2cKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo5NQoJLy8gcmV0dXJuCglyZXRzdWIKCippZjJfZW5kOgoJLy8gKmlmM19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEwMgoJLy8gdGhpcy50eG4ubnVtQXBwQXJncyA9PT0gNCAmJiB0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhWzBdID09PSBSRUdJU1RSWV9DQUxMX1ZFUklGWV9ORkRfQUREUkVTUwoJdHhuIE51bUFwcEFyZ3MKCWludCA0Cgk9PQoJZHVwCglieiAqc2tpcF9hbmQxCgl0eG4gQXBwbGljYXRpb25BcmdzIDAKCWJ5dGUgInZlcmlmeV9uZmRfYWRkciIKCT09CgkmJgoKKnNraXBfYW5kMToKCWJ6ICppZjNfZW5kCgoJLy8gKmlmM19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMDcKCS8vIHRoaXMubGlua05mZEFkZHJlc3MoCgkvLyAgICAgICAgICAgICAgICAgdGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVsxXSBhcyBieXRlcywKCS8vICAgICAgICAgICAgICAgICBidG9pKHRoaXMudHhuLmFwcGxpY2F0aW9uQXJncyFbMl0pLAoJLy8gICAgICAgICAgICAgICAgIEFkZHJlc3MuZnJvbUJ5dGVzKHRoaXMudHhuLmFwcGxpY2F0aW9uQXJncyFbM10pLAoJLy8gICAgICAgICAgICAgKQoJdHhuIEFwcGxpY2F0aW9uQXJncyAzCgl0eG4gQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMQoJY2FsbHN1YiBsaW5rTmZkQWRkcmVzcwoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjExMgoJLy8gcmV0dXJuCglyZXRzdWIKCippZjNfZW5kOgoJLy8gKmlmNF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjExNAoJLy8gdGhpcy50eG4ubnVtQXBwQXJncyA9PT0gNCAmJiB0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhWzBdID09PSBSRUdJU1RSWV9DQUxMX1VOTElOS19ORkRfQUREUkVTUwoJdHhuIE51bUFwcEFyZ3MKCWludCA0Cgk9PQoJZHVwCglieiAqc2tpcF9hbmQyCgl0eG4gQXBwbGljYXRpb25BcmdzIDAKCWJ5dGUgInVubGlua19uZmRfYWRkciIKCT09CgkmJgoKKnNraXBfYW5kMjoKCWJ6ICppZjRfZW5kCgoJLy8gKmlmNF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTkKCS8vIHRoaXMudW5saW5rTmZkQWRkcmVzcygKCS8vICAgICAgICAgICAgICAgICB0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhWzFdIGFzIGJ5dGVzLAoJLy8gICAgICAgICAgICAgICAgIGJ0b2kodGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVsyXSksCgkvLyAgICAgICAgICAgICAgICAgQWRkcmVzcy5mcm9tQnl0ZXModGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVszXSksCgkvLyAgICAgICAgICAgICApCgl0eG4gQXBwbGljYXRpb25BcmdzIDMKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoJdHhuIEFwcGxpY2F0aW9uQXJncyAxCgljYWxsc3ViIHVubGlua05mZEFkZHJlc3MKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMjQKCS8vIHJldHVybgoJcmV0c3ViCgoqaWY0X2VuZDoKCS8vICppZjVfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMjcKCS8vIHRoaXMudHhuLm51bUFwcEFyZ3MgPT09IDQgJiYgdGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVswXSA9PT0gUkVHSVNUUllfQ0FMTF9TRVRfQUREUl9QUklNQVJZX05GRAoJdHhuIE51bUFwcEFyZ3MKCWludCA0Cgk9PQoJZHVwCglieiAqc2tpcF9hbmQzCgl0eG4gQXBwbGljYXRpb25BcmdzIDAKCWJ5dGUgInNldF9hZGRyX3ByaW1hcnlfbmZkIgoJPT0KCSYmCgoqc2tpcF9hbmQzOgoJYnogKmlmNV9lbmQKCgkvLyAqaWY1X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEzMgoJLy8gdGhpcy5zZXRBZGRyZXNzUHJpbWFyeU5mZCgKCS8vICAgICAgICAgICAgICAgICB0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhWzFdIGFzIGJ5dGVzLAoJLy8gICAgICAgICAgICAgICAgIGJ0b2kodGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVsyXSksCgkvLyAgICAgICAgICAgICAgICAgQWRkcmVzcy5mcm9tQnl0ZXModGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVszXSksCgkvLyAgICAgICAgICAgICApCgl0eG4gQXBwbGljYXRpb25BcmdzIDMKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoJdHhuIEFwcGxpY2F0aW9uQXJncyAxCgljYWxsc3ViIHNldEFkZHJlc3NQcmltYXJ5TmZkCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTM3CgkvLyByZXR1cm4KCXJldHN1YgoKKmlmNV9lbmQ6CgkvLyAqaWY2X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQwCgkvLyB0aGlzLnR4bi5udW1BcHBBcmdzID09PSAyICYmIHRoaXMudHhuLmFwcGxpY2F0aW9uQXJncyFbMF0gPT09IFJFR0lTVFJZX0NBTExfR0VUX05BTUVfQVBQSUQKCXR4biBOdW1BcHBBcmdzCglpbnQgMgoJPT0KCWR1cAoJYnogKnNraXBfYW5kNAoJdHhuIEFwcGxpY2F0aW9uQXJncyAwCglieXRlICJnZXRfbmFtZV9hcHBpZCIKCT09CgkmJgoKKnNraXBfYW5kNDoKCWJ6ICppZjZfZW5kCgoJLy8gKmlmNl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxNDEKCS8vIHRoaXMuZ2V0Tm9uQWJpTmFtZUFwcElkKCkKCWNhbGxzdWIgZ2V0Tm9uQWJpTmFtZUFwcElkCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQyCgkvLyByZXR1cm4KCXJldHN1YgoKKmlmNl9lbmQ6CgkvLyAqaWY3X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQ0CgkvLyB0aGlzLnR4bi5udW1BcHBBcmdzID09PSAzICYmIHRoaXMudHhuLmFwcGxpY2F0aW9uQXJncyFbMF0gPT09IFJFR0lTVFJZX0NBTExfR0VUX0FERFJFU1NfQVBQSURTCgl0eG4gTnVtQXBwQXJncwoJaW50IDMKCT09CglkdXAKCWJ6ICpza2lwX2FuZDUKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMAoJYnl0ZSAiZ2V0X2FkZHJlc3NfYXBwaWRzIgoJPT0KCSYmCgoqc2tpcF9hbmQ1OgoJYnogKmlmN19lbmQKCgkvLyAqaWY3X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE0NQoJLy8gdGhpcy5ub25BYmlnZXRBZGRyZXNzQXBwSWRzKCkKCWNhbGxzdWIgbm9uQWJpZ2V0QWRkcmVzc0FwcElkcwoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE0NgoJLy8gcmV0dXJuCglyZXRzdWIKCippZjdfZW5kOgoJLy8gKmlmOF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE1MQoJLy8gZ2xvYmFscy5ncm91cFNpemUgPj0gMgoJZ2xvYmFsIEdyb3VwU2l6ZQoJaW50IDIKCT49CglieiAqaWY4X2VuZAoKCS8vICppZjhfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTU1CgkvLyBwcmlvclRyYW5zYWN0aW9uID0gdGhpcy50eG5Hcm91cFt0aGlzLnR4bi5ncm91cEluZGV4IC0gMV0KCXR4biBHcm91cEluZGV4CglpbnQgMQoJLQoJZnJhbWVfYnVyeSAwIC8vIHByaW9yVHJhbnNhY3Rpb246IHR4bgoKCS8vICppZjlfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxNTcKCS8vIHByaW9yVHJhbnNhY3Rpb24udHlwZUVudW0gPT09IFRyYW5zYWN0aW9uVHlwZS5QYXltZW50ICYmCgkvLyAgICAgICAgICAgICAgICAgcHJpb3JUcmFuc2FjdGlvbi5yZWtleVRvID09PSBnbG9iYWxzLnplcm9BZGRyZXNzICYmCgkvLyAgICAgICAgICAgICAgICAgcHJpb3JUcmFuc2FjdGlvbi5jbG9zZVJlbWFpbmRlclRvID09PSBnbG9iYWxzLnplcm9BZGRyZXNzICYmCgkvLyAgICAgICAgICAgICAgICAgKHByaW9yVHJhbnNhY3Rpb24uYW1vdW50ID49IGdsb2JhbHMubWluVHhuRmVlIHx8IHByaW9yVHJhbnNhY3Rpb24uZmVlID4gZ2xvYmFscy5taW5UeG5GZWUpICYmCgkvLyAgICAgICAgICAgICAgICAgdGhpcy5pc1R4bkxhYihwcmlvclRyYW5zYWN0aW9uKQoJZnJhbWVfZGlnIDAgLy8gcHJpb3JUcmFuc2FjdGlvbjogdHhuCglndHhucyBUeXBlRW51bQoJaW50IHBheQoJPT0KCWR1cAoJYnogKnNraXBfYW5kNgoJZnJhbWVfZGlnIDAgLy8gcHJpb3JUcmFuc2FjdGlvbjogdHhuCglndHhucyBSZWtleVRvCglnbG9iYWwgWmVyb0FkZHJlc3MKCT09CgkmJgoKKnNraXBfYW5kNjoKCWR1cAoJYnogKnNraXBfYW5kNwoJZnJhbWVfZGlnIDAgLy8gcHJpb3JUcmFuc2FjdGlvbjogdHhuCglndHhucyBDbG9zZVJlbWFpbmRlclRvCglnbG9iYWwgWmVyb0FkZHJlc3MKCT09CgkmJgoKKnNraXBfYW5kNzoKCWR1cAoJYnogKnNraXBfYW5kOAoJZnJhbWVfZGlnIDAgLy8gcHJpb3JUcmFuc2FjdGlvbjogdHhuCglndHhucyBBbW91bnQKCWdsb2JhbCBNaW5UeG5GZWUKCT49CglkdXAKCWJueiAqc2tpcF9vcjAKCWZyYW1lX2RpZyAwIC8vIHByaW9yVHJhbnNhY3Rpb246IHR4bgoJZ3R4bnMgRmVlCglnbG9iYWwgTWluVHhuRmVlCgk+Cgl8fAoKKnNraXBfb3IwOgoJJiYKCipza2lwX2FuZDg6CglkdXAKCWJ6ICpza2lwX2FuZDkKCWZyYW1lX2RpZyAwIC8vIHByaW9yVHJhbnNhY3Rpb246IHR4bgoJY2FsbHN1YiBpc1R4bkxhYgoJJiYKCipza2lwX2FuZDk6CglieiAqaWY5X2VuZAoKCS8vICppZjlfY29uc2VxdWVudAoJLy8gKmlmMTBfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxNjUKCS8vIHRoaXMudHhuLm51bUFwcEFyZ3MgPT09IDIgJiYKCS8vICAgICAgICAgICAgICAgICAgICAgdGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVswXSA9PT0gUkVHSVNUUllfQ0FMTF9SRU1PVkVfQUREUkVTUyAmJgoJLy8gICAgICAgICAgICAgICAgICAgICAvLyBWZXJpZnkgVHhuTGFiIEZ1bmRlZCBhY2N0IGluIHByaW9yIGNoZWNrcyBhbmQgVEhBVCB3YXMgdGhlbiBvdXIgY2FsbGVyCgkvLyAgICAgICAgICAgICAgICAgICAgIHRoaXMudHhuR3JvdXBbdGhpcy50eG4uZ3JvdXBJbmRleCAtIDFdLnJlY2VpdmVyID09PSB0aGlzLnR4bi5zZW5kZXIKCXR4biBOdW1BcHBBcmdzCglpbnQgMgoJPT0KCWR1cAoJYnogKnNraXBfYW5kMTAKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMAoJYnl0ZSAicmVtb3ZlX2FkZHIiCgk9PQoJJiYKCipza2lwX2FuZDEwOgoJZHVwCglieiAqc2tpcF9hbmQxMQoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCglndHhucyBSZWNlaXZlcgoJdHhuIFNlbmRlcgoJPT0KCSYmCgoqc2tpcF9hbmQxMToKCWJ6ICppZjEwX2Vsc2UKCgkvLyAqaWYxMF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxNzAKCS8vIHRoaXMucmVtb3ZlSW50RnJvbVYxTXVsdGlzZXQoCgkvLyAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnR4bi5zZW5kZXIsCgkvLyAgICAgICAgICAgICAgICAgICAgICAgICBSRUdJU1RSWV9LRVlfQVBQSURTRVRQUkVGSVgsCgkvLyAgICAgICAgICAgICAgICAgICAgICAgICAxNiwKCS8vICAgICAgICAgICAgICAgICAgICAgICAgIGJ0b2kodGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVsxXSksCgkvLyAgICAgICAgICAgICAgICAgICAgICkKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoJaW50IDE2CglieXRlICJpLmFwcHMiCgl0eG4gU2VuZGVyCgljYWxsc3ViIHJlbW92ZUludEZyb21WMU11bHRpc2V0CgliICppZjEwX2VuZAoKKmlmMTBfZWxzZToKCS8vIGludmFsaWQKCWVycgoKKmlmMTBfZW5kOgoKKmlmOV9lbmQ6CgoqaWY4X2VuZDoKCS8vICppZjExX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTgyCgkvLyB0aGlzLmlzVHhuTGFiKHRoaXMudHhuR3JvdXBbdGhpcy50eG4uZ3JvdXBJbmRleF0pCgl0eG4gR3JvdXBJbmRleAoJY2FsbHN1YiBpc1R4bkxhYgoJYnogKmlmMTFfZW5kCgoJLy8gKmlmMTFfY29uc2VxdWVudAoJLy8gKmlmMTJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxODMKCS8vIHRoaXMudHhuLm51bUFwcEFyZ3MgPT09IDMgJiYgdGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVswXSA9PT0gUkVHSVNUUllfQ0FMTF9NSUdSQVRFX05BTUUKCXR4biBOdW1BcHBBcmdzCglpbnQgMwoJPT0KCWR1cAoJYnogKnNraXBfYW5kMTIKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMAoJYnl0ZSAibWlncmF0ZV9uYW1lIgoJPT0KCSYmCgoqc2tpcF9hbmQxMjoKCWJ6ICppZjEyX2VuZAoKCS8vICppZjEyX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE4NAoJLy8gdGhpcy5taWdyYXRlVjFOYW1lKCkKCWNhbGxzdWIgbWlncmF0ZVYxTmFtZQoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE4NQoJLy8gcmV0dXJuCglyZXRzdWIKCippZjEyX2VuZDoKCS8vICppZjEzX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTg3CgkvLyB0aGlzLnR4bi5udW1BcHBBcmdzID09PSAzICYmIHRoaXMudHhuLmFwcGxpY2F0aW9uQXJncyFbMF0gPT09IFJFR0lTVFJZX0NBTExfTUlHUkFURV9BRERSRVNTCgl0eG4gTnVtQXBwQXJncwoJaW50IDMKCT09CglkdXAKCWJ6ICpza2lwX2FuZDEzCgl0eG4gQXBwbGljYXRpb25BcmdzIDAKCWJ5dGUgIm1pZ3JhdGVfYWRkcmVzcyIKCT09CgkmJgoKKnNraXBfYW5kMTM6CglieiAqaWYxM19lbmQKCgkvLyAqaWYxM19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxODgKCS8vIHRoaXMubWlncmF0ZVYxQWRkcmVzc0tleXModGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVsxXSBhcyBieXRlcywgdGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVsyXSBhcyBieXRlcykKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMgoJdHhuIEFwcGxpY2F0aW9uQXJncyAxCgljYWxsc3ViIG1pZ3JhdGVWMUFkZHJlc3NLZXlzCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTg5CgkvLyByZXR1cm4KCXJldHN1YgoKKmlmMTNfZW5kOgoJLy8gKmlmMTRfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxOTEKCS8vIHRoaXMudHhuLm51bUFwcEFyZ3MgPT09IDIgJiYgdGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVswXSA9PT0gUkVHSVNUUllfQ0FMTF9TV0VFUF9EVVNUCgl0eG4gTnVtQXBwQXJncwoJaW50IDIKCT09CglkdXAKCWJ6ICpza2lwX2FuZDE0Cgl0eG4gQXBwbGljYXRpb25BcmdzIDAKCWJ5dGUgInN3ZWVwX2R1c3QiCgk9PQoJJiYKCipza2lwX2FuZDE0OgoJYnogKmlmMTRfZW5kCgoJLy8gKmlmMTRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTkyCgkvLyB0aGlzLnN3ZWVwRHVzdCgpCgljYWxsc3ViIHN3ZWVwRHVzdAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE5MwoJLy8gcmV0dXJuCglyZXRzdWIKCippZjE0X2VuZDoKCS8vIGludmFsaWQgbWV0aG9kCgllcnIKCippZjExX2VuZDoKCS8vIHVua25vd24gbWV0aG9kCgllcnIKCXJldHN1YgoKLy8gZ2FzKCl2b2lkCiphYmlfcm91dGVfZ2FzOgoJLy8gZXhlY3V0ZSBnYXMoKXZvaWQKCWNhbGxzdWIgZ2FzCglpbnQgMQoJcmV0dXJuCgovLyBnYXMoKTogdm9pZApnYXM6Cglwcm90byAwIDAKCXJldHN1YgoKLy8gZ2V0UHJpY2Uoc3RyaW5nLGFkZHJlc3MpKHVpbnQ2NCx1aW50NjQsYm9vbCxib29sLGJvb2wpCiphYmlfcm91dGVfZ2V0UHJpY2U6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIGNhbGxlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludCAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChjYWxsZXIpIGZvciBnZXRQcmljZSBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gbmZkTmFtZTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgZ2V0UHJpY2Uoc3RyaW5nLGFkZHJlc3MpKHVpbnQ2NCx1aW50NjQsYm9vbCxib29sLGJvb2wpCgljYWxsc3ViIGdldFByaWNlCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gZ2V0UHJpY2UobmZkTmFtZTogc3RyaW5nLCBjYWxsZXI6IEFkZHJlc3MpOiBQcmljZUluZm8KLy8KLy8gUmV0dXJucyB0aGUgcHJpY2UgZm9yIGEgZ2l2ZW4gTkZEIChzaW5nbGUgeWVhciksIHRoZSBtYXggIyBvZiB5ZWFycyBhbGxvd2VkIChOYW1lIGZvciBEaXNwbGF5KSwKLy8gYW5kIGV4dHJhIGFsZ28gcmVxdWlyZWQgdG8gY292ZXIgTUJSIHdoZW4gcHVyY2hhc2luZy4KLy8KLy8gQHBhcmFtIHtzdHJpbmd9IG5mZE5hbWUgLSBUaGUgTkZEIG5hbWUgZm9yIHdoaWNoIHRvIHJldHJpZXZlIHRoZSBwcmljZS4KLy8gQHBhcmFtIHtBZGRyZXNzfSBjYWxsZXIgLSB0aGUgYWRkcmVzcyB0aGlzIHJlcXVlc3QgaXMgb24gYmVoYWxmIG9mIChzaW5jZSBhbiBuZmQgY29udHJhY3QgbWlnaHQgY2FsbCB1cyBpdAovLyBuZWVkcyB0byBiZSBhYmxlIHRvIHBhc3Mgb24gdGhlIHJlcXVlc3Qgb24gYmVoYWxmIG9mIElUUyBjYWxsZXIgLSBpZTogZ2V0dGluZyBwcmljZSBmb3IgYW4gZXhwaXJlZCBuZmQgd2lsbCBiZQovLyBkaWZmZXJlbnQgaWYgaXRzIG93bmVyIGlyIGFza2luZy4KLy8gQHJldHVybiB7UHJpY2VJbmZvfSBUeXBlIGNvbnRhaW5pbmcgdGhlIHByaWNlLCBjYXJyeSBjb3N0LCBldGMuCmdldFByaWNlOgoJcHJvdG8gMiAxCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MjE0CgkvLyByZXR1cm4gdGhpcy5nZXRQcmljZUZvck5hbWUobmZkTmFtZSwgdGhpcy5udW1MZXR0ZXJzSW5OZmQobmZkTmFtZSksIGNhbGxlcikKCWZyYW1lX2RpZyAtMiAvLyBjYWxsZXI6IEFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBuZmROYW1lOiBzdHJpbmcKCWNhbGxzdWIgbnVtTGV0dGVyc0luTmZkCglmcmFtZV9kaWcgLTEgLy8gbmZkTmFtZTogc3RyaW5nCgljYWxsc3ViIGdldFByaWNlRm9yTmFtZQoJcmV0c3ViCgovLyBnZXRDb25zdHJhaW50cygpKHVpbnQ2NCx1aW50NjQsdWludDY0LGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCiphYmlfcm91dGVfZ2V0Q29uc3RyYWludHM6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIGV4ZWN1dGUgZ2V0Q29uc3RyYWludHMoKSh1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJY2FsbHN1YiBnZXRDb25zdHJhaW50cwoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGdldENvbnN0cmFpbnRzKCk6IENvbnN0cmFpbnRzCmdldENvbnN0cmFpbnRzOgoJcHJvdG8gMCAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoyMTgKCS8vIHBsYXRmb3JtUHJpY2UgPSB0aGlzLmNhbGNGdXR1cmVQcmljZShORkRfTUlOX1NFR01FTlRfVVNELCBnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWludCA1MDAKCWNhbGxzdWIgY2FsY0Z1dHVyZVByaWNlCglmcmFtZV9idXJ5IDAgLy8gcGxhdGZvcm1QcmljZTogdWludDY0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MjE5CgkvLyByZXR1cm4gewoJLy8gICAgICAgICAgICAgc2VnbWVudFBsYXRmb3JtQ29zdEluVXNkOiBwbGF0Zm9ybVByaWNlLAoJLy8gICAgICAgICAgICAgc2VnbWVudFBsYXRmb3JtQ29zdEluQWxnbzogdGhpcy51c2RJbk1pY3JvQWxnbyhwbGF0Zm9ybVByaWNlKSwKCS8vICAgICAgICAgICAgIG1heFllYXJzQWxsb3dlZDogTkZEX01BWF9FWFBJUkFUSU9OX1lFQVJTLAoJLy8gICAgICAgICAgICAgdHJlYXN1cnlBZGRyZXNzOiB0aGlzLm5mZFRyZWFzdXJ5QWRkciwKCS8vICAgICAgICAgICAgIGV4cGlyZWRBdWN0aW9uRHVyYXRpb246IE5GRF9BVUNUSU9OX0RVUkFUSU9OLAoJLy8gICAgICAgICAgICAgZXhwaXJlZFN0YXJ0aW5nUHJpY2U6IE5GRF9BVUNUSU9OX1NUQVJUUFJJQ0UsCgkvLyAgICAgICAgICAgICBtYXhNaW50Q2FycnlDb3N0OiB0aGlzLmdldE5mZE1ickNvc3QoJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMC4wMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAuYWxnbycpLCAvLyBtYXggbGVuZ3RoIG5mZAoJLy8gICAgICAgICB9CglmcmFtZV9kaWcgMCAvLyBwbGF0Zm9ybVByaWNlOiB1aW50NjQKCWl0b2IKCWZyYW1lX2RpZyAwIC8vIHBsYXRmb3JtUHJpY2U6IHVpbnQ2NAoJY2FsbHN1YiB1c2RJbk1pY3JvQWxnbwoJaXRvYgoJY29uY2F0CglieXRlIDB4MDAwMDAwMDAwMDAwMDAxNAoJY29uY2F0Cglsb2FkIDIwMSAvLyBUTVBMX25mZFRyZWFzdXJ5QWRkcgoJY29uY2F0CglieXRlIDB4MDAwMDAwMDAwMDAwMDAxYwoJY29uY2F0CglieXRlIDB4MDAwMDAwMDAwMDk4OTY4MAoJY29uY2F0CglieXRlIDB4MzAzMDMwMzAzMDMwMzAzMDMwMzAzMDMwMzAzMDMwMzAzMDMwMzAzMDMwMzAzMDMwMzAzMDMwMmUzMDMwMzAzMDMwMzAzMDMwMzAzMDMwMzAzMDMwMzAzMDMwMzAzMDMwMzAzMDMwMzAzMDMwMzAyZTYxNmM2NzZmIC8vICIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAuMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwLmFsZ28iCgljYWxsc3ViIGdldE5mZE1ickNvc3QKCWl0b2IKCWNvbmNhdAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBnZXROZmRNYnJDb3N0KHN0cmluZyl1aW50NjQKKmFiaV9yb3V0ZV9nZXROZmRNYnJDb3N0OgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBuZmROYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBnZXROZmRNYnJDb3N0KHN0cmluZyl1aW50NjQKCWNhbGxzdWIgZ2V0TmZkTWJyQ29zdAoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGdldE5mZE1ickNvc3QobmZkTmFtZTogc3RyaW5nKTogdWludDY0Ci8vCi8vIFJldHVybnMgdGhlIE1CUiBhbW91bnRzIG5lZWRlZCB0byBNSU5UIGFuIG5mZC4KLy8gVGhpcyB2YWx1ZSBuZWVkcyB0byBiZSBhZGRlZCB0byBwdXJjaGFzZSBwcmljZSBpbiBtaW50TmZkIGNhbGwuCi8vIGdldFByaWNlKCkgcmV0dXJucyBpdCB0aG91Z2guCmdldE5mZE1ickNvc3Q6Cglwcm90byAxIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MjQwCgkvLyByZWdpc3RyeUNhcnJ5Q29zdCA9CgkvLyAgICAgICAgICAgICB0aGlzLm1pbkJhbGFuY2VGb3JBY2NvdW50KDEsIG51bUV4dHJhUGFnZXMsIDAsIDAsIDAsIDAsIG51bUdsb2JhbEJ5dGVzKSAtIEFMR09SQU5EX0FDQ09VTlRfTUlOX0JBTEFOQ0UKCWludCAzMAoJaW50IDAKCWR1cG4gMwoJaW50IDMKCWludCAxCgljYWxsc3ViIG1pbkJhbGFuY2VGb3JBY2NvdW50CglpbnQgMTAwMDAwCgktCglmcmFtZV9idXJ5IDAgLy8gcmVnaXN0cnlDYXJyeUNvc3Q6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjI0NwoJLy8gYm94U3RvcmFnZUNvc3QgPSB0aGlzLmNvc3RGb3JCb3hTdG9yYWdlKDIsIDMyICsgMTYgKyAzMyArIDggKyBuZmROYW1lLmxlbmd0aCkKCWludCA4OQoJZnJhbWVfZGlnIC0xIC8vIG5mZE5hbWU6IHN0cmluZwoJbGVuCgkrCglpbnQgMgoJY2FsbHN1YiBjb3N0Rm9yQm94U3RvcmFnZQoJZnJhbWVfYnVyeSAxIC8vIGJveFN0b3JhZ2VDb3N0OiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoyNDgKCS8vIHJldHVybiByZWdpc3RyeUNhcnJ5Q29zdCArIGJveFN0b3JhZ2VDb3N0ICsgdGhpcy5nZXROZmRJbnN0YW5jZU1icigpCglmcmFtZV9kaWcgMCAvLyByZWdpc3RyeUNhcnJ5Q29zdDogdWludDY0CglmcmFtZV9kaWcgMSAvLyBib3hTdG9yYWdlQ29zdDogdWludDY0CgkrCgljYWxsc3ViIGdldE5mZEluc3RhbmNlTWJyCgkrCgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMQoJcmV0c3ViCgovLyBnZXROZmRMaW5rT25NaW50RXh0cmFNYnJDb3N0KGFkZHJlc3MpKHVpbnQ2NCx1aW50NjQpCiphYmlfcm91dGVfZ2V0TmZkTGlua09uTWludEV4dHJhTWJyQ29zdDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gYWRkcmVzczogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChhZGRyZXNzKSBmb3IgZ2V0TmZkTGlua09uTWludEV4dHJhTWJyQ29zdCBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBnZXROZmRMaW5rT25NaW50RXh0cmFNYnJDb3N0KGFkZHJlc3MpKHVpbnQ2NCx1aW50NjQpCgljYWxsc3ViIGdldE5mZExpbmtPbk1pbnRFeHRyYU1ickNvc3QKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBnZXROZmRMaW5rT25NaW50RXh0cmFNYnJDb3N0KGFkZHJlc3M6IEFkZHJlc3MpOiBMaW5rT25NaW50RXh0cmFNYnJDb3N0cwpnZXROZmRMaW5rT25NaW50RXh0cmFNYnJDb3N0OgoJcHJvdG8gMSAxCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MjUzCgkvLyByZXR1cm4gewoJLy8gICAgICAgICAgICAgbGlua2luZ05mZE1ickNvc3Q6IHRoaXMuY29zdEZvckJveFN0b3JhZ2UoMSwgTkZEX0ZJRUxEX0NBX1ZFUklGSUVEX1NFVC5sZW5ndGggKyAzMiksCgkvLyAgICAgICAgICAgICBsaW5raW5nUmVnaXN0cnlNYnJDb3N0OiB0aGlzLmNvc3RUb0FkZFRvQWRkcmVzcyhhZGRyZXNzKSwKCS8vICAgICAgICAgfQoJYnl0ZSAidi5jYUFsZ28uMC5hcyIKCWxlbgoJaW50IDMyCgkrCglpbnQgMQoJY2FsbHN1YiBjb3N0Rm9yQm94U3RvcmFnZQoJaXRvYgoJZnJhbWVfZGlnIC0xIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWNhbGxzdWIgY29zdFRvQWRkVG9BZGRyZXNzCglpdG9iCgljb25jYXQKCXJldHN1YgoKLy8gbWludE5mZChwYXksc3RyaW5nLGFkZHJlc3MsYm9vbCl1aW50NjQKKmFiaV9yb3V0ZV9taW50TmZkOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBsaW5rT25NaW50OiBib29sCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglkdXAKCWxlbgoJaW50IDEKCT09CgoJLy8gYXJndW1lbnQgMCAobGlua09uTWludCkgZm9yIG1pbnROZmQgbXVzdCBiZSBhIGJvb2wKCWFzc2VydAoJaW50IDAKCWdldGJpdAoKCS8vIHJlc2VydmVkRm9yOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50IDMyCgk9PQoKCS8vIGFyZ3VtZW50IDEgKHJlc2VydmVkRm9yKSBmb3IgbWludE5mZCBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gbmZkTmFtZTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIHB1cmNoYXNlVHhuOiBwYXkKCXR4biBHcm91cEluZGV4CglpbnQgMQoJLQoJZHVwCglndHhucyBUeXBlRW51bQoJaW50IHBheQoJPT0KCgkvLyBhcmd1bWVudCAzIChwdXJjaGFzZVR4bikgZm9yIG1pbnROZmQgbXVzdCBiZSBhIHBheSB0cmFuc2FjdGlvbgoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBtaW50TmZkKHBheSxzdHJpbmcsYWRkcmVzcyxib29sKXVpbnQ2NAoJY2FsbHN1YiBtaW50TmZkCglpdG9iCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gbWludE5mZChwdXJjaGFzZVR4bjogUGF5VHhuLCBuZmROYW1lOiBzdHJpbmcsIHJlc2VydmVkRm9yOiBBZGRyZXNzLCBsaW5rT25NaW50OiBib29sZWFuKTogdWludDY0Ci8vCi8vIE1pbnQgYW4gTkZEIChORlQpIGFuZCBjcmVhdGUgYSBuZXcgTkZEIGluc3RhbmNlLgovLwovLyBAcGFyYW0ge1BheVR4bn0gcHVyY2hhc2VUeG4gLSBUaGUgcGF5bWVudCB0cmFuc2FjdGlvbiBjb3ZlcmluZyB0aGUgcHVyY2hhc2UgYW1vdW50IG9mIHRoZSBuZmQKLy8gQHBhcmFtIHtzdHJpbmd9IG5mZE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgTkZEIHRvIG1pbnQKLy8gQHBhcmFtIHtBZGRyZXNzfSByZXNlcnZlZEZvciAtIFRoZSBhZGRyZXNzIHRoYXQgd2lsbCBvd24gdGhlIE5GRCBvbmNlIG1pbnRlZCAoc28geW91IGNhbiBidXkgZm9yIHNvbWVvbmUgZWxzZSkKLy8gQHBhcmFtIHtib29sZWFufSBsaW5rT25NaW50IC0gd2hldGhlciB0byBhdXRvLWxpbmsgdGhlIGFkZHJlc3MgKHJlc2VydmVkIGZvciBNVVNUIE1BVENIIHBheWVyISkgYXQgbWludAovLyBAcmV0dXJuIHt1aW50NjR9IC0gVGhlIElEIG9mIHRoZSBuZXdseSBjcmVhdGVkIE5GRCBpbnN0YW5jZS4KbWludE5mZDoKCXByb3RvIDQgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXBuIDE3CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MjY5CgkvLyB2ZXJpZnlQYXlUeG4ocHVyY2hhc2VUeG4sIHsgcmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MgfSkKCS8vIHZlcmlmeSByZWNlaXZlcgoJZnJhbWVfZGlnIC0xIC8vIHB1cmNoYXNlVHhuOiBQYXlUeG4KCWd0eG5zIFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCgkvLyB0cmFuc2FjdGlvbiB2ZXJpZmljYXRpb24gZmFpbGVkOiB7InR4biI6InB1cmNoYXNlVHhuIiwiZmllbGQiOiJyZWNlaXZlciIsImV4cGVjdGVkIjoidGhpcy5hcHAuYWRkcmVzcyJ9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoyNzEKCS8vIGFzc2VydChsZW4ocmVzZXJ2ZWRGb3IpID09PSAzMikKCWludCAzMgoJZHVwCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MjcyCgkvLyBhc3NlcnQocmVzZXJ2ZWRGb3IgIT09IGdsb2JhbHMuemVyb0FkZHJlc3MpCglmcmFtZV9kaWcgLTMgLy8gcmVzZXJ2ZWRGb3I6IEFkZHJlc3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJIT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjI3NAoJLy8gaW5jcmVhc2VPcGNvZGVCdWRnZXQoKQoJaXR4bl9iZWdpbgoJaW50IGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCWludCAwCglpdHhuX2ZpZWxkIEZlZQoJYnl0ZSBiNjQgQ29FQiAvLyAjcHJhZ21hIHZlcnNpb24gMTA7IGludCAxCglkdXAKCWl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtCglpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtCglpbnQgRGVsZXRlQXBwbGljYXRpb24KCWl0eG5fZmllbGQgT25Db21wbGV0aW9uCglpdHhuX3N1Ym1pdAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjI3NwoJLy8gbmZkTmFtZUluZm8gPSB0aGlzLm51bUxldHRlcnNJbk5mZChuZmROYW1lKQoJZnJhbWVfZGlnIC0yIC8vIG5mZE5hbWU6IHN0cmluZwoJY2FsbHN1YiBudW1MZXR0ZXJzSW5OZmQKCWZyYW1lX2J1cnkgMCAvLyBuZmROYW1lSW5mbzogKGJvb2wsdWludDY0LHVpbnQ2NCkKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoyNzkKCS8vIHBhcmVudEFwcElkID0gMAoJaW50IDAKCWZyYW1lX2J1cnkgMSAvLyBwYXJlbnRBcHBJZDogdWludDY0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MjgwCgkvLyBwYXJlbnRQYXlvdXRBZGRyZXNzID0gZ2xvYmFscy56ZXJvQWRkcmVzcwoJZ2xvYmFsIFplcm9BZGRyZXNzCglmcmFtZV9idXJ5IDIgLy8gcGFyZW50UGF5b3V0QWRkcmVzczogYWRkcmVzcwoKCS8vICppZjE1X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MjgyCgkvLyBuZmROYW1lSW5mby5pc1NlZ21lbnQKCWZyYW1lX2RpZyAwIC8vIG5mZE5hbWVJbmZvOiAoYm9vbCx1aW50NjQsdWludDY0KQoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWludCAwCglnZXRiaXQKCWJ6ICppZjE1X2VuZAoKCS8vICppZjE1X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjI4MwoJLy8gaW5jcmVhc2VPcGNvZGVCdWRnZXQoKQoJaXR4bl9iZWdpbgoJaW50IGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCWludCAwCglpdHhuX2ZpZWxkIEZlZQoJYnl0ZSBiNjQgQ29FQiAvLyAjcHJhZ21hIHZlcnNpb24gMTA7IGludCAxCglkdXAKCWl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtCglpdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtCglpbnQgRGVsZXRlQXBwbGljYXRpb24KCWl0eG5fZmllbGQgT25Db21wbGV0aW9uCglpdHhuX3N1Ym1pdAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjI4NQoJLy8gcGFyZW50QXBwSWQgPSB0aGlzLmZldGNoQXBwSWRGb3JOYW1lKHRoaXMuZnJvbU5hbWVJbmZvR2V0UGFyZW50TmFtZShuZmROYW1lLCBuZmROYW1lSW5mbykpCglmcmFtZV9kaWcgMCAvLyBuZmROYW1lSW5mbzogKGJvb2wsdWludDY0LHVpbnQ2NCkKCWZyYW1lX2RpZyAtMiAvLyBuZmROYW1lOiBzdHJpbmcKCWNhbGxzdWIgZnJvbU5hbWVJbmZvR2V0UGFyZW50TmFtZQoJY2FsbHN1YiBmZXRjaEFwcElkRm9yTmFtZQoJZnJhbWVfYnVyeSAxIC8vIHBhcmVudEFwcElkOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoyODYKCS8vIGFzc2VydChwYXJlbnRBcHBJZCAhPT0gMCwgJ3BhcmVudCBuZmQvaWQgbXVzdCBiZSBmb3VuZCcpCglmcmFtZV9kaWcgMSAvLyBwYXJlbnRBcHBJZDogdWludDY0CglpbnQgMAoJIT0KCgkvLyBwYXJlbnQgbmZkL2lkIG11c3QgYmUgZm91bmQKCWFzc2VydAoKCS8vICppZjE2X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6Mjg5CgkvLyB0aGlzLnNhZmVHbG9iYWxCeXRlR2V0RXgocGFyZW50QXBwSWQsIE5GRF9LRVlfSVNTRUdNRU5UTE9DS0VEKSA9PT0gTkZEX0xPQ0tFRF9WQUxfRkFMU0UKCWJ5dGUgImkuc2VnbWVudExvY2tlZCIKCWZyYW1lX2RpZyAxIC8vIHBhcmVudEFwcElkOiB1aW50NjQKCWNhbGxzdWIgc2FmZUdsb2JhbEJ5dGVHZXRFeAoJYnl0ZSAiMCIKCT09CglieiAqaWYxNl9lbHNlCgoJLy8gKmlmMTZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MjkwCgkvLyBwYXJlbnRQYXlvdXRBZGRyZXNzID0gQXBwSUQuZnJvbVVpbnQ2NChwYXJlbnRBcHBJZCkuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUxMRVIpIGFzIEFkZHJlc3MKCWZyYW1lX2RpZyAxIC8vIHBhcmVudEFwcElkOiB1aW50NjQKCWJ5dGUgImkuc2VsbGVyLmEiCglhcHBfZ2xvYmFsX2dldF9leAoKCS8vIGdsb2JhbCBzdGF0ZSB2YWx1ZSBkb2VzIG5vdCBleGlzdDogQXBwSUQuZnJvbVVpbnQ2NChwYXJlbnRBcHBJZCkuZ2xvYmFsU3RhdGUoTkZEX0tFWV9TRUxMRVIpCglhc3NlcnQKCWZyYW1lX2J1cnkgMiAvLyBwYXJlbnRQYXlvdXRBZGRyZXNzOiBhZGRyZXNzCgliICppZjE2X2VuZAoKKmlmMTZfZWxzZToKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjI5MwoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgICAgICAgICBwdXJjaGFzZVR4bi5zZW5kZXIgPT09IEFwcElELmZyb21VaW50NjQocGFyZW50QXBwSWQpLmdsb2JhbFN0YXRlKE5GRF9LRVlfT1dORVIpLAoJLy8gICAgICAgICAgICAgICAgICAgICAnb25seSBvd25lciBvZiByb290IGNhbiBtaW50IHNlZ21lbnRzIGlmIHNlZ21lbnRzIGFyZSBsb2NrZWQnLAoJLy8gICAgICAgICAgICAgICAgICkKCWZyYW1lX2RpZyAtMSAvLyBwdXJjaGFzZVR4bjogUGF5VHhuCglndHhucyBTZW5kZXIKCWZyYW1lX2RpZyAxIC8vIHBhcmVudEFwcElkOiB1aW50NjQKCWJ5dGUgImkub3duZXIuYSIKCWFwcF9nbG9iYWxfZ2V0X2V4CgoJLy8gZ2xvYmFsIHN0YXRlIHZhbHVlIGRvZXMgbm90IGV4aXN0OiBBcHBJRC5mcm9tVWludDY0KHBhcmVudEFwcElkKS5nbG9iYWxTdGF0ZShORkRfS0VZX09XTkVSKQoJYXNzZXJ0Cgk9PQoKCS8vIG9ubHkgb3duZXIgb2Ygcm9vdCBjYW4gbWludCBzZWdtZW50cyBpZiBzZWdtZW50cyBhcmUgbG9ja2VkCglhc3NlcnQKCippZjE2X2VuZDoKCippZjE1X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjMwMQoJLy8gb25lWWVhclByaWNlID0gdGhpcy5nZXRQcmljZUZvck5hbWUobmZkTmFtZSwgbmZkTmFtZUluZm8sIHRoaXMudHhuLnNlbmRlcikub25lWWVhclByaWNlCgl0eG4gU2VuZGVyCglmcmFtZV9kaWcgMCAvLyBuZmROYW1lSW5mbzogKGJvb2wsdWludDY0LHVpbnQ2NCkKCWZyYW1lX2RpZyAtMiAvLyBuZmROYW1lOiBzdHJpbmcKCWNhbGxzdWIgZ2V0UHJpY2VGb3JOYW1lCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWZyYW1lX2J1cnkgMyAvLyBvbmVZZWFyUHJpY2U6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjMwMgoJLy8gYXNzZXJ0KG9uZVllYXJQcmljZSA+IDAsICdwcmljZSBjYW4gbmV2ZXIgYmUgMCcpCglmcmFtZV9kaWcgMyAvLyBvbmVZZWFyUHJpY2U6IHVpbnQ2NAoJaW50IDAKCT4KCgkvLyBwcmljZSBjYW4gbmV2ZXIgYmUgMAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MzA1CgkvLyBuZmRNYnJDb3N0ID0gdGhpcy5nZXROZmRNYnJDb3N0KG5mZE5hbWUpCglmcmFtZV9kaWcgLTIgLy8gbmZkTmFtZTogc3RyaW5nCgljYWxsc3ViIGdldE5mZE1ickNvc3QKCWZyYW1lX2J1cnkgNCAvLyBuZmRNYnJDb3N0OiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czozMDYKCS8vIGxpbmtpbmdOZmRNYnJDb3N0ID0gMAoJaW50IDAKCWZyYW1lX2J1cnkgNSAvLyBsaW5raW5nTmZkTWJyQ29zdDogdWludDY0CgoJLy8gKmlmMTdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czozMDcKCS8vIGxpbmtPbk1pbnQKCWZyYW1lX2RpZyAtNCAvLyBsaW5rT25NaW50OiBib29sZWFuCglieiAqaWYxN19lbmQKCgkvLyAqaWYxN19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czozMDgKCS8vIGV4dHJhTWJyQ29zdHMgPSB0aGlzLmdldE5mZExpbmtPbk1pbnRFeHRyYU1ickNvc3QodGhpcy50eG4uc2VuZGVyKQoJdHhuIFNlbmRlcgoJY2FsbHN1YiBnZXROZmRMaW5rT25NaW50RXh0cmFNYnJDb3N0CglmcmFtZV9idXJ5IDYgLy8gZXh0cmFNYnJDb3N0czogKHVpbnQ2NCx1aW50NjQpCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MzA5CgkvLyBsaW5raW5nTmZkTWJyQ29zdCA9IGV4dHJhTWJyQ29zdHMubGlua2luZ05mZE1ickNvc3QKCWZyYW1lX2RpZyA2IC8vIGV4dHJhTWJyQ29zdHM6ICh1aW50NjQsdWludDY0KQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWZyYW1lX2J1cnkgNSAvLyBsaW5raW5nTmZkTWJyQ29zdDogdWludDY0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MzEwCgkvLyBuZmRNYnJDb3N0ICs9IGV4dHJhTWJyQ29zdHMubGlua2luZ05mZE1ickNvc3QgKyBleHRyYU1ickNvc3RzLmxpbmtpbmdSZWdpc3RyeU1ickNvc3QKCWZyYW1lX2RpZyA0IC8vIG5mZE1ickNvc3Q6IHVpbnQ2NAoJZnJhbWVfZGlnIDYgLy8gZXh0cmFNYnJDb3N0czogKHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDAgOAoJYnRvaQoJZnJhbWVfZGlnIDYgLy8gZXh0cmFNYnJDb3N0czogKHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDggOAoJYnRvaQoJKwoJKwoJZnJhbWVfYnVyeSA0IC8vIG5mZE1ickNvc3Q6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjMxMQoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgICAgIHRoaXMudHhuLnNlbmRlciA9PT0gcmVzZXJ2ZWRGb3IsCgkvLyAgICAgICAgICAgICAgICAgJ2lmIGxpbmtpbmcgb24gbWludCwgdGhlIGJ1eWVyIE1VU1QgYmUgd2hvIHdpbGwgYmUgdGhlIG93bmVyIChyZXNlcnZlZEZvciknLAoJLy8gICAgICAgICAgICAgKQoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0zIC8vIHJlc2VydmVkRm9yOiBBZGRyZXNzCgk9PQoKCS8vIGlmIGxpbmtpbmcgb24gbWludCwgdGhlIGJ1eWVyIE1VU1QgYmUgd2hvIHdpbGwgYmUgdGhlIG93bmVyIChyZXNlcnZlZEZvcikKCWFzc2VydAoKKmlmMTdfZW5kOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MzE3CgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICAoMzY1ICogKHB1cmNoYXNlVHhuLmFtb3VudCAtIG5mZE1ickNvc3QpKSAvIG9uZVllYXJQcmljZSA+PSAzMCwKCS8vICAgICAgICAgICAgICdwYXltZW50IHRyYW5zYWN0aW9uIG11c3QgYmUgYXQgbGVhc3QgZW5vdWdoIHRvIGNvdmVyIDMwIGRheXMgb2YgbmZkIGNvc3QgKyBjYXJyeSBjb3N0JywKCS8vICAgICAgICAgKQoJaW50IDM2NQoJZnJhbWVfZGlnIC0xIC8vIHB1cmNoYXNlVHhuOiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJZnJhbWVfZGlnIDQgLy8gbmZkTWJyQ29zdDogdWludDY0CgktCgkqCglmcmFtZV9kaWcgMyAvLyBvbmVZZWFyUHJpY2U6IHVpbnQ2NAoJLwoJaW50IDMwCgk+PQoKCS8vIHBheW1lbnQgdHJhbnNhY3Rpb24gbXVzdCBiZSBhdCBsZWFzdCBlbm91Z2ggdG8gY292ZXIgMzAgZGF5cyBvZiBuZmQgY29zdCArIGNhcnJ5IGNvc3QKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjMyNAoJLy8gY3VycmVudENvbnRyYWN0VmVyID0gdGhpcy5ib3hlcyhSRUdJU1RSWV9DT05UUkFDVF9CT1hfQ1VSUkVOVF9DT05UUkFDVCkudmFsdWUgYXMgYnl0ZXMKCWJ5dGUgImN1cnJlbnQiCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLmJveGVzKFJFR0lTVFJZX0NPTlRSQUNUX0JPWF9DVVJSRU5UX0NPTlRSQUNUKS52YWx1ZQoJYXNzZXJ0CglmcmFtZV9idXJ5IDcgLy8gY3VycmVudENvbnRyYWN0VmVyOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czozMjUKCS8vIGFwcHJvdlByb2dOYW1lID0gY29uY2F0KAoJLy8gICAgICAgICAgICAgUkVHSVNUUllfQ09OVFJBQ1RfQk9YX0FQUFJPVkFMX05BTUVQUkVGSVgsCgkvLyAgICAgICAgICAgICB0aGlzLmJveGVzKFJFR0lTVFJZX0NPTlRSQUNUX0JPWF9DVVJSRU5UX0NPTlRSQUNUKS52YWx1ZSBhcyBieXRlcywKCS8vICAgICAgICAgKQoJYnl0ZSAiY29udHJhY3Q6QToiCglieXRlICJjdXJyZW50IgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5ib3hlcyhSRUdJU1RSWV9DT05UUkFDVF9CT1hfQ1VSUkVOVF9DT05UUkFDVCkudmFsdWUKCWFzc2VydAoJY29uY2F0CglmcmFtZV9idXJ5IDggLy8gYXBwcm92UHJvZ05hbWU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjMyOQoJLy8gY2xlYXJQcm9nID0gdGhpcy5ib3hlcyhjb25jYXQoUkVHSVNUUllfQ09OVFJBQ1RfQk9YX0NMRUFSX05BTUVQUkVGSVgsIGN1cnJlbnRDb250cmFjdFZlcikpLnZhbHVlIGFzIGJ5dGVzCglieXRlICJjb250cmFjdDpDOiIKCWZyYW1lX2RpZyA3IC8vIGN1cnJlbnRDb250cmFjdFZlcjogYnl0ZVtdCgljb25jYXQKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuYm94ZXMoY29uY2F0KFJFR0lTVFJZX0NPTlRSQUNUX0JPWF9DTEVBUl9OQU1FUFJFRklYLCBjdXJyZW50Q29udHJhY3RWZXIpKS52YWx1ZQoJYXNzZXJ0CglmcmFtZV9idXJ5IDkgLy8gY2xlYXJQcm9nOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czozMzAKCS8vIGFwcHJvdlByb2dMZW5ndGggPSB0aGlzLmJveGVzKGFwcHJvdlByb2dOYW1lKS5zaXplCglmcmFtZV9kaWcgOCAvLyBhcHByb3ZQcm9nTmFtZTogYnl0ZVtdCglib3hfbGVuCgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLmJveGVzKGFwcHJvdlByb2dOYW1lKS5zaXplCglhc3NlcnQKCWZyYW1lX2J1cnkgMTAgLy8gYXBwcm92UHJvZ0xlbmd0aDogdWludDY0CgoJLy8gKmlmMThfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czozMzIKCS8vIGdsb2JhbHMub3Bjb2RlQnVkZ2V0IDwgMjAwCglnbG9iYWwgT3Bjb2RlQnVkZ2V0CglpbnQgMjAwCgk8CglieiAqaWYxOF9lbmQKCgkvLyAqaWYxOF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czozMzMKCS8vIGluY3JlYXNlT3Bjb2RlQnVkZ2V0KCkKCWl0eG5fYmVnaW4KCWludCBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCWJ5dGUgYjY0IENvRUIgLy8gI3ByYWdtYSB2ZXJzaW9uIDEwOyBpbnQgMQoJZHVwCglpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQoJaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbQoJaW50IERlbGV0ZUFwcGxpY2F0aW9uCglpdHhuX2ZpZWxkIE9uQ29tcGxldGlvbgoJaXR4bl9zdWJtaXQKCippZjE4X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjMzNgoJLy8gZXhwVGltZSA9IHRoaXMuY2FsY0V4cGlyYXRpb24oCgkvLyAgICAgICAgICAgICBvbmVZZWFyUHJpY2UsCgkvLyAgICAgICAgICAgICBwdXJjaGFzZVR4bi5hbW91bnQgLSBuZmRNYnJDb3N0LAoJLy8gICAgICAgICAgICAgZ2xvYmFscy5sYXRlc3RUaW1lc3RhbXAsCgkvLyAgICAgICAgICAgICBORkRfTUFYX0VYUElSQVRJT05fWUVBUlMsCgkvLyAgICAgICAgICkKCWludCAyMAoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJZnJhbWVfZGlnIC0xIC8vIHB1cmNoYXNlVHhuOiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJZnJhbWVfZGlnIDQgLy8gbmZkTWJyQ29zdDogdWludDY0CgktCglmcmFtZV9kaWcgMyAvLyBvbmVZZWFyUHJpY2U6IHVpbnQ2NAoJY2FsbHN1YiBjYWxjRXhwaXJhdGlvbgoJZnJhbWVfYnVyeSAxMSAvLyBleHBUaW1lOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czozNDMKCS8vIHNlbmRBcHBDYWxsKHsKCS8vICAgICAgICAgICAgIG9uQ29tcGxldGlvbjogT25Db21wbGV0aW9uLk5vT3AsCgkvLyAgICAgICAgICAgICBhcHByb3ZhbFByb2dyYW06IFsKCS8vICAgICAgICAgICAgICAgICB0aGlzLmJveGVzKGFwcHJvdlByb2dOYW1lKS5leHRyYWN0KDAsIDQwOTYpLAoJLy8gICAgICAgICAgICAgICAgIHRoaXMuYm94ZXMoYXBwcm92UHJvZ05hbWUpLmV4dHJhY3QoNDA5NiwgYXBwcm92UHJvZ0xlbmd0aCAtIDQwOTYpLAoJLy8gICAgICAgICAgICAgXSwKCS8vICAgICAgICAgICAgIGNsZWFyU3RhdGVQcm9ncmFtOiBjbGVhclByb2csCgkvLyAgICAgICAgICAgICBnbG9iYWxOdW1VaW50OiBORkRJbnN0YW5jZS5zY2hlbWEuZ2xvYmFsLm51bVVpbnQsCgkvLyAgICAgICAgICAgICBnbG9iYWxOdW1CeXRlU2xpY2U6IE5GREluc3RhbmNlLnNjaGVtYS5nbG9iYWwubnVtQnl0ZVNsaWNlLAoJLy8gICAgICAgICAgICAgZXh0cmFQcm9ncmFtUGFnZXM6IDMsCgkvLyAgICAgICAgICAgICBhcHBsaWNhdGlvbkFyZ3M6IFsKCS8vICAgICAgICAgICAgICAgICAvLyBuZmROYW1lOiBzdHJpbmcsCgkvLyAgICAgICAgICAgICAgICAgLy8gc2VsbGVyOiBBZGRyZXNzLCAvLyB0cmVhc3VyeSBhZGRyZXNzCgkvLyAgICAgICAgICAgICAgICAgLy8gYnV5ZXI6IEFkZHJlc3MsIC8vIChidXllciAvIHJlc2VydmVkLWZvciBhZGRyZXNzCgkvLyAgICAgICAgICAgICAgICAgLy8ga2lja29mZkFtb3VudDogdWludDY0LCAvLyBwYXNzIHdoYXQgdGhleSBQQUlEIG1pbnVzIE1CUiBhbW91bnRzICEhCgkvLyAgICAgICAgICAgICAgICAgLy8gZXhwVGltZTogdWludDY0LCAvLyBleHBpcmF0aW9uIHRpbWUgdG8gc2V0IGludG8gY29udHJhY3QKCS8vICAgICAgICAgICAgICAgICAvLyBjb21taXNzaW9uMUFkZHI6IEFkZHJlc3MsIC8vIGNvbW1pc3Npb24gYWdlbnQgcHJpbWFyeQoJLy8gICAgICAgICAgICAgICAgIC8vIGNvbW1pc3Npb24xUGN0OiB1aW50NjQsIC8vIGNvbW1pc3Npb24gJSAtIHNpbmdsZSBkZWNpbWFsIC0gaWU6IDI1IGlzIDIuNSUKCS8vICAgICAgICAgICAgICAgICAvLyBjb21taXNzaW9uMkFkZHI6IEFkZHJlc3MsIC8vIGNvbW1pc3Npb24gYWdlbnQgc2Vjb25kYXJ5CgkvLyAgICAgICAgICAgICAgICAgLy8gY29tbWlzc2lvbjJQY3Q6IHVpbnQ2NCwgLy8gY29tbWlzc2lvbiAlIC0gc2luZ2xlIGRlY2ltYWwgLSBpZTogMjUgaXMgMi41JQoJLy8gICAgICAgICAgICAgICAgIC8vIHNlZ21lbnRSb290QXBwSWQ6IHVpbnQ2NCwgLy8gcGFyZW50IGFwcCBpZCBvZiBzZWdtZW50IG9yIDAgLSBjb21taXNzaW9uIG9uIHNlZ21lbnQgaXMgb25seSBpZiBvcGVuIHNlZ21lbnQKCS8vICAgICAgICAgICAgICAgICAvLyBzZWdtZW50Um9vdENvbW1pc3Npb25BZGRyOiBBZGRyZXNzLCAvLyBvcGVuIHNlZ21lbnQgcGFyZW50IGNvbW1pc3Npb24gYWdlbnQgb3IgWkVSTyBBRERSRVNTIElGIE5PVCBVU0VECgkvLyAgICAgICAgICAgICAgICAgbWV0aG9kKAoJLy8gICAgICAgICAgICAgICAgICAgICAnY3JlYXRlQXBwbGljYXRpb24oc3RyaW5nLGFkZHJlc3MsYWRkcmVzcyx1aW50NjQsdWludDY0LGFkZHJlc3MsdWludDY0LGFkZHJlc3MsdWludDY0LHVpbnQ2NCxhZGRyZXNzKXZvaWQnLAoJLy8gICAgICAgICAgICAgICAgICksCgkvLyAgICAgICAgICAgICAgICAgcmF3Qnl0ZXMobmZkTmFtZSksCgkvLyAgICAgICAgICAgICAgICAgcmF3Qnl0ZXModGhpcy5uZmRUcmVhc3VyeUFkZHIpLAoJLy8gICAgICAgICAgICAgICAgIHJhd0J5dGVzKHJlc2VydmVkRm9yKSwKCS8vICAgICAgICAgICAgICAgICAvLyB0aGlzIG5leHQgdmFsdWUgd2lsbCBiZSB3aGF0IHRoZSBORkQgd2lsbCBiZSAnb24gc2FsZSBmb3InIGF0IGNyZWF0ZSAhIGFuZCBpcyB1c2VkIGFzIHBhcnQgb2YgbGF0ZXIKCS8vICAgICAgICAgICAgICAgICAvLyBwYXlvdXRzIGluIG1pbnRQYXlvdXQgY2FsbAoJLy8gICAgICAgICAgICAgICAgIGl0b2IocHVyY2hhc2VUeG4uYW1vdW50IC0gbmZkTWJyQ29zdCksCgkvLyAgICAgICAgICAgICAgICAgaXRvYihleHBUaW1lKSwKCS8vICAgICAgICAgICAgICAgICByYXdCeXRlcyh0aGlzLm5mZENvbW1pc3Npb24xQWRkciksCgkvLyAgICAgICAgICAgICAgICAgaXRvYih0aGlzLm5mZENvbW1pc3Npb24xUmF0ZSksCgkvLyAgICAgICAgICAgICAgICAgLy8gbm8gc2Vjb25kYXJ5IGNvbW1pc3Npb25zICEKCS8vICAgICAgICAgICAgICAgICByYXdCeXRlcyhnbG9iYWxzLnplcm9BZGRyZXNzKSwKCS8vICAgICAgICAgICAgICAgICBpdG9iKDApLAoJLy8gICAgICAgICAgICAgICAgIC8vCgkvLyAgICAgICAgICAgICAgICAgaXRvYihwYXJlbnRBcHBJZCksCgkvLyAgICAgICAgICAgICAgICAgcmF3Qnl0ZXMocGFyZW50UGF5b3V0QWRkcmVzcyksCgkvLyAgICAgICAgICAgICBdLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czozNDQKCS8vIG9uQ29tcGxldGlvbjogT25Db21wbGV0aW9uLk5vT3AKCWludCAwIC8vIE5vT3AKCWl0eG5fZmllbGQgT25Db21wbGV0aW9uCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MzQ1CgkvLyBhcHByb3ZhbFByb2dyYW06IFsKCS8vICAgICAgICAgICAgICAgICB0aGlzLmJveGVzKGFwcHJvdlByb2dOYW1lKS5leHRyYWN0KDAsIDQwOTYpLAoJLy8gICAgICAgICAgICAgICAgIHRoaXMuYm94ZXMoYXBwcm92UHJvZ05hbWUpLmV4dHJhY3QoNDA5NiwgYXBwcm92UHJvZ0xlbmd0aCAtIDQwOTYpLAoJLy8gICAgICAgICAgICAgXQoJZnJhbWVfZGlnIDggLy8gYXBwcm92UHJvZ05hbWU6IGJ5dGVbXQoJaW50IDAKCWludCA0MDk2Cglib3hfZXh0cmFjdAoJaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW1QYWdlcwoJZnJhbWVfZGlnIDggLy8gYXBwcm92UHJvZ05hbWU6IGJ5dGVbXQoJaW50IDQwOTYKCWZyYW1lX2RpZyAxMCAvLyBhcHByb3ZQcm9nTGVuZ3RoOiB1aW50NjQKCWludCA0MDk2CgktCglib3hfZXh0cmFjdAoJaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW1QYWdlcwoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjM0OQoJLy8gY2xlYXJTdGF0ZVByb2dyYW06IGNsZWFyUHJvZwoJZnJhbWVfZGlnIDkgLy8gY2xlYXJQcm9nOiBieXRlW10KCWl0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czozNTAKCS8vIGdsb2JhbE51bVVpbnQ6IE5GREluc3RhbmNlLnNjaGVtYS5nbG9iYWwubnVtVWludAoJaW50IDAKCWl0eG5fZmllbGQgR2xvYmFsTnVtVWludAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjM1MQoJLy8gZ2xvYmFsTnVtQnl0ZVNsaWNlOiBORkRJbnN0YW5jZS5zY2hlbWEuZ2xvYmFsLm51bUJ5dGVTbGljZQoJaW50IDMwCglpdHhuX2ZpZWxkIEdsb2JhbE51bUJ5dGVTbGljZQoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjM1MgoJLy8gZXh0cmFQcm9ncmFtUGFnZXM6IDMKCWludCAzCglpdHhuX2ZpZWxkIEV4dHJhUHJvZ3JhbVBhZ2VzCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MzUzCgkvLyBhcHBsaWNhdGlvbkFyZ3M6IFsKCS8vICAgICAgICAgICAgICAgICAvLyBuZmROYW1lOiBzdHJpbmcsCgkvLyAgICAgICAgICAgICAgICAgLy8gc2VsbGVyOiBBZGRyZXNzLCAvLyB0cmVhc3VyeSBhZGRyZXNzCgkvLyAgICAgICAgICAgICAgICAgLy8gYnV5ZXI6IEFkZHJlc3MsIC8vIChidXllciAvIHJlc2VydmVkLWZvciBhZGRyZXNzCgkvLyAgICAgICAgICAgICAgICAgLy8ga2lja29mZkFtb3VudDogdWludDY0LCAvLyBwYXNzIHdoYXQgdGhleSBQQUlEIG1pbnVzIE1CUiBhbW91bnRzICEhCgkvLyAgICAgICAgICAgICAgICAgLy8gZXhwVGltZTogdWludDY0LCAvLyBleHBpcmF0aW9uIHRpbWUgdG8gc2V0IGludG8gY29udHJhY3QKCS8vICAgICAgICAgICAgICAgICAvLyBjb21taXNzaW9uMUFkZHI6IEFkZHJlc3MsIC8vIGNvbW1pc3Npb24gYWdlbnQgcHJpbWFyeQoJLy8gICAgICAgICAgICAgICAgIC8vIGNvbW1pc3Npb24xUGN0OiB1aW50NjQsIC8vIGNvbW1pc3Npb24gJSAtIHNpbmdsZSBkZWNpbWFsIC0gaWU6IDI1IGlzIDIuNSUKCS8vICAgICAgICAgICAgICAgICAvLyBjb21taXNzaW9uMkFkZHI6IEFkZHJlc3MsIC8vIGNvbW1pc3Npb24gYWdlbnQgc2Vjb25kYXJ5CgkvLyAgICAgICAgICAgICAgICAgLy8gY29tbWlzc2lvbjJQY3Q6IHVpbnQ2NCwgLy8gY29tbWlzc2lvbiAlIC0gc2luZ2xlIGRlY2ltYWwgLSBpZTogMjUgaXMgMi41JQoJLy8gICAgICAgICAgICAgICAgIC8vIHNlZ21lbnRSb290QXBwSWQ6IHVpbnQ2NCwgLy8gcGFyZW50IGFwcCBpZCBvZiBzZWdtZW50IG9yIDAgLSBjb21taXNzaW9uIG9uIHNlZ21lbnQgaXMgb25seSBpZiBvcGVuIHNlZ21lbnQKCS8vICAgICAgICAgICAgICAgICAvLyBzZWdtZW50Um9vdENvbW1pc3Npb25BZGRyOiBBZGRyZXNzLCAvLyBvcGVuIHNlZ21lbnQgcGFyZW50IGNvbW1pc3Npb24gYWdlbnQgb3IgWkVSTyBBRERSRVNTIElGIE5PVCBVU0VECgkvLyAgICAgICAgICAgICAgICAgbWV0aG9kKAoJLy8gICAgICAgICAgICAgICAgICAgICAnY3JlYXRlQXBwbGljYXRpb24oc3RyaW5nLGFkZHJlc3MsYWRkcmVzcyx1aW50NjQsdWludDY0LGFkZHJlc3MsdWludDY0LGFkZHJlc3MsdWludDY0LHVpbnQ2NCxhZGRyZXNzKXZvaWQnLAoJLy8gICAgICAgICAgICAgICAgICksCgkvLyAgICAgICAgICAgICAgICAgcmF3Qnl0ZXMobmZkTmFtZSksCgkvLyAgICAgICAgICAgICAgICAgcmF3Qnl0ZXModGhpcy5uZmRUcmVhc3VyeUFkZHIpLAoJLy8gICAgICAgICAgICAgICAgIHJhd0J5dGVzKHJlc2VydmVkRm9yKSwKCS8vICAgICAgICAgICAgICAgICAvLyB0aGlzIG5leHQgdmFsdWUgd2lsbCBiZSB3aGF0IHRoZSBORkQgd2lsbCBiZSAnb24gc2FsZSBmb3InIGF0IGNyZWF0ZSAhIGFuZCBpcyB1c2VkIGFzIHBhcnQgb2YgbGF0ZXIKCS8vICAgICAgICAgICAgICAgICAvLyBwYXlvdXRzIGluIG1pbnRQYXlvdXQgY2FsbAoJLy8gICAgICAgICAgICAgICAgIGl0b2IocHVyY2hhc2VUeG4uYW1vdW50IC0gbmZkTWJyQ29zdCksCgkvLyAgICAgICAgICAgICAgICAgaXRvYihleHBUaW1lKSwKCS8vICAgICAgICAgICAgICAgICByYXdCeXRlcyh0aGlzLm5mZENvbW1pc3Npb24xQWRkciksCgkvLyAgICAgICAgICAgICAgICAgaXRvYih0aGlzLm5mZENvbW1pc3Npb24xUmF0ZSksCgkvLyAgICAgICAgICAgICAgICAgLy8gbm8gc2Vjb25kYXJ5IGNvbW1pc3Npb25zICEKCS8vICAgICAgICAgICAgICAgICByYXdCeXRlcyhnbG9iYWxzLnplcm9BZGRyZXNzKSwKCS8vICAgICAgICAgICAgICAgICBpdG9iKDApLAoJLy8gICAgICAgICAgICAgICAgIC8vCgkvLyAgICAgICAgICAgICAgICAgaXRvYihwYXJlbnRBcHBJZCksCgkvLyAgICAgICAgICAgICAgICAgcmF3Qnl0ZXMocGFyZW50UGF5b3V0QWRkcmVzcyksCgkvLyAgICAgICAgICAgICBdCgltZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKHN0cmluZyxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsYWRkcmVzcyl2b2lkIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWZyYW1lX2RpZyAtMiAvLyBuZmROYW1lOiBzdHJpbmcKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJbG9hZCAyMDEgLy8gVE1QTF9uZmRUcmVhc3VyeUFkZHIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCglmcmFtZV9kaWcgLTMgLy8gcmVzZXJ2ZWRGb3I6IEFkZHJlc3MKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCglmcmFtZV9kaWcgLTEgLy8gcHVyY2hhc2VUeG46IFBheVR4bgoJZ3R4bnMgQW1vdW50CglmcmFtZV9kaWcgNCAvLyBuZmRNYnJDb3N0OiB1aW50NjQKCS0KCWl0b2IKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCglmcmFtZV9kaWcgMTEgLy8gZXhwVGltZTogdWludDY0CglpdG9iCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJbG9hZCAyMDIgLy8gVE1QTF9uZmRDb21taXNzaW9uMUFkZHIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCglsb2FkIDIwMyAvLyBUTVBMX25mZENvbW1pc3Npb24xUmF0ZQoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWdsb2JhbCBaZXJvQWRkcmVzcwoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWJ5dGUgMHgwMDAwMDAwMDAwMDAwMDAwCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIDEgLy8gcGFyZW50QXBwSWQ6IHVpbnQ2NAoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWZyYW1lX2RpZyAyIC8vIHBhcmVudFBheW91dEFkZHJlc3M6IGFkZHJlc3MKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjM4NwoJLy8gbmZkQXBwSWQgPSB0aGlzLml0eG4uY3JlYXRlZEFwcGxpY2F0aW9uSUQuaWQKCWl0eG4gQ3JlYXRlZEFwcGxpY2F0aW9uSUQKCWZyYW1lX2J1cnkgMTIgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjM4OAoJLy8gbmZkU0NBZGRyZXNzID0gdGhpcy5pdHhuLmNyZWF0ZWRBcHBsaWNhdGlvbklELmFkZHJlc3MKCWl0eG4gQ3JlYXRlZEFwcGxpY2F0aW9uSUQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJZnJhbWVfYnVyeSAxMyAvLyBuZmRTQ0FkZHJlc3M6IGFkZHJlc3MKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czozODkKCS8vIG5mZEluc3RhbmNlTWJyID0gdGhpcy5nZXROZmRJbnN0YW5jZU1icigpCgljYWxsc3ViIGdldE5mZEluc3RhbmNlTWJyCglmcmFtZV9idXJ5IDE0IC8vIG5mZEluc3RhbmNlTWJyOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czozOTcKCS8vIHNlbmRQYXltZW50KHsKCS8vICAgICAgICAgICAgIGFtb3VudDogcHVyY2hhc2VUeG4uYW1vdW50IC0gbmZkTWJyQ29zdCArIG5mZEluc3RhbmNlTWJyICsgbGlua2luZ05mZE1ickNvc3QsCgkvLyAgICAgICAgICAgICByZWNlaXZlcjogbmZkU0NBZGRyZXNzLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjM5OAoJLy8gYW1vdW50OiBwdXJjaGFzZVR4bi5hbW91bnQgLSBuZmRNYnJDb3N0ICsgbmZkSW5zdGFuY2VNYnIgKyBsaW5raW5nTmZkTWJyQ29zdAoJZnJhbWVfZGlnIC0xIC8vIHB1cmNoYXNlVHhuOiBQYXlUeG4KCWd0eG5zIEFtb3VudAoJZnJhbWVfZGlnIDQgLy8gbmZkTWJyQ29zdDogdWludDY0CgktCglmcmFtZV9kaWcgMTQgLy8gbmZkSW5zdGFuY2VNYnI6IHVpbnQ2NAoJKwoJZnJhbWVfZGlnIDUgLy8gbGlua2luZ05mZE1ickNvc3Q6IHVpbnQ2NAoJKwoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czozOTkKCS8vIHJlY2VpdmVyOiBuZmRTQ0FkZHJlc3MKCWZyYW1lX2RpZyAxMyAvLyBuZmRTQ0FkZHJlc3M6IGFkZHJlc3MKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NDAyCgkvLyBzZW5kTWV0aG9kQ2FsbDx0eXBlb2YgTkZESW5zdGFuY2UucHJvdG90eXBlLm1pbnRBc2E+KHsKCS8vICAgICAgICAgICAgIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQobmZkQXBwSWQpLAoJLy8gICAgICAgICAgICAgbWV0aG9kQXJnczogWwoJLy8gICAgICAgICAgICAgICAgIHRoaXMuY29uZGVuc2VkQXNhTmFtZShuZmROYW1lKSwgLy8gPD0zMiBjaGFycyAoaWYgbG9uZ2VyIGVuZHMgbGlrZSBsb25nbmFtZS4uLmFsZ28pCgkvLyAgICAgICAgICAgICAgICAgJ3RlbXBsYXRlLWlwZnM6Ly97aXBmc2NpZDoxOmRhZy1wYjpyZXNlcnZlOnNoYTItMjU2fS9uZmQuanNvbicsCgkvLyAgICAgICAgICAgICBdLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCW1ldGhvZCAibWludEFzYShzdHJpbmcsc3RyaW5nKXZvaWQiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjQwMwoJLy8gYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJZCkKCWZyYW1lX2RpZyAxMiAvLyBuZmRBcHBJZDogdWludDY0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo0MDQKCS8vIG1ldGhvZEFyZ3M6IFsKCS8vICAgICAgICAgICAgICAgICB0aGlzLmNvbmRlbnNlZEFzYU5hbWUobmZkTmFtZSksIC8vIDw9MzIgY2hhcnMgKGlmIGxvbmdlciBlbmRzIGxpa2UgbG9uZ25hbWUuLi5hbGdvKQoJLy8gICAgICAgICAgICAgICAgICd0ZW1wbGF0ZS1pcGZzOi8ve2lwZnNjaWQ6MTpkYWctcGI6cmVzZXJ2ZTpzaGEyLTI1Nn0vbmZkLmpzb24nLAoJLy8gICAgICAgICAgICAgXQoJZnJhbWVfZGlnIC0yIC8vIG5mZE5hbWU6IHN0cmluZwoJY2FsbHN1YiBjb25kZW5zZWRBc2FOYW1lCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWJ5dGUgMHgwMDNjNzQ2NTZkNzA2YzYxNzQ2NTJkNjk3MDY2NzMzYTJmMmY3YjY5NzA2NjczNjM2OTY0M2EzMTNhNjQ2MTY3MmQ3MDYyM2E3MjY1NzM2NTcyNzY2NTNhNzM2ODYxMzIyZDMyMzUzNjdkMmY2ZTY2NjQyZTZhNzM2ZjZlCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo0MTAKCS8vIG5mZEFzYUlkID0gYnRvaSh0aGlzLml0eG4ubGFzdExvZykKCWl0eG4gTGFzdExvZwoJYnRvaQoJZnJhbWVfYnVyeSAxNSAvLyBuZmRBc2FJZDogdWludDY0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NDEzCgkvLyB0aGlzLmFzc2lnbk5hbWVUb1JlZ2lzdHJ5KG5mZE5hbWUsIG5mZEFzYUlkLCBuZmRBcHBJZCwgZmFsc2UpCglpbnQgMAoJZnJhbWVfZGlnIDEyIC8vIG5mZEFwcElkOiB1aW50NjQKCWZyYW1lX2RpZyAxNSAvLyBuZmRBc2FJZDogdWludDY0CglmcmFtZV9kaWcgLTIgLy8gbmZkTmFtZTogc3RyaW5nCgljYWxsc3ViIGFzc2lnbk5hbWVUb1JlZ2lzdHJ5CgoJLy8gKmlmMTlfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo0MTYKCS8vIHBhcmVudEFwcElkICE9PSAwCglmcmFtZV9kaWcgMSAvLyBwYXJlbnRBcHBJZDogdWludDY0CglpbnQgMAoJIT0KCWJ6ICppZjE5X2VuZAoKCS8vICppZjE5X2NvbnNlcXVlbnQKCS8vICppZjIwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NDE4CgkvLyB0aGlzLmlzUHJlVjMocGFyZW50QXBwSWQpCglmcmFtZV9kaWcgMSAvLyBwYXJlbnRBcHBJZDogdWludDY0CgljYWxsc3ViIGlzUHJlVjMKCWJ6ICppZjIwX2Vsc2UKCgkvLyAqaWYyMF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo0MTkKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgICAgICAgICAgKEFwcElELmZyb21VaW50NjQocGFyZW50QXBwSWQpLmdsb2JhbFN0YXRlKE5GRF9LRVlfVkVSU0lPTikgYXMgYnl0ZXMpID09PSAnMi4xMicsCgkvLyAgICAgICAgICAgICAgICAgICAgICduZmQgcm9vdCBub3QgMy54IG11c3QgYmUgdmVyc2lvbiAyLjEyIGluIG9yZGVyIGZvciBzZWdtZW50IG1pbnRpbmcgdG8gc3VjY2VlZCcsCgkvLyAgICAgICAgICAgICAgICAgKQoJZnJhbWVfZGlnIDEgLy8gcGFyZW50QXBwSWQ6IHVpbnQ2NAoJYnl0ZSAiaS52ZXIiCglhcHBfZ2xvYmFsX2dldF9leAoKCS8vIGdsb2JhbCBzdGF0ZSB2YWx1ZSBkb2VzIG5vdCBleGlzdDogQXBwSUQuZnJvbVVpbnQ2NChwYXJlbnRBcHBJZCkuZ2xvYmFsU3RhdGUoTkZEX0tFWV9WRVJTSU9OKQoJYXNzZXJ0CglieXRlIDB4MzIyZTMxMzIgLy8gIjIuMTIiCgk9PQoKCS8vIG5mZCByb290IG5vdCAzLnggbXVzdCBiZSB2ZXJzaW9uIDIuMTIgaW4gb3JkZXIgZm9yIHNlZ21lbnQgbWludGluZyB0byBzdWNjZWVkCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo0MjMKCS8vIHNlbmRBcHBDYWxsKHsKCS8vICAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0aW9uOiBPbkNvbXBsZXRpb24uTm9PcCwKCS8vICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NChwYXJlbnRBcHBJZCksCgkvLyAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uQXJnczogWyd1cGRhdGVfc2VnbWVudF9jb3VudCcsIG5mZE5hbWUsIGl0b2IobmZkQXBwSWQpXSwKCS8vICAgICAgICAgICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo0MjQKCS8vIG9uQ29tcGxldGlvbjogT25Db21wbGV0aW9uLk5vT3AKCWludCAwIC8vIE5vT3AKCWl0eG5fZmllbGQgT25Db21wbGV0aW9uCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NDI1CgkvLyBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KHBhcmVudEFwcElkKQoJZnJhbWVfZGlnIDEgLy8gcGFyZW50QXBwSWQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NDI2CgkvLyBhcHBsaWNhdGlvbkFyZ3M6IFsndXBkYXRlX3NlZ21lbnRfY291bnQnLCBuZmROYW1lLCBpdG9iKG5mZEFwcElkKV0KCWJ5dGUgMHg3NTcwNjQ2MTc0NjU1ZjczNjU2NzZkNjU2ZTc0NWY2MzZmNzU2ZTc0IC8vICJ1cGRhdGVfc2VnbWVudF9jb3VudCIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCglmcmFtZV9kaWcgLTIgLy8gbmZkTmFtZTogc3RyaW5nCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIDEyIC8vIG5mZEFwcElkOiB1aW50NjQKCWl0b2IKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJYiAqaWYyMF9lbmQKCippZjIwX2Vsc2U6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo0MjkKCS8vIHNlbmRNZXRob2RDYWxsPHR5cGVvZiBORkRJbnN0YW5jZS5wcm90b3R5cGUudXBkYXRlU2VnbWVudENvdW50Pih7CgkvLyAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQocGFyZW50QXBwSWQpLAoJLy8gICAgICAgICAgICAgICAgICAgICBtZXRob2RBcmdzOiBbbmZkTmFtZSwgbmZkQXBwSWRdLAoJLy8gICAgICAgICAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnQgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJbWV0aG9kICJ1cGRhdGVTZWdtZW50Q291bnQoc3RyaW5nLHVpbnQ2NCl2b2lkIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo0MzAKCS8vIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQocGFyZW50QXBwSWQpCglmcmFtZV9kaWcgMSAvLyBwYXJlbnRBcHBJZDogdWludDY0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo0MzEKCS8vIG1ldGhvZEFyZ3M6IFtuZmROYW1lLCBuZmRBcHBJZF0KCWZyYW1lX2RpZyAtMiAvLyBuZmROYW1lOiBzdHJpbmcKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIDEyIC8vIG5mZEFwcElkOiB1aW50NjQKCWl0b2IKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKKmlmMjBfZW5kOgoKKmlmMTlfZW5kOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NDM3CgkvLyBjb25zdHJhaW50RGF0YSA9IHRoaXMuZ2V0Q29uc3RyYWludHMoKQoJY2FsbHN1YiBnZXRDb25zdHJhaW50cwoJZnJhbWVfYnVyeSAxNiAvLyBjb25zdHJhaW50RGF0YTogKHVpbnQ2NCx1aW50NjQsdWludDY0LGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NDM5CgkvLyBwYXlvdXRJbmZvID0gc2VuZE1ldGhvZENhbGw8dHlwZW9mIE5GREluc3RhbmNlLnByb3RvdHlwZS5taW50UGF5b3V0Pih7CgkvLyAgICAgICAgICAgICBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KG5mZEFwcElkKSwKCS8vICAgICAgICAgICAgIG1ldGhvZEFyZ3M6IFtjb25zdHJhaW50RGF0YS5zZWdtZW50UGxhdGZvcm1Db3N0SW5BbGdvXSwKCS8vICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgltZXRob2QgIm1pbnRQYXlvdXQodWludDY0KSh1aW50NjQsYWRkcmVzcyx1aW50NjQsYWRkcmVzcyx1aW50NjQpIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo0NDAKCS8vIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQobmZkQXBwSWQpCglmcmFtZV9kaWcgMTIgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NDQxCgkvLyBtZXRob2RBcmdzOiBbY29uc3RyYWludERhdGEuc2VnbWVudFBsYXRmb3JtQ29zdEluQWxnb10KCWZyYW1lX2RpZyAxNiAvLyBjb25zdHJhaW50RGF0YTogKHVpbnQ2NCx1aW50NjQsdWludDY0LGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpCglleHRyYWN0IDggOAoJYnRvaQoJaXRvYgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglpdHhuIE51bUxvZ3MKCWludCAxCgktCglpdHhuYXMgTG9ncwoJZXh0cmFjdCA0IDAKCWZyYW1lX2J1cnkgMTcgLy8gcGF5b3V0SW5mbzogKHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCkKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo0NDQKCS8vIHRoaXMubmZkUmVnaXN0cnlfbWludGVkLmxvZyh7CgkvLyAgICAgICAgICAgICBhcHBJZDogbmZkQXBwSWQsCgkvLyAgICAgICAgICAgICBuYW1lOiBuZmROYW1lLAoJLy8gICAgICAgICAgICAgcHJpY2VPbmVZZWFyOiBvbmVZZWFyUHJpY2UsCgkvLyAgICAgICAgICAgICBwYWlkQW1vdW50OiBwdXJjaGFzZVR4bi5hbW91bnQgLSBuZmRNYnJDb3N0LAoJLy8gICAgICAgICAgICAgY2FycnlDb3N0OiBuZmRNYnJDb3N0LAoJLy8gICAgICAgICAgICAgc2VsbGVyOiB0aGlzLm5mZFRyZWFzdXJ5QWRkciwKCS8vICAgICAgICAgICAgIGJ1eWVyOiBwdXJjaGFzZVR4bi5zZW5kZXIsCgkvLyAgICAgICAgICAgICBvd25lcjogcmVzZXJ2ZWRGb3IsCgkvLyAgICAgICAgICAgICBleHBUaW1lOiBleHBUaW1lLAoJLy8gICAgICAgICAgICAgYW1vdW50VG9TZWxsZXI6IHBheW91dEluZm8uYW1vdW50VG9TZWxsZXIsCgkvLyAgICAgICAgICAgICBjb21taXNzaW9uQWRkcmVzczogcGF5b3V0SW5mby5jb21taXNzaW9uQWRkcmVzcywKCS8vICAgICAgICAgICAgIGFtb3VudFRvQ29tbWlzc2lvbjogcGF5b3V0SW5mby5hbW91bnRUb0NvbW1pc3Npb24sCgkvLyAgICAgICAgICAgICBzZWdtZW50Um9vdE93bmVyOiBwYXlvdXRJbmZvLnNlZ21lbnRSb290T3duZXIsCgkvLyAgICAgICAgICAgICBhbW91bnRUb1NlZ21lbnRSb290OiBwYXlvdXRJbmZvLmFtb3VudFRvU2VnbWVudFJvb3QsCgkvLyAgICAgICAgIH0pCglieXRlIDB4MzVjNTk0MTggLy8gbmZkUmVnaXN0cnlfbWludGVkKHVpbnQ2NCxzdHJpbmcsdWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCkKCWJ5dGUgMHggLy8gaW5pdGlhbCBoZWFkCglieXRlIDB4IC8vIGluaXRpYWwgdGFpbAoJYnl0ZSAweDAwZTIgLy8gaW5pdGlhbCBoZWFkIG9mZnNldAoJZnJhbWVfZGlnIDEyIC8vIG5mZEFwcElkOiB1aW50NjQKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAtMiAvLyBuZmROYW1lOiBzdHJpbmcKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CgljYWxsc3ViICpwcm9jZXNzX2R5bmFtaWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIDMgLy8gb25lWWVhclByaWNlOiB1aW50NjQKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAtMSAvLyBwdXJjaGFzZVR4bjogUGF5VHhuCglndHhucyBBbW91bnQKCWZyYW1lX2RpZyA0IC8vIG5mZE1ickNvc3Q6IHVpbnQ2NAoJLQoJaXRvYgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIDQgLy8gbmZkTWJyQ29zdDogdWludDY0CglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50Cglsb2FkIDIwMSAvLyBUTVBMX25mZFRyZWFzdXJ5QWRkcgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIC0xIC8vIHB1cmNoYXNlVHhuOiBQYXlUeG4KCWd0eG5zIFNlbmRlcgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIC0zIC8vIHJlc2VydmVkRm9yOiBBZGRyZXNzCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgMTEgLy8gZXhwVGltZTogdWludDY0CglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgMTcgLy8gcGF5b3V0SW5mbzogKHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCkKCWV4dHJhY3QgMCA4CglidG9pCglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgMTcgLy8gcGF5b3V0SW5mbzogKHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCkKCWV4dHJhY3QgOCAzMgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIDE3IC8vIHBheW91dEluZm86ICh1aW50NjQsYWRkcmVzcyx1aW50NjQsYWRkcmVzcyx1aW50NjQpCglleHRyYWN0IDQwIDgKCWJ0b2kKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAxNyAvLyBwYXlvdXRJbmZvOiAodWludDY0LGFkZHJlc3MsdWludDY0LGFkZHJlc3MsdWludDY0KQoJZXh0cmFjdCA0OCAzMgoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIDE3IC8vIHBheW91dEluZm86ICh1aW50NjQsYWRkcmVzcyx1aW50NjQsYWRkcmVzcyx1aW50NjQpCglleHRyYWN0IDgwIDgKCWJ0b2kKCWl0b2IKCWNhbGxzdWIgKnByb2Nlc3Nfc3RhdGljX3R1cGxlX2VsZW1lbnQKCXBvcCAvLyBwb3AgaGVhZCBvZmZzZXQKCWNvbmNhdCAvLyBjb25jYXQgaGVhZCBhbmQgdGFpbAoJY29uY2F0Cglsb2cKCgkvLyAqaWYyMV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjQ2MQoJLy8gbGlua09uTWludAoJZnJhbWVfZGlnIC00IC8vIGxpbmtPbk1pbnQ6IGJvb2xlYW4KCWJ6ICppZjIxX2VuZAoKCS8vICppZjIxX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjQ2MgoJLy8gc2VuZE1ldGhvZENhbGw8dHlwZW9mIE5GREluc3RhbmNlLnByb3RvdHlwZS51cGRhdGVGaWVsZHM+KHsKCS8vICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KG5mZEFwcElkKSwKCS8vICAgICAgICAgICAgICAgICBtZXRob2RBcmdzOiBbW05GRF9GSUVMRF9DQV9UT19WRVJJRlksIHJhd0J5dGVzKHRoaXMudHhuLnNlbmRlcildXSwKCS8vICAgICAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnQgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJbWV0aG9kICJ1cGRhdGVGaWVsZHMoYnl0ZVtdW10pdm9pZCIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NDYzCgkvLyBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KG5mZEFwcElkKQoJZnJhbWVfZGlnIDEyIC8vIG5mZEFwcElkOiB1aW50NjQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25JRAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjQ2NAoJLy8gbWV0aG9kQXJnczogW1tORkRfRklFTERfQ0FfVE9fVkVSSUZZLCByYXdCeXRlcyh0aGlzLnR4bi5zZW5kZXIpXV0KCWJ5dGUgMHggLy8gaW5pdGlhbCBoZWFkCglieXRlIDB4IC8vIGluaXRpYWwgdGFpbAoJYnl0ZSAweDAwMDQgLy8gaW5pdGlhbCBoZWFkIG9mZnNldAoJYnl0ZSAidS5jYXYuYWxnby5hIgoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWNhbGxzdWIgKnByb2Nlc3NfZHluYW1pY190dXBsZV9lbGVtZW50Cgl0eG4gU2VuZGVyCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY2FsbHN1YiAqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQKCXBvcCAvLyBwb3AgaGVhZCBvZmZzZXQKCWNvbmNhdCAvLyBjb25jYXQgaGVhZCBhbmQgdGFpbAoJYnl0ZSAweDAwMDIKCXN3YXAKCWNvbmNhdAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NDY2CgkvLyB0aGlzLmxpbmtOZmRBZGRyZXNzKG5mZE5hbWUsIG5mZEFwcElkLCB0aGlzLnR4bi5zZW5kZXIpCgl0eG4gU2VuZGVyCglmcmFtZV9kaWcgMTIgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC0yIC8vIG5mZE5hbWU6IHN0cmluZwoJY2FsbHN1YiBsaW5rTmZkQWRkcmVzcwoKKmlmMjFfZW5kOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NDY4CgkvLyByZXR1cm4gbmZkQXBwSWQKCWZyYW1lX2RpZyAxMiAvLyBuZmRBcHBJZDogdWludDY0CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMTcKCXJldHN1YgoKLy8gbGlua05mZEFkZHJlc3Moc3RyaW5nLHVpbnQ2NCxhZGRyZXNzKXZvaWQKKmFiaV9yb3V0ZV9saW5rTmZkQWRkcmVzczoKCS8vIGFkZHJUb1ZlcmlmeTogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZHVwCglsZW4KCWludCAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChhZGRyVG9WZXJpZnkpIGZvciBsaW5rTmZkQWRkcmVzcyBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIG5mZE5hbWU6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZXh0cmFjdCAyIDAKCgkvLyBleGVjdXRlIGxpbmtOZmRBZGRyZXNzKHN0cmluZyx1aW50NjQsYWRkcmVzcyl2b2lkCgljYWxsc3ViIGxpbmtOZmRBZGRyZXNzCglpbnQgMQoJcmV0dXJuCgovLyBsaW5rTmZkQWRkcmVzcyhuZmROYW1lOiBzdHJpbmcsIG5mZEFwcElkOiB1aW50NjQsIGFkZHJUb1ZlcmlmeTogQWRkcmVzcyk6IHZvaWQKbGlua05mZEFkZHJlc3M6Cglwcm90byAzIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NDc1CgkvLyBhZGRyQm94TmFtZSA9IHRoaXMuZ2V0QWxnb0FkZHJlc3NCb3hOYW1lKHJhd0J5dGVzKGFkZHJUb1ZlcmlmeSkpCglmcmFtZV9kaWcgLTMgLy8gYWRkclRvVmVyaWZ5OiBBZGRyZXNzCgljYWxsc3ViIGdldEFsZ29BZGRyZXNzQm94TmFtZQoJZnJhbWVfYnVyeSAwIC8vIGFkZHJCb3hOYW1lOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo0NzYKCS8vIG5mZE93bmVyID0gQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJZCkuZ2xvYmFsU3RhdGUoTkZEX0tFWV9PV05FUikgYXMgQWRkcmVzcwoJZnJhbWVfZGlnIC0yIC8vIG5mZEFwcElkOiB1aW50NjQKCWJ5dGUgImkub3duZXIuYSIKCWFwcF9nbG9iYWxfZ2V0X2V4CgoJLy8gZ2xvYmFsIHN0YXRlIHZhbHVlIGRvZXMgbm90IGV4aXN0OiBBcHBJRC5mcm9tVWludDY0KG5mZEFwcElkKS5nbG9iYWxTdGF0ZShORkRfS0VZX09XTkVSKQoJYXNzZXJ0CglmcmFtZV9idXJ5IDEgLy8gbmZkT3duZXI6IGFkZHJlc3MKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo0NzgKCS8vIGFzc2VydCh0aGlzLmlzVjJOZmRBcHBJZEF1dGhlbnRpYyhuZmROYW1lLCBuZmRBcHBJZCksICdyZWZlcmVuY2VkIE5GRCBuYW1lL2lkIG11c3QgYmUgdmFsaWQnKQoJZnJhbWVfZGlnIC0yIC8vIG5mZEFwcElkOiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyBuZmROYW1lOiBzdHJpbmcKCWNhbGxzdWIgaXNWMk5mZEFwcElkQXV0aGVudGljCgoJLy8gcmVmZXJlbmNlZCBORkQgbmFtZS9pZCBtdXN0IGJlIHZhbGlkCglhc3NlcnQKCgkvLyAqaWYyMl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjQ4MwoJLy8gQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJZCkuYWRkcmVzcyA9PT0gYWRkclRvVmVyaWZ5CglmcmFtZV9kaWcgLTIgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwoJcG9wCglmcmFtZV9kaWcgLTMgLy8gYWRkclRvVmVyaWZ5OiBBZGRyZXNzCgk9PQoJYnogKmlmMjJfZWxzZQoKCS8vICppZjIyX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjQ4NAoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gbmZkT3duZXIsICd2ZXJpZnlpbmcgdmF1bHQgYWNjb3VudCwgc2VuZGVyIG11c3QgYmUgTkZEIG93bmVyJykKCXR4biBTZW5kZXIKCWZyYW1lX2RpZyAxIC8vIG5mZE93bmVyOiBhZGRyZXNzCgk9PQoKCS8vIHZlcmlmeWluZyB2YXVsdCBhY2NvdW50LCBzZW5kZXIgbXVzdCBiZSBORkQgb3duZXIKCWFzc2VydAoJYiAqaWYyMl9lbmQKCippZjIyX2Vsc2U6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo0ODcKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IGFkZHJUb1ZlcmlmeSwgJ2FwcCBjYWxsIHNlbmRlciBtdXN0IG1hdGNoIGFkZHJlc3MgYmVpbmcgYWRkZWQvcmVtb3ZlZCcpCgl0eG4gU2VuZGVyCglmcmFtZV9kaWcgLTMgLy8gYWRkclRvVmVyaWZ5OiBBZGRyZXNzCgk9PQoKCS8vIGFwcCBjYWxsIHNlbmRlciBtdXN0IG1hdGNoIGFkZHJlc3MgYmVpbmcgYWRkZWQvcmVtb3ZlZAoJYXNzZXJ0CgoqaWYyMl9lbmQ6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo0OTAKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgIHRoaXMuY2FsbE5GRElzQWRkcmVzc0luRmllbGQobmZkQXBwSWQsIE5GRF9GSUVMRF9DQV9UT19WRVJJRlksIGFkZHJUb1ZlcmlmeSksCgkvLyAgICAgICAgICAgICAnbmZkIHZlcmlmaWVkIGNhQWxnby4wLmFzIG11c3QgY29udGFpbiBhZGRyZXNzIGJlaW5nIGFkZGVkL3JlbW92ZWQnLAoJLy8gICAgICAgICApCglmcmFtZV9kaWcgLTMgLy8gYWRkclRvVmVyaWZ5OiBBZGRyZXNzCglieXRlICJ1LmNhdi5hbGdvLmEiCglmcmFtZV9kaWcgLTIgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJY2FsbHN1YiBjYWxsTkZESXNBZGRyZXNzSW5GaWVsZAoKCS8vIG5mZCB2ZXJpZmllZCBjYUFsZ28uMC5hcyBtdXN0IGNvbnRhaW4gYWRkcmVzcyBiZWluZyBhZGRlZC9yZW1vdmVkCglhc3NlcnQKCgkvLyAqaWYyM19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjUwMgoJLy8gIXRoaXMuZmluZEludEluU2V0KGFkZHJCb3hOYW1lLCBuZmRBcHBJZCkKCWZyYW1lX2RpZyAtMiAvLyBuZmRBcHBJZDogdWludDY0CglmcmFtZV9kaWcgMCAvLyBhZGRyQm94TmFtZTogYnl0ZVtdCgljYWxsc3ViIGZpbmRJbnRJblNldAoJIQoJYnogKmlmMjNfZW5kCgoJLy8gKmlmMjNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NTA1CgkvLyBhc3NlcnQodGhpcy5hZGRJbnRUb1NldChhZGRyQm94TmFtZSwgbmZkQXBwSWQpLCAnc2hvdWxkIGFkZCBuZmQgdG8gcmV2ZXJzZSBhZGRyZXNzJykKCWZyYW1lX2RpZyAtMiAvLyBuZmRBcHBJZDogdWludDY0CglmcmFtZV9kaWcgMCAvLyBhZGRyQm94TmFtZTogYnl0ZVtdCgljYWxsc3ViIGFkZEludFRvU2V0CgoJLy8gc2hvdWxkIGFkZCBuZmQgdG8gcmV2ZXJzZSBhZGRyZXNzCglhc3NlcnQKCippZjIzX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjUwOQoJLy8gdGhpcy5jYWxsTkZEUmVnaXN0cnlBcHByb3ZlZEFkZHJlc3NBZGQobmZkQXBwSWQsIE5GRF9GSUVMRF9DQV9UT19WRVJJRlksIE5GRF9GSUVMRF9DQV9WRVJJRklFRF9TRVQpCglieXRlICJ2LmNhQWxnby4wLmFzIgoJYnl0ZSAidS5jYXYuYWxnby5hIgoJZnJhbWVfZGlnIC0yIC8vIG5mZEFwcElkOiB1aW50NjQKCWNhbGxzdWIgY2FsbE5GRFJlZ2lzdHJ5QXBwcm92ZWRBZGRyZXNzQWRkCglyZXRzdWIKCi8vIHVubGlua05mZEFkZHJlc3Moc3RyaW5nLHVpbnQ2NCxhZGRyZXNzKXZvaWQKKmFiaV9yb3V0ZV91bmxpbmtOZmRBZGRyZXNzOgoJLy8gYWRkclRvVW5saW5rOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglkdXAKCWxlbgoJaW50IDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKGFkZHJUb1VubGluaykgZm9yIHVubGlua05mZEFkZHJlc3MgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIG5mZEFwcElkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBuZmROYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSB1bmxpbmtOZmRBZGRyZXNzKHN0cmluZyx1aW50NjQsYWRkcmVzcyl2b2lkCgljYWxsc3ViIHVubGlua05mZEFkZHJlc3MKCWludCAxCglyZXR1cm4KCi8vIHVubGlua05mZEFkZHJlc3MobmZkTmFtZTogc3RyaW5nLCBuZmRBcHBJZDogdWludDY0LCBhZGRyVG9Vbmxpbms6IEFkZHJlc3MpOiB2b2lkCnVubGlua05mZEFkZHJlc3M6Cglwcm90byAzIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NTE2CgkvLyBuZmRPd25lciA9IEFwcElELmZyb21VaW50NjQobmZkQXBwSWQpLmdsb2JhbFN0YXRlKE5GRF9LRVlfT1dORVIpIGFzIEFkZHJlc3MKCWZyYW1lX2RpZyAtMiAvLyBuZmRBcHBJZDogdWludDY0CglieXRlICJpLm93bmVyLmEiCglhcHBfZ2xvYmFsX2dldF9leAoKCS8vIGdsb2JhbCBzdGF0ZSB2YWx1ZSBkb2VzIG5vdCBleGlzdDogQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJZCkuZ2xvYmFsU3RhdGUoTkZEX0tFWV9PV05FUikKCWFzc2VydAoJZnJhbWVfYnVyeSAwIC8vIG5mZE93bmVyOiBhZGRyZXNzCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NTE4CgkvLyBhc3NlcnQodGhpcy5pc1YyTmZkQXBwSWRBdXRoZW50aWMobmZkTmFtZSwgbmZkQXBwSWQpLCAncmVmZXJlbmNlZCBORkQgbmFtZS9pZCBtdXN0IGJlIHZhbGlkJykKCWZyYW1lX2RpZyAtMiAvLyBuZmRBcHBJZDogdWludDY0CglmcmFtZV9kaWcgLTEgLy8gbmZkTmFtZTogc3RyaW5nCgljYWxsc3ViIGlzVjJOZmRBcHBJZEF1dGhlbnRpYwoKCS8vIHJlZmVyZW5jZWQgTkZEIG5hbWUvaWQgbXVzdCBiZSB2YWxpZAoJYXNzZXJ0CgoJLy8gKmlmMjRfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo1MjMKCS8vICF0aGlzLmlzRXhwaXJlZCh0aGlzLnNhZmVHbG9iYWxJbnRHZXRFeChuZmRBcHBJZCwgTkZEX0tFWV9FWFBJUkFUSU9OVElNRSkpCglieXRlICJpLmV4cGlyYXRpb25UaW1lIgoJZnJhbWVfZGlnIC0yIC8vIG5mZEFwcElkOiB1aW50NjQKCWNhbGxzdWIgc2FmZUdsb2JhbEludEdldEV4CgljYWxsc3ViIGlzRXhwaXJlZAoJIQoJYnogKmlmMjRfZW5kCgoJLy8gKmlmMjRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NTI0CgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICAgICAgdGhpcy50eG4uc2VuZGVyID09PSBuZmRPd25lciB8fCB0aGlzLnR4bi5zZW5kZXIgPT09IGFkZHJUb1VubGluaywKCS8vICAgICAgICAgICAgICAgICAnU2VuZGVyIHVubGlua2luZyBtdXN0IGJlIE5GRCBvd25lciBPUiBhZGRyZXNzIHJlbW92aW5nIGl0c2VsZicsCgkvLyAgICAgICAgICAgICApCgl0eG4gU2VuZGVyCglmcmFtZV9kaWcgMCAvLyBuZmRPd25lcjogYWRkcmVzcwoJPT0KCWR1cAoJYm56ICpza2lwX29yMQoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0zIC8vIGFkZHJUb1VubGluazogQWRkcmVzcwoJPT0KCXx8Cgoqc2tpcF9vcjE6CgkvLyBTZW5kZXIgdW5saW5raW5nIG11c3QgYmUgTkZEIG93bmVyIE9SIGFkZHJlc3MgcmVtb3ZpbmcgaXRzZWxmCglhc3NlcnQKCippZjI0X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjUyOQoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgdGhpcy5jYWxsTkZESXNBZGRyZXNzSW5GaWVsZChuZmRBcHBJZCwgTkZEX0ZJRUxEX0NBX1ZFUklGSUVEX1NFVCwgYWRkclRvVW5saW5rKSwKCS8vICAgICAgICAgICAgICduZmQgdmVyaWZpZWQgY2FBbGdvLjAuYXMgbXVzdCBjb250YWluIGFkZHJlc3MgYmVpbmcgcmVtb3ZlZCcsCgkvLyAgICAgICAgICkKCWZyYW1lX2RpZyAtMyAvLyBhZGRyVG9Vbmxpbms6IEFkZHJlc3MKCWJ5dGUgInYuY2FBbGdvLjAuYXMiCglmcmFtZV9kaWcgLTIgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJY2FsbHN1YiBjYWxsTkZESXNBZGRyZXNzSW5GaWVsZAoKCS8vIG5mZCB2ZXJpZmllZCBjYUFsZ28uMC5hcyBtdXN0IGNvbnRhaW4gYWRkcmVzcyBiZWluZyByZW1vdmVkCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo1MzQKCS8vIGFkZHJCb3hOYW1lID0gdGhpcy5nZXRBbGdvQWRkcmVzc0JveE5hbWUocmF3Qnl0ZXMoYWRkclRvVW5saW5rKSkKCWZyYW1lX2RpZyAtMyAvLyBhZGRyVG9Vbmxpbms6IEFkZHJlc3MKCWNhbGxzdWIgZ2V0QWxnb0FkZHJlc3NCb3hOYW1lCglmcmFtZV9idXJ5IDEgLy8gYWRkckJveE5hbWU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjUzNQoJLy8gYXNzZXJ0KHRoaXMucmVtb3ZlSW50RnJvbVNldChhZGRyQm94TmFtZSwgbmZkQXBwSWQpKQoJZnJhbWVfZGlnIC0yIC8vIG5mZEFwcElkOiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIGFkZHJCb3hOYW1lOiBieXRlW10KCWNhbGxzdWIgcmVtb3ZlSW50RnJvbVNldAoJYXNzZXJ0CgoJLy8gKmlmMjVfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo1MzYKCS8vICF0aGlzLmJveGVzKGFkZHJCb3hOYW1lKS5leGlzdHMKCWZyYW1lX2RpZyAxIC8vIGFkZHJCb3hOYW1lOiBieXRlW10KCWJveF9sZW4KCXN3YXAKCXBvcAoJIQoJYnogKmlmMjVfZW5kCgoJLy8gKmlmMjVfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NTM4CgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgICAgICAgICAgYW1vdW50OiB0aGlzLmNvc3RGb3JCb3hTdG9yYWdlKDEsIGFkZHJCb3hOYW1lLmxlbmd0aCArIDgpLAoJLy8gICAgICAgICAgICAgICAgIHJlY2VpdmVyOiB0aGlzLnR4bi5zZW5kZXIsCgkvLyAgICAgICAgICAgICAgICAgbm90ZTogJ2JveFJlZnVuZCcsCgkvLyAgICAgICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjUzOQoJLy8gYW1vdW50OiB0aGlzLmNvc3RGb3JCb3hTdG9yYWdlKDEsIGFkZHJCb3hOYW1lLmxlbmd0aCArIDgpCglmcmFtZV9kaWcgMSAvLyBhZGRyQm94TmFtZTogYnl0ZVtdCglsZW4KCWludCA4CgkrCglpbnQgMQoJY2FsbHN1YiBjb3N0Rm9yQm94U3RvcmFnZQoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo1NDAKCS8vIHJlY2VpdmVyOiB0aGlzLnR4bi5zZW5kZXIKCXR4biBTZW5kZXIKCWl0eG5fZmllbGQgUmVjZWl2ZXIKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo1NDEKCS8vIG5vdGU6ICdib3hSZWZ1bmQnCglieXRlIDB4NjI2Zjc4NTI2NTY2NzU2ZTY0IC8vICJib3hSZWZ1bmQiCglpdHhuX2ZpZWxkIE5vdGUKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoqaWYyNV9lbmQ6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo1NDYKCS8vIHRoaXMuY2FsbE5GRFJlZ2lzdHJ5QXBwcm92ZWRBZGRyZXNzUmVtb3ZlKG5mZEFwcElkLCBORkRfRklFTERfQ0FfVkVSSUZJRURfU0VULCBhZGRyVG9VbmxpbmssIHRoaXMudHhuLnNlbmRlcikKCXR4biBTZW5kZXIKCWZyYW1lX2RpZyAtMyAvLyBhZGRyVG9Vbmxpbms6IEFkZHJlc3MKCWJ5dGUgInYuY2FBbGdvLjAuYXMiCglmcmFtZV9kaWcgLTIgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJY2FsbHN1YiBjYWxsTkZEUmVnaXN0cnlBcHByb3ZlZEFkZHJlc3NSZW1vdmUKCXJldHN1YgoKLy8gb3duZXJzaGlwQXNzaWduKHN0cmluZyx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX293bmVyc2hpcEFzc2lnbjoKCS8vIG5mZEFwcElkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBuZmROYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBvd25lcnNoaXBBc3NpZ24oc3RyaW5nLHVpbnQ2NCl2b2lkCgljYWxsc3ViIG93bmVyc2hpcEFzc2lnbgoJaW50IDEKCXJldHVybgoKLy8gb3duZXJzaGlwQXNzaWduKG5mZE5hbWU6IHN0cmluZywgbmZkQXBwSWQ6IHVpbnQ2NCk6IHZvaWQKb3duZXJzaGlwQXNzaWduOgoJcHJvdG8gMiAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo1NTMKCS8vIGFzc2VydCh0aGlzLmlzVmFsaWROZmRBcHBJZChuZmROYW1lLCBuZmRBcHBJZCksICdyZWZlcmVuY2VkIE5GRCBuYW1lL2lkIG11c3QgYmUgdmFsaWQnKQoJZnJhbWVfZGlnIC0yIC8vIG5mZEFwcElkOiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyBuZmROYW1lOiBzdHJpbmcKCWNhbGxzdWIgaXNWYWxpZE5mZEFwcElkCgoJLy8gcmVmZXJlbmNlZCBORkQgbmFtZS9pZCBtdXN0IGJlIHZhbGlkCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo1NTQKCS8vIGJveE5hbWUgPSB0aGlzLmdldEFjY291bnRPd25zTmZkQm94TmFtZSgKCS8vICAgICAgICAgICAgIEFwcElELmZyb21VaW50NjQobmZkQXBwSWQpLmdsb2JhbFN0YXRlKE5GRF9LRVlfT1dORVIpIGFzIEFkZHJlc3MsCgkvLyAgICAgICAgICAgICBuZmRBcHBJZCwKCS8vICAgICAgICAgKQoJZnJhbWVfZGlnIC0yIC8vIG5mZEFwcElkOiB1aW50NjQKCWZyYW1lX2RpZyAtMiAvLyBuZmRBcHBJZDogdWludDY0CglieXRlICJpLm93bmVyLmEiCglhcHBfZ2xvYmFsX2dldF9leAoKCS8vIGdsb2JhbCBzdGF0ZSB2YWx1ZSBkb2VzIG5vdCBleGlzdDogQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJZCkuZ2xvYmFsU3RhdGUoTkZEX0tFWV9PV05FUikKCWFzc2VydAoJY2FsbHN1YiBnZXRBY2NvdW50T3duc05mZEJveE5hbWUKCWZyYW1lX2J1cnkgMCAvLyBib3hOYW1lOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo1NTgKCS8vIGFzc2VydCghdGhpcy5ib3hlcyhib3hOYW1lKS5leGlzdHMpCglmcmFtZV9kaWcgMCAvLyBib3hOYW1lOiBieXRlW10KCWJveF9sZW4KCXN3YXAKCXBvcAoJIQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NTYxCgkvLyB0aGlzLmJveGVzKGJveE5hbWUpLnZhbHVlID0gbmZkTmFtZQoJZnJhbWVfZGlnIDAgLy8gYm94TmFtZTogYnl0ZVtdCglmcmFtZV9kaWcgLTEgLy8gbmZkTmFtZTogc3RyaW5nCglib3hfcHV0CglyZXRzdWIKCi8vIG93bmVyc2hpcENoYW5nZWQoc3RyaW5nLHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3Mpdm9pZAoqYWJpX3JvdXRlX293bmVyc2hpcENoYW5nZWQ6CgkvLyBidXllcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJZHVwCglsZW4KCWludCAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChidXllcikgZm9yIG93bmVyc2hpcENoYW5nZWQgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIHNlbGxlcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZHVwCglsZW4KCWludCAzMgoJPT0KCgkvLyBhcmd1bWVudCAxIChzZWxsZXIpIGZvciBvd25lcnNoaXBDaGFuZ2VkIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBuZmRBcHBJZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gbmZkTmFtZTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgb3duZXJzaGlwQ2hhbmdlZChzdHJpbmcsdWludDY0LGFkZHJlc3MsYWRkcmVzcyl2b2lkCgljYWxsc3ViIG93bmVyc2hpcENoYW5nZWQKCWludCAxCglyZXR1cm4KCi8vIG93bmVyc2hpcENoYW5nZWQobmZkTmFtZTogc3RyaW5nLCBuZmRBcHBJZDogdWludDY0LCBzZWxsZXI6IEFkZHJlc3MsIGJ1eWVyOiBBZGRyZXNzKTogdm9pZAovLwovLyBUaGlzIG1ldGhvZCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgb3duZXJzaGlwIG9mIGFuIE5GRCAoTm9uLUZ1bmdpYmxlIERvbWFpbikgY2hhbmdlcy4KLy8gSXQgaXMgY2FsbGVkIGJ5IHRoZSBORkQgdmlhIHRoZSBwdXJjaGFzZSBtZXRob2QuICBJdCBjYW4gYWxzbyBiZSBjYWxsZWQgYnkgVHhuTGFiIGFkbWluIGZvciBvbGRlciAzLjMKLy8gTkZEcyB3aGVuIGl0IGRldGVjdHMgcHVyY2hhc2VkIGV2ZW50cyBmb3IgMy4zCi8vCi8vIEBwYXJhbSB7c3RyaW5nfSBuZmROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIE5GRC4KLy8gQHBhcmFtIHt1aW50NjR9IG5mZEFwcElkIC0gVGhlIHVuaXF1ZSBhcHBsaWNhdGlvbiBJRCBvZiB0aGUgTkZELgovLyBAcGFyYW0ge0FkZHJlc3N9IHNlbGxlciAtIFRoZSBhZGRyZXNzIG9mIHRoZSBwcmlvciBvd25lciAoc2VsbGVyKSBvZiB0aGUgbmZkCi8vIEBwYXJhbSB7QWRkcmVzc30gYnV5ZXIgLSBUaGUgYWRkcmVzcyBvZiB0aGUgbmV3IG93bmVyIG9mIHRoZSBORkQuCm93bmVyc2hpcENoYW5nZWQ6Cglwcm90byA0IDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwCgoJLy8gKmlmMjZfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo1NzUKCS8vIHNlbGxlciA9PT0gYnV5ZXIKCWZyYW1lX2RpZyAtMyAvLyBzZWxsZXI6IEFkZHJlc3MKCWZyYW1lX2RpZyAtNCAvLyBidXllcjogQWRkcmVzcwoJPT0KCWJ6ICppZjI2X2VuZAoKCS8vICppZjI2X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjU3NgoJLy8gcmV0dXJuCglyZXRzdWIKCippZjI2X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjU3OAoJLy8gYXNzZXJ0KHRoaXMuaXNWMk5mZEFwcElkQXV0aGVudGljKG5mZE5hbWUsIG5mZEFwcElkKSwgJ3JlZmVyZW5jZWQgTkZEIG5hbWUvaWQgbXVzdCBiZSB2YWxpZCcpCglmcmFtZV9kaWcgLTIgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC0xIC8vIG5mZE5hbWU6IHN0cmluZwoJY2FsbHN1YiBpc1YyTmZkQXBwSWRBdXRoZW50aWMKCgkvLyByZWZlcmVuY2VkIE5GRCBuYW1lL2lkIG11c3QgYmUgdmFsaWQKCWFzc2VydAoKCS8vICppZjI3X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NTc5CgkvLyAoQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJZCkuZ2xvYmFsU3RhdGUoTkZEX0tFWV9WRVJTSU9OKSBhcyBieXRlcykgPT09ICczLjMnCglmcmFtZV9kaWcgLTIgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJYnl0ZSAiaS52ZXIiCglhcHBfZ2xvYmFsX2dldF9leAoKCS8vIGdsb2JhbCBzdGF0ZSB2YWx1ZSBkb2VzIG5vdCBleGlzdDogQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJZCkuZ2xvYmFsU3RhdGUoTkZEX0tFWV9WRVJTSU9OKQoJYXNzZXJ0CglieXRlIDB4MzMyZTMzIC8vICIzLjMiCgk9PQoJYnogKmlmMjdfZWxzZQoKCS8vICppZjI3X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjU4MQoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgICAgIHRoaXMuaXNUeG5MYWIodGhpcy50eG5Hcm91cFt0aGlzLnR4bi5ncm91cEluZGV4XSksCgkvLyAgICAgICAgICAgICAgICAgJ29ubHkgdHhubGFiIGNhbiBjYWxsIHRoaXMgbWV0aG9kIHRvIGJhY2tmaWxsIG93bmVyc2hpcCwgMy40KyBoYW5kbGVzIGl0IGJ5IGNhbGxpbmcgZnJvbSB0aGUgbmZkIGl0c2VsZicsCgkvLyAgICAgICAgICAgICApCgl0eG4gR3JvdXBJbmRleAoJY2FsbHN1YiBpc1R4bkxhYgoKCS8vIG9ubHkgdHhubGFiIGNhbiBjYWxsIHRoaXMgbWV0aG9kIHRvIGJhY2tmaWxsIG93bmVyc2hpcCwgMy40KyBoYW5kbGVzIGl0IGJ5IGNhbGxpbmcgZnJvbSB0aGUgbmZkIGl0c2VsZgoJYXNzZXJ0CgliICppZjI3X2VuZAoKKmlmMjdfZWxzZToKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjU4NwoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJZCkuYWRkcmVzcykKCXR4biBTZW5kZXIKCWZyYW1lX2RpZyAtMiAvLyBuZmRBcHBJZDogdWludDY0CglhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCglwb3AKCT09Cglhc3NlcnQKCippZjI3X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjU5MAoJLy8gc2VsbGVyQm94TmFtZSA9IHRoaXMuZ2V0QWNjb3VudE93bnNOZmRCb3hOYW1lKHNlbGxlciwgbmZkQXBwSWQpCglmcmFtZV9kaWcgLTIgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC0zIC8vIHNlbGxlcjogQWRkcmVzcwoJY2FsbHN1YiBnZXRBY2NvdW50T3duc05mZEJveE5hbWUKCWZyYW1lX2J1cnkgMCAvLyBzZWxsZXJCb3hOYW1lOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo1OTEKCS8vIGJ1eWVyQm94TmFtZSA9IHRoaXMuZ2V0QWNjb3VudE93bnNOZmRCb3hOYW1lKGJ1eWVyLCBuZmRBcHBJZCkKCWZyYW1lX2RpZyAtMiAvLyBuZmRBcHBJZDogdWludDY0CglmcmFtZV9kaWcgLTQgLy8gYnV5ZXI6IEFkZHJlc3MKCWNhbGxzdWIgZ2V0QWNjb3VudE93bnNOZmRCb3hOYW1lCglmcmFtZV9idXJ5IDEgLy8gYnV5ZXJCb3hOYW1lOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo1OTIKCS8vIHRoaXMuYm94ZXMoc2VsbGVyQm94TmFtZSkuZGVsZXRlKCkKCWZyYW1lX2RpZyAwIC8vIHNlbGxlckJveE5hbWU6IGJ5dGVbXQoJYm94X2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjU5MwoJLy8gdGhpcy5ib3hlcyhidXllckJveE5hbWUpLnZhbHVlID0gbmZkTmFtZQoJZnJhbWVfZGlnIDEgLy8gYnV5ZXJCb3hOYW1lOiBieXRlW10KCWZyYW1lX2RpZyAtMSAvLyBuZmROYW1lOiBzdHJpbmcKCWJveF9wdXQKCXJldHN1YgoKLy8gc2V0QWRkcmVzc1ByaW1hcnlOZmQoc3RyaW5nLHVpbnQ2NCxhZGRyZXNzKXZvaWQKKmFiaV9yb3V0ZV9zZXRBZGRyZXNzUHJpbWFyeU5mZDoKCS8vIGFkZHJCZWluZ01vZGlmaWVkOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglkdXAKCWxlbgoJaW50IDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKGFkZHJCZWluZ01vZGlmaWVkKSBmb3Igc2V0QWRkcmVzc1ByaW1hcnlOZmQgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIG5mZEFwcElkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyBuZmROYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBzZXRBZGRyZXNzUHJpbWFyeU5mZChzdHJpbmcsdWludDY0LGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiBzZXRBZGRyZXNzUHJpbWFyeU5mZAoJaW50IDEKCXJldHVybgoKLy8gc2V0QWRkcmVzc1ByaW1hcnlOZmQobmZkTmFtZTogc3RyaW5nLCBuZmRBcHBJZDogdWludDY0LCBhZGRyQmVpbmdNb2RpZmllZDogQWRkcmVzcyk6IHZvaWQKLy8KLy8gTWFrZXMgdGhlIHNwZWNpZmllZCBORkQgdGhlICdmaXJzdCcgTkZEIGluIHRoZSByZXZlcnNlLWFkZHJlc3Mgc2V0IHNvIGl0cyB0aGUgcHJpbWFyeSBORkQgZm9yIHRoaXMgYWRkcmVzcy4KLy8gVGhlIE5GRCBtdXN0IGJlIHZhbGlkLCBhbmQgdGhlIHNlbmRlciBtdXN0IGJlIHRoZSBhZGRyZXNzIChvciBuZmQgb3duZXIgaWYgdmF1bHQpLiAgVGhlIE5GRCB3b3VsZG4ndCBhbHJlYWR5IGJlCi8vIGluIHRoZSByZXZlcnNlLWxvb2t1cCBzZXQgaWYgaXQgd2Fzbid0IGFscmVhZHkgdmFsaWQuCi8vIEBwYXJhbSBuZmROYW1lCi8vIEBwYXJhbSBuZmRBcHBJZAovLyBAcGFyYW0gYWRkckJlaW5nTW9kaWZpZWQKc2V0QWRkcmVzc1ByaW1hcnlOZmQ6Cglwcm90byAzIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjYwNQoJLy8gYXNzZXJ0KHRoaXMuaXNWMk5mZEFwcElkQXV0aGVudGljKG5mZE5hbWUsIG5mZEFwcElkKSwgJ3JlZmVyZW5jZWQgTkZEIG5hbWUvaWQgbXVzdCBiZSB2YWxpZCcpCglmcmFtZV9kaWcgLTIgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC0xIC8vIG5mZE5hbWU6IHN0cmluZwoJY2FsbHN1YiBpc1YyTmZkQXBwSWRBdXRoZW50aWMKCgkvLyByZWZlcmVuY2VkIE5GRCBuYW1lL2lkIG11c3QgYmUgdmFsaWQKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjYwNgoJLy8gbmZkT3duZXIgPSBBcHBJRC5mcm9tVWludDY0KG5mZEFwcElkKS5nbG9iYWxTdGF0ZShORkRfS0VZX09XTkVSKSBhcyBBZGRyZXNzCglmcmFtZV9kaWcgLTIgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJYnl0ZSAiaS5vd25lci5hIgoJYXBwX2dsb2JhbF9nZXRfZXgKCgkvLyBnbG9iYWwgc3RhdGUgdmFsdWUgZG9lcyBub3QgZXhpc3Q6IEFwcElELmZyb21VaW50NjQobmZkQXBwSWQpLmdsb2JhbFN0YXRlKE5GRF9LRVlfT1dORVIpCglhc3NlcnQKCWZyYW1lX2J1cnkgMCAvLyBuZmRPd25lcjogYWRkcmVzcwoKCS8vICppZjI4X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NjExCgkvLyBBcHBJRC5mcm9tVWludDY0KG5mZEFwcElkKS5hZGRyZXNzID09PSBhZGRyQmVpbmdNb2RpZmllZAoJZnJhbWVfZGlnIC0yIC8vIG5mZEFwcElkOiB1aW50NjQKCWFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKCXBvcAoJZnJhbWVfZGlnIC0zIC8vIGFkZHJCZWluZ01vZGlmaWVkOiBBZGRyZXNzCgk9PQoJYnogKmlmMjhfZWxzZQoKCS8vICppZjI4X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjYxMgoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gbmZkT3duZXIsICdpZiBjaGFuZ2luZyBwcmltYXJ5IG5mZCBmb3IgdmF1bHQgYWNjb3VudCwgc2VuZGVyIG11c3QgYmUgTkZEIG93bmVyJykKCXR4biBTZW5kZXIKCWZyYW1lX2RpZyAwIC8vIG5mZE93bmVyOiBhZGRyZXNzCgk9PQoKCS8vIGlmIGNoYW5naW5nIHByaW1hcnkgbmZkIGZvciB2YXVsdCBhY2NvdW50LCBzZW5kZXIgbXVzdCBiZSBORkQgb3duZXIKCWFzc2VydAoJYiAqaWYyOF9lbmQKCippZjI4X2Vsc2U6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo2MTUKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgICAgICB0aGlzLnR4bi5zZW5kZXIgPT09IGFkZHJCZWluZ01vZGlmaWVkLAoJLy8gICAgICAgICAgICAgICAgICdhcHAgY2FsbCBzZW5kZXIgbXVzdCBtYXRjaCBhZGRyZXNzIGJlaW5nIHVwZGF0ZWQgdG8gY2hhbmdlIHByaW1hcnkgTkZEJywKCS8vICAgICAgICAgICAgICkKCXR4biBTZW5kZXIKCWZyYW1lX2RpZyAtMyAvLyBhZGRyQmVpbmdNb2RpZmllZDogQWRkcmVzcwoJPT0KCgkvLyBhcHAgY2FsbCBzZW5kZXIgbXVzdCBtYXRjaCBhZGRyZXNzIGJlaW5nIHVwZGF0ZWQgdG8gY2hhbmdlIHByaW1hcnkgTkZECglhc3NlcnQKCippZjI4X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjYyMwoJLy8gdGhpcy5maW5kSW50QW5kU2V0Rmlyc3QodGhpcy5nZXRBbGdvQWRkcmVzc0JveE5hbWUodGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVszXSBhcyBieXRlcyksIG5mZEFwcElkKQoJZnJhbWVfZGlnIC0yIC8vIG5mZEFwcElkOiB1aW50NjQKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMwoJY2FsbHN1YiBnZXRBbGdvQWRkcmVzc0JveE5hbWUKCWNhbGxzdWIgZmluZEludEFuZFNldEZpcnN0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NjI1CgkvLyB0aGlzLm5mZFJlZ2lzdHJ5X2FkZHJlc3NQcmltYXJ5TmZkQ2hhbmdlZC5sb2coewoJLy8gICAgICAgICAgICAgYXBwSWQ6IG5mZEFwcElkLAoJLy8gICAgICAgICAgICAgbmFtZTogbmZkTmFtZSwKCS8vICAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJCZWluZ01vZGlmaWVkLAoJLy8gICAgICAgICB9KQoJYnl0ZSAweDUxNzJjZjAxIC8vIG5mZFJlZ2lzdHJ5X2FkZHJlc3NQcmltYXJ5TmZkQ2hhbmdlZCh1aW50NjQsc3RyaW5nLGFkZHJlc3MpCglieXRlIDB4IC8vIGluaXRpYWwgaGVhZAoJYnl0ZSAweCAvLyBpbml0aWFsIHRhaWwKCWJ5dGUgMHgwMDJhIC8vIGluaXRpYWwgaGVhZCBvZmZzZXQKCWZyYW1lX2RpZyAtMiAvLyBuZmRBcHBJZDogdWludDY0CglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgLTEgLy8gbmZkTmFtZTogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY2FsbHN1YiAqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAtMyAvLyBhZGRyQmVpbmdNb2RpZmllZDogQWRkcmVzcwoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJcG9wIC8vIHBvcCBoZWFkIG9mZnNldAoJY29uY2F0IC8vIGNvbmNhdCBoZWFkIGFuZCB0YWlsCgljb25jYXQKCWxvZwoJcmV0c3ViCgovLyB1cGdyYWRlTmZkKHN0cmluZylzdHJpbmcKKmFiaV9yb3V0ZV91cGdyYWRlTmZkOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBuZmROYW1lOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSB1cGdyYWRlTmZkKHN0cmluZylzdHJpbmcKCWNhbGxzdWIgdXBncmFkZU5mZAoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyB1cGdyYWRlTmZkKG5mZE5hbWU6IHN0cmluZyk6IHN0cmluZwp1cGdyYWRlTmZkOgoJcHJvdG8gMSAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gNQoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjYzNQoJLy8gbmZkQXBwSWQgPSB0aGlzLmdldE5hbWVBcHBJZChuZmROYW1lKQoJZnJhbWVfZGlnIC0xIC8vIG5mZE5hbWU6IHN0cmluZwoJY2FsbHN1YiBnZXROYW1lQXBwSWQKCWZyYW1lX2J1cnkgMCAvLyBuZmRBcHBJZDogdWludDY0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NjM2CgkvLyBuZmRPd25lciA9IEFwcElELmZyb21VaW50NjQobmZkQXBwSWQpLmdsb2JhbFN0YXRlKE5GRF9LRVlfT1dORVIpIGFzIEFkZHJlc3MKCWZyYW1lX2RpZyAwIC8vIG5mZEFwcElkOiB1aW50NjQKCWJ5dGUgImkub3duZXIuYSIKCWFwcF9nbG9iYWxfZ2V0X2V4CgoJLy8gZ2xvYmFsIHN0YXRlIHZhbHVlIGRvZXMgbm90IGV4aXN0OiBBcHBJRC5mcm9tVWludDY0KG5mZEFwcElkKS5nbG9iYWxTdGF0ZShORkRfS0VZX09XTkVSKQoJYXNzZXJ0CglmcmFtZV9idXJ5IDEgLy8gbmZkT3duZXI6IGFkZHJlc3MKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo2MzcKCS8vIGFzc2VydCgoQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJZCkuZ2xvYmFsU3RhdGUoTkZEX0tFWV9OQU1FKSBhcyBieXRlcykgPT09IG5mZE5hbWUpCglmcmFtZV9kaWcgMCAvLyBuZmRBcHBJZDogdWludDY0CglieXRlICJpLm5hbWUiCglhcHBfZ2xvYmFsX2dldF9leAoKCS8vIGdsb2JhbCBzdGF0ZSB2YWx1ZSBkb2VzIG5vdCBleGlzdDogQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJZCkuZ2xvYmFsU3RhdGUoTkZEX0tFWV9OQU1FKQoJYXNzZXJ0CglmcmFtZV9kaWcgLTEgLy8gbmZkTmFtZTogc3RyaW5nCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NjM4CgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSBuZmRPd25lciwgJ29ubHkgTkZEIG93bmVyIGNhbiB1cGdyYWRlIE5GRCcpCgl0eG4gU2VuZGVyCglmcmFtZV9kaWcgMSAvLyBuZmRPd25lcjogYWRkcmVzcwoJPT0KCgkvLyBvbmx5IE5GRCBvd25lciBjYW4gdXBncmFkZSBORkQKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjY0MQoJLy8gYXNzZXJ0KEFwcElELmZyb21VaW50NjQobmZkQXBwSWQpLmdsb2JhbFN0YXRlRXhpc3RzKE5GRF9LRVlfRVhQSVJBVElPTlRJTUUpKQoJZnJhbWVfZGlnIDAgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJYnl0ZSAiaS5leHBpcmF0aW9uVGltZSIKCWFwcF9nbG9iYWxfZ2V0X2V4Cglzd2FwCglwb3AKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjY0NAoJLy8gY3VycmVudENvbnRyYWN0VmVyID0gdGhpcy5ib3hlcyhSRUdJU1RSWV9DT05UUkFDVF9CT1hfQ1VSUkVOVF9DT05UUkFDVCkudmFsdWUgYXMgYnl0ZXMKCWJ5dGUgImN1cnJlbnQiCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLmJveGVzKFJFR0lTVFJZX0NPTlRSQUNUX0JPWF9DVVJSRU5UX0NPTlRSQUNUKS52YWx1ZQoJYXNzZXJ0CglmcmFtZV9idXJ5IDIgLy8gY3VycmVudENvbnRyYWN0VmVyOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo2NDUKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgIChBcHBJRC5mcm9tVWludDY0KG5mZEFwcElkKS5nbG9iYWxTdGF0ZShORkRfS0VZX1ZFUlNJT04pIGFzIGJ5dGVzKSAhPT0gY3VycmVudENvbnRyYWN0VmVyLAoJLy8gICAgICAgICAgICAgJ2NvbnRyYWN0IGFscmVhZHkgYXQgdGhpcyB2ZXJzaW9uJywKCS8vICAgICAgICAgKQoJZnJhbWVfZGlnIDAgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJYnl0ZSAiaS52ZXIiCglhcHBfZ2xvYmFsX2dldF9leAoKCS8vIGdsb2JhbCBzdGF0ZSB2YWx1ZSBkb2VzIG5vdCBleGlzdDogQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJZCkuZ2xvYmFsU3RhdGUoTkZEX0tFWV9WRVJTSU9OKQoJYXNzZXJ0CglmcmFtZV9kaWcgMiAvLyBjdXJyZW50Q29udHJhY3RWZXI6IGJ5dGVbXQoJIT0KCgkvLyBjb250cmFjdCBhbHJlYWR5IGF0IHRoaXMgdmVyc2lvbgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NjQ5CgkvLyBhcHByb3ZQcm9nTmFtZSA9IGNvbmNhdCgKCS8vICAgICAgICAgICAgIFJFR0lTVFJZX0NPTlRSQUNUX0JPWF9BUFBST1ZBTF9OQU1FUFJFRklYLAoJLy8gICAgICAgICAgICAgdGhpcy5ib3hlcyhSRUdJU1RSWV9DT05UUkFDVF9CT1hfQ1VSUkVOVF9DT05UUkFDVCkudmFsdWUgYXMgYnl0ZXMsCgkvLyAgICAgICAgICkKCWJ5dGUgImNvbnRyYWN0OkE6IgoJYnl0ZSAiY3VycmVudCIKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuYm94ZXMoUkVHSVNUUllfQ09OVFJBQ1RfQk9YX0NVUlJFTlRfQ09OVFJBQ1QpLnZhbHVlCglhc3NlcnQKCWNvbmNhdAoJZnJhbWVfYnVyeSAzIC8vIGFwcHJvdlByb2dOYW1lOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo2NTMKCS8vIGNsZWFyUHJvZyA9IHRoaXMuYm94ZXMoY29uY2F0KFJFR0lTVFJZX0NPTlRSQUNUX0JPWF9DTEVBUl9OQU1FUFJFRklYLCBjdXJyZW50Q29udHJhY3RWZXIpKS52YWx1ZSBhcyBieXRlcwoJYnl0ZSAiY29udHJhY3Q6QzoiCglmcmFtZV9kaWcgMiAvLyBjdXJyZW50Q29udHJhY3RWZXI6IGJ5dGVbXQoJY29uY2F0Cglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLmJveGVzKGNvbmNhdChSRUdJU1RSWV9DT05UUkFDVF9CT1hfQ0xFQVJfTkFNRVBSRUZJWCwgY3VycmVudENvbnRyYWN0VmVyKSkudmFsdWUKCWFzc2VydAoJZnJhbWVfYnVyeSA0IC8vIGNsZWFyUHJvZzogYnl0ZVtdCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NjU0CgkvLyBhcHByb3ZQcm9nTGVuZ3RoID0gdGhpcy5ib3hlcyhhcHByb3ZQcm9nTmFtZSkuc2l6ZQoJZnJhbWVfZGlnIDMgLy8gYXBwcm92UHJvZ05hbWU6IGJ5dGVbXQoJYm94X2xlbgoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5ib3hlcyhhcHByb3ZQcm9nTmFtZSkuc2l6ZQoJYXNzZXJ0CglmcmFtZV9idXJ5IDUgLy8gYXBwcm92UHJvZ0xlbmd0aDogdWludDY0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NjU2CgkvLyBzZW5kTWV0aG9kQ2FsbDx0eXBlb2YgTkZESW5zdGFuY2UucHJvdG90eXBlLnVwZGF0ZUFwcGxpY2F0aW9uPih7CgkvLyAgICAgICAgICAgICBvbkNvbXBsZXRpb246IE9uQ29tcGxldGlvbi5VcGRhdGVBcHBsaWNhdGlvbiwKCS8vICAgICAgICAgICAgIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQobmZkQXBwSWQpLAoJLy8gICAgICAgICAgICAgbWV0aG9kQXJnczogW2N1cnJlbnRDb250cmFjdFZlcl0sCgkvLyAgICAgICAgICAgICBhcHByb3ZhbFByb2dyYW06IFsKCS8vICAgICAgICAgICAgICAgICB0aGlzLmJveGVzKGFwcHJvdlByb2dOYW1lKS5leHRyYWN0KDAsIDQwOTYpLAoJLy8gICAgICAgICAgICAgICAgIHRoaXMuYm94ZXMoYXBwcm92UHJvZ05hbWUpLmV4dHJhY3QoNDA5NiwgYXBwcm92UHJvZ0xlbmd0aCAtIDQwOTYpLAoJLy8gICAgICAgICAgICAgXSwKCS8vICAgICAgICAgICAgIGNsZWFyU3RhdGVQcm9ncmFtOiBjbGVhclByb2csCgkvLyAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnQgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJbWV0aG9kICJ1cGRhdGVBcHBsaWNhdGlvbihzdHJpbmcpdm9pZCIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NjU3CgkvLyBvbkNvbXBsZXRpb246IE9uQ29tcGxldGlvbi5VcGRhdGVBcHBsaWNhdGlvbgoJaW50IDQgLy8gVXBkYXRlQXBwbGljYXRpb24KCWl0eG5fZmllbGQgT25Db21wbGV0aW9uCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NjU4CgkvLyBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KG5mZEFwcElkKQoJZnJhbWVfZGlnIDAgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NjU5CgkvLyBtZXRob2RBcmdzOiBbY3VycmVudENvbnRyYWN0VmVyXQoJZnJhbWVfZGlnIDIgLy8gY3VycmVudENvbnRyYWN0VmVyOiBieXRlW10KCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjY2MAoJLy8gYXBwcm92YWxQcm9ncmFtOiBbCgkvLyAgICAgICAgICAgICAgICAgdGhpcy5ib3hlcyhhcHByb3ZQcm9nTmFtZSkuZXh0cmFjdCgwLCA0MDk2KSwKCS8vICAgICAgICAgICAgICAgICB0aGlzLmJveGVzKGFwcHJvdlByb2dOYW1lKS5leHRyYWN0KDQwOTYsIGFwcHJvdlByb2dMZW5ndGggLSA0MDk2KSwKCS8vICAgICAgICAgICAgIF0KCWZyYW1lX2RpZyAzIC8vIGFwcHJvdlByb2dOYW1lOiBieXRlW10KCWludCAwCglpbnQgNDA5NgoJYm94X2V4dHJhY3QKCWl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtUGFnZXMKCWZyYW1lX2RpZyAzIC8vIGFwcHJvdlByb2dOYW1lOiBieXRlW10KCWludCA0MDk2CglmcmFtZV9kaWcgNSAvLyBhcHByb3ZQcm9nTGVuZ3RoOiB1aW50NjQKCWludCA0MDk2CgktCglib3hfZXh0cmFjdAoJaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW1QYWdlcwoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjY2NAoJLy8gY2xlYXJTdGF0ZVByb2dyYW06IGNsZWFyUHJvZwoJZnJhbWVfZGlnIDQgLy8gY2xlYXJQcm9nOiBieXRlW10KCWl0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NjY2CgkvLyByZXR1cm4gY3VycmVudENvbnRyYWN0VmVyCglmcmFtZV9kaWcgMiAvLyBjdXJyZW50Q29udHJhY3RWZXI6IGJ5dGVbXQoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDUKCXJldHN1YgoKLy8gaXNWYWxpZE5mZEFwcElkKHN0cmluZyx1aW50NjQpYm9vbAoqYWJpX3JvdXRlX2lzVmFsaWROZmRBcHBJZDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIG5mZE5hbWU6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZXh0cmFjdCAyIDAKCgkvLyBleGVjdXRlIGlzVmFsaWROZmRBcHBJZChzdHJpbmcsdWludDY0KWJvb2wKCWNhbGxzdWIgaXNWYWxpZE5mZEFwcElkCglieXRlIDB4MDAKCWludCAwCgl1bmNvdmVyIDIKCXNldGJpdAoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGlzVmFsaWROZmRBcHBJZChuZmROYW1lOiBzdHJpbmcsIG5mZEFwcElkOiB1aW50NjQpOiBib29sZWFuCmlzVmFsaWROZmRBcHBJZDoKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6Njc0CgkvLyBib3hOYW1lID0gdGhpcy5nZXRCb3hOYW1lKG5mZE5hbWUpCglmcmFtZV9kaWcgLTEgLy8gbmZkTmFtZTogc3RyaW5nCgljYWxsc3ViIGdldEJveE5hbWUKCWZyYW1lX2J1cnkgMCAvLyBib3hOYW1lOiBieXRlW10KCgkvLyAqaWYyOV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjY3NgoJLy8gIXRoaXMuYm94ZXMoYm94TmFtZSkuZXhpc3RzCglmcmFtZV9kaWcgMCAvLyBib3hOYW1lOiBieXRlW10KCWJveF9sZW4KCXN3YXAKCXBvcAoJIQoJYnogKmlmMjlfZW5kCgoJLy8gKmlmMjlfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6Njc3CgkvLyByZXR1cm4gdGhpcy5pc1YxTkZESURBdXRoZW50aWMobmZkTmFtZSwgbmZkQXBwSWQpCglmcmFtZV9kaWcgLTIgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC0xIC8vIG5mZE5hbWU6IHN0cmluZwoJY2FsbHN1YiBpc1YxTkZESURBdXRoZW50aWMKCWIgKmlzVmFsaWROZmRBcHBJZCpyZXR1cm4KCippZjI5X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjY3OQoJLy8gcmV0dXJuIHRoaXMuaXNWMk5mZEFwcElkQXV0aGVudGljKG5mZE5hbWUsIG5mZEFwcElkKQoJZnJhbWVfZGlnIC0yIC8vIG5mZEFwcElkOiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyBuZmROYW1lOiBzdHJpbmcKCWNhbGxzdWIgaXNWMk5mZEFwcElkQXV0aGVudGljCgoqaXNWYWxpZE5mZEFwcElkKnJldHVybjoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBnZXROYW1lQXBwSWQoc3RyaW5nKXVpbnQ2NAoqYWJpX3JvdXRlX2dldE5hbWVBcHBJZDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gbmZkTmFtZTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgZ2V0TmFtZUFwcElkKHN0cmluZyl1aW50NjQKCWNhbGxzdWIgZ2V0TmFtZUFwcElkCglpdG9iCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gZ2V0TmFtZUFwcElkKG5mZE5hbWU6IHN0cmluZyk6IHVpbnQ2NApnZXROYW1lQXBwSWQ6Cglwcm90byAxIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6Njg0CgkvLyBib3hOYW1lID0gdGhpcy5nZXRCb3hOYW1lKG5mZE5hbWUpCglmcmFtZV9kaWcgLTEgLy8gbmZkTmFtZTogc3RyaW5nCgljYWxsc3ViIGdldEJveE5hbWUKCWZyYW1lX2J1cnkgMCAvLyBib3hOYW1lOiBieXRlW10KCgkvLyAqaWYzMF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjY4NQoJLy8gIXRoaXMuYm94ZXMoYm94TmFtZSkuZXhpc3RzCglmcmFtZV9kaWcgMCAvLyBib3hOYW1lOiBieXRlW10KCWJveF9sZW4KCXN3YXAKCXBvcAoJIQoJYnogKmlmMzBfZW5kCgoJLy8gKmlmMzBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6Njg2CgkvLyByZXR1cm4gMAoJaW50IDAKCWIgKmdldE5hbWVBcHBJZCpyZXR1cm4KCippZjMwX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjY4OQoJLy8gYm94RGF0YSA9IHRoaXMuYm94ZXMoYm94TmFtZSkudmFsdWUKCWZyYW1lX2RpZyAwIC8vIGJveE5hbWU6IGJ5dGVbXQoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5ib3hlcyhib3hOYW1lKS52YWx1ZQoJYXNzZXJ0CglmcmFtZV9idXJ5IDEgLy8gYm94RGF0YTogYnl0ZVtdCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NjkwCgkvLyBhc3NlcnQoYm94RGF0YS5sZW5ndGggPT09IDE2KQoJZnJhbWVfZGlnIDEgLy8gYm94RGF0YTogYnl0ZVtdCglsZW4KCWludCAxNgoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjY5MQoJLy8gcmV0dXJuIGV4dHJhY3RVaW50NjQoYm94RGF0YSwgOCkKCWZyYW1lX2RpZyAxIC8vIGJveERhdGE6IGJ5dGVbXQoJaW50IDgKCWV4dHJhY3RfdWludDY0CgoqZ2V0TmFtZUFwcElkKnJldHVybjoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDEKCXJldHN1YgoKLy8gZ2V0QWRkcmVzc0FwcElkcyhhZGRyZXNzKXVpbnQ2NFtdCiphYmlfcm91dGVfZ2V0QWRkcmVzc0FwcElkczoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gbG9va3VwQWRkcmVzczogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChsb29rdXBBZGRyZXNzKSBmb3IgZ2V0QWRkcmVzc0FwcElkcyBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBnZXRBZGRyZXNzQXBwSWRzKGFkZHJlc3MpdWludDY0W10KCWNhbGxzdWIgZ2V0QWRkcmVzc0FwcElkcwoJZHVwCglsZW4KCWludCA4CgkvCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0Cgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gZ2V0QWRkcmVzc0FwcElkcyhsb29rdXBBZGRyZXNzOiBBZGRyZXNzKTogdWludDY0W10KZ2V0QWRkcmVzc0FwcElkczoKCXByb3RvIDEgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXBuIDQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo2OTUKCS8vIHJldERhdGE6IHVpbnQ2NFtdID0gW10KCWJ5dGUgMHgKCWZyYW1lX2J1cnkgMCAvLyByZXREYXRhOiB1aW50NjRbXQoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjY5NgoJLy8gYm94TmFtZSA9IHRoaXMuZ2V0QWxnb0FkZHJlc3NCb3hOYW1lKHJhd0J5dGVzKGxvb2t1cEFkZHJlc3MpKQoJZnJhbWVfZGlnIC0xIC8vIGxvb2t1cEFkZHJlc3M6IEFkZHJlc3MKCWNhbGxzdWIgZ2V0QWxnb0FkZHJlc3NCb3hOYW1lCglmcmFtZV9idXJ5IDEgLy8gYm94TmFtZTogYnl0ZVtdCgoJLy8gKmlmMzFfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo2OTcKCS8vICF0aGlzLmJveGVzKGJveE5hbWUpLmV4aXN0cwoJZnJhbWVfZGlnIDEgLy8gYm94TmFtZTogYnl0ZVtdCglib3hfbGVuCglzd2FwCglwb3AKCSEKCWJ6ICppZjMxX2VuZAoKCS8vICppZjMxX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjY5OAoJLy8gcmV0dXJuIHJldERhdGEKCWZyYW1lX2RpZyAwIC8vIHJldERhdGE6IHVpbnQ2NFtdCgliICpnZXRBZGRyZXNzQXBwSWRzKnJldHVybgoKKmlmMzFfZW5kOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NzAwCgkvLyBib3hEYXRhID0gdGhpcy5ib3hlcyhib3hOYW1lKS52YWx1ZQoJZnJhbWVfZGlnIDEgLy8gYm94TmFtZTogYnl0ZVtdCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLmJveGVzKGJveE5hbWUpLnZhbHVlCglhc3NlcnQKCWZyYW1lX2J1cnkgMiAvLyBib3hEYXRhOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo3MDEKCS8vIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuKGJveERhdGEpOyBpICs9IDgpCglpbnQgMAoJZnJhbWVfYnVyeSAzIC8vIGk6IHVpbnQ2NAoKKmZvcl8wOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NzAxCgkvLyBpIDwgbGVuKGJveERhdGEpCglmcmFtZV9kaWcgMyAvLyBpOiB1aW50NjQKCWZyYW1lX2RpZyAyIC8vIGJveERhdGE6IGJ5dGVbXQoJbGVuCgk8CglieiAqZm9yXzBfZW5kCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NzAyCgkvLyB2YWwgPSBidG9pKGV4dHJhY3QzKGJveERhdGEsIGksIDgpKQoJZnJhbWVfZGlnIDIgLy8gYm94RGF0YTogYnl0ZVtdCglmcmFtZV9kaWcgMyAvLyBpOiB1aW50NjQKCWludCA4CglleHRyYWN0MwoJYnRvaQoJZnJhbWVfYnVyeSA0IC8vIHZhbDogdWludDY0CgoJLy8gKmlmMzJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo3MDMKCS8vIHZhbCAhPT0gMAoJZnJhbWVfZGlnIDQgLy8gdmFsOiB1aW50NjQKCWludCAwCgkhPQoJYnogKmlmMzJfZW5kCgoJLy8gKmlmMzJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NzA0CgkvLyByZXREYXRhLnB1c2godmFsKQoJZnJhbWVfZGlnIDAgLy8gcmV0RGF0YTogdWludDY0W10KCWZyYW1lX2RpZyA0IC8vIHZhbDogdWludDY0CglpdG9iCgljb25jYXQKCWZyYW1lX2J1cnkgMCAvLyByZXREYXRhOiB1aW50NjRbXQoKKmlmMzJfZW5kOgoKKmZvcl8wX2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NzAxCgkvLyBpICs9IDgKCWZyYW1lX2RpZyAzIC8vIGk6IHVpbnQ2NAoJaW50IDgKCSsKCWZyYW1lX2J1cnkgMyAvLyBpOiB1aW50NjQKCWIgKmZvcl8wCgoqZm9yXzBfZW5kOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NzA3CgkvLyByZXR1cm4gcmV0RGF0YQoJZnJhbWVfZGlnIDAgLy8gcmV0RGF0YTogdWludDY0W10KCipnZXRBZGRyZXNzQXBwSWRzKnJldHVybjoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDQKCXJldHN1YgoKLy8gbmZkQ29udHJhY3RJbml0KHN0cmluZyx1aW50NjQsYnl0ZVtdKXZvaWQKKmFiaV9yb3V0ZV9uZmRDb250cmFjdEluaXQ6CgkvLyBjbGVhckNvZGU6IGJ5dGVbXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJZXh0cmFjdCAyIDAKCgkvLyBzaXplOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyB2ZXJzaW9uOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBuZmRDb250cmFjdEluaXQoc3RyaW5nLHVpbnQ2NCxieXRlW10pdm9pZAoJY2FsbHN1YiBuZmRDb250cmFjdEluaXQKCWludCAxCglyZXR1cm4KCi8vIG5mZENvbnRyYWN0SW5pdCh2ZXJzaW9uOiBzdHJpbmcsIHNpemU6IHVpbnQ2NCwgY2xlYXJDb2RlOiBieXRlcyk6IHZvaWQKLy8KLy8gSW5pdGlhbGl6ZXMgdGhlIE5GRCBjb250cmFjdCBieXRlY29kZSBpbnRvIHRoZSByZWdpc3RyeQovLwovLyBAcGFyYW0ge3N0cmluZ30gdmVyc2lvbiAtIFRoZSB2ZXJzaW9uIG9mIHRoZSBjb250cmFjdC4KLy8gQHBhcmFtIHt1aW50NjR9IHNpemUgLSBleGFjdCBieXRlIHNpemUgb2YgY29udHJhY3QgdG8gbG9hZAovLyBAcGFyYW0ge3VpbnQ2NH0gY2xlYXJDb2RlIC0gYnl0ZXMgb2YgY2xlYXIgY29kZQpuZmRDb250cmFjdEluaXQ6Cglwcm90byAzIDAKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo3MTgKCS8vIGFzc2VydCh0aGlzLmlzVHhuTGFiKHRoaXMudHhuR3JvdXBbdGhpcy50eG4uZ3JvdXBJbmRleF0pKQoJdHhuIEdyb3VwSW5kZXgKCWNhbGxzdWIgaXNUeG5MYWIKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjcyMQoJLy8gdGhpcy5ib3hlcyhSRUdJU1RSWV9DT05UUkFDVF9CT1hfQVBQUk9WQUxfTkFNRVBSRUZJWCArIHZlcnNpb24pLmNyZWF0ZShzaXplKQoJYnl0ZSAiY29udHJhY3Q6QToiCglmcmFtZV9kaWcgLTEgLy8gdmVyc2lvbjogc3RyaW5nCgljb25jYXQKCWZyYW1lX2RpZyAtMiAvLyBzaXplOiB1aW50NjQKCWJveF9jcmVhdGUKCXBvcAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjcyMgoJLy8gdGhpcy5ib3hlcyhSRUdJU1RSWV9DT05UUkFDVF9CT1hfQ0xFQVJfTkFNRVBSRUZJWCArIHZlcnNpb24pLnZhbHVlID0gY2xlYXJDb2RlCglieXRlICJjb250cmFjdDpDOiIKCWZyYW1lX2RpZyAtMSAvLyB2ZXJzaW9uOiBzdHJpbmcKCWNvbmNhdAoJZnJhbWVfZGlnIC0zIC8vIGNsZWFyQ29kZTogYnl0ZXMKCWJveF9wdXQKCXJldHN1YgoKLy8gbmZkQ29udHJhY3RMb2FkKHN0cmluZyx1aW50NjQsYnl0ZVtdKXZvaWQKKmFiaV9yb3V0ZV9uZmRDb250cmFjdExvYWQ6CgkvLyBkYXRhOiBieXRlW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWV4dHJhY3QgMiAwCgoJLy8gb2Zmc2V0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCgkvLyB2ZXJzaW9uOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBuZmRDb250cmFjdExvYWQoc3RyaW5nLHVpbnQ2NCxieXRlW10pdm9pZAoJY2FsbHN1YiBuZmRDb250cmFjdExvYWQKCWludCAxCglyZXR1cm4KCi8vIG5mZENvbnRyYWN0TG9hZCh2ZXJzaW9uOiBzdHJpbmcsIG9mZnNldDogdWludDY0LCBkYXRhOiBieXRlcyk6IHZvaWQKLy8KLy8gTG9hZHMgY29udHJhY3QgZGF0YSBpbnRvIHRoZSBgUkVHSVNUUllfQ09OVFJBQ1RfQk9YX0FQUFJPVkFMX05BTUVQUkVGSVggKyB2ZXJzaW9uYCBib3ggYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQuCi8vCi8vIEBwYXJhbSB7c3RyaW5nfSB2ZXJzaW9uIC0gVGhlIHZlcnNpb24gb2YgdGhlIGNvbnRyYWN0LgovLyBAcGFyYW0ge3VpbnQ2NH0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byByZXBsYWNlIHRoZSBjb250cmFjdCBkYXRhIHdpdGhpbiB0aGUgYm94LgovLyBAcGFyYW0ge2J5dGVzfSBkYXRhIC0gVGhlIGNvbnRyYWN0IGRhdGEgdG8gYmUgbG9hZGVkLgpuZmRDb250cmFjdExvYWQ6Cglwcm90byAzIDAKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo3MzMKCS8vIGFzc2VydCh0aGlzLmlzVHhuTGFiKHRoaXMudHhuR3JvdXBbdGhpcy50eG4uZ3JvdXBJbmRleF0pKQoJdHhuIEdyb3VwSW5kZXgKCWNhbGxzdWIgaXNUeG5MYWIKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjczNAoJLy8gdGhpcy5ib3hlcyhSRUdJU1RSWV9DT05UUkFDVF9CT1hfQVBQUk9WQUxfTkFNRVBSRUZJWCArIHZlcnNpb24pLnJlcGxhY2Uob2Zmc2V0LCBkYXRhKQoJYnl0ZSAiY29udHJhY3Q6QToiCglmcmFtZV9kaWcgLTEgLy8gdmVyc2lvbjogc3RyaW5nCgljb25jYXQKCWZyYW1lX2RpZyAtMiAvLyBvZmZzZXQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC0zIC8vIGRhdGE6IGJ5dGVzCglib3hfcmVwbGFjZQoJcmV0c3ViCgovLyBuZmRDb250cmFjdENvbW1pdChzdHJpbmcpdm9pZAoqYWJpX3JvdXRlX25mZENvbnRyYWN0Q29tbWl0OgoJLy8gdmVyc2lvbjogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgbmZkQ29udHJhY3RDb21taXQoc3RyaW5nKXZvaWQKCWNhbGxzdWIgbmZkQ29udHJhY3RDb21taXQKCWludCAxCglyZXR1cm4KCi8vIG5mZENvbnRyYWN0Q29tbWl0KHZlcnNpb246IHN0cmluZyk6IHZvaWQKLy8KLy8gQ29tbWl0IGEgbmV3IHZlcnNpb24gb2YgdGhlIGNvbnRyYWN0LgovLwovLyBAcGFyYW0ge3N0cmluZ30gdmVyc2lvbiAtIFRoZSB2ZXJzaW9uIG51bWJlciBvZiB0aGUgY29udHJhY3QgdG8gYmUgY29tbWl0dGVkLgpuZmRDb250cmFjdENvbW1pdDoKCXByb3RvIDEgMAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjc0MwoJLy8gYXNzZXJ0KHRoaXMuaXNUeG5MYWIodGhpcy50eG5Hcm91cFt0aGlzLnR4bi5ncm91cEluZGV4XSkpCgl0eG4gR3JvdXBJbmRleAoJY2FsbHN1YiBpc1R4bkxhYgoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NzQ0CgkvLyB0aGlzLmJveGVzKFJFR0lTVFJZX0NPTlRSQUNUX0JPWF9DVVJSRU5UX0NPTlRSQUNUKS52YWx1ZSA9IHZlcnNpb24KCWJ5dGUgImN1cnJlbnQiCglmcmFtZV9kaWcgLTEgLy8gdmVyc2lvbjogc3RyaW5nCglib3hfcHV0CglyZXRzdWIKCi8vIHVzZEluTWljcm9BbGdvKHVpbnQ2NCl1aW50NjQKKmFiaV9yb3V0ZV91c2RJbk1pY3JvQWxnbzoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gdXNkQ29zdDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSB1c2RJbk1pY3JvQWxnbyh1aW50NjQpdWludDY0CgljYWxsc3ViIHVzZEluTWljcm9BbGdvCglpdG9iCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gdXNkSW5NaWNyb0FsZ28odXNkQ29zdDogdWludDY0KTogdWludDY0CnVzZEluTWljcm9BbGdvOgoJcHJvdG8gMSAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMgoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjc1MAoJLy8gdHMgPSBBcHBJRC5mcm9tVWludDY0KHRoaXMuYWxnb1VzZE9yYWNsZUFwcElkKS5nbG9iYWxTdGF0ZSgndHMnKSBhcyB1aW50NjQKCWxvYWQgMjA0IC8vIFRNUExfYWxnb1VzZE9yYWNsZUFwcElkCglieXRlIDB4NzQ3MyAvLyAidHMiCglhcHBfZ2xvYmFsX2dldF9leAoKCS8vIGdsb2JhbCBzdGF0ZSB2YWx1ZSBkb2VzIG5vdCBleGlzdDogQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLmFsZ29Vc2RPcmFjbGVBcHBJZCkuZ2xvYmFsU3RhdGUoJ3RzJykKCWFzc2VydAoJZnJhbWVfYnVyeSAwIC8vIHRzOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo3NTEKCS8vIGRlY2ltYWxzID0gQXBwSUQuZnJvbVVpbnQ2NCh0aGlzLmFsZ29Vc2RPcmFjbGVBcHBJZCkuZ2xvYmFsU3RhdGUoJ2RlY2ltYWxzJykgYXMgdWludDY0Cglsb2FkIDIwNCAvLyBUTVBMX2FsZ29Vc2RPcmFjbGVBcHBJZAoJYnl0ZSAweDY0NjU2MzY5NmQ2MTZjNzMgLy8gImRlY2ltYWxzIgoJYXBwX2dsb2JhbF9nZXRfZXgKCgkvLyBnbG9iYWwgc3RhdGUgdmFsdWUgZG9lcyBub3QgZXhpc3Q6IEFwcElELmZyb21VaW50NjQodGhpcy5hbGdvVXNkT3JhY2xlQXBwSWQpLmdsb2JhbFN0YXRlKCdkZWNpbWFscycpCglhc3NlcnQKCWZyYW1lX2J1cnkgMSAvLyBkZWNpbWFsczogdWludDY0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NzUyCgkvLyBwcmljZSA9IEFwcElELmZyb21VaW50NjQodGhpcy5hbGdvVXNkT3JhY2xlQXBwSWQpLmdsb2JhbFN0YXRlKCdwcmljZScpIGFzIHVpbnQ2NAoJbG9hZCAyMDQgLy8gVE1QTF9hbGdvVXNkT3JhY2xlQXBwSWQKCWJ5dGUgMHg3MDcyNjk2MzY1IC8vICJwcmljZSIKCWFwcF9nbG9iYWxfZ2V0X2V4CgoJLy8gZ2xvYmFsIHN0YXRlIHZhbHVlIGRvZXMgbm90IGV4aXN0OiBBcHBJRC5mcm9tVWludDY0KHRoaXMuYWxnb1VzZE9yYWNsZUFwcElkKS5nbG9iYWxTdGF0ZSgncHJpY2UnKQoJYXNzZXJ0CglmcmFtZV9idXJ5IDIgLy8gcHJpY2U6IHVpbnQ2NAoKCS8vICppZjMzX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NzU0CgkvLyBnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCAtIHRzID4gODY0MDAKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWZyYW1lX2RpZyAwIC8vIHRzOiB1aW50NjQKCS0KCWludCA4NjQwMAoJPgoJYnogKmlmMzNfZW5kCgoJLy8gKmlmMzNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NzU1CgkvLyBkZWNpbWFscyA9IDIKCWludCAyCglmcmFtZV9idXJ5IDEgLy8gZGVjaW1hbHM6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjc1NgoJLy8gcHJpY2UgPSAzMwoJaW50IDMzCglmcmFtZV9idXJ5IDIgLy8gcHJpY2U6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjc1NwoJLy8gbG9nKCdvcmFjbGUgPjI0aHIgdXNpbmcgLjMzYycpCglieXRlIDB4NmY3MjYxNjM2YzY1MjAzZTMyMzQ2ODcyMjA3NTczNjk2ZTY3MjAyZTMzMzM2MyAvLyAib3JhY2xlID4yNGhyIHVzaW5nIC4zM2MiCglsb2cKCippZjMzX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjc2MQoJLy8gcmV0dXJuICgodXNkQ29zdCAqIDEwXzAwMCAqIHRoaXMucG93MTAoZGVjaW1hbHMpKSAvIHByaWNlIC8gMTBfMDAwKSAqIDEwXzAwMAoJZnJhbWVfZGlnIC0xIC8vIHVzZENvc3Q6IHVpbnQ2NAoJaW50IDEwXzAwMAoJKgoJZnJhbWVfZGlnIDEgLy8gZGVjaW1hbHM6IHVpbnQ2NAoJY2FsbHN1YiBwb3cxMAoJKgoJZnJhbWVfZGlnIDIgLy8gcHJpY2U6IHVpbnQ2NAoJLwoJaW50IDEwXzAwMAoJLwoJaW50IDEwXzAwMAoJKgoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDIKCXJldHN1YgoKLy8gY29zdFRvQWRkVG9BZGRyZXNzKGFkZHJlc3MpdWludDY0CiphYmlfcm91dGVfY29zdFRvQWRkVG9BZGRyZXNzOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBsb29rdXBBZGRyZXNzOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKGxvb2t1cEFkZHJlc3MpIGZvciBjb3N0VG9BZGRUb0FkZHJlc3MgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIGV4ZWN1dGUgY29zdFRvQWRkVG9BZGRyZXNzKGFkZHJlc3MpdWludDY0CgljYWxsc3ViIGNvc3RUb0FkZFRvQWRkcmVzcwoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGNvc3RUb0FkZFRvQWRkcmVzcyhsb29rdXBBZGRyZXNzOiBBZGRyZXNzKTogdWludDY0Ci8vCi8vIFJldHVybnMgdGhlIGNvc3QgdG8gYWRkIGFuIE5GRCB0byB0aGUgcmV2ZXJzZS1sb29rdXAgZGF0YQovLwovLyBAcGFyYW0ge0FkZHJlc3N9IGxvb2t1cEFkZHJlc3MgLSBUaGUgYWRkcmVzcyB0byBhZGQgdGhlIE5GRCBhcHAgaWQgdG8KY29zdFRvQWRkVG9BZGRyZXNzOgoJcHJvdG8gMSAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo3NzAKCS8vIGJveE5hbWUgPSB0aGlzLmdldEFsZ29BZGRyZXNzQm94TmFtZShyYXdCeXRlcyhsb29rdXBBZGRyZXNzKSkKCWZyYW1lX2RpZyAtMSAvLyBsb29rdXBBZGRyZXNzOiBBZGRyZXNzCgljYWxsc3ViIGdldEFsZ29BZGRyZXNzQm94TmFtZQoJZnJhbWVfYnVyeSAwIC8vIGJveE5hbWU6IGJ5dGVbXQoKCS8vICppZjM0X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6NzcxCgkvLyAhdGhpcy5ib3hlcyhib3hOYW1lKS5leGlzdHMKCWZyYW1lX2RpZyAwIC8vIGJveE5hbWU6IGJ5dGVbXQoJYm94X2xlbgoJc3dhcAoJcG9wCgkhCglieiAqaWYzNF9lbmQKCgkvLyAqaWYzNF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo3NzMKCS8vIHJldHVybiB0aGlzLmNvc3RGb3JCb3hTdG9yYWdlKDEsIGJveE5hbWUubGVuZ3RoICsgOCkKCWZyYW1lX2RpZyAwIC8vIGJveE5hbWU6IGJ5dGVbXQoJbGVuCglpbnQgOAoJKwoJaW50IDEKCWNhbGxzdWIgY29zdEZvckJveFN0b3JhZ2UKCWIgKmNvc3RUb0FkZFRvQWRkcmVzcypyZXR1cm4KCippZjM0X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjc3NgoJLy8gcmV0dXJuIFNDQk9YX1BFUkJZVEUgKiA4CglpbnQgMzIwMAoKKmNvc3RUb0FkZFRvQWRkcmVzcypyZXR1cm46CgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gaXNUeG5MYWIodHhuOiBUeG4pOiBib29sZWFuCmlzVHhuTGFiOgoJcHJvdG8gMSAxCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6ODA2CgkvLyByZXR1cm4gKAoJLy8gICAgICAgICAgICAgdHhuLnNlbmRlci5hc3NldEJhbGFuY2UoQXNzZXRJRC5mcm9tVWludDY0KHRoaXMuYWRtaW5Bc2FJZCkpID09PSAxICYmCgkvLyAgICAgICAgICAgICB0eG4uY2xvc2VSZW1haW5kZXJUbyA9PT0gZ2xvYmFscy56ZXJvQWRkcmVzcyAmJgoJLy8gICAgICAgICAgICAgdHhuLnJla2V5VG8gPT09IGdsb2JhbHMuemVyb0FkZHJlc3MKCS8vICAgICAgICAgKQoJZnJhbWVfZGlnIC0xIC8vIHR4bjogVHhuCglndHhucyBTZW5kZXIKCWxvYWQgMjAwIC8vIFRNUExfYWRtaW5Bc2FJZAoJYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCglwb3AKCWludCAxCgk9PQoJZHVwCglieiAqc2tpcF9hbmQxNQoJZnJhbWVfZGlnIC0xIC8vIHR4bjogVHhuCglndHhucyBDbG9zZVJlbWFpbmRlclRvCglnbG9iYWwgWmVyb0FkZHJlc3MKCT09CgkmJgoKKnNraXBfYW5kMTU6CglkdXAKCWJ6ICpza2lwX2FuZDE2CglmcmFtZV9kaWcgLTEgLy8gdHhuOiBUeG4KCWd0eG5zIFJla2V5VG8KCWdsb2JhbCBaZXJvQWRkcmVzcwoJPT0KCSYmCgoqc2tpcF9hbmQxNjoKCXJldHN1YgoKLy8gZ2V0TmZkSW5zdGFuY2VNYnIoKTogdWludDY0CmdldE5mZEluc3RhbmNlTWJyOgoJcHJvdG8gMCAxCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6ODE1CgkvLyByZXR1cm4gdGhpcy5taW5CYWxhbmNlRm9yQWNjb3VudCgwLCAwLCAxLCAwLCAwLCAwLCAwKQoJaW50IDAKCWR1cG4gMwoJaW50IDEKCWludCAwCglkdXAKCWNhbGxzdWIgbWluQmFsYW5jZUZvckFjY291bnQKCXJldHN1YgoKLy8gY2FsbE5GRElzQWRkcmVzc0luRmllbGQobmZkQXBwSWQ6IHVpbnQ2NCwgZmllbGROYW1lOiBzdHJpbmcsIGFkZHJlc3M6IEFkZHJlc3MpOiBib29sZWFuCmNhbGxORkRJc0FkZHJlc3NJbkZpZWxkOgoJcHJvdG8gMyAxCgoJLy8gKmlmMzVfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo4MTkKCS8vIHRoaXMuaXNQcmVWMyhuZmRBcHBJZCkKCWZyYW1lX2RpZyAtMSAvLyBuZmRBcHBJZDogdWludDY0CgljYWxsc3ViIGlzUHJlVjMKCWJ6ICppZjM1X2VuZAoKCS8vICppZjM1X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjgyMQoJLy8gc2VuZEFwcENhbGwoewoJLy8gICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQobmZkQXBwSWQpLAoJLy8gICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uQXJnczogW05GRF9DQUxMX0lTX0FERFJFU1NfSU5fRklFTEQsIGZpZWxkTmFtZSwgcmF3Qnl0ZXMoYWRkcmVzcyldLAoJLy8gICAgICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6ODIyCgkvLyBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KG5mZEFwcElkKQoJZnJhbWVfZGlnIC0xIC8vIG5mZEFwcElkOiB1aW50NjQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25JRAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjgyMwoJLy8gYXBwbGljYXRpb25BcmdzOiBbTkZEX0NBTExfSVNfQUREUkVTU19JTl9GSUVMRCwgZmllbGROYW1lLCByYXdCeXRlcyhhZGRyZXNzKV0KCWJ5dGUgImlzX2FkZHJlc3NfaW5fZmllbGQiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIC0yIC8vIGZpZWxkTmFtZTogc3RyaW5nCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIC0zIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjgyNQoJLy8gcmV0dXJuIGJ0b2kodGhpcy5pdHhuLmxhc3RMb2cpID09PSAxCglpdHhuIExhc3RMb2cKCWJ0b2kKCWludCAxCgk9PQoJcmV0c3ViCgoqaWYzNV9lbmQ6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo4MjgKCS8vIHJldHVybiBzZW5kTWV0aG9kQ2FsbDx0eXBlb2YgTkZESW5zdGFuY2UucHJvdG90eXBlLmlzQWRkcmVzc0luRmllbGQ+KHsKCS8vICAgICAgICAgICAgIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQobmZkQXBwSWQpLAoJLy8gICAgICAgICAgICAgbWV0aG9kQXJnczogW2ZpZWxkTmFtZSwgYWRkcmVzc10sCgkvLyAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnQgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoJbWV0aG9kICJpc0FkZHJlc3NJbkZpZWxkKHN0cmluZyxhZGRyZXNzKWJvb2wiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjgyOQoJLy8gYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJZCkKCWZyYW1lX2RpZyAtMSAvLyBuZmRBcHBJZDogdWludDY0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo4MzAKCS8vIG1ldGhvZEFyZ3M6IFtmaWVsZE5hbWUsIGFkZHJlc3NdCglmcmFtZV9kaWcgLTIgLy8gZmllbGROYW1lOiBzdHJpbmcKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIC0zIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJaXR4biBOdW1Mb2dzCglpbnQgMQoJLQoJaXR4bmFzIExvZ3MKCWV4dHJhY3QgNCAwCglpbnQgMAoJZ2V0Yml0CglyZXRzdWIKCi8vIGZpbmRJbnRJblNldChrZXk6IGJ5dGVzLCBpbnRWYWw6IHVpbnQ2NCk6IGJvb2xlYW4KZmluZEludEluU2V0OgoJcHJvdG8gMiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMwoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjgzNQoJLy8gYXNzZXJ0KGludFZhbCAhPT0gMCkKCWZyYW1lX2RpZyAtMiAvLyBpbnRWYWw6IHVpbnQ2NAoJaW50IDAKCSE9Cglhc3NlcnQKCgkvLyAqaWYzNl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjgzNgoJLy8gIXRoaXMuYm94ZXMoa2V5KS5leGlzdHMKCWZyYW1lX2RpZyAtMSAvLyBrZXk6IGJ5dGVzCglib3hfbGVuCglzd2FwCglwb3AKCSEKCWJ6ICppZjM2X2VuZAoKCS8vICppZjM2X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjgzNwoJLy8gcmV0dXJuIGZhbHNlCglpbnQgMAoJYiAqZmluZEludEluU2V0KnJldHVybgoKKmlmMzZfZW5kOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6ODM5CgkvLyBib3hEYXRhID0gdGhpcy5ib3hlcyhrZXkpLnZhbHVlCglmcmFtZV9kaWcgLTEgLy8ga2V5OiBieXRlcwoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5ib3hlcyhrZXkpLnZhbHVlCglhc3NlcnQKCWZyYW1lX2J1cnkgMCAvLyBib3hEYXRhOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo4NDAKCS8vIGJ5dGVzT2ZTZXQgPSBib3hEYXRhCglmcmFtZV9kaWcgMCAvLyBib3hEYXRhOiBieXRlW10KCWZyYW1lX2J1cnkgMSAvLyBieXRlc09mU2V0OiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo4NDEKCS8vIGxpbWl0ID0gYm94RGF0YS5sZW5ndGggLyA4CglmcmFtZV9kaWcgMCAvLyBib3hEYXRhOiBieXRlW10KCWxlbgoJaW50IDgKCS8KCWZyYW1lX2J1cnkgMiAvLyBsaW1pdDogdWludDY0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6ODQzCgkvLyBmb3IgKGxldCBpID0gMDsgaSA8IGxpbWl0OyBpICs9IDEpCglpbnQgMAoJZnJhbWVfYnVyeSAzIC8vIGk6IHVpbnQ2NAoKKmZvcl8xOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6ODQzCgkvLyBpIDwgbGltaXQKCWZyYW1lX2RpZyAzIC8vIGk6IHVpbnQ2NAoJZnJhbWVfZGlnIDIgLy8gbGltaXQ6IHVpbnQ2NAoJPAoJYnogKmZvcl8xX2VuZAoKCS8vICppZjM3X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6ODQ0CgkvLyBidG9pKGV4dHJhY3QzKGJ5dGVzT2ZTZXQsIGkgKiA4LCA4KSkgPT09IGludFZhbAoJZnJhbWVfZGlnIDEgLy8gYnl0ZXNPZlNldDogYnl0ZVtdCglmcmFtZV9kaWcgMyAvLyBpOiB1aW50NjQKCWludCA4CgkqCglpbnQgOAoJZXh0cmFjdDMKCWJ0b2kKCWZyYW1lX2RpZyAtMiAvLyBpbnRWYWw6IHVpbnQ2NAoJPT0KCWJ6ICppZjM3X2VuZAoKCS8vICppZjM3X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjg0NAoJLy8gcmV0dXJuIHRydWUKCWludCAxCgliICpmaW5kSW50SW5TZXQqcmV0dXJuCgoqaWYzN19lbmQ6CgoqZm9yXzFfY29udGludWU6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo4NDMKCS8vIGkgKz0gMQoJZnJhbWVfZGlnIDMgLy8gaTogdWludDY0CglpbnQgMQoJKwoJZnJhbWVfYnVyeSAzIC8vIGk6IHVpbnQ2NAoJYiAqZm9yXzEKCipmb3JfMV9lbmQ6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo4NDcKCS8vIHJldHVybiBmYWxzZQoJaW50IDAKCipmaW5kSW50SW5TZXQqcmV0dXJuOgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMwoJcmV0c3ViCgovLyBhZGRJbnRUb1NldChrZXk6IGJ5dGVzLCBpbnRWYWw6IHVpbnQ2NCk6IGJvb2xlYW4KYWRkSW50VG9TZXQ6Cglwcm90byAyIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiAzCgoJLy8gKmlmMzhfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo4NTEKCS8vICF0aGlzLmJveGVzKGtleSkuZXhpc3RzCglmcmFtZV9kaWcgLTEgLy8ga2V5OiBieXRlcwoJYm94X2xlbgoJc3dhcAoJcG9wCgkhCglieiAqaWYzOF9lbmQKCgkvLyAqaWYzOF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo4NTMKCS8vIHRoaXMuYm94ZXMoa2V5KS52YWx1ZSA9IGl0b2IoaW50VmFsKQoJZnJhbWVfZGlnIC0xIC8vIGtleTogYnl0ZXMKCWZyYW1lX2RpZyAtMiAvLyBpbnRWYWw6IHVpbnQ2NAoJaXRvYgoJYm94X3B1dAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjg1NAoJLy8gcmV0dXJuIHRydWUKCWludCAxCgliICphZGRJbnRUb1NldCpyZXR1cm4KCippZjM4X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjg1NgoJLy8gaWRMaXN0ID0gdGhpcy5ib3hlcyhrZXkpLnZhbHVlCglmcmFtZV9kaWcgLTEgLy8ga2V5OiBieXRlcwoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5ib3hlcyhrZXkpLnZhbHVlCglhc3NlcnQKCWZyYW1lX2J1cnkgMCAvLyBpZExpc3Q6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjg1NwoJLy8gbGltaXQgPSBpZExpc3QubGVuZ3RoIC8gOAoJZnJhbWVfZGlnIDAgLy8gaWRMaXN0OiBieXRlW10KCWxlbgoJaW50IDgKCS8KCWZyYW1lX2J1cnkgMSAvLyBsaW1pdDogdWludDY0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6ODU5CgkvLyBmb3IgKGxldCBpID0gMDsgaSA8IGxpbWl0OyBpICs9IDEpCglpbnQgMAoJZnJhbWVfYnVyeSAyIC8vIGk6IHVpbnQ2NAoKKmZvcl8yOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6ODU5CgkvLyBpIDwgbGltaXQKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJZnJhbWVfZGlnIDEgLy8gbGltaXQ6IHVpbnQ2NAoJPAoJYnogKmZvcl8yX2VuZAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjg2MAoJLy8gY3VycmVudFZhbEluU2xvdCA9IGV4dHJhY3RVaW50NjQoaWRMaXN0LCBpICogOCkKCWZyYW1lX2RpZyAwIC8vIGlkTGlzdDogYnl0ZVtdCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludCA4CgkqCglleHRyYWN0X3VpbnQ2NAoJZnJhbWVfYnVyeSAzIC8vIGN1cnJlbnRWYWxJblNsb3Q6IHVpbnQ2NAoKCS8vICppZjM5X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6ODYyCgkvLyBjdXJyZW50VmFsSW5TbG90ID09PSAwCglmcmFtZV9kaWcgMyAvLyBjdXJyZW50VmFsSW5TbG90OiB1aW50NjQKCWludCAwCgk9PQoJYnogKmlmMzlfZW5kCgoJLy8gKmlmMzlfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6ODY0CgkvLyB0aGlzLmJveGVzKGtleSkucmVwbGFjZShpICogOCwgaXRvYihpbnRWYWwpKQoJZnJhbWVfZGlnIC0xIC8vIGtleTogYnl0ZXMKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50IDgKCSoKCWZyYW1lX2RpZyAtMiAvLyBpbnRWYWw6IHVpbnQ2NAoJaXRvYgoJYm94X3JlcGxhY2UKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo4NjUKCS8vIHJldHVybiB0cnVlCglpbnQgMQoJYiAqYWRkSW50VG9TZXQqcmV0dXJuCgoqaWYzOV9lbmQ6CgkvLyAqaWY0MF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjg2NwoJLy8gY3VycmVudFZhbEluU2xvdCA9PT0gaW50VmFsCglmcmFtZV9kaWcgMyAvLyBjdXJyZW50VmFsSW5TbG90OiB1aW50NjQKCWZyYW1lX2RpZyAtMiAvLyBpbnRWYWw6IHVpbnQ2NAoJPT0KCWJ6ICppZjQwX2VuZAoKCS8vICppZjQwX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjg2OAoJLy8gcmV0dXJuIHRydWUKCWludCAxCgliICphZGRJbnRUb1NldCpyZXR1cm4KCippZjQwX2VuZDoKCipmb3JfMl9jb250aW51ZToKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjg1OQoJLy8gaSArPSAxCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludCAxCgkrCglmcmFtZV9idXJ5IDIgLy8gaTogdWludDY0CgliICpmb3JfMgoKKmZvcl8yX2VuZDoKCS8vICppZjQxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6ODcyCgkvLyBpZExpc3QubGVuZ3RoIDwgOCAqIDEyNgoJZnJhbWVfZGlnIDAgLy8gaWRMaXN0OiBieXRlW10KCWxlbgoJaW50IDEwMDgKCTwKCWJ6ICppZjQxX2VuZAoKCS8vICppZjQxX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjg3MwoJLy8gdGhpcy5ib3hlcyhrZXkpLmRlbGV0ZSgpCglmcmFtZV9kaWcgLTEgLy8ga2V5OiBieXRlcwoJYm94X2RlbAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjg3NAoJLy8gdGhpcy5ib3hlcyhrZXkpLnZhbHVlID0gaWRMaXN0ICsgaXRvYihpbnRWYWwpCglmcmFtZV9kaWcgLTEgLy8ga2V5OiBieXRlcwoJZnJhbWVfZGlnIDAgLy8gaWRMaXN0OiBieXRlW10KCWZyYW1lX2RpZyAtMiAvLyBpbnRWYWw6IHVpbnQ2NAoJaXRvYgoJY29uY2F0Cglib3hfcHV0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6ODc1CgkvLyByZXR1cm4gdHJ1ZQoJaW50IDEKCWIgKmFkZEludFRvU2V0KnJldHVybgoKKmlmNDFfZW5kOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6ODc4CgkvLyByZXR1cm4gZmFsc2UKCWludCAwCgoqYWRkSW50VG9TZXQqcmV0dXJuOgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMwoJcmV0c3ViCgovLyBjYWxsTkZEUmVnaXN0cnlBcHByb3ZlZEFkZHJlc3NBZGQobmZkQXBwSWQ6IHVpbnQ2NCwgZmllbGRUb01vdmU6IHN0cmluZywgZGVzdGluYXRpb25GaWVsZDogc3RyaW5nKTogYm9vbGVhbgpjYWxsTkZEUmVnaXN0cnlBcHByb3ZlZEFkZHJlc3NBZGQ6Cglwcm90byAzIDEKCgkvLyAqaWY0Ml9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjg4NgoJLy8gdGhpcy5pc1ByZVYzKG5mZEFwcElkKQoJZnJhbWVfZGlnIC0xIC8vIG5mZEFwcElkOiB1aW50NjQKCWNhbGxzdWIgaXNQcmVWMwoJYnogKmlmNDJfZW5kCgoJLy8gKmlmNDJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6ODg4CgkvLyBzZW5kQXBwQ2FsbCh7CgkvLyAgICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgcmVnX2FkZF92ZXJpZmllZF9hZGRyZXNzIG1ldGhvZCB3aXRoaW4gdGhlIE5GRCwgYXJnczoKCS8vICAgICAgICAgICAgICAgICAvLyBzdHI6IHJlZ19hZGRfdmVyaWZpZWRfYWRkcmVzcwoJLy8gICAgICAgICAgICAgICAgIC8vIHN0cjogZmllbGQgYmVpbmcgJ3ZlcmlmaWVkJyAod2hpY2ggd2UgYWxyZWFkeSBkaWQpIC0gYmFzaWNhbGx5IGZpZWxkIHZhbHVlIHRvIG1vdmUgLyBhZGQgdG8gc2V0CgkvLyAgICAgICAgICAgICAgICAgLy8gc3RyOiBmaWVsZCBuYW1lIG9mIHNldCB3aGljaCB2YWx1ZSBpbiBmaWVsZCB0byB2ZXJpZnkgaXMgYWRkZWQgdG8uCgkvLyAgICAgICAgICAgICAgICAgYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJZCksCgkvLyAgICAgICAgICAgICAgICAgYXBwbGljYXRpb25BcmdzOiBbTkZEX0NBTExfUkVHX0FERF9WRVJJRklFRF9BRERSRVNTLCBmaWVsZFRvTW92ZSwgZGVzdGluYXRpb25GaWVsZF0sCgkvLyAgICAgICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IGFwcGwKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo4OTMKCS8vIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQobmZkQXBwSWQpCglmcmFtZV9kaWcgLTEgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6ODk0CgkvLyBhcHBsaWNhdGlvbkFyZ3M6IFtORkRfQ0FMTF9SRUdfQUREX1ZFUklGSUVEX0FERFJFU1MsIGZpZWxkVG9Nb3ZlLCBkZXN0aW5hdGlvbkZpZWxkXQoJYnl0ZSAicmVnX2FkZF92ZXJpZmllZF9hZGRyZXNzIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWZyYW1lX2RpZyAtMiAvLyBmaWVsZFRvTW92ZTogc3RyaW5nCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIC0zIC8vIGRlc3RpbmF0aW9uRmllbGQ6IHN0cmluZwoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6ODk3CgkvLyByZXR1cm4gYnRvaSh0aGlzLml0eG4ubGFzdExvZykgPT09IDEKCWl0eG4gTGFzdExvZwoJYnRvaQoJaW50IDEKCT09CglyZXRzdWIKCippZjQyX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjkwMAoJLy8gcmV0dXJuIHNlbmRNZXRob2RDYWxsPHR5cGVvZiBORkRJbnN0YW5jZS5wcm90b3R5cGUucmVnaXN0cnlBZGRpbmdWZXJpZmllZEFkZHJlc3M+KHsKCS8vICAgICAgICAgICAgIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQobmZkQXBwSWQpLAoJLy8gICAgICAgICAgICAgbWV0aG9kQXJnczogW2ZpZWxkVG9Nb3ZlLCBkZXN0aW5hdGlvbkZpZWxkXSwKCS8vICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgltZXRob2QgInJlZ2lzdHJ5QWRkaW5nVmVyaWZpZWRBZGRyZXNzKHN0cmluZyxzdHJpbmcpYm9vbCIKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6OTAxCgkvLyBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KG5mZEFwcElkKQoJZnJhbWVfZGlnIC0xIC8vIG5mZEFwcElkOiB1aW50NjQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25JRAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjkwMgoJLy8gbWV0aG9kQXJnczogW2ZpZWxkVG9Nb3ZlLCBkZXN0aW5hdGlvbkZpZWxkXQoJZnJhbWVfZGlnIC0yIC8vIGZpZWxkVG9Nb3ZlOiBzdHJpbmcKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIC0zIC8vIGRlc3RpbmF0aW9uRmllbGQ6IHN0cmluZwoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJaXR4biBOdW1Mb2dzCglpbnQgMQoJLQoJaXR4bmFzIExvZ3MKCWV4dHJhY3QgNCAwCglpbnQgMAoJZ2V0Yml0CglyZXRzdWIKCi8vIGNhbGxORkRSZWdpc3RyeUFwcHJvdmVkQWRkcmVzc1JlbW92ZShuZmRBcHBJZDogdWludDY0LCBmaWVsZFRvQ2hhbmdlOiBzdHJpbmcsIGFkZHJlc3M6IEFkZHJlc3MsIG1iclJlZnVuZERlc3Q6IEFkZHJlc3MpOiBib29sZWFuCmNhbGxORkRSZWdpc3RyeUFwcHJvdmVkQWRkcmVzc1JlbW92ZToKCXByb3RvIDQgMQoKCS8vICppZjQzX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6OTEyCgkvLyB0aGlzLmlzUHJlVjMobmZkQXBwSWQpCglmcmFtZV9kaWcgLTEgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJY2FsbHN1YiBpc1ByZVYzCglieiAqaWY0M19lbmQKCgkvLyAqaWY0M19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo5MTgKCS8vIHNlbmRBcHBDYWxsKHsKCS8vICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KG5mZEFwcElkKSwKCS8vICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbkFyZ3M6IFtORkRfQ0FMTF9SRUdfUkVNT1ZFX1ZFUklGSUVEX0FERFJFU1MsIGZpZWxkVG9DaGFuZ2UsIHJhd0J5dGVzKGFkZHJlc3MpXSwKCS8vICAgICAgICAgICAgIH0pCglpdHhuX2JlZ2luCglpbnQgYXBwbAoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjkxOQoJLy8gYXBwbGljYXRpb25JRDogQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJZCkKCWZyYW1lX2RpZyAtMSAvLyBuZmRBcHBJZDogdWludDY0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo5MjAKCS8vIGFwcGxpY2F0aW9uQXJnczogW05GRF9DQUxMX1JFR19SRU1PVkVfVkVSSUZJRURfQUREUkVTUywgZmllbGRUb0NoYW5nZSwgcmF3Qnl0ZXMoYWRkcmVzcyldCglieXRlICJyZWdfcmVtb3ZlX3ZlcmlmaWVkX2FkZHJlc3MiCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIC0yIC8vIGZpZWxkVG9DaGFuZ2U6IHN0cmluZwoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCWZyYW1lX2RpZyAtMyAvLyBhZGRyZXNzOiBBZGRyZXNzCglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo5MjIKCS8vIHJldHVybiBidG9pKHRoaXMuaXR4bi5sYXN0TG9nKSA9PT0gMQoJaXR4biBMYXN0TG9nCglidG9pCglpbnQgMQoJPT0KCXJldHN1YgoKKmlmNDNfZW5kOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6OTI1CgkvLyByZXR1cm4gc2VuZE1ldGhvZENhbGw8dHlwZW9mIE5GREluc3RhbmNlLnByb3RvdHlwZS5yZWdpc3RyeVJlbW92aW5nVmVyaWZpZWRBZGRyZXNzPih7CgkvLyAgICAgICAgICAgICBhcHBsaWNhdGlvbklEOiBBcHBJRC5mcm9tVWludDY0KG5mZEFwcElkKSwKCS8vICAgICAgICAgICAgIG1ldGhvZEFyZ3M6IFtmaWVsZFRvQ2hhbmdlLCBhZGRyZXNzLCBtYnJSZWZ1bmREZXN0XSwKCS8vICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBhcHBsCglpdHhuX2ZpZWxkIFR5cGVFbnVtCgltZXRob2QgInJlZ2lzdHJ5UmVtb3ZpbmdWZXJpZmllZEFkZHJlc3Moc3RyaW5nLGFkZHJlc3MsYWRkcmVzcylib29sIgoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo5MjYKCS8vIGFwcGxpY2F0aW9uSUQ6IEFwcElELmZyb21VaW50NjQobmZkQXBwSWQpCglmcmFtZV9kaWcgLTEgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6OTI3CgkvLyBtZXRob2RBcmdzOiBbZmllbGRUb0NoYW5nZSwgYWRkcmVzcywgbWJyUmVmdW5kRGVzdF0KCWZyYW1lX2RpZyAtMiAvLyBmaWVsZFRvQ2hhbmdlOiBzdHJpbmcKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CglpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwoJZnJhbWVfZGlnIC0zIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCglmcmFtZV9kaWcgLTQgLy8gbWJyUmVmdW5kRGVzdDogQWRkcmVzcwoJaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKCgkvLyBGZWUgZmllbGQgbm90IHNldCwgZGVmYXVsdGluZyB0byAwCglpbnQgMAoJaXR4bl9maWVsZCBGZWUKCgkvLyBTdWJtaXQgaW5uZXIgdHJhbnNhY3Rpb24KCWl0eG5fc3VibWl0CglpdHhuIE51bUxvZ3MKCWludCAxCgktCglpdHhuYXMgTG9ncwoJZXh0cmFjdCA0IDAKCWludCAwCglnZXRiaXQKCXJldHN1YgoKLy8gaXNFeHBpcmVkKGV4cFRpbWU6IHVpbnQ2NCk6IGJvb2xlYW4KaXNFeHBpcmVkOgoJcHJvdG8gMSAxCgoJLy8gKmlmNDRfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo5MzMKCS8vIGV4cFRpbWUgPT09IDAKCWZyYW1lX2RpZyAtMSAvLyBleHBUaW1lOiB1aW50NjQKCWludCAwCgk9PQoJYnogKmlmNDRfZW5kCgoJLy8gKmlmNDRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6OTM0CgkvLyByZXR1cm4gZmFsc2UKCWludCAwCglyZXRzdWIKCippZjQ0X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjkzNgoJLy8gcmV0dXJuIGdsb2JhbHMubGF0ZXN0VGltZXN0YW1wID4gZXhwVGltZQoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJZnJhbWVfZGlnIC0xIC8vIGV4cFRpbWU6IHVpbnQ2NAoJPgoJcmV0c3ViCgovLyBnZXROb25BYmlOYW1lQXBwSWQoKTogdm9pZApnZXROb25BYmlOYW1lQXBwSWQ6Cglwcm90byAwIDAKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo5NDMKCS8vIGxvZyhpdG9iKHRoaXMuZ2V0TmFtZUFwcElkKHRoaXMudHhuLmFwcGxpY2F0aW9uQXJncyFbMV0gYXMgYnl0ZXMpKSkKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMQoJY2FsbHN1YiBnZXROYW1lQXBwSWQKCWl0b2IKCWxvZwoJcmV0c3ViCgovLyBub25BYmlnZXRBZGRyZXNzQXBwSWRzKCk6IHZvaWQKbm9uQWJpZ2V0QWRkcmVzc0FwcElkczoKCXByb3RvIDAgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6OTUxCgkvLyBib3hOYW1lID0gdGhpcy5nZXRBbGdvQWRkcmVzc0JveE5hbWUodGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVsxXSBhcyBieXRlcykKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMQoJY2FsbHN1YiBnZXRBbGdvQWRkcmVzc0JveE5hbWUKCWZyYW1lX2J1cnkgMCAvLyBib3hOYW1lOiBieXRlW10KCgkvLyAqaWY0NV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjk1MgoJLy8gIXRoaXMuYm94ZXMoYm94TmFtZSkuZXhpc3RzCglmcmFtZV9kaWcgMCAvLyBib3hOYW1lOiBieXRlW10KCWJveF9sZW4KCXN3YXAKCXBvcAoJIQoJYnogKmlmNDVfZW5kCgoJLy8gKmlmNDVfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6OTUzCgkvLyBsb2coJycpCglieXRlIDB4IC8vICIiCglsb2cKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo5NTQKCS8vIHJldHVybgoJcmV0c3ViCgoqaWY0NV9lbmQ6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo5NTcKCS8vIGxvZyh0aGlzLmJveGVzKGJveE5hbWUpLnZhbHVlKQoJZnJhbWVfZGlnIDAgLy8gYm94TmFtZTogYnl0ZVtdCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLmJveGVzKGJveE5hbWUpLnZhbHVlCglhc3NlcnQKCWxvZwoJcmV0c3ViCgovLyBtaWdyYXRlVjFOYW1lKCk6IHZvaWQKbWlncmF0ZVYxTmFtZToKCXByb3RvIDAgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6OTY2CgkvLyBhc3NlcnQoCgkvLyAgICAgICAgICAgICB0aGlzLmlzVjFORkRJREF1dGhlbnRpYyh0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhWzFdIGFzIGJ5dGVzLCBidG9pKHRoaXMudHhuLmFwcGxpY2F0aW9uQXJncyFbMl0pKSwKCS8vICAgICAgICAgICAgICdtdXN0IGJlIGV4aXN0aW5nIHYxIG5hbWUnLAoJLy8gICAgICAgICApCgl0eG4gQXBwbGljYXRpb25BcmdzIDIKCWJ0b2kKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMQoJY2FsbHN1YiBpc1YxTkZESURBdXRoZW50aWMKCgkvLyBtdXN0IGJlIGV4aXN0aW5nIHYxIG5hbWUKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjk3MQoJLy8gbmZkQXNhSUQgPSBBcHBJRC5mcm9tVWludDY0KGJ0b2kodGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVsyXSkpLmdsb2JhbFN0YXRlKFJFR0lTVFJZX0tFWV9BU0FJRCkgYXMgYnl0ZXMKCXR4biBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoJYnl0ZSAiaS5hc2FpZCIKCWFwcF9nbG9iYWxfZ2V0X2V4CgoJLy8gZ2xvYmFsIHN0YXRlIHZhbHVlIGRvZXMgbm90IGV4aXN0OiBBcHBJRC5mcm9tVWludDY0KGJ0b2kodGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVsyXSkpLmdsb2JhbFN0YXRlKFJFR0lTVFJZX0tFWV9BU0FJRCkKCWFzc2VydAoJZnJhbWVfYnVyeSAwIC8vIG5mZEFzYUlEOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo5NzIKCS8vIGFzc2VydChuZmRBc2FJRCAhPT0gJycpCglmcmFtZV9kaWcgMCAvLyBuZmRBc2FJRDogYnl0ZVtdCglieXRlIDB4IC8vICIiCgkhPQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6OTczCgkvLyB0aGlzLmFzc2lnbk5hbWVUb1JlZ2lzdHJ5KAoJLy8gICAgICAgICAgICAgdGhpcy50eG4uYXBwbGljYXRpb25BcmdzIVsxXSBhcyBieXRlcywKCS8vICAgICAgICAgICAgIGJ0b2kobmZkQXNhSUQpLAoJLy8gICAgICAgICAgICAgYnRvaSh0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhWzJdKSwKCS8vICAgICAgICAgICAgIHRydWUsIC8vIHdlJ3JlIG1pZ3JhdGluZwoJLy8gICAgICAgICApCglpbnQgMQoJdHhuIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCglmcmFtZV9kaWcgMCAvLyBuZmRBc2FJRDogYnl0ZVtdCglidG9pCgl0eG4gQXBwbGljYXRpb25BcmdzIDEKCWNhbGxzdWIgYXNzaWduTmFtZVRvUmVnaXN0cnkKCXJldHN1YgoKLy8gbWlncmF0ZVYxQWRkcmVzc0tleXMoYWRkcmVzczogYnl0ZXMsIHN0ckFkZHJlc3M6IHN0cmluZyk6IHZvaWQKbWlncmF0ZVYxQWRkcmVzc0tleXM6Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiAzCgoJLy8gKmlmNDZfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo5ODcKCS8vIHRoaXMuYm94ZXModGhpcy5nZXRBbGdvQWRkcmVzc0JveE5hbWUoYWRkcmVzcykpLmV4aXN0cwoJZnJhbWVfZGlnIC0xIC8vIGFkZHJlc3M6IGJ5dGVzCgljYWxsc3ViIGdldEFsZ29BZGRyZXNzQm94TmFtZQoJYm94X2xlbgoJc3dhcAoJcG9wCglieiAqaWY0Nl9lbmQKCgkvLyAqaWY0Nl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo5ODkKCS8vIHJldHVybgoJcmV0c3ViCgoqaWY0Nl9lbmQ6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo5OTIKCS8vIHByb2dIYXNoID0gdGhpcy5nZXRMc2lnQWRkcmVzcygnYWRkcmVzcy8nICsgc3RyQWRkcmVzcykKCWJ5dGUgMHg2MTY0NjQ3MjY1NzM3MzJmIC8vICJhZGRyZXNzLyIKCWZyYW1lX2RpZyAtMiAvLyBzdHJBZGRyZXNzOiBzdHJpbmcKCWNvbmNhdAoJY2FsbHN1YiBnZXRMc2lnQWRkcmVzcwoJZnJhbWVfYnVyeSAwIC8vIHByb2dIYXNoOiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czo5OTMKCS8vIGJveERhdGFUb1N0b3JlID0gJycKCWJ5dGUgMHggLy8gIiIKCWZyYW1lX2J1cnkgMSAvLyBib3hEYXRhVG9TdG9yZTogYnl0ZVtdCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6OTk2CgkvLyBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpICs9IDEpCglpbnQgMAoJZnJhbWVfYnVyeSAyIC8vIGk6IHVpbnQ2NAoKKmZvcl8zOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6OTk2CgkvLyBpIDwgMTYKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50IDE2Cgk8CglieiAqZm9yXzNfZW5kCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6OTk3CgkvLyBrZXlOYW1lID0gUkVHSVNUUllfS0VZX0FQUElEU0VUUFJFRklYICsgaS50b1N0cmluZygpCglieXRlICJpLmFwcHMiCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWNhbGxzdWIgKml0b2EKCWNvbmNhdAoJZnJhbWVfYnVyeSAzIC8vIGtleU5hbWU6IGJ5dGVbXQoKCS8vICppZjQ3X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6OTk5CgkvLyB0aGlzLmxvY2FsU3RhdGUoQWRkcmVzcy5mcm9tQnl0ZXMocHJvZ0hhc2gpLCBrZXlOYW1lKS5leGlzdHMKCWZyYW1lX2RpZyAwIC8vIHByb2dIYXNoOiBieXRlW10KCXR4bmEgQXBwbGljYXRpb25zIDAKCWZyYW1lX2RpZyAzIC8vIGtleU5hbWU6IGJ5dGVbXQoJYXBwX2xvY2FsX2dldF9leAoJc3dhcAoJcG9wCglieiAqaWY0N19lbHNlCgoJLy8gKmlmNDdfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTAwMAoJLy8gYm94RGF0YVRvU3RvcmUgPSBib3hEYXRhVG9TdG9yZSArIHRoaXMubG9jYWxTdGF0ZShBZGRyZXNzLmZyb21CeXRlcyhwcm9nSGFzaCksIGtleU5hbWUpLnZhbHVlCglmcmFtZV9kaWcgMSAvLyBib3hEYXRhVG9TdG9yZTogYnl0ZVtdCglmcmFtZV9kaWcgMCAvLyBwcm9nSGFzaDogYnl0ZVtdCglmcmFtZV9kaWcgMyAvLyBrZXlOYW1lOiBieXRlW10KCWFwcF9sb2NhbF9nZXQKCWNvbmNhdAoJZnJhbWVfYnVyeSAxIC8vIGJveERhdGFUb1N0b3JlOiBieXRlW10KCWIgKmlmNDdfZW5kCgoqaWY0N19lbHNlOgoJLy8gKmlmNDhfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMDAzCgkvLyBib3hEYXRhVG9TdG9yZS5sZW5ndGggPiAwCglmcmFtZV9kaWcgMSAvLyBib3hEYXRhVG9TdG9yZTogYnl0ZVtdCglsZW4KCWludCAwCgk+CglieiAqaWY0OF9lbmQKCgkvLyAqaWY0OF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMDA0CgkvLyB0aGlzLmJveGVzKHRoaXMuZ2V0QWxnb0FkZHJlc3NCb3hOYW1lKGFkZHJlc3MpKS52YWx1ZSA9IGJveERhdGFUb1N0b3JlCglmcmFtZV9kaWcgLTEgLy8gYWRkcmVzczogYnl0ZXMKCWNhbGxzdWIgZ2V0QWxnb0FkZHJlc3NCb3hOYW1lCglmcmFtZV9kaWcgMSAvLyBib3hEYXRhVG9TdG9yZTogYnl0ZVtdCglib3hfcHV0CgoqaWY0OF9lbmQ6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMDA2CgkvLyByZXR1cm4KCXJldHN1YgoKKmlmNDdfZW5kOgoKKmZvcl8zX2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6OTk2CgkvLyBpICs9IDEKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50IDEKCSsKCWZyYW1lX2J1cnkgMiAvLyBpOiB1aW50NjQKCWIgKmZvcl8zCgoqZm9yXzNfZW5kOgoJcmV0c3ViCgovLyBhc3NpZ25OYW1lVG9SZWdpc3RyeShuZmROYW1lOiBieXRlcywgbmZkQXNhSWQ6IHVpbnQ2NCwgbmZkQXBwSWQ6IHVpbnQ2NCwgaXNNaWdyYXRpbmc6IGJvb2xlYW4pOiB2b2lkCi8vCi8vIEFzc2lnbnMgYSBuYW1lIHRvIHRoZSByZWdpc3RyeSAoaWYgbm90IGFscmVhZHkgbWludGVkKS4KLy8gTXVzdCBvbmx5IGJlIGNhbGxlZCBhcyBwYXJ0IG9mIG1pbnRpbmcsIG9yIG1pZ3JhdGluZyBmcm9tIG9sZCB2MSBzdG9yYWdlCi8vCi8vIEBwYXJhbSB7Ynl0ZXN9IG5mZE5hbWUgLSBUaGUgbmFtZSB0byBiZSBhc3NpZ25lZCB0byB0aGUgcmVnaXN0cnkuCi8vIEBwYXJhbSB7dWludDY0fSBuZmRBc2FJZCAtIFRoZSBBU0EgSUQgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpc3RyeS4KLy8gQHBhcmFtIHt1aW50NjR9IG5mZEFwcElkIC0gVGhlIEFwcCBJRCB0byBiZSBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LgovLyBAcGFyYW0ge2Jvb2xlYW59IGlzTWlncmF0aW5nIC0gd2hldGhlciB0aGlzIGlzIHBhcnQgb2YgdjEtPnYyIG1pZ3JhdGlvbiBvciBtaW50aW5nLgovLyBAcmV0dXJuIHt2b2lkfQphc3NpZ25OYW1lVG9SZWdpc3RyeToKCXByb3RvIDQgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gKmlmNDlfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMDIyCgkvLyAhaXNNaWdyYXRpbmcKCWZyYW1lX2RpZyAtNCAvLyBpc01pZ3JhdGluZzogYm9vbGVhbgoJIQoJYnogKmlmNDlfZW5kCgoJLy8gKmlmNDlfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTAyNAoJLy8gYXNzZXJ0KCF0aGlzLmRvZXNWMU5GREV4aXN0KG5mZE5hbWUpLCAnTkZEIGFscmVhZHkgZXhpc3RzIHdpdGggdGhpcyBuYW1lJykKCWZyYW1lX2RpZyAtMSAvLyBuZmROYW1lOiBieXRlcwoJY2FsbHN1YiBkb2VzVjFORkRFeGlzdAoJIQoKCS8vIE5GRCBhbHJlYWR5IGV4aXN0cyB3aXRoIHRoaXMgbmFtZQoJYXNzZXJ0CgoqaWY0OV9lbmQ6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMDI3CgkvLyBib3hOYW1lID0gdGhpcy5nZXRCb3hOYW1lKG5mZE5hbWUpCglmcmFtZV9kaWcgLTEgLy8gbmZkTmFtZTogYnl0ZXMKCWNhbGxzdWIgZ2V0Qm94TmFtZQoJZnJhbWVfYnVyeSAwIC8vIGJveE5hbWU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEwMjgKCS8vIGFzc2VydChuZmRBc2FJZCkKCWZyYW1lX2RpZyAtMiAvLyBuZmRBc2FJZDogdWludDY0Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMDI5CgkvLyBhc3NlcnQobmZkQXBwSWQpCglmcmFtZV9kaWcgLTMgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTAzMAoJLy8gYXNzZXJ0KCF0aGlzLmJveGVzKGJveE5hbWUpLmV4aXN0cywgJ05GRCBoYXMgYWxyZWFkeSBiZWVuIG1pbnRlZCEnKQoJZnJhbWVfZGlnIDAgLy8gYm94TmFtZTogYnl0ZVtdCglib3hfbGVuCglzd2FwCglwb3AKCSEKCgkvLyBORkQgaGFzIGFscmVhZHkgYmVlbiBtaW50ZWQhCglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMDMxCgkvLyB0aGlzLmJveGVzKGJveE5hbWUpLnZhbHVlID0gY29uY2F0KGl0b2IobmZkQXNhSWQpLCBpdG9iKG5mZEFwcElkKSkKCWZyYW1lX2RpZyAwIC8vIGJveE5hbWU6IGJ5dGVbXQoJZnJhbWVfZGlnIC0yIC8vIG5mZEFzYUlkOiB1aW50NjQKCWl0b2IKCWZyYW1lX2RpZyAtMyAvLyBuZmRBcHBJZDogdWludDY0CglpdG9iCgljb25jYXQKCWJveF9wdXQKCXJldHN1YgoKLy8gZG9lc1YxTkZERXhpc3QobmZkTmFtZTogYnl0ZXMpOiBib29sZWFuCmRvZXNWMU5GREV4aXN0OgoJcHJvdG8gMSAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMDM4CgkvLyBwcm9nSGFzaCA9IEFkZHJlc3MuZnJvbUJ5dGVzKHRoaXMuZ2V0THNpZ0FkZHJlc3MoJ25hbWUvJyArIG5mZE5hbWUpKQoJYnl0ZSAweDZlNjE2ZDY1MmYgLy8gIm5hbWUvIgoJZnJhbWVfZGlnIC0xIC8vIG5mZE5hbWU6IGJ5dGVzCgljb25jYXQKCWNhbGxzdWIgZ2V0THNpZ0FkZHJlc3MKCWZyYW1lX2J1cnkgMCAvLyBwcm9nSGFzaDogYWRkcmVzcwoKCS8vICppZjUwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTAzOQoJLy8gIXByb2dIYXNoLmlzT3B0ZWRJblRvQXBwKHRoaXMuYXBwKQoJZnJhbWVfZGlnIDAgLy8gcHJvZ0hhc2g6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25zIDAKCWFwcF9vcHRlZF9pbgoJIQoJYnogKmlmNTBfZW5kCgoJLy8gKmlmNTBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTA0MAoJLy8gcmV0dXJuIGZhbHNlCglpbnQgMAoJYiAqZG9lc1YxTkZERXhpc3QqcmV0dXJuCgoqaWY1MF9lbmQ6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMDQyCgkvLyByZXR1cm4gdGhpcy5sb2NhbFN0YXRlKHByb2dIYXNoLCBSRUdJU1RSWV9LRVlfQVBQSUQpLmV4aXN0cwoJZnJhbWVfZGlnIDAgLy8gcHJvZ0hhc2g6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25zIDAKCWJ5dGUgImkuYXBwaWQiCglhcHBfbG9jYWxfZ2V0X2V4Cglzd2FwCglwb3AKCipkb2VzVjFORkRFeGlzdCpyZXR1cm46CgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gZmluZEludEFuZFNldEZpcnN0KGtleTogYnl0ZXMsIGludFZhbDogdWludDY0KTogYm9vbGVhbgpmaW5kSW50QW5kU2V0Rmlyc3Q6Cglwcm90byAyIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiA0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTA0NwoJLy8gYnl0ZXNPZlNldCA9IHRoaXMuYm94ZXMoa2V5KS52YWx1ZQoJZnJhbWVfZGlnIC0xIC8vIGtleTogYnl0ZXMKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuYm94ZXMoa2V5KS52YWx1ZQoJYXNzZXJ0CglmcmFtZV9idXJ5IDAgLy8gYnl0ZXNPZlNldDogYnl0ZVtdCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTA0OQoJLy8gYXNzZXJ0KGludFZhbCAhPT0gMCkKCWZyYW1lX2RpZyAtMiAvLyBpbnRWYWw6IHVpbnQ2NAoJaW50IDAKCSE9Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMDUxCgkvLyBhc3NlcnQoYnl0ZXNPZlNldC5sZW5ndGggPj0gMTYsICJpbnQgKGFwcGlkKSAnc2V0JyBzaG91bGQgYWxyZWFkeSBoYXZlIGF0IGxlYXN0IHR3byB2YWx1ZXMiKQoJZnJhbWVfZGlnIDAgLy8gYnl0ZXNPZlNldDogYnl0ZVtdCglsZW4KCWludCAxNgoJPj0KCgkvLyBpbnQgKGFwcGlkKSAnc2V0JyBzaG91bGQgYWxyZWFkeSBoYXZlIGF0IGxlYXN0IHR3byB2YWx1ZXMKCWFzc2VydAoKCS8vICppZjUxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTA1NAoJLy8gZXh0cmFjdFVpbnQ2NChieXRlc09mU2V0LCAwKSA9PT0gaW50VmFsCglmcmFtZV9kaWcgMCAvLyBieXRlc09mU2V0OiBieXRlW10KCWludCAwCglleHRyYWN0X3VpbnQ2NAoJZnJhbWVfZGlnIC0yIC8vIGludFZhbDogdWludDY0Cgk9PQoJYnogKmlmNTFfZW5kCgoJLy8gKmlmNTFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTA1NAoJLy8gcmV0dXJuIHRydWUKCWludCAxCgliICpmaW5kSW50QW5kU2V0Rmlyc3QqcmV0dXJuCgoqaWY1MV9lbmQ6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMDU2CgkvLyBsaW1pdCA9IGJ5dGVzT2ZTZXQubGVuZ3RoIC8gOAoJZnJhbWVfZGlnIDAgLy8gYnl0ZXNPZlNldDogYnl0ZVtdCglsZW4KCWludCA4CgkvCglmcmFtZV9idXJ5IDEgLy8gbGltaXQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEwNTcKCS8vIGZvdW5kU2xvdCA9IDAKCWludCAwCglmcmFtZV9idXJ5IDIgLy8gZm91bmRTbG90OiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMDU5CgkvLyBmb3IgKGxldCBpID0gMDsgaSA8IGxpbWl0OyBpICs9IDEpCglpbnQgMAoJZnJhbWVfYnVyeSAzIC8vIGk6IHVpbnQ2NAoKKmZvcl80OgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTA1OQoJLy8gaSA8IGxpbWl0CglmcmFtZV9kaWcgMyAvLyBpOiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIGxpbWl0OiB1aW50NjQKCTwKCWJ6ICpmb3JfNF9lbmQKCgkvLyAqaWY1Ml9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEwNjAKCS8vIGV4dHJhY3RVaW50NjQoYnl0ZXNPZlNldCwgaSAqIDgpID09PSBpbnRWYWwKCWZyYW1lX2RpZyAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoJZnJhbWVfZGlnIDMgLy8gaTogdWludDY0CglpbnQgOAoJKgoJZXh0cmFjdF91aW50NjQKCWZyYW1lX2RpZyAtMiAvLyBpbnRWYWw6IHVpbnQ2NAoJPT0KCWJ6ICppZjUyX2VuZAoKCS8vICppZjUyX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEwNjEKCS8vIGZvdW5kU2xvdCA9IGkKCWZyYW1lX2RpZyAzIC8vIGk6IHVpbnQ2NAoJZnJhbWVfYnVyeSAyIC8vIGZvdW5kU2xvdDogdWludDY0CgliICpmb3JfNF9lbmQKCippZjUyX2VuZDoKCipmb3JfNF9jb250aW51ZToKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEwNTkKCS8vIGkgKz0gMQoJZnJhbWVfZGlnIDMgLy8gaTogdWludDY0CglpbnQgMQoJKwoJZnJhbWVfYnVyeSAzIC8vIGk6IHVpbnQ2NAoJYiAqZm9yXzQKCipmb3JfNF9lbmQ6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMDY1CgkvLyBhc3NlcnQoZm91bmRTbG90ICE9PSAwLCAnaW50IChhcHAgaWQpIG11c3QgYmUgZm91bmQgaW4gc2V0IGluIG9yZGVyIHRvIG1vdmUgaXQnKQoJZnJhbWVfZGlnIDIgLy8gZm91bmRTbG90OiB1aW50NjQKCWludCAwCgkhPQoKCS8vIGludCAoYXBwIGlkKSBtdXN0IGJlIGZvdW5kIGluIHNldCBpbiBvcmRlciB0byBtb3ZlIGl0Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMDY3CgkvLyBpbnRBdEZyb250ID0gZXh0cmFjdFVpbnQ2NChieXRlc09mU2V0LCAwKQoJZnJhbWVfZGlnIDAgLy8gYnl0ZXNPZlNldDogYnl0ZVtdCglpbnQgMAoJZXh0cmFjdF91aW50NjQKCWZyYW1lX2J1cnkgNCAvLyBpbnRBdEZyb250OiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMDY5CgkvLyBieXRlc09mU2V0ID0gcmVwbGFjZTMoYnl0ZXNPZlNldCwgMCwgaXRvYihpbnRWYWwpKQoJZnJhbWVfZGlnIDAgLy8gYnl0ZXNPZlNldDogYnl0ZVtdCglpbnQgMAoJZnJhbWVfZGlnIC0yIC8vIGludFZhbDogdWludDY0CglpdG9iCglyZXBsYWNlMwoJZnJhbWVfYnVyeSAwIC8vIGJ5dGVzT2ZTZXQ6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEwNzEKCS8vIHRoaXMuYm94ZXMoa2V5KS52YWx1ZSA9IHJlcGxhY2UzKGJ5dGVzT2ZTZXQsIGZvdW5kU2xvdCAqIDgsIGl0b2IoaW50QXRGcm9udCkpCglmcmFtZV9kaWcgLTEgLy8ga2V5OiBieXRlcwoJZnJhbWVfZGlnIDAgLy8gYnl0ZXNPZlNldDogYnl0ZVtdCglmcmFtZV9kaWcgMiAvLyBmb3VuZFNsb3Q6IHVpbnQ2NAoJaW50IDgKCSoKCWZyYW1lX2RpZyA0IC8vIGludEF0RnJvbnQ6IHVpbnQ2NAoJaXRvYgoJcmVwbGFjZTMKCWJveF9wdXQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMDcyCgkvLyByZXR1cm4gdHJ1ZQoJaW50IDEKCipmaW5kSW50QW5kU2V0Rmlyc3QqcmV0dXJuOgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gNAoJcmV0c3ViCgovLyByZW1vdmVJbnRGcm9tU2V0KGtleTogYnl0ZXMsIGludFZhbDogdWludDY0KTogYm9vbGVhbgpyZW1vdmVJbnRGcm9tU2V0OgoJcHJvdG8gMiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMgoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEwNzYKCS8vIGJveERhdGEgPSB0aGlzLmJveGVzKGtleSkudmFsdWUKCWZyYW1lX2RpZyAtMSAvLyBrZXk6IGJ5dGVzCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLmJveGVzKGtleSkudmFsdWUKCWFzc2VydAoJZnJhbWVfYnVyeSAwIC8vIGJveERhdGE6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEwNzcKCS8vIGxpbWl0ID0gYm94RGF0YS5sZW5ndGggLyA4CglmcmFtZV9kaWcgMCAvLyBib3hEYXRhOiBieXRlW10KCWxlbgoJaW50IDgKCS8KCWZyYW1lX2J1cnkgMSAvLyBsaW1pdDogdWludDY0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTA3OQoJLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBsaW1pdDsgaSArPSAxKQoJaW50IDAKCWZyYW1lX2J1cnkgMiAvLyBpOiB1aW50NjQKCipmb3JfNToKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEwNzkKCS8vIGkgPCBsaW1pdAoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglmcmFtZV9kaWcgMSAvLyBsaW1pdDogdWludDY0Cgk8CglieiAqZm9yXzVfZW5kCgoJLy8gKmlmNTNfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMDgwCgkvLyBleHRyYWN0VWludDY0KGJveERhdGEsIGkgKiA4KSA9PT0gaW50VmFsCglmcmFtZV9kaWcgMCAvLyBib3hEYXRhOiBieXRlW10KCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50IDgKCSoKCWV4dHJhY3RfdWludDY0CglmcmFtZV9kaWcgLTIgLy8gaW50VmFsOiB1aW50NjQKCT09CglieiAqaWY1M19lbmQKCgkvLyAqaWY1M19jb25zZXF1ZW50CgkvLyAqaWY1NF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEwODEKCS8vIGkgPT09IGxpbWl0IC0gMQoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglmcmFtZV9kaWcgMSAvLyBsaW1pdDogdWludDY0CglpbnQgMQoJLQoJPT0KCWJ6ICppZjU0X2VuZAoKCS8vICppZjU0X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEwODQKCS8vIHRoaXMuYm94ZXMoa2V5KS5kZWxldGUoKQoJZnJhbWVfZGlnIC0xIC8vIGtleTogYnl0ZXMKCWJveF9kZWwKCgkvLyAqaWY1NV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEwODUKCS8vIGkgPiAwCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludCAwCgk+CglieiAqaWY1NV9lbmQKCgkvLyAqaWY1NV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMDg3CgkvLyB0aGlzLmJveGVzKGtleSkudmFsdWUgPSBleHRyYWN0Myhib3hEYXRhLCAwLCBpICogOCkKCWZyYW1lX2RpZyAtMSAvLyBrZXk6IGJ5dGVzCglmcmFtZV9kaWcgMCAvLyBib3hEYXRhOiBieXRlW10KCWludCAwCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludCA4CgkqCglleHRyYWN0MwoJYm94X3B1dAoKKmlmNTVfZW5kOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTA4OQoJLy8gcmV0dXJuIHRydWUKCWludCAxCgliICpyZW1vdmVJbnRGcm9tU2V0KnJldHVybgoKKmlmNTRfZW5kOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTA5MgoJLy8gdGhpcy5ib3hlcyhrZXkpLnJlcGxhY2UoaSAqIDgsIGl0b2IoMCkpCglmcmFtZV9kaWcgLTEgLy8ga2V5OiBieXRlcwoJZnJhbWVfZGlnIDIgLy8gaTogdWludDY0CglpbnQgOAoJKgoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAKCWJveF9yZXBsYWNlCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTA5MwoJLy8gcmV0dXJuIHRydWUKCWludCAxCgliICpyZW1vdmVJbnRGcm9tU2V0KnJldHVybgoKKmlmNTNfZW5kOgoKKmZvcl81X2NvbnRpbnVlOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTA3OQoJLy8gaSArPSAxCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludCAxCgkrCglmcmFtZV9idXJ5IDIgLy8gaTogdWludDY0CgliICpmb3JfNQoKKmZvcl81X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEwOTcKCS8vIHJldHVybiBmYWxzZQoJaW50IDAKCipyZW1vdmVJbnRGcm9tU2V0KnJldHVybjoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDIKCXJldHN1YgoKLy8gdjFSZXBsYWNlSW50QXRQb3MoaW50VmFsOiB1aW50NjQsIGJ5dGVzT2ZTZXQ6IGJ5dGVzLCBwb3M6IHVpbnQ2NCk6IGJ5dGVzCnYxUmVwbGFjZUludEF0UG9zOgoJcHJvdG8gMyAxCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTEwMQoJLy8gcmV0dXJuIHN1YnN0cmluZzMoYnl0ZXNPZlNldCwgMCwgcG9zKSArIGl0b2IoaW50VmFsKSArIHN1YnN0cmluZzMoYnl0ZXNPZlNldCwgcG9zICsgOCwgYnl0ZXNPZlNldC5sZW5ndGgpCglmcmFtZV9kaWcgLTIgLy8gYnl0ZXNPZlNldDogYnl0ZXMKCWludCAwCglmcmFtZV9kaWcgLTMgLy8gcG9zOiB1aW50NjQKCXN1YnN0cmluZzMKCWZyYW1lX2RpZyAtMSAvLyBpbnRWYWw6IHVpbnQ2NAoJaXRvYgoJY29uY2F0CglmcmFtZV9kaWcgLTIgLy8gYnl0ZXNPZlNldDogYnl0ZXMKCWZyYW1lX2RpZyAtMyAvLyBwb3M6IHVpbnQ2NAoJaW50IDgKCSsKCWZyYW1lX2RpZyAtMiAvLyBieXRlc09mU2V0OiBieXRlcwoJbGVuCglzdWJzdHJpbmczCgljb25jYXQKCXJldHN1YgoKLy8gcmVtb3ZlSW50RnJvbVYxU2V0KGFkZHI6IEFkZHJlc3MsIGtleTogYnl0ZXMsIGludFZhbDogdWludDY0KTogYm9vbGVhbgpyZW1vdmVJbnRGcm9tVjFTZXQ6Cglwcm90byAzIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiAyCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTEwNQoJLy8gYnl0ZXNPZlNldCA9IHRoaXMubG9jYWxTdGF0ZShhZGRyLCBrZXkpLnZhbHVlCglmcmFtZV9kaWcgLTEgLy8gYWRkcjogQWRkcmVzcwoJZnJhbWVfZGlnIC0yIC8vIGtleTogYnl0ZXMKCWFwcF9sb2NhbF9nZXQKCWZyYW1lX2J1cnkgMCAvLyBieXRlc09mU2V0OiBieXRlW10KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTA2CgkvLyBsaW1pdCA9IGJ5dGVzT2ZTZXQubGVuZ3RoIC8gOAoJZnJhbWVfZGlnIDAgLy8gYnl0ZXNPZlNldDogYnl0ZVtdCglsZW4KCWludCA4CgkvCglmcmFtZV9idXJ5IDEgLy8gbGltaXQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjExMDgKCS8vIGZvciAobGV0IGkgPSAwOyBpIDwgbGltaXQ7IGkgKz0gMSkKCWludCAwCglmcmFtZV9idXJ5IDIgLy8gaTogdWludDY0CgoqZm9yXzY6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTA4CgkvLyBpIDwgbGltaXQKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJZnJhbWVfZGlnIDEgLy8gbGltaXQ6IHVpbnQ2NAoJPAoJYnogKmZvcl82X2VuZAoKCS8vICppZjU2X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTEwOQoJLy8gZXh0cmFjdFVpbnQ2NChieXRlc09mU2V0LCBpICogOCkgPT09IGludFZhbAoJZnJhbWVfZGlnIDAgLy8gYnl0ZXNPZlNldDogYnl0ZVtdCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludCA4CgkqCglleHRyYWN0X3VpbnQ2NAoJZnJhbWVfZGlnIC0zIC8vIGludFZhbDogdWludDY0Cgk9PQoJYnogKmlmNTZfZW5kCgoJLy8gKmlmNTZfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTExMAoJLy8gdGhpcy5sb2NhbFN0YXRlKGFkZHIsIGtleSkudmFsdWUgPSB0aGlzLnYxUmVwbGFjZUludEF0UG9zKDAsIGJ5dGVzT2ZTZXQsIGkgKiA4KQoJZnJhbWVfZGlnIC0xIC8vIGFkZHI6IEFkZHJlc3MKCWZyYW1lX2RpZyAtMiAvLyBrZXk6IGJ5dGVzCglmcmFtZV9kaWcgMiAvLyBpOiB1aW50NjQKCWludCA4CgkqCglmcmFtZV9kaWcgMCAvLyBieXRlc09mU2V0OiBieXRlW10KCWludCAwCgljYWxsc3ViIHYxUmVwbGFjZUludEF0UG9zCglhcHBfbG9jYWxfcHV0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTExMQoJLy8gcmV0dXJuIHRydWUKCWludCAxCgliICpyZW1vdmVJbnRGcm9tVjFTZXQqcmV0dXJuCgoqaWY1Nl9lbmQ6CgoqZm9yXzZfY29udGludWU6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTA4CgkvLyBpICs9IDEKCWZyYW1lX2RpZyAyIC8vIGk6IHVpbnQ2NAoJaW50IDEKCSsKCWZyYW1lX2J1cnkgMiAvLyBpOiB1aW50NjQKCWIgKmZvcl82CgoqZm9yXzZfZW5kOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTExNQoJLy8gcmV0dXJuIGZhbHNlCglpbnQgMAoKKnJlbW92ZUludEZyb21WMVNldCpyZXR1cm46CgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAyCglyZXRzdWIKCi8vIHJlbW92ZUludEZyb21WMU11bHRpc2V0KGFkZHI6IEFkZHJlc3MsIGtleVByZWZpeDogYnl0ZXMsIG1heEtleXM6IHVpbnQ2NCwgaW50VmFsOiB1aW50NjQpOiBib29sZWFuCnJlbW92ZUludEZyb21WMU11bHRpc2V0OgoJcHJvdG8gNCAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTE5CgkvLyBmb3IgKGxldCBpID0gMDsgaSA8IG1heEtleXM7IGkgKz0gMSkKCWludCAwCglmcmFtZV9idXJ5IDAgLy8gaTogdWludDY0CgoqZm9yXzc6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTE5CgkvLyBpIDwgbWF4S2V5cwoJZnJhbWVfZGlnIDAgLy8gaTogdWludDY0CglmcmFtZV9kaWcgLTMgLy8gbWF4S2V5czogdWludDY0Cgk8CglieiAqZm9yXzdfZW5kCgoJLy8gKmlmNTdfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTIwCgkvLyB0aGlzLnJlbW92ZUludEZyb21WMVNldChhZGRyLCBrZXlQcmVmaXggKyBpLnRvU3RyaW5nKCksIGludFZhbCkKCWZyYW1lX2RpZyAtNCAvLyBpbnRWYWw6IHVpbnQ2NAoJZnJhbWVfZGlnIC0yIC8vIGtleVByZWZpeDogYnl0ZXMKCWZyYW1lX2RpZyAwIC8vIGk6IHVpbnQ2NAoJY2FsbHN1YiAqaXRvYQoJY29uY2F0CglmcmFtZV9kaWcgLTEgLy8gYWRkcjogQWRkcmVzcwoJY2FsbHN1YiByZW1vdmVJbnRGcm9tVjFTZXQKCWJ6ICppZjU3X2VuZAoKCS8vICppZjU3X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjExMjAKCS8vIHJldHVybiB0cnVlCglpbnQgMQoJYiAqcmVtb3ZlSW50RnJvbVYxTXVsdGlzZXQqcmV0dXJuCgoqaWY1N19lbmQ6CgoqZm9yXzdfY29udGludWU6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTE5CgkvLyBpICs9IDEKCWZyYW1lX2RpZyAwIC8vIGk6IHVpbnQ2NAoJaW50IDEKCSsKCWZyYW1lX2J1cnkgMCAvLyBpOiB1aW50NjQKCWIgKmZvcl83CgoqZm9yXzdfZW5kOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTEyMwoJLy8gcmV0dXJuIGZhbHNlCglpbnQgMAoKKnJlbW92ZUludEZyb21WMU11bHRpc2V0KnJldHVybjoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBzd2VlcER1c3QoKTogdm9pZApzd2VlcER1c3Q6Cglwcm90byAwIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTEzMgoJLy8gYmFsID0gdGhpcy5hcHAuYWRkcmVzcy5iYWxhbmNlCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCglwb3AKCWZyYW1lX2J1cnkgMCAvLyBiYWw6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjExMzMKCS8vIG1iciA9IHRoaXMuYXBwLmFkZHJlc3MubWluQmFsYW5jZQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQoJcG9wCglmcmFtZV9idXJ5IDEgLy8gbWJyOiB1aW50NjQKCgkvLyAqaWY1OF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjExMzQKCS8vIGJhbCA+IG1icgoJZnJhbWVfZGlnIDAgLy8gYmFsOiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIG1icjogdWludDY0Cgk+CglieiAqaWY1OF9lbmQKCgkvLyAqaWY1OF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTM1CgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgICAgICAgICAgYW1vdW50OiBiYWwgLSBtYnIsCgkvLyAgICAgICAgICAgICAgICAgcmVjZWl2ZXI6IEFkZHJlc3MuZnJvbUJ5dGVzKHRoaXMudHhuLmFwcGxpY2F0aW9uQXJncyFbMV0pLAoJLy8gICAgICAgICAgICAgICAgIG5vdGU6ICdzd2VlcER1c3QnLAoJLy8gICAgICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTM2CgkvLyBhbW91bnQ6IGJhbCAtIG1icgoJZnJhbWVfZGlnIDAgLy8gYmFsOiB1aW50NjQKCWZyYW1lX2RpZyAxIC8vIG1icjogdWludDY0CgktCglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjExMzcKCS8vIHJlY2VpdmVyOiBBZGRyZXNzLmZyb21CeXRlcyh0aGlzLnR4bi5hcHBsaWNhdGlvbkFyZ3MhWzFdKQoJdHhuIEFwcGxpY2F0aW9uQXJncyAxCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTEzOAoJLy8gbm90ZTogJ3N3ZWVwRHVzdCcKCWJ5dGUgMHg3Mzc3NjU2NTcwNDQ3NTczNzQgLy8gInN3ZWVwRHVzdCIKCWl0eG5fZmllbGQgTm90ZQoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCippZjU4X2VuZDoKCXJldHN1YgoKLy8gbnVtTGV0dGVyc0luTmZkKG5mZE5hbWU6IHN0cmluZyk6IG5mZExldHRlcnNJbmZvCm51bUxldHRlcnNJbk5mZDoKCXByb3RvIDEgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXBuIDYKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTU2CgkvLyBpbnB1dExlbmd0aCA9IGxlbihuZmROYW1lKQoJZnJhbWVfZGlnIC0xIC8vIG5mZE5hbWU6IHN0cmluZwoJbGVuCglmcmFtZV9idXJ5IDAgLy8gaW5wdXRMZW5ndGg6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjExNTgKCS8vIGFzc2VydChpbnB1dExlbmd0aCA+PSA2LCAiaWYgbm90IGF0IGxlYXN0IDYgY2hhcnMgY2FuJ3QgYmUgdmFsaWQgLSBtaW5pbXVtIGxlbmd0aCB0byBoYXZlIC5hbGdvIikKCWZyYW1lX2RpZyAwIC8vIGlucHV0TGVuZ3RoOiB1aW50NjQKCWludCA2Cgk+PQoKCS8vIGlmIG5vdCBhdCBsZWFzdCA2IGNoYXJzIGNhbid0IGJlIHZhbGlkIC0gbWluaW11bSBsZW5ndGggdG8gaGF2ZSAuYWxnbwoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTE1OQoJLy8gYXNzZXJ0KGV4dHJhY3QzKG5mZE5hbWUsIGlucHV0TGVuZ3RoIC0gNSwgNSkgPT09ICcuYWxnbycsICdzdHJpbmcgbXVzdCBlbmQgdy8gLmFsZ28nKQoJZnJhbWVfZGlnIC0xIC8vIG5mZE5hbWU6IHN0cmluZwoJZnJhbWVfZGlnIDAgLy8gaW5wdXRMZW5ndGg6IHVpbnQ2NAoJaW50IDUKCS0KCWludCA1CglleHRyYWN0MwoJYnl0ZSAweDJlNjE2YzY3NmYgLy8gIi5hbGdvIgoJPT0KCgkvLyBzdHJpbmcgbXVzdCBlbmQgdy8gLmFsZ28KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjExNjEKCS8vIHJldFZhbDogbmZkTGV0dGVyc0luZm8gPSB7IGlzU2VnbWVudDogZmFsc2UsIGlkeE9mQmFzZW5hbWU6IDAsIG51bUNoYXJzSW5CYXNlbmFtZTogMCB9CglieXRlIDB4MDAKCWludCAwCglkdXAKCXNldGJpdAoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAKCWNvbmNhdAoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAKCWNvbmNhdAoJZnJhbWVfYnVyeSAxIC8vIHJldFZhbDogbmZkTGV0dGVyc0luZm8KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTYyCgkvLyBwZXJpb2RDb3VudCA9IDAKCWludCAwCglmcmFtZV9idXJ5IDIgLy8gcGVyaW9kQ291bnQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjExNjMKCS8vIGNoYXJDb3VudCA9IDAKCWludCAwCglmcmFtZV9idXJ5IDMgLy8gY2hhckNvdW50OiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTY0CgkvLyBmaXJzdFBlcmlvZElkeCA9IDAKCWludCAwCglmcmFtZV9idXJ5IDQgLy8gZmlyc3RQZXJpb2RJZHg6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjExNjYKCS8vIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRMZW5ndGggLSA0OyBpICs9IDEpCglpbnQgMAoJZnJhbWVfYnVyeSA1IC8vIGk6IHVpbnQ2NAoKKmZvcl84OgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTE2NgoJLy8gaSA8IGlucHV0TGVuZ3RoIC0gNAoJZnJhbWVfZGlnIDUgLy8gaTogdWludDY0CglmcmFtZV9kaWcgMCAvLyBpbnB1dExlbmd0aDogdWludDY0CglpbnQgNAoJLQoJPAoJYnogKmZvcl84X2VuZAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjExNjcKCS8vIGJ5dGVWYWwgPSBnZXRieXRlKG5mZE5hbWUsIGkpCglmcmFtZV9kaWcgLTEgLy8gbmZkTmFtZTogc3RyaW5nCglmcmFtZV9kaWcgNSAvLyBpOiB1aW50NjQKCWdldGJ5dGUKCWZyYW1lX2J1cnkgNiAvLyBieXRlVmFsOiB1aW50NjQKCgkvLyAqaWY1OV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjExNjkKCS8vIGJ5dGVWYWwgPT09IEFTQ0lJX1BFUklPRAoJZnJhbWVfZGlnIDYgLy8gYnl0ZVZhbDogdWludDY0CglpbnQgNDYKCT09CglieiAqaWY1OV9lbHNlaWYxX2NvbmRpdGlvbgoKCS8vICppZjU5X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjExNzAKCS8vIHBlcmlvZENvdW50ICs9IDEKCWZyYW1lX2RpZyAyIC8vIHBlcmlvZENvdW50OiB1aW50NjQKCWludCAxCgkrCglmcmFtZV9idXJ5IDIgLy8gcGVyaW9kQ291bnQ6IHVpbnQ2NAoKCS8vICppZjYwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTE3MgoJLy8gcGVyaW9kQ291bnQgPT09IDEKCWZyYW1lX2RpZyAyIC8vIHBlcmlvZENvdW50OiB1aW50NjQKCWludCAxCgk9PQoJYnogKmlmNjBfZWxzZWlmMV9jb25kaXRpb24KCgkvLyAqaWY2MF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTczCgkvLyBmaXJzdFBlcmlvZElkeCA9IGkKCWZyYW1lX2RpZyA1IC8vIGk6IHVpbnQ2NAoJZnJhbWVfYnVyeSA0IC8vIGZpcnN0UGVyaW9kSWR4OiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTc0CgkvLyBhc3NlcnQoY2hhckNvdW50ID49IDEgJiYgY2hhckNvdW50IDw9IDI3LCAnbXVzdCBiZSAxLTI3IGNoYXJzIGluIG5mZCByb290IG9yIHNlZ21lbnQgbmFtZScpCglmcmFtZV9kaWcgMyAvLyBjaGFyQ291bnQ6IHVpbnQ2NAoJaW50IDEKCT49CglkdXAKCWJ6ICpza2lwX2FuZDE3CglmcmFtZV9kaWcgMyAvLyBjaGFyQ291bnQ6IHVpbnQ2NAoJaW50IDI3Cgk8PQoJJiYKCipza2lwX2FuZDE3OgoJLy8gbXVzdCBiZSAxLTI3IGNoYXJzIGluIG5mZCByb290IG9yIHNlZ21lbnQgbmFtZQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTE3NQoJLy8gY2hhckNvdW50ID0gMAoJaW50IDAKCWZyYW1lX2J1cnkgMyAvLyBjaGFyQ291bnQ6IHVpbnQ2NAoJYiAqaWY2MF9lbmQKCippZjYwX2Vsc2VpZjFfY29uZGl0aW9uOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTE3NgoJLy8gcGVyaW9kQ291bnQgPT09IDIKCWZyYW1lX2RpZyAyIC8vIHBlcmlvZENvdW50OiB1aW50NjQKCWludCAyCgk9PQoJYnogKmlmNjBfZWxzZQoKCS8vICppZjYwX2Vsc2VpZjFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTE3NwoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvdW50ID49IDEgJiYgY2hhckNvdW50IDw9IDI3ICYmIGkgPT09IGlucHV0TGVuZ3RoIC0gNSwKCS8vICAgICAgICAgICAgICAgICAgICAgICAgICdtdXN0IGJlIDEtMjcgY2hhcnMgYW5kIGF0IGVuZCBvZiBzdHJpbmcnLAoJLy8gICAgICAgICAgICAgICAgICAgICApCglmcmFtZV9kaWcgMyAvLyBjaGFyQ291bnQ6IHVpbnQ2NAoJaW50IDEKCT49CglkdXAKCWJ6ICpza2lwX2FuZDE4CglmcmFtZV9kaWcgMyAvLyBjaGFyQ291bnQ6IHVpbnQ2NAoJaW50IDI3Cgk8PQoJJiYKCipza2lwX2FuZDE4OgoJZHVwCglieiAqc2tpcF9hbmQxOQoJZnJhbWVfZGlnIDUgLy8gaTogdWludDY0CglmcmFtZV9kaWcgMCAvLyBpbnB1dExlbmd0aDogdWludDY0CglpbnQgNQoJLQoJPT0KCSYmCgoqc2tpcF9hbmQxOToKCS8vIG11c3QgYmUgMS0yNyBjaGFycyBhbmQgYXQgZW5kIG9mIHN0cmluZwoJYXNzZXJ0CgliICppZjYwX2VuZAoKKmlmNjBfZWxzZToKCS8vIHRvbyBtYW55ICcuJyBjaGFycyBpbiBuYW1lCgllcnIKCippZjYwX2VuZDoKCWIgKmlmNTlfZW5kCgoqaWY1OV9lbHNlaWYxX2NvbmRpdGlvbjoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjExODUKCS8vIChieXRlVmFsID49IEFTQ0lJX0xXUl9BICYmIGJ5dGVWYWwgPD0gQVNDSUlfTFdSX1opIHx8CgkvLyAgICAgICAgICAgICAgICAgKGJ5dGVWYWwgPj0gQVNDSUlfMCAmJiBieXRlVmFsIDw9IEFTQ0lJXzkpCglmcmFtZV9kaWcgNiAvLyBieXRlVmFsOiB1aW50NjQKCWludCA5NwoJPj0KCWR1cAoJYnogKnNraXBfYW5kMjAKCWZyYW1lX2RpZyA2IC8vIGJ5dGVWYWw6IHVpbnQ2NAoJaW50IDEyMgoJPD0KCSYmCgoqc2tpcF9hbmQyMDoKCWR1cAoJYm56ICpza2lwX29yMgoJZnJhbWVfZGlnIDYgLy8gYnl0ZVZhbDogdWludDY0CglpbnQgNDgKCT49CglkdXAKCWJ6ICpza2lwX2FuZDIxCglmcmFtZV9kaWcgNiAvLyBieXRlVmFsOiB1aW50NjQKCWludCA1NwoJPD0KCSYmCgoqc2tpcF9hbmQyMToKCXx8Cgoqc2tpcF9vcjI6CglieiAqaWY1OV9lbHNlCgoJLy8gKmlmNTlfZWxzZWlmMV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTg4CgkvLyBjaGFyQ291bnQgKz0gMQoJZnJhbWVfZGlnIDMgLy8gY2hhckNvdW50OiB1aW50NjQKCWludCAxCgkrCglmcmFtZV9idXJ5IDMgLy8gY2hhckNvdW50OiB1aW50NjQKCWIgKmlmNTlfZW5kCgoqaWY1OV9lbHNlOgoJLy8gaW52YWxpZCBjaGFyYWN0ZXIgaW4gbmFtZQoJZXJyCgoqaWY1OV9lbmQ6CgoqZm9yXzhfY29udGludWU6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTY2CgkvLyBpICs9IDEKCWZyYW1lX2RpZyA1IC8vIGk6IHVpbnQ2NAoJaW50IDEKCSsKCWZyYW1lX2J1cnkgNSAvLyBpOiB1aW50NjQKCWIgKmZvcl84CgoqZm9yXzhfZW5kOgoJLy8gKmlmNjFfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTkzCgkvLyBwZXJpb2RDb3VudCA9PT0gMQoJZnJhbWVfZGlnIDIgLy8gcGVyaW9kQ291bnQ6IHVpbnQ2NAoJaW50IDEKCT09CglieiAqaWY2MV9lbHNlCgoJLy8gKmlmNjFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTE5NAoJLy8gcmV0VmFsLmlzU2VnbWVudCA9IGZhbHNlCglmcmFtZV9kaWcgMSAvLyByZXRWYWw6IG5mZExldHRlcnNJbmZvCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJaW50IDAKCWR1cAoJc2V0Yml0CglmcmFtZV9idXJ5IDEgLy8gcmV0VmFsOiBuZmRMZXR0ZXJzSW5mbwoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjExOTUKCS8vIHJldFZhbC5udW1DaGFyc0luQmFzZW5hbWUgPSBmaXJzdFBlcmlvZElkeAoJZnJhbWVfZGlnIDEgLy8gcmV0VmFsOiBuZmRMZXR0ZXJzSW5mbwoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWludCAxCglmcmFtZV9kaWcgNCAvLyBmaXJzdFBlcmlvZElkeDogdWludDY0CglpdG9iCglyZXBsYWNlMwoJZnJhbWVfYnVyeSAxIC8vIHJldFZhbDogbmZkTGV0dGVyc0luZm8KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTk2CgkvLyByZXRWYWwuaWR4T2ZCYXNlbmFtZSA9IDAKCWZyYW1lX2RpZyAxIC8vIHJldFZhbDogbmZkTGV0dGVyc0luZm8KCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglieXRlIDB4MDAwMDAwMDAwMDAwMDAwMAoJcmVwbGFjZTIgOQoJZnJhbWVfYnVyeSAxIC8vIHJldFZhbDogbmZkTGV0dGVyc0luZm8KCWIgKmlmNjFfZW5kCgoqaWY2MV9lbHNlOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTE5OAoJLy8gcmV0VmFsLmlzU2VnbWVudCA9IHRydWUKCWZyYW1lX2RpZyAxIC8vIHJldFZhbDogbmZkTGV0dGVyc0luZm8KCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnQgMAoJaW50IDEKCXNldGJpdAoJZnJhbWVfYnVyeSAxIC8vIHJldFZhbDogbmZkTGV0dGVyc0luZm8KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMTk5CgkvLyByZXRWYWwubnVtQ2hhcnNJbkJhc2VuYW1lID0gY2hhckNvdW50CglmcmFtZV9kaWcgMSAvLyByZXRWYWw6IG5mZExldHRlcnNJbmZvCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJaW50IDEKCWZyYW1lX2RpZyAzIC8vIGNoYXJDb3VudDogdWludDY0CglpdG9iCglyZXBsYWNlMwoJZnJhbWVfYnVyeSAxIC8vIHJldFZhbDogbmZkTGV0dGVyc0luZm8KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMjAwCgkvLyByZXRWYWwuaWR4T2ZCYXNlbmFtZSA9IGlucHV0TGVuZ3RoIC0gNSAtIGNoYXJDb3VudAoJZnJhbWVfZGlnIDEgLy8gcmV0VmFsOiBuZmRMZXR0ZXJzSW5mbwoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWludCA5CglmcmFtZV9kaWcgMCAvLyBpbnB1dExlbmd0aDogdWludDY0CglpbnQgNQoJLQoJZnJhbWVfZGlnIDMgLy8gY2hhckNvdW50OiB1aW50NjQKCS0KCWl0b2IKCXJlcGxhY2UzCglmcmFtZV9idXJ5IDEgLy8gcmV0VmFsOiBuZmRMZXR0ZXJzSW5mbwoKKmlmNjFfZW5kOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTIwMwoJLy8gcmV0dXJuIHJldFZhbAoJZnJhbWVfZGlnIDEgLy8gcmV0VmFsOiBuZmRMZXR0ZXJzSW5mbwoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDYKCXJldHN1YgoKLy8gZmV0Y2hBcHBJZEZvck5hbWUobmFtZTogc3RyaW5nKTogdWludDY0CmZldGNoQXBwSWRGb3JOYW1lOgoJcHJvdG8gMSAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEyMDcKCS8vIGJveE5hbWUgPSB0aGlzLmdldEJveE5hbWUobmFtZSkKCWZyYW1lX2RpZyAtMSAvLyBuYW1lOiBzdHJpbmcKCWNhbGxzdWIgZ2V0Qm94TmFtZQoJZnJhbWVfYnVyeSAwIC8vIGJveE5hbWU6IGJ5dGVbXQoKCS8vICppZjYyX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTIwOAoJLy8gIXRoaXMuYm94ZXMoYm94TmFtZSkuZXhpc3RzCglmcmFtZV9kaWcgMCAvLyBib3hOYW1lOiBieXRlW10KCWJveF9sZW4KCXN3YXAKCXBvcAoJIQoJYnogKmlmNjJfZW5kCgoJLy8gKmlmNjJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTIwOQoJLy8gcmV0dXJuIDAKCWludCAwCgliICpmZXRjaEFwcElkRm9yTmFtZSpyZXR1cm4KCippZjYyX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEyMTEKCS8vIGJveFZhbHVlID0gdGhpcy5ib3hlcyhib3hOYW1lKS52YWx1ZQoJZnJhbWVfZGlnIDAgLy8gYm94TmFtZTogYnl0ZVtdCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLmJveGVzKGJveE5hbWUpLnZhbHVlCglhc3NlcnQKCWZyYW1lX2J1cnkgMSAvLyBib3hWYWx1ZTogYnl0ZVtdCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTIxMgoJLy8gYXNzZXJ0KGxlbihib3hWYWx1ZSkgPT09IDE2KQoJZnJhbWVfZGlnIDEgLy8gYm94VmFsdWU6IGJ5dGVbXQoJbGVuCglpbnQgMTYKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMjEzCgkvLyByZXR1cm4gZXh0cmFjdFVpbnQ2NChib3hWYWx1ZSwgOCkKCWZyYW1lX2RpZyAxIC8vIGJveFZhbHVlOiBieXRlW10KCWludCA4CglleHRyYWN0X3VpbnQ2NAoKKmZldGNoQXBwSWRGb3JOYW1lKnJldHVybjoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDEKCXJldHN1YgoKLy8gZnJvbU5hbWVJbmZvR2V0UGFyZW50TmFtZShuZmROYW1lOiBzdHJpbmcsIG5mZE5hbWVJbmZvOiBuZmRMZXR0ZXJzSW5mbyk6IHN0cmluZwpmcm9tTmFtZUluZm9HZXRQYXJlbnROYW1lOgoJcHJvdG8gMiAxCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTIxNwoJLy8gcmV0dXJuIHN1YnN0cmluZzMobmZkTmFtZSwgbmZkTmFtZUluZm8uaWR4T2ZCYXNlbmFtZSwgbGVuKG5mZE5hbWUpKQoJZnJhbWVfZGlnIC0xIC8vIG5mZE5hbWU6IHN0cmluZwoJZnJhbWVfZGlnIC0yIC8vIG5mZE5hbWVJbmZvOiBuZmRMZXR0ZXJzSW5mbwoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWV4dHJhY3QgOSA4CglidG9pCglmcmFtZV9kaWcgLTEgLy8gbmZkTmFtZTogc3RyaW5nCglsZW4KCXN1YnN0cmluZzMKCXJldHN1YgoKLy8gc2FmZUdsb2JhbEJ5dGVHZXRFeChhcHBJZDogdWludDY0LCBrZXk6IGJ5dGVzKTogYnl0ZXMKc2FmZUdsb2JhbEJ5dGVHZXRFeDoKCXByb3RvIDIgMQoKCS8vICppZjYzX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTIyMQoJLy8gIUFwcElELmZyb21VaW50NjQoYXBwSWQpLmdsb2JhbFN0YXRlRXhpc3RzKGtleSkKCWZyYW1lX2RpZyAtMSAvLyBhcHBJZDogdWludDY0CglmcmFtZV9kaWcgLTIgLy8ga2V5OiBieXRlcwoJYXBwX2dsb2JhbF9nZXRfZXgKCXN3YXAKCXBvcAoJIQoJYnogKmlmNjNfZW5kCgoJLy8gKmlmNjNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTIyMgoJLy8gcmV0dXJuICcnCglieXRlIDB4IC8vICIiCglyZXRzdWIKCippZjYzX2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEyMjQKCS8vIHJldHVybiBBcHBJRC5mcm9tVWludDY0KGFwcElkKS5nbG9iYWxTdGF0ZShrZXkpIGFzIGJ5dGVzCglmcmFtZV9kaWcgLTEgLy8gYXBwSWQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC0yIC8vIGtleTogYnl0ZXMKCWFwcF9nbG9iYWxfZ2V0X2V4CgoJLy8gZ2xvYmFsIHN0YXRlIHZhbHVlIGRvZXMgbm90IGV4aXN0OiBBcHBJRC5mcm9tVWludDY0KGFwcElkKS5nbG9iYWxTdGF0ZShrZXkpCglhc3NlcnQKCXJldHN1YgoKLy8gc2FmZUdsb2JhbEludEdldEV4KGFwcElkOiB1aW50NjQsIGtleTogYnl0ZXMpOiB1aW50NjQKc2FmZUdsb2JhbEludEdldEV4OgoJcHJvdG8gMiAxCgoJLy8gKmlmNjRfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMjI4CgkvLyAhQXBwSUQuZnJvbVVpbnQ2NChhcHBJZCkuZ2xvYmFsU3RhdGVFeGlzdHMoa2V5KQoJZnJhbWVfZGlnIC0xIC8vIGFwcElkOiB1aW50NjQKCWZyYW1lX2RpZyAtMiAvLyBrZXk6IGJ5dGVzCglhcHBfZ2xvYmFsX2dldF9leAoJc3dhcAoJcG9wCgkhCglieiAqaWY2NF9lbmQKCgkvLyAqaWY2NF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMjI5CgkvLyByZXR1cm4gMAoJaW50IDAKCXJldHN1YgoKKmlmNjRfZW5kOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTIzMQoJLy8gcmV0dXJuIGJ0b2koQXBwSUQuZnJvbVVpbnQ2NChhcHBJZCkuZ2xvYmFsU3RhdGUoa2V5KSBhcyBieXRlcykKCWZyYW1lX2RpZyAtMSAvLyBhcHBJZDogdWludDY0CglmcmFtZV9kaWcgLTIgLy8ga2V5OiBieXRlcwoJYXBwX2dsb2JhbF9nZXRfZXgKCgkvLyBnbG9iYWwgc3RhdGUgdmFsdWUgZG9lcyBub3QgZXhpc3Q6IEFwcElELmZyb21VaW50NjQoYXBwSWQpLmdsb2JhbFN0YXRlKGtleSkKCWFzc2VydAoJYnRvaQoJcmV0c3ViCgovLyBnZXRQcmljZUZvck5hbWUobmZkTmFtZTogc3RyaW5nLCBuZmROYW1lSW5mbzogbmZkTGV0dGVyc0luZm8sIGNhbGxlcjogQWRkcmVzcyk6IFByaWNlSW5mbwovLwovLyBUaGlzIG1ldGhvZCBjYWxjdWxhdGVzIHRoZSBwcmljZSBmb3IgYSBnaXZlbiBORkQgbmFtZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgaW5mb3JtYXRpb24uIFRoZSBwcmljZSBkZXBlbmRzIG9uCi8vIHdoZXRoZXIgdGhlIG5hbWUgaXMgYSBzZWdtZW50IG9yIG5vdCwgYW5kIHRoZSBudW1iZXIgb2YgbGV0dGVycyBpbiB0aGUgYmFzZW5hbWUuCi8vIEl0IGFzc3VtZXMgaXRzIGJlaW5nIGFza2VkIGFzIGlmIHRoaXMgaXMgYSAnbmV3JyBuYW1lIGFuZCBkb2Vzbid0IGNvbnNpZGVyIGlmIGFuIGV4aXN0aW5nIG5hbWUgYW5kIGlmIGl0cwovLyBleHBpcmVkLCBldGMuICBGb3IgdGhhdCwgYXNrIFRIQVQgbmZkIHdoYXQgaXRzIHJlbmV3YWwgcHJpY2UgaXMuCi8vCi8vIElmIHRoZSBuYW1lIGlzIGEgc2VnbWVudCwgdGhlIHByaWNpbmcgY29tZXMgZnJvbSBpdHMgcGFyZW50IG9yIHRoZSBzeXN0ZW0uIFRoZSBtZXRob2QgZmlyc3QgbG9va3MgdXAgdGhlIGFwcCBJRAovLyBmb3IgdGhlIHBhcmVudCBuYW1lLiBJZiB0aGUgYXBwIElEIGlzIG5vdCBhdmFpbGFibGUsIGFuIGFzc2VydGlvbiBpcyByYWlzZWQuCi8vCi8vIElmIHRoZSBwYXJlbnQgc2VnbWVudCBpcyB1bmxvY2tlZCwgdGhlIHByaWNlIGZvciBtaW50aW5nIHRoZSBzZWdtZW50IGlzIHJldHJpZXZlZCBmcm9tIHRoZSBwYXJlbnQgdXNpbmcgdGhlCi8vICdORkRfS0VZX1NFR01FTlRfVVNEX1BSSUNFJyBrZXkuIE90aGVyd2lzZSwgYSBtaW5pbXVtIHByaWNlIG9mIE5GRF9NSU5fU0VHTUVOVF9VU0QgaXMgdXNlZC4gVGhlIHNlZ21lbnQgbWludAovLyBjb3N0IGlzIHRoZW4gY29udmVydGVkIHRvIG1pY3JvYWxnb3MgYW5kIHJldHVybmVkLgovLwovLyBJZiB0aGUgbmFtZSBpcyBub3QgYSBzZWdtZW50LCB0aGUgcHJpY2UgaXMgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIGxldHRlcnMgaW4gdGhlIGJhc2VuYW1lLiBUaGUKLy8gYmFzZW5hbWUgbGVuZ3RoIGlzIHJldHJpZXZlZCBmcm9tIHRoZSBuYW1lIGluZm9ybWF0aW9uLiBUaGUgbWV0aG9kIHVzZXMgYSBjb25kaXRpb25hbCBzdGF0ZW1lbnQgdG8gZGV0ZXJtaW5lCi8vIHRoZSBwcmljZSBiYXNlZCBvbiB0aGUgYmFzZW5hbWUgbGVuZ3RoLiBUaGUgcHJpY2UgaXMgdGhlbiBjb252ZXJ0ZWQgdG8gbWljcm9hbGdvcyBhbmQgcmV0dXJuZWQuCi8vCi8vIEBwYXJhbSB7c3RyaW5nfSBuZmROYW1lIC0gVGhlIG5hbWUgdG8gZ2V0IHRoZSBwcmljZSBmb3IuCi8vIEBwYXJhbSB7bmZkTGV0dGVyc0luZm99IG5mZE5hbWVJbmZvIC0gVGhlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBuZmROYW1lIGxldHRlcnMuCi8vIEBwYXJhbSB7QWRkcmVzc30gY2FsbGVyIC0gdGhlIGFkZHJlc3MgdGhpcyByZXF1ZXN0IGlzIG9uIGJlaGFsZiBvZiAoc2luY2UgYW4gbmZkIGNvbnRyYWN0IG1pZ2h0IGNhbGwgdXMgaXQKLy8gbmVlZHMgdG8gYmUgYWJsZSB0byBwYXNzIG9uIHRoZSByZXF1ZXN0IG9uIGJlaGFsZiBvZiBJVFMgY2FsbGVyIC0gaWU6IGdldHRpbmcgcHJpY2UgZm9yIGFuIGV4cGlyZWQgbmZkIHdpbGwgYmUKLy8gZGlmZmVyZW50IGlmIGl0cyBvd25lciBpciBhc2tpbmcuCi8vIEByZXR1cm4ge1ByaWNlSW5mb30gcHJpY2UgZGV0YWlscyBmb3IgbWludGluZyBvciByZW5ld2luZwpnZXRQcmljZUZvck5hbWU6Cglwcm90byAzIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiAxOQoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEyNTkKCS8vIGNvbnN0cmFpbnREYXRhID0gdGhpcy5nZXRDb25zdHJhaW50cygpCgljYWxsc3ViIGdldENvbnN0cmFpbnRzCglmcmFtZV9idXJ5IDAgLy8gY29uc3RyYWludERhdGE6ICh1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoKCS8vICppZjY1X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTI2MQoJLy8gbmZkTmFtZUluZm8uaXNTZWdtZW50CglmcmFtZV9kaWcgLTIgLy8gbmZkTmFtZUluZm86IG5mZExldHRlcnNJbmZvCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJaW50IDAKCWdldGJpdAoJYnogKmlmNjVfZWxzZQoKCS8vICppZjY1X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEyNjMKCS8vIHBhcmVudEFwcElkID0gdGhpcy5mZXRjaEFwcElkRm9yTmFtZSh0aGlzLmZyb21OYW1lSW5mb0dldFBhcmVudE5hbWUobmZkTmFtZSwgbmZkTmFtZUluZm8pKQoJZnJhbWVfZGlnIC0yIC8vIG5mZE5hbWVJbmZvOiBuZmRMZXR0ZXJzSW5mbwoJZnJhbWVfZGlnIC0xIC8vIG5mZE5hbWU6IHN0cmluZwoJY2FsbHN1YiBmcm9tTmFtZUluZm9HZXRQYXJlbnROYW1lCgljYWxsc3ViIGZldGNoQXBwSWRGb3JOYW1lCglmcmFtZV9idXJ5IDIgLy8gcGFyZW50QXBwSWQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEyNjQKCS8vIGFzc2VydChwYXJlbnRBcHBJZCAhPT0gMCwgJ3BhcmVudCBuZmQvaWQgbXVzdCBiZSBmb3VuZCcpCglmcmFtZV9kaWcgMiAvLyBwYXJlbnRBcHBJZDogdWludDY0CglpbnQgMAoJIT0KCgkvLyBwYXJlbnQgbmZkL2lkIG11c3QgYmUgZm91bmQKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEyNjYKCS8vIHNlZ21lbnRNaW50Q29zdCA9IDAKCWludCAwCglmcmFtZV9idXJ5IDMgLy8gc2VnbWVudE1pbnRDb3N0OiB1aW50NjQKCgkvLyAqaWY2Nl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEyNjgKCS8vIHRoaXMuc2FmZUdsb2JhbEJ5dGVHZXRFeChwYXJlbnRBcHBJZCwgTkZEX0tFWV9JU1NFR01FTlRMT0NLRUQpID09PSBORkRfTE9DS0VEX1ZBTF9GQUxTRQoJYnl0ZSAiaS5zZWdtZW50TG9ja2VkIgoJZnJhbWVfZGlnIDIgLy8gcGFyZW50QXBwSWQ6IHVpbnQ2NAoJY2FsbHN1YiBzYWZlR2xvYmFsQnl0ZUdldEV4CglieXRlICIwIgoJPT0KCWJ6ICppZjY2X2Vsc2UKCgkvLyAqaWY2Nl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMjcwCgkvLyBzZWdtZW50TWludENvc3QgPSB0aGlzLnNhZmVHbG9iYWxJbnRHZXRFeChwYXJlbnRBcHBJZCwgTkZEX0tFWV9TRUdNRU5UX1VTRF9QUklDRSkKCWJ5dGUgImkuc2VnbWVudFByaWNlVXNkIgoJZnJhbWVfZGlnIDIgLy8gcGFyZW50QXBwSWQ6IHVpbnQ2NAoJY2FsbHN1YiBzYWZlR2xvYmFsSW50R2V0RXgKCWZyYW1lX2J1cnkgMyAvLyBzZWdtZW50TWludENvc3Q6IHVpbnQ2NAoKCS8vICppZjY3X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTI3MQoJLy8gc2VnbWVudE1pbnRDb3N0IDwgY29uc3RyYWludERhdGEuc2VnbWVudFBsYXRmb3JtQ29zdEluVXNkCglmcmFtZV9kaWcgMyAvLyBzZWdtZW50TWludENvc3Q6IHVpbnQ2NAoJZnJhbWVfZGlnIDAgLy8gY29uc3RyYWludERhdGE6ICh1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAwIDgKCWJ0b2kKCTwKCWJ6ICppZjY3X2VuZAoKCS8vICppZjY3X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEyNzIKCS8vIHNlZ21lbnRNaW50Q29zdCA9IGNvbnN0cmFpbnREYXRhLnNlZ21lbnRQbGF0Zm9ybUNvc3RJblVzZAoJZnJhbWVfZGlnIDAgLy8gY29uc3RyYWludERhdGE6ICh1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCAwIDgKCWJ0b2kKCWZyYW1lX2J1cnkgMyAvLyBzZWdtZW50TWludENvc3Q6IHVpbnQ2NAoKKmlmNjdfZW5kOgoJYiAqaWY2Nl9lbmQKCippZjY2X2Vsc2U6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMjc2CgkvLyBzZWdtZW50TWludENvc3QgPSBjb25zdHJhaW50RGF0YS5zZWdtZW50UGxhdGZvcm1Db3N0SW5Vc2QKCWZyYW1lX2RpZyAwIC8vIGNvbnN0cmFpbnREYXRhOiAodWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMCA4CglidG9pCglmcmFtZV9idXJ5IDMgLy8gc2VnbWVudE1pbnRDb3N0OiB1aW50NjQKCippZjY2X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEyNzkKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgICAgICBzZWdtZW50TWludENvc3QgPj0gY29uc3RyYWludERhdGEuc2VnbWVudFBsYXRmb3JtQ29zdEluVXNkLAoJLy8gICAgICAgICAgICAgICAgICdzZWdtZW50IG1pbnQgY29zdCBtdXN0IGJlIGF0IGxlYXN0IE5GRF9NSU5fU0VHTUVOVF9VU0QnLAoJLy8gICAgICAgICAgICAgKQoJZnJhbWVfZGlnIDMgLy8gc2VnbWVudE1pbnRDb3N0OiB1aW50NjQKCWZyYW1lX2RpZyAwIC8vIGNvbnN0cmFpbnREYXRhOiAodWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgMCA4CglidG9pCgk+PQoKCS8vIHNlZ21lbnQgbWludCBjb3N0IG11c3QgYmUgYXQgbGVhc3QgTkZEX01JTl9TRUdNRU5UX1VTRAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTI4NQoJLy8gcmV0UHJpY2UgPSB0aGlzLnVzZEluTWljcm9BbGdvKHNlZ21lbnRNaW50Q29zdCkKCWZyYW1lX2RpZyAzIC8vIHNlZ21lbnRNaW50Q29zdDogdWludDY0CgljYWxsc3ViIHVzZEluTWljcm9BbGdvCglmcmFtZV9idXJ5IDEgLy8gcmV0UHJpY2U6IHVpbnQ2NAoJYiAqaWY2NV9lbmQKCippZjY1X2Vsc2U6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMjg4CgkvLyBiYXNlbmFtZUxlbmd0aCA9IG5mZE5hbWVJbmZvLm51bUNoYXJzSW5CYXNlbmFtZQoJZnJhbWVfZGlnIC0yIC8vIG5mZE5hbWVJbmZvOiBuZmRMZXR0ZXJzSW5mbwoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWV4dHJhY3QgMSA4CglidG9pCglmcmFtZV9idXJ5IDQgLy8gYmFzZW5hbWVMZW5ndGg6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEyODkKCS8vIHVzZENvc3QgPSAwCglpbnQgMAoJZnJhbWVfYnVyeSA1IC8vIHVzZENvc3Q6IHVpbnQ2NAoKCS8vICppZjY4X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTI5MAoJLy8gYmFzZW5hbWVMZW5ndGggPj0gNQoJZnJhbWVfZGlnIDQgLy8gYmFzZW5hbWVMZW5ndGg6IHVpbnQ2NAoJaW50IDUKCT49CglieiAqaWY2OF9lbHNlaWYxX2NvbmRpdGlvbgoKCS8vICppZjY4X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEyOTEKCS8vIHVzZENvc3QgPSA2MDAKCWludCA2MDAKCWZyYW1lX2J1cnkgNSAvLyB1c2RDb3N0OiB1aW50NjQKCWIgKmlmNjhfZW5kCgoqaWY2OF9lbHNlaWYxX2NvbmRpdGlvbjoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEyOTIKCS8vIGJhc2VuYW1lTGVuZ3RoID09PSA0CglmcmFtZV9kaWcgNCAvLyBiYXNlbmFtZUxlbmd0aDogdWludDY0CglpbnQgNAoJPT0KCWJ6ICppZjY4X2Vsc2VpZjJfY29uZGl0aW9uCgoJLy8gKmlmNjhfZWxzZWlmMV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMjkzCgkvLyB1c2RDb3N0ID0gMTIwMAoJaW50IDEyMDAKCWZyYW1lX2J1cnkgNSAvLyB1c2RDb3N0OiB1aW50NjQKCWIgKmlmNjhfZW5kCgoqaWY2OF9lbHNlaWYyX2NvbmRpdGlvbjoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEyOTQKCS8vIGJhc2VuYW1lTGVuZ3RoID09PSAzCglmcmFtZV9kaWcgNCAvLyBiYXNlbmFtZUxlbmd0aDogdWludDY0CglpbnQgMwoJPT0KCWJ6ICppZjY4X2Vsc2VpZjNfY29uZGl0aW9uCgoJLy8gKmlmNjhfZWxzZWlmMl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMjk1CgkvLyB1c2RDb3N0ID0gMzAwMAoJaW50IDMwMDAKCWZyYW1lX2J1cnkgNSAvLyB1c2RDb3N0OiB1aW50NjQKCWIgKmlmNjhfZW5kCgoqaWY2OF9lbHNlaWYzX2NvbmRpdGlvbjoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEyOTYKCS8vIGJhc2VuYW1lTGVuZ3RoID09PSAyCglmcmFtZV9kaWcgNCAvLyBiYXNlbmFtZUxlbmd0aDogdWludDY0CglpbnQgMgoJPT0KCWJ6ICppZjY4X2Vsc2VpZjRfY29uZGl0aW9uCgoJLy8gKmlmNjhfZWxzZWlmM19jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMjk3CgkvLyB1c2RDb3N0ID0gOTAwMAoJaW50IDkwMDAKCWZyYW1lX2J1cnkgNSAvLyB1c2RDb3N0OiB1aW50NjQKCWIgKmlmNjhfZW5kCgoqaWY2OF9lbHNlaWY0X2NvbmRpdGlvbjoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEyOTgKCS8vIGJhc2VuYW1lTGVuZ3RoID09PSAxCglmcmFtZV9kaWcgNCAvLyBiYXNlbmFtZUxlbmd0aDogdWludDY0CglpbnQgMQoJPT0KCWJ6ICppZjY4X2Vsc2UKCgkvLyAqaWY2OF9lbHNlaWY0X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEyOTkKCS8vIHVzZENvc3QgPSAzMTUwMAoJaW50IDMxNTAwCglmcmFtZV9idXJ5IDUgLy8gdXNkQ29zdDogdWludDY0CgliICppZjY4X2VuZAoKKmlmNjhfZWxzZToKCS8vIGludmFsaWQgY29zdCBjYWxjCgllcnIKCippZjY4X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEzMDMKCS8vIG5ld1VzZENvc3QgPSB0aGlzLmNhbGNGdXR1cmVQcmljZSh1c2RDb3N0LCBnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcCkKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWZyYW1lX2RpZyA1IC8vIHVzZENvc3Q6IHVpbnQ2NAoJY2FsbHN1YiBjYWxjRnV0dXJlUHJpY2UKCWZyYW1lX2J1cnkgNiAvLyBuZXdVc2RDb3N0OiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMzA0CgkvLyByZXRQcmljZSA9IHRoaXMudXNkSW5NaWNyb0FsZ28obmV3VXNkQ29zdCkKCWZyYW1lX2RpZyA2IC8vIG5ld1VzZENvc3Q6IHVpbnQ2NAoJY2FsbHN1YiB1c2RJbk1pY3JvQWxnbwoJZnJhbWVfYnVyeSAxIC8vIHJldFByaWNlOiB1aW50NjQKCippZjY1X2VuZDoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEzMDgKCS8vIG5mZEFwcElkID0gdGhpcy5nZXROYW1lQXBwSWQobmZkTmFtZSkKCWZyYW1lX2RpZyAtMSAvLyBuZmROYW1lOiBzdHJpbmcKCWNhbGxzdWIgZ2V0TmFtZUFwcElkCglmcmFtZV9idXJ5IDcgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEzMDkKCS8vIGluQXVjdGlvbjogYm9vbGVhbiA9IGZhbHNlCglpbnQgMAoJZnJhbWVfYnVyeSA4IC8vIGluQXVjdGlvbjogYm9vbGVhbgoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEzMTAKCS8vIGlzRXhwaXJlZDogYm9vbGVhbiA9IGZhbHNlCglpbnQgMAoJZnJhbWVfYnVyeSA5IC8vIGlzRXhwaXJlZDogYm9vbGVhbgoKCS8vICppZjY5X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTMxMQoJLy8gbmZkQXBwSWQgIT09IDAKCWZyYW1lX2RpZyA3IC8vIG5mZEFwcElkOiB1aW50NjQKCWludCAwCgkhPQoJYnogKmlmNjlfZW5kCgoJLy8gKmlmNjlfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTMxMgoJLy8gaXNFeGlzdGluZ093bmVyID0gY2FsbGVyID09PSAoQXBwSUQuZnJvbVVpbnQ2NChuZmRBcHBJZCkuZ2xvYmFsU3RhdGUoTkZEX0tFWV9PV05FUikgYXMgQWRkcmVzcykKCWZyYW1lX2RpZyAtMyAvLyBjYWxsZXI6IEFkZHJlc3MKCWZyYW1lX2RpZyA3IC8vIG5mZEFwcElkOiB1aW50NjQKCWJ5dGUgImkub3duZXIuYSIKCWFwcF9nbG9iYWxfZ2V0X2V4CgoJLy8gZ2xvYmFsIHN0YXRlIHZhbHVlIGRvZXMgbm90IGV4aXN0OiBBcHBJRC5mcm9tVWludDY0KG5mZEFwcElkKS5nbG9iYWxTdGF0ZShORkRfS0VZX09XTkVSKQoJYXNzZXJ0Cgk9PQoJZnJhbWVfYnVyeSAxMCAvLyBpc0V4aXN0aW5nT3duZXI6IGJvb2wKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMzEzCgkvLyBleHBUaW1lID0gdGhpcy5zYWZlR2xvYmFsSW50R2V0RXgobmZkQXBwSWQsIE5GRF9LRVlfRVhQSVJBVElPTlRJTUUpCglieXRlICJpLmV4cGlyYXRpb25UaW1lIgoJZnJhbWVfZGlnIDcgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJY2FsbHN1YiBzYWZlR2xvYmFsSW50R2V0RXgKCWZyYW1lX2J1cnkgMTEgLy8gZXhwVGltZTogdWludDY0CgoJLy8gKmlmNzBfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMzE0CgkvLyB0aGlzLmlzRXhwaXJlZChleHBUaW1lKSAmJiAhaXNFeGlzdGluZ093bmVyCglmcmFtZV9kaWcgMTEgLy8gZXhwVGltZTogdWludDY0CgljYWxsc3ViIGlzRXhwaXJlZAoJZHVwCglieiAqc2tpcF9hbmQyMgoJZnJhbWVfZGlnIDEwIC8vIGlzRXhpc3RpbmdPd25lcjogYm9vbAoJIQoJJiYKCipza2lwX2FuZDIyOgoJYnogKmlmNzBfZW5kCgoJLy8gKmlmNzBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTMxNQoJLy8gaW5BdWN0aW9uID0gdHJ1ZQoJaW50IDEKCWZyYW1lX2J1cnkgOCAvLyBpbkF1Y3Rpb246IGJvb2xlYW4KCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMzE2CgkvLyBpc0V4cGlyZWQgPSB0cnVlCglpbnQgMQoJZnJhbWVfYnVyeSA5IC8vIGlzRXhwaXJlZDogYm9vbGVhbgoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEzMTkKCS8vIHN0YXJ0aW5nUHJpY2UgPSB0aGlzLnVzZEluTWljcm9BbGdvKGNvbnN0cmFpbnREYXRhLmV4cGlyZWRTdGFydGluZ1ByaWNlKQoJZnJhbWVfZGlnIDAgLy8gY29uc3RyYWludERhdGE6ICh1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KQoJZXh0cmFjdCA2NCA4CglidG9pCgljYWxsc3ViIHVzZEluTWljcm9BbGdvCglmcmFtZV9idXJ5IDEyIC8vIHN0YXJ0aW5nUHJpY2U6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEzMjAKCS8vIGVuZFByaWNlID0gcmV0UHJpY2UKCWZyYW1lX2RpZyAxIC8vIHJldFByaWNlOiB1aW50NjQKCWZyYW1lX2J1cnkgMTMgLy8gZW5kUHJpY2U6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEzMjEKCS8vIGN1clRpbWUgPSBnbG9iYWxzLmxhdGVzdFRpbWVzdGFtcAoJZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAoJZnJhbWVfYnVyeSAxNCAvLyBjdXJUaW1lOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMzIyCgkvLyBlbmRUaW1lID0gZXhwVGltZSArIGNvbnN0cmFpbnREYXRhLmV4cGlyZWRBdWN0aW9uRHVyYXRpb24gKiA2MCAqIDYwICogMjQKCWZyYW1lX2RpZyAxMSAvLyBleHBUaW1lOiB1aW50NjQKCWZyYW1lX2RpZyAwIC8vIGNvbnN0cmFpbnREYXRhOiAodWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCkKCWV4dHJhY3QgNTYgOAoJYnRvaQoJaW50IDYwCgkqCglpbnQgNjAKCSoKCWludCAyNAoJKgoJKwoJZnJhbWVfYnVyeSAxNSAvLyBlbmRUaW1lOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMzI3CgkvLyBhc3NlcnQoY3VyVGltZSA+IGV4cFRpbWUpCglmcmFtZV9kaWcgMTQgLy8gY3VyVGltZTogdWludDY0CglmcmFtZV9kaWcgMTEgLy8gZXhwVGltZTogdWludDY0Cgk+Cglhc3NlcnQKCgkvLyAqaWY3MV9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEzMjgKCS8vIGN1clRpbWUgPj0gZW5kVGltZQoJZnJhbWVfZGlnIDE0IC8vIGN1clRpbWU6IHVpbnQ2NAoJZnJhbWVfZGlnIDE1IC8vIGVuZFRpbWU6IHVpbnQ2NAoJPj0KCWJ6ICppZjcxX2Vsc2UKCgkvLyAqaWY3MV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMzI5CgkvLyByZXRQcmljZSA9IGVuZFByaWNlCglmcmFtZV9kaWcgMTMgLy8gZW5kUHJpY2U6IHVpbnQ2NAoJZnJhbWVfYnVyeSAxIC8vIHJldFByaWNlOiB1aW50NjQKCWIgKmlmNzFfZW5kCgoqaWY3MV9lbHNlOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTMzMQoJLy8gZWxhcHNlZCA9IGN1clRpbWUgLSBleHBUaW1lCglmcmFtZV9kaWcgMTQgLy8gY3VyVGltZTogdWludDY0CglmcmFtZV9kaWcgMTEgLy8gZXhwVGltZTogdWludDY0CgktCglmcmFtZV9idXJ5IDE2IC8vIGVsYXBzZWQ6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEzMzIKCS8vIHRvdGFsRHVyYXRpb24gPSBlbmRUaW1lIC0gZXhwVGltZQoJZnJhbWVfZGlnIDE1IC8vIGVuZFRpbWU6IHVpbnQ2NAoJZnJhbWVfZGlnIDExIC8vIGV4cFRpbWU6IHVpbnQ2NAoJLQoJZnJhbWVfYnVyeSAxNyAvLyB0b3RhbER1cmF0aW9uOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMzMzCgkvLyBwcmljZURpZmZlcmVuY2UgPSBzdGFydGluZ1ByaWNlIC0gZW5kUHJpY2UKCWZyYW1lX2RpZyAxMiAvLyBzdGFydGluZ1ByaWNlOiB1aW50NjQKCWZyYW1lX2RpZyAxMyAvLyBlbmRQcmljZTogdWludDY0CgktCglmcmFtZV9idXJ5IDE4IC8vIHByaWNlRGlmZmVyZW5jZTogdWludDY0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTMzNAoJLy8gcHJpY2VEcm9wID0gKHByaWNlRGlmZmVyZW5jZSAqIGVsYXBzZWQpIC8gdG90YWxEdXJhdGlvbgoJZnJhbWVfZGlnIDE4IC8vIHByaWNlRGlmZmVyZW5jZTogdWludDY0CglmcmFtZV9kaWcgMTYgLy8gZWxhcHNlZDogdWludDY0CgkqCglmcmFtZV9kaWcgMTcgLy8gdG90YWxEdXJhdGlvbjogdWludDY0CgkvCglmcmFtZV9idXJ5IDE5IC8vIHByaWNlRHJvcDogdWludDY0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTMzNQoJLy8gcmV0UHJpY2UgPSBzdGFydGluZ1ByaWNlIC0gcHJpY2VEcm9wCglmcmFtZV9kaWcgMTIgLy8gc3RhcnRpbmdQcmljZTogdWludDY0CglmcmFtZV9kaWcgMTkgLy8gcHJpY2VEcm9wOiB1aW50NjQKCS0KCWZyYW1lX2J1cnkgMSAvLyByZXRQcmljZTogdWludDY0CgoJLy8gKmlmNzJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMzM3CgkvLyByZXRQcmljZSA8IGVuZFByaWNlCglmcmFtZV9kaWcgMSAvLyByZXRQcmljZTogdWludDY0CglmcmFtZV9kaWcgMTMgLy8gZW5kUHJpY2U6IHVpbnQ2NAoJPAoJYnogKmlmNzJfZW5kCgoJLy8gKmlmNzJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTMzOAoJLy8gcmV0UHJpY2UgPSBlbmRQcmljZQoJZnJhbWVfZGlnIDEzIC8vIGVuZFByaWNlOiB1aW50NjQKCWZyYW1lX2J1cnkgMSAvLyByZXRQcmljZTogdWludDY0CgoqaWY3Ml9lbmQ6CgoqaWY3MV9lbmQ6CgoqaWY3MF9lbmQ6CgoqaWY2OV9lbmQ6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMzQzCgkvLyBhc3NlcnQocmV0UHJpY2UgPj0gMTAwMDAwMCwgJ3ByaWNlIGFsd2F5cyBuZWVkcyB0byBiZSBhdCBsZWFzdCAxIGFsZ28nKQoJZnJhbWVfZGlnIDEgLy8gcmV0UHJpY2U6IHVpbnQ2NAoJaW50IDEwMDAwMDAKCT49CgoJLy8gcHJpY2UgYWx3YXlzIG5lZWRzIHRvIGJlIGF0IGxlYXN0IDEgYWxnbwoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTM0NAoJLy8gcmV0dXJuIHsKCS8vICAgICAgICAgICAgIG9uZVllYXJQcmljZTogcmV0UHJpY2UsCgkvLyAgICAgICAgICAgICBjYXJyeUNvc3Q6IG5mZEFwcElkID09PSAwID8gdGhpcy5nZXROZmRNYnJDb3N0KG5mZE5hbWUpIDogMCwKCS8vICAgICAgICAgICAgIGV4aXN0czogbmZkQXBwSWQgIT09IDAsCgkvLyAgICAgICAgICAgICBpbkF1Y3Rpb246IGluQXVjdGlvbiwKCS8vICAgICAgICAgICAgIGlzRXhwaXJlZDogaXNFeHBpcmVkLAoJLy8gICAgICAgICB9CglmcmFtZV9kaWcgMSAvLyByZXRQcmljZTogdWludDY0CglpdG9iCglmcmFtZV9kaWcgNyAvLyBuZmRBcHBJZDogdWludDY0CglpbnQgMAoJPT0KCWJ6ICp0ZXJuYXJ5MV9mYWxzZQoJZnJhbWVfZGlnIC0xIC8vIG5mZE5hbWU6IHN0cmluZwoJY2FsbHN1YiBnZXROZmRNYnJDb3N0CgliICp0ZXJuYXJ5MV9lbmQKCip0ZXJuYXJ5MV9mYWxzZToKCWludCAwCgoqdGVybmFyeTFfZW5kOgoJaXRvYgoJY29uY2F0CglieXRlIDB4MDAKCWludCAwCglmcmFtZV9kaWcgNyAvLyBuZmRBcHBJZDogdWludDY0CglpbnQgMAoJIT0KCXNldGJpdAoJaW50IDEKCWZyYW1lX2RpZyA5IC8vIGlzRXhwaXJlZDogYm9vbGVhbgoJc2V0Yml0CglpbnQgMgoJZnJhbWVfZGlnIDggLy8gaW5BdWN0aW9uOiBib29sZWFuCglzZXRiaXQKCWNvbmNhdAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDE5CglyZXRzdWIKCi8vIGNhbGNGdXR1cmVQcmljZSh1aW50NjQsdWludDY0KXVpbnQ2NAoqYWJpX3JvdXRlX2NhbGNGdXR1cmVQcmljZToKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gZm9yVGltZTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gY3VyUHJpY2U6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgY2FsY0Z1dHVyZVByaWNlKHVpbnQ2NCx1aW50NjQpdWludDY0CgljYWxsc3ViIGNhbGNGdXR1cmVQcmljZQoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGNhbGNGdXR1cmVQcmljZShjdXJQcmljZTogdWludDY0LCBmb3JUaW1lOiB1aW50NjQpOiB1aW50NjQKLy8KLy8gQ2FsY3VsYXRlcyB0aGUgZnV0dXJlIHByaWNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IHByaWNlIGFuZCB0aGUgbnVtYmVyIG9mIHllYXJzLgovLwovLyBAcGFyYW0ge3VpbnQ2NH0gY3VyUHJpY2UgLSBUaGUgY3VycmVudCBwcmljZSBpbiBVU0QgKGluIGRlY2ltYWxzKS4gRm9yIGV4YW1wbGUsIGlmIHRoZSBjdXJyZW50IHByaWNlIGlzICQyLjAwLCB0aGUgdmFsdWUgc2hvdWxkIGJlIDIwMC4KLy8gQHBhcmFtIHt1aW50NjR9IGZvclRpbWUgLSBUaGUgdGltZXN0YW1wIHRvIGNhbGMgdGhlIGZ1dHVyZSBwcmljZSBiYXNlZCBvbiAtIGllOiAxIHllYXIgcGFzdCAnZ28gbGl2ZSBkYXRlJyB0aGUgcHJpY2Ugd291bGQgaGF2ZSBpbmZsYXRlZCBieSAxIHllYXIuCi8vCi8vIEByZXR1cm4ge3VpbnQ2NH0gVGhlIGZ1dHVyZSBwcmljZSBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBjdXJyZW50IHByaWNlIGFuZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiB5ZWFycy4KY2FsY0Z1dHVyZVByaWNlOgoJcHJvdG8gMiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMwoKCS8vICppZjczX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTM2NAoJLy8gZm9yVGltZSA8IDU2OTc1MDI4NDgwMAoJZnJhbWVfZGlnIC0yIC8vIGZvclRpbWU6IHVpbnQ2NAoJaW50IDU2OTc1MDI4NDgwMAoJPAoJYnogKmlmNzNfZW5kCgoJLy8gKmlmNzNfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTM2NgoJLy8gcmV0dXJuIGN1clByaWNlCglmcmFtZV9kaWcgLTEgLy8gY3VyUHJpY2U6IHVpbnQ2NAoJYiAqY2FsY0Z1dHVyZVByaWNlKnJldHVybgoKKmlmNzNfZW5kOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTM2OAoJLy8gdGltZVBhc3RMYXVuY2ggPSBmb3JUaW1lIC0gNTY5NzUwMjg0ODAwCglmcmFtZV9kaWcgLTIgLy8gZm9yVGltZTogdWludDY0CglpbnQgNTY5NzUwMjg0ODAwCgktCglmcmFtZV9idXJ5IDAgLy8gdGltZVBhc3RMYXVuY2g6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEzNzEKCS8vIHllYXJzQWZ0ZXJMYXVuY2ggPSB0aW1lUGFzdExhdW5jaCAvIDMxNTM2MDAwCglmcmFtZV9kaWcgMCAvLyB0aW1lUGFzdExhdW5jaDogdWludDY0CglpbnQgMzE1MzYwMDAKCS8KCWZyYW1lX2J1cnkgMSAvLyB5ZWFyc0FmdGVyTGF1bmNoOiB1aW50NjQKCgkvLyAqaWY3NF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEzNzIKCS8vIHllYXJzQWZ0ZXJMYXVuY2ggPT09IDAKCWZyYW1lX2RpZyAxIC8vIHllYXJzQWZ0ZXJMYXVuY2g6IHVpbnQ2NAoJaW50IDAKCT09CglieiAqaWY3NF9lbmQKCgkvLyAqaWY3NF9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMzczCgkvLyByZXR1cm4gY3VyUHJpY2UKCWZyYW1lX2RpZyAtMSAvLyBjdXJQcmljZTogdWludDY0CgliICpjYWxjRnV0dXJlUHJpY2UqcmV0dXJuCgoqaWY3NF9lbmQ6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMzc5CgkvLyBhZGpJbmZsYXRpb24gPSBleHB3KDEwMiwgeWVhcnNBZnRlckxhdW5jaCkKCWludCAxMDIKCWZyYW1lX2RpZyAxIC8vIHllYXJzQWZ0ZXJMYXVuY2g6IHVpbnQ2NAoJZXhwdwoJZnJhbWVfYnVyeSAyIC8vIGFkakluZmxhdGlvbiBsb3c6IHVpbnQ2NAoJZnJhbWVfYnVyeSAzIC8vIGFkakluZmxhdGlvbiBoaWdoOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMzgwCgkvLyByZXR1cm4gKGN1clByaWNlICogYWRqSW5mbGF0aW9uLmxvdykgLyAxMDAKCWZyYW1lX2RpZyAtMSAvLyBjdXJQcmljZTogdWludDY0CglmcmFtZV9kaWcgMiAvLyBhZGpJbmZsYXRpb24gbG93OiB1aW50NjQKCSoKCWludCAxMDAKCS8KCipjYWxjRnV0dXJlUHJpY2UqcmV0dXJuOgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMwoJcmV0c3ViCgovLyBwb3cxMChkZWNpbWFsczogdWludDY0KTogdWludDY0CnBvdzEwOgoJcHJvdG8gMSAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEzODQKCS8vIGV4cFJlc3VsdCA9IGV4cHcoMTAsIGRlY2ltYWxzKQoJaW50IDEwCglmcmFtZV9kaWcgLTEgLy8gZGVjaW1hbHM6IHVpbnQ2NAoJZXhwdwoJZnJhbWVfYnVyeSAwIC8vIGV4cFJlc3VsdCBsb3c6IHVpbnQ2NAoJZnJhbWVfYnVyeSAxIC8vIGV4cFJlc3VsdCBoaWdoOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMzg1CgkvLyByZXR1cm4gZXhwUmVzdWx0LmxvdwoJZnJhbWVfZGlnIDAgLy8gZXhwUmVzdWx0IGxvdzogdWludDY0CgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMQoJcmV0c3ViCgovLyBtaW5CYWxhbmNlRm9yQWNjb3VudChjb250cmFjdHM6IHVpbnQ2NCwgZXh0cmFQYWdlczogdWludDY0LCBhc3NldHM6IHVpbnQ2NCwgbG9jYWxJbnRzOiB1aW50NjQsIGxvY2FsQnl0ZXM6IHVpbnQ2NCwgZ2xvYmFsSW50czogdWludDY0LCBnbG9iYWxCeXRlczogdWludDY0KTogdWludDY0Cm1pbkJhbGFuY2VGb3JBY2NvdW50OgoJcHJvdG8gNyAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMzk3CgkvLyBtaW5CYWwgPSBBTEdPUkFORF9BQ0NPVU5UX01JTl9CQUxBTkNFCglpbnQgMTAwMDAwCglmcmFtZV9idXJ5IDAgLy8gbWluQmFsOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxMzk4CgkvLyBtaW5CYWwgKz0gY29udHJhY3RzICogQVBQTElDQVRJT05fQkFTRV9GRUUKCWZyYW1lX2RpZyAwIC8vIG1pbkJhbDogdWludDY0CglmcmFtZV9kaWcgLTEgLy8gY29udHJhY3RzOiB1aW50NjQKCWludCAxMDAwMDAKCSoKCSsKCWZyYW1lX2J1cnkgMCAvLyBtaW5CYWw6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjEzOTkKCS8vIG1pbkJhbCArPSBleHRyYVBhZ2VzICogQVBQTElDQVRJT05fQkFTRV9GRUUKCWZyYW1lX2RpZyAwIC8vIG1pbkJhbDogdWludDY0CglmcmFtZV9kaWcgLTIgLy8gZXh0cmFQYWdlczogdWludDY0CglpbnQgMTAwMDAwCgkqCgkrCglmcmFtZV9idXJ5IDAgLy8gbWluQmFsOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxNDAwCgkvLyBtaW5CYWwgKz0gYXNzZXRzICogQVNTRVRfSE9MRElOR19GRUUKCWZyYW1lX2RpZyAwIC8vIG1pbkJhbDogdWludDY0CglmcmFtZV9kaWcgLTMgLy8gYXNzZXRzOiB1aW50NjQKCWludCAxMDAwMDAKCSoKCSsKCWZyYW1lX2J1cnkgMCAvLyBtaW5CYWw6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE0MDEKCS8vIG1pbkJhbCArPSBsb2NhbEludHMgKiBTU0NfVkFMVUVfVUlOVAoJZnJhbWVfZGlnIDAgLy8gbWluQmFsOiB1aW50NjQKCWZyYW1lX2RpZyAtNCAvLyBsb2NhbEludHM6IHVpbnQ2NAoJaW50IDI4NTAwCgkqCgkrCglmcmFtZV9idXJ5IDAgLy8gbWluQmFsOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxNDAyCgkvLyBtaW5CYWwgKz0gZ2xvYmFsSW50cyAqIFNTQ19WQUxVRV9VSU5UCglmcmFtZV9kaWcgMCAvLyBtaW5CYWw6IHVpbnQ2NAoJZnJhbWVfZGlnIC02IC8vIGdsb2JhbEludHM6IHVpbnQ2NAoJaW50IDI4NTAwCgkqCgkrCglmcmFtZV9idXJ5IDAgLy8gbWluQmFsOiB1aW50NjQKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxNDAzCgkvLyBtaW5CYWwgKz0gbG9jYWxCeXRlcyAqIFNTQ19WQUxVRV9CWVRFUwoJZnJhbWVfZGlnIDAgLy8gbWluQmFsOiB1aW50NjQKCWZyYW1lX2RpZyAtNSAvLyBsb2NhbEJ5dGVzOiB1aW50NjQKCWludCA1MDAwMAoJKgoJKwoJZnJhbWVfYnVyeSAwIC8vIG1pbkJhbDogdWludDY0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQwNAoJLy8gbWluQmFsICs9IGdsb2JhbEJ5dGVzICogU1NDX1ZBTFVFX0JZVEVTCglmcmFtZV9kaWcgMCAvLyBtaW5CYWw6IHVpbnQ2NAoJZnJhbWVfZGlnIC03IC8vIGdsb2JhbEJ5dGVzOiB1aW50NjQKCWludCA1MDAwMAoJKgoJKwoJZnJhbWVfYnVyeSAwIC8vIG1pbkJhbDogdWludDY0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQwNQoJLy8gcmV0dXJuIG1pbkJhbAoJZnJhbWVfZGlnIDAgLy8gbWluQmFsOiB1aW50NjQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gY29zdEZvckJveFN0b3JhZ2UobmV3Qm94ZXM6IHVpbnQ2NCwgdG90YWxOdW1CeXRlczogdWludDY0KTogdWludDY0CmNvc3RGb3JCb3hTdG9yYWdlOgoJcHJvdG8gMiAxCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQwOQoJLy8gcmV0dXJuIFNDQk9YX1BFUkJPWCAqIG5ld0JveGVzICsgdG90YWxOdW1CeXRlcyAqIFNDQk9YX1BFUkJZVEUKCWludCAyNTAwCglmcmFtZV9kaWcgLTEgLy8gbmV3Qm94ZXM6IHVpbnQ2NAoJKgoJZnJhbWVfZGlnIC0yIC8vIHRvdGFsTnVtQnl0ZXM6IHVpbnQ2NAoJaW50IDQwMAoJKgoJKwoJcmV0c3ViCgovLyBjb25kZW5zZWRBc2FOYW1lKG5mZE5hbWU6IHN0cmluZyk6IHN0cmluZwpjb25kZW5zZWRBc2FOYW1lOgoJcHJvdG8gMSAxCgoJLy8gKmlmNzVfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxNDE0CgkvLyBsZW4obmZkTmFtZSkgPD0gMzIKCWZyYW1lX2RpZyAtMSAvLyBuZmROYW1lOiBzdHJpbmcKCWxlbgoJaW50IDMyCgk8PQoJYnogKmlmNzVfZW5kCgoJLy8gKmlmNzVfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQxNQoJLy8gcmV0dXJuIG5mZE5hbWUKCWZyYW1lX2RpZyAtMSAvLyBuZmROYW1lOiBzdHJpbmcKCXJldHN1YgoKKmlmNzVfZW5kOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQxOAoJLy8gcmV0dXJuIHN1YnN0cmluZzMobmZkTmFtZSwgMCwgMzIgLSBsZW4oc3VmZml4KSkgKyBzdWZmaXgKCWZyYW1lX2RpZyAtMSAvLyBuZmROYW1lOiBzdHJpbmcKCWludCAwCglpbnQgMzIKCWJ5dGUgIi4uLmFsZ28iCglsZW4KCS0KCXN1YnN0cmluZzMKCWJ5dGUgIi4uLmFsZ28iCgljb25jYXQKCXJldHN1YgoKLy8gZW5jb2RlVVZhckludEltcGwodmFsOiB1aW50NjQsIGI6IGJ5dGVzKTogYnl0ZXMKZW5jb2RlVVZhckludEltcGw6Cglwcm90byAyIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE0MjIKCS8vIGJ1ZmYgPSBiCglmcmFtZV9kaWcgLTIgLy8gYjogYnl0ZXMKCWZyYW1lX2J1cnkgMCAvLyBidWZmOiBieXRlW10KCgkvLyAqaWY3Nl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE0MjMKCS8vIHZhbCA+PSAxMjgKCWZyYW1lX2RpZyAtMSAvLyB2YWw6IHVpbnQ2NAoJaW50IDEyOAoJPj0KCWJ6ICppZjc2X2Vsc2UKCgkvLyAqaWY3Nl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxNDI0CgkvLyBidWZmID0gdGhpcy5lbmNvZGVVVmFySW50SW1wbCh2YWwgPj4gNywgZXh0cmFjdDMoaXRvYigodmFsICYgMjU1KSB8IDEyOCksIDcsIDEpKQoJZnJhbWVfZGlnIC0xIC8vIHZhbDogdWludDY0CglpbnQgMjU1CgkmCglpbnQgMTI4Cgl8CglpdG9iCglleHRyYWN0IDcgMQoJZnJhbWVfZGlnIC0xIC8vIHZhbDogdWludDY0CglpbnQgNwoJc2hyCgljYWxsc3ViIGVuY29kZVVWYXJJbnRJbXBsCglmcmFtZV9idXJ5IDAgLy8gYnVmZjogYnl0ZVtdCgliICppZjc2X2VuZAoKKmlmNzZfZWxzZToKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE0MjUKCS8vIGJ1ZmYgPSBleHRyYWN0MyhpdG9iKHZhbCAmIDI1NSksIDcsIDEpCglmcmFtZV9kaWcgLTEgLy8gdmFsOiB1aW50NjQKCWludCAyNTUKCSYKCWl0b2IKCWV4dHJhY3QgNyAxCglmcmFtZV9idXJ5IDAgLy8gYnVmZjogYnl0ZVtdCgoqaWY3Nl9lbmQ6CgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxNDI3CgkvLyByZXR1cm4gYiArIGJ1ZmYKCWZyYW1lX2RpZyAtMiAvLyBiOiBieXRlcwoJZnJhbWVfZGlnIDAgLy8gYnVmZjogYnl0ZVtdCgljb25jYXQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gZW5jb2RlVVZhckludCh2YWw6IHVpbnQ2NCk6IGJ5dGVzCmVuY29kZVVWYXJJbnQ6Cglwcm90byAxIDEKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxNDMxCgkvLyByZXR1cm4gdGhpcy5lbmNvZGVVVmFySW50SW1wbCh2YWwsICcnKQoJYnl0ZSAweCAvLyAiIgoJZnJhbWVfZGlnIC0xIC8vIHZhbDogdWludDY0CgljYWxsc3ViIGVuY29kZVVWYXJJbnRJbXBsCglyZXRzdWIKCi8vIGdldExzaWdBZGRyZXNzKGJ5dGVzVG9BZGQ6IGJ5dGVzKTogYnl0ZXMKZ2V0THNpZ0FkZHJlc3M6Cglwcm90byAxIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE0MzUKCS8vIGxzaWdCeXRlQ29kZSA9CgkvLyAgICAgICAgICAgICBoZXgoJzB4MDUyMDAxMDE4MDA4MDEwMjAzMDQwNTA2JykgKwoJLy8gICAgICAgICAgICAgaGV4KCcweDA3MDgxNzM1MDAzMTE4MzQwMDEyMzExMCcpICsKCS8vICAgICAgICAgICAgIGhleCgnMHg4MTA2MTIxMDMxMTkyMjEyMzExOTgxMDAnKSArCgkvLyAgICAgICAgICAgICBoZXgoJzB4MTIxMTEwNDAwMDAxMDAyMjQzMjYwMScpCglieXRlIDB4MDUyMDAxMDE4MDA4MDEwMjAzMDQwNTA2MDcwODE3MzUwMDMxMTgzNDAwMTIzMTEwODEwNjEyMTAzMTE5MjIxMjMxMTk4MTAwMTIxMTEwNDAwMDAxMDAyMjQzMjYwMQoJZnJhbWVfYnVyeSAwIC8vIGxzaWdCeXRlQ29kZTogYnl0ZVtdCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQ0MAoJLy8gbHNpZ0J5dGVDb2RlID0gcmVwbGFjZTMobHNpZ0J5dGVDb2RlLCA2LCBpdG9iKHRoaXMuYXBwKSkKCWZyYW1lX2RpZyAwIC8vIGxzaWdCeXRlQ29kZTogYnl0ZVtdCglpbnQgNgoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJaXRvYgoJcmVwbGFjZTMKCWZyYW1lX2J1cnkgMCAvLyBsc2lnQnl0ZUNvZGU6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE0NDEKCS8vIGxzaWdCeXRlQ29kZSA9IGxzaWdCeXRlQ29kZSArIHRoaXMuZW5jb2RlVVZhckludChieXRlc1RvQWRkLmxlbmd0aCkgKyBieXRlc1RvQWRkCglmcmFtZV9kaWcgMCAvLyBsc2lnQnl0ZUNvZGU6IGJ5dGVbXQoJZnJhbWVfZGlnIC0xIC8vIGJ5dGVzVG9BZGQ6IGJ5dGVzCglsZW4KCWNhbGxzdWIgZW5jb2RlVVZhckludAoJY29uY2F0CglmcmFtZV9kaWcgLTEgLy8gYnl0ZXNUb0FkZDogYnl0ZXMKCWNvbmNhdAoJZnJhbWVfYnVyeSAwIC8vIGxzaWdCeXRlQ29kZTogYnl0ZVtdCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQ0MgoJLy8gcmV0dXJuIHNoYTUxMl8yNTYoJ1Byb2dyYW0nICsgbHNpZ0J5dGVDb2RlKSBhcyBieXRlcwoJYnl0ZSAweDUwNzI2ZjY3NzI2MTZkIC8vICJQcm9ncmFtIgoJZnJhbWVfZGlnIDAgLy8gbHNpZ0J5dGVDb2RlOiBieXRlW10KCWNvbmNhdAoJc2hhNTEyXzI1NgoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBpc1YxTkZESURBdXRoZW50aWMobmZkTmFtZTogYnl0ZXMsIG5mZEFwcElkOiB1aW50NjQpOiBib29sZWFuCmlzVjFORkRJREF1dGhlbnRpYzoKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQ0NgoJLy8gcHJvZ0hhc2ggPSB0aGlzLmdldExzaWdBZGRyZXNzKCduYW1lLycgKyBuZmROYW1lKQoJYnl0ZSAweDZlNjE2ZDY1MmYgLy8gIm5hbWUvIgoJZnJhbWVfZGlnIC0xIC8vIG5mZE5hbWU6IGJ5dGVzCgljb25jYXQKCWNhbGxzdWIgZ2V0THNpZ0FkZHJlc3MKCWZyYW1lX2J1cnkgMCAvLyBwcm9nSGFzaDogYnl0ZVtdCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQ0OAoJLy8gYXNzZXJ0KAoJLy8gICAgICAgICAgICAgdGhpcy5sb2NhbFN0YXRlKEFkZHJlc3MuZnJvbUJ5dGVzKHByb2dIYXNoKSwgUkVHSVNUUllfS0VZX0FQUElEKS5leGlzdHMsCgkvLyAgICAgICAgICAgICAnbHNpZyBoYXMgdG8gaGF2ZSBpLmFwcGlkIGxvY2Fsc3RhdGUnLAoJLy8gICAgICAgICApCglmcmFtZV9kaWcgMCAvLyBwcm9nSGFzaDogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9ucyAwCglieXRlICJpLmFwcGlkIgoJYXBwX2xvY2FsX2dldF9leAoJc3dhcAoJcG9wCgoJLy8gbHNpZyBoYXMgdG8gaGF2ZSBpLmFwcGlkIGxvY2Fsc3RhdGUKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE0NTIKCS8vIHJldHVybiB0aGlzLmxvY2FsU3RhdGUoQWRkcmVzcy5mcm9tQnl0ZXMocHJvZ0hhc2gpLCBSRUdJU1RSWV9LRVlfQVBQSUQpLnZhbHVlID09PSBpdG9iKG5mZEFwcElkKQoJZnJhbWVfZGlnIDAgLy8gcHJvZ0hhc2g6IGJ5dGVbXQoJYnl0ZSAiaS5hcHBpZCIKCWFwcF9sb2NhbF9nZXQKCWZyYW1lX2RpZyAtMiAvLyBuZmRBcHBJZDogdWludDY0CglpdG9iCgk9PQoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoJcmV0c3ViCgovLyBnZXRCb3hOYW1lKG5mZE5hbWU6IGJ5dGVzKTogYnl0ZXMKZ2V0Qm94TmFtZToKCXByb3RvIDEgMQoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE0NTYKCS8vIHJldHVybiBzaGEyNTYoJ25hbWUvJyArIG5mZE5hbWUpIGFzIGJ5dGVzCglieXRlIDB4NmU2MTZkNjUyZiAvLyAibmFtZS8iCglmcmFtZV9kaWcgLTEgLy8gbmZkTmFtZTogYnl0ZXMKCWNvbmNhdAoJc2hhMjU2CglyZXRzdWIKCi8vIGdldEFsZ29BZGRyZXNzQm94TmFtZShhZGRyZXNzOiBieXRlcyk6IGJ5dGVzCmdldEFsZ29BZGRyZXNzQm94TmFtZToKCXByb3RvIDEgMQoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE0NjAKCS8vIHJldHVybiBzaGEyNTYoJ2FkZHIvYWxnby8nICsgYWRkcmVzcykgYXMgYnl0ZXMKCWJ5dGUgMHg2MTY0NjQ3MjJmNjE2YzY3NmYyZiAvLyAiYWRkci9hbGdvLyIKCWZyYW1lX2RpZyAtMSAvLyBhZGRyZXNzOiBieXRlcwoJY29uY2F0CglzaGEyNTYKCXJldHN1YgoKLy8gZ2V0QWNjb3VudE93bnNOZmRCb3hOYW1lKHVzZXJBY2NvdW50OiBBZGRyZXNzLCBuZmRBcHBJZDogdWludDY0KTogYnl0ZXMKZ2V0QWNjb3VudE93bnNOZmRCb3hOYW1lOgoJcHJvdG8gMiAxCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQ2NgoJLy8gcmV0dXJuIGNvbmNhdCgnTycsIGNvbmNhdChyYXdCeXRlcyh1c2VyQWNjb3VudCksIGl0b2IobmZkQXBwSWQpKSkKCWJ5dGUgMHg0ZiAvLyAiTyIKCWZyYW1lX2RpZyAtMSAvLyB1c2VyQWNjb3VudDogQWRkcmVzcwoJZnJhbWVfZGlnIC0yIC8vIG5mZEFwcElkOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJY29uY2F0CglyZXRzdWIKCi8vIGlzVjJOZmRBcHBJZEF1dGhlbnRpYyhuZmROYW1lOiBieXRlcywgbmZkQXBwSWQ6IHVpbnQ2NCk6IGJvb2xlYW4KaXNWMk5mZEFwcElkQXV0aGVudGljOgoJcHJvdG8gMiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMgoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE0NzAKCS8vIGJveE5hbWUgPSB0aGlzLmdldEJveE5hbWUobmZkTmFtZSkKCWZyYW1lX2RpZyAtMSAvLyBuZmROYW1lOiBieXRlcwoJY2FsbHN1YiBnZXRCb3hOYW1lCglmcmFtZV9idXJ5IDAgLy8gYm94TmFtZTogYnl0ZVtdCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQ3MQoJLy8gYm94RGF0YSA9IHRoaXMuYm94ZXMoYm94TmFtZSkudmFsdWUKCWZyYW1lX2RpZyAwIC8vIGJveE5hbWU6IGJ5dGVbXQoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5ib3hlcyhib3hOYW1lKS52YWx1ZQoJYXNzZXJ0CglmcmFtZV9idXJ5IDEgLy8gYm94RGF0YTogYnl0ZVtdCgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQ3MgoJLy8gYm94TGVuZ3RoID0gdGhpcy5ib3hlcyhib3hOYW1lKS5zaXplCglmcmFtZV9kaWcgMCAvLyBib3hOYW1lOiBieXRlW10KCWJveF9sZW4KCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMuYm94ZXMoYm94TmFtZSkuc2l6ZQoJYXNzZXJ0CglmcmFtZV9idXJ5IDIgLy8gYm94TGVuZ3RoOiB1aW50NjQKCgkvLyAqaWY3N19jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE0NzUKCS8vICF0aGlzLmJveGVzKGJveE5hbWUpLmV4aXN0cwoJZnJhbWVfZGlnIDAgLy8gYm94TmFtZTogYnl0ZVtdCglib3hfbGVuCglzd2FwCglwb3AKCSEKCWJ6ICppZjc3X2VuZAoKCS8vICppZjc3X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE0NzUKCS8vIHJldHVybiBmYWxzZQoJaW50IDAKCWIgKmlzVjJOZmRBcHBJZEF1dGhlbnRpYypyZXR1cm4KCippZjc3X2VuZDoKCS8vICppZjc4X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQ3NwoJLy8gYm94TGVuZ3RoICE9PSAxNgoJZnJhbWVfZGlnIDIgLy8gYm94TGVuZ3RoOiB1aW50NjQKCWludCAxNgoJIT0KCWJ6ICppZjc4X2VuZAoKCS8vICppZjc4X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE0NzcKCS8vIHJldHVybiBmYWxzZQoJaW50IDAKCWIgKmlzVjJOZmRBcHBJZEF1dGhlbnRpYypyZXR1cm4KCippZjc4X2VuZDoKCS8vICppZjc5X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQ3OAoJLy8gbmZkTmFtZS5sZW5ndGggPCA1CglmcmFtZV9kaWcgLTEgLy8gbmZkTmFtZTogYnl0ZXMKCWxlbgoJaW50IDUKCTwKCWJ6ICppZjc5X2VuZAoKCS8vICppZjc5X2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE0NzgKCS8vIHJldHVybiBmYWxzZQoJaW50IDAKCWIgKmlzVjJOZmRBcHBJZEF1dGhlbnRpYypyZXR1cm4KCippZjc5X2VuZDoKCS8vICppZjgwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQ3OQoJLy8gKEFwcElELmZyb21VaW50NjQobmZkQXBwSWQpLmdsb2JhbFN0YXRlKE5GRF9LRVlfTkFNRSkgYXMgYnl0ZXMpICE9PSBuZmROYW1lCglmcmFtZV9kaWcgLTIgLy8gbmZkQXBwSWQ6IHVpbnQ2NAoJYnl0ZSAiaS5uYW1lIgoJYXBwX2dsb2JhbF9nZXRfZXgKCgkvLyBnbG9iYWwgc3RhdGUgdmFsdWUgZG9lcyBub3QgZXhpc3Q6IEFwcElELmZyb21VaW50NjQobmZkQXBwSWQpLmdsb2JhbFN0YXRlKE5GRF9LRVlfTkFNRSkKCWFzc2VydAoJZnJhbWVfZGlnIC0xIC8vIG5mZE5hbWU6IGJ5dGVzCgkhPQoJYnogKmlmODBfZW5kCgoJLy8gKmlmODBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQ3OQoJLy8gcmV0dXJuIGZhbHNlCglpbnQgMAoJYiAqaXNWMk5mZEFwcElkQXV0aGVudGljKnJldHVybgoKKmlmODBfZW5kOgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQ4MAoJLy8gcmV0dXJuIGV4dHJhY3RVaW50NjQoYm94RGF0YSwgOCkgPT09IG5mZEFwcElkCglmcmFtZV9kaWcgMSAvLyBib3hEYXRhOiBieXRlW10KCWludCA4CglleHRyYWN0X3VpbnQ2NAoJZnJhbWVfZGlnIC0yIC8vIG5mZEFwcElkOiB1aW50NjQKCT09CgoqaXNWMk5mZEFwcElkQXV0aGVudGljKnJldHVybjoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDIKCXJldHN1YgoKLy8gY2FsY0V4cGlyYXRpb24ocmVuZXdhbFByaWNlOiB1aW50NjQsIGFtdFBhaWQ6IHVpbnQ2NCwgY3VyVGltZTogdWludDY0LCBtYXhZZWFyc0FsbG93ZWQ6IHVpbnQ2NCk6IHVpbnQ2NAovLwovLyBDYWxjdWxhdGVzIHRoZSBuZXcgZXhwaXJhdGlvbiB0aW1lIGJhc2VkIG9uIHRoZSByZW5ld2FsIHByaWNlLCBhbW91bnQgcGFpZCwgY3VycmVudCB0aW1lLCBhbmQgbWF4aW11bSB5ZWFycyBhbGxvd2VkLgovLwovLyBAcGFyYW0gcmVuZXdhbFByaWNlIC0gVGhlIHByaWNlIGZvciByZW5ld2luZyB0aGUgZXhwaXJhdGlvbi4KLy8gQHBhcmFtIGFtdFBhaWQgLSBUaGUgYW1vdW50IHBhaWQgZm9yIHRoZSByZW5ld2FsLgovLyBAcGFyYW0gY3VyVGltZSAtIFRoZSBjdXJyZW50IHRpbWUgaW4gdW5peCB0aW1lIHNlY29uZHMuCi8vIEBwYXJhbSBtYXhZZWFyc0FsbG93ZWQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgeWVhcnMgYWxsb3dlZCBmb3IgdGhlIGV4cGlyYXRpb24uCi8vCi8vIEByZXR1cm4gVGhlIG5ldyBleHBpcmF0aW9uIHRpbWUgaW4gdW5peHRpbWUgc2Vjb25kcwpjYWxjRXhwaXJhdGlvbjoKCXByb3RvIDQgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXAKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxNDk0CgkvLyBleHRyYURheXMgPSAoMzY1ICogYW10UGFpZCkgLyByZW5ld2FsUHJpY2UKCWludCAzNjUKCWZyYW1lX2RpZyAtMiAvLyBhbXRQYWlkOiB1aW50NjQKCSoKCWZyYW1lX2RpZyAtMSAvLyByZW5ld2FsUHJpY2U6IHVpbnQ2NAoJLwoJZnJhbWVfYnVyeSAwIC8vIGV4dHJhRGF5czogdWludDY0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTQ5NQoJLy8gbmV3RXhwaXJhdGlvbiA9IGN1clRpbWUgKyBleHRyYURheXMgKiBTRUNTX0lOX0RBWQoJZnJhbWVfZGlnIC0zIC8vIGN1clRpbWU6IHVpbnQ2NAoJZnJhbWVfZGlnIDAgLy8gZXh0cmFEYXlzOiB1aW50NjQKCWludCA4NjQwMAoJKgoJKwoJZnJhbWVfYnVyeSAxIC8vIG5ld0V4cGlyYXRpb246IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE0OTcKCS8vIGFzc2VydCgKCS8vICAgICAgICAgICAgIG5ld0V4cGlyYXRpb24gPD0gZ2xvYmFscy5sYXRlc3RUaW1lc3RhbXAgKyAzNjUgKiBtYXhZZWFyc0FsbG93ZWQgKiBTRUNTX0lOX0RBWSwKCS8vICAgICAgICAgICAgICdtYXggZXhwaXJhdGlvbiBleGNlZWRlZCBwYXJhbWV0ZXJzIGRlZmluZWQgYnkgcmVnaXN0cnknLAoJLy8gICAgICAgICApCglmcmFtZV9kaWcgMSAvLyBuZXdFeHBpcmF0aW9uOiB1aW50NjQKCWdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKCWludCAzNjUKCWZyYW1lX2RpZyAtNCAvLyBtYXhZZWFyc0FsbG93ZWQ6IHVpbnQ2NAoJKgoJaW50IDg2NDAwCgkqCgkrCgk8PQoKCS8vIG1heCBleHBpcmF0aW9uIGV4Y2VlZGVkIHBhcmFtZXRlcnMgZGVmaW5lZCBieSByZWdpc3RyeQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL05GRFJlZ2lzdHJ5LmFsZ28udHM6MTUwMQoJLy8gcmV0dXJuIG5ld0V4cGlyYXRpb24KCWZyYW1lX2RpZyAxIC8vIG5ld0V4cGlyYXRpb246IHVpbnQ2NAoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDEKCXJldHN1YgoKLy8gaXNQcmVWMyhhcHBJZDogdWludDY0KTogYm9vbGVhbgppc1ByZVYzOgoJcHJvdG8gMSAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHMvTkZEUmVnaXN0cnkuYWxnby50czoxNTA1CgkvLyBtYWpWZXIgPSBleHRyYWN0MyhBcHBJRC5mcm9tVWludDY0KGFwcElkKS5nbG9iYWxTdGF0ZShORkRfS0VZX1ZFUlNJT04pIGFzIGJ5dGVzLCAwLCAyKQoJZnJhbWVfZGlnIC0xIC8vIGFwcElkOiB1aW50NjQKCWJ5dGUgImkudmVyIgoJYXBwX2dsb2JhbF9nZXRfZXgKCgkvLyBnbG9iYWwgc3RhdGUgdmFsdWUgZG9lcyBub3QgZXhpc3Q6IEFwcElELmZyb21VaW50NjQoYXBwSWQpLmdsb2JhbFN0YXRlKE5GRF9LRVlfVkVSU0lPTikKCWFzc2VydAoJZXh0cmFjdCAwIDIKCWZyYW1lX2J1cnkgMCAvLyBtYWpWZXI6IGJ5dGVbXQoKCS8vIGNvbnRyYWN0cy9ORkRSZWdpc3RyeS5hbGdvLnRzOjE1MDYKCS8vIHJldHVybiBtYWpWZXIgPT09ICcxLicgfHwgbWFqVmVyID09PSAnMi4nCglmcmFtZV9kaWcgMCAvLyBtYWpWZXI6IGJ5dGVbXQoJYnl0ZSAweDMxMmUgLy8gIjEuIgoJPT0KCWR1cAoJYm56ICpza2lwX29yMwoJZnJhbWVfZGlnIDAgLy8gbWFqVmVyOiBieXRlW10KCWJ5dGUgMHgzMjJlIC8vICIyLiIKCT09Cgl8fAoKKnNraXBfb3IzOgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCglyZXRzdWIKCiphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb246CglpbnQgMQoJcmV0dXJuCgoqY3JlYXRlX05vT3A6CgltZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbgoKCS8vIHRoaXMgY29udHJhY3QgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBnaXZlbiBBQkkgbWV0aG9kIGZvciBjcmVhdGUgTm9PcAoJZXJyCgoqY2FsbF9Ob09wOgoJbWV0aG9kICJnYXMoKXZvaWQiCgltZXRob2QgImdldFByaWNlKHN0cmluZyxhZGRyZXNzKSh1aW50NjQsdWludDY0LGJvb2wsYm9vbCxib29sKSIKCW1ldGhvZCAiZ2V0Q29uc3RyYWludHMoKSh1aW50NjQsdWludDY0LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KSIKCW1ldGhvZCAiZ2V0TmZkTWJyQ29zdChzdHJpbmcpdWludDY0IgoJbWV0aG9kICJnZXROZmRMaW5rT25NaW50RXh0cmFNYnJDb3N0KGFkZHJlc3MpKHVpbnQ2NCx1aW50NjQpIgoJbWV0aG9kICJtaW50TmZkKHBheSxzdHJpbmcsYWRkcmVzcyxib29sKXVpbnQ2NCIKCW1ldGhvZCAibGlua05mZEFkZHJlc3Moc3RyaW5nLHVpbnQ2NCxhZGRyZXNzKXZvaWQiCgltZXRob2QgInVubGlua05mZEFkZHJlc3Moc3RyaW5nLHVpbnQ2NCxhZGRyZXNzKXZvaWQiCgltZXRob2QgIm93bmVyc2hpcEFzc2lnbihzdHJpbmcsdWludDY0KXZvaWQiCgltZXRob2QgIm93bmVyc2hpcENoYW5nZWQoc3RyaW5nLHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3Mpdm9pZCIKCW1ldGhvZCAic2V0QWRkcmVzc1ByaW1hcnlOZmQoc3RyaW5nLHVpbnQ2NCxhZGRyZXNzKXZvaWQiCgltZXRob2QgInVwZ3JhZGVOZmQoc3RyaW5nKXN0cmluZyIKCW1ldGhvZCAiaXNWYWxpZE5mZEFwcElkKHN0cmluZyx1aW50NjQpYm9vbCIKCW1ldGhvZCAiZ2V0TmFtZUFwcElkKHN0cmluZyl1aW50NjQiCgltZXRob2QgImdldEFkZHJlc3NBcHBJZHMoYWRkcmVzcyl1aW50NjRbXSIKCW1ldGhvZCAibmZkQ29udHJhY3RJbml0KHN0cmluZyx1aW50NjQsYnl0ZVtdKXZvaWQiCgltZXRob2QgIm5mZENvbnRyYWN0TG9hZChzdHJpbmcsdWludDY0LGJ5dGVbXSl2b2lkIgoJbWV0aG9kICJuZmRDb250cmFjdENvbW1pdChzdHJpbmcpdm9pZCIKCW1ldGhvZCAidXNkSW5NaWNyb0FsZ28odWludDY0KXVpbnQ2NCIKCW1ldGhvZCAiY29zdFRvQWRkVG9BZGRyZXNzKGFkZHJlc3MpdWludDY0IgoJbWV0aG9kICJjYWxjRnV0dXJlUHJpY2UodWludDY0LHVpbnQ2NCl1aW50NjQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCAqYWJpX3JvdXRlX2dhcyAqYWJpX3JvdXRlX2dldFByaWNlICphYmlfcm91dGVfZ2V0Q29uc3RyYWludHMgKmFiaV9yb3V0ZV9nZXROZmRNYnJDb3N0ICphYmlfcm91dGVfZ2V0TmZkTGlua09uTWludEV4dHJhTWJyQ29zdCAqYWJpX3JvdXRlX21pbnROZmQgKmFiaV9yb3V0ZV9saW5rTmZkQWRkcmVzcyAqYWJpX3JvdXRlX3VubGlua05mZEFkZHJlc3MgKmFiaV9yb3V0ZV9vd25lcnNoaXBBc3NpZ24gKmFiaV9yb3V0ZV9vd25lcnNoaXBDaGFuZ2VkICphYmlfcm91dGVfc2V0QWRkcmVzc1ByaW1hcnlOZmQgKmFiaV9yb3V0ZV91cGdyYWRlTmZkICphYmlfcm91dGVfaXNWYWxpZE5mZEFwcElkICphYmlfcm91dGVfZ2V0TmFtZUFwcElkICphYmlfcm91dGVfZ2V0QWRkcmVzc0FwcElkcyAqYWJpX3JvdXRlX25mZENvbnRyYWN0SW5pdCAqYWJpX3JvdXRlX25mZENvbnRyYWN0TG9hZCAqYWJpX3JvdXRlX25mZENvbnRyYWN0Q29tbWl0ICphYmlfcm91dGVfdXNkSW5NaWNyb0FsZ28gKmFiaV9yb3V0ZV9jb3N0VG9BZGRUb0FkZHJlc3MgKmFiaV9yb3V0ZV9jYWxjRnV0dXJlUHJpY2UKCgkvLyAhISEhIFdBUk5JTkc6IG5vbi1BQkkgcm91dGluZwoJY2FsbHN1YiBvbkNhbGwKCWludCAxCglyZXR1cm4KCipjYWxsX1VwZGF0ZUFwcGxpY2F0aW9uOgoJbWV0aG9kICJ1cGRhdGVBcHBsaWNhdGlvbigpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfdXBkYXRlQXBwbGljYXRpb24KCgkvLyAhISEhIFdBUk5JTkc6IG5vbi1BQkkgcm91dGluZwoJY2FsbHN1YiBvbkNhbGwKCWludCAxCglyZXR1cm4KCippbnRUb0FzY2lpOgoJcHJvdG8gMSAxCglieXRlIDB4MzAzMTMyMzMzNDM1MzYzNzM4MzkgLy8gIjAxMjM0NTY3ODkiCglmcmFtZV9kaWcgLTEgLy8gaTogdWludDY0CglpbnQgMQoJZXh0cmFjdDMKCXJldHN1YgoJCgoqaXRvYToKCXByb3RvIDEgMQoJZnJhbWVfZGlnIC0xIC8vIGk6IHVpbnQ2NAoJaW50IDAKCT09CglieiAqaXRvYV9pZl9lbmQKCWJ5dGUgMHgzMAoJcmV0c3ViCgoqaXRvYV9pZl9lbmQ6CglmcmFtZV9kaWcgLTEgLy8gaTogdWludDY0CglpbnQgMTAKCS8KCWludCAwCgk+CglieiAqaXRvYV90ZXJuYXJ5X2ZhbHNlCglmcmFtZV9kaWcgLTEgLy8gaTogdWludDY0CglpbnQgMTAKCS8KCWNhbGxzdWIgKml0b2EKCWIgKml0b2FfdGVybmFyeV9lbmQKCippdG9hX3Rlcm5hcnlfZmFsc2U6CglieXRlIDB4IC8vICIiCgoqaXRvYV90ZXJuYXJ5X2VuZDoKCWZyYW1lX2RpZyAtMSAvLyBpOiB1aW50NjQKCWludCAxMAoJJQoJY2FsbHN1YiAqaW50VG9Bc2NpaQoJY29uY2F0CglyZXRzdWIKCipwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50OgoJcHJvdG8gNCAzCglmcmFtZV9kaWcgLTQgLy8gdHVwbGUgaGVhZAoJZnJhbWVfZGlnIC0xIC8vIGVsZW1lbnQKCWNvbmNhdAoJZnJhbWVfZGlnIC0zIC8vIHR1cGxlIHRhaWwKCWZyYW1lX2RpZyAtMiAvLyBoZWFkIG9mZnNldAoJcmV0c3ViCgoqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQ6Cglwcm90byA0IDMKCWZyYW1lX2RpZyAtNCAvLyB0dXBsZSBoZWFkCglmcmFtZV9kaWcgLTIgLy8gaGVhZCBvZmZzZXQKCWNvbmNhdAoJZnJhbWVfYnVyeSAtNCAvLyB0dXBsZSBoZWFkCglmcmFtZV9kaWcgLTEgLy8gZWxlbWVudAoJZHVwCglsZW4KCWZyYW1lX2RpZyAtMiAvLyBoZWFkIG9mZnNldAoJYnRvaQoJKwoJaXRvYgoJZXh0cmFjdCA2IDIKCWZyYW1lX2J1cnkgLTIgLy8gaGVhZCBvZmZzZXQKCWZyYW1lX2RpZyAtMyAvLyB0dXBsZSB0YWlsCglzd2FwCgljb25jYXQKCWZyYW1lX2J1cnkgLTMgLy8gdHVwbGUgdGFpbAoJZnJhbWVfZGlnIC00IC8vIHR1cGxlIGhlYWQKCWZyYW1lX2RpZyAtMyAvLyB0dXBsZSB0YWlsCglmcmFtZV9kaWcgLTIgLy8gaGVhZCBvZmZzZXQKCXJldHN1Yg==",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw"
  },
  "contract": {
    "name": "NFDRegistry",
    "desc": "",
    "methods": [
      {
        "name": "updateApplication",
        "args": [],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "gas",
        "args": [],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "getPrice",
        "desc": "Returns the price for a given NFD (single year), the max # of years allowed (Name for Display),\nand extra algo required to cover MBR when purchasing.",
        "args": [
          {
            "name": "nfdName",
            "type": "string",
            "desc": "The NFD name for which to retrieve the price."
          },
          {
            "name": "caller",
            "type": "address",
            "desc": "the address this request is on behalf of (since an nfd contract might call us it\nneeds to be able to pass on the request on behalf of ITS caller - ie: getting price for an expired nfd will be\ndifferent if its owner ir asking.\n PriceInfo Type containing the price, carry cost, etc."
          }
        ],
        "returns": {
          "type": "(uint64,uint64,bool,bool,bool)"
        }
      },
      {
        "name": "getConstraints",
        "args": [],
        "returns": {
          "type": "(uint64,uint64,uint64,address,uint64,uint64,uint64)"
        }
      },
      {
        "name": "getNfdMbrCost",
        "desc": "Returns the MBR amounts needed to MINT an nfd.\nThis value needs to be added to purchase price in mintNfd call.\ngetPrice() returns it though.",
        "args": [
          {
            "name": "nfdName",
            "type": "string"
          }
        ],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "getNfdLinkOnMintExtraMbrCost",
        "args": [
          {
            "name": "address",
            "type": "address"
          }
        ],
        "returns": {
          "type": "(uint64,uint64)"
        }
      },
      {
        "name": "mintNfd",
        "desc": "Mint an NFD (NFT) and create a new NFD instance.",
        "args": [
          {
            "name": "purchaseTxn",
            "type": "pay",
            "desc": "The payment transaction covering the purchase amount of the nfd"
          },
          {
            "name": "nfdName",
            "type": "string",
            "desc": "The name of the NFD to mint"
          },
          {
            "name": "reservedFor",
            "type": "address",
            "desc": "The address that will own the NFD once minted (so you can buy for someone else)"
          },
          {
            "name": "linkOnMint",
            "type": "bool",
            "desc": "whether to auto-link the address (reserved for MUST MATCH payer!) at mint\n uint64 - The ID of the newly created NFD instance."
          }
        ],
        "returns": {
          "type": "uint64"
        },
        "events": [
          {
            "name": "nfdRegistry_minted",
            "args": [
              {
                "name": "appId",
                "type": "uint64"
              },
              {
                "name": "name",
                "type": "string"
              },
              {
                "name": "priceOneYear",
                "type": "uint64"
              },
              {
                "name": "paidAmount",
                "type": "uint64"
              },
              {
                "name": "carryCost",
                "type": "uint64"
              },
              {
                "name": "seller",
                "type": "address"
              },
              {
                "name": "buyer",
                "type": "address"
              },
              {
                "name": "owner",
                "type": "address"
              },
              {
                "name": "expTime",
                "type": "uint64"
              },
              {
                "name": "amountToSeller",
                "type": "uint64"
              },
              {
                "name": "commissionAddress",
                "type": "address"
              },
              {
                "name": "amountToCommission",
                "type": "uint64"
              },
              {
                "name": "segmentRootOwner",
                "type": "address"
              },
              {
                "name": "amountToSegmentRoot",
                "type": "uint64"
              }
            ],
            "desc": ""
          }
        ]
      },
      {
        "name": "linkNfdAddress",
        "args": [
          {
            "name": "nfdName",
            "type": "string"
          },
          {
            "name": "nfdAppId",
            "type": "uint64"
          },
          {
            "name": "addrToVerify",
            "type": "address"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "unlinkNfdAddress",
        "args": [
          {
            "name": "nfdName",
            "type": "string"
          },
          {
            "name": "nfdAppId",
            "type": "uint64"
          },
          {
            "name": "addrToUnlink",
            "type": "address"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "ownershipAssign",
        "args": [
          {
            "name": "nfdName",
            "type": "string"
          },
          {
            "name": "nfdAppId",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "ownershipChanged",
        "desc": "This method is triggered when the ownership of an NFD (Non-Fungible Domain) changes.\nIt is called by the NFD via the purchase method.  It can also be called by TxnLab admin for older 3.3\nNFDs when it detects purchased events for 3.3",
        "args": [
          {
            "name": "nfdName",
            "type": "string",
            "desc": "The name of the NFD."
          },
          {
            "name": "nfdAppId",
            "type": "uint64",
            "desc": "The unique application ID of the NFD."
          },
          {
            "name": "seller",
            "type": "address",
            "desc": "The address of the prior owner (seller) of the nfd"
          },
          {
            "name": "buyer",
            "type": "address",
            "desc": "The address of the new owner of the NFD."
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "setAddressPrimaryNfd",
        "desc": "Makes the specified NFD the 'first' NFD in the reverse-address set so its the primary NFD for this address.\nThe NFD must be valid, and the sender must be the address (or nfd owner if vault).  The NFD wouldn't already be\nin the reverse-lookup set if it wasn't already valid.",
        "args": [
          {
            "name": "nfdName",
            "type": "string"
          },
          {
            "name": "nfdAppId",
            "type": "uint64"
          },
          {
            "name": "addrBeingModified",
            "type": "address"
          }
        ],
        "returns": {
          "type": "void"
        },
        "events": [
          {
            "name": "nfdRegistry_addressPrimaryNfdChanged",
            "args": [
              {
                "name": "appId",
                "type": "uint64"
              },
              {
                "name": "name",
                "type": "string"
              },
              {
                "name": "address",
                "type": "address"
              }
            ],
            "desc": ""
          }
        ]
      },
      {
        "name": "upgradeNfd",
        "args": [
          {
            "name": "nfdName",
            "type": "string"
          }
        ],
        "returns": {
          "type": "string"
        }
      },
      {
        "name": "isValidNfdAppId",
        "args": [
          {
            "name": "nfdName",
            "type": "string"
          },
          {
            "name": "nfdAppId",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "bool"
        }
      },
      {
        "name": "getNameAppId",
        "args": [
          {
            "name": "nfdName",
            "type": "string"
          }
        ],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "getAddressAppIds",
        "args": [
          {
            "name": "lookupAddress",
            "type": "address"
          }
        ],
        "returns": {
          "type": "uint64[]"
        }
      },
      {
        "name": "nfdContractInit",
        "desc": "Initializes the NFD contract bytecode into the registry",
        "args": [
          {
            "name": "version",
            "type": "string",
            "desc": "The version of the contract."
          },
          {
            "name": "size",
            "type": "uint64",
            "desc": "exact byte size of contract to load"
          },
          {
            "name": "clearCode",
            "type": "byte[]",
            "desc": "bytes of clear code"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "nfdContractLoad",
        "desc": "Loads contract data into the  box at the specified offset.",
        "args": [
          {
            "name": "version",
            "type": "string",
            "desc": "The version of the contract."
          },
          {
            "name": "offset",
            "type": "uint64",
            "desc": "The offset at which to replace the contract data within the box."
          },
          {
            "name": "data",
            "type": "byte[]",
            "desc": "The contract data to be loaded."
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "nfdContractCommit",
        "desc": "Commit a new version of the contract.",
        "args": [
          {
            "name": "version",
            "type": "string",
            "desc": "The version number of the contract to be committed."
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "usdInMicroAlgo",
        "args": [
          {
            "name": "usdCost",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "costToAddToAddress",
        "desc": "Returns the cost to add an NFD to the reverse-lookup data",
        "args": [
          {
            "name": "lookupAddress",
            "type": "address",
            "desc": "The address to add the NFD app id to"
          }
        ],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "calcFuturePrice",
        "desc": "Calculates the future price based on the current price and the number of years.",
        "args": [
          {
            "name": "curPrice",
            "type": "uint64",
            "desc": "The current price in USD (in decimals). For example, if the current price is $2.00, the value should be 200."
          },
          {
            "name": "forTime",
            "type": "uint64",
            "desc": "The timestamp to calc the future price based on - ie: 1 year past 'go live date' the price would have inflated by 1 year.\n\n\n uint64 The future price calculated based on the current price and the specified number of years."
          }
        ],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "createApplication",
        "args": [],
        "returns": {
          "type": "void"
        }
      }
    ],
    "events": [
      {
        "name": "nfdRegistry_minted",
        "args": [
          {
            "name": "appId",
            "type": "uint64"
          },
          {
            "name": "name",
            "type": "string"
          },
          {
            "name": "priceOneYear",
            "type": "uint64"
          },
          {
            "name": "paidAmount",
            "type": "uint64"
          },
          {
            "name": "carryCost",
            "type": "uint64"
          },
          {
            "name": "seller",
            "type": "address"
          },
          {
            "name": "buyer",
            "type": "address"
          },
          {
            "name": "owner",
            "type": "address"
          },
          {
            "name": "expTime",
            "type": "uint64"
          },
          {
            "name": "amountToSeller",
            "type": "uint64"
          },
          {
            "name": "commissionAddress",
            "type": "address"
          },
          {
            "name": "amountToCommission",
            "type": "uint64"
          },
          {
            "name": "segmentRootOwner",
            "type": "address"
          },
          {
            "name": "amountToSegmentRoot",
            "type": "uint64"
          }
        ],
        "desc": ""
      },
      {
        "name": "nfdRegistry_addressPrimaryNfdChanged",
        "args": [
          {
            "name": "appId",
            "type": "uint64"
          },
          {
            "name": "name",
            "type": "string"
          },
          {
            "name": "address",
            "type": "address"
          }
        ],
        "desc": ""
      }
    ]
  }
}

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt.
   */
  asBigInt(): bigint
  /**
   * Gets the state value as a number.
   */
  asNumber(): number
}
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array
  /**
   * Gets the state value as a string
   */
  asString(): string
}

export type AppCreateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult> & AppReference
export type AppUpdateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult>

export type AppClientComposeCallCoreParams = Omit<AppClientCallCoreParams, 'sendParams'> & {
  sendParams?: Omit<SendTransactionParams, 'skipSending' | 'atc' | 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources'>
}
export type AppClientComposeExecuteParams = Pick<SendTransactionParams, 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources' | 'suppressLog'>

/**
 * Defines the types of available calls and state of the NfdRegistry smart contract.
 */
export type NfdRegistry = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'updateApplication()void' | 'updateApplication', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
    & Record<'gas()void' | 'gas', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
    & Record<'getPrice(string,address)(uint64,uint64,bool,bool,bool)' | 'getPrice', {
      argsObj: {
        /**
         * The NFD name for which to retrieve the price.
         */
        nfdName: string
        /**
         * the address this request is on behalf of (since an nfd contract might call us it
needs to be able to pass on the request on behalf of ITS caller - ie: getting price for an expired nfd will be
different if its owner ir asking.
 PriceInfo Type containing the price, carry cost, etc.
         */
        caller: string
      }
      argsTuple: [nfdName: string, caller: string]
      returns: [bigint, bigint, boolean, boolean, boolean]
    }>
    & Record<'getConstraints()(uint64,uint64,uint64,address,uint64,uint64,uint64)' | 'getConstraints', {
      argsObj: {
      }
      argsTuple: []
      returns: [bigint, bigint, bigint, string, bigint, bigint, bigint]
    }>
    & Record<'getNfdMbrCost(string)uint64' | 'getNfdMbrCost', {
      argsObj: {
        nfdName: string
      }
      argsTuple: [nfdName: string]
      returns: bigint
    }>
    & Record<'getNfdLinkOnMintExtraMbrCost(address)(uint64,uint64)' | 'getNfdLinkOnMintExtraMbrCost', {
      argsObj: {
        address: string
      }
      argsTuple: [address: string]
      returns: [bigint, bigint]
    }>
    & Record<'mintNfd(pay,string,address,bool)uint64' | 'mintNfd', {
      argsObj: {
        /**
         * The payment transaction covering the purchase amount of the nfd
         */
        purchaseTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * The name of the NFD to mint
         */
        nfdName: string
        /**
         * The address that will own the NFD once minted (so you can buy for someone else)
         */
        reservedFor: string
        /**
         * whether to auto-link the address (reserved for MUST MATCH payer!) at mint
 uint64 - The ID of the newly created NFD instance.
         */
        linkOnMint: boolean
      }
      argsTuple: [purchaseTxn: TransactionToSign | Transaction | Promise<SendTransactionResult>, nfdName: string, reservedFor: string, linkOnMint: boolean]
      returns: bigint
    }>
    & Record<'linkNfdAddress(string,uint64,address)void' | 'linkNfdAddress', {
      argsObj: {
        nfdName: string
        nfdAppId: bigint | number
        addrToVerify: string
      }
      argsTuple: [nfdName: string, nfdAppId: bigint | number, addrToVerify: string]
      returns: void
    }>
    & Record<'unlinkNfdAddress(string,uint64,address)void' | 'unlinkNfdAddress', {
      argsObj: {
        nfdName: string
        nfdAppId: bigint | number
        addrToUnlink: string
      }
      argsTuple: [nfdName: string, nfdAppId: bigint | number, addrToUnlink: string]
      returns: void
    }>
    & Record<'ownershipAssign(string,uint64)void' | 'ownershipAssign', {
      argsObj: {
        nfdName: string
        nfdAppId: bigint | number
      }
      argsTuple: [nfdName: string, nfdAppId: bigint | number]
      returns: void
    }>
    & Record<'ownershipChanged(string,uint64,address,address)void' | 'ownershipChanged', {
      argsObj: {
        /**
         * The name of the NFD.
         */
        nfdName: string
        /**
         * The unique application ID of the NFD.
         */
        nfdAppId: bigint | number
        /**
         * The address of the prior owner (seller) of the nfd
         */
        seller: string
        /**
         * The address of the new owner of the NFD.
         */
        buyer: string
      }
      argsTuple: [nfdName: string, nfdAppId: bigint | number, seller: string, buyer: string]
      returns: void
    }>
    & Record<'setAddressPrimaryNfd(string,uint64,address)void' | 'setAddressPrimaryNfd', {
      argsObj: {
        nfdName: string
        nfdAppId: bigint | number
        addrBeingModified: string
      }
      argsTuple: [nfdName: string, nfdAppId: bigint | number, addrBeingModified: string]
      returns: void
    }>
    & Record<'upgradeNfd(string)string' | 'upgradeNfd', {
      argsObj: {
        nfdName: string
      }
      argsTuple: [nfdName: string]
      returns: string
    }>
    & Record<'isValidNfdAppId(string,uint64)bool' | 'isValidNfdAppId', {
      argsObj: {
        nfdName: string
        nfdAppId: bigint | number
      }
      argsTuple: [nfdName: string, nfdAppId: bigint | number]
      returns: boolean
    }>
    & Record<'getNameAppId(string)uint64' | 'getNameAppId', {
      argsObj: {
        nfdName: string
      }
      argsTuple: [nfdName: string]
      returns: bigint
    }>
    & Record<'getAddressAppIds(address)uint64[]' | 'getAddressAppIds', {
      argsObj: {
        lookupAddress: string
      }
      argsTuple: [lookupAddress: string]
      returns: bigint[]
    }>
    & Record<'nfdContractInit(string,uint64,byte[])void' | 'nfdContractInit', {
      argsObj: {
        /**
         * The version of the contract.
         */
        version: string
        /**
         * exact byte size of contract to load
         */
        size: bigint | number
        /**
         * bytes of clear code
         */
        clearCode: Uint8Array
      }
      argsTuple: [version: string, size: bigint | number, clearCode: Uint8Array]
      returns: void
    }>
    & Record<'nfdContractLoad(string,uint64,byte[])void' | 'nfdContractLoad', {
      argsObj: {
        /**
         * The version of the contract.
         */
        version: string
        /**
         * The offset at which to replace the contract data within the box.
         */
        offset: bigint | number
        /**
         * The contract data to be loaded.
         */
        data: Uint8Array
      }
      argsTuple: [version: string, offset: bigint | number, data: Uint8Array]
      returns: void
    }>
    & Record<'nfdContractCommit(string)void' | 'nfdContractCommit', {
      argsObj: {
        /**
         * The version number of the contract to be committed.
         */
        version: string
      }
      argsTuple: [version: string]
      returns: void
    }>
    & Record<'usdInMicroAlgo(uint64)uint64' | 'usdInMicroAlgo', {
      argsObj: {
        usdCost: bigint | number
      }
      argsTuple: [usdCost: bigint | number]
      returns: bigint
    }>
    & Record<'costToAddToAddress(address)uint64' | 'costToAddToAddress', {
      argsObj: {
        /**
         * The address to add the NFD app id to
         */
        lookupAddress: string
      }
      argsTuple: [lookupAddress: string]
      returns: bigint
    }>
    & Record<'calcFuturePrice(uint64,uint64)uint64' | 'calcFuturePrice', {
      argsObj: {
        /**
         * The current price in USD (in decimals). For example, if the current price is $2.00, the value should be 200.
         */
        curPrice: bigint | number
        /**
         * The timestamp to calc the future price based on - ie: 1 year past 'go live date' the price would have inflated by 1 year.


 uint64 The future price calculated based on the current price and the specified number of years.
         */
        forTime: bigint | number
      }
      argsTuple: [curPrice: bigint | number, forTime: bigint | number]
      returns: bigint
    }>
    & Record<'createApplication()void' | 'createApplication', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
}
/**
 * Defines the possible abi call signatures
 */
export type NfdRegistrySig = keyof NfdRegistry['methods']
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends NfdRegistrySig | undefined> = {
  method: TSignature
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>
} & AppClientCallCoreParams & CoreAppCallArgs
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>
/**
 * Maps a method signature from the NfdRegistry smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends NfdRegistrySig> = NfdRegistry['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the NfdRegistry smart contract to the method's return type
 */
export type MethodReturn<TSignature extends NfdRegistrySig> = NfdRegistry['methods'][TSignature]['returns']

/**
 * A factory for available 'create' calls
 */
export type NfdRegistryCreateCalls = (typeof NfdRegistryCallFactory)['create']
/**
 * Defines supported create methods for this smart contract
 */
export type NfdRegistryCreateCallParams =
  | (TypedCallParams<'createApplication()void'> & (OnCompleteNoOp))
/**
 * A factory for available 'update' calls
 */
export type NfdRegistryUpdateCalls = (typeof NfdRegistryCallFactory)['update']
/**
 * Defines supported update methods for this smart contract
 */
export type NfdRegistryUpdateCallParams =
  | TypedCallParams<'updateApplication()void'>
/**
 * Defines arguments required for the deploy method.
 */
export type NfdRegistryDeployArgs = {
  deployTimeParams?: TealTemplateParams
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: NfdRegistryCreateCalls) => NfdRegistryCreateCallParams
  /**
   * A delegate which takes a update call factory and returns the update call params for this smart contract
   */
  updateCall?: (callFactory: NfdRegistryUpdateCalls) => NfdRegistryUpdateCallParams
}


/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class NfdRegistryCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the NFDRegistry smart contract using the createApplication()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      createApplication(args: MethodArgs<'createApplication()void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return {
          method: 'createApplication()void' as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        }
      },
    }
  }

  /**
   * Gets available update call factories
   */
  static get update() {
    return {
      /**
       * Constructs an update call for the NFDRegistry smart contract using the updateApplication()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      updateApplication(args: MethodArgs<'updateApplication()void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams = {}) {
        return {
          method: 'updateApplication()void' as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        }
      },
    }
  }

  /**
   * Constructs a no op call for the gas()void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static gas(args: MethodArgs<'gas()void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'gas()void' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getPrice(string,address)(uint64,uint64,bool,bool,bool) ABI method
   *
   * Returns the price for a given NFD (single year), the max # of years allowed (Name for Display),
and extra algo required to cover MBR when purchasing.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getPrice(args: MethodArgs<'getPrice(string,address)(uint64,uint64,bool,bool,bool)'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getPrice(string,address)(uint64,uint64,bool,bool,bool)' as const,
      methodArgs: Array.isArray(args) ? args : [args.nfdName, args.caller],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getConstraints()(uint64,uint64,uint64,address,uint64,uint64,uint64) ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getConstraints(args: MethodArgs<'getConstraints()(uint64,uint64,uint64,address,uint64,uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getConstraints()(uint64,uint64,uint64,address,uint64,uint64,uint64)' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getNfdMbrCost(string)uint64 ABI method
   *
   * Returns the MBR amounts needed to MINT an nfd.
This value needs to be added to purchase price in mintNfd call.
getPrice() returns it though.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getNfdMbrCost(args: MethodArgs<'getNfdMbrCost(string)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getNfdMbrCost(string)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.nfdName],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getNfdLinkOnMintExtraMbrCost(address)(uint64,uint64) ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getNfdLinkOnMintExtraMbrCost(args: MethodArgs<'getNfdLinkOnMintExtraMbrCost(address)(uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getNfdLinkOnMintExtraMbrCost(address)(uint64,uint64)' as const,
      methodArgs: Array.isArray(args) ? args : [args.address],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the mintNfd(pay,string,address,bool)uint64 ABI method
   *
   * Mint an NFD (NFT) and create a new NFD instance.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static mintNfd(args: MethodArgs<'mintNfd(pay,string,address,bool)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'mintNfd(pay,string,address,bool)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.purchaseTxn, args.nfdName, args.reservedFor, args.linkOnMint],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the linkNfdAddress(string,uint64,address)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static linkNfdAddress(args: MethodArgs<'linkNfdAddress(string,uint64,address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'linkNfdAddress(string,uint64,address)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.nfdName, args.nfdAppId, args.addrToVerify],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the unlinkNfdAddress(string,uint64,address)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static unlinkNfdAddress(args: MethodArgs<'unlinkNfdAddress(string,uint64,address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'unlinkNfdAddress(string,uint64,address)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.nfdName, args.nfdAppId, args.addrToUnlink],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the ownershipAssign(string,uint64)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static ownershipAssign(args: MethodArgs<'ownershipAssign(string,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'ownershipAssign(string,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.nfdName, args.nfdAppId],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the ownershipChanged(string,uint64,address,address)void ABI method
   *
   * This method is triggered when the ownership of an NFD (Non-Fungible Domain) changes.
It is called by the NFD via the purchase method.  It can also be called by TxnLab admin for older 3.3
NFDs when it detects purchased events for 3.3
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static ownershipChanged(args: MethodArgs<'ownershipChanged(string,uint64,address,address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'ownershipChanged(string,uint64,address,address)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.nfdName, args.nfdAppId, args.seller, args.buyer],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the setAddressPrimaryNfd(string,uint64,address)void ABI method
   *
   * Makes the specified NFD the 'first' NFD in the reverse-address set so its the primary NFD for this address.
The NFD must be valid, and the sender must be the address (or nfd owner if vault).  The NFD wouldn't already be
in the reverse-lookup set if it wasn't already valid.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static setAddressPrimaryNfd(args: MethodArgs<'setAddressPrimaryNfd(string,uint64,address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'setAddressPrimaryNfd(string,uint64,address)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.nfdName, args.nfdAppId, args.addrBeingModified],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the upgradeNfd(string)string ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static upgradeNfd(args: MethodArgs<'upgradeNfd(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'upgradeNfd(string)string' as const,
      methodArgs: Array.isArray(args) ? args : [args.nfdName],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the isValidNfdAppId(string,uint64)bool ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static isValidNfdAppId(args: MethodArgs<'isValidNfdAppId(string,uint64)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'isValidNfdAppId(string,uint64)bool' as const,
      methodArgs: Array.isArray(args) ? args : [args.nfdName, args.nfdAppId],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getNameAppId(string)uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getNameAppId(args: MethodArgs<'getNameAppId(string)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getNameAppId(string)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.nfdName],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getAddressAppIds(address)uint64[] ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getAddressAppIds(args: MethodArgs<'getAddressAppIds(address)uint64[]'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getAddressAppIds(address)uint64[]' as const,
      methodArgs: Array.isArray(args) ? args : [args.lookupAddress],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the nfdContractInit(string,uint64,byte[])void ABI method
   *
   * Initializes the NFD contract bytecode into the registry
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static nfdContractInit(args: MethodArgs<'nfdContractInit(string,uint64,byte[])void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'nfdContractInit(string,uint64,byte[])void' as const,
      methodArgs: Array.isArray(args) ? args : [args.version, args.size, args.clearCode],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the nfdContractLoad(string,uint64,byte[])void ABI method
   *
   * Loads contract data into the  box at the specified offset.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static nfdContractLoad(args: MethodArgs<'nfdContractLoad(string,uint64,byte[])void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'nfdContractLoad(string,uint64,byte[])void' as const,
      methodArgs: Array.isArray(args) ? args : [args.version, args.offset, args.data],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the nfdContractCommit(string)void ABI method
   *
   * Commit a new version of the contract.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static nfdContractCommit(args: MethodArgs<'nfdContractCommit(string)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'nfdContractCommit(string)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.version],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the usdInMicroAlgo(uint64)uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static usdInMicroAlgo(args: MethodArgs<'usdInMicroAlgo(uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'usdInMicroAlgo(uint64)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.usdCost],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the costToAddToAddress(address)uint64 ABI method
   *
   * Returns the cost to add an NFD to the reverse-lookup data
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static costToAddToAddress(args: MethodArgs<'costToAddToAddress(address)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'costToAddToAddress(address)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.lookupAddress],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the calcFuturePrice(uint64,uint64)uint64 ABI method
   *
   * Calculates the future price based on the current price and the number of years.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static calcFuturePrice(args: MethodArgs<'calcFuturePrice(uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'calcFuturePrice(uint64,uint64)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.curPrice, args.forTime],
      ...params,
    }
  }
}

/**
 * A client to make calls to the NFDRegistry smart contract
 */
export class NfdRegistryClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient

  private readonly sender: SendTransactionFrom | undefined

  /**
   * Creates a new instance of `NfdRegistryClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender
    this.appClient = algokit.getAppClient({
      ...appDetails,
      app: APP_SPEC
    }, algod)
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn, TResult extends AppCallTransactionResult = AppCallTransactionResult>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> & TResult {
    if(result.return?.decodeError) {
      throw result.return.decodeError
    }
    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
      ? returnValueFormatter(result.return.returnValue)
      : result.return?.returnValue as TReturn | undefined
      return { ...result, return: returnValue } as AppCallTransactionResultOfType<TReturn> & TResult
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof NfdRegistry['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {
    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)
  }

  /**
   * Idempotently deploys the NFDRegistry smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(params: NfdRegistryDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(NfdRegistryCallFactory.create)
    const updateArgs = params.updateCall?.(NfdRegistryCallFactory.update)
    return this.appClient.deploy({
      ...params,
      updateArgs,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    })
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this
    return {
      /**
       * Creates a new instance of the NFDRegistry smart contract using the createApplication()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result
       */
      async createApplication(args: MethodArgs<'createApplication()void'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return $this.mapReturnValue<MethodReturn<'createApplication()void'>, AppCreateCallTransactionResult>(await $this.appClient.create(NfdRegistryCallFactory.create.createApplication(args, params)))
      },
    }
  }

  /**
   * Gets available update methods
   */
  public get update() {
    const $this = this
    return {
      /**
       * Updates an existing instance of the NFDRegistry smart contract using the updateApplication()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The update result
       */
      async updateApplication(args: MethodArgs<'updateApplication()void'>, params: AppClientCallCoreParams & AppClientCompilationParams = {}) {
        return $this.mapReturnValue<MethodReturn<'updateApplication()void'>, AppUpdateCallTransactionResult>(await $this.appClient.update(NfdRegistryCallFactory.update.updateApplication(args, params)))
      },
    }
  }

  /**
   * Makes a clear_state call to an existing instance of the NFDRegistry smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args)
  }

  /**
   * Calls the gas()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public gas(args: MethodArgs<'gas()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.gas(args, params))
  }

  /**
   * Calls the getPrice(string,address)(uint64,uint64,bool,bool,bool) ABI method.
   *
   * Returns the price for a given NFD (single year), the max # of years allowed (Name for Display),
and extra algo required to cover MBR when purchasing.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getPrice(args: MethodArgs<'getPrice(string,address)(uint64,uint64,bool,bool,bool)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.getPrice(args, params))
  }

  /**
   * Calls the getConstraints()(uint64,uint64,uint64,address,uint64,uint64,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getConstraints(args: MethodArgs<'getConstraints()(uint64,uint64,uint64,address,uint64,uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.getConstraints(args, params))
  }

  /**
   * Calls the getNfdMbrCost(string)uint64 ABI method.
   *
   * Returns the MBR amounts needed to MINT an nfd.
This value needs to be added to purchase price in mintNfd call.
getPrice() returns it though.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getNfdMbrCost(args: MethodArgs<'getNfdMbrCost(string)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.getNfdMbrCost(args, params))
  }

  /**
   * Calls the getNfdLinkOnMintExtraMbrCost(address)(uint64,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getNfdLinkOnMintExtraMbrCost(args: MethodArgs<'getNfdLinkOnMintExtraMbrCost(address)(uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.getNfdLinkOnMintExtraMbrCost(args, params))
  }

  /**
   * Calls the mintNfd(pay,string,address,bool)uint64 ABI method.
   *
   * Mint an NFD (NFT) and create a new NFD instance.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public mintNfd(args: MethodArgs<'mintNfd(pay,string,address,bool)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.mintNfd(args, params))
  }

  /**
   * Calls the linkNfdAddress(string,uint64,address)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public linkNfdAddress(args: MethodArgs<'linkNfdAddress(string,uint64,address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.linkNfdAddress(args, params))
  }

  /**
   * Calls the unlinkNfdAddress(string,uint64,address)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public unlinkNfdAddress(args: MethodArgs<'unlinkNfdAddress(string,uint64,address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.unlinkNfdAddress(args, params))
  }

  /**
   * Calls the ownershipAssign(string,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public ownershipAssign(args: MethodArgs<'ownershipAssign(string,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.ownershipAssign(args, params))
  }

  /**
   * Calls the ownershipChanged(string,uint64,address,address)void ABI method.
   *
   * This method is triggered when the ownership of an NFD (Non-Fungible Domain) changes.
It is called by the NFD via the purchase method.  It can also be called by TxnLab admin for older 3.3
NFDs when it detects purchased events for 3.3
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public ownershipChanged(args: MethodArgs<'ownershipChanged(string,uint64,address,address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.ownershipChanged(args, params))
  }

  /**
   * Calls the setAddressPrimaryNfd(string,uint64,address)void ABI method.
   *
   * Makes the specified NFD the 'first' NFD in the reverse-address set so its the primary NFD for this address.
The NFD must be valid, and the sender must be the address (or nfd owner if vault).  The NFD wouldn't already be
in the reverse-lookup set if it wasn't already valid.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public setAddressPrimaryNfd(args: MethodArgs<'setAddressPrimaryNfd(string,uint64,address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.setAddressPrimaryNfd(args, params))
  }

  /**
   * Calls the upgradeNfd(string)string ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public upgradeNfd(args: MethodArgs<'upgradeNfd(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.upgradeNfd(args, params))
  }

  /**
   * Calls the isValidNfdAppId(string,uint64)bool ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public isValidNfdAppId(args: MethodArgs<'isValidNfdAppId(string,uint64)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.isValidNfdAppId(args, params))
  }

  /**
   * Calls the getNameAppId(string)uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getNameAppId(args: MethodArgs<'getNameAppId(string)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.getNameAppId(args, params))
  }

  /**
   * Calls the getAddressAppIds(address)uint64[] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getAddressAppIds(args: MethodArgs<'getAddressAppIds(address)uint64[]'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.getAddressAppIds(args, params))
  }

  /**
   * Calls the nfdContractInit(string,uint64,byte[])void ABI method.
   *
   * Initializes the NFD contract bytecode into the registry
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public nfdContractInit(args: MethodArgs<'nfdContractInit(string,uint64,byte[])void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.nfdContractInit(args, params))
  }

  /**
   * Calls the nfdContractLoad(string,uint64,byte[])void ABI method.
   *
   * Loads contract data into the  box at the specified offset.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public nfdContractLoad(args: MethodArgs<'nfdContractLoad(string,uint64,byte[])void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.nfdContractLoad(args, params))
  }

  /**
   * Calls the nfdContractCommit(string)void ABI method.
   *
   * Commit a new version of the contract.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public nfdContractCommit(args: MethodArgs<'nfdContractCommit(string)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.nfdContractCommit(args, params))
  }

  /**
   * Calls the usdInMicroAlgo(uint64)uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public usdInMicroAlgo(args: MethodArgs<'usdInMicroAlgo(uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.usdInMicroAlgo(args, params))
  }

  /**
   * Calls the costToAddToAddress(address)uint64 ABI method.
   *
   * Returns the cost to add an NFD to the reverse-lookup data
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public costToAddToAddress(args: MethodArgs<'costToAddToAddress(address)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.costToAddToAddress(args, params))
  }

  /**
   * Calls the calcFuturePrice(uint64,uint64)uint64 ABI method.
   *
   * Calculates the future price based on the current price and the number of years.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public calcFuturePrice(args: MethodArgs<'calcFuturePrice(uint64,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(NfdRegistryCallFactory.calcFuturePrice(args, params))
  }

  public compose(): NfdRegistryComposer {
    const client = this
    const atc = new AtomicTransactionComposer()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: any) => any)> = []
    return {
      gas(args: MethodArgs<'gas()void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.gas(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getPrice(args: MethodArgs<'getPrice(string,address)(uint64,uint64,bool,bool,bool)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getPrice(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getConstraints(args: MethodArgs<'getConstraints()(uint64,uint64,uint64,address,uint64,uint64,uint64)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getConstraints(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getNfdMbrCost(args: MethodArgs<'getNfdMbrCost(string)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getNfdMbrCost(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getNfdLinkOnMintExtraMbrCost(args: MethodArgs<'getNfdLinkOnMintExtraMbrCost(address)(uint64,uint64)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getNfdLinkOnMintExtraMbrCost(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      mintNfd(args: MethodArgs<'mintNfd(pay,string,address,bool)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.mintNfd(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      linkNfdAddress(args: MethodArgs<'linkNfdAddress(string,uint64,address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.linkNfdAddress(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      unlinkNfdAddress(args: MethodArgs<'unlinkNfdAddress(string,uint64,address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.unlinkNfdAddress(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      ownershipAssign(args: MethodArgs<'ownershipAssign(string,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.ownershipAssign(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      ownershipChanged(args: MethodArgs<'ownershipChanged(string,uint64,address,address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.ownershipChanged(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      setAddressPrimaryNfd(args: MethodArgs<'setAddressPrimaryNfd(string,uint64,address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.setAddressPrimaryNfd(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      upgradeNfd(args: MethodArgs<'upgradeNfd(string)string'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.upgradeNfd(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      isValidNfdAppId(args: MethodArgs<'isValidNfdAppId(string,uint64)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.isValidNfdAppId(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getNameAppId(args: MethodArgs<'getNameAppId(string)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getNameAppId(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getAddressAppIds(args: MethodArgs<'getAddressAppIds(address)uint64[]'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getAddressAppIds(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      nfdContractInit(args: MethodArgs<'nfdContractInit(string,uint64,byte[])void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.nfdContractInit(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      nfdContractLoad(args: MethodArgs<'nfdContractLoad(string,uint64,byte[])void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.nfdContractLoad(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      nfdContractCommit(args: MethodArgs<'nfdContractCommit(string)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.nfdContractCommit(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      usdInMicroAlgo(args: MethodArgs<'usdInMicroAlgo(uint64)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.usdInMicroAlgo(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      costToAddToAddress(args: MethodArgs<'costToAddToAddress(address)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.costToAddToAddress(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      calcFuturePrice(args: MethodArgs<'calcFuturePrice(uint64,uint64)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.calcFuturePrice(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      get update() {
        const $this = this
        return {
          updateApplication(args: MethodArgs<'updateApplication()void'>, params?: AppClientComposeCallCoreParams & AppClientCompilationParams) {
            promiseChain = promiseChain.then(() => client.update.updateApplication(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
            resultMappers.push(undefined)
            return $this
          },
        }
      },
      clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {
        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))
        return this
      },
      async atc() {
        await promiseChain
        return atc
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await atc.simulate(client.algod, new modelsv2.SimulateRequest({ txnGroups: [], ...options }))
        return {
          ...result,
          returns: result.methodResults?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      },
      async execute(sendParams?: AppClientComposeExecuteParams) {
        await promiseChain
        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams }, client.algod)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      }
    } as unknown as NfdRegistryComposer
  }
}
export type NfdRegistryComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the gas()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  gas(args: MethodArgs<'gas()void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'gas()void'>]>

  /**
   * Calls the getPrice(string,address)(uint64,uint64,bool,bool,bool) ABI method.
   *
   * Returns the price for a given NFD (single year), the max # of years allowed (Name for Display),
and extra algo required to cover MBR when purchasing.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getPrice(args: MethodArgs<'getPrice(string,address)(uint64,uint64,bool,bool,bool)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'getPrice(string,address)(uint64,uint64,bool,bool,bool)'>]>

  /**
   * Calls the getConstraints()(uint64,uint64,uint64,address,uint64,uint64,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getConstraints(args: MethodArgs<'getConstraints()(uint64,uint64,uint64,address,uint64,uint64,uint64)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'getConstraints()(uint64,uint64,uint64,address,uint64,uint64,uint64)'>]>

  /**
   * Calls the getNfdMbrCost(string)uint64 ABI method.
   *
   * Returns the MBR amounts needed to MINT an nfd.
This value needs to be added to purchase price in mintNfd call.
getPrice() returns it though.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getNfdMbrCost(args: MethodArgs<'getNfdMbrCost(string)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'getNfdMbrCost(string)uint64'>]>

  /**
   * Calls the getNfdLinkOnMintExtraMbrCost(address)(uint64,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getNfdLinkOnMintExtraMbrCost(args: MethodArgs<'getNfdLinkOnMintExtraMbrCost(address)(uint64,uint64)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'getNfdLinkOnMintExtraMbrCost(address)(uint64,uint64)'>]>

  /**
   * Calls the mintNfd(pay,string,address,bool)uint64 ABI method.
   *
   * Mint an NFD (NFT) and create a new NFD instance.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  mintNfd(args: MethodArgs<'mintNfd(pay,string,address,bool)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'mintNfd(pay,string,address,bool)uint64'>]>

  /**
   * Calls the linkNfdAddress(string,uint64,address)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  linkNfdAddress(args: MethodArgs<'linkNfdAddress(string,uint64,address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'linkNfdAddress(string,uint64,address)void'>]>

  /**
   * Calls the unlinkNfdAddress(string,uint64,address)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  unlinkNfdAddress(args: MethodArgs<'unlinkNfdAddress(string,uint64,address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'unlinkNfdAddress(string,uint64,address)void'>]>

  /**
   * Calls the ownershipAssign(string,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  ownershipAssign(args: MethodArgs<'ownershipAssign(string,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'ownershipAssign(string,uint64)void'>]>

  /**
   * Calls the ownershipChanged(string,uint64,address,address)void ABI method.
   *
   * This method is triggered when the ownership of an NFD (Non-Fungible Domain) changes.
It is called by the NFD via the purchase method.  It can also be called by TxnLab admin for older 3.3
NFDs when it detects purchased events for 3.3
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  ownershipChanged(args: MethodArgs<'ownershipChanged(string,uint64,address,address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'ownershipChanged(string,uint64,address,address)void'>]>

  /**
   * Calls the setAddressPrimaryNfd(string,uint64,address)void ABI method.
   *
   * Makes the specified NFD the 'first' NFD in the reverse-address set so its the primary NFD for this address.
The NFD must be valid, and the sender must be the address (or nfd owner if vault).  The NFD wouldn't already be
in the reverse-lookup set if it wasn't already valid.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setAddressPrimaryNfd(args: MethodArgs<'setAddressPrimaryNfd(string,uint64,address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'setAddressPrimaryNfd(string,uint64,address)void'>]>

  /**
   * Calls the upgradeNfd(string)string ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  upgradeNfd(args: MethodArgs<'upgradeNfd(string)string'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'upgradeNfd(string)string'>]>

  /**
   * Calls the isValidNfdAppId(string,uint64)bool ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  isValidNfdAppId(args: MethodArgs<'isValidNfdAppId(string,uint64)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'isValidNfdAppId(string,uint64)bool'>]>

  /**
   * Calls the getNameAppId(string)uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getNameAppId(args: MethodArgs<'getNameAppId(string)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'getNameAppId(string)uint64'>]>

  /**
   * Calls the getAddressAppIds(address)uint64[] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getAddressAppIds(args: MethodArgs<'getAddressAppIds(address)uint64[]'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'getAddressAppIds(address)uint64[]'>]>

  /**
   * Calls the nfdContractInit(string,uint64,byte[])void ABI method.
   *
   * Initializes the NFD contract bytecode into the registry
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  nfdContractInit(args: MethodArgs<'nfdContractInit(string,uint64,byte[])void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'nfdContractInit(string,uint64,byte[])void'>]>

  /**
   * Calls the nfdContractLoad(string,uint64,byte[])void ABI method.
   *
   * Loads contract data into the  box at the specified offset.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  nfdContractLoad(args: MethodArgs<'nfdContractLoad(string,uint64,byte[])void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'nfdContractLoad(string,uint64,byte[])void'>]>

  /**
   * Calls the nfdContractCommit(string)void ABI method.
   *
   * Commit a new version of the contract.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  nfdContractCommit(args: MethodArgs<'nfdContractCommit(string)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'nfdContractCommit(string)void'>]>

  /**
   * Calls the usdInMicroAlgo(uint64)uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  usdInMicroAlgo(args: MethodArgs<'usdInMicroAlgo(uint64)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'usdInMicroAlgo(uint64)uint64'>]>

  /**
   * Calls the costToAddToAddress(address)uint64 ABI method.
   *
   * Returns the cost to add an NFD to the reverse-lookup data
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  costToAddToAddress(args: MethodArgs<'costToAddToAddress(address)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'costToAddToAddress(address)uint64'>]>

  /**
   * Calls the calcFuturePrice(uint64,uint64)uint64 ABI method.
   *
   * Calculates the future price based on the current price and the number of years.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  calcFuturePrice(args: MethodArgs<'calcFuturePrice(uint64,uint64)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, MethodReturn<'calcFuturePrice(uint64,uint64)uint64'>]>

  /**
   * Gets available update methods
   */
  readonly update: {
    /**
     * Updates an existing instance of the NFDRegistry smart contract using the updateApplication()void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    updateApplication(args: MethodArgs<'updateApplication()void'>, params?: AppClientComposeCallCoreParams & AppClientCompilationParams): NfdRegistryComposer<[...TReturns, MethodReturn<'updateApplication()void'>]>
  }

  /**
   * Makes a clear_state call to an existing instance of the NFDRegistry smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs): NfdRegistryComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): NfdRegistryComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(options?: SimulateOptions): Promise<NfdRegistryComposerSimulateResult<TReturns>>
  /**
   * Executes the transaction group and returns the results
   */
  execute(sendParams?: AppClientComposeExecuteParams): Promise<NfdRegistryComposerResults<TReturns>>
}
export type SimulateOptions = Omit<ConstructorParameters<typeof modelsv2.SimulateRequest>[0], 'txnGroups'>
export type NfdRegistryComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns
  methodResults: ABIResult[]
  simulateResponse: modelsv2.SimulateResponse
}
export type NfdRegistryComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns
  groupId: string
  txIds: string[]
  transactions: Transaction[]
}
